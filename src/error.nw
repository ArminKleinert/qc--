
% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml

% ------------------------------------------------------------------  
\section{Error Handling}
% ------------------------------------------------------------------ 

The idea is not to stop in all cases after an error but to mark
results as either good or bad.  Bad values can be used for further
computation although the overall result will be bad.  The hope is, to
detect even more errors that are \textit{not} caused by any previous
error.  Details of this idea and the following implementation can be
found in \textit{Eliminating Spurious Error Messages Using Exceptions,
Polymorphism and Higher-Order Functions} \cite{ramsey:99:compj}.

Technically results are wrapped in an [['a error]] type; good results
are represented by the [[Ok]] constructor, bad results by [[Error]]. 
A set of combinators helps to deal with this type of values.

% ------------------------------------------------------------------  
\subsection{Interface}
% ------------------------------------------------------------------  

<<error.mli>>=
type 'a error       = Error                     (* bad result  *)
                    | Ok        of 'a           (* good result *)
@

At some point in a program the processing is finally aborted by
raising an exception.  We expect to find most errors while checking
the static semantics of a \C~program.  However, the way the abstract
syntax is organized the location information is usually \textit{not}
available where the exception is raised but where it is caught. 
Because of this we do not attach any informations about the origin of
an error to an exception. 

<<error.mli>>=
type pretty         = string                    (* for the moment *)

exception ErrorExn  of pretty
val error :         pretty -> 'a
@

Combinators to deal with functions that do not naturally expect 
values of type [[error]].

<<error.mli>>=
val combine     : 'a error error -> 'a error
val emap        : ('a -> 'b) -> 'a error -> 'b error
val sequence    : ('a -> 'b error) -> 'a error -> 'b error
@

Raising combinators raise the constructors of an [[error]] value
inside a complex value to the top-level.  A complex value is bad when
one of its components is bad and good otherwise.  The raising
combinators deal with the most important data types:  options, lists,
and tuples.

<<error.mli>>=
module Raise :
  sig
    val option : 'a error option                -> 'a option error
    val list   : 'a error list                  -> 'a list error
    val pair   : 'a error * 'b error            -> ('a * 'b) error
@

The [[left]] and [[right]] functions consider only one component of
a pair when raising the constructor.

<<error.mli>>=
    val left   : 'a error * 'b                  -> ('a * 'b) error
    val right  : 'a * 'b error                  -> ('a * 'b) error
    
    val triple : 'a error * 'b error * 'c error -> ('a * 'b * 'c) error
    val quad   : 'a error * 'b error * 'c error * 'd error 
                  -> ('a * 'b * 'c * 'd) error
  end
@

Lowering functions take a complex [[error]] value and push the
constructor from the top-level to the values inside the [[error]]
value. 

<<error.mli>>=
module Lower :
  sig
    val pair   : ('a * 'b)           error -> 'a error * 'b error
    val triple : ('a * 'b * 'c)      error -> 'a error * 'b error * 'c error
    val quad   : ('a * 'b * 'c * 'd) error -> 'a error 
                                            * 'b error 
                                            * 'c error 
                                            * 'd error
  end
@ 

The functions of the [[Implode]] module destroy informations by
reducing complex [['a error] values to [[unit error]]. They come in
handy when are there are only good and bad results. Whenever an
any argument of a function contains an [[Error]] value the outcome is
[[Error]] and [[Ok()]] otherwise. 

The [[list]] function is similar to [[Raise.list]] as is raises the
[[error]] type to the top level.  The [[map]] function is greedy:  it
does not stop when it encounters the first [[Error]] but traverses the
whole list.  The motivation is to give detect possible bad values in
the list such that the [[ErrorExn]] can be raised for them. 

<<>>=
module Implode :
  sig
    val singleton : 'a error                                  -> unit error
    val pair :      'a error * 'b error                       -> unit error
    val triple :    'a error * 'b error * 'c error            -> unit error
    val quad :      'a error * 'b error * 'c error * 'd error -> unit error
    val list :      'a error list                             -> unit error
    val map :       ('a -> 'b error) -> 'a list               -> unit error
  end
@

At the point where an error occurs the first time the [[ErrorExn]]
is raised.  When the exception is caught is is turned into an
[[Error]] value and from there on the [[Error]] value is propagated. 
Catching the exception is done with [[catch]] in the special case, and
[[catch']] in the general case.  [[catch']] permits to specify the
value that is returned when an exception is caught whereas [[catch]]
always uses [[Error]] for this.

<<>>=
val catch   :       (pretty -> unit) 
                    -> ('a -> 'b error) -> 'a -> 'b error
val catch'  : 'b -> (pretty -> unit) 
                    -> ('a -> 'b      ) -> 'a -> 'b 
@

The first argument in [[catch printer f x]] is an error reporting
function; [[f]] is applied to [[x]] and in case of an error [[Error]]
is returned. The first argument to [[catch']] is the value to return
in case of an error.

The [[warningPrt]] and [[errorPrt]] functions can be passed to
[[catch]] and [[catch']] as error printing functions. However, in most
cases specialized functions for error reporting will be used to include
some source code locations.

<<>>=
val warningPrt : pretty -> unit
val errorPrt   : pretty -> unit
@

The following error reporting functions take a location as their first
argument.  Typically the location is supplied to the function like in
[[errorPointPrt point]] and the resulting closure is passed to
[[catch]].  This works because the error locations are attached where
exceptions are caught and not where they are raised.

<<>>=
val errorPointPrt : Srcmap.point -> string -> unit
val errorRegionPrt : Srcmap.region -> string -> unit
val errorPosPrt : Srcmap.pos -> string -> unit
val errorRegPrt : Srcmap.reg -> string -> unit
@

% ------------------------------------------------------------------  
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<error.ml>>=
type 'a error       = Error                     (* bad result  *)
                    | Ok        of 'a           (* good result *)

type pretty         = string                    (* for the moment *)

exception ErrorExn  of    pretty

<<>>=
let combine = function  
    | Ok x      -> x
    | Error     -> Error

<<>>=
let emap f = function
    | Ok x      -> Ok (f x)
    | Error     -> Error

<<>>=
let sequence f = function
    | Ok x      -> f x
    | Error     -> Error
@

Raising combinators raise the constructors of an [[error]] value inside
a complex value to the top-level. A complex value is bad when one
of its components is bad and good otherwise. The raising combinators
deal with the most important data types: options, lists, and tuples.

<<error.ml>>=    
module Raise = struct
    <<raise module>>
end
@
<<raise module>>=
let option = function
    | Some Error        -> Error
    | Some (Ok x)       -> Ok (Some x)
    | None              -> Ok (None)
<<>>=
let list xs =
    let rec loop acc = function
        | []            -> Ok (List.rev acc)
        | (Ok x)::xs    -> loop (x::acc) xs
        | Error::xs     -> Error 
    in      
        loop [] xs

<<>>=
let pair = function
    | (Ok x, Ok y)          -> Ok (x,y)
    | _                     -> Error
        
<<>>=
let left = function
    | (Ok x, y)             -> Ok (x,y)
    | _                     -> Error

<<>>=
let right = function
    | (x, Ok y)             -> Ok (x,y)
    | _                     -> Error

<<>>=
let triple = function
    | (Ok x, Ok y, Ok z)    -> Ok (x,y,z)
    | _                     -> Error 

<<>>=
let quad = function
    | (Ok a,Ok b,Ok c,Ok d) -> Ok (a,b,c,d)
    | _                     -> Error
@

Lowering functions take a complex [[error]] value and push the
constructor from the top-level to the values inside the [[error]]
value. 

<<error.ml>>=
module Lower = struct
    <<lower module>>
end
@

<<lower module>>=
let pair = function
    | Ok (x,y)              -> Ok x , Ok y
    | Error                 -> Error, Error 
<<>>=
let triple = function
    | Ok (x,y,z)            -> Ok x , Ok y , Ok z
    | Error                 -> Error, Error, Error
<<>>=
let quad = function
    | Ok (a,b,c,d)          -> Ok a , Ok b , Ok c , Ok d
    | Error                 -> Error, Error, Error, Error
@ 

Sometimes it is sufficient to distinguish between good and bad
values. Any complex value that has a bad value in it is itself bad.
The [[Implode]] module reduces everything to [[unit Error]] values
which means it (carefully) destroys informations.

<<error.ml>>=
module Implode = struct
    <<implode module>>
end

<<implode module>>=
let singleton = function
    | Ok _ -> Ok ()
    | _    -> Error

<<>>=
let pair = function
    | Ok _, Ok _ -> Ok ()
    | _          -> Error

<<>>=
let triple = function
    | Ok _, Ok _, Ok _ -> Ok ()
    | _                -> Error

<<>>=
let quad = function
    | Ok _, Ok _, Ok _, Ok _ -> Ok ()
    | _                      -> Error

<<>>=
let rec list = function
    | []            -> Ok ()
    | (Ok _)::xs    -> list xs
    | _             -> Error 

<<>>=
let map f l =
    let ok = Ok () in
    let rec loop res = function
        | []    -> res
        | x::xs -> ( match res, f x with
                   | Error, _     -> loop Error xs 
                   |    _ , Error -> loop Error xs
                   | _            -> loop ok    xs
                   )
    in
        loop ok l 
@

We provide functions to raise the error ([[ErrorExn]]) exception and
issue warnings.

<<error.ml>>=
let catch' default printer f arg =
    try f arg with
    | ErrorExn(msg) -> ( printer msg 
                       ; default
                       )
<<>>=    
let catch printer f arg = catch' Error printer f arg
let error msg           = raise (ErrorExn msg)
<<>>=
let warningPrt msg = 
    ( prerr_string "Warning: "
    ; prerr_string msg
    ; prerr_newline ()
    ) 
<<>>=
let errorPrt msg = 
    ( prerr_string "Error: "
    ; prerr_string msg
    ; prerr_newline ()
    )
<<>>=
let errorPointPrt  p msg = 
    ( Printf.eprintf "%s " (Srcmap.Str.point p)
    ; errorPrt msg
    )
<<>>=    
let errorRegionPrt r msg =
    ( Printf.eprintf "%s " (Srcmap.Str.region r)
    ; errorPrt msg
    )
<<>>=    
let errorPosPrt    p msg =
    ( Printf.eprintf "Character %d " p
    ; errorPrt msg
    )
<<>>=
let errorRegPrt (l,r) msg = 
    ( Printf.eprintf "Character %d-%d " l r
    ; errorPrt msg
    )
@


