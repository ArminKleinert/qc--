
% ------------------------------------------------------------------ 
\section{Checking Static Semantics}
% ------------------------------------------------------------------ 

Checking the static semantics of a {\PAL} program is a multi-step
approach:  a program declares symbols in the global scope (made up by
the toplevel and its sections) and in local scopes made up by
individual procedures.  Because symbols in {\PAL} are visible inside
their scope before there declaration, checking a scope requires the
following steps:

\begin{enumerate}
\item All type declarations of the current scope are collected. They
      are topologically sorted with respect to the use of each other and
      entered into the type environment.

\item All constant declarations are collected, topologically sorted
      and processed. Processing includes inferring their types and
      evaluating them. The values and types found are then entered into
      the value environment.

\item Now the environment in complete to check the static semantics of
      the current section or procedure. This involves checking the types
      and all the orher constraints defined by the static semantics.
\end{enumerate}

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<check.ml>>=
module T = Types
module E = Error
module A = Ast
module F = Fatenv

(* f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a *)
let foldl = List.fold_left
@

The remove offending declarations from a list we use [[exclude]]: 
[[exclude xx yy]] returns [[xx]] without elements found in [[yy]]. 
Since we expect [[yy]] to be very short (1 to 3 elements) we have
chosen a naive approach for implementation.
 
<<>>=
let exclude xx yy = 
    let _, xx' = List.partition (fun x  -> List.mem x yy) xx  in
    xx'
@

Types in the abstract syntax may be names and must be evaluated before
they can be used. The evaluation can fail in case the name is
undefined and therefore an [[E.error]] type is used.

<<>>=
let rec evalTy env = function
    | A.TyAt(x,r)    -> E.catch (E.errorRegPrt r) (evalTy env) x
    | A.BitsTy(size) -> E.Ok(Types.Bits size)
    | A.AliasTy(n)   -> snd (F.findt n env)

<<building the type environment>>
<<building the value environment>>

<<check file>>
@

% ------------------------------------------------------------------ 
\subsection{Building the type environment}
% ------------------------------------------------------------------ 

The [[TSort.sort]] function knows very few things about (type)
declarations: it can ask for the names a declaration [[defines]], and
the declared names it [[uses]]. For error reporting declarations are
enriched with optional source coude positions.

<<module TT>>=
type decl = A.decl * A.region option

let rec defines = function
    | A.DeclAt(d,r)      , _   -> defines (d,Some r)
    | A.Typedef(t,names) , _   -> names
    | _                  , _   -> []
<<>>=
let rec uses = function     
    | A.DeclAt(d,r)                 , _   -> uses (d,Some r)
    | A.Typedef(A.BitsTy(_),names)  , _   -> []
    | A.Typedef(A.AliasTy(x),names) , _   -> [x]
    | _                             , _   -> []
@

To build the global type environment global type declarations must be
collected. Type declarations ([[typedef]]) on the top-level and the
section-level are global; [[foldGlobalTypeDecls]] collects them from
the abstract syntax.

<<building the type environment>>=
module TypeEnv = struct
    module TT = struct
        <<module TT>>
    end
    module TSort = Topsort.Make(TT)
    
    <<build type env>>
end
@

% ------------------------------------------------------------------ 
\subsection{Collecting Type Declarations}
% ------------------------------------------------------------------ 
        
<<build type env>>=
let rec body r dd = function
    | A.BodyAt(x,r)     -> body (Some r) dd x
    | A.DeclBody(d)     -> decl r dd d
    | _                 -> dd
and decl r dd = function
    | A.DeclAt(x,r)     -> decl (Some r) dd x
    | A.Typedef(_) as d -> (d,r)::dd
    | _                 -> dd
and stmt r dd = function
    | A.StmtAt(x,r)     -> stmt (Some r) dd x
    | A.SpanStmt(_,_,bb)-> foldl (body r) dd bb
    | _                 -> dd

<<>>=
let rec section r dd = function
    | A.SectionAt(x,r)         -> section (Some r) dd x 
    | A.Decl(d)                -> decl r dd d 
    | A.SSpan( e1, e2, ss)     -> foldl (section r) dd ss
    | A.Datum( d)              -> dd
    | A.Procedure(p)           -> dd 
<<>>=    
let rec toplevel r dd = function
    | A.ToplevelAt(x,r)   -> toplevel (Some r) dd x
    | A.Section(_, ss)    -> foldl (section r) dd ss
    | A.TopDecl (d)       -> decl r dd d
    | _                   -> dd
<<>>=
let foldGlobalTypeDecls program =
    foldl (toplevel None) [] program
<<>>=
let foldLocalTypeDecls b =
    foldl (body None) [] b
@

% ------------------------------------------------------------------ 
\subsubsection{Processing type declarations}
% ------------------------------------------------------------------ 

After the global type declarations have been collected they are sorted
topologically to get the right order to process them.  Sorting can
fail when declarations happen to be circular; this is reported by an
exceptions.  In that case offending declarations are taken out and the
sorting is repeated. We end up with a fat environment in that binds
all global names for types.

Names defined by declarations found in cycles are bound to [[E.Error]]
in the (fat) environment.
<<>>=
let bindError scope env decls = 
    let names = List.concat (List.map TT.defines decls) in 
        foldl (fun env name -> F.bindtError name scope env) env names
@


<<>>=
let bindt names ty scope env =
    foldl (fun env n -> F.bindt n (scope,ty) env) env names

<<>>=
let rec doTypeDecl env = function
    | A.DeclAt(x,r)      -> E.catch' env (E.errorRegPrt r) (doTypeDecl env) x
    | A.Typedef(t,names) -> bindt names (evalTy env t) F.Global env
    | _                  -> env

<<>>=
let doTypeDecls env decls = foldl doTypeDecl env decls
@

When cycles are found in the list of declarations they are reported.
Their source code positions were attached to them during their
collection. 

<<>>=
let reportCycle decls = 
    let report = function
        | A.Typedef(t,n::nn), Some r -> 
            E.errorRegPrt r ("typedef for "^n^" is cyclic")
        | A.Typedef(t,n::nn), None   -> 
            E.errorPrt      ("typedef for "^n^" is cyclic")
        | _                     -> assert false
    in
        List.iter report decls      

<<>>=
let doTypes is_global env dd =
    let decls          = List.map fst                   in 
    let rec bindAll dd =
        try
            let dd' = TSort.sort dd                     in
            doTypeDecls env (decls dd')
        with TSort.Cycle(offending) ->
            let dd'   = exclude dd offending             in
            let scope = if is_global then F.Global 
                        else F.Local                     in
            let env'  = bindError scope env offending in
                ( reportCycle offending
                ; bindAll dd'
                )
                                                        in
        bindAll dd

let doGlobalTypes env program = doTypes true  env (foldGlobalTypeDecls program)
let doLocalTypes  env body    = doTypes false env (foldLocalTypeDecls body)
@

% ------------------------------------------------------------------ 
\subsection{Building the value environment}
% ------------------------------------------------------------------ 

The top-level scope of a compilation unit includes the top-level
itself and all sections.  Values declared on either level are visible
in the entire compilation unit.  Before the static semantics of a
program can be checked these global declarations must be bound in an
environment.  Additionally constant declarations are type checked and
evaluated.  The values for them are also bound in the environment,
too.

Except for constants all other values like labels, continuations, or
registers, are completely known at the place where they are defined or
declared.  Constants can refer to other constants and thus processing
them takes some care.  Like for type declarations constants must be
processed in a (topological) order such that less dependent
declarations are processed first. 

Conceptually all declarations and language constructs that create a
named value could be treated as a declaration -- most of them
depending on no other.  But to improve performance constant
declarations are treated separately because only they require a
topological sort.  We thus traverse the abstract syntax and bind all
non-constant values into the environment.  Then we collect all
constant declarations, sort and process them.  Because sorting fails
in the presence of cyclic declarations and must be re-done keeping the
list to be sorted small is advantageous.

<<building the value environment>>=
module ValueEnv = struct
    module TV = struct
        <<module TV>>
    end
    module TSort = Topsort.Make(TV)
   
    module BindGlobals = struct
        <<bind global values>>
    end

    module CollectConst = struct
        <<collecting const declarations>>
    end

    module EvalConst = struct
        <<processing const declarations>>
    end
end
@

% ------------------------------------------------------------------ 
\subsubsection{Preparing Constant Declarations for Sorting}
% ------------------------------------------------------------------  

Module [[T]] captures what is important to sort declarations:  A
declaration defines a name (multiple in general) and refers to other
names.  As said before we only sort constant declarations. 

<<module TV>>=
type decl = A.decl * A.region option

let rec defines = function
    | A.DeclAt(d,r)        , _   -> defines (d,Some r)
    | A.Const(t,name,expr) , _   -> [name]
    | _                    , _   -> []
@

A constant expression can refer to other constant and link-time
constants.  To find the right topological order it is only important
to find other constants.  Of course, these can be syntactically no be
distinguished and so we will collect all free variables of an
expression.  This leads to used names, that are not constants and that
appear to be defined from the perspective of the topological [[sort]]
function.  But [[sort]] assumes that these undeclared names do not
depend on any constant---which is correct.

<<>>=
let rec freeExprVars = function
    | A.ExprAt(x,r)     -> freeExprVars x
    | A.Fetch(lvalue)   -> freeLValueVars lvalue
    | A.BinOp(e1,_,e2)  -> (freeExprVars e1) @ (freeExprVars e2)
    | A.UnOp(_,e)       -> freeExprVars e
    | A.PrimOp(_,args)  -> 
        List.concat (List.map (fun (_,e) -> freeExprVars e) args)
    | _                 -> []
<<>>=
and freeLValueVars = function
    | A.LValueAt(x,r)   -> freeLValueVars x
    | A.Mem(_,e,_)      -> freeExprVars e
    | A.Var(name)       -> [name]
       
let rec uses = function
    | A.DeclAt(d,r)        , _   -> uses (d,Some r)
    | A.Const(t,name,expr) , _   -> freeExprVars expr
    | _                    , _   -> []
@
    
% ------------------------------------------------------------------ 
\subsubsection{Binding Value Symbols}
% ------------------------------------------------------------------ 

Global labels and procedures have fixed types that can be entered into
the environment. Register and Import declarations on the other hand
carry user provided types with them. In case these types are names
they may be undefined; this leads to register and import declarations which
are bound to [[Error]]. 

<<bind global values>>=
let proct     = (F.Global, E.Ok(F.Label(F.Proc),T.code))
let codet     = (F.Global, E.Ok(F.Label(F.Code),T.code))
let datat     = (F.Global, E.Ok(F.Label(F.Data),T.data))

<<>>=
let regt = function 
    | E.Ok(t) -> (F.Global, E.Ok(F.Register,t))
    | E.Error -> (F.Global, E.Error)
<<>>=
let importt = function 
    | E.Ok(t) -> (F.Global, E.Ok(F.Import,t))
    | E.Error -> (F.Global, E.Error)
<<>>=
let rec ty env = function
    | A.TyAt(x,r)       -> E.catch (E.errorRegPrt r) (ty env) x
    | A.BitsTy(n)       -> E.Ok(T.bits n)
    | A.AliasTy(n)      -> F.findt' n env
@

The following functions traverse the abstract syntax and enter all
names of global scope into the environment -- except for constants. 
In particular, these are:  all import, register, and procedure
declarations on the top-level and section-level.  Additionally all
label for code and data anywhere in the compilation unit because they
have global scope.

    
<<>>=
let import t env = function
    | Some foreign, name -> F.bindv name (importt (ty env t)) env
    | None        , name -> F.bindv name (importt (ty env t)) env
<<>>=
let target env = function
    | A.Memsize(i)        -> F.bindMemsize i env
    | A.ByteorderBig      -> F.bindendianness F.Big env
    | A.ByteorderLittle   -> F.bindendianness F.Little env 
    
<<>>=
let imports env t ii          = foldl (import t) env ii
let register env (_,t,name,_) = F.bindv name (regt (ty env t)) env

<<>>=
let rec datum env = function
    | A.DatumAt(x,r)        -> E.catch' env (E.errorRegPrt r) (datum env) x
    | A.Label(n)            -> F.bindv n codet env 
    | _                     -> env

<<>>=
let rec stmt env = function 
    | A.StmtAt(x,r)           -> E.catch' env (E.errorRegPrt r) (stmt env) x
    | A.IfStmt ( e, ss1, ss2) -> foldl stmt (foldl stmt env ss1) ss2
    | A.LabelStmt(n)          -> F.bindv n codet env
    | A.SpanStmt(e1,e2,ss)    -> foldl (body false) env ss
    | A.SwitchStmt (r,e,arms) -> foldl arm  env arms
    | _                       -> env

and arm env = function
    | A.ArmAt(x,r)            -> E.catch' env (E.errorRegPrt r) (arm env) x
    | A.Case(ranges, ss)      -> foldl stmt env ss
<<>>=
and decl is_global env = function
    | A.DeclAt(x,r)    -> E.catch' env (E.errorRegPrt r) (decl is_global env) x
    | A.Import(ty,ii)  -> if is_global then imports env ty ii     else env
    | A.Registers(rr)  -> if is_global then foldl register env rr else env
    | A.Target(aa)     -> if is_global then foldl target env aa   else env
    | _                -> env

and body is_global env = function
    | A.BodyAt(x, r) -> E.catch' env (E.errorRegPrt r) (body is_global env) x
    | A.DeclBody(d)  -> if is_global then decl is_global env d else env
    | A.DataBody(dd) -> if is_global then foldl datum env dd   else env 
    | A.StmtBody(s)  -> stmt env s
<<>>=       
let proc is_global env (_,name,_,bb) = 
    let env' = F.bindv name proct env in
        foldl (body is_global) env bb
<<>>=
let rec section env = function
    | A.SectionAt(x,r)     -> E.catch' env (E.errorRegPrt r) (section env) x
    | A.Decl(d)            -> decl true env d
    | A.SSpan( e1, e2, ss) -> foldl section env ss
    | A.Datum( d)          -> datum env d
    | A.Procedure(p)       -> proc true env p

<<>>=
let rec toplevel env = function 
    | A.ToplevelAt(x, r)  -> E.catch' env (E.errorRegPrt r) (toplevel env) x
    | A.Section(name, ss) -> foldl section env ss
    | A.TopDecl(d)        -> decl true env d
    | A.TopProcedure(p)   -> proc true env p 

<<>>=
let program env tt = foldl toplevel env tt
@ 

% ------------------------------------------------------------------ 
\subsection{Collecting constant declarations}
% ------------------------------------------------------------------ 

Constant declarations are a bit special because every declaration's
type and value can depend on other declarations. They thus must be
topologically sorted before their types and values can be computed.

<<collecting const declarations>>=
let rec body r dd = function
    | A.BodyAt(x,r)     -> body (Some r) dd x
    | A.DeclBody(d)     -> decl r dd d
    | _                 -> dd
and decl r dd = function
    | A.DeclAt(x,r)     -> decl (Some r) dd x
    | A.Const(_) as d   -> (d,r)::dd
    | _                 -> dd
and stmt r dd = function
    | A.StmtAt(x,r)     -> stmt (Some r) dd x
    | A.SpanStmt(_,_,bb)-> foldl (body r) dd bb
    | _                 -> dd

<<>>=
let rec section r dd = function
    | A.SectionAt(x,r)         -> section (Some r) dd x 
    | A.Decl(d)                -> decl r dd d 
    | A.SSpan( e1, e2, ss)     -> foldl (section r) dd ss
    | A.Datum( d)              -> dd
    | A.Procedure(p)           -> dd 
<<>>=    
let rec toplevel r dd = function
    | A.ToplevelAt(x,r)   -> toplevel (Some r) dd x
    | A.Section(_, ss)    -> foldl (section r) dd ss
    | A.TopDecl (d)       -> decl r dd d
    | _                   -> dd
<<>>=
let foldGlobalConstDecls program =
    foldl (toplevel None) [] program
<<>>=
let foldLocalConstDecls b =
    foldl (body None) [] b
@

% ------------------------------------------------------------------ 
\subsection{Evaluating constant declarations}
% ------------------------------------------------------------------ 

Constant declarations must be sorted topoligically before they can be
processed. Processing includes checking their types and evaluating
their values. Bot type and value are bound in the environment.

Processing a constant declaration means to

\begin{enumerate}
\item infer its type and compare it an optionally supplied type that
      is part of it declaration,
\item evaluate it to its value,
\item bind the value and the type in the environment.
\end{enumerate}

The topological sorting guarantees that every named value a constant
declaration depends on is already processed and the name is bound in
the environment.  The following functions type check and evaluate
constants in a single step.  Each function returns a pair of a type
and a value.
 
<<processing const declarations>>=
@

<<>>=
let rec evalFetch env = function
    | A.LValueAt(x,r) -> E.catch (E.errorRegPrt r) (evalFetch env) x
    | A.Mem (_,_,_)   -> E.error "memory access in const declaration"
    | A.Var(id)       -> ( match F.findv' id env with
                         | E.Error                -> E.Error
                         | E.Ok(F.Constant(v),ty) -> E.Ok(ty, v)
                         | _ -> E.error ("access of non-constant "^id)
                         ) 
@
<<>>=
let rec evalPrimOp' op env args =
    let f, t   = Const.Symbol.lookup op Const.constOps in
    let at,av  = List.split args                       in
    let unused = Types.bool                            in
    let sigma  = ( try Types.unify t (Types.proc at unused) Types.empty with
                 | Types.UnifyExn -> E.error "type mismatch"
                 )                                     in
    let rt     = ( match Types.subst sigma t with
                 | Types.Procedure(_,t) -> t
                 | _                    -> assert false
                 )                                     in
        rt, f av
<<>>=
and evalPrimOp env op args =
    E.emap (evalPrimOp' op env) (evalExprs env args)

<<>>=
and evalExprs env ee =
    let rec loop env acc = function
        | []    -> E.Ok(acc)
        | e::ee -> ( match evalExpr env e with
                   | E.Ok(t, v) -> loop env ((t,v)::acc) ee
                   | E.Error    -> E.Error
                   )
    in
        loop env [] ee

<<>>=
and evalExpr env = function
| A.ExprAt(x,r) -> E.catch (E.errorRegPrt r) (evalExpr env) x
| A.Int (str,(Some size as s))   -> E.Ok(T.bits size, Const.int2value str s)
| A.Int (str,(None      as s))   -> E.Ok(T.word     , Const.int2value str s)
| A.Float (str,(Some size as s)) -> E.Ok(T.bits size, Const.float2value str s)
| A.Float (str,(None      as s)) -> E.Ok(T.word     , Const.float2value str s)
| A.Char (str,(Some size as s))  -> E.Ok(T.bits size, Const.char2value str s)
| A.Char (str,(None      as s))  -> E.Ok(T.word     , Const.char2value str s)
| A.Fetch(v)                     -> evalFetch env v
| A.BinOp(l,op,r)                -> evalPrimOp env op [l;r]
| A.UnOp(op,expr)                -> evalPrimOp env op [expr]
| A.PrimOp(op,args)              -> evalPrimOp env op (List.map snd args)

<<>>=
let doConstDecl scope env = function
    | A.Const(Some t', name, expr) -> 
        ( match evalExpr env expr, evalTy env t' with 
        | E.Ok(t,v),E.Ok(t') when t =t'  -> 
            F.bindv name (scope,E.Ok(F.Constant(v),t)) env
        | E.Ok(t,v),E.Ok(t') when t<>t'  ->
            ( E.errorPrt ("type declared for constant "^name^" does not match actual type")
            ; F.bindvError name scope env
            )
        | _ -> F.bindvError name scope env
        )
    | A.Const(None, name, expr) ->
        ( match evalExpr env expr with
        | E.Ok(t,v) -> F.bindv name (scope,E.Ok(F.Constant(v),t)) env
        | _         -> F.bindvError name scope env
        )
    | _             -> assert false

<<>>=
let doConstDecls scope env dd =
    foldl (doConstDecl scope) env dd
@


Names defined by declarations found in cycles are bound to [[E.Error]]
in the (fat) environment.

<<>>=
let bindError scope env decls = 
    let names = List.concat (List.map TV.defines decls) in 
        foldl (fun env name -> F.bindvError name scope env) env names
@
<<>>=
let reportCycle decls = 
    let report = function
        | A.Const(t,n,_), Some r -> 
            E.errorRegPrt r ("const declaration for "^n^" is cyclic")
        | A.Const(t,n,_), None   ->
            E.errorPrt      ("const declaration for "^n^" is cyclic")
        | _                     -> assert false
    in
        List.iter report decls      

<<>>=
let doConst is_global env dd =
    let decls          = List.map fst                            in
    let scope          = if is_global then F.Global else F.Local in
    let rec bindAll dd =
        try
            let dd' = TSort.sort dd                              in
            doConstDecls scope env (decls dd')
        with TSort.Cycle(offending) ->
            let dd'   = exclude dd offending                     in
            let scope = if is_global then F.Global else F.Local  in
            let env'  = bindError scope env offending            in
                ( reportCycle offending
                ; bindAll dd'
                )
                                                                 in
        bindAll dd

let doGlobalConst env program = 
        doConst true  env (CollectConst.foldGlobalConstDecls program)
let doLocalConst  env body    = 
        doConst false env (CollectConst.foldLocalConstDecls body)
@

% ------------------------------------------------------------------ 
\subsection{Checking a whole file}
% ------------------------------------------------------------------ 

To actually scan, parse, and check a file we provide a function
[[check]] to be called with a file name.  It calls the parser to
create the abstract syntax and calls the different phases of checking.

<<check file>>=
let check file =
    let fd          = try open_in file 
                      with Sys_error(msg) -> E.error msg                 in
    let finally ()  = close_in fd                                        in
    let lexbuf      = Lexing.from_channel fd                             in
    let map         = Srcmap.empty                                       in
    let scanner     = Scan.scan map                                      in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; let ast        = Parse.program scanner lexbuf              in
              let env0       = F.empty                                   in
              let env1       = TypeEnv.doGlobalTypes env0 ast            in
              let env2       = ValueEnv.BindGlobals.program env1 ast     in
              let env3       = ValueEnv.EvalConst.doGlobalConst env2 ast in
                 ( E.Ok ()
                 )
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.Error
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.Error
              )
            | e ->
              ( finally()
              ; raise e
              )
@
