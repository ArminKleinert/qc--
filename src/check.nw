% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

% ------------------------------------------------------------------ 
\section{Checking Static Semantics}
% ------------------------------------------------------------------ 

To check the static semantics of a {\PAL} program the meaning of all
names used by it must be determined and their correct usage verified. 
The visibility of names in {\PAL} is controlled by name spaces and
scopes.  There are four name spaces:

\begin{enumerate}
\item Values (Procedures, Constants, Registers, Imports, \dots).
\item Types (names defined by [[typedef]]).
\item Constant operators ([[%add]], \dots).
\item Runtime operators; this a superset of the constant name space.
\end{enumerate}

Since operators are predefined they are visible everywhere and have no
further scoping rules.  Values and types are scoped:

\begin{enumerate}
\item The scope of the compilation unit is called \textit{global}. It
      includes the top-level and all sections. Labels at the statement
      level of procedures have additionally global scope.
      
\item The procedure scope, called \textit{local}.  Values and types
      declared inside a procedure have local scope.  Entries in the
      local scope shadow entries in the global scope.
\end{enumerate} 

A name is visible inside its whole scope, even before its declaration.
Type declarations can refer to each other, constant declarations can
refer to type declarations and each other. All non-constant values can
only refer to type declarations. Before the static semantics of a
scope can be checked all names must be resolved in a multi-step approach:

\begin{enumerate}
\item All type declarations of the current scope are collected. They
      are topologically sorted with respect to the use of each other
      and entered into the type environment.

\item All non-constant values are entered into the environment.

\item All constant declarations are collected, topologically sorted
      and processed. Processing includes inferring their types and
      evaluating them. The values and types found are then entered into
      the value environment.

\item Now the environment in complete to check the static semantics of
      the current scope. This involves checking the types
      and all the other constraints defined by the static semantics.
\end{enumerate}


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Currently the interface only allows to check the static semantics of a
named file.  When the check succeeds [[Error.Ok()]] is returned, and
[[Error.Error]] otherwise.

<<check.mli>>=
val check : string -> unit Error.error
@ 

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The key to understand the implementation is the fat environment
[[Fatenv]]; it defines a symbol table that holds the type, value, and
target environment.

<<check.ml>>=
module T = Types
module E = Error
module A = Ast
module F = Fatenv

let foldl = List.fold_left (* f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a *)
@

The remove offending declarations from a list we use [[exclude]]: 
[[exclude xx yy]] returns [[xx]] without elements found in [[yy]]. 
Since we expect [[yy]] to be very short (1 to 3 elements) we have
chosen a naive approach for implementation.
 
<<>>=
let exclude xx yy = 
    let _, xx' = List.partition (fun x  -> List.mem x yy) xx  in
    xx'
@

For error reports we need a source code map to resolve character
positions into meaningful file, line, column triples.  The source map
can be obtained from the fat environment.  Here is a suitable error
reporting function for [[E.catch]]:

<<>>=
let error r env msg = E.errorRegionPrt (F.srcmap env,r) msg 
@

Types in the abstract syntax may be names and must be evaluated before
they can be used. The evaluation can fail in case the name is
undefined and therefore an [[E.error]] type is used.

<<>>=
let rec evalTy env = function
    | A.TyAt(x,r)    -> E.catch (error r env) (evalTy env) x
    | A.BitsTy(size) -> E.Ok(Types.Bits size)
    | A.AliasTy(n)   -> snd (F.findt n env)

<<>>=
<<building the type environment>>
<<building the value environment>>
<<checking the static semantics>>

<<>>=
let checkProgram env program =
    let env1       = TypeEnv.doGlobalTypes env  program            in
    let env2       = ValueEnv.Bind.globals env1 program            in
    let env3       = ValueEnv.EvalConst.doGlobalConst env2 program in
        Semantics.program env3 program

<<check file>>
@

% ------------------------------------------------------------------ 
\subsection{Building the type environment}
% ------------------------------------------------------------------ 

Because type declarations can refer to each other they can not be
simply processed in source code order.  They are collected, then
sorted, and finally processed. The sort function is provided by the
[[Topsort.Make]] functor, which is parameterized over the declarations
being sorted.  In this case module [[TT]] provides the necessary
informations about type declarations. 

<<building the type environment>>=
module TypeEnv = struct
    module TT = struct
        <<module TT>>
    end
    module TSort = Topsort.Make(TT)
    
    <<collect type decls>>
    <<process type decls>>

    let foldGlobalTypeDecls program =
        foldl (toplevel None) [] program

    let foldLocalTypeDecls b =
        foldl (body None) [] b
end
@

% ------------------------------------------------------------------ 
\subsubsection{Collecting Type declarations}
% ------------------------------------------------------------------ 

The functions collecting type declarations walk over the abstract
syntax and return them in a list.  The top-level and its sections
declare global types, the body of procedures local types. 
        
<<collect type decls>>=
let rec body r dd = function
    | A.BodyAt(x,r)     -> body (Some r) dd x
    | A.DeclBody(d)     -> decl r dd d
    | _                 -> dd
<<>>=
and decl r dd = function
    | A.DeclAt(x,r)     -> decl (Some r) dd x
    | A.Typedef(_) as d -> (d,r)::dd
    | _                 -> dd
<<>>=
and stmt r dd = function
    | A.StmtAt(x,r)     -> stmt (Some r) dd x
    | A.SpanStmt(_,_,bb)-> foldl (body r) dd bb
    | _                 -> dd

<<>>=
let rec section r dd = function
    | A.SectionAt(x,r)         -> section (Some r) dd x 
    | A.Decl(d)                -> decl r dd d 
    | A.SSpan( e1, e2, ss)     -> foldl (section r) dd ss
    | A.Datum( d)              -> dd
    | A.Procedure(p)           -> dd 
<<>>=    
let rec toplevel r dd = function
    | A.ToplevelAt(x,r)   -> toplevel (Some r) dd x
    | A.Section(_, ss)    -> foldl (section r) dd ss
    | A.TopDecl (d)       -> decl r dd d
    | _                   -> dd
<<>>=
let foldGlobalTypeDecls program =
    foldl (toplevel None) [] program
<<>>=
let foldLocalTypeDecls b =
    foldl (body None) [] b
@

% ------------------------------------------------------------------ 
\subsubsection{Sorting type declarations}
% ------------------------------------------------------------------ 

Before the values of a scope are entered into the environment all type
declarations are processed. Type declarations can refer to each other
and thus they must be processed in a topological order: declarations
must depend only on declarations that have been already processed.

Topological sort is implemented by the [[TSort]] module.  The
[[TSort.sort]] function knows very few things about (type)
declarations:  it can ask for the names a declaration [[defines]], and
the declared names it [[uses]].  For error reporting declarations are
enriched with optional source code positions.

<<module TT>>=
type decl = A.decl * A.region option

let rec defines = function
    | A.DeclAt(d,r)      , _   -> defines (d,Some r)
    | A.Typedef(t,names) , _   -> names
    | _                  , _   -> []
<<>>=
let rec uses = function     
    | A.DeclAt(d,r)                 , _   -> uses (d,Some r)
    | A.Typedef(A.BitsTy(_),names)  , _   -> []
    | A.Typedef(A.AliasTy(x),names) , _   -> [x]
    | _                             , _   -> []
@

% ------------------------------------------------------------------ 
\subsubsection{Processing type declarations}
% ------------------------------------------------------------------ 

After type declarations have been collected they are sorted
topologically to get the right order to process them.  Sorting can
fail when declarations happen to be circular; this is reported by an
exceptions.  In that case offending declarations are taken out and the
sorting is repeated.  We end up with a fat environment that binds all
names for types of the actual scope.

Names defined by declarations found in cycles are bound to [[E.Error]]
in the (fat) environment.

<<process type decls>>=
let bindError scope env decls = 
    let names = List.concat (List.map TT.defines decls) in 
        foldl (fun env name -> F.bindtError name scope env) env names

<<>>=
let bindt names ty scope env =
    foldl (fun env n -> F.bindt n (scope,ty) env) env names

<<>>=
let rec doTypeDecl env = function
    | A.DeclAt(x,r)      -> E.catch' env (error r env) (doTypeDecl env) x
    | A.Typedef(t,names) -> bindt names (evalTy env t) F.Global env
    | _                  -> env

<<>>=
let doTypeDecls env decls = foldl doTypeDecl env decls
@

When cycles are found in the list of declarations they are reported.
Their source code positions were attached to them during their
collection. 

<<>>=
let reportCycle env decls = 
    let report = function
        | A.Typedef(t,n::nn), Some r -> 
            error r env ("typedef for "^n^" is cyclic")
        | A.Typedef(t,n::nn), None   -> 
            E.errorPrt      ("typedef for "^n^" is cyclic")
        | _                     -> assert false
    in
        List.iter report decls      

<<>>=
let doTypes is_global env dd =
    let decls          = List.map fst                 in
    let rec bindAll dd =
        try
            let dd'   = TSort.sort dd                 in
            doTypeDecls env (decls dd')
        with TSort.Cycle(offending) ->
            let dd'   = exclude dd offending          in
            let scope = if is_global then F.Global
                        else F.Local                  in
            let env'  = bindError scope env offending in
                ( reportCycle env' offending
                ; bindAll dd'
                )
                                                      in
        bindAll dd
<<>>=
let doGlobalTypes env program = doTypes true  env (foldGlobalTypeDecls program)
let doLocalTypes  env body    = doTypes false env (foldLocalTypeDecls body)
@

% ------------------------------------------------------------------ 
\subsection{Building the value environment}
% ------------------------------------------------------------------ 

The top-level scope of a compilation unit includes the top-level
itself and all sections.  Values declared on either level are visible
in the entire compilation unit.  Before the static semantics of a
program can be checked these global declarations must be bound in an
environment.  Additionally constant declarations are type checked and
evaluated.  The values for them are also bound in the environment,
too. 

Except for constants all other values like labels, continuations, or
registers, are completely known at the place where they are defined or
declared.  Constants can refer to other constants and thus processing
them takes some care.  Like type declarations, constants must be
processed in a (topological) order such that less dependent
declarations are processed first. 

Conceptually all declarations and language constructs that create a
named value could be treated as a declaration--most of them depending
on no other.  But to improve performance constant declarations are
treated separately because only they require a topological sort.  We
thus traverse the abstract syntax and bind all non-constant values
into the environment.  Then we collect all constant declarations, sort
and process them.  Because sorting fails in the presence of cyclic
declarations and must be re-done, keeping the list to be sorted small
is also advantageous.

<<building the value environment>>=
module ValueEnv = struct
    module TV = struct
        <<module TV>>
    end
    module TSort = Topsort.Make(TV)
   
    module Bind = struct
        <<bind global values>>
    end

    module CollectConst = struct
        <<collecting const declarations>>
    end

    module EvalConst = struct
        <<processing const declarations>>
    end
end
@

    
% ------------------------------------------------------------------ 
\subsubsection{Binding non-constant values}
% ------------------------------------------------------------------ 

Labels and procedures have fixed types that can be entered into the
environment.  Register and Import declarations on the other hand carry
user provided types with them.  In case these types are names they may
be undefined; this leads to register and import declarations which are
bound to [[Error]]. 

<<bind global values>>=
let proct scope    = (scope, E.Ok(F.Label(F.Proc),T.code))
let codet scope    = (scope, E.Ok(F.Label(F.Code),T.code))
let datat scope    = (scope, E.Ok(F.Label(F.Data),T.data))
let contt scope    = (scope, E.Ok(F.Continuation,T.cont))    

<<>>=
let regt scope = function 
    | E.Ok(t) -> (scope, E.Ok(F.Register,t))
    | E.Error -> (scope, E.Error)
<<>>=
let importt scope = function 
    | E.Ok(t) -> (scope, E.Ok(F.Import,t))
    | E.Error -> (scope, E.Error)
<<>>=
let rec ty env = function
    | A.TyAt(x,r)       -> E.catch (error r env) (ty env) x
    | A.BitsTy(n)       -> E.Ok(T.bits n)
    | A.AliasTy(n)      -> F.findt' n env
@

The following functions traverse the abstract syntax of the global or
local scope and enter all names into the environment -- except for
constants.  The parameter [[scope]] indicates whether local or global
symbols are bound and defines also the scope that is used when names
are bound in the fat environment. 

Global symbols are all those on the top-level and section level.
Additionally all labels for code inside procedures are also
bound because they have global scope. When local symbols (inside a
procedure) are bound labels are bound a second time with a local scope
in the environment. This helps to decide whether a symbol is local or
global when it is accessed from inside a procedure.

    
<<>>=
let import scope t env = function
    | Some foreign, name -> F.bindv name (importt scope (ty env t)) env
    | None        , name -> F.bindv name (importt scope (ty env t)) env
<<>>=
let target env = function
    | A.Memsize(i)        -> F.bindMemsize i env
    | A.ByteorderBig      -> F.bindendianness F.Big env
    | A.ByteorderLittle   -> F.bindendianness F.Little env 
    
<<>>=
let imports  scope env t ii         = foldl (import scope t) env ii
let register scope env (_,t,name,_) = F.bindv name (regt scope (ty env t)) env
@

The [[datum]] function binds global data-labels and local
[[stackdata]] labels when called from [[body]].

<<>>=
let rec datum scope env = function
    | A.DatumAt(x,r)        -> E.catch' env (error r env) (datum scope env) x
    | A.Label(n)            -> F.bindv n (datat scope) env 
    | _                     -> env
@

Continuations are local to procedures and thus they are only bound
when in [[F.Local]] mode.

<<>>=
let rec stmt scope env = function 
    | A.StmtAt(x,r)           -> 
        E.catch' env (error r env) (stmt scope env) x
    | A.IfStmt ( e, ss1, ss2) -> 
        foldl (stmt scope) (foldl (stmt scope) env ss1) ss2
    | A.LabelStmt(n)          -> F.bindv n (codet scope) env
    | A.SpanStmt(e1,e2,ss)    -> foldl (body scope) env ss
    | A.SwitchStmt (r,e,arms) -> foldl (arm scope)  env arms
    | A.ContStmt(n,ee)        -> if scope=F.Global then env 
                                 else F.bindv n (contt scope) env
    
    | _                       -> env

and arm scope env = function
    | A.ArmAt(x,r)            -> E.catch' env (error r env) (arm scope env) x
    | A.Case(ranges, ss)      -> foldl (stmt scope) env ss
<<>>=
and decl scope env = function
    | A.DeclAt(x,r)    -> E.catch' env (error r env) (decl scope env) x
    | A.Import(ty,ii)  -> imports scope env ty ii
    | A.Registers(rr)  -> foldl (register scope) env rr 
    | A.Target(aa)     -> if scope=F.Global then foldl target env aa else env
    | _                -> env
@

A \textit{body} is always local to procedure and therefore its
declarations are only processed when local values are bound. 

<<>>=
and body scope env = function
    | A.BodyAt(x, r) -> E.catch' env (error r env) (body scope env) x
    | A.DeclBody(d)  -> if scope=F.Local then decl scope env d else env 
    | A.DataBody(dd) -> if scope=F.Local then foldl (datum scope) env dd 
                        else env
    | A.StmtBody(s)  -> stmt scope env s
<<>>=       
let proc scope env (_,name,_,bb) = 
    let env' = F.bindv name (proct scope) env in
        foldl (body scope) env' bb
<<>>=
let rec section env = function
    | A.SectionAt(x,r)     -> E.catch' env (error r env) (section env) x
    | A.Decl(d)            -> decl F.Global env d
    | A.SSpan( e1, e2, ss) -> foldl section env ss
    | A.Datum( d)          -> datum F.Global env d
    | A.Procedure(p)       -> proc F.Global env p

<<>>=
let rec toplevel env = function 
    | A.ToplevelAt(x, r)  -> E.catch' env (error r env) (toplevel env) x
    | A.Section(name, ss) -> foldl section env ss
    | A.TopDecl(d)        -> decl F.Global env d
    | A.TopProcedure(p)   -> proc F.Global env p 

<<>>=
let globals env tt   = foldl toplevel env tt
let locals  env bb   = foldl (body F.Local) env bb
@ 

% ------------------------------------------------------------------ 
\subsubsection{Collecting constant declarations}
% ------------------------------------------------------------------ 

Constant declarations are a bit special because every declaration's
type and value can depend on other declarations. They thus must be
topologically sorted before their types and values can be computed.
The following functions walk over the abstract syntax and collect
constant declarations in a list. 

<<collecting const declarations>>=
let rec body r dd = function
    | A.BodyAt(x,r)     -> body (Some r) dd x
    | A.DeclBody(d)     -> decl r dd d
    | _                 -> dd
and decl r dd = function
    | A.DeclAt(x,r)     -> decl (Some r) dd x
    | A.Const(_) as d   -> (d,r)::dd
    | _                 -> dd
and stmt r dd = function
    | A.StmtAt(x,r)     -> stmt (Some r) dd x
    | A.SpanStmt(_,_,bb)-> foldl (body r) dd bb
    | _                 -> dd

<<>>=
let rec section r dd = function
    | A.SectionAt(x,r)         -> section (Some r) dd x 
    | A.Decl(d)                -> decl r dd d 
    | A.SSpan( e1, e2, ss)     -> foldl (section r) dd ss
    | A.Datum( d)              -> dd
    | A.Procedure(p)           -> dd 
<<>>=    
let rec toplevel r dd = function
    | A.ToplevelAt(x,r)   -> toplevel (Some r) dd x
    | A.Section(_, ss)    -> foldl (section r) dd ss
    | A.TopDecl (d)       -> decl r dd d
    | _                   -> dd
<<>>=
let foldGlobalConstDecls program =
    foldl (toplevel None) [] program
<<>>=
let foldLocalConstDecls b =
    foldl (body None) [] b
@

% ------------------------------------------------------------------ 
\subsubsection{Sorting Constant Declarations}
% ------------------------------------------------------------------  

Module [[T]] captures what is important to sort declarations:  A
declaration defines a name (multiple in general) and refers to other
names.  As said before we only sort constant declarations. 

<<module TV>>=
type decl = A.decl * A.region option

let rec defines = function
    | A.DeclAt(d,r)        , _   -> defines (d,Some r)
    | A.Const(t,name,expr) , _   -> [name]
    | _                    , _   -> []
@

A constant expression can refer to other constant and link-time
constants.  To find the right topological order it is only important
to find other constants.  Of course, these can not be syntactically
distinguished and so we will collect all free variables of an
expression.  This leads to used names, that are not constants and that
appear to be undefined from the perspective of the topological
[[sort]] function.  But [[sort]] assumes that these undeclared names
do not depend on any constant---which is correct.

<<>>=
let rec freeExprVars = function
    | A.ExprAt(x,r)     -> freeExprVars x
    | A.Fetch(lvalue)   -> freeLValueVars lvalue
    | A.BinOp(e1,_,e2)  -> (freeExprVars e1) @ (freeExprVars e2)
    | A.UnOp(_,e)       -> freeExprVars e
    | A.PrimOp(_,args)  -> 
        List.concat (List.map (fun (_,e) -> freeExprVars e) args)
    | _                 -> []
<<>>=
and freeLValueVars = function
    | A.LValueAt(x,r)   -> freeLValueVars x
    | A.Mem(_,e,_)      -> freeExprVars e
    | A.Var(name)       -> [name]
       
let rec uses = function
    | A.DeclAt(d,r)        , _   -> uses (d,Some r)
    | A.Const(t,name,expr) , _   -> freeExprVars expr
    | _                    , _   -> []
@

% ------------------------------------------------------------------ 
\subsubsection{Evaluating constant declarations}
% ------------------------------------------------------------------ 

Constant declarations must be sorted topologically before they can be
processed.  Processing includes checking their types and evaluating
their values.  Both type and value are bound in the environment.

Processing a constant declaration means to

\begin{enumerate}
\item infer its type and compare it to an optionally supplied type that
      is part of it declaration,
\item evaluate it to its value,
\item bind the value and the type in the environment.
\end{enumerate}

The topological sorting guarantees that every named value a constant
declaration depends on is already processed and the name is bound in
the environment.  The following functions type check and evaluate
constants in a single step.  Each function returns a pair of a type
and a value.

<<processing const declarations>>=
let rec evalFetch env = function
    | A.LValueAt(x,r) -> E.catch (error r env) (evalFetch env) x
    | A.Mem (_,_,_)   -> E.error "memory access in const declaration"
    | A.Var(id)       -> ( match F.findv' id env with
                         | E.Error                -> E.Error
                         | E.Ok(F.Constant(v),ty) -> E.Ok(ty, v)
                         | _ -> E.error ("access of non-constant "^id)
                         ) 
@
<<>>=
let rec evalPrimOp' op env args =
    let f, t   = Const.Symbol.lookup op Const.constOps in
    let at,av  = List.split args                       in
    let unused = Types.bool                            in
    let sigma  = ( try Types.unify t (Types.proc at unused) Types.empty with
                 | Types.UnifyExn -> E.error "type mismatch"
                 )                                     in
    let rt     = ( match Types.subst sigma t with
                 | Types.Procedure(_,t) -> t
                 | _                    -> assert false
                 )                                     in
        rt, f av
<<>>=
and evalPrimOp env op args =
    E.emap (evalPrimOp' op env) (evalExprs env args)

<<>>=
and evalExprs env ee =
    let rec loop env acc = function
        | []    -> E.Ok(acc)
        | e::ee -> ( match evalExpr env e with
                   | E.Ok(t, v) -> loop env ((t,v)::acc) ee
                   | E.Error    -> E.Error
                   )
    in
        loop env [] ee

<<>>=
and evalExpr env = function
| A.ExprAt(x,r) -> E.catch (error r env) (evalExpr env) x
| A.Int (str,(Some size as s))   -> E.Ok(T.bits size, Const.int2value str s)
| A.Int (str,(None      as s))   -> E.Ok(T.word     , Const.int2value str s)
| A.Float (str,(Some size as s)) -> E.Ok(T.bits size, Const.float2value str s)
| A.Float (str,(None      as s)) -> E.Ok(T.word     , Const.float2value str s)
| A.Char (str,(Some size as s))  -> E.Ok(T.bits size, Const.char2value str s)
| A.Char (str,(None      as s))  -> E.Ok(T.word     , Const.char2value str s)
| A.Fetch(v)                     -> evalFetch env v
| A.BinOp(l,op,r)                -> evalPrimOp env op [l;r]
| A.UnOp(op,expr)                -> evalPrimOp env op [expr]
| A.PrimOp(op,args)              -> evalPrimOp env op (List.map snd args)
@

A constant declaration must declare a value of type [[bits]]; although
it is syntactically and type-wise possible to declare a boolean value
this is not permitted. The optionally provided type must match the
actual type of the defining expression.

<<>>=
let doConstDecl scope env = function
    | A.Const(Some t', name, expr) -> 
        ( match evalExpr env expr, evalTy env t' with 
        | E.Ok(t,v),E.Ok(t') when t =t' && t <> Types.bool -> 
            F.bindv name (scope,E.Ok(F.Constant(v),t)) env
        | E.Ok(t,v),E.Ok(t') when t =t' && t = Types.bool -> 
            ( E.errorPrt "contant has type bool but must have type bits"
            ;  F.bindvError name scope env
            )
        | E.Ok(t,v),E.Ok(t') when t<>t'  ->
            ( E.errorPrt ("type declared for constant "^name^" does not match actual type")
            ; F.bindvError name scope env
            )
        | _ -> F.bindvError name scope env
        )
    | A.Const(None, name, expr) ->
        ( match evalExpr env expr with
        | E.Ok(t,v) when t <> Types.bool ->
            F.bindv name (scope,E.Ok(F.Constant(v),t)) env
        | E.Ok(t,v) when t = Types.bool ->
            ( E.errorPrt "contant has type bool but must have type bits"
            ; F.bindvError name scope env
            ) 
        | _  -> F.bindvError name scope env
        )
    | _   -> assert false

<<>>=
let doConstDecls scope env dd =
    foldl (doConstDecl scope) env dd
@

Names defined by declarations found in cycles are bound to [[E.Error]]
in the (fat) environment.

<<>>=
let bindError scope env decls = 
    let names = List.concat (List.map TV.defines decls) in 
        foldl (fun env name -> F.bindvError name scope env) env names
@
<<>>=
let reportCycle env decls = 
    let report = function
        | A.Const(t,n,_), Some r -> 
            error r env ("const declaration for "^n^" is cyclic")
        | A.Const(t,n,_), None   ->
            E.errorPrt  ("const declaration for "^n^" is cyclic")
        | _                     -> assert false
    in
        List.iter report decls      

<<>>=
let doConst is_global env dd =
    let decls          = List.map fst                            in
    let scope          = if is_global then F.Global else F.Local in
    let rec bindAll env dd =
        try
            let dd' = TSort.sort dd                              in
            doConstDecls scope env (decls dd')
        with TSort.Cycle(offending) ->
            let dd'   = exclude dd offending                     in
            let scope = if is_global then F.Global else F.Local  in
            let env'  = bindError scope env offending            in
                ( reportCycle env offending
                ; bindAll env' dd'
                )
                                                                 in
        bindAll env dd
@

Procedures open a new scope where they declare they own types and
constants. These are processed by [[doLocalConst]] which is called
during the check of the static semantics below.

<<>>=
let doGlobalConst env program = 
        doConst true  env (CollectConst.foldGlobalConstDecls program)
let doLocalConst  env body    = 
        doConst false env (CollectConst.foldLocalConstDecls body)
@

% ------------------------------------------------------------------ 
\subsection{Checking the static semantics}
% ------------------------------------------------------------------ 

After all global names for types and values are bound in the fat
environment the static semantics can be checked.  This essentially
means to walk over the abstract syntax and check all the constraints
defined by the static semantics.  In case of an error we like to
report it but continue to check the rest of a program.  The success of
a check is therefore expressed by an [[Error.error]] value.

<<checking the static semantics>>=
module Semantics = struct
    <<utilities>>
    <<type check expression>>
    <<check>>
end
@

Alignments must be a power of two. This predicates is true, iff its argument
is a positive power of two.

<<utilities>>=
let rec is2power = function
    | 1 -> true
    | x -> x > 0 && (x mod 2) = 0 && is2power (x/2)
@

% ------------------------------------------------------------------ 
\subsubsection{Expression types}
% ------------------------------------------------------------------ 

Expressions are type checked.  In [[ValueEnv.EvalConst]] constant
definitions were already type checked and there is some code for this. 
But the evaluation of constants interlaced type checking and
evaluations. It is easier and cleaner to implement the type checking
functions again.

<<type check expression>>=
let rec tyFetch env = function
    | A.LValueAt(x,r) -> E.catch (error r env) (tyFetch env) x
    | A.Var(id)       -> ( match F.findv' id env with
                         | E.Error                -> E.Error
                         | E.Ok(denotation,ty)    -> E.Ok(ty)
                         ) 
    | A.Mem (t,e,a)   -> 
        let te    = tyExpr env e in
        let t'    = evalTy env t in
        let align = match a with
                    | None   -> 1
                    | Some a when is2power a -> a
                    | Some a -> E.error "alignment not a power of 2"
        in
            ( match te, t' with
            | E.Error , _         -> E.Error
            | _       , E.Error   -> E.Error
            | E.Ok(te), E.Ok(t') when te = Types.data -> E.Ok(t')
            | _      -> E.error "memory reference by non-data pointer"
            )

<<>>=
and tyAppl' opTy argTys =
    let unused = Types.bool                            in
    let sigma  = ( try Types.unify opTy (Types.proc argTys unused) Types.empty with
                 | Types.UnifyExn -> E.error "type error in application"
                 )                                     in
        ( match Types.subst sigma opTy with
        | Types.Procedure(_,t) -> t
        | _                    -> assert false
        )
        
and tyAppl opTy argTys = E.emap (tyAppl' opTy) argTys
@

For now we are using the types of the primitive constant operators. 
All primitive runtime operators will go into their own module
[[Primitives]].  So we have to fix the [[lookup]] later.

<<>>=
and tyPrimOp env op args =
    let at = List.map (tyExpr env) args                  in
    let ot = snd (Const.Symbol.lookup op Const.constOps) in
        tyAppl ot (E.Raise.list at)

<<>>=
and tyExpr env = function
    | A.ExprAt(x,r) -> E.catch (error r env) (tyExpr env) x
    | A.Int (str,(Some size as s))   -> E.Ok(T.bits size)
    | A.Int (str,(None      as s))   -> E.Ok(T.word     )
    | A.Float (str,(Some size as s)) -> E.Ok(T.bits size)
    | A.Float (str,(None      as s)) -> E.Ok(T.word     )
    | A.Char (str,(Some size as s))  -> E.Ok(T.bits size)
    | A.Char (str,(None      as s))  -> E.Ok(T.word     )
    | A.Fetch(v)                     -> tyFetch env v
    | A.BinOp(l,op,r)                -> tyPrimOp env op [l;r]
    | A.UnOp(op,expr)                -> tyPrimOp env op [expr]
    | A.PrimOp(op,args)              -> tyPrimOp env op (List.map snd args)
@

% ------------------------------------------------------------------ 
\subsubsection{Checking the static semantics}
% ------------------------------------------------------------------ 

Checking the static semantics really starts here.  We traverse the
abstract syntax and check all the constrains.  The overall result is
either [[E.Ok()]] or [[E.Error]].  The reduce the correctness of a
complex object to a single result we employ the [[Error.Implode]]
module heavily.

To evaluate constant expressions we use the code from
[[ValueEnv.EvalConst]]:

<<check>>=
let constExpr env e = ValueEnv.EvalConst.evalExpr env e
@    

Initial values for memory must be either compile-time constants or
link-time constants.  Currently we only check the types which is not
enough; have to fix this.

<<>>=
let rec init env = function
    | A.InitAt(x,_)   -> init env x
    | A.InitExprs(es) -> E.Raise.list (List.map (tyExpr env) es)
    | A.InitStr(s)    -> E.Ok ([Types.char])
    | A.InitUStr(s)   -> E.Ok ([Types.uchar])

let memsize env = function
    | A.NoSize    -> E.Ok(Some 1)
    | A.DynSize   -> E.Ok(None)
    | A.FixSize e -> 
        let f' = function
            | Types.Bits(x), size 
              when Const.val2i size > 0 -> Some (Const.val2i size)
            | otherwise                 -> E.error "invalid size"   in
        E.emap f' (ValueEnv.EvalConst.evalExpr env e)
<<>>=
let memdecl env ty size = function 
    | None     -> E.Implode.pair (memsize env size, evalTy env ty)
    | Some (i) -> 
        ( match init env i, evalTy env ty with
        | E.Error,_          -> E.Error
        | _, E.Error         -> E.Error
        | E.Ok tys, E.Ok ty' ->
            let n           = List.length tys in
            let consistent  = foldl (fun res t -> res && ty' = t) true tys in

            if not consistent then
                E.error 
                    "initial values have types different than declared type" 
            else ( match memsize env size with
                 | E.Ok(Some m) when n > m -> E.error "too many initial values"
                 | E.Ok(Some m) when n < m -> E.error "too few  initial values"
                 | E.Ok(Some m)            -> E.Ok ()
                 | E.Ok(None)              -> E.Ok ()
                 | E.Error                 -> E.Error
                 )
        )
@

Labels must not be processed because they have been already entered
into the environment during previous steps.
        
<<>>=
let rec datum env = function
    | A.DatumAt(x,r)   -> E.catch (error r env) (datum env) x
    | A.Label(n)       -> E.Ok ()
    | A.Align(a)       -> if is2power a then E.Ok () else 
                          E.error ("illegal alignment: " ^ string_of_int a)
    | A.MemDecl(t,m,i) -> memdecl env t m i

<<>>=
let rec stackdatum env = function
    | A.DatumAt(x,r)      -> E.catch  (error r env) (stackdatum env) x
    | A.Label(n)          -> E.Ok() (* should be in env *)
    | A.Align(a)          -> if is2power a then E.Ok() else 
                             E.error ("illegal alignment: " ^ string_of_int a)
    | A.MemDecl(t,m,None) -> memdecl env t m None 
    | A.MemDecl(t,m,_   ) -> E.error "no initial values allowed for stackdata"
<<>>=
let checkJumpTarget env x =
    match F.findv x env with
    | _       ,E.Error                 ->  E.Error
    | F.Local ,E.Ok(F.Label(F.Code),_) ->  E.Ok ()
    | F.Global,E.Ok(F.Label(F.Code),_) ->  E.error (x^" not a local label")
    | _       ,E.Ok(F.Label(_)     ,_) ->  E.error (x^" not a goto  label")
    | otherwise                        ->  E.error (x^" is not a label")
<<>>=
let targets env ts = E.Implode.map (checkJumpTarget env) ts 

<<>>=
let checkFlowTarget env x =
    match F.findv x env with
    | _      , E.Error                -> E.Error
    | F.Local, E.Ok(F.Continuation,_) -> E.Ok()
    | _      , E.Ok(F.Continuation,_) -> assert false
    | _                               -> E.error (x^" is not a continuation")
@
The flow annotations [[returns to]] and [[unwinds to]] is meaningless when
used to annotate a [[cuts to]] statement. We are checking a [[cut to]] 
statement when [[isCutTo]] is true.

<<>>=
let rec flow isCutTo env = function
    | A.FlowAt(x,r)     -> E.catch (error r env) (flow isCutTo env) x
    | A.CutsTo(ns)      -> E.Implode.map (checkFlowTarget env) ns 
    | A.UnwindsTo(ns)   -> 
        if isCutTo then E.error "unwinds is meaningless for cut to" 
        else E.Implode.map (checkFlowTarget env) ns 
    | A.ReturnsTo(ns)   -> 
        if isCutTo then E.error "returns is meaningless for cut to"
        else E.Implode.map (checkFlowTarget env) ns 
    | A.Aborts          -> E.Ok ()

let flows isCutTo env fs = E.Implode.map (flow isCutTo env) fs
@

The [[isLabel env e]] function returns [[true]] if the expression
[[e]] is a label, i.e. when it is statically known.

<<>>=
let rec isLabel env = function
    | A.ExprAt(x,_)                     -> isLabel env x
    | A.Fetch(A.LValueAt(x,_))          -> isLabel env (A.Fetch x)
    | A.Fetch(A.Var(x))                 -> 
          ( match F.findv x env with
          | _       ,E.Error            -> false
          | scope   ,E.Ok(F.Label(_),_) -> true
          | _                           -> false
          )        
    | _                                 -> false
@

An \textit{lvalue} must be a memory location or a register. We check
the types of both sides of an assignment and therefore return the type
of the \textit{lvalue}. The results of a call can be only assigned to
registers, but not memory. References to memory in that case are thus
an error.

<<>>=
let rec lvalue is_call env lv =
    let align = function
        | Some a when not (is2power a)  -> E.error "alignment not a power of 2"
        | Some _ (* properly aligned *) -> E.Ok()
        | None                          -> E.Ok()
    in match lv with 
    | A.LValueAt (lv, r)   -> E.catch (error r env) (lvalue is_call env) lv
    | A.Var(name)          -> 
        ( match F.findv name env with
        | _, E.Ok(F.Register,t) -> E.Ok(t)
        | _, E.Ok(_)            -> E.error ("not a register: "^name)
        | _, E.Error            -> E.Error
        )
    | A.Mem(t, e, a) when is_call -> E.error ("not a register") 
    | A.Mem(t, e, a)       -> 
        ( match tyExpr env e, evalTy env t, align a with
        | E.Ok(te), E.Ok(t), E.Ok() when te = T.data    ->
            E.Ok(t)         
        | E.Ok(te), E.Ok(t), E.Ok() when te <> T.data   -> 
            E.error "expression is not a data pointer"
        | _                                             -> E.Error
        )
<<>>=
let rec ifStmt env e ss1 ss2 =
    match tyExpr env e with
    | E.Error                   -> E.Error
    | E.Ok(ty) when ty = T.bool -> E.Implode.pair (stmts env ss1, stmts env ss2)
    | otherwise                 -> E.error "if-condition must be of type bool"

<<>>=
and spanStmt env e1 e2 bb =
    let f = function
        | E.Error                           -> E.Error
        | E.Ok (ty,value) when ty = T.word  -> E.Ok() 
        | E.Ok (_)                          -> 
            E.error "span key and value must be of the natural word type"
    in
        E.Implode.triple ( f (constExpr env e1)
                         , f (constExpr env e2)
                         , E.Implode.map (body env) bb
                         )
@ 

The target list of a [[goto]] statement may be empty only if the
expression is a label.
                         
<<>>=
and gotoStmt env e ts = 
    let t' = targets env ts in
    let e' = match tyExpr env e with
        | E.Error                 -> E.Error
        | E.Ok(t) when t = T.code -> E.Ok()
        | _                       -> 
            E.error "goto-expression does not evaluate to a code pointer" 
    in 
        match ts, isLabel env e with
        | [], false   -> E.error "must specify a target list"
        | _           -> E.Implode.pair (e',t')

<<>>=
and cutStmt env e args fs =
    let f    = flows true env fs in
    let args = List.map (tyExpr env) (List.map snd args) in
    let nt   = match tyExpr env e with
                | E.Ok(t) when t = Types.cont -> E.Ok ()
                | E.Error                     -> E.Error 
                | otherwise  -> E.error "expression not of continuation type"
    in
        E.Implode.triple (f,E.Raise.list args,nt)

<<>>=    
and jumpStmt env cc e args ts =
    let t    = targets env ts in
    let args = List.map (tyExpr env) (List.map snd args) in
    let et   = match tyExpr env e with
                | E.Ok(t) when t = T.code  -> E.Ok ()
                | otherwise                -> 
                    E.error "jump target is not a pointer"
    in
        E.Implode.triple (t,E.Raise.list args, et)

<<>>=
and contStmt env n ns = 
    let check n = 
        let f = function
            | F.Local , E.Ok(F.Register,_) -> E.Ok ()
            | F.Global, E.Ok(F.Register,_) -> E.error (n^" is not local")  
            | _, E.Error                   -> E.Error
            | otherwise                    -> 
                E.error ("formal continuation parameter not a register: "^n)
        in
            f (F.findv n env)
    in
        E.Implode.list (List.map check ns)
<<>>=
and returnStmt env cc alt args =
    let args  = List.map snd args  in
    let tys   = E.Implode.list (List.map (tyExpr env) args) in
    let f     = function (tx, x),(ty, y) ->
                      tx = T.word 
                   && ty = T.word 
                   && Const.val2i x >= 0 
                   && Const.val2i y >= 0 
                   && Const.val2i x <= Const.val2i y
    in 
        match alt with
        | None         -> tys
        | Some (e1,e2) -> let e1' = constExpr env e1 in
                          let e2' = constExpr env e2 in
                          ( match E.emap f (E.Raise.pair (e1',e2')) with
                          | E.Ok(true)  -> tys
                          | E.Ok(false) -> E.error "illegal <x/y> combination"
                          | E.Error     -> E.Error
                          )

<<>>=
and assignStmt env (lvalues,exprs) =
    let pairs = try List.combine lvalues exprs
                with Invalid_argument _ -> 
                E.error "length of lhs/rhs in assignment differs"
    in
    let pair (lhs,expr) =  
        match lvalue false env lhs, tyExpr env expr with
        | E.Ok (t), E.Ok(te) when t = te -> E.Ok()
        | E.Error , _                    -> E.Error
        | _       , E.Error              -> E.Error
        | otherwise   -> E.error "type mismatch in assignment"
    in
        E.Implode.map pair pairs

<<>>=
and callStmt env (l,cc,e,args,ts,fs) =
    let lt      = E.Implode.map (lvalue true env) l in
    let ts'     = targets env ts                    in
    let fs'     = flows false env fs                in
    let args'   = List.map snd args                 in
    let argsTy  = E.Implode.map (tyExpr env) args'  in
        if ts = [] && not (isLabel env e) then
            E.error "a target annotation for this call is missing"
        else match tyExpr env e with
        | E.Error                 -> E.Error
        | E.Ok(t) when t = T.code -> E.Implode.quad (lt,ts',fs',argsTy)
        | otherwise               -> E.error "call-expression is not a pointer"
             
<<>>=
and primStmt env (l,cc,op,args,fs) =
    let l      = E.Implode.map (lvalue true env) l           in
    let fs     = flows false env fs                          in
    let opTy   = snd (Const.Symbol.lookup op Const.constOps) in
    let args'  = List.map snd args                           in
    let argsTy = List.map (tyExpr env) args'                 in
    let rTy    = tyAppl opTy (E.Raise.list argsTy)           in
        E.Implode.triple (l,fs,rTy)

<<>>=
and range env = function
    | A.Point(e)     -> E.emap fst (constExpr env e)
    | A.Range(e1,e2) -> 
        ( match constExpr env e1, constExpr env e2 with
        | E.Error         , _                      ->  E.Error
        | _               , E.Error                ->  E.Error
        | E.Ok(t1,v1)     , E.Ok(t2,v2) when t1=t2 ->  E.Ok(t1)
        | otherwise -> E.error "Different types of lower and upper range bound"
        )
<<>>=        
and arm t env = function
    | A.ArmAt(x,r)   -> E.catch (error r env) (arm t env) x
    | A.Case(rr, ss) ->
        let ss' = stmts env ss in 
        let rr' =
            ( match E.Raise.list (List.map (range env) rr) with
            | E.Ok([])     -> E.error "must specify range for this arm"
            | E.Ok(t::tt)  -> if    List.for_all ((=) t) tt then E.Ok(t)
                              else E.error "type inconsistencies in ranges"
            | E.Error      -> E.Error
            )
        in
            ( match ss', rr' with
            | E.Ok(), E.Ok(_) -> rr'
            | _               -> E.Error
            )
<<>>=                
and switchStmt env (r, expr, arms) =
    let et = tyExpr env expr in
    let at = ( match E.Raise.list (List.map (arm et env) arms) with
             | E.Ok([])    -> E.error "empty switch body"
             | E.Ok(t::tt) -> if   List.for_all ((=) t) tt then E.Ok(t)
                              else E.error "type inconsistencies across arms" 
             | E.Error     -> E.Error
             ) in
    let rt = ( match r with
             | None   -> et 
             | Some r -> range env r
             ) in
        match E.Implode.triple (et, at, rt) with
        | E.Ok() when et <> at -> 
            E.error "type inconsistency between expression and arms"
        | E.Ok() when at <> rt -> 
            E.error "type inconsistency between expression and range"
        | E.Ok()               -> E.Ok()
        | E.Error              -> E.Error

<<>>=
and body env = function
    | A.BodyAt(x, r) -> E.catch (error r env) (body env) x
    | A.DeclBody(d)  -> decl env d
    | A.DataBody(dd) -> E.Implode.map (stackdatum env) dd 
    | A.StmtBody(s)  -> stmt env s       
<<>>=
and stmt env = function
    | A.StmtAt(x,r)                 -> E.catch (error r env) (stmt env) x
    | A.IfStmt ( e, ss1, ss2)       -> ifStmt env e ss1 ss2
    | A.SpanStmt(e1,e2,ss)          -> spanStmt env e1 e2 ss
    | A.AssignStmt(xs)              -> assignStmt env xs
    | A.CallStmt call               -> callStmt env call
    | A.PrimStmt call               -> primStmt env call
    | A.GotoStmt(e,ts)              -> gotoStmt env e ts
    | A.CutStmt(n, args, fs)        -> cutStmt env n args fs
    | A.ReturnStmt(cc, alt, args)   -> returnStmt env cc alt args
    | A.JumpStmt(cc,e,args,ts)      -> jumpStmt env cc e args ts
    | A.ContStmt(n,ns)              -> contStmt env n ns
    | A.LabelStmt(n)                -> E.Ok ()
    | A.EmptyStmt                   -> E.Ok ()
    | A.SwitchStmt switch           -> switchStmt env switch         
<<>>=
and stmts env ss = E.Implode.map (stmt env) ss

<<>>=
and export' env = function
    | None, name   -> 
        ( match F.findv' name env with
        | E.Error                 -> E.Error
        | E.Ok(F.Label(F.Proc),_) -> E.Ok()
        | _                       -> E.error (name^" can't be exported")
        )
    | Some t, name -> 
        ( match F.findv' name env, evalTy env t with
        | E.Error                , _        -> E.Error
        | _                      , E.Error  -> E.Error
        | E.Ok(F.Label(F.Proc),t), E.Ok(t')
            when t = t'                     -> E.Ok()
        | E.Ok(F.Label(F.Proc),t), E.Ok(t') ->
            E.error (name^" has not declared type")
        | _                                 -> 
            E.error (name^" can't be exported")
           
        )

and export env t ns = E.Implode.map (fun (n,_) -> export' env (t,n)) ns

<<>>=
and decl env = function
    | A.DeclAt(x,r)        -> E.catch (error r env) (decl env) x
    | A.Import( t, ns)     -> E.Ok()
    | A.Export( t, ns)     -> export env t ns
    | A.Const (t,n,e)      -> E.Ok()
    | A.Registers( rs)     -> E.Ok()
    | A.Typedef (t,nn)     -> E.Ok()
    | A.Target (arch)      -> E.Ok()
    | A.Pragma             -> E.Ok()
    
<<>>=
and formal env (hint, inv, ty, name) =
    match evalTy env ty with
    | E.Ok(t) -> F.bindv name (F.Local,E.Ok(F.Register,t)) env 
    | E.Error -> F.bindvError name F.Local env
    
<<>>=
and proc env (cc, name, ff, bb) =
    let env0 = foldl formal env ff                     in 
    let env1 = TypeEnv.doLocalTypes env0 bb             in
    let env2 = ValueEnv.Bind.locals env1 bb            in
    let env3 = ValueEnv.EvalConst.doLocalConst env2 bb in
        E.Implode.map (body env3) bb            

<<>>=
and section env = function    
    | A.SectionAt(x,r)     -> E.catch (error r env) (section env) x
    | A.Decl(d)            -> E.Ok()
    | A.Datum( d)          -> datum env d
    | A.Procedure(p)       -> proc env p
    | A.SSpan( e1, e2, ss) -> E.Ok()
<<>>=
let rec toplevel env = function
    | A.ToplevelAt(x, r)   -> E.catch (error r env) (toplevel env) x
    | A.Section(name, ss)  -> E.Implode.map (section env) ss 
    | A.TopDecl(d)         -> decl env d
    | A.TopProcedure(p)    -> proc env p 

<<>>=
and program env tt = E.Implode.map (toplevel env) tt
@

% ------------------------------------------------------------------ 
\subsection{Checking a whole file}
% ------------------------------------------------------------------ 

To actually scan, parse, and check a file we provide a function
[[check]] to be called with a file name.  It calls the parser to
create the abstract syntax and calls the different phases of checking.

<<check file>>=
let check file =
    let fd          = try open_in file 
                      with Sys_error(msg) -> E.error msg                 in
    let finally ()  = close_in fd                                        in
    let lexbuf      = Lexing.from_channel fd                             in
    let map         = Srcmap.empty                                       in
    let scanner     = Scan.scan map                                      in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; let ast        = Parse.program scanner lexbuf              in
                checkProgram (F.create map) ast   
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.Error
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.Error
              )
            | e ->
              ( finally()
              ; raise e
              )
@
