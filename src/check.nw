% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

% ------------------------------------------------------------------ 
\section{Checking Static Semantics}
% ------------------------------------------------------------------ 

To check the static semantics of a {\PAL} program the meaning of all
names used by it must be determined and their correct usage verified. 
The visibility of names in {\PAL} is controlled by name spaces and
scopes.  There are four name spaces:

\begin{enumerate}
\item Values (Procedures, Constants, Registers, Imports, \dots).
\item Types (names defined by [[typedef]]).
\item Primitive compile-time operators ([[%add]], \dots).
\item Primitive run-time operators; this a super set of the compile-time
      operators.
\end{enumerate}

Since operators are predefined they are visible everywhere and have no
further scoping rules.  On the other hand, names for values and types
are scoped:

\begin{enumerate}
\item The scope of the compilation unit is called \textit{global}. It
      includes the top-level and all sections. Labels at the statement
      level of procedures have additionally global scope.
      
\item The procedure scope, called \textit{local}.  Values and types
      declared inside a procedure have local scope.  Entries in the
      local scope shadow entries in the global scope.
\end{enumerate} 

A name is visible inside its whole scope, even before its declaration.
Type declarations can refer to each other; compile-time computes
(constant) value declarations can refer to type declarations and each
other.  All run-time computed named values can only refer to type
declarations.  Before the static semantics of a scope can be checked
all names must be resolved in a multi-step approach:

\begin{enumerate}
\item All type declarations of the current scope are collected. They
      are topologically sorted with respect to the use of each other
      and entered into the fat environment.

\item All named run-time computed values are entered into the fat
      environment.

\item All constant declarations are collected, topologically sorted
      and processed.  Processing includes inferring their types and
      evaluating them.  The values and types found are then entered
      into the environment.

\item Now the environment in complete to check the static semantics of
      the current scope. This involves checking the types
      and all the other constraints defined by the static semantics.
\end{enumerate}


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Currently the interface only allows to check the static semantics of a
named file.  When the check succeeds [[Error.Ok()]] is returned, and
[[Error.Error]] otherwise.

<<check.mli>>=
val check : string -> unit Error.error
@ 

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The key to understand the implementation is the fat environment
[[Fatenv]]; it defines a symbol table that holds the type, value, and
target environment.  Names are chosen similar to the non-terminals
used in the grammar.

<<check.ml>>=
module T = Types
module E = Error
module A = Ast
module F = Fatenv
@

% ------------------------------------------------------------------ 
\subsubsection{The 30\,000 feet overview}
% ------------------------------------------------------------------  

An outlined in the introduction, an environment must be built up before
the static semantics can be checked. The different phases are delegated
to sub-modules which are assembled here. 

<<>>=
<<auxiliaries>>
<<building the type environment>>
<<building the value environment>>
<<checking the static semantics>>
@

Finally, here is the function that checks an entire program.  The
implementation gives an overview of the different steps.

<<>>=
let checkProgram env program =
    let env        = TypeEnv.doGlobalTypes env program             in
    let env        = ValueEnv.Bind.globals env program             in
    let env        = ValueEnv.Eval.doGlobalConst env  program in
    let env        = F.setDefaults env                             in
        Semantics.program env program
@

To actually scan, parse, and check a file we provide a function
[[check]] to be called with a file name.  It calls the parser to
create the abstract syntax and calls the different phases of checking. 
In principle errors are propagated and [[checkProgram]] returns with
[[Error.Error]] when a violation of a static semantic rule was found. 
Sometimes a violation manifests itself only by bindings of the
[[Error.Error]] value in the fat environment.  Thus, this is scanned
for such bindings. Still, not all errors are detected: a
re-declaration of a type or value is an error. When the second
declaration is processed the re-declaration is detected and an error
message is issued.  Currently the first (valid) declaration stays in
the environment and the error stays invisible.

<<>>=
let check file =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; let ast        = Parse.program scanner lexbuf in
              let env        = F.create map                 in
                E.Implode.pair (checkProgram env ast, F.errorfree env)   
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.Error
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.Error
              )
            | e ->
              ( finally()
              ; raise e
              )
@

% ------------------------------------------------------------------ 
\subsubsection{Auxiliaries}
% ------------------------------------------------------------------ 

The non-terminal symbol [[lvalue]] is used in different contexts that
we would like to distinguish: only in the [[Call]] context lvalues may
carry hints for calling conventions.

<<auxiliaries>>=
type context = Assign     (* x,y = y,x  *)
             | Call       (* x,y = f()  *)
             | PrimCall   (* x,y = %f() *)
@

Fold is the most frequently used higher order function in this module. 
We therefore like a short name.  Unlike its cousin
[[List.fold_right]], [[foldl]] is tail-recursive.

<<>>=
let foldl = List.fold_left (* f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a *)
@

The remove offending declarations from a list we use [[exclude]]: 
[[exclude xx yy]] returns [[xx]] without elements found in [[yy]]. 
Since we expect [[yy]] to be very short (1 to 3 elements) we have
chosen a naive approach for implementation.  Efficiency is also less
of a concern because we are dealing with a program that has errors and
thus nobody expects us to be fast.
 
<<>>=
let exclude xx yy = List.filter (fun x  -> List.mem x yy) xx 
@

For error reports we need a source-code map to resolve character
positions into meaningful file, line, column triples.  The source map
can be obtained from the fat environment.  Here is a suitable error
reporting function for [[E.catch]]:

<<>>=
let error r env msg = E.errorRegionPrt (F.srcmap env,r) msg 
@

Types in the abstract syntax may be names and must be evaluated before
they can be used. The evaluation can fail in case the name is
undefined and therefore an [[E.error]] type is used.

<<>>=
let rec evalTy env = function
    | A.TyAt(x,r)    -> E.catch (error r env) (evalTy env) x
    | A.BitsTy(size) -> E.Ok(Types.Bits size)
    | A.AliasTy(n)   -> snd (F.findt n env)
@

% ------------------------------------------------------------------ 
\subsection{Building the type environment}
% ------------------------------------------------------------------ 

Because type declarations can refer to each other they can not be
simply processed in source code order.  They are collected, then
sorted, and finally processed. The sort function is provided by the
[[Topsort.Make]] functor, which is parameterized over the declarations
being sorted.  In this case module [[TT]] provides the necessary
informations about type declarations. 

As in the rest of the [[Check]] module, functions are named after the
non-terminals in the grammar. So a function [[body]] deals with the
body of procedure, for example.

The overall purpose of this module is to provide functions that take
the abstract syntax of a program or procedure and enter all type
declarations found there into the fat environment.  This is done by
[[foldGlobalTypeDecls]] and [[foldLocalTypeDecls]] respectively.  As
explained earlier declaration can refer to each other.  Because of
these dependencies among each other, they must be first collected,
than sorted, and finally processed in the right order.

<<building the type environment>>=
module TypeEnv = struct
    module TT = struct
        <<module TT>>
    end
    module TSort = Topsort.Make(TT)
    
    <<collect type decls>>
    <<process type decls>>

    let foldGlobalTypeDecls program =
        foldl (toplevel Srcmap.null) [] program

    let foldLocalTypeDecls b =
        foldl (body Srcmap.null) [] b
end
@

% ------------------------------------------------------------------ 
\subsubsection{Collecting Type declarations}
% ------------------------------------------------------------------ 

The following functions collect type declarations by walking over the
abstract syntax and returning them in a list.  The declarations are
not returned literally but their constructors are stripped of and
only the abstract information is returned.

The top-level and its sections declare global types, the body of
procedures local types. 
        
A procedure body contains statements, stack data declarations and type
declarations. A [[span]] statement has its own body which again can
contain type declarations - so we have to scan the statements part of
a body.

While descending into the abstract syntax we remember source-code
positions.  The last source-code position we came across is paired
with the declaration as its source-code location.  To simplify things
we use the [[Srcmap.null]] source-code position at when we start to
avoid dealing with optional source-code positions.

<<collect type decls>>=
let rec body r dd = function
    | A.BodyAt(x,r)     -> body r dd x
    | A.DeclBody(d)     -> decl r dd d
    | A.StmtBody(s)     -> stmt r dd s
    | A.DataBody _      -> dd
<<>>=
and stmt r dd = function
    | A.StmtAt(x,r)     -> stmt r dd x
    | A.SpanStmt(_,_,bb)-> foldl (body r) dd bb
    | A.IfStmt _     -> dd
    | A.SwitchStmt _ -> dd
    | A.LabelStmt _  -> dd
    | A.ContStmt _   -> dd
    | A.AssignStmt _ -> dd
    | A.CallStmt _   -> dd
    | A.PrimStmt _   -> dd
    | A.GotoStmt _   -> dd
    | A.JumpStmt _   -> dd
    | A.CutStmt _    -> dd
    | A.ReturnStmt _ -> dd
    | A.EmptyStmt    -> dd
<<>>=
and decl r dd = function
    | A.DeclAt(x,r)     -> decl r dd x
    | A.Typedef(d)      -> (d,r)::dd
    | A.Import    _       -> dd
    | A.Export    _       -> dd
    | A.Const     _       -> dd
    | A.Registers _       -> dd
    | A.Target    _       -> dd
    | A.Pragma            -> dd
@

Global type declarations are either on the top-level, or at the
section-level.  A [[span]] at the section-level contains more
declarations which must be checked.  Since procedures declare local
types they must not be checked when we are collecting the global
types.
    
<<>>=
let rec section r dd = function
    | A.SectionAt(x,r)         -> section r dd x 
    | A.Decl(d)                -> decl r dd d 
    | A.SSpan( e1, e2, ss)     -> foldl (section r) dd ss
    | A.Datum( d)              -> dd
    | A.Procedure(p)           -> dd 
<<>>=    
let rec toplevel r dd = function
    | A.ToplevelAt(x,r)   -> toplevel r dd x
    | A.Section(_, ss)    -> foldl (section r) dd ss
    | A.TopDecl (d)       -> decl r dd d
    | A.TopProcedure _    -> dd (* no global typedefs here *)
@

The following two functions collect type declarations at the global
(program) and the local (procedure) level and return them in a list.
    
<<>>=
let foldGlobalTypeDecls program =
    foldl (toplevel Srcmap.null) [] program
<<>>=
let foldLocalTypeDecls b =
    foldl (body Srcmap.null) [] b
@

% ------------------------------------------------------------------ 
\subsubsection{Sorting type declarations}
% ------------------------------------------------------------------ 

Before the values of a scope are entered into the environment all type
declarations are processed. Type declarations can refer to each other
and thus they must be processed in a topological order: declarations
must depend only on declarations that have been already processed.

Topological sort is implemented by the [[TSort]] module.  The
[[TSort.sort]] function knows very few things about (type)
declarations:  it can ask for the names a declaration [[defines]], and
the declared names it [[uses]].  For error reporting declarations are
enriched with optional source code positions.


<<module TT>>=
type decl = (A.ty * string list) * A.region
@

Things are easy: a [[typedef]] defines the names it defines; it depends
on another type if its type is itself just a name. 

<<>>=
let defines ((t,names),_) = names
let uses    ((t,names),_) = match t with
    | A.BitsTy(_)   -> []
    | A.AliasTy(x)  -> [x]
    | A.TyAt _      -> assert false
@

% ------------------------------------------------------------------ 
\subsubsection{Processing type declarations}
% ------------------------------------------------------------------ 

After type declarations have been collected they are sorted
topologically to get the right order to process them.  Sorting can
fail when declarations happen to be circular; this is reported by an
exceptions.  In that case offending declarations are taken out and the
sorting is repeated.  We end up with a fat environment that binds all
names for types of the actual scope.

Names defined by declarations found in cycles are bound to [[E.Error]]
in the (fat) environment.

<<process type decls>>=
let bindError scope env decls = 
    let names = List.concat (List.map TT.defines decls) in 
        foldl (fun env name -> F.bindtError name scope env) env names
@

A [[typedef]] declares multiple names.  This function binds all
[[names]] to the same [[ty]] in [[scope]]. 

<<>>=
let bindt names ty scope env =
    foldl (fun env n -> F.bindt n scope ty env) env names
@

While processing a declaration an error may occur. This is caught
here; the source-code position associated with a type declaration is
used for error reporting.

<<>>=
let rec doTypeDecl env (d,r) = 
    let bind (t,names) = bindt names (evalTy env t) F.Global env 
    in
        E.catch' env (error r env) bind d

<<>>=
let doTypeDecls env decls = foldl doTypeDecl env decls
@

When cycles are found in the list of declarations they are reported.
Their source code positions were attached to them during their
collection. 

<<>>=
let reportCycle env decls = 
    let report = function 
        | ((t,n::nn),r) ->  error r env ("typedef for "^n^" is cyclic")
        | _             ->  assert false (* list of names empty *)
    in
        List.iter report decls      
@

When a cycle is found it is removed from the list of declarations and
the process of sorting and processing is started over.  We don't care
that this takes time because we have an illegal {\PAL} program.

<<>>=
let doTypes is_global env dd =
    let rec bindAll dd =
        try
            let dd    = TSort.sort dd                 in
            doTypeDecls env dd
        with TSort.Cycle(offending) ->
            let dd    = exclude dd offending          in
            let scope = if is_global then F.Global
                        else F.Local                  in
            let env   = bindError scope env offending in
                ( reportCycle env offending
                ; bindAll dd
                )
                                                      in
        bindAll dd
@
After all, here are the two functions to process global and local type
declarations:

<<>>=
let doGlobalTypes env program = doTypes true  env (foldGlobalTypeDecls program)
let doLocalTypes  env body    = doTypes false env (foldLocalTypeDecls body)
@

% ------------------------------------------------------------------ 
\subsection{Building the value environment}
% ------------------------------------------------------------------ 

The top-level scope of a compilation unit includes the top-level
itself and all sections.  Names declared on either level are visible
in the entire compilation unit.  Before the static semantics of a
program can be checked these global declarations must be bound in an
environment.  Additionally constant declarations are type checked and
evaluated.  The values for them are also bound in the environment,
too. 

Except for constants all other values like labels, continuations, or
registers, are completely described by the place where they are found
and can be immediately bound in the environment.  Constants, on the
other hand, can refer to other constants and thus processing them
takes some care.  Like type declarations, constants must be processed
in a (topological) order such that less dependent declarations are
processed first. 

Conceptually all declarations and language constructs that create a
named value could be treated as a declaration--most of them depending
on no other.  But to improve performance constant declarations are
treated separately because only they require a topological sort.  We
thus traverse the abstract syntax and bind all non-constant values
into the environment.  Then we collect all constant declarations, sort
and process them.  Because sorting fails in the presence of cyclic
declarations and must be re-done, keeping the list to be sorted small
is also advantageous.

The outline of the [[ValueEnv]] module below gives a glimpse of the
different steps:  module [[TV]] provides informations about the
dependencies of constant declarations.  [[Bind]] enters names for
values (except of constants) into the environment, [[Collect]]
collects constant declarations, and [[Eval]] evaluates constant
declarations and enters them into the environment. 

<<building the value environment>>=
module ValueEnv = struct
    module TV = struct
        <<module TV>>
    end
    module TSort = Topsort.Make(TV)
   
    module Bind = struct
        <<bind global values>>
    end

    module Collect = struct
        <<collecting const declarations>>
    end

    module Eval = struct
        <<processing const declarations>>
    end
end
@

    
% ------------------------------------------------------------------ 
\subsubsection{Binding names for link- and run-time values}
% ------------------------------------------------------------------ 

Labels and names for procedures have fixed types.  Types of register
and import declarations on the other hand can refer to named types
which may be undefined. A declaration which refers to an undefined type
is bound to [[Error.Error]].

<<bind global values>>=
let rec ty env = function
    | A.TyAt(x,r)       -> E.catch (error r env) (ty env) x
    | A.BitsTy(n)       -> E.Ok(T.bits n)
    | A.AliasTy(n)      -> F.findt' n env
@

The following functions traverse the abstract syntax of the global or
local scope and enter all names into the environment -- except for
constants.  The parameter [[scope]] indicates whether local or global
symbols are bound and defines also the scope that is used when names
are bound in the fat environment. 

Global symbols are all those on the top-level and section level.
Additionally all labels for code inside procedures are also
bound because they have global scope. When local symbols (inside a
procedure) are bound labels are bound a second time with a local scope
in the environment. This helps to decide whether a symbol is local or
global when it is accessed from inside a procedure.

<<>>=
let import scope t env = function
    | Some foreign, name -> 
        F.bindv name scope (E.ematch (ty env t) (fun t -> F.Import,t)) env
    | None        , name -> 
        F.bindv name scope (E.ematch (ty env t) (fun t -> F.Import,t)) env
         
<<>>=
let target env = function
    | A.Memsize(i) when i > 0   -> F.bindMemsize i env
    | A.Memsize(i)              -> E.error "memsize must be positive"
    | A.ByteorderBig            -> F.bindEndianness F.Big env
    | A.ByteorderLittle         -> F.bindEndianness F.Little env 
    
<<>>=
let imports  scope env t ii         = foldl (import scope t) env ii
let register scope env (_,t,name,_) = 
    F.bindv name scope (E.ematch (ty env t) (fun t -> F.Register,t)) env
@

The [[datum]] function binds global data-labels and local
[[stackdata]] labels when called from [[body]].

<<>>=
let rec datum scope env = function
    | A.DatumAt(x,r)  -> E.catch' env (error r env) (datum scope env) x
    | A.Label(n)      -> F.bindv n scope (E.Ok(F.Label(F.Data),T.data)) env
    | _               -> env
@

Continuations are local to procedures and thus they are only bound
when in [[F.Local]] mode.

<<>>=
let rec stmt scope env = function 
    | A.StmtAt(x,r)           -> 
        E.catch' env (error r env) (stmt scope env) x
    | A.IfStmt ( e, ss1, ss2) -> 
        foldl (stmt scope) (foldl (stmt scope) env ss1) ss2
    | A.LabelStmt(n)          -> 
        F.bindv n scope (E.Ok(F.Label(F.Code),T.code)) env
    | A.SpanStmt(e1,e2,ss)    -> 
        foldl (body scope) env ss
    | A.SwitchStmt (r,e,arms) -> 
        foldl (arm scope)  env arms
    | A.ContStmt(n,ee)        -> 
        if scope=F.Global then env 
        else F.bindv n scope (E.Ok(F.Continuation,T.cont)) env
    | otherwise               -> 
        env

and arm scope env = function
    | A.ArmAt(x,r)            -> E.catch' env (error r env) (arm scope env) x
    | A.Case(ranges, ss)      -> foldl (stmt scope) env ss
<<>>=
and decl scope env = function
    | A.DeclAt(x,r)    -> E.catch' env (error r env) (decl scope env) x
    | A.Import(ty,ii)  -> imports scope env ty ii
    | A.Registers(rr)  -> foldl (register scope) env rr 
    | A.Target(aa)     -> if scope=F.Global then foldl target env aa else env
    | _                -> env
@

A \textit{body} is always local to procedure and therefore its
declarations are only processed when local values are bound. 

<<>>=
and body scope env = function
    | A.BodyAt(x, r) -> E.catch' env (error r env) (body scope env) x
    | A.DeclBody(d)  -> if scope=F.Local then decl scope env d else env 
    | A.DataBody(dd) -> if scope=F.Local then foldl (datum scope) env dd 
                        else env
    | A.StmtBody(s)  -> stmt scope env s
<<>>=       
let proc scope env (_,name,_,bb) = 
    let env' = F.bindv name scope (E.Ok(F.Label(F.Proc),T.code)) env in
        foldl (body scope) env' bb
<<>>=
let rec section env = function
    | A.SectionAt(x,r)     -> E.catch' env (error r env) (section env) x
    | A.Decl(d)            -> decl F.Global env d
    | A.SSpan( e1, e2, ss) -> foldl section env ss
    | A.Datum( d)          -> datum F.Global env d
    | A.Procedure(p)       -> proc F.Global env p

<<>>=
let rec toplevel env = function 
    | A.ToplevelAt(x, r)  -> E.catch' env (error r env) (toplevel env) x
    | A.Section(name, ss) -> foldl section env ss
    | A.TopDecl(d)        -> decl F.Global env d
    | A.TopProcedure(p)   -> proc F.Global env p 

<<>>=
let globals env tt   = foldl toplevel env tt
let locals  env bb   = foldl (body F.Local) env bb
@ 

% ------------------------------------------------------------------ 
\subsubsection{Collecting constant declarations}
% ------------------------------------------------------------------ 

Constant declarations are special because every declaration's type and
value can depend on other declarations.  They thus must be
topologically sorted before their types and values can be computed. 
The following functions walk over the abstract syntax and collect
constant declarations in a list.  As we walk we remember the last
source code position annotation we came across and use it for the
declaration we find. 

Local constant declarations are only found in the [[body]] of
procedures and [[span]] statements.  Global constant declarations are
part of [[section]s and their [[span]]s.

<<collecting const declarations>>=
let rec body r dd = function
    | A.BodyAt(x,r)     -> body r dd x
    | A.DeclBody(d)     -> decl r dd d
    | A.StmtBody(s)     -> stmt r dd s
    | A.DataBody _      -> dd    
<<>>=
and decl r dd = function
    | A.DeclAt(x,r)       -> decl r dd x
    | A.Const(d)          -> (d,r)::dd
    | A.Typedef   _       -> dd
    | A.Import    _       -> dd
    | A.Export    _       -> dd
    | A.Registers _       -> dd
    | A.Target    _       -> dd
    | A.Pragma            -> dd
@
The function [[body]] is used only for collecting local declarations,
[[stmt]] for both global and and local declarations, and the two
remaining functions [[section]] and [[toplevel]] only for global
declarations.

<<>>=
and stmt r dd = function
    | A.StmtAt(x,r)     -> stmt r dd x
    | A.SpanStmt(_,_,bb)-> foldl (body r) dd bb
    | A.IfStmt      _   -> dd
    | A.SwitchStmt  _   -> dd
    | A.LabelStmt   _   -> dd
    | A.ContStmt    _   -> dd
    | A.AssignStmt  _   -> dd
    | A.CallStmt    _   -> dd
    | A.PrimStmt    _   -> dd
    | A.GotoStmt    _   -> dd
    | A.JumpStmt    _   -> dd
    | A.CutStmt     _   -> dd
    | A.ReturnStmt  _   -> dd
    | A.EmptyStmt       -> dd

<<>>=
let rec section r dd = function
    | A.SectionAt(x,r)         -> section r dd x 
    | A.Decl(d)                -> decl r dd d 
    | A.SSpan( e1, e2, ss)     -> foldl (section r) dd ss
    | A.Datum( d)              -> dd
    | A.Procedure(p)           -> dd 
<<>>=    
let rec toplevel r dd = function
    | A.ToplevelAt(x,r)   -> toplevel r dd x
    | A.Section(_, ss)    -> foldl (section r) dd ss
    | A.TopDecl (d)       -> decl r dd d
    | _                   -> dd
@

The following two functions collect global (unit/section) and local
(procedure) constant declarations and return them in a list. 
    
<<>>=
let foldGlobalConstDecls program =
    foldl (toplevel Srcmap.null) [] program
<<>>=
let foldLocalConstDecls b =
    foldl (body Srcmap.null) [] b
@

% ------------------------------------------------------------------ 
\subsubsection{Sorting Constant Declarations}
% ------------------------------------------------------------------  

Module [[T]] captures what is important to sort declarations:  A
declaration defines a name (multiple in general) and refers to other
names.  As said before we only sort constant declarations. 

<<module TV>>=
type decl = (A.ty option * string * A.expr) * A.region
@

A [[const]] declaration defines the name it declare. That was simple.

<<>>=
let rec defines ((t,name,expr),r) = [name]
@

A constant expression can refer to other constant and link-time
constants.  To find the right topological order it is only important
to find other constants.  Of course, these can not be syntactically
distinguished and so we will collect all free variables of an
expression.  This leads to used names, that are not constants and that
appear to be undefined from the perspective of the topological
[[sort]] function.  But [[sort]] assumes that these undeclared names
do not depend on any constant---which is correct. 

The [[freeExprVars]] function returns all names referenced in an
expression. A constant expression depends on all of them.

We like to avoid costly append operations.  Since the order of our
result does not matter we can easily code an efficient [[join]]
functions:  that returns the elements of two lists in one list.

<<>>=
let rec join l = foldl (fun x y -> y :: x) l

<<>>=
let rec freeExprVars = function
    | A.ExprAt(x,_)     -> freeExprVars x
    | A.Fetch(lvalue)   -> freeLValueVars lvalue
    | A.BinOp(e1,_,e2)  -> join (freeExprVars e1) (freeExprVars e2)
    | A.UnOp(_,e)       -> freeExprVars e
    | A.PrimOp(_,args)  -> 
        foldl (fun l (_,e) -> join l (freeExprVars e))  [] args
    | A.Int _           -> []
    | A.Float _         -> []
    | A.Char _          -> []

<<>>=
and freeLValueVars = function
    | A.LValueAt(x,r)   -> freeLValueVars x
    | A.Mem(_,e,_)      -> freeExprVars e
    | A.Var(_,name)     -> [name]
@
A constant declaration uses all names in its defining expression.
These should be names of other constant expression but we don't know
this yet.
         
<<>>=  
let rec uses ((t,n,e),r) = freeExprVars e
@

% ------------------------------------------------------------------ 
\subsubsection{Evaluating constant declarations}
% ------------------------------------------------------------------ 

Constant declarations must be sorted topologically before they can be
processed.  Processing includes checking their types and evaluating
their values.  Both type and value are bound in the environment.

Processing a constant declaration means to

\begin{enumerate}
\item infer its type and compare it to an optionally supplied type that
      is part of it declaration,
\item evaluate it to its value,
\item bind the value and the type in the environment.
\end{enumerate}

The topological sorting guarantees that every named value a constant
declaration depends on is already processed and the name is bound in
the environment.  The following functions type check and evaluate
constants in a single step.  Each function returns a pair of a type
and a value.


<<processing const declarations>>=
let rec evalFetch env = function
    | A.LValueAt(x,r) -> E.catch (error r env) (evalFetch env) x
    | A.Mem (_,_,_)   -> E.error "memory access in const declaration"
    | A.Var(hint,id)  -> ( match F.findv' id env with
                         | E.Error                -> E.Error
                         | E.Ok(F.Constant(v),ty) -> E.Ok(ty, v)
                         | _ -> E.error ("access of non-constant "^id)
                         ) 
@

Applications to primitives operators must be type checked.  The types
of the arguments [[at]] and the typescheme [[t]] of the operator as
found in [[Const.Symbol]] are passed to [[Types.appl]] which returns
the type of the result, if the type check passes.  Otherwise it raises
an [[Error.ErrorExn]].  Only if the type check passes we apply the
values to the implementation [[f]] of the operator and get the result. 
Both result and type are returned.

<<>>=
let rec evalPrimOp' op env args =
    let f, t   = Const.Symbol.lookup op Const.constOps in
    let at,av  = List.split args                       in
    let rt     = Types.appl t at                       in
        rt, f av
<<>>=
and evalPrimOp env op args =
    E.emap (evalPrimOp' op env) (evalExprs env args)

<<>>=
and evalExprs env ee = E.Raise.list (List.map (evalExpr env) ee)

<<>>=
and evalExpr env = function
| A.ExprAt(x,r) -> E.catch (error r env) (evalExpr env) x
| A.Int (str, Some t)    -> E.ematch (evalTy env t) 
    (fun t -> t, Const.int2value str)
| A.Int (str, None   )   -> E.Ok(T.word     , Const.int2value str)
| A.Float (str, Some t)  -> E.ematch (evalTy env t)
    (fun t -> t, Const.float2value str)
| A.Float (str, None)    -> E.Ok(T.word     , Const.float2value str)
| A.Char (str, Some t)   -> E.ematch (evalTy env t)
    (fun t -> t, Const.char2value str)
| A.Char (str, None)     -> E.Ok(T.word     , Const.char2value str)
| A.Fetch(v)             -> evalFetch env v
| A.BinOp(l,op,r)        -> evalPrimOp env op [l;r]
| A.UnOp(op,expr)        -> evalPrimOp env op [expr]
| A.PrimOp(op,args)      -> evalPrimOp env op (List.map snd args)
@

A constant declaration must declare a value of type [[bits]]; although
it is syntactically and type-wise possible to declare a boolean value
this is not permitted. The optionally provided type must match the
actual type of the defining expression.

The [[doConstDecl]] evaluates the expression for a constant declaration
and optionally its type. Only when both succeed and the resulting type
match the given type, and is not [[bool]] the name is bound to the
type and value in the environment.

<<>>=
let doConstDecl scope env ((ty,name,expr),r) = 
    let seqPair p f = E.sequence f (E.Raise.pair p)                in
    let seq     x f = E.sequence f x                               in
    let consistent t = match ty with None -> true | Some t' -> t'=t in
    let entry = seq (evalExpr env expr) 
        ( function
        | (t,v) when t <> Types.bool -> E.Ok(F.Constant(v),t)
        | (t,v) -> 
            ( E.errorPrt "constant has type bool but must have type bits"
            ; E.Error
            )
        ) in
    let entry = (* check user provided type against inferred type *)
        ( match ty with 
        | None    -> entry
        | Some t' -> seqPair (entry, evalTy env t') 
                    ( function
                    | (v,t), t' when t = t' -> entry
                    | _ -> ( E.errorPrt ("type declared for constant "^name^" does not match actual type")
                           ; E.Error
                           )
                    )
         ) 
    in 
         F.bindv name scope entry env

<<>>=
let doConstDecls scope env dd =
    foldl (doConstDecl scope) env dd
@

Names defined by declarations found in cycles are bound to [[E.Error]]
in the (fat) environment.

<<>>=
let bindError scope env decls = 
    let names = List.concat (List.map TV.defines decls) in 
        foldl (fun env name -> F.bindvError name scope env) env names
@

This functions reports an error for all names defined by declarations
that were found to be cyclic.

<<>>=
let reportCycle env decls = 
    let report ((t,n,e),r) =
        error r env ("const declaration for "^n^" is cyclic")
    in
        List.iter report decls      
@

The [[doConst]] function sorts and processes constant declarations.
Depending on its [[scope]] parameter the declared names get the
respective scope in [[env]]; an enlarged [[env]] is returned.

<<>>=
let doConst scope env dd =
    let rec bindAll env dd =
        try
            let dd' = TSort.sort dd                              in
            doConstDecls scope env dd'
        with TSort.Cycle(offending) ->
            let dd'   = exclude dd offending                     in
            let env'  = bindError scope env offending            in
                ( reportCycle env offending
                ; bindAll env' dd'
                )
                                                                 in
        bindAll env dd
@

Procedures open a new scope where they declare they own types and
constants. These are processed by [[doLocalConst]] which is called
during the check of the static semantics below.

<<>>=
let doGlobalConst env program = 
        doConst F.Global env (Collect.foldGlobalConstDecls program)
let doLocalConst  env body    = 
        doConst F.Local env (Collect.foldLocalConstDecls body)
@

% ------------------------------------------------------------------ 
\subsection{Checking the static semantics}
% ------------------------------------------------------------------ 

After all global names for types and values are bound in the fat
environment the static semantics can be checked.  This essentially
means to walk over the abstract syntax and check all the constraints
defined by the static semantics.  In case of an error we like to
report it but continue to check the rest of a program.  The success of
a check is therefore expressed by an [[Error.error]] value.

<<checking the static semantics>>=
module Semantics = struct
    <<utilities>>
    <<type check expression>>
    <<check>>
end
@

Alignments must be a power of two. This predicates is true, iff its argument
is a positive power of two.

<<utilities>>=
let rec is2power = function
    | 1 -> true
    | x -> x > 0 && (x mod 2) = 0 && is2power (x/2)
@

% ------------------------------------------------------------------ 
\subsubsection{Expression types}
% ------------------------------------------------------------------ 

Expressions are type checked.  In [[ValueEnv.Eval]] constant
definitions were already type checked and there is some code for this. 
But the evaluation of constants interlaced type checking and
evaluations. It is easier and cleaner to implement the type checking
functions again.

<<type check expression>>=
let rec tyFetch : F.env -> A.lvalue -> F.ty E.error = fun env -> function
    | A.LValueAt(x,r) -> E.catch (error r env) (tyFetch env) x
    | A.Var(hint,id)  -> snd (E.Lower.pair (F.findv' id env))
    | A.Mem (t,e,a)   -> 
        let te    = tyExpr env e in
        let t'    = evalTy env t in
        let align = match a with
                    | None   -> 1 (* wrong! bits / memsize *)
                    | Some a when is2power a -> a
                    | Some a -> E.error "alignment not a power of 2"
        in
            E.matchPair (te, te) 
            ( function
            | te, t' when te = Types.data -> t'
            | otherwise -> E.error "memory reference by non-data pointer"
            )
<<>>=        
 (* tyAppl: Types.tyscheme -> Types.ty list E.error -> Types.ty E.error *)
and tyAppl opTy argTys = E.emap (Types.appl opTy) argTys
@

For now we are using the types of the primitive constant operators. 
All primitive runtime operators will go into their own module
[[Primitives]].  So we have to fix the [[lookup]] later.

<<>>=
and tyPrimOp env op args =
    let at = List.map (tyExpr env) args                  in
    let ot = snd (Const.Symbol.lookup op Const.constOps) in
        tyAppl ot (E.Raise.list at)

<<>>=
 (* tyExpr: F.env -> A.expr -> Types.ty E.error *)
and tyExpr env = function
    | A.ExprAt(x,r) -> E.catch (error r env) (tyExpr env) x
    | A.Int   (str, Some t)          -> evalTy env t
    | A.Int   (str, None)            -> E.Ok(T.word     )
    | A.Float (str, Some t)          -> evalTy env t
    | A.Float (str, None)            -> E.Ok(T.word     )
    | A.Char  (str, Some t)          -> evalTy env t
    | A.Char  (str, None)            -> E.Ok(T.word     )
    | A.Fetch (v)                    -> tyFetch env v
    | A.BinOp (l,op,r)               -> tyPrimOp env op [l;r]
    | A.UnOp  (op,expr)              -> tyPrimOp env op [expr]
    | A.PrimOp(op,args)              -> tyPrimOp env op (List.map snd args)
@

% ------------------------------------------------------------------ 
\subsubsection{Checking the static semantics}
% ------------------------------------------------------------------ 

Checking the static semantics really starts here.  We traverse the
abstract syntax and check all the constrains.  The overall result is
either [[E.Ok()]] or [[E.Error]].  The reduce the correctness of a
complex object to a single result we employ the [[Error.Implode]]
module heavily.

To evaluate constant expressions we use the code from
[[ValueEnv.Eval]]:

<<check>>=
let constExpr env e = ValueEnv.Eval.evalExpr env e
@    

Here is a function to check for a type and report an error in case of
a mismatch.

<<>>=
let isTy t msg = E.emap (fun t' -> if t=t' then () else E.error msg) 
@

Initial values for memory must be either compile-time constants or
link-time constants.  Currently we only check the types which is not
enough; have to fix this.

<<>>=
let rec init env = function
    | A.InitAt(x,_)   -> init env x
    | A.InitExprs(es) -> E.Raise.list (List.map (tyExpr env) es)
    | A.InitStr(s)    -> E.Ok ([Types.char])
    | A.InitUStr(s)   -> E.Ok ([Types.uchar])
@

By default, memory for for value is reserved. When an explicit size is
given, it must be positive.

<<>>=
let memsize env = function
    | A.NoSize    -> E.Ok(Some 1)
    | A.DynSize   -> E.Ok(None)
    | A.FixSize e -> E.ematch (ValueEnv.Eval.evalExpr env e)
        ( function
        | Types.Bits(x), size
          when Const.val2i size > 0 -> Some (Const.val2i size)
        | otherwise                 -> E.error "invalid size"   
        ) 
@
A memory declaration has a type, a type, and optionally a number of
expressions to initialize the memory.  The number of expressions must
match the size specification, and the type of the expressions must
match the declared type.

<<>>=
let memdecl env ty size = function 
    | None     -> E.Implode.pair (memsize env size, evalTy env ty)
    | Some (i) -> E.combine (E.matchPair (init env i, evalTy env ty)
        ( function 
        | tys, ty' ->
            let n           = List.length tys in
            let consistent  = foldl (fun res t -> res && ty' = t) true tys in
            if not consistent then
                E.error "initial values have types different than declared type" 
            else E.ematch (memsize env size) 
               ( function  
               | Some m when n > m -> E.error "too many initial values"
               | Some m when n < m -> E.error "too few  initial values"
               | Some m            -> ()
               | None              -> ()
               )
        ))
@
Labels must not be processed because they have been already entered
into the environment during previous steps.  Alignments ([[memsize]]
units) must be a power of two.
        
<<>>=
let rec datum env = function
    | A.DatumAt(x,r)   -> E.catch (error r env) (datum env) x
    | A.Label(n)       -> E.Ok ()
    | A.Align(a)       -> if is2power a then E.Ok () else 
                          E.error ("illegal alignment: " ^ string_of_int a)
    | A.MemDecl(t,m,i) -> memdecl env t m i
@

A stackdatum must not specify an expression to initialize memory.
Alignments must be a power of two.

<<>>=
let rec stackdatum env = function
    | A.DatumAt(x,r)      -> E.catch  (error r env) (stackdatum env) x
    | A.Label(n)          -> E.Ok() (* should be in env *)
    | A.Align(a)          -> if is2power a then E.Ok() else 
                             E.error ("illegal alignment: " ^ string_of_int a)
    | A.MemDecl(t,m,None) -> memdecl env t m None 
    | A.MemDecl(t,m,_   ) -> E.error "no initial values allowed for stackdata"
@

A [[goto]] target must have local scope and the native code pointer
type.

<<>>=
let checkGotoTarget env x = 
    E.ematch (E.Raise.right (F.findv x env)) 
    ( function 
    | F.Local , (F.Label(F.Code),_) -> ()
    | F.Global, (F.Label(F.Code),_) -> E.error (x^" not a local label")
    | _       , (F.Label(_)     ,_) -> E.error (x^" is not a goto label")
    | otherwise                     -> E.error (x^" is not a label")
    )
@

A call-target must be either a procedure, or an imported symbol with
the native code pointer type.
    
<<>>=
let checkCallTarget env x =
    E.ematch (E.Raise.right (F.findv x env))
    ( function
    | _       ,(F.Label(F.Proc),_) ->  ()
    | _       ,(F.Import       ,t) 
      when t = Types.code          ->  ()
    | otherwise                    ->  E.error (x^" is not call target")
    )

<<>>=
let gotoTargets env ts = E.Implode.map (checkGotoTarget env) ts 
let callTargets env ts = E.Implode.map (checkCallTarget env) ts 
@

A [[also cuts to]] target must be a local continuation.

<<>>=
let checkFlowTarget env x =
    E.ematch (E.Raise.right (F.findv x env))
    ( function
    | F.Local, (F.Continuation,_) -> ()
    | _      , (F.Continuation,_) -> assert false
    | _                           -> E.error (x^" is not a continuation")
    ) 
@
The flow annotations [[returns to]] and [[unwinds to]] is meaningless when
used to annotate a [[cuts to]] statement. We are checking a [[cut to]] 
statement when [[isCutTo]] is true.

<<>>=
let rec flow isCutTo env = function
    | A.FlowAt(x,r)     -> E.catch (error r env) (flow isCutTo env) x
    | A.CutsTo(ns)      -> E.Implode.map (checkFlowTarget env) ns 
    | A.UnwindsTo(ns)   -> 
        if isCutTo then E.error "unwinds is meaningless for cut to" 
        else E.Implode.map (checkFlowTarget env) ns 
    | A.ReturnsTo(ns)   -> 
        if isCutTo then E.error "returns is meaningless for cut to"
        else E.Implode.map (checkFlowTarget env) ns 
    | A.Aborts          -> E.Ok ()

let flows isCutTo env fs = E.Implode.map (flow isCutTo env) fs
@

The [[isLabel env e]] function returns [[true]] if the expression
[[e]] denotes a statically known address. This means it must be a
label or an imported symbol.

<<>>=
let rec isLabel env = function
    | A.ExprAt(x,_)                     -> isLabel env x
    | A.Fetch(A.LValueAt(x,_))          -> isLabel env (A.Fetch x)
    | A.Fetch(A.Var(_,x))               -> 
          ( match F.findv x env with
          | _       ,E.Error            -> false
          | scope   ,E.Ok(F.Label(_),_) -> true
          | scope   ,E.Ok(F.Import,_)   -> true
          | _                           -> false
          )        
    | _                                 -> false
@

An \textit{lvalue} must be a memory location or a register.  We check
the types of both sides of an assignment and therefore return the type
of the \textit{lvalue}.  The results of a call can be only assigned to
registers, but not memory.  A register can be identified by its
[[denotation]].  Registers may carry hints when used to receive values
returned by a call but not otherwise.  References to memory in a
call-context case are an error. 

<<>>=
let lvalue context env lv =
    let memsize = match F.findMemsize env with
        | Some n -> n
        | None   -> assert false (* user defined or default *) in
    let align = function
        | Some a when not (is2power a)  -> E.error "alignment not a power of 2"
        | Some _ (* properly aligned *) -> E.Ok()
        | None                          -> E.Ok()              in
    let multiMemsize = function
        | Types.Bits(m) -> (m mod memsize) = 0
        | _             -> assert false
    in 
    let rec f = function 
    | A.LValueAt (lv, r)   -> E.catch (error r env) f lv
    | A.Var(Some hint, name) 
           when context <> Call -> E.error "no hint allowed in this context"
    | A.Var(hint,name) -> E.ematch (E.Raise.right (F.findv name env))
        ( function
        | _, (F.Register,t) -> t
        | _, _              -> E.error ("not a register: "^name)
        )
    | A.Mem(t, e, a) when context <> Assign  -> E.error ("not a register") 
    | A.Mem(t, e, a) -> E.matchTriple (tyExpr env e, evalTy env t, align a) 
        ( function  
        | te, t, () when not (multiMemsize t) ->
            E.error "type must be a mutiple of target memsize (typically bits8,16,24..)"
        | te, t, () when te = T.data          -> t         
        | te, t, () -> E.error "expression is not a data pointer"
        )
    in
        f lv
@

An [[if]] expression must have type [[bool]].

<<>>=
let rec ifStmt env e ss1 ss2 =
    let seq f x = E.sequence x f in
    seq (tyExpr env e) 
    ( function 
    | ty when ty = T.bool -> E.Implode.pair (stmts env ss1, stmts env ss2)
    | otherwise           -> E.error "if-condition must be of type bool"
    )
@
The key of a span must a native word type, the value a link-time native
data pointer. We only check the types, which is not enough.
     
<<>>=
and spanStmt env e1 e2 bb =
    let msg1 = "span key must be of the native word type"      in 
    let msg2 = "span value must be of the native data pointer type" in
        E.Implode.triple ( E.ematch (constExpr env e1) 
                           ( fun (t,v) ->
                             if t=T.word then ()
                             else E.error msg1
                           )
                         , E.ematch (constExpr env e2)
                           ( fun (t,v) ->
                             if t=T.data then ()
                             else E.error msg2
                           )  
                         , E.Implode.map (body env) bb
                         )
@ 

The target list of a [[goto]] statement may be empty only if the
expression is a label. The [[goto]] expression must have a native code
pointer type.
                         
<<>>=
and gotoStmt env e ts = 
    let t' = gotoTargets env ts in
    let e' = E.ematch (tyExpr env e)
        ( function 
        | t when t = T.code -> ()
        | _  -> E.error "goto-expression does not evaluate to a code pointer" 
        )
    in 
        match ts, isLabel env e with
        | [], false   -> E.error "must specify a target list"
        | _           -> E.Implode.pair (e',t')
@

A [[cut to]] expression must have a contiuation type.

<<>>=
and cutStmt env e args fs =
    let f    = flows true env fs in
    let args = List.map (tyExpr env) (List.map snd args) in
    let nt   = E.ematch (tyExpr env e) 
                ( function 
                | t when t = Types.cont -> ()
                | otherwise  -> E.error "expression not of continuation type"
                )
    in
        E.Implode.triple (f,E.Raise.list args,nt)

<<>>=    
and jumpStmt env cc e args ts =
    let t    = callTargets env ts in
    let args = List.map (tyExpr env) (List.map snd args) in
    let et   = E.ematch (tyExpr env e) 
                ( function 
                | t when t = T.code  -> ()
                | otherwise -> E.error "jump target is not a pointer"
                )
    in
        if ts = [] && not (isLabel env e) then
            E.error "a target annotation for this jump is missing"
        else 
            E.Implode.triple (t,E.Raise.list args, et)

<<>>=
and contStmt env n ns = 
    let check n = E.ematch (E.Raise.right (F.findv n env))
        ( function  
        | F.Local , (F.Register,_) -> ()
        | F.Global, (F.Register,_) -> E.error (n^" is not local")  
        | otherwise                -> 
                E.error ("formal continuation parameter not a register: "^n)
        )
    in
        E.Implode.list (List.map check ns)
@

A [[return]] may specify alternate return continuations.  The
expressions $e_1/e_2$ must be both of the native word type and $0 \leq
e1 \leq e_2$.

<<>>=
and returnStmt env cc alt args =
    let args  = List.map snd args  in
    let tys   = E.Implode.list (List.map (tyExpr env) args) in
    let f     = function (tx, x),(ty, y) ->
                      tx = T.word 
                   && ty = T.word 
                   && Const.val2i x >= 0 
                   && Const.val2i y >= 0 
                   && Const.val2i x <= Const.val2i y
    in 
        match alt with
        | None         -> tys
        | Some (e1,e2) -> let e1' = constExpr env e1 in
                          let e2' = constExpr env e2 in
                          ( E.combine (E.matchPair (e1',e2') 
                            ( function 
                            | x when f x -> tys
                            | otherwise  -> E.error "illegal <x/y> combination"
                            ))
                          )
@

An assignment must provide storage on the left hand side for every
value on the right.  The type of a storage and the associated
expression on the right hand side must match.  The details of the
[[Assign]] context are handled by [[lvalue]]. 

<<>>=
and assignStmt env (lvalues,exprs) =
    let pairs = try List.combine lvalues exprs
                with Invalid_argument _ -> 
                E.error "length of lhs/rhs in assignment differs"
    in
    let pair (lhs,expr) =  
        E.matchPair (lvalue Assign env lhs, tyExpr env expr) 
        ( function 
        | t, te when t = te -> ()
        | otherwise         -> E.error "type mismatch in assignment"
        )
    in
        E.Implode.map pair pairs
@

A call must name targets, unless its expression is a label or import.
In any case must the expression have a native code pointer type.
The details of the assignment in a [[Call]] context are handled by
[[lvalue]].
 

<<>>=
and callStmt env (l,cc,e,args,ts,fs) =
    let lt      = E.Implode.map (lvalue Call env) l in
    let ts'     = callTargets env ts                    in
    let fs'     = flows false env fs                in
    let args'   = List.map snd args                 in
    let argsTy  = E.Implode.map (tyExpr env) args'  in
    let seq f x = E.sequence x f                    in    
        if ts = [] && not (isLabel env e) then
            E.error "a target annotation for this call is missing"
        else seq (tyExpr env e) 
        ( function 
        | t when t = T.code -> E.Implode.quad (lt,ts',fs',argsTy)
        | otherwise         -> E.error "call-expression is not a pointer"
        )
@

A call of a promitive is type checked: argument types must have the
expected types. This is done by [[Types.appl]]. The type for the
primitive is currently taken from [[Const.constOps]] but this will
change. 
             
<<>>=
and primStmt env (l,cc,op,args,fs) =
    let l      = E.Implode.map (lvalue PrimCall env) l           in
    let fs     = flows false env fs                          in
    let opTy   = snd (Const.Symbol.lookup op Const.constOps) in
    let args'  = List.map snd args                           in
    let argsTy = List.map (tyExpr env) args'                 in
    let rTy    = tyAppl opTy (E.Raise.list argsTy)           in
        E.Implode.triple (l,fs,rTy)
@

The type of range-expressions must match the type of the [[switch]]
expression. 

<<>>=
and range t env = function
    | A.Point(e)     -> E.ematch (constExpr env e)
        ( function
        | (t',v) when t=t' -> ()
        | otherwise -> E.error "Range type does not match expression type"
        )

    | A.Range(e1,e2) -> 
        E.matchPair (constExpr env e1, constExpr env e2) 
        ( function 
        | (t1,v1), (t2,v2) when t1=t && t2=t -> ()
        | otherwise -> E.error "Range type does not match expression type"
        )
@
All ranges that guard a [[switch]] arm must match the type of the
[[switch]]-expression
        
<<>>=        
and arm t env = function
    | A.ArmAt(x,r)   -> E.catch (error r env) (arm t env) x
    | A.Case(rr, ss) ->
        let ss' = stmts env ss in 
        let rr' = E.Implode.map (range t env) rr in
            ( match rr with 
            | [] -> E.error "must specify range for this arm"
            | _  -> E.Implode.pair (rr',ss')
            )
@

The type of the switch expression must be matched by the guarding
ranges of the arms.  An empty switch-statement is an error because no
arm can match the value of the switch-expression at run-time.

<<>>=                
and switchStmt env (r, expr, arms) =
    let f t = match r with
        | Some r -> E.Implode.pair ( E.Implode.map (arm t env) arms
                                   , range t env r
                                   ) 
        | None   -> E.Implode.map (arm t env) arms in
    let r = E.sequence f (tyExpr env expr) in
        if arms = [] then
            E.error "empty switch statement"
        else r    
@

The [[body]] function checks the body of procedures which contains
declrations and statements.

<<>>=
and body env = function
    | A.BodyAt(x, r) -> E.catch (error r env) (body env) x
    | A.DeclBody(d)  -> decl env d
    | A.DataBody(dd) -> E.Implode.map (stackdatum env) dd 
    | A.StmtBody(s)  -> stmt env s       
@

A label-statement requires no processing because it has been
previously enterend into the environment.

<<>>=
and stmt env = function
    | A.StmtAt(x,r)                 -> E.catch (error r env) (stmt env) x
    | A.IfStmt ( e, ss1, ss2)       -> ifStmt env e ss1 ss2
    | A.SpanStmt(e1,e2,ss)          -> spanStmt env e1 e2 ss
    | A.AssignStmt(xs)              -> assignStmt env xs
    | A.CallStmt call               -> callStmt env call
    | A.PrimStmt call               -> primStmt env call
    | A.GotoStmt(e,ts)              -> gotoStmt env e ts
    | A.CutStmt(n, args, fs)        -> cutStmt env n args fs
    | A.ReturnStmt(cc, alt, args)   -> returnStmt env cc alt args
    | A.JumpStmt(cc,e,args,ts)      -> jumpStmt env cc e args ts
    | A.ContStmt(n,ns)              -> contStmt env n ns
    | A.LabelStmt(n)                -> E.Ok ()
    | A.EmptyStmt                   -> E.Ok ()
    | A.SwitchStmt switch           -> switchStmt env switch         
<<>>=
and stmts env ss = E.Implode.map (stmt env) ss
@

Registers, continuations, and stack-labels can't be exported, all
other labels can. An optionally declared type must match the actual
type of the exported symbol.

<<>>=
and export' env = function
    | None, name   -> 
        E.ematch (F.findv' name env)
        ( function
        | F.Label(F.Proc),    _ -> ()
        | F.Label(F.Code),    _ -> ()
        | F.Label(F.Data),    _ -> ()
        | _                   -> E.error (name^" can't be exported")
        )
    | Some t, name -> 
        E.matchPair (F.findv' name env, evalTy env t)
        ( function
        | (F.Label(F.Proc),t), t' when t = t' -> ()
        | (F.Label(F.Code),t), t' when t = t' -> ()
        | (F.Label(F.Data),t), t' when t = t' -> ()
        | (F.Label(F.Proc),_), _ 
        | (F.Label(F.Data),_), _ 
        | (F.Label(F.Code),_), _  -> E.error (name^" has not declared type")
        | _                       -> E.error (name^" can't be exported")
           
        )

and export env t ns = E.Implode.map (fun (n,_) -> export' env (t,n)) ns
@

Declarations have already been processed. 

<<>>=
and decl env = function
    | A.DeclAt(x,r)        -> E.catch (error r env) (decl env) x
    | A.Import( t, ns)     -> E.Ok()
    | A.Export( t, ns)     -> export env t ns
    | A.Const (t,n,e)      -> E.Ok()
    | A.Registers( rs)     -> E.Ok()
    | A.Typedef (t,nn)     -> E.Ok()
    | A.Target (arch)      -> E.Ok()
    | A.Pragma             -> E.Ok()
@

Formal parameters are entered with local scope into the environment
when a procedure is checked.

<<>>=
and formal env (hint, inv, ty, name) =
    match evalTy env ty with
    | E.Ok(t) -> F.bindv name F.Local (E.Ok(F.Register,t)) env 
    | E.Error -> F.bindvError name F.Local env
@

A procedure opens a new scope.  First all local type, value, and
constant declarations must be entered into the environment, as well as
formal parameters.  It should not matter whether formal parameters are
entered before or after values and types.
    
<<>>=
and proc env (cc, name, ff, bb) =
    let env = foldl formal env ff                     in 
    let env = TypeEnv.doLocalTypes env bb             in
    let env = ValueEnv.Bind.locals env bb             in
    let env = ValueEnv.Eval.doLocalConst env bb in
        E.Implode.map (body env) bb            


<<>>=
and section env = function    
    | A.SectionAt(x,r)     -> E.catch (error r env) (section env) x
    | A.Decl(d)            -> E.Ok()
    | A.Datum( d)          -> datum env d
    | A.Procedure(p)       -> proc env p
    | A.SSpan( e1, e2, ss) -> E.Ok()
<<>>=
let rec toplevel env = function
    | A.ToplevelAt(x, r)   -> E.catch (error r env) (toplevel env) x
    | A.Section(name, ss)  -> E.Implode.map (section env) ss 
    | A.TopDecl(d)         -> decl env d
    | A.TopProcedure(p)    -> proc env p 
@

The [[program]] function is the entry point to check the static
sementics of a program \emph{after} the environment has been enlarged
with all global symbols.
    
<<>>=
and program env tt = E.Implode.map (toplevel env) tt
@

