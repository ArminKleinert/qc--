% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Back end for the SPARC}

Required as part of the interface: postexpander, target, and variable
placer.  May add other pieces as required by the recognizer (the main
client of this module).
<<sparc.mli>>=
module X : Expander.S
val target: Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@ 
<<sparc.ml>>=
module PX = Postexpander
module S  = Space
module SS = S.Standard32
module R  = Rtl
module RU = Rtlutil
module Up = R.Up
module Dn = R.Dn
module RP = R.Private
module SM = Strutil.Map
module A  = Automaton
module T  = Target

let rtl r = PX.Rtl r
let (<:>) = PX.(<:>)
let rstore l r w = rtl (R.store l r w) 
let astore l r w = rtl (A.store l r w) 
@ 
<<sparc.ml>>=
let byteorder = R.BigEndian
let wordsize  = 32
@ 
% ------------------------------------------------------------------
\subsection{Storage spaces}
% ------------------------------------------------------------------
<<sparc.ml>>=
module Spaces = struct
  let id = R.Identity
  <<SPARC spaces>>
end
@ [[m]] is a big-endian memory space with byte, halfword, word, and
doubleword accesses.
<<SPARC spaces>>=
  let m = SS.m byteorder [8; 16; 32]
@ [[r]] is the general purpose integer register file with 32-bit
registers.  Some of these may be managed specially by register
windows.  Nyarggg.  We pretend that it's actually split between 32 and
64 bit registers.
<<SPARC spaces>>=
  let r = SS.r 32 id [32]
@ [[f]] is the general purpose floating-point register file with 32
32-bit registers.  Unlike the [[r]] space, these are all globals.
(We have lies and more lies!!!)
<<SPARC spaces>>=
  let f = S.checked { S.space          = ('f', Rtl.Identity, Cell.of_size 32)
                    ; S.doc            = "floating-point registers"
                    ; S.cellwidth      = 32
                    ; S.indexwidth     = 32
                    ; S.indexlimit     = Some 8
                    ; S.aggregation    = Rtl.Identity
                    ; S.widths         = [32]
                    ; S.classification = S.Reg
                    }

  let x = S.checked { S.space           = ('x', Rtl.Identity, Cell.of_size 64)
                    ; S.doc            = "64-bit floating-point registers"
                    ; S.cellwidth      = 64
                    ; S.indexwidth     = 32
                    ; S.indexlimit     = Some 8
                    ; S.aggregation    = Rtl.Identity
                    ; S.widths         = [64]
                    ; S.classification = S.Reg
                    }

(*
 let f = SS.f 32 id [32]
*)
@ [[t]] is the temporary space for the [[r]] space.
<<SPARC spaces>>=
  let t = SS.t    id [32]
@ [[u]] is the temporary space for the [[f]] space.
<<SPARC spaces>>=
  let u = S.checked { S.space          = ('u', 
                                          Rtl.Identity, (* Rtl.BigEndian, *)
                                          Cell.of_size 32)
                    ; S.doc            = "floating-point temporaries"
                    ; S.cellwidth      = 32
                    ; S.indexwidth     = 32
                    ; S.indexlimit     = None
                    (* ; S.aggregation    = Rtl.BigEndian *)
                    ; S.aggregation    = Rtl.Identity
                    ; S.widths         = [32]
                    ; S.classification =
                        S.Temp { S.stands_for = f.S.space
                               ; S.index_ok   = (fun _ -> true) (* lies *)
                               ; S.set_doc    = "floating-point temporaries"
                               }
                    }

  let q = S.checked { S.space          = ('q', Rtl.Identity, Cell.of_size 64)
                    ; S.doc            = "64-bit floating-point temporaries"
                    ; S.cellwidth      = 64
                    ; S.indexwidth     = 32
                    ; S.indexlimit     = None
                    (* ; S.aggregation    = Rtl.BigEndian *)
                    ; S.aggregation    = Rtl.Identity
                    ; S.widths         = [64]
                    ; S.classification =
                        S.Temp { S.stands_for = x.S.space
                               ; S.index_ok   = (fun _ -> true) (* lies *)
                               ; S.set_doc    = "64-bit floating-point temporaries"
                               }
                    }

(*
  let u = SS.u    id [32]
*)
@ [[c]] is the space for condition codes and the program counter.
<<SPARC spaces>>=
  let c = SS.c  6 id [32]  (* pc, npc, cc, ???, fp_mode, fp_fcmp *)
@ [[k]] is the space for register windows.  The first cell represents
the CWP (current window pointer), which is just a counter that we
increment and decrement when saving and restoring windows.  The rest
of the space will eventually be used to represent saved window
registers.
<<SPARC spaces>>=
  let k = S.checked { Space.space          = ('k', Rtl.Identity, Cell.of_size 32)
                    ; Space.doc            = "register windows"
                    ; Space.cellwidth      = 32
                    ; Space.indexwidth     = 32     (* what is indexwidth? *)
                    ; Space.indexlimit     = Some 1
                    ; Space.aggregation    = Rtl.Identity
                    ; Space.widths         = [32]
                    ; Space.classification = Space.Fixed
                    }
@ 
% ------------------------------------------------------------------
\subsection{Registers}
% ------------------------------------------------------------------
<<sparc.ml>>=
let locations = SS.locations Spaces.c
let pc        = locations.SS.pc
let cc        = locations.SS.cc
let npc       = locations.SS.npc
(* Do we use this?
   let fp_mode = locations.SS.fp_mode
   let fp_fcmp = locations.SS.fcmp
*)
let vfp     = Vfp.mk wordsize

let mcell = Cell.of_size 8
let mspace = ('m', Rtl.BigEndian, mcell)
let rspace = ('r', Rtl.BigEndian, Cell.of_size 32)
let fspace = ('f', Rtl.Identity, Cell.of_size 32)
let xspace = ('x', Rtl.Identity, Cell.of_size 64)
let dspace = ('d', Rtl.Identity, Cell.of_size 2)  (* rounding modes *)

let r n  = (rspace, n, R.C 1)

let zero = r 0  (* always zero, r[0] is sames as global[0] *)
let ra   = r 31 (* return address set by CALL instruction, same as %o7 *)

let fp   = r 30 (* conventionally the same as %fp or %i6 *)
let sp   = r 14 (* conventionally the same as %sp or %o6 *)

let cwp  = (('k', Rtl.Identity, Cell.of_size 32), 0, R.C 1)

let rounding_modesl   = Rtl.reg (dspace, 0, R.C 1)
let rounding_resultsl = Rtl.reg (dspace, 1, R.C 1)
@ 
% ------------------------------------------------------------------
\subsection{Utilities}
% ------------------------------------------------------------------
<<sparc.ml>>=
let imposs      = Impossible.impossible
let unimpf  fmt = Printf.kprintf Impossible.unimp fmt
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let mem w addr = R.mem R.none mspace (Cell.to_count mcell w) addr
let reg_width  = Register.width

let rfetch t = R.fetch (R.reg t) (Register.width t)
@ 
% ------------------------------------------------------------------
\subsection{Control flow}
% ------------------------------------------------------------------
<<sparc.ml>>=
module F = Mflow.MakeStandard
    (struct
      let pc_lhs    = npc
      let pc_rhs    = pc
      let ra_reg    = R.reg ra
      let ra_offset = 4
    end)
@ 
<<sparc.ml>>=
let return e =
  let one = R.bits (Bits.S.of_int 1 32) 32 in
  R.par [R.store npc e wordsize;
         R.store (R.reg cwp) (R.app (R.opr "add" [32]) [rfetch cwp; one]) wordsize]
@ 
% ------------------------------------------------------------------
\subsection{Postexpander}
% ------------------------------------------------------------------
<<sparc.ml>>=
module Post = struct
  let byte_order = byteorder
  let wordsize   = wordsize
  module Address = struct
    type t    = R.exp
    let reg r = R.fetch (R.reg r) (Register.width r) 
  end
  type temp      = Register.t
  type rtl       = R.rtl
  type width     = R.width
  type assertion = R.assertion
  type operator  = RP.opr
  <<SPARC postexpander>>
  include Postexpander.Nostack(Address)
end
@ 
Our allocators.
<<SPARC postexpander>>=
let talloc = Postexpander.Alloc.temp
let salloc = Postexpander.Alloc.slot
@ 
There is some nasty cheating going on regarding the [['o']] registers.
(And what about [['l']], [['i']], \ldots?)
<<SPARC postexpander>>=
type context = (Talloc.Multiple.t -> int -> Register.t) * (Register.t -> bool)

let icontext =
  Talloc.Multiple.reg 't',
  fun ((c,_,_), _, _) -> c =<= 'r' || c =<= 't' || c =<= 'o'

let fcontext = (* Talloc.Multiple.reg 'u', fun (c, _, _) -> c =<= 'f' || c =<= 'u' *)
  (fun t w ->
    if w = 32 then Talloc.Multiple.reg 'u' t 32
    else Talloc.Multiple.reg 'q' t 64), 
  fun ((c,_,_), _, _) -> c =<= 'f' || c =<= 'u' || c =<= 'x' || c =<= 'q'
let acontext = icontext
let rcontext = (fun x y -> unimpf "Unsupported soft rounding mode")
               ,fun ((sp,_,_), i, _) -> sp =<= 'd' && i = 0
let itempwidth = 32
@ 
<<SPARC postexpander>>=
let load ~dst ~addr assn =
  let w = reg_width dst in
  assert (w = wordsize || w = wordsize * 2); 
  rtl (R.store (R.reg dst) (R.fetch (mem w addr) w) w)
@ 
<<SPARC postexpander>>=
let store ~addr ~src assn =
  let w = reg_width src in
  assert (w = wordsize || w = wordsize * 2);
  rtl (R.store (mem w addr) (rfetch src) w)
@ 
<<SPARC postexpander>>=
let extend  op n w e = R.app (R.opr op       [n; w]) [e]
let lobits     w n e = R.app (R.opr "lobits" [w; n]) [e]
let xload op ~dst ~addr n assn =
  let w = reg_width dst in
  assert (w = wordsize || w = wordsize * 2); 
  rtl (R.store (R.reg dst)
        (extend op n w (R.fetch (R.mem assn mspace (Cell.to_count mcell n) addr) n)) w)

let sxload = xload "sx"
let zxload = xload "zx"

let lostore ~addr ~src n assn =
  let w = reg_width src in
  assert (w = wordsize || w = 2 * wordsize);
  rtl (R.store (R.mem assn mspace (Cell.to_count mcell n) addr)
               (lobits w n (rfetch src)) n)
@ Block copies are only implemented in powers of 2 up to 64~bytes.
IT'S NOT CLEAR WHY THE 64-BIT CASE DOESN'T USE [[load]] AND [[store]].
<<SPARC postexpander>>=
let block_copy ~dst dassn ~src sassn w =
  match w with
  | 8 | 16 ->
      let t = talloc 't' 32 in
      zxload t src w sassn <:> lostore dst t w dassn
  | 32 ->
      let t = talloc 't' 32 in
      load t src sassn <:> store dst t dassn
  | 64 ->
      let q = talloc 'q' 64 in
      rstore (R.reg q) (R.fetch (mem w src) w) w <:>
      rstore (mem w dst) (rfetch q) w
  | _  -> unimpf "general block copies on SPARC"
@ 
We write very strange code in [[if]] in case of the possibility that a
temporary is \emph{neither} a float nor an integer.
<<SPARC postexpander>>=
let is_int   = snd icontext
let is_float = snd fcontext
let move ~dst ~src =
  let w = reg_width src in
  assert (w = reg_width dst);
  if (if is_int src then is_float dst else is_float src && is_int dst) then
    (* move through stack *)
    let slot = salloc w in
    rtl (A.store slot (rfetch src) w) <:> rtl (R.store (R.reg dst) (A.fetch slot w) w)
  else if Register.eq src dst then
    PX.Nop
  else
    rtl (R.store (R.reg dst) (rfetch src) w)
@ 
<<SPARC postexpander>>=
let li  ~dst const =
  match dst, const with
  | (('u', _, _), _, R.C 1), _ -> (* we are forced to go through memory *)
      let t = talloc 't' 32 in
      let slot = salloc 32 in
      rstore (R.reg t)   (Up.const const)  32 <:>
      astore slot        (rfetch t)        32 <:>
      rstore (R.reg dst) (A.fetch slot 32) 32
(*
      let offset = R.bits (Bits.S.of_int (23*4) 32) 32 in
      let addr   = R.app (R.opr "add" [32]) [rfetch sp; offset] in
      [ R.store (R.reg dst)    (R.fetch (mem 32 addr) 32) 32
      ; R.store (mem 32 addr) (rfetch t) 32
      ; R.store (R.reg t)      (Up.const const) 32
      ]
*)
  | (('q', _, _), _, R.C 1), RP.Bits b -> (* we are forced to go through memory *)
      Printf.eprintf "Bad idea!!!!\n";
      let t1 = talloc 't' 32 in
      let t2 = talloc 't' 32 in
      let offset1 = R.bits (Bits.S.of_int (24*4) 32) 32 in
      let offset2 = R.bits (Bits.S.of_int (25*4) 32) 32 in
      let addr1   = R.app (R.opr "add" [32]) [rfetch sp; offset1] in
      let addr2   = R.app (R.opr "add" [32]) [rfetch sp; offset2] in
      (* now split the 64-bit literal into high and low 32 bits *)
      let hi = Bits.Ops.lobits 32 (Bits.Ops.shrl b (Bits.U.of_int 32 32)) in
      let lo = Bits.Ops.lobits 32 b in
      rstore (R.reg t1)     (Up.const (RP.Bits hi))     32 <:>
      rstore (mem 32 addr1) (rfetch t1)                 32 <:>
      rstore (R.reg t2)     (Up.const (RP.Bits lo))     32 <:>
      rstore (mem 32 addr2) (rfetch t2)                 32 <:>
      rstore (R.reg dst)    (R.fetch (mem 64 addr1) 64) 64 
  | (('t', _, _), _, R.C 1), _ ->
      rstore (R.reg dst) (Up.const const) 32
  | ((s, _, _), _, _) as r, RP.Bits b ->
      unimpf "loading immediate %s to a %d-bit register in space %%%c"
        (Bits.to_string b) (Register.width r) s
  | ((s, _, _), _, _) as r, _ ->
      unimpf "loading symbolic immediate to a %d-bit register in space %%%c"
        (Register.width r) s
let lix ~dst e = rtl (R.store (R.reg dst) e (reg_width dst))
  (* IS THIS REALLY RIGHT? *)
@ 
What do argmap and resmap actually do??
<<SPARC postexpander>>=
let bcontext = (fun x y -> imposs "allocate from bcontext"), fun _ -> false
let operators = Context.standard icontext fcontext rcontext acontext bcontext

let resmap = List.fold_left (fun m (n,a,r) -> SM.add n r m) SM.empty operators
let argmap = List.fold_left (fun m (n,a,r) -> SM.add n a m) SM.empty operators
@ 
<<SPARC postexpander>>=
let arg_contexts   (n, _) =
  try SM.find n argmap with Not_found -> impossf "arg_context %s failed\n" n
let result_context (n, _) =
  try SM.find n resmap with Not_found -> impossf "result_context %s failed\n" n
let constant_context w = icontext
@ 
<<SPARC postexpander>>=
let unop ~dst op x =
  match op with
  | ("zx", _) | ("sx", _) | ("lobits", _) ->
      impossf "%%%s%d reached sparc postexpander" (fst op) (List.nth (snd op) 1)
  | _ -> rstore (R.reg dst) (R.app (Up.opr op) [rfetch x]) (reg_width dst)

let binop ~dst op x y =
  let dstw = reg_width dst in
  match op with
(* I think this is never used...
  | "f2i", ws ->
      begin match dst, x with
      | ('r', _, _), ('f', _, _) ->
          assert (dstw = 32);
          let ftmp = talloc 'u' dstw in
          let slot = salloc dstw in
          [R.store (R.reg dst) (A.fetch slot) dstw;
           R.store (A.store slot) (rfetch ftmp); 
           R.store (R.reg ftmp) (R.app (Up.opr op) [rfetch x; rfetch y]) dstw]
      | _ -> [R.store (R.reg dst) (R.app (Up.opr op) [rfetch x; rfetch y]) dstw]
      end
*)
  | "modu", ws ->
      rstore (R.reg dst) (R.app (R.opr "divu" ws) [rfetch x; rfetch y])   dstw <:>
      rstore (R.reg dst) (R.app (R.opr "mul"  ws) [rfetch y; rfetch dst]) dstw <:>
      rstore (R.reg dst) (R.app (R.opr "sub"  ws) [rfetch x; rfetch dst]) dstw
  | "rem", ws ->
      rstore (R.reg dst) (R.app (R.opr "quot" ws) [rfetch x; rfetch y])   dstw <:>
      rstore (R.reg dst) (R.app (R.opr "mul"  ws) [rfetch y; rfetch dst]) dstw <:>
      rstore (R.reg dst) (R.app (R.opr "sub"  ws) [rfetch x; rfetch dst]) dstw
  | _ ->
      rstore (R.reg dst) (R.app (Up.opr op) [rfetch x; rfetch y]) dstw

let rtlop ~dst op args =
  rstore (R.reg dst) (R.app (Up.opr op) (List.map rfetch args)) (reg_width dst)
let dblop ~dsthi ~dstlo op x y = Unsupported.mulx_and_mulux()
let wrdop  ~dst op x y z = Unsupported.singlebit ~op:(fst op)
let wrdrop ~dst op x y z = Unsupported.singlebit ~op:(fst op)
@ 
<<SPARC postexpander>>=
let pc_lhs = npc        (* PC as assigned by branch *)
let pc_rhs = pc         (* PC as captured by call   *)
@ 
<<SPARC postexpander>>=
let br ~tgt = PX.Nop, R.store pc_lhs (rfetch tgt)   wordsize  (* branch reg *)
let b  ~tgt = PX.Nop, R.store pc_lhs (Up.const tgt) wordsize  (* branch     *)
@ 
Needs to be filled in
<<SPARC postexpander>>=
let bc x (opr, ws as op) y ~ifso ~ifnot =
  (* Might be a 64-bit float *)
  assert (ws =*= [wordsize] || ws =*= [wordsize*2]);
  PX.Test (rstore cc (R.app (R.opr "sparc_subcc" ws) [rfetch x; rfetch y]) 32,
           (R.app (R.opr ("sparc_"^opr) ws) [R.fetch cc 32], ifso, ifnot))

(* Why won't the following work?  If I try it, I get a runtime error from
   the expander when it tries to call succ on an illegal node! *)
(*
  [ R.guard (R.app (R.opr opr ws) [rfetch x; rfetch y])
            (R.store pc_lhs (Up.const tgt) 32) ]
*)
@ 
<<SPARC postexpander>>=
let bnegate r = 
    let zero   = R.bits (Bits.zero 32) 32 in
    let negate = function
        | "sparc_ne" -> "sparc_eq"
        | "sparc_eq" -> "sparc_ne"
        | "sparc_feq" -> "sparc_fne"
        | "sparc_fne" -> "sparc_feq"
        | _    -> imposs "ill-formed SPARC conditional branch" in
    match Dn.rtl r with
    | RP.Rtl [ RP.App( (("eq"|"ne" as op),[32])
                     , [RP.Fetch(RP.Reg(x),32); RP.Const(RP.Bits(b))]
                     ) 
             , RP.Store (pc, tgt, 32)
             ] when RU.Eq.loc pc (Dn.loc pc_lhs) && Bits.eq b (Bits.zero 32) ->
                 R.guard (R.app (R.opr (negate op) [32]) [rfetch x; zero]) 
                (R.store pc_lhs (Up.exp tgt) wordsize)
    | _ -> imposs "ill-formed SPARC conditional branch"
@ 
<<SPARC postexpander>>=
let effects = List.map Up.effect
let call  ~tgt ~others =
  PX.Nop, R.par (R.store pc_lhs (Up.const tgt) wordsize :: effects others)
let callr ~tgt ~others =
  PX.Nop, R.par (R.store pc_lhs (rfetch tgt)   wordsize :: effects others)
@ 
<<SPARC postexpander>>=
let cut_to effs = PX.Nop, R.par (effects effs)
@ 
If an instruction modifies the current window pointer, it's a save or
restore, and the generic expander must not touch it.
<<SPARC postexpander>>=
let don't_touch_me =
  let stores_to_cwp = function
    | RP.Store (RP.Reg maybe_cwp, _, _) when Register.eq maybe_cwp cwp -> true
    | _                                                                -> false in
  List.exists stores_to_cwp
@ 
% ------------------------------------------------------------------ 
\subsection{Expander}
% ------------------------------------------------------------------ 
<<sparc.ml>>=
module X = Expander.IntFloatAddr(Post)
@ 
% ------------------------------------------------------------------
\subsection{Target}
% ------------------------------------------------------------------
<<sparc.ml>>=
let spill  p t l = (* assert (reg_width t = Rtlutil.Width.loc l); *)
  [A.store l (rfetch t) (reg_width t)]
let reload p t l = 
  let w = reg_width t in [R.store (R.reg t) (A.fetch l w) w]
@ 
<<sparc.ml>>=
let ( *> ) = A.( *> )
let globals base = 
  let width w = if      w <= 8  then 8  
                else if w <= 16 then 16 
                else Aux.round_up_to ~multiple_of:wordsize w in
  let align = function _ -> 8 in
  A.at mspace ~start:base (A.widen width *> A.align_to align *>
  A.overflow ~growth:Memalloc.Up ~max_alignment:16)
@ 
<<sparc.ml>>=
let target =
    let spaces = [ Spaces.m
                 ; Spaces.r
                 ; Spaces.f
                 ; Spaces.x
                 ; Spaces.t
                 ; Spaces.u
                 ; Spaces.q
                 ; Spaces.c
                 ; Spaces.k
                 ] in
    { T.name                = "sparc"
    ; T.memspace            = mspace
    ; T.byteorder           = byteorder
    ; T.wordsize            = wordsize
    ; T.pointersize         = wordsize
    ; T.alignment           = 8             (* sparc 9 *)
    ; T.memsize             = 8
    ; T.spaces              = spaces
    ; T.reg_ix_map          = T.mk_reg_ix_map spaces
    ; T.distinct_addr_sp    = false
    ; T.float               = Float.ieee754
    ; T.spill               = spill
    ; T.reload              = reload

    ; T.vfp                 = vfp
    ; T.bnegate             = F.bnegate cc
    ; T.goto                = F.goto
    ; T.jump                = F.jump
    ; T.call                = F.call
    ; T.return              = F.return
    ; T.branch              = F.branch
    
    ; T.cc_specs            = A.init_cc
    ; T.cc_spec_to_auto     = Sparccall.cconv ~return_to:return
                                   (F.cutto (Rtl.reg sp))

    ; T.is_instruction      = Sparcrec.is_instruction
    ; T.capabilities        = T.incapable
    ; T.globals             = globals
    ; T.rounding_mode       = rounding_modesl (* Rtl.reg rm_reg *)
    ; T.named_locs   = Strutil.assoc2map 
                       ["IEEE 754 rounding mode",    rounding_modesl
                       ;"IEEE 754 rounding results", rounding_resultsl
                       ]
    ; T.data_section        = "data"
    ; T.charset             = "latin1" (* REMOVE THIS FROM TARGET.T *)
    }    
@ 
\subsection{Variable Placement}

If we get a 64-bit variable that is not hinted float, we could put it
in a floating-point temporary, but we're not that aggressive.
<<sparc.ml>>=
let warning s = Printf.eprintf "backend warning: %s\n" s
let placevars = 
  let is_float w hint _ = hint =$= "float" in
  let warn ~width ~alignment ~hint = () in
  let mk_stage ~temps =
    A.choice
      [ is_float,                 A.widen (Aux.round_up_to ~multiple_of: 32)
      ; (fun w h _ -> w <= 32),   A.widen (fun _ -> 32) *> temps 't'
      ; A.is_any,                 A.widen (Aux.round_up_to ~multiple_of: 8)
      ] in
  Placevar.mk_automaton ~warn ~vfp:target.T.vfp ~memspace:mspace mk_stage
@ 
