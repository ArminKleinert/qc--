% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Back end for the SPARC}

Required as part of the interface: postexpander, target, and variable
placer.  May add other pieces as required by the recognizer (the main
client of this module).
<<sparc.mli>>=
module X : Expander.S
val target: Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@ 
<<sparc.ml>>=
module PX = Postexpander
module S  = Space
module SS = S.Standard32
module R  = Rtl
module RO = Rewrite.Ops
module RU = Rtlutil
module Up = R.Up
module Dn = R.Dn
module RP = R.Private
module SM = Strutil.Map
module A  = Automaton
module T  = Target

let rtl r = PX.Rtl r
let (<:>) = PX.(<:>)
let rstore l r w = rtl (R.store l r w) 
let astore l r w = rtl (A.store l r w) 
@ 
<<sparc.ml>>=
let byteorder = R.BigEndian
let wordsize  = 32
@ 
% ------------------------------------------------------------------
\subsection{Storage spaces}
% ------------------------------------------------------------------
<<sparc.ml>>=
module Spaces = Sparcregs.Spaces
@ 
% ------------------------------------------------------------------
\subsection{Registers}
% ------------------------------------------------------------------
<<sparc.ml>>=
let pc  = Sparcregs.pc
let cc  = Sparcregs.cc
let npc = Sparcregs.npc
(* Do we use this?
   let fp_mode = locations.SS.fp_mode
   let fp_fcmp = locations.SS.fcmp
*)
let vfp     = Vfp.mk wordsize

let (_, _, mcell) as mspace = Spaces.m.S.space
let rspace = Spaces.r.S.space
let fspace = Spaces.f.S.space
let dspace = Spaces.d.S.space

let r n  = (rspace, n, R.C 1)

let zero = r 0  (* always zero, r[0] is sames as global[0] *)
let ra   = r 31 (* return address set by CALL instruction, same as %o7 *)

let fp   = r 30 (* conventionally the same as %fp or %i6 *)
let sp   = r 14 (* conventionally the same as %sp or %o6 *)

let cwp = Sparcregs.cwp

let rounding_mode_reg = (dspace, 0, R.C 1)
let rounding_model   = Rtl.reg rounding_mode_reg
let rounding_mode    = R.fetch rounding_model 2
let rounding_resultsl = Rtl.reg (dspace, 1, R.C 1)
@ 
% ------------------------------------------------------------------
\subsection{Utilities}
% ------------------------------------------------------------------
<<sparc.ml>>=
let imposs      = Impossible.impossible
let unimpf  fmt = Printf.kprintf Impossible.unimp fmt
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let mem w addr = R.mem R.none mspace (Cell.to_count mcell w) addr
let reg_width  = Register.width

let rfetch t = R.fetch (R.reg t) (Register.width t)
@ 
% ------------------------------------------------------------------
\subsection{Control flow}
% ------------------------------------------------------------------
<<sparc.ml>>=
module F = Mflow.MakeStandard
    (struct
      let pc_lhs    = npc
      let pc_rhs    = pc
      let ra_reg    = R.reg ra
      let ra_offset = 4
    end)
@ 
<<sparc.ml>>=
let return e =
  let one = R.bits (Bits.S.of_int 1 32) 32 in
  R.par [R.store npc e wordsize;
         R.store (R.reg cwp) (R.app (R.opr "add" [32]) [rfetch cwp; one]) wordsize]
@ 
% ------------------------------------------------------------------
\subsection{Postexpander}
% ------------------------------------------------------------------
<<sparc.ml>>=
module Post = struct
  let byte_order = byteorder
  let wordsize   = wordsize
  module Address = struct
    type t    = R.exp
    let reg r = R.fetch (R.reg r) (Register.width r) 
  end
  type temp      = Register.t
  type rtl       = R.rtl
  type width     = R.width
  type assertion = R.assertion
  type operator  = RP.opr
  <<SPARC postexpander>>
  include Postexpander.Nostack(Address)
end
@ 
Our allocators.
<<SPARC postexpander>>=
let talloc = Postexpander.Alloc.temp
let salloc = Postexpander.Alloc.slot
@ 
There is some nasty cheating going on regarding the [['o']] registers.
For this reason, it is not useful to use [[Context.of_space]] and friends.
(And what about [['l']], [['i']], \ldots?)
<<SPARC postexpander>>=
let icontext =
  Talloc.Multiple.reg 't',
  fun ((c,_,_), _, _) -> c =<= 'r' || c =<= 't' || c =<= 'o'

let fcontext =
  (fun t w ->
    if w = 32 then Talloc.Multiple.reg 'u' t 32
    else Talloc.Multiple.reg 'q' t 64), 
  fun ((c,_,_), _, _) -> c =<= 'f' || c =<= 'u' || c =<= 'q'
let acontext = icontext
let rcontext = (fun x y -> unimpf "Unsupported soft rounding mode")
               ,fun ((sp,_,_), i, _) -> sp =<= 'd' && i = 0
let itempwidth = 32

let operators = Context.nonbool icontext fcontext rcontext []
let arg_contexts, result_context = Context.functions operators
let constant_context w = icontext
@ 
<<SPARC postexpander>>=
let load ~dst ~addr assn =
  let w = reg_width dst in
  assert (w = wordsize || w = wordsize * 2); 
  rtl (R.store (R.reg dst) (R.fetch (mem w addr) w) w)
@ 
<<SPARC postexpander>>=
let store ~addr ~src assn =
  let w = reg_width src in
  assert (w = wordsize || w = wordsize * 2);
  rtl (R.store (mem w addr) (rfetch src) w)
@ 
<<SPARC postexpander>>=
let extend  op n w e = R.app (R.opr op       [n; w]) [e]
let lobits     w n e = R.app (R.opr "lobits" [w; n]) [e]
let xload op ~dst ~addr n assn =
  let w = reg_width dst in
  assert (w = wordsize || w = wordsize * 2); 
  rtl (R.store (R.reg dst)
        (extend op n w (R.fetch (R.mem assn mspace (Cell.to_count mcell n) addr) n)) w)

let sxload = xload "sx"
let zxload = xload "zx"

let lostore ~addr ~src n assn =
  let w = reg_width src in
  assert (w = wordsize || w = 2 * wordsize);
  rtl (R.store (R.mem assn mspace (Cell.to_count mcell n) addr)
               (lobits w n (rfetch src)) n)
@ Block copies are only implemented in powers of 2 up to 64~bytes.
IT'S NOT CLEAR WHY THE 64-BIT CASE DOESN'T USE [[load]] AND [[store]].
<<SPARC postexpander>>=
let block_copy ~dst dassn ~src sassn w =
  match w with
  | 8 | 16 ->
      let t = talloc 't' 32 in
      zxload t src w sassn <:> lostore dst t w dassn
  | 32 ->
      let t = talloc 't' 32 in
      load t src sassn <:> store dst t dassn
  | 64 ->
      let q = talloc 'q' 64 in
      rstore (R.reg q) (R.fetch (mem w src) w) w <:>
      rstore (mem w dst) (rfetch q) w
  | _  -> unimpf "general block copies on SPARC"
@ 
We write very strange code in [[if]] in case of the possibility that a
temporary is \emph{neither} a float nor an integer.
<<SPARC postexpander>>=
let is_int   = snd icontext
let is_float = snd fcontext
let move ~dst ~src =
  let w = reg_width src in
  assert (w = reg_width dst);
  if (if is_int src then is_float dst else is_float src && is_int dst) then
    (* move through stack *)
    let slot = salloc w in
    rtl (A.store slot (rfetch src) w) <:> rtl (R.store (R.reg dst) (A.fetch slot w) w)
  else if Register.eq src dst then
    PX.Nop
  else
    rtl (R.store (R.reg dst) (rfetch src) w)
@ 
<<SPARC postexpander>>=
let extract ~dst ~lsb ~src =
  let w = reg_width src in
  let n = reg_width dst in
  let srcval =
    if lsb = 0 then
      RO.lobits w n (rfetch src)
    else if lsb = 32 then
      RO.lobits w n (RO.shrl w (rfetch src) (RO.unsigned w lsb))
    else
      impossf "bad lsb in sparc extract" in
  if is_int dst && is_float src then
    (* move through stack *)
    let slot = salloc n in
    rtl (A.store slot srcval n) <:> rtl (R.store (R.reg dst) (A.fetch slot n) n)
  else if is_float dst && is_float src then
    rtl (R.store (R.reg dst) srcval n)
  else
    impossf "unexpected extract in sparc postexpander"

let aggregate ~dst ~src = Impossible.unimp "aggregate"
@ 
<<SPARC postexpander>>=
let hwset ~dst ~src = Impossible.unimp "setting hardware register"
let hwget ~dst ~src = Impossible.unimp "getting hardware register"
@ 
<<SPARC postexpander>>=
let li  ~dst const =
  match dst, const with
  | (('u', _, _), _, R.C 1), _ -> (* we are forced to go through memory *)
      let t = talloc 't' 32 in
      let slot = salloc 32 in
      rstore (R.reg t)   (Up.const const)  32 <:>
      astore slot        (rfetch t)        32 <:>
      rstore (R.reg dst) (A.fetch slot 32) 32
  | (('q', _, _), _, R.C 1), RP.Bits b -> (* we are forced to go through memory *)
      Printf.eprintf "Bad idea!!!!\n";
      let t1 = talloc 't' 32 in
      let t2 = talloc 't' 32 in
      let offset1 = R.bits (Bits.S.of_int (24*4) 32) 32 in
      let offset2 = R.bits (Bits.S.of_int (25*4) 32) 32 in
      let addr1   = R.app (R.opr "add" [32]) [rfetch sp; offset1] in
      let addr2   = R.app (R.opr "add" [32]) [rfetch sp; offset2] in
      (* now split the 64-bit literal into high and low 32 bits *)
      let hi = Bits.Ops.lobits 32 (Bits.Ops.shrl b (Bits.U.of_int 32 32)) in
      let lo = Bits.Ops.lobits 32 b in
      rstore (R.reg t1)     (Up.const (RP.Bits hi))     32 <:>
      rstore (mem 32 addr1) (rfetch t1)                 32 <:>
      rstore (R.reg t2)     (Up.const (RP.Bits lo))     32 <:>
      rstore (mem 32 addr2) (rfetch t2)                 32 <:>
      rstore (R.reg dst)    (R.fetch (mem 64 addr1) 64) 64 
  | (('t', _, _), _, R.C 1), _ ->
      rstore (R.reg dst) (Up.const const) 32
  | ((s, _, _), _, _) as r, RP.Bits b ->
      unimpf "loading immediate %s to a %d-bit register in space %%%c"
        (Bits.to_string b) (Register.width r) s
  | ((s, _, _), _, _) as r, _ ->
      unimpf "loading symbolic immediate to a %d-bit register in space %%%c"
        (Register.width r) s
let lix ~dst e = rtl (R.store (R.reg dst) e (reg_width dst))
  (* IS THIS REALLY RIGHT? *)
@ 
<<SPARC postexpander>>=
let unop ~dst op x =
  match op with
  | ("zx", _) | ("sx", _) | ("lobits", _) ->
      impossf "%%%s%d reached sparc postexpander" (fst op) (List.nth (snd op) 1)
  | _ -> rstore (R.reg dst) (R.app (Up.opr op) [rfetch x]) (reg_width dst)
<<SPARC postexpander>>=
let binop ~dst op x y =
  let dstw = reg_width dst in
  match op with
  | "modu", [w] ->
      PX.Expand.block (rstore (R.reg dst) (Rewrite.modu w (rfetch x) (rfetch y)) dstw)
  | "rem", [w] ->
      PX.Expand.block (rstore (R.reg dst) (Rewrite.rem w (rfetch x) (rfetch y)) dstw)
  | _ ->
      rstore (R.reg dst) (R.app (Up.opr op) [rfetch x; rfetch y]) dstw
<<SPARC postexpander>>=
let dblop ~dsthi ~dstlo op x y = Unsupported.mulx_and_mulux()
let wrdop  ~dst op x y z = Unsupported.singlebit ~op:(fst op)
let wrdrop ~dst op x y z = Unsupported.singlebit ~op:(fst op)
<<SPARC postexpander>>=
let with_rm rm b =
  PX.with_hw ~hard:(Register.Reg rounding_mode_reg) ~soft:rm ~temp:(talloc 't' 32) b

let f2i op dst x w = match dst, x with
| (('u', _, _), _, _), (('u', _, _), _, _) ->
    rstore (R.reg dst) (R.app op [rfetch x; rounding_mode]) w
| (('u', _, _), _, _), (('q', _, _), _, _) ->
    rstore (R.reg dst) (R.app op [rfetch x; rounding_mode]) w
| ((dstr, _, _), _, _), ((xr, _, _), _, _) ->
    impossf "'%c' := %%f2i('%c'..): f2i only available single precision\
             or float-to-float space\n" dstr xr

let unrm ~dst op x rm   =
  let w = Register.width dst in
  match op with
  | "f2i", _ -> with_rm rm  (f2i (Up.opr op) dst x w)
  | _ ->
      with_rm rm (rstore (R.reg dst) (R.app (Up.opr op) [rfetch x; rounding_mode]) w)
let binrm ~dst op x y rm =
  let w = Register.width dst in
  with_rm rm
    (rstore (R.reg dst) (R.app (Up.opr op) [rfetch x; rfetch y; rounding_mode]) w)
@ 
<<SPARC postexpander>>=
let pc_lhs = npc        (* PC as assigned by branch *)
let pc_rhs = pc         (* PC as captured by call   *)
@ 
<<SPARC postexpander>>=
let br ~tgt = PX.Nop, R.store pc_lhs (rfetch tgt)   wordsize  (* branch reg *)
let b  ~tgt = PX.Nop, R.store pc_lhs (Up.const tgt) wordsize  (* branch     *)
@ 
Needs to be filled in
<<SPARC postexpander>>=
let bc x (opr, ws as op) y ~ifso ~ifnot =
  (* Might be a 64-bit float *)
  assert (ws =*= [wordsize] || ws =*= [wordsize*2]);
  PX.Test (rstore cc (R.app (R.opr "sparc_subcc" ws) [rfetch x; rfetch y]) 32,
           (R.app (R.opr ("sparc_"^opr) ws) [R.fetch cc 32], ifso, ifnot))
@ 
<<SPARC postexpander>>=
let bnegate r = 
    let zero   = R.bits (Bits.zero 32) 32 in
    let negate = function
        | "sparc_ne" -> "sparc_eq"
        | "sparc_eq" -> "sparc_ne"
        | "sparc_feq" -> "sparc_fne"
        | "sparc_fne" -> "sparc_feq"
        | _    -> imposs "ill-formed SPARC conditional branch" in
    match Dn.rtl r with
    | RP.Rtl [ RP.App( (("eq"|"ne" as op),[32])
                     , [RP.Fetch(RP.Reg(x),32); RP.Const(RP.Bits(b))]
                     ) 
             , RP.Store (pc, tgt, 32)
             ] when RU.Eq.loc pc (Dn.loc pc_lhs) && Bits.eq b (Bits.zero 32) ->
                 R.guard (R.app (R.opr (negate op) [32]) [rfetch x; zero]) 
                (R.store pc_lhs (Up.exp tgt) wordsize)
    | _ -> imposs "ill-formed SPARC conditional branch"
@ 
<<SPARC postexpander>>=
let effects = List.map Up.effect
let call  ~tgt ~others =
  PX.Nop, R.par (R.store pc_lhs (Up.const tgt) wordsize :: effects others)
let callr ~tgt ~others =
  PX.Nop, R.par (R.store pc_lhs (rfetch tgt)   wordsize :: effects others)
@ 
<<SPARC postexpander>>=
let cut_to effs = PX.Nop, R.par (effects effs)
@ 
If an instruction modifies the current window pointer, it's a save or
restore, and the generic expander must not touch it.
<<SPARC postexpander>>=
let don't_touch_me =
  let stores_to_cwp = function
    | RP.Store (RP.Reg maybe_cwp, _, _) when Register.eq maybe_cwp cwp -> true
    | _                                                                -> false in
  List.exists stores_to_cwp
@ 
% ------------------------------------------------------------------ 
\subsection{Expander}
% ------------------------------------------------------------------ 
<<sparc.ml>>=
module X = Expander.IntFloatAddr(Post)
@ 
% ------------------------------------------------------------------
\subsection{Target}
% ------------------------------------------------------------------
<<sparc.ml>>=
let spill  p t l = (* assert (reg_width t = Rtlutil.Width.loc l); *)
  [A.store l (rfetch t) (reg_width t)]
let reload p t l = 
  let w = reg_width t in [R.store (R.reg t) (A.fetch l w) w]
@ 
<<sparc.ml>>=
let ( *> ) = A.( *> )
let globals base = 
  let width w = if      w <= 8  then 8  
                else if w <= 16 then 16 
                else Aux.round_up_to ~multiple_of:wordsize w in
  let align = function _ -> 8 in
  A.at mspace ~start:base (A.widen width *> A.align_to align *>
  A.overflow ~growth:Memalloc.Up ~max_alignment:16)
@ 
<<sparc.ml>>=
let target =
    let spaces = [ Spaces.m
                 ; Spaces.r
                 ; Spaces.f
                 ; Spaces.t
                 ; Spaces.u
                 ; Spaces.q
                 ; Spaces.c
                 ; Spaces.k
                 ] in
    { T.name                = "sparc"
    ; T.memspace            = mspace
    ; T.byteorder           = byteorder
    ; T.wordsize            = wordsize
    ; T.pointersize         = wordsize
    ; T.alignment           = 8             (* sparc 9 *)
    ; T.memsize             = 8
    ; T.spaces              = spaces
    ; T.reg_ix_map          = T.mk_reg_ix_map spaces
    ; T.distinct_addr_sp    = false
    ; T.float               = Float.ieee754
    ; T.spill               = spill
    ; T.reload              = reload

    ; T.vfp                 = vfp
    ; T.bnegate             = F.bnegate cc
    ; T.goto                = F.goto
    ; T.jump                = F.jump
    ; T.call                = F.call
    ; T.return              = F.return
    ; T.branch              = F.branch
    
    ; T.cc_specs            = A.init_cc
    ; T.cc_spec_to_auto     = Sparccall.cconv ~return_to:return
                                   (F.cutto (Rtl.reg sp))

    ; T.is_instruction      = Sparcrec.is_instruction
    ; T.capabilities        = T.incapable
    ; T.globals             = globals
    ; T.rounding_mode       = rounding_model (* Rtl.reg rm_reg *)
    ; T.named_locs   = Strutil.assoc2map 
                       ["IEEE 754 rounding mode",    rounding_model
                       ;"IEEE 754 rounding results", rounding_resultsl
                       ]
    ; T.data_section        = "data"
    ; T.charset             = "latin1" (* REMOVE THIS FROM TARGET.T *)
    }    
@ 
\subsection{Variable Placement}

If we get a 64-bit variable that is not hinted float, we could put it
in a floating-point temporary, but we're not that aggressive.
<<sparc.ml>>=
let warning s = Printf.eprintf "backend warning: %s\n" s
let placevars = 
  let is_float w hint _ = hint =$= "float" in
  let warn ~width ~alignment ~hint = () in
  let mk_stage ~temps =
    A.choice
      [ is_float,                 A.widen (Aux.round_up_to ~multiple_of: 32)
      ; (fun w h _ -> w <= 32),   A.widen (fun _ -> 32) *> temps 't'
      ; A.is_any,                 A.widen (Aux.round_up_to ~multiple_of: 8)
      ] in
  Placevar.mk_automaton ~warn ~vfp:target.T.vfp ~memspace:mspace mk_stage
@ 
