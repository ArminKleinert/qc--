

% ------------------------------------------------------------------ 
\section{Back end for the Alpha}
% ------------------------------------------------------------------ 

The Alpha is a 64 bit little-endian architecture. For informations about
he architecture, we consulted the \textit{True64 {\small UNIX} Assembly
Language Programmer's Guide}, Version 5.1, published by Compaq Computer,
Houston.


<<alpha.mli>>=
module Post : Postexpander.S
module X    : Expander.S

val target: Ast2ir.tgt
@

% ------------------------------------------------------------------ 
\subsection{Name and storage spaces}
% ------------------------------------------------------------------ 

<<alpha.ml>>=
let arch        = "alpha"                    (* architecture *)
let byteorder   = Rtl.LittleEndian 
let wordsize    = 64
@

We use the standard storage spaces, including the spaces for PC and
condition codes. 

<<alpha.ml>>=
module SS   = Space.Standard64
module A    = Automaton
module R    = Rtl
module RP   = Rtl.Private
module Up   = Rtl.Up
module Dn   = Rtl.Dn
module SM   = Strutil.Map
module T    = Target

module Spaces = struct
    let id = Rtl.Identity
    let m  = SS.m byteorder [8; 16; 32; 64] (* byte, word, longword, quadword *)
    let r  = SS.r 32 id [64]
    let f  = SS.f 32 id [64]    
    let t  = SS.t    id [64]    
    let u  = SS.u    id [64]
    let c  = SS.c  6 id [64]    (* pc, npc, cc, _, fp_mode, fp_fcmp *)
end
@

% ------------------------------------------------------------------ 
\subsection{Registers}
% ------------------------------------------------------------------ 

<<alpha.ml>>=
let locations   = SS.locations Spaces.c
let pc          = locations.SS.pc
let cc          = locations.SS.cc
let npc         = locations.SS.npc
let fp_mode     = locations.SS.fp_mode
let fp_fcmp     = locations.SS.fp_fcmp
let vfp         = Vfp.mk wordsize

let reg n       = ('r',n,wordsize)
let sp          = reg 30        (* stack pointer    *)
let ra          = reg 26        (* return address   *)
let zero        = reg 31        (* always zero      *)
@

% ------------------------------------------------------------------ 
\subsection{Utilities}
% ------------------------------------------------------------------  

<<alpha.ml>>=
let unimp               = Impossible.unimp
let impossible          = Impossible.impossible

let fetch_word l        = R.fetch l   wordsize
let store_word l e      = R.store l e wordsize
let mem w addr          = R.mem R.none 'm' byteorder w  addr
let reg_width (_,_,w)   = w
@
% ------------------------------------------------------------------ 
\subsection{Control-flow {\rtl}s}
% ------------------------------------------------------------------ 

We generate standard control-flow {\rtl}s. The \module{ast2ir.nw} module
inserts these into the {\cfg} it builds. 

<<alpha.ml>>=
module F = Mflow.MakeStandard
    (struct
        let pc_lhs    = pc
        let pc_rhs    = pc
        let ra_reg    = R.reg ra
        let ra_offset = 0               (* not sure *)
     end)   
@

Module [[F]] does not provide a return instruction. A return is simply a
jump.

<<alpha.ml>>=
let return = R.store pc (fetch_word (R.reg ra))
@


% ------------------------------------------------------------------ 
\subsection{Postexpander}
% ------------------------------------------------------------------ 

<<alpha.ml>>=
module Post = struct
    <<Alpha postexpander>>
end

<<Alpha postexpander>>=
let byte_order  = byteorder
let wordsize    = wordsize

type temp       = Register.t
type rtl        = Rtl.rtl
type width      = Rtl.width
type assertion  = Rtl.assertion
type operator   = Rtl.Private.opr
@

\paragraph{Contexts}
There is no distinction between an integer and an address.
@
<<Alpha postexpander>>=
type context = Rtl.space * (Register.t -> bool)
let icontext = 't', fun (c, _, _) -> c = 'r' || c = 't'
let fcontext = 'u', fun (c, _, _) -> c = 'f' || c = 'u'
let acontext = icontext
@
\paragraph{Addressing modes}
<<Alpha postexpander>>=
module Address = struct
    type t               = Rtl.exp
    let reg (_,_,w as r) = R.fetch (R.reg r) w 
end
@

% ------------------------------------------------------------------ 
\subsubsection{Load and Store}
% ------------------------------------------------------------------ 

For now we assume every temporary is 64 bits wide. However, the alpha
can handle 32 bit floating point values in its 64 bit floating point
registers. I belive that one would always spill the 64 bit register.

<<Alpha postexpander>>=
let tloc t              = Rtl.reg t
let tval (_,_,w as t)   = R.fetch (tloc t) w
let twidth              = reg_width

let load ~dst ~addr assn =
    let w = twidth dst in
        assert (w = wordsize); 
        [R.store (tloc dst) (R.fetch (mem w addr) w) w]
    

let store ~addr ~src assn =
    let w = twidth src in
        assert (w = wordsize); 
        [R.store (mem w addr) (tval src) w]
@

The Alpha provides sign- and zero-extending load operations for
loading values smaller than [[wordsize]]. Values are always extended to
64 bits.

<<Alpha postexpander>>=
let extend  op n e = R.app (R.opr op       [n; wordsize]) [e]
let lobits     n e = R.app (R.opr "lobits" [wordsize; n]) [e]

let xload op ~dst ~addr n assn =
    let w = twidth dst in
        assert (w = wordsize); 
        [R.store (tloc dst)
                 (extend op n (R.fetch (R.mem assn 'm' byteorder n addr) n)) 
                 w]

let sxload = xload "sx"
let zxload = xload "zx"

let lostore ~addr ~src n assn =
    assert (reg_width src = wordsize);
    [R.store (R.mem assn 'm' byteorder n addr) (lobits n (tval src)) n]
@

The general move operation only works between temporaries of the same
width. Load immediate loads a constant into a temorary.

<<Alpha postexpander>>=
let move ~dst ~src =
    assert (reg_width src = reg_width dst);
    if src = dst then [] else [R.store (tloc dst) (tval src) (twidth src)]
@

Immediate load, and extended immediate load. An extended load-immediate
can take sums and differences of compile-time constants (including late
compile-time constants). 

<<Alpha postexpander>>=
let li  ~dst const = [R.store (tloc dst) (Up.const const) (twidth dst)]
let lix ~dst e     = [R.store (tloc dst) e                (twidth dst)]  
@


% ------------------------------------------------------------------ 
\subsubsection{Operator contexts}
% ------------------------------------------------------------------ 

We have no boolean context because boolean operations are rewritten into
control flow.

<<Alpha postexpander>>=
let bcontext = ' ', fun _ -> false  (* should never be used *)
let operators = Context.standard icontext fcontext acontext bcontext

let resmap = List.fold_left (fun m (n, a, r)-> SM.add n r m) SM.empty operators
let argmap = List.fold_left (fun m (n, a, r)-> SM.add n a m) SM.empty operators
@

We have two maps: from operator to argument context, and from operator
to result context.

<<Alpha postexpander>>=
let arg_contexts   (n, _) = try SM.find n argmap with Not_found -> assert false
let result_context (n, _) = try SM.find n resmap with Not_found -> assert false
@

% ------------------------------------------------------------------ 
\subsubsection{Binary and unary operators}
% ------------------------------------------------------------------ 

None of the operators below expect or return boolean values. This
implies, that comparison operators are not expanded here before they are
used as guards for branches.

<<Alpha postexpander>>=
let unop ~dst op x =
    [R.store (tloc dst) (R.app (Up.opr op) [tval x]) (twidth dst)]

let binop ~dst op x y =
    [R.store (tloc dst) (R.app (Up.opr op) [tval x;tval y]) (twidth dst)]

let rtlop ~dst op args =
    [R.store (tloc dst) (R.app (Up.opr op) (List.map tval args)) (twidth dst)]
@

% ------------------------------------------------------------------ 
\subsubsection{Control Flow}
% ------------------------------------------------------------------ 

On the Alpha, we can read and write the program counter.

<<Alpha postexpander>>=
let pc_lhs = pc         (* PC as assigned by branch *)
let pc_rhs = pc         (* PC as captured by call   *)
@

\paragraph{Unconditional Branches}
<<Alpha postexpander>>=
let br ~tgt = [R.store pc_lhs (tval tgt)     wordsize]  (* branch reg *)
let b  ~tgt = [R.store pc_lhs (Up.const tgt) wordsize]  (* branch     *)
@

\paragraph{Conditional Branches}

On the Alpha, a conditional branch is not a primitive instruction.
Instead, a sequence of instructions implements a comparision, whose
result is written to a register. The branch instruction reads the
register, interprets it as a boolean, and branches accordingly.

For the results of the comparison instructions we would like to allocate
new temporaries. However, the Postexpander interface does not allow for
it. We therefore store the result of $x \oplus y$ and $\lnot x$
in $x$.

Not all comparion operators are provided as primitives on the Alpha. We
thus have to implement them as an instruction sequence. The rusult is in
all cases stored in [[x]].


[[com]] complements a temporay bitwise. As above, we could like to
assigne the result to a new temporary, but cannot allocate one. We thus
mutate the argument.

<<Alpha postexpander>>=
let bit = R.opr "bit" [wordsize] 
let com x =
    let o = R.opr "com" [wordsize] in
        R.store (tloc x)  (R.app o [tval x]) wordsize
@

[[relation]] implements a binary relation, where the result is
stored in [[x]] \emph{as a value}. 

<<Alpha postexpander>>=
let relation op x y = 
    let o   = R.opr op    [wordsize] in
        R.store (tloc x) (R.app bit [R.app o [tval x;tval y]]) wordsize 
@

[[cmp]] implements the {\rtl} comparision operators where the result is
stored in the first argument. 

<<Alpha postexpander>>=
let cmp op x y = match op with
    | "eq"          -> [relation "eq"  x y;]
    | "ne"          -> [relation "eq"  x y; com x]
    | "lt"          -> [relation "lt"  x y]
    | "gt"          -> [relation "le"  x y; com x]
    | "ge"          -> [relation "lt"  x y; com x]
    | "ltu"         -> [relation "ltu" x y]
    | "leu"         -> [relation "leu" x y]
    | "gtu"         -> [relation "leu" x y; com x]
    | "geu"         -> [relation "ltu" x y; com x]
    | "feq"           -> unimp "floating-point comparison"
    | "fne"           -> unimp "floating-point comparison"
    | "flt"           -> unimp "floating-point comparison"
    | "fle"           -> unimp "floating-point comparison"
    | "fgt"           -> unimp "floating-point comparison"
    | "fge"           -> unimp "floating-point comparison"
    | "fordered"      -> unimp "floating-point comparison"
    | "funordered"    -> unimp "floating-point comparison"
    | _               -> impossible 
                        "bad comparison in expanded Alpha conditional branch"
@

A conditional branch is a sequence of relational operators, followed by
a [[cbranch]] on the result. The guard inside [[cbranch]] compares for
not equal.

<<Alpha postexpander>>=
let cbranch op x tgt =
    R.guard (R.app (R.opr op [wordsize]) [tval x; R.bits (Bits.zero 64) 64])
            (R.store pc_lhs (Up.const tgt) wordsize)

let bc x (opr, ws as op) y ~tgt =
    assert (ws = [wordsize]);
    (cbranch "ne" x tgt) :: (cmp opr x y)  
@

[[bnegate]] inverts the condition in a conditional branch. Since we only
compare for equality or inequality, this is easy. All the real work is
done in the relational operators preceding the branch.

<<Alpha postexpander>>=
let bnegate r = 
    let zero   = R.bits (Bits.zero 64) 64 in    
    let negate = function
        | "ne" -> "eq"
        | "eq" -> "ne"
        | _    -> impossible "ill-formed Alpha conditional branch" in
    match Dn.rtl r with
    | RP.Rtl [ RP.App( (("eq"|"ne" as op),[64])
                     , [RP.Fetch(RP.Reg(x),64);RP.Const(RP.Bits(b))]
                     ) 
             , RP.Store (pc, tgt, 64)
             ] when pc = Dn.loc pc_lhs && b = Bits.zero 64 ->
                 R.guard (R.app (R.opr (negate op) [64]) [tval x; zero]) 
                (R.store pc_lhs (Up.exp tgt) wordsize)
    | _ -> Impossible.impossible "ill-formed Alpha conditional branch"
@

\paragraph{Calls} In an indirect call the target is held in a register,
otherwise it is an immediate constant.


<<Alpha postexpander>>=
let effects = List.map Up.effect
let call  ~tgt ~others = 
    [R.par (R.store pc_lhs (Up.const tgt) wordsize :: effects others)]
let callr ~tgt ~others = 
    [R.par (R.store pc_lhs (tval tgt) wordsize :: effects others)]
@

\paragraph{Cut-To}

<<Alpha postexpander>>=
let cut_to effs = [R.par (effects effs)]
@

\paragraph{No sacred instructions}

<<Alpha postexpander>>=
let don't_touch_me es = false
@

% ------------------------------------------------------------------ 
\subsection{Expander}
% ------------------------------------------------------------------ 

<<alpha.ml>>=
module X = Expander.IntFloatAddr(Post)
@


% ------------------------------------------------------------------ 
\subsection{Spill and reload}
% ------------------------------------------------------------------ 

The register allocator needs to spill and reload values; we have to
provide the instructions.

<<alpha.ml>>=
let spill  p t l = [A.store l (Post.tval t) (Post.twidth t)]
let reload p t l = 
    let w = Post.twidth t in [R.store (Post.tloc t) (Automaton.fetch l w) w]
@

% ------------------------------------------------------------------ 
\subsection{Global Variables}
% ------------------------------------------------------------------ 

When a Global {\PAL} variable names no hardware register to live in, the
variable is passed through to following automaton to obtain its
location.

THIS AUTOMATON SEEMS QUITE UNIVERSAL FOR 64 BIT ARCHITECTURES. MOVE IT
TO Automaton.Standard64?

I am not sure what the best alignments are. Maybe every slot should be
8-byte aligned.

<<alpha.ml>>=
let ( **> ) f x = f x
let globals base = 
  let width w = if      w <= 8  then 8  
                else if w <= 16 then 16 
                else if w <= 32 then 32
                else Aux.round_up_to wordsize w in
  let align = function _ -> 8 in
  A.at ~start:base **> A.widen width **> A.align_to align **>
  A.overflow ~memsize:8 
             ~byteorder:byteorder 
             ~growth:Memalloc.Up 
             ~max_alignment:8
@

% ------------------------------------------------------------------ 
\subsection{The target record}
% ------------------------------------------------------------------ 

<<alpha.ml>>=
let c_convention = Alphacall.c (fun ra -> (R.store pc ra wordsize)) 
                               (F.cutto (Rtl.reg sp)) 

let target =
    { T.name                = "alpha"
    ; T.byteorder           = byteorder
    ; T.wordsize            = wordsize
    ; T.pointersize         = wordsize
    ; T.alignment           = 8             (* not sure *)
    ; T.memsize             = 8
    ; T.spaces              = [ Spaces.m
                              ; Spaces.r
                              ; Spaces.f
                              ; Spaces.t
                              ; Spaces.u
                              ; Spaces.c
                              ]
    ; T.float               = "ieee754"
    ; T.spill               = spill
    ; T.reload              = reload

    ; T.vfp                 = vfp
    ; T.bnegate             = F.bnegate cc
    ; T.goto                = F.goto
    ; T.jump                = F.jump
    ; T.call                = F.call
    ; T.branch              = F.branch
    
    ; T.cc                  = (fun _ -> c_convention)
    ; T.globals             = globals
    ; T.is_rounding_mode    = (fun loc -> false)
    ; T.named_locs          = Strutil.Map.empty
    ; T.data_section        = "data"
    ; T.charset             = "latin1" (* REMOVE THIS FROM TARGET.T *)
    }    

