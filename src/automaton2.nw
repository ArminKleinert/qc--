% vim: ts=8 sw=4 et:
%
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% $Id$
%
% Automaton.nw will be replaced by this module. The major difference is
% that this modules relies on the simple Block abstraction.

% ------------------------------------------------------------------ 
\section{Automaton-Based Slot Allocation}
% ------------------------------------------------------------------ 

\begin{quote}\it
    I like to suggest to use objects directly rather than hiding them
    behind a functional interface. Why make things more complicated than
    need to be? --CL (Tue May 14 11:30:12 EDT 2002)
\end{quote}

Allocation of registers for parameter passing and slot allocation can be
hidden behind an automaton. An automaton knows a set of locations and
hands them out in response to queries. A location can be a hardware
register, a memory location, or a combination of both. The details are
hidden behind a common abstraction.

An \emph{automaton} is imperative; the type [[t]] encapsulates mutable
state.  After allocation is completed, an automaton is \emph{frozen},
and it cannot be queried for more locations. While an actual automaton
is imperative, its \emph{specification} is not. An automaton is created
from a specification and a base address. The base address designates a
memory area that the automaton can use for locations. When the automaton
is frozen, it returns a memory block that exactly describes the memory
requirements for the locations it handed out.

We have not yet developed a sense what might be good constructor
functions for an automaton specification. To avoid that we can specify
(target specific) automata only here, I expose the class types
[[location]] and [[automaton]] for types that we rather keep completely
abstract. Now automata can be defined by the targets that they belong
to.

<<types>>=
class type location = object
    method fetch:   (*width*) int -> Rtl.exp
    method store:   Rtl.exp -> (*width*) int -> Rtl.rtl
    method to_loc:  Rtl.loc
end


class type automaton = object
    method allocate:    (*width*) int -> (*hint*) (string option) -> location
    method freeze:      unit -> Block.t
end

type spec = Rtl.exp -> automaton    (* specification should be abstract *)
type loc  = location                (* location      should be abstract *)
type t    = automaton               (* automaton     should be abstract *)
@

<<automaton2.mli>>=
<<types>>
@

Supply an address of the overflow area, and get back an automaton in
its initial state.

<<automaton2.mli>>=
val mk : spec -> address:Rtl.exp -> t           
@

To allocate a new resource slot, call [[allocate]] with the width of the
slot in \emph{bits} and an optional hint.  It returns a location
[[[loc]] and change the automaton's internal state.  

<<automaton2.mli>>=
val ty:       t -> width:int -> hint:(string option) -> loc  (* deprecated *)  
val allocate: t -> width:int -> hint:(string option) -> loc  (* alias for ty *)
@

A location as returned by an automaton can't be used directly because it
is  abstract.  To use it for storing and fetching data, use the
following two functions:

<<automaton2.mli>>=
val fetch : loc -> width:int -> Rtl.exp
val store : loc -> Rtl.exp -> width:int -> Rtl.rtl
@

Because locations are abstract they can handle difficult cases where a
value is stored in part in a hardware register and in part in memory.
Some complicated calling conventions may require such concepts of a
location.  However, the very most cases are much simpler and we like to
represent those as [[Rtl.loc]] values, which are also very general but
can't deal with values split into different memory spaces.  The
following function allows to transform a sufficiently simple [[loc]]
value to a [[Rtl.loc]] value.  If a conversion is not possible,
[[Invalid_argument]] is raised as a checked run-time error.

<<automaton2.mli>>=
val to_loc : loc -> Rtl.loc
val of_loc : Rtl.loc -> loc
@

When an automaton [[t]] is frozen, it responds with the memory
[[Block.t]] that it used for locations it handed out.

<<automaton2.mli>>=
val freeze : t -> Block.t
@

% ------------------------------------------------------------------ 
\subsection{Memory-based Automata}
% ------------------------------------------------------------------ 

Here we provide a generic automaton that allocates slots in memory. The
behavior of the automaton is controlled by two sets of parameters:
target-specific parameters and policy-specific parameters.

\emph{Unfortuntately, we cannot use the [[Target2.t]] here because it
would introduce a circular dependency.}

The [[policy]] arguments controls the automatons behavior: when [[up]]
is true, slots are allocated from low to high memory. The [[alignment]]
is used for the alignment of the individual slots, and the resulting
memory block as a whole.

\emph{Maybe we have to offer more control over alignment. -- CL}

<<automaton2.mli>>=
module Memory: sig
    type target = 
        { byteorder:        Rtl.aggregation
        ; wordsize:         int                 (* in bits *)
        ; pointersize:      int                 (* in bits *)
        ; memsize:          int                 (* in bits *)
        }

    type policy =
        { up:               bool                (* allocate from lo to hi mem *)
        ; alignment:        int                 (* in memsize *)
        }
        

    val mk: target -> policy -> Rtl.exp (*base*) -> automaton
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

Until we know better we assume that automata for different platforms
are probably quite different and a single implementation is unlikely
to support them all.  We resort to an object-oriented implementation
that allows to have several implementations for the same interface. 

All real work is done by objects of class [[location]] and
[[automaton]] that are used as representation for [[loc]] and [[t]]
respectively. The class types define their shape but we are free to
provide entirely different implementations.

<<automaton2.ml>>=
<<types>>
@

Because the representations for [[t]] and [[loc]] are objects the
implementations for [[mk]], [[ty]] and so forth just pass their
arguments to the objects at hand.

<<automaton2.ml>>=
let mk spec ~address     = spec address
let ty t ~width ~hint    = t#allocate width hint
let allocate             = ty
let freeze t             = t#freeze ()

let fetch loc ~width      = loc#fetch width
let store loc expr ~width = loc#store expr width
let to_loc loc            = loc#to_loc
let of_loc loc            = Impossible.unimp "Automaton.of_rtl_loc"
@



% ------------------------------------------------------------------ 
\subsection{Implementation of Memory-Based Automata}
% ------------------------------------------------------------------ 

<<automaton2.ml>>=
module Memory = struct
    type target = 
        { byteorder:        Rtl.aggregation
        ; wordsize:         int                 (* in bits *)
        ; pointersize:      int                 (* in bits *)
        ; memsize:          int                 (* in bits *)
        }

    type policy =
        { up:               bool                (* allocate from lo to hi mem *)
        ; alignment:        int                 (* in memsize *)
        }
        
    <<class loc>>
    <<class t>>
    
    let mk target policy base = new t target policy base
end    
@


Each automaton defines an abstract location which is intended for
complex location like a register and a memory cell pair. Since all slots
are in memory, this is essentially a wrapper for [[Rtl.loc]].

<<class loc>>=
class loc (loc:Rtl.loc): location =
object
    val _loc   = loc
    
    method store expr width = Rtl.store _loc expr width 
    method fetch width      = Rtl.fetch _loc width
    method to_loc           = _loc
end
@

The automaton [[t]] maintains a block [[_block]] of memory allocated so
far. For every new slot it allocates a small block and concatenates it
with [[_block]]. Depending on [[T.up]] the [[_block]] grows on its high
or low end.

<<class t>>=
class t (target:target) (policy:policy) (base:Rtl.exp): automaton =
object (this)
    val mutable _block  = Block.mk base 0 policy.alignment  (* initial block *)
    val mutable _frozen = false
    
    method freeze () =
        ( _block  <- Block.adjust _block 
        ; _frozen <- true 
        ; _block  (* return block *)
        )

    method private memloc addr w = 
        new loc (Rtl.cell Rtl.none 'm' target.byteorder w addr)
    
    method private slotaddress = (* base + v *)
        let add = Rtl.opr "add" [target.pointersize] in
        Rtl.app add [base; Rtl.late (Idgen.slot "slots") target.pointersize]
    
    method allocate width hint = 
        let ()      = assert (_frozen = false)           
        and ()      = assert (width mod target.memsize = 0) 
        and bytes   = width / target.memsize in
        match hint with 
        | Some x -> assert false (* hints not supported *)
        | None ->
            let slot = Block.mk this#slotaddress bytes policy.alignment in
                ( if policy.up then
                    _block <- Block.cathl slot _block 
                  else
                    _block <- Block.cathl _block slot 
                ; this#memloc (Block.base slot) width
                )                
end
@



