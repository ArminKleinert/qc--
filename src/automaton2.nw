% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:
%
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% $Id$
%
% Automaton.nw will be replaced by this module. The major difference is
% that this modules relies on the simple Block abstraction.

% ------------------------------------------------------------------ 
\section{Automaton-Based Slot Allocation}
% ------------------------------------------------------------------ 

\begin{quote}\it
    I like to suggest to use objects directly rather than hiding them
    behind a functional interface. Why make things more complicated than
    need to be? --CL (Tue May 14 11:30:12 EDT 2002)
\end{quote}

Allocation of registers for parameter passing and slot allocation can be
hidden behind an automaton. An automaton knows a set of locations and
hands them out in response to queries. A location can be a hardware
register, a memory location, or a combination of both. The details are
hidden behind a common abstraction.

An \emph{automaton} is imperative; the type [[t]] encapsulates mutable
state.  After allocation is completed, an automaton is \emph{frozen},
and it cannot be queried for more locations. While an actual automaton
is imperative, its \emph{specification} is not. An automaton is created
from a specification and a base address. The base address designates a
memory area that the automaton can use for locations. When the automaton
is frozen, it returns a memory block that exactly describes the memory
requirements for the locations it handed out.
\begin{quote}
\emph{
In a just world, it would be possible to restructure the block interface such
that it would be unnecessary to supply a specific address---so the
address could be bound later.  
The continual supplying of the
address is awkward and antithetical to the spirit of giving the client
choice of binding time.
Unfortunately, the automaton must hand out locations, and it seems
impossible to hand out a location in a block without knowing something
about the block's address.
Supplying the address lazily seems appealing in principle, but in
practice the laziness would leak into the [[Automaton.loc]], which
seems of dubious value. ---NR}
\end{quote}


We have not yet developed a sense what might be good constructor
functions for an automaton specification. To avoid that we can specify
(target specific) automata only here, I expose the class types
[[location]] and [[automaton]] for types that we rather keep completely
abstract. Now automata can be defined by the targets that they belong
to.

<<types>>=
class type location = object
    method fetch:   (*width*) int -> Rtl.exp
    method store:   Rtl.exp -> (*width*) int -> Rtl.rtl
    method to_loc:  Rtl.loc
end

type result = { overflow : Block.t; sp_value : Rtl.exp }

class type automaton = object
    method allocate:    (*width*) int -> (*hint*) (string option) -> location
    method freeze:      unit -> result  (* clients must never call this *)
end

type spec = Rtl.exp -> automaton    (* specification should be abstract *)
type loc  = location                (* location      should be abstract *)
type t    = automaton               (* automaton     should be abstract *)
@
Here's an alternative:
<<types>>=
  type parts = { allocate : int -> string option -> loc
               ; freeze   : unit -> result
               } 

module type S = sig
  type t
  type loc
  type parts = { allocate : int -> string option -> loc
               ; freeze   : unit -> result
               } 
  val mk : parts -> t
  type pre_t = next:t -> parts
  type with_overflow = next:t -> overflow:t -> parts
  val alloc  : t -> int -> string option -> loc
  val freeze : t -> result
  type width = int
  val fetch  : loc -> width -> Rtl.exp
  val store  : loc -> Rtl.exp -> width -> Rtl.rtl
end
@          

<<automaton2.mli>>=
<<types>>
@

Supply an address of the overflow area, and get back an automaton in
its initial state.

<<automaton2.mli>>=
val mk : spec -> address:Rtl.exp -> t           
@

To allocate a new resource slot, call [[allocate]] with the width of the
slot in \emph{bits} and an optional hint.  It returns a location
[[[loc]] and changes the automaton's internal state.  

<<automaton2.mli>>=
val ty:       t -> width:int -> hint:(string option) -> loc  (* deprecated *)  
val allocate: t -> width:int -> hint:(string option) -> loc  (* alias for ty *)
@

A location as returned by an automaton can't be used directly because it
is  abstract.  To use it for storing and fetching data, use the
following two functions:

<<automaton2.mli>>=
val fetch : loc -> width:int -> Rtl.exp
val store : loc -> Rtl.exp -> width:int -> Rtl.rtl
@

Because locations are abstract they can handle difficult cases where a
value is stored in part in a hardware register and in part in memory.
Some complicated calling conventions may require such concepts of a
location.  However, the very most cases are much simpler and we like to
represent those as [[Rtl.loc]] values, which are also very general but
can't deal with values split into different memory spaces.  The
following function allows to transform a sufficiently simple [[loc]]
value to a [[Rtl.loc]] value.  If a conversion is not possible,
[[Invalid_argument]] is raised as a checked run-time error.

<<automaton2.mli>>=
val to_loc : loc -> Rtl.loc
val of_loc : Rtl.loc -> loc
@

When an automaton [[t]] is frozen, it responds with the memory
[[Block.t]] that it used for locations it handed out.

<<automaton2.mli>>=
val freeze  : t -> Block.t
val freeze' : t -> result
@

% ------------------------------------------------------------------ 
\subsection{Memory-based Automata}
% ------------------------------------------------------------------ 

Here we provide a generic automaton that allocates slots in memory. The
behavior of the automaton is controlled by two sets of parameters:
target-specific parameters and policy-specific parameters.

\emph{Unfortuntately, we cannot use the [[Target2.t]] here because it
would introduce a circular dependency.}

The ``policy'' argument control the automaton's behavior: when [[up]]
is true, slots are allocated from low to high memory. 
When [[alignment]] is true, every slot is aligned on its size. 
When false, no slot is aligned. 
The alignment of the resulting block is the maxmimum alignment of any slot.

Upon freezing, the stack pointer points at the young (most recently
allocated) end of the block.
The block will be addressed at an unknown offset relative to the
[[anchor]] expression. 
<<automaton2.mli>>=
module Memory: sig
    type target = 
        { byteorder:        Rtl.aggregation
        ; wordsize:         int                 (* in bits *)
        ; pointersize:      int                 (* in bits *)
        ; memsize:          int                 (* in bits *)
        }

    val relative:
        target -> up:bool -> aligned:bool -> anchor:Rtl.exp -> dbg:string -> automaton
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

Until we know better we assume that automata for different platforms
are probably quite different and a single implementation is unlikely
to support them all.  We resort to an object-oriented implementation
that allows to have several implementations for the same interface. 

All real work is done by objects of class [[location]] and
[[automaton]] that are used as representation for [[loc]] and [[t]]
respectively. The class types define their shape but we are free to
provide entirely different implementations.

<<automaton2.ml>>=
module RU = Rtlutil
module B  = Block
<<types>>
@

Because the representations for [[t]] and [[loc]] are objects the
implementations for [[mk]], [[ty]] and so forth just pass their
arguments to the objects at hand.

<<automaton2.ml>>=
let mk spec ~address     = spec address
let ty t ~width ~hint    = t#allocate width hint
let allocate             = ty
let freeze' t            = t#freeze ()
let freeze t             = (t#freeze ()).overflow

let fetch loc ~width      = loc#fetch width
let store loc expr ~width = loc#store expr width
let to_loc loc            = loc#to_loc
let of_loc loc            = Impossible.unimp "Automaton.of_rtl_loc"
@



% ------------------------------------------------------------------ 
\subsection{Implementation of Memory-Based Automata}
% ------------------------------------------------------------------ 

<<automaton2.ml>>=
module Memory = struct
    type target = 
        { byteorder:        Rtl.aggregation
        ; wordsize:         int                 (* in bits *)
        ; pointersize:      int                 (* in bits *)
        ; memsize:          int                 (* in bits *)
        }
        
    <<class loc>>
    <<class [[Memory.t]]>>
    
    let relative target ~up ~aligned ~anchor ~dbg = new t target up aligned anchor dbg
end    
@


Each automaton defines an abstract location which is intended for
complex location like a register and a memory cell pair. Since all slots
are in memory, this is essentially a wrapper for [[Rtl.loc]].

<<class loc>>=
class loc (loc:Rtl.loc): location =
object
    val _loc   = loc
    
    method store expr width = Rtl.store _loc expr width 
    method fetch width      = Rtl.fetch _loc width
    method to_loc           = _loc
end
@

The automaton [[t]] maintains a block [[_block]] of memory allocated so
far. For every new slot it allocates a small block and concatenates it
with [[_block]]. Depending on [[T.up]] the [[_block]] grows on its high
or low end.

<<class [[Memory.t]]>>=
class t (target:target) up aligned (anchor:Rtl.exp) dbg : automaton =
object (this)
    val mutable _block  = B.relative anchor dbg 0 1  (* initial block *)
    val mutable _frozen = false
    val mutable _maxalign = 1
    val         _add      = RU.add  target.pointersize
    val         _addk     = RU.addk target.pointersize
    
    method freeze () =
        ( _block  <- 
             (let alignblock = B.at (B.base _block) 0 _maxalign in
              B.adjust (B.cathl _block alignblock))
        ; _frozen <- true 
        ; { overflow = _block
          ; sp_value =
              if up then _addk (B.base _block) (B.size _block)
              else B.base _block
          }
        )
    
    method allocate width hint = 
        let ()        = assert (_frozen = false)           
        and ()        = assert (width mod target.memsize = 0) 
        and bytes     = width / target.memsize in
        let setmax () = if _maxalign < bytes then _maxalign <- bytes in
	let align     = if aligned then (setmax(); bytes) else 1 in
        let assn      = if aligned then Rtl.aligned bytes else Rtl.none in
        match hint with 
        | Some x -> Impossible.impossible "hint reached a memory automaton"
        | None ->
            let slot = B.relative anchor "slots" bytes align in
                ( if up then
                    _block <- B.cathl slot _block 
                  else
                    _block <- B.cathl _block slot 
                ; new loc (Rtl.mem assn 'm' target.byteorder width (B.base slot))
                )                
end
@
