% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:
%
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% $Id$
%

\emph{This module will be replaced by the new automaton model in module 
\module{automaton.nw}.}

% ------------------------------------------------------------------ 
\section{Automaton-Based Slot Allocation}
% ------------------------------------------------------------------ 

\begin{quote}\it
    I like to suggest to use objects directly rather than hiding them
    behind a functional interface. Why make things more complicated than
    need to be? --CL (Tue May 14 11:30:12 EDT 2002)
\end{quote}

Allocation of registers for parameter passing and slot allocation can be
hidden behind an automaton. An automaton knows a set of locations and
hands them out in response to queries. A location can be a hardware
register, a memory location, or a combination of both. The details are
hidden behind a common abstraction.

An \emph{automaton} is imperative; the type [[t]] encapsulates mutable
state.  After allocation is completed, an automaton is \emph{frozen},
and it cannot be queried for more locations. While an actual automaton
is imperative, its \emph{specification} is not. An automaton is created
from a specification and a base address. The base address designates a
memory area that the automaton can use for locations. When the automaton
is frozen, it returns a memory block that exactly describes the memory
requirements for the locations it handed out.
\begin{quote}
\emph{
In a just world, it would be possible to restructure the block interface such
that it would be unnecessary to supply a specific address---so the
address could be bound later.  
The continual supplying of the
address is awkward and antithetical to the spirit of giving the client
choice of binding time.
Unfortunately, the automaton must hand out locations, and it seems
impossible to hand out a location in a block without knowing something
about the block's address.
Supplying the address lazily seems appealing in principle, but in
practice the laziness would leak into the [[Automaton.loc]], which
seems of dubious value. ---NR}
\end{quote}


We have not yet developed a sense what might be good constructor
functions for an automaton specification. To avoid that we can specify
(target specific) automata only here, I expose the class types
[[location]] and [[automaton]] for types that we rather keep completely
abstract. Now automata can be defined by the targets that they belong
to.

<<types>>=
class type location = object
    method fetch:   (*width*) int -> Rtl.exp
    method store:   Rtl.exp -> (*width*) int -> Rtl.rtl
end

type result = { overflow : Block.t
              ; sp_value : Rtl.exp 
              }

class type automaton = object
    method allocate:    (*width*) int -> (*hint*) (string option) -> location
    method freeze:      unit -> result  (* clients must never call this *)
end

type spec = Rtl.exp -> automaton    (* specification should be abstract *)
type loc  = location                (* location      should be abstract *)
type t    = automaton               (* automaton     should be abstract *)
@

<<automaton2.mli>>=
<<types>>
@

Supply an address of the overflow area, and get back an automaton in
its initial state.

<<automaton2.mli>>=
val mk : spec -> address:Rtl.exp -> t           
@

To allocate a new resource slot, call [[allocate]] with the width of the
slot in \emph{bits} and an optional hint.  It returns a location
[[[loc]] and changes the automaton's internal state.  

<<automaton2.mli>>=
val allocate: t -> width:int -> hint:(string option) -> loc  (* alias for ty *)
@

A location as returned by an automaton can't be used directly because it
is  abstract.  To use it for storing and fetching data, use the
following two functions:

<<automaton2.mli>>=
val fetch : loc -> width:int -> Rtl.exp
val store : loc -> Rtl.exp -> width:int -> Rtl.rtl
@

Because locations are abstract they can handle difficult cases where a
value is stored in part in a hardware register and in part in memory.
Most times, however, a location is a sensible RTL location, in which
case we make it abstract using [[of_loc]].

<<automaton2.mli>>=
val of_loc : Rtl.loc -> loc
@

When an automaton [[t]] is frozen, it responds with the memory
[[Block.t]] that it used for locations it handed out.

<<automaton2.mli>>=
val freeze  : t -> Block.t
val freeze' : t -> result
@

% ------------------------------------------------------------------ 
\subsection{Discussion}
% ------------------------------------------------------------------ 

Here's an alternative:
<<alternative types>>=
  type parts = { allocate : int -> string option -> loc
               ; freeze   : unit -> result
               } 

module type S = sig
  type t
  type loc
  type parts = { allocate : int -> string option -> loc
               ; freeze   : unit -> result
               } 
  val mk : parts -> t
  type pre_t = next:t -> parts
  type with_overflow = next:t -> overflow:t -> parts
  val alloc  : t -> int -> string option -> loc
  val freeze : t -> result
  type width = int
  val fetch  : loc -> width -> Rtl.exp
  val store  : loc -> Rtl.exp -> width -> Rtl.rtl
end
@          


% ------------------------------------------------------------------ 
\subsection{Sample Automata}
% ------------------------------------------------------------------ 

All automata are parameterized over a [[target]] value. We only use them
until we come up with something better.

<<automaton2.mli>>=
module Sample: sig
    type target = 
        { byteorder:        Rtl.aggregation
        ; wordsize:         int                 (* in bits *)
        ; pointersize:      int                 (* in bits *)
        ; memsize:          int                 (* in bits *)
        ; registers:        (string * Rtl.loc) list
        }
    
    val relative: target -> up:bool -> aligned:bool 
                         -> anchor:Rtl.exp -> dbg:string -> automaton
    
    val stack:  target -> Rtl.exp -> automaton
    val global: target -> Rtl.exp -> automaton
end
@

The ``policy'' argument control the automaton's behavior: when [[up]] is
true, slots are allocated from low to high memory.  When [[alignment]]
is true, every slot is aligned on its size.  When false, no slot is
aligned.  The alignment of the resulting block is the maxmimum alignment
of any slot.

Upon freezing, the stack pointer points at the young (most recently
allocated) end of the block.  The block will be addressed at an unknown
offset relative to the [[anchor]] expression. 

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

Until we know better we assume that automata for different platforms
are probably quite different and a single implementation is unlikely
to support them all.  We resort to an object-oriented implementation
that allows to have several implementations for the same interface. 

All real work is done by objects of class [[location]] and
[[automaton]] that are used as representation for [[loc]] and [[t]]
respectively. The class types define their shape but we are free to
provide entirely different implementations.

<<automaton2.ml>>=
module RU = Rtlutil
module B  = Block
<<types>>
@

Because the representations for [[t]] and [[loc]] are objects the
implementations for [[mk]], [[ty]] and so forth just pass their
arguments to the objects at hand.

<<automaton2.ml>>=
let mk spec ~address      = spec address
let ty t ~width ~hint     = t#allocate width hint
let allocate              = ty
let freeze' t             = t#freeze ()
let freeze t              = (t#freeze ()).overflow

let fetch loc ~width      = loc#fetch width
let store loc expr ~width = loc#store expr width
@

Each automaton defines an abstract location which is intended for
complex location like a register and a memory cell pair. Since all slots
are in memory, this is essentially a wrapper for [[Rtl.loc]].

<<automaton2.ml>>=
class simple_loc (loc:Rtl.loc): location =
object
    val _loc   = loc
    
    method store expr width = Rtl.store _loc expr width 
    method fetch width      = Rtl.fetch _loc width
end


let of_loc l              = new simple_loc l
@

% ------------------------------------------------------------------ 
\subsection{Implementation of Sample Automata}
% ------------------------------------------------------------------ 

<<automaton2.ml>>=
module Sample = struct
    type target = 
        { byteorder:        Rtl.aggregation
        ; wordsize:         int                 (* in bits *)
        ; pointersize:      int                 (* in bits *)
        ; memsize:          int                 (* in bits *)
        ; registers:        (string * Rtl.loc) list
        }
    
    <<class memory>>
    <<class stack>>
    <<class global>>
    
    let relative target ~up ~aligned ~anchor ~dbg = 
        new memory target up aligned anchor dbg

    let stack   target = new stack   target
    let global  target = new global  target
end    
@

I DON'T KNOW THE DIFFERENCES BETWEEN THE MEMORY AND THE STACK CLASSES.
THEY SHOULD BE UNIFIED. HOWEVER, WE ARE GETTING RID OF AUTOMATON2 SOON,
SO I WILL KEEP THEM. -CL


The automaton [[memory]] maintains a block [[_block]] of memory
allocated so far. For every new slot it allocates a small block and
concatenates it with [[_block]]. Depending on [[up]] the [[_block]]
grows on its high or low end.

<<class memory>>=
class memory (target:target) up aligned anchor dbg : automaton =
object (this)
    val mutable _block  = (B.relative anchor dbg B.at) 0 1  (* initial block *)
    val mutable _frozen = false
    val mutable _maxalign = 1
    val         _add      = RU.add  target.pointersize
    val         _addk     = RU.addk target.pointersize
    
    method freeze () =
        ( _block  <- 
             (let alignblock = B.at (B.base _block) 0 _maxalign in
              B.adjust (B.cathl _block alignblock))
        ; _frozen <- true 
        ; { overflow = _block
          ; sp_value =
              if up then _addk (B.base _block) (B.size _block)
              else B.base _block
          }
        )
    
    method allocate width hint = 
        let ()        = assert (_frozen = false)           
        and ()        = assert (width mod target.memsize = 0) 
        and bytes     = width / target.memsize in
        let setmax () = if _maxalign < bytes then _maxalign <- bytes in
	let align     = if aligned then (setmax(); bytes) else 1 in
        let assn      = if aligned then Rtl.aligned bytes else Rtl.none in
        match hint with 
        | Some x -> Impossible.impossible "hint reached a memory automaton"
        | None ->
            let slot = (B.relative anchor "slots" B.at) bytes align in
                ( if up then
                    _block <- B.cathl slot _block 
                  else
                    _block <- B.cathl _block slot 
                ; new simple_loc (Rtl.mem assn 'm' target.byteorder width (B.base slot))
                )                
end

<<class stack>>=
class stack (target:target) (base:Rtl.exp): automaton =
object (this)
    val mutable _block  = Block.at base (*size*) 0 (*align*) 8  (* block *)
    val mutable _frozen = false
    
    method freeze () =
        let _ = _frozen <- true in
            { overflow = _block
            ; sp_value = base 
            } 
    
    method private memloc addr w = 
        new simple_loc (Rtl.cell Rtl.none 'm' target.byteorder w addr)
    
    method private hardware hint = match hint with 
    | r     -> Impossible.impossible ("unknown hardware register "^r) 
    
    method allocate width hint = 
        let ()      = assert (_frozen = false) in          
        match hint with 
        | Some x -> this#hardware x
        | None ->
            let ()      = assert (width mod target.memsize = 0) in
            let slot    = Block.relative base "slots"
                          Block.at ~size:(width/target.memsize) 
                            ~alignment:target.pointersize in
            ( _block <- Block.cathl slot _block 
            ; this#memloc (Block.base slot) width
            )
end

<<class global>>=
class global (target:target) (base:Rtl.exp): automaton =
object (this)
    val mutable _block  = Block.at base (*size*) 0 (*align*) 8  (* block *)
    val mutable _frozen = false
    
    method freeze () =
        let _ = _frozen <- true in
            { overflow = _block
            ; sp_value = base 
            } 
    
    method private memloc addr w = 
        new simple_loc (Rtl.cell Rtl.none 'm' target.byteorder w addr)
    
    method private hardware hint = 
        try new simple_loc (List.assoc hint target.registers) with 
        Not_found -> Impossible.impossible ("unknown hardware register "^hint) 
    
    method allocate width hint = 
        let ()      = assert (_frozen = false) in          
        match hint with 
        | Some x -> this#hardware x
        | None ->
            let ()      = assert (width mod target.memsize = 0) in
            let slot    = Block.at base (width/target.memsize) 
                            target.pointersize in
            ( _block <- Block.cathl slot _block 
            ; this#memloc (Block.base slot) width
            )
end
@

