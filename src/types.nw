% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h substitution to ->


% ------------------------------------------------------------------  
\section{Types}\label{sec:types}
% ------------------------------------------------------------------  

The static semantics of \C~require some type checks:  types of
arguments to primitive functions must meet the types of their formal
parameters, if-statements are governed by an expression of type
[[bool]].  This module lays out the type language for this purpose.

The basic types in \C~are [[bool]] and [[bits]]$n$, where $n$ is a
power of two.  Every value in \C~is monomorphic except for primitive
operators like [[add]], which can be polymorphic in the size of their
operators: 

$$[[add]]: \forall~\#n.[[bits]]\#n \times [[bits]]\#n \to [[bits]]\#n$$
 
A polymorphic values is described by a \textit{type scheme} that may
contains bound variables for the size part of a [[bits]] type. Types,
on the other hand, contain no variables at all. The structure of type
schema and types are covered by a parameterized type [[t]]. Depending
on the parameter types [[ty]] and type schema [[tyscheme]] can be
created from [[t]].

<<types>>=
type key        = int

type 'a t       = Bool
                | Bits of 'a 
                | Procedure of 'a t list * 'a t

type size       = Const of int
                | Var   of key

type ty         = int  t
type tyscheme   = size t

exception UnifyExn
exception SubstExn

@ The formal parameters to a primitive operation are describe by a
type scheme, the types of the actual parameters.  The [[unify]]
function checks that those two fit together.  During unification the
variables part of the type scheme are instantiated.  The instantiation
are recorded in a substitution [[subst]] that maps variable names from
a type scheme to sizes (of type [[int]]).  When [[unify]] fails it
raises the [[UnifyExn]] exception.

<<unify>>=
type subst

val unify  : tyscheme      -> ty       -> subst -> subst
val unify' : tyscheme list -> ty list  -> subst -> subst
@

A type scheme [[tyscheme]] can be turned into a type [[ty]] by
replacing all variable sizes with fixed ones. This happens when a
substitution is applied to a type scheme. Of course, it is an error
when the type scheme contains variables not in the domain of the
substitution. In that case the [[SubstExn]] is raised.

<<subst>>=
val subst  : subst -> tyscheme -> ty
val empty  : subst
@

For debugging types and type schema can be pretty printed into
[[Pp.doc]] values. These can be printed into a string or a file.

<<pp>>=
val ppTy         :   ty -> Pp.doc
val ppTy'        :   tyscheme -> Pp.doc
@


% ------------------------------------------------------------------ 
\subsection{Useful abbreviations}
% ------------------------------------------------------------------ 

When dealing with type the same types are used over and over again. 
Here are some useful definitions for them.  There are at least three
target dependent types:  the natural word type [[word]], the natural
code pointer type [[code]], and the natural data pointer type.  We
define types for them here, but only for the moment. 

<<abbrevs>>=
val bitsc  : int -> size t              (* fixed/constant size  *)
val bitsv  : key -> size t              (* variable size        *)
val bits   : 'a -> 'a t                 (* polymorphis size     *)
val bool   : 'a t                       (* bool                 *)
val proc   : 'a t list -> 'a t -> 'a t  (* build proc type      *)
val word   : int t                      (* natural word         *)
val code   : int t                      (* natural code pointer *)
val data   : int t                      (* natural data pointer *)
val char   : int t                      (* char                 *)
val uchar  : int t                      (* unicode char         *)
val cont   : int t                      (* continuation         *)
val dummy  : 'a t

val wordsize : int
val datasize : int
val codesize : int 
@


% ------------------------------------------------------------------  
\subsection{Interface}
% ------------------------------------------------------------------ 

<<types.mli>>=
<<types>>
<<unify>>
<<subst>>
<<pp>>
<<abbrevs>>
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation uses an environment to model substitutions. 

<<types.ml>>=
<<types>>

module Subst = Env.Make(struct type t=key let compare=compare end)
open Subst

type subst = int env
let empty = Subst.empty 

let unifyExn msg = raise UnifyExn
let substExn ()  = raise SubstExn

@ What is called a unification is technically a matching of a constant
type with a variable type. Unification in contrast deals with two two
variable term. There are two non trivial cases:

\begin{itemize}
\item A variable width unifies with a fixed width; this leads to an
      instantiation of the variable. 
\item A width variable might have been instantiated; thus the
      instantiation must be looked up in the substitutions and checked
      against the fixed width.
\end{itemize}

The unification of procedure types does not unify the result types
because there is no result type at the call site.  The unification
typically results in a substitution for the result type in the type
scheme.  When the substitution is then applied (using [[subst]]) to
the type scheme a result type is available.

<<>>=
let rec unify ts t sigma = match ts, t with
    | Bool           , Bool                          -> sigma
    | Bits(Const(x)) , Bits(y) when x = y            -> sigma
    | Bits(Var(x))   , Bits(y) when (domain x sigma) ->
        if (lookup x sigma) = y then sigma else unifyExn "sorry"
    | Bits(Var(x))   , Bits(y)                       -> enter x y sigma
    | Procedure(xs,x), Procedure(ys,y)  -> unify' (xs) (ys) sigma 
    | _              , _                             -> unifyExn "sorry"

and unify' xs ys sigma = match xs, ys with
    | []            , []        -> sigma
    | []            , ys        -> unifyExn "arity mismatch"
    | xs            , []        -> unifyExn "arity mismatch"
    | x::xs         , y::ys     -> unify' xs ys (unify x y sigma)

let rec subst sigma = function
    | Bool              -> Bool
    | Bits(Const(x))    -> Bits(x)
    | Procedure(xs,x)   -> Procedure (List.map (subst sigma) xs, subst sigma x)
    | Bits(Var(x))      -> try Bits(lookup x sigma)
                           with Not_found -> substExn ()
@

The pretty printer for types ueses the pretty printer module [[Pp]]. 
The list code is dublicated from the [[Astpp]]] module and should go
into the [[Pp]] module. 

<<>>=
open Pp (* convert this to module P = Pp *)

let (~~) x     = x
let nest       = nest 4    
let int i      = text (string_of_int i)
<<>>=
let tuple f xs =   
    text "("
    ^^ nest begin
       ~~ break
       ^^ list (break ^^ text "x" ^^ break) f xs
       end 
    ^/ text ")"
<<>>=
let rec ppProcTy f args return =
    agrp begin
    ~~ tuple f args
    ^/ text "->"
    ^/ f return
    end
<<>>=
let rec ppTy = function
    | Bool                      -> text "bool"
    | Bits(i)                   -> text "bits" ^^ int i
    | Procedure(args,return)    -> ppProcTy ppTy args return
<<>>=
and ppTy' = function
    | Bool                      -> text "bool"
    | Bits(Const(i))            -> text "bits"  ^^ int i
    | Bits(Var(i))              -> text "bits#" ^^ int i
    | Procedure(args,return)    -> ppProcTy ppTy' args return
@

The implementation of the abbreviations is trivial:

<<>>=
let codesize = 32       (* code pointer      *)
let datasize = 16       (* data pointer      *)
let wordsize = 32       (* natural word size *)

<<>>=
let bitsc x         = Bits(Const(x))
let bitsv x         = Bits(Var(x))
let bits  x         = Bits(x)
let bool            = Bool
let proc args res   = Procedure(args,res)
let word            = bits wordsize
let code            = bits codesize
let data            = bits datasize
let char            = bits 8
let uchar           = bits 16
let cont            = bits datasize
let dummy           = bool
@                           

