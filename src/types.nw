% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h substitution to ->
% l2h substitution rtl RTL

%%Grades: B Central Immediate

% ------------------------------------------------------------------  
\section{Types}\label{sec:types}
% ------------------------------------------------------------------  

Expressions in {\PAL} are type checked. This module provides types and
type checking functions for {\rtl} operators. 

Conditions in {\PAL} have type [[bool]], values types [[bits]]$n$. These
two are the basic types. {\PAL} and their closely related {\rtl}
operators have polymorphic function types. The typical case is an
operator like [[add]]:

$$[[add]]: \forall~n.[[bits]]n \times [[bits]]n \to [[bits]]n$$

The result size of [[add]] is the size of its arguments. A concrete
instance like $n=32$ is called a (function) type. The general scheme is
called a (polymorphic) \emph{type scheme}.

{\PAL} has a number of operators whose types are a bit more complicated
than that of [[add]]. The first complication is illustrated by the
[[zx]] operator. The [[zx]] operator widens a value by filling high
biths with zeros. In {\PAL} the width of the result is encoded into the
name: [[zx32]] widens a value to 32 bits; its type scheme can be thought
of like this:

$$[[sz32]]: \forall~n.[[bits]]n \to [[bits32]]$$

However, this is not the way [[zx]] is implemented in the compiler. All
{\PAL} operators are translated to {\rtl} operators that are allowed to
be polymorphic in the result size. The general [[sz]] operators has the
following type:

$$[[sz]]: \forall~n,m.[[bits]]n \to [[bits]]m$$

The translation (in \module{rtlop}) of [[sz32]] into [[sz]] takes care
that $m$ is bound to $32$.

The second complication is intriduced by multiplication operators like
[[mulu]]:

$$[[mulu]]: \forall~n,m.[[bits]]$n$ \times [[bits]]$n$ \to [[bits]]m, m
= 2n$$

The result of a multiplication is twice as wide a the operands. This
constraint cannot be easily expressed in the above formalism using bound
variables. We therefore have to employ a little hack to express it.

% ------------------------------------------------------------------ 
\subsection{Interface (Types)}
% ------------------------------------------------------------------ 

The parameterized type [['a t]] describes either a type [[ty]] when 
[['a]] equals [[int]], or a type scheme, when [['a]] is a [[size]]. In a
type scheme the width of a value is one of the following:

\begin{itemize}
\item A constant, like 32.
\item A bound variable. To maximize confusion, variables are identified
      by integers. Maybe we should switch to characters. Bound variables
      allow to express that two values in a function type have the same
      width.
\item The size of a another bound variable, times two. This is a hack to
      express the result width of a multiplication operator, as explained
      above.
      
\end{itemize}

<<types>>=
type 'a t       = Bool
                | Bits of 'a 
                
type key        = int
type size       = Const of int
                | Var   of key
                | Var2  of key      (* see above - better name?? *)

type ty         = int  t
@

\emph{Rather than having a fixed operator [[Var2]] we could implement a
map: [[Fun of key * (int -> int)]]. The key indentifies a width
variable, and ultimately a width. We take it, and apply the function to
obtain a new width. In our case the function is simply multiplication by
two. I haven't thought about this, but would in the general case expect
problems with circular dependencies among types. What is the right
formalism here? -- CL}

The type of a function is a pair of a list of operand types and a result
type. A [[tyscheme]] describes a type scheme, a [[monotype]] the
instance of a type scheme.

<<types>>=
type tyscheme   = (size t) list * (size t)
type monotype   = (int  t) list * (int  t)
@

Unlike in the formalism that uses $\forall$ to bind type variables
explicitly, type variables in the implementation are bound implicitly:
The [[tyscheme]] for the [[add]] and [[mulu]] primitves are encoded as
follows:

\begin{quote}
    \begin{verbatim}
add:  ([Bits(Var 1); Bits(Var 1)], Bits(Var 1))
mulu: ([Bits(Var 1); Bits(Var 1)], Bits(Var2 1))
    \end{verbatim}
\end{quote}

The [[Var 1]] values identify the variable in the type scheme that is
replaced by an integer when the type scheme is instantiated. In case of
[[mulu]], the size of the result is twice the number of bits [[Var 1]]
gets bound to.

% ------------------------------------------------------------------ 
\subsection{Interface (Functions)}
% ------------------------------------------------------------------ 

The [[appl]] function implements the type checking of arguments that are
supplied to a primitive function: given the [[tyscheme]] to describe the
primitive, and the list of argument [[ty]]s, [[appl]] returns the type
of the primitive's result. In case the primitive's [[tyscheme]] can not
be instantiated such that the supplied argument type match, a
[[matchExn]] is raised.

<<types>>=
exception MatchExn

<<appl>>=
val appl      : tyscheme -> ty list -> ty       (* raises matchExn *)
val widthlist : tyscheme -> ty list -> int list (* raises matchExn *)
@

Instantiation of a type scheme fails  when a type scheme contains a
variable in the result position that does not also show up in an
argument position. This indicates a checked run-time error in the type
specification of a primitive and should never happen.  

The [[widthlist]] function takes the type of a primitive (a
[[tyscheme]]) and a list of argument types and returns the sizes bound
by the variables in the type scheme.

<<appl>>=
val split : string -> string * int option     (* RTL op name, return width *)
@

Some operators encode the size of their return values in their name:
[[zx32]] is the zero-extension function that returns a 32 bit value.
The [[split]] function returns the operator name (without the numbers)
and the size of the return value, if it exists:

<<appl>>=
val instantiate: tyscheme -> widths:int list -> monotype
@

An operator inside an {\rtl} is monomorphic. It carries a \emph{width
list} that allows to reconstruct the monomorphic type from its
polymorphic type scheme. This process is called instantiation. It is a
checked run-time error if the width list is too short to instantiate all
variables in the type scheme.



% ------------------------------------------------------------------ 
\subsection{Useful abbreviations}
% ------------------------------------------------------------------ 

When dealing with type the same types are used over and over again. 
Here are some useful definitions for them.  There are at least three
target dependent types:  the native word type [[word]], the native
code pointer type [[code]], and the native data pointer type.  We
define types for them here, but only for the moment. 

<<abbrevs>>=
val bitsc  : int -> size t              (* fixed/constant size       *)
val bitsv  : key -> size t              (* variable size             *)
val bitsv2 : key -> size t              (* doubled width - see above *)
val bits   : 'a -> 'a t                 (* polymorphic size          *)
val bool   : 'a t                       (* bool                      *)
val proc   : size t list -> size t -> tyscheme   (* build proc type  *)
@


Finally, here we put together the interface file.

<<types.mli>>=
<<types>>
<<appl>>
<<abbrevs>>
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

A substitution associates a width variable (identified by an [[int]])
with an integer bit width. We use a map to implement a substitution.  In
addition to the functions provided by [[Map]] we define some helper
functions. 

<<types.ml>>=
<<types>>  (* types from the interface definition *)
module E = Error
module S = Map.Make(struct type t=key let compare=compare end)

let lookup key env = S.find key env 
let dump env       = let f key data res = (key,data)::res in S.fold f env []
@

To check that the application of an operator is well typed, we
\emph{match} the type scheme of the operator against the operand types.
A match takes a type scheme and a type, and produces a substitution. The
substitution records bindings for width variables, resulting from a
match between a constant width and a variable width. These are the
important cases:

\begin{itemize}
\item A type variable width matches with a fixed width; this leads to an
      instantiation of the variable that is recorded in the
      substitution.
\item A width variable might have been instantiated; thus the
      instantiation must be looked up in the substitutions and checked
      against the fixed width.
\end{itemize}

The [[match]] function matches a [[tyscheme]] with a [[ty]] and
returns a substitution.  In case of a mismatch, [[matchExn]] is
raised. 

We never expect to see a [[Var2]] constructor during matching. It should
only show up in the result position of a function type. Since only the
argument positions are matched, we should never see it here. However,
a succeeding match can bind a width variable that \emph{is} mentioned in
a [[Var2]] result position.

\emph{Is it possible to define a general match function where [[Var2]]
can show up in all positions? -- CL}

<<types.ml>>=
let match' sigma = function 
    | Bool           , Bool                          -> sigma
    | Bits(Const(x)) , Bits(y) when x = y            -> sigma
    | Bits(Var(x))   , Bits(y) when (S.mem x sigma)  ->
        if (lookup x sigma) = y then sigma else (raise MatchExn)
    | Bits(Var(x))   , Bits(y)                       -> S.add x y sigma
    | _              , _                             -> raise MatchExn
@

The [[subst]] function applies a substitution [[sigma]] to a [[size t]]
and returns a [[ty]].  In the context of C-- this must always succeed,
because primitive operators are predefined and only their type schemes
are used for matching and substitution.

<<types.ml>>=
let subst sigma = function
    | Bool              -> Bool
    | Bits(Const(x))    -> Bits(x)
    | Bits(Var(x))      -> (try Bits(lookup x sigma) with Not_found -> 
                                E.error "internal error (1) in application")
    | Bits(Var2(x))     -> (try Bits(2*(lookup x sigma)) with Not_found ->
                                E.error "internal error (2) in application")
@

The [[appl]] function matches the argument types with the [[size t]]
values at the argument positions of a [[tyscheme]].  The resulting
substitution is applied to the result [[size t]] to get the result
[[ty]].
                           
<<types.ml>>=
let appl (args',r) args =
    let sigma  = S.empty                                     in
    let pairs  = try List.combine args' args with Invalid_argument _ ->
                 E.error "wrong number of arguments in call" in
    let sigma  = ( try List.fold_left match' sigma pairs with
                 | MatchExn -> E.error "type error in application"
                 )                                           in
        subst sigma r
@

The [[widthlist]] function takes the type of a primitive (a
[[tyscheme]]) and a list of argument types and returns the sizes bound
by the variables in the type scheme.

<<types.ml>>=
let widthlist (args',r) args =
    let sigma  = S.empty                                     in
    let pairs  = try List.combine args' args with Invalid_argument _ ->
                 E.error "wrong number of arguments in call" in
    let sigma  = ( try List.fold_left match' sigma pairs with
                 | MatchExn -> E.error "type error in application"
                 )                                           in
    let sorted = List.sort (fun (key1,val1) (key2,val2) -> compare key1 key2) 
                 (dump sigma)                                in
        List.map snd sorted
@


The implementation of [[spilt]] uses regular expressions to split off
a trailing number.

<<types.ml>>=
let rtlop = Str.regexp "^\([a-z0-9_]*[a-z_]\)\([0-9]+\)?$"

let split op =
    let matched n l = Str.matched_group n l in  
    if Str.string_match rtlop op 0 then
        let basename = matched 1 op in
        let size     = try Some (int_of_string (matched 2 op))
                       with Not_found -> None in
            (basename, size)
    else
        Impossible.impossible ("illegal operator? '"^op^"'")
            

<<old implementation of split>>=
let split op =
    let ( *** ) = Lc.seq                              in
    let isnum c = '0' <= c && c <= '9'                in
    let num     = Lc.satisfy isnum                    in
    let alpha   = Lc.satisfy (fun c -> not (isnum c)) in
    let op'     =     Lc.saveStr (Lc.some alpha)
                  *** Lc.saveStr (Lc.many num)
                  *** Lc.eof                          in
        try match Lc.scan op op' with
            | l, ["";op]   -> op, None
            | l, [n ;op]   -> op, Some (int_of_string n)
            | _            -> assert false
        with Lc.Error msg  -> assert false
@

[[Instantiate]] computes a monomorphic function type from a width list
and a polymorphic [[tyscheme]] by instantiating it. The $n$-th element
in the (zero based) width list instantiates [[Var]] $n+1$ in the
[[tyscheme]]. It is a checked run-time error if [[tyscheme]] contains a
variable [[Var]] $x$ where $x > |[[width]]|$. 

<<types.ml>>=
let instantiate ((args,ret):tyscheme) ~widths  =
    let inst = function
        | Bits (Var i)   -> ( try Bits (List.nth widths (i-1)) with 
                            | Failure _ -> assert false
                            ) 
        | Bits (Var2 i)  -> ( try Bits (2 * (List.nth widths (i-1))) with 
                            | Failure _ -> assert false
                            )
        | Bits (Const k) -> Bits k
        | Bool           -> Bool
    in (List.map inst args, inst ret)
@        
        
        

The implementation of the abbreviations is trivial:

<<types.ml>>=
let bitsc  x         = Bits(Const(x))
let bitsv  x         = Bits(Var(x))
let bitsv2 x         = Bits(Var2(x))
let bits   x         = Bits(x)
let bool            = Bool
let proc args res   = (args,res)
@

