% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h substitution to ->
% l2h substitution rtl RTL

% ------------------------------------------------------------------  
\section{Types}\label{sec:types}
% ------------------------------------------------------------------  

The static semantics of \C~require type checks:  types of arguments to
primitive functions must match the types of their formal parameters,and
[[if]]-statements are governed by an expression of type [[bool]].  This
module lays out the type language for this purpose.

The basic types in \C~are [[bool]] and [[bits]]$n$.  Values in \C~are
monomorphic, primitive operators like [[add]] are polymorphic in
general in the size of their operands: 

$$[[add]]: \forall~n.[[bits]]n \times [[bits]]n \to [[bits]]n$$
 
A polymorphic primitive is described by a \textit{type scheme} that
may contain bound variables for the size part of a [[bits]] type. 
Types (for values), on the other hand, contain no variables at all. 
The structure of type schema and types are covered by a parameterized
type [[t]].  Depending on the parameter [['a]] types [[ty]] and type schema
[[tyscheme]] can be created from [[t]].

<<types>>=
type key        = int

type 'a t       = Bool
                | Bits of 'a 
                
type size       = Const of int
                | Var   of key

type ty         = int  t
@
A [[tyscheme]] describes a polymorphic function that takes a list of
arguments and returns a single value as result. A [[monotype]] is a
monomorphic function type.

<<types>>=
type tyscheme   = (size t) list * (size t)
type monotype   = (int  t) list * (int  t)
@

The [[tyscheme]] for the [[add]] primitve would be encoded as follows:
\begin{quote}
    \begin{verbatim}
([Bits(Var 1); Bits(Var 1)], Bits(Var 1))
    \end{verbatim}
\end{quote}

The [[Var 1]] values identify the variable in the type scheme that is
replaced by an integer when the type scheme is instantiated. 

The [[appl]] function implements the type checking of arguments that
are supplied to a primitive function: given the [[tyscheme]] to
describe the primitive, and the list of argument [[ty]]s, [[appl]]
returns the type of the primitive's result. In case the primitive's
[[tyscheme]] can not be instantiated such that the supplied argument
type match, a [[matchExn]] is raised.

Instantiation of a type scheme fails  when a type scheme contains a
variable in the result position that does not also show up in an
argument position. This indicates a checked run-time error in the type
specification of a primitive and should never happen.  

<<types>>=
exception MatchExn

<<appl>>=
val appl      : tyscheme -> ty list -> ty       (* raises matchExn *)
val widthlist : tyscheme -> ty list -> int list (* raises matchExn *)
@

Some operators encode the size of their return values in their name: 
[[zx32]] is the zero-extension function that returns a 32 bit value. 
The [[retsize]] function returns this number from an operator name (if
present) as an [[int option]] value.

<<appl>>=
val retsize : string -> int option
@

An operator inside an {\rtl} is monomorphic. It carries a \emph{width
list} that allows to reconstruct the monomorphic type from its
polymorphic type scheme. This process is called instantiation. It is a
checked run-time error if the width list is too short to instantiate all
variables in the type scheme.

<<appl>>=
val instantiate: tyscheme -> widths:int list -> monotype
@


% ------------------------------------------------------------------ 
\subsection{Useful abbreviations}
% ------------------------------------------------------------------ 

When dealing with type the same types are used over and over again. 
Here are some useful definitions for them.  There are at least three
target dependent types:  the native word type [[word]], the native
code pointer type [[code]], and the native data pointer type.  We
define types for them here, but only for the moment. 

<<abbrevs>>=
val bitsc  : int -> size t              (* fixed/constant size  *)
val bitsv  : key -> size t              (* variable size        *)
val bits   : 'a -> 'a t                 (* polymorphic size     *)
val bool   : 'a t                       (* bool                 *)
val proc   : size t list -> size t -> tyscheme   (* build proc type      *)
@


% ------------------------------------------------------------------  
\subsection{Interface}
% ------------------------------------------------------------------ 

<<types.mli>>=
<<types>>
<<appl>>
<<abbrevs>>
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

Substitutions describe the variables of a type scheme.  The
implementation uses a map to model substitutions.

<<types.ml>>=
module E = Error
<<types>>
@

In addition to the functions provided by [[Map]] we define some helper
functions. 

<<types.ml>>=
module S = Map.Make(struct type t=key let compare=compare end)

let lookup key env = 
    try S.find key env with Not_found -> Error.error ("unknown operator")
let dump env = let f key data res = (key,data)::res in S.fold f env []
@

What is called a unification is technically a matching of a constant
type with a variable type.  Unification in contrast deals with two two
variable term.  There are two non trivial cases:

\begin{itemize}
\item A variable width matches with a fixed width; this leads to an
      instantiation of the variable. 
\item A width variable might have been instantiated; thus the
      instantiation must be looked up in the substitutions and checked
      against the fixed width.
\end{itemize}

The [[match]] function matches a [[tyscheme]] with a [[ty]] and
returns a substitution.  In case of a mismatch, [[matchExn]] is
raised.

<<types.ml>>=
let match' sigma = function 
    | Bool           , Bool                          -> sigma
    | Bits(Const(x)) , Bits(y) when x = y            -> sigma
    | Bits(Var(x))   , Bits(y) when (S.mem x sigma) ->
        if (lookup x sigma) = y then sigma else (raise MatchExn)
    | Bits(Var(x))   , Bits(y)                       -> S.add x y sigma
    | _              , _ -> raise MatchExn
@

The [[subst]] function applies a substitution [[sigma]] to a [[size t]] 
and returns a [[ty]].  In the context of C-- this must always
succeed, because primitive operators are predefined and only their
type schemes are used for matching and substitution.

<<types.ml>>=
let subst sigma = function
    | Bool              -> Bool
    | Bits(Const(x))    -> Bits(x)
    | Bits(Var(x))      -> try Bits(lookup x sigma)
                           with Not_found -> assert false
@

The [[appl]] function matches the argument types with the [[size t]]
values at the argument positions of a [[tyscheme]].  The resulting
substitution is applied to the result [[size t]] to get the result
[[ty]].
                           
<<types.ml>>=
let appl (args',r) args =
    let sigma  = S.empty                                     in
    let pairs  = try List.combine args' args with Invalid_argument _ ->
                 E.error "wrong number of arguments in call" in
    let sigma  = ( try List.fold_left match' sigma pairs with
                 | MatchExn -> E.error "type error in application"
                 )                                           in
        subst sigma r
@

The [[widthlist]] function takes the type of a primitive (a
[[tyscheme]]) and a list of argument types and returns the sizes bound
by the variables in the type scheme.

<<types.ml>>=
let widthlist (args',r) args =
    let sigma  = S.empty                                     in
    let pairs  = try List.combine args' args with Invalid_argument _ ->
                 E.error "wrong number of arguments in call" in
    let sigma  = ( try List.fold_left match' sigma pairs with
                 | MatchExn -> E.error "type error in application"
                 )                                           in
    let sorted = List.sort (fun (key1,val1) (key2,val2) -> compare key1 key2) 
                 (dump sigma)                                in
        List.map snd sorted
@


The implementation of [[retsize]] uses the lexical combinator module
[[Lc]]:  the first part of an operator is scanned using the [[some
alpha]] scanner, the second by the [[many num]] scanner whose result
is also saved. A successful scan must consume the whole string and
return the (possibly empty) string of the matched numbers.

<<types.ml>>=
let retsize op =
    let ( *** ) = Lc.seq                                                in
    let num     = Lc.satisfy (fun c -> '0'  <= c && c <= '9')           in
    let alpha   = Lc.satisfy (fun c -> ('a' <= c && c <= 'z')
                                   ||  ('A' <= c && c <= 'Z'))          in
    let op'     = Lc.some alpha *** Lc.saveStr (Lc.many num) *** Lc.eof in
        try match Lc.scan op op' with
            | l, [""]      -> None
            | l, [n]       -> Some (int_of_string n)
            | _            -> assert false
        with Lc.Error msg  -> assert false
@

[[Instantiate]] computes a monomorphic function type from a width list
and polymorphic [[tyscheme]] by instantiating it. The $n$-th element in
the (zero based) width list instantiates [[Var]] $n+1$ in the
[[tyscheme]]. It is a checked run-time error if [[tyscheme]] contains a
variable [[Var]] $x$ where $x > |[[width]]|$. 

<<types.ml>>=
let instantiate ((args,ret):tyscheme) widths  =
    let inst = function
        | Bits (Var i)   -> ( try Bits (List.nth widths (i-1)) with 
                            | Failure _ -> assert false
                            ) 
        | Bits (Const k) -> Bits k
        | Bool           -> Bool
    in (List.map inst args, inst ret)
@        
        
        

The implementation of the abbreviations is trivial:

<<types.ml>>=
let bitsc x         = Bits(Const(x))
let bitsv x         = Bits(Var(x))
let bits  x         = Bits(x)
let bool            = Bool
let proc args res   = (args,res)
@

