% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ----------------------------------------------------------------
\section{Operations on bit vectors}
% ----------------------------------------------------------------

This module encapsulates operations on bit vectors.
Its primary use will be to support constant evaluation, but
it is also used to evaluate `early' expressions during RTL creation.
%
<<bitops.mli>>=
(*module Bitops*)
type t = Bits.bits
type width = Bits.width
@ 
Standard RTL operators
<<bitops.mli>>=
(* comparisons *)
val eq : t -> t -> bool
val ne : t -> t -> bool
val lt : t -> t -> bool
val le : t -> t -> bool
val gt : t -> t -> bool
val ge : t -> t -> bool

(* extensions *)
val sx : t -> width -> t  (* sign extend to the given width *)
val zx : t -> width -> t

(* shifts *)
val shl  : t -> t -> t
val shra : t -> t -> t
val shrl : t -> t -> t

(* extractions a painless specialty *)
val bitExtract : lsb:int -> t -> width -> t
val bitInsert  : lsb:int -> wide:t -> narrow:t -> t

(* bitwise operations *)
val com : t -> t

(* floating-point goo *)
val float_lt : t
val float_gt : t
val float_eq : t
val unordered : t

val round_nearest : t
val round_zero : t
val round_down : t
val round_up : t

@ 
Testing for widths.
<<bitops.mli>>=
val fits_signed : t -> width -> bool
  (* fits_signed v w == v can be narrowed to width w, then
         sign-extended to its original width, without changing its value *)
val fits_unsigned : t -> width -> bool
  (* fits_signed v w == v can be narrowed to width w, then
         zero-extended to its original width, without changing its value *)
@



% ----------------------------------------------------------------
\subsection{Implementation}
% ----------------------------------------------------------------

<<bitops.ml>>=
type t = Bits.bits
type width = Bits.width
let eq x y = x = y
let ne x y = x <> y

exception Unimplemented of string
let unimp s = raise (Unimplemented s)

let lt x y = unimp "lt"
let le x y = unimp "le"
let gt x y = unimp "gt"
let ge x y = unimp "ge"

let sx x w = unimp "sx"
let zx x w = unimp "zx"

let com x = unimp "com"

let fits_signed x w = unimp "fits_signed"
let fits_unsigned x w = unimp "fits_unsigned"

let bitExtract _ _ _ = unimp "bitExtract"
let bitInsert lsb wide narrow = unimp "bitInsert"

let float_lt = unimp "floating-point stuff"
let float_gt = unimp "floating-point stuff"
let float_eq = unimp "floating-point stuff"
let unordered = unimp "floating-point stuff"

let round_nearest = unimp "floating-point stuff"
let round_zero = unimp "floating-point stuff"
let round_down = unimp "floating-point stuff"
let round_up = unimp "floating-point stuff"

let shl  _ _ = unimp "shifts"
let shra _ _ = unimp "shifts"
let shrl _ _ = unimp "shifts"
