% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ----------------------------------------------------------------
\section{Operations on bit vectors}
% ----------------------------------------------------------------

This module encapsulates operations on bit vectors.
Its primary use will be to support constant evaluation, but
it is also used to evaluate `early' expressions during RTL creation.
%
<<bitops.mli ((evaluating))>>=
(*module Bitops*)
type t = Bits.bits
type width = Bits.width
@ 
Standard RTL operators
<<bitops.mli ((evaluating))>>=
(* comparisons *)
val eq : t -> t -> bool
val ne : t -> t -> bool
val lt : t -> t -> bool
val le : t -> t -> bool
val gt : t -> t -> bool
val ge : t -> t -> bool

(* extensions *)
val sx : t -> width -> t  (* sign extend to the given width *)
val zx : t -> width -> t

(* shifts *)
val shl  : t -> t -> t
val shra : t -> t -> t
val shrl : t -> t -> t

(* extractions a painless specialty *)
val bitExtract : lsb:int -> t -> width -> t
val bitInsert  : lsb:int -> wide:t -> narrow:t -> t

(* bitwise operations *)
val com : t -> t

(* floating-point goo *)
val float_lt : t
val float_gt : t
val float_eq : t
val unordered : t

val round_nearest : t
val round_zero : t
val round_down : t
val round_up : t

@ 
Testing for widths.
<<bitops.mli ((evaluating))>>=
val fits_signed : t -> width -> bool
  (* fits_signed v w == v can be narrowed to width w, then
         sign-extended to its original width, without changing its value *)
val fits_unsigned : t -> width -> bool
  (* fits_signed v w == v can be narrowed to width w, then
         zero-extended to its original width, without changing its value *)
@



% ----------------------------------------------------------------
\subsection{Implementation}
% ----------------------------------------------------------------

<<bitops.ml ((evaluating))>>=
type t = Bits.bits
type width = Bits.width
let eq x y = x = y
let ne x y = x <> y

let unimp = Impossible.unimp

let lt x y = unimp "lt"
let le x y = unimp "le"
let gt x y = unimp "gt"
let ge x y = unimp "ge"

let sx x w = unimp "sx"
let zx x w = unimp "zx"

let com x = unimp "com"

let fits_signed x w = unimp "fits_signed"
let fits_unsigned x w = unimp "fits_unsigned"

let bitExtract _ _ _ = unimp "bitExtract"
let bitInsert lsb wide narrow = unimp "bitInsert"
@

We can't use [[unimp]] for the following values because the
[[Impossible.Impossible]] exception would be raised when the module is
initialized. So we have to use some dummy value.

Here are some useful IEEE 754 constants, taken from C header files:

\begin{tabularx}{\hsize}{llX}
\tt NaN & \tt 0x7f, 0xc0, 0, 0 & on big endian \\
\tt NaN & \tt 0, 0, 0xc0, 0x7f & on little endian \\
\end{tabularx}

\begin{quote}\it
    Are the results for floating point comparison standardized? It
    seems that FPUs use the four results outlined below. However, they
    seem to be free to use any format they want to indicate these. The
    Intel FPUs for example use 3-bit values to indicate a result. In
    that case we would be free to define our own 2-bit values. It
    would be the task for the platform specific implementation of the
    primitives to present the result in the right form.

    The question and consequences apply to the rounding modes.
\end{quote}

<<bitops.ml ((evaluating))>>=
let dummy = Bits.zero 32

let float_lt        = dummy
let float_gt        = dummy
let float_eq        = dummy
let unordered       = dummy

let round_nearest   = Bits.of_int 0 2
let round_down      = Bits.of_int 1 2
let round_up        = Bits.of_int 2 2
let round_zero      = Bits.of_int 3 2

let shl  _ _ = unimp "shifts"
let shra _ _ = unimp "shifts"
let shrl _ _ = unimp "shifts"

@ \section{Residualising instantiation}


% ----------------------------------------------------------------
\section{Operations on bit vectors}
% ----------------------------------------------------------------

This module encapsulates operations on bit vectors.
Its primary use will be to support constant evaluation, but
it is also used to evaluate `early' expressions during RTL creation.
%
<<bitops.mli ((residualizing))>>=
(*module Bitops*)
type t = Bits.bits
type width = Bits.width
@ 
Standard RTL operators
<<bitops.mli ((residualizing))>>=
(* comparisons *)
val eq : t -> t -> Base.std_bool
val lt : t -> t -> bool
val ne : t -> t -> Base.std_bool
val le : t -> t -> bool
val gt : t -> t -> bool
val ge : t -> t -> bool

val eq' : t -> t -> bool
val ne' : t -> t -> bool

(* we need addition *)
val add : t -> t -> t
    
(* extensions *)
val sx : t -> width -> t  (* sign extend to the given width *)
val zx : t -> width -> t

(* extractions a painless specialty *)
val bitExtract : lsb:int -> t -> width -> t
val bitInsert  : lsb:int -> wide:t -> narrow:t -> t

(* bitwise operations *)
val com : t -> t

(* floating-point goo *)
val float_lt : t
val float_gt : t
val float_eq : t
val unordered : t

val round_nearest : t
val round_zero : t
val round_down : t
val round_up : t

@ 
Testing for widths.
<<bitops.mli ((residualizing))>>=
val fits_signed : t -> width -> Base.std_bool
val fits_signed' : t -> width -> bool
  (* fits_signed v w == v can be narrowed to width w, then
         sign-extended to its original width, without changing its value *)
val fits_unsigned : t -> width -> Base.std_bool
val fits_unsigned' : t -> width -> bool
  (* fits_signed v w == v can be narrowed to width w, then
         zero-extended to its original width, without changing its value *)
@



% ----------------------------------------------------------------
\subsection{Implementation}
% ----------------------------------------------------------------

<<bitops.ml ((residualizing))>>=
type t = Bits.bits
type width = Bits.width

module T = Tdpe
module Sy = Syntax
    
exception Unimplemented of string
(*let unimp s = raise (Unimplemented s)*)

(* some brainless solution *)

let unimp s = ((Bits.BV,Sy.APP(Sy.VAR "raise",Sy.VAR "Unimplemented")),0)

let bitsC = T.a'
let bitsCP = T.pair(T.a',T.a')

@ Here I am making a gross approximation. Also, maybe the implementation
is not quite right. Also, perhaps one will want to residualize the calls
to [[Bits.of_]] for side-effects reasons.
<<bitops.ml ((residualizing))>>=    

let commit ((tag,bitv),w) =
  match tag with
    Bits.INT -> Tdpe.nbe' (Tdpe.arrowN(Tdpe.a',Tdpe.arrowN(Tdpe.a',bitsC)))
	(Sy.VAR "Bits.of_int") bitv (Sy.INT w)
  | Bits.NINT -> Tdpe.nbe' (Tdpe.arrowN(Tdpe.a',Tdpe.arrowN(Tdpe.a',bitsC)))
	(Sy.VAR "Bits.of_nativeint") bitv (Sy.INT w)
  | Bits.INT64 -> Tdpe.nbe' (Tdpe.arrowN(Tdpe.a',Tdpe.arrowN(Tdpe.a',bitsC)))
	(Sy.VAR "Bits.of_int64") bitv (Sy.INT w)
  | Bits.BV -> bitv
    

let bits_bits_bool s ((t1,b1),w1) ((t2,b2),w2) =
  let b1 = commit ((t1,b1),w1) in
  let b2 = commit ((t2,b2),w2) in
  if (w1=w2) then
    T.nbe' (T.arrowN(bitsC,T.arrowN(bitsC,T.booNone)))
      (Sy.VAR s) b1 b2
  else false

@ Be careful here: the sign extension should return 32 bits???
<<bitops.ml ((residualizing))>>=


let bits_int_bool s ((t,b),w) y = 
  T.nbe' (T.arrow(bitsCP,T.arrow(T.a',T.boo)))
    (Sy.VAR s) (b,Sy.INT w) (Sy.INT y)

let bits_int_a' s ((t,b),w) y = 
  T.nbe' (T.arrow(bitsCP,T.arrow(T.a',T.a')))
    (Sy.VAR s) (b,Sy.INT w) (Sy.INT y)

let bitsop s ((t,b),w) =
  ((Bits.BV,T.nbe' (T.arrow(bitsC,T.a'))
      (Sy.VAR s) b),
   w)

let bits_bits_a' s ((t1,b1),w1) ((t2,b2),w2) =
  let b1 = commit ((t1,b1),w1) in
  let b2 = commit ((t2,b2),w2) in
  if (w1=w2) then 
    T.nbe' (T.arrowN(bitsC,T.arrowN(bitsC,T.a'))) (Sy.VAR s)
      b1 b2 
  else (Sy.BOOL false)


let eq = bits_bits_a' "Bitops.eq"
let ne = bits_bits_a' "Bitops.ne"
let lt = bits_bits_bool "Bitops.lt"
let le = bits_bits_bool "Bitops.le"
let gt = bits_bits_bool "Bitops.gt"
let ge = bits_bits_bool "Bitops.ge"

let eq' = bits_bits_bool "Bitops.eq"
let ne' = bits_bits_bool "Bitops.ne"


let bits_bits_bits s ((tag,bits),w) ((tag1,bits1),w1) =
  let bv = commit ((tag,bits),w) in
  let bv1 = commit ((tag1,bits1),w1) in
  let (b2,w2) =
    T.nbe' (T.arrowN(bitsC,T.arrowN(bitsC,bitsCP)))
      (Sy.VAR s) bv bv1 in
  ((Bits.BV,b2),w)


let add = bits_bits_bits "Bitops.add"
    
    
let bits_int_bits s ((tag,bits),w) y =
  let bv = commit ((tag,bits),w) in
  let (b2,w2) =
    T.nbe' (T.arrowN(bitsC,T.arrowN(T.a',bitsCP)))
      (Sy.VAR s) bv (Sy.INT y) in
  ((Bits.BV,b2),32)
    
let sx = bits_int_bits "Bitops.sx"
let zx = bits_int_bits "Bitops.zx"

let com = bitsop "Bitops.com"

let fits_signed = bits_int_a' "Bitops.fits_signed"
let fits_unsigned = bits_int_a' "Bitops.fits_unsigned"

let fits_signed' = bits_int_bool "Bitops.fits_signed"
let fits_unsigned' = bits_int_bool "Bitops.fits_unsigned"

@ Here I clearly do not know what to do
<<bitops.ml ((residualizing))>>=
let bitExtract lsb ((t1,b1),w1) w =
  ((Bits.BV,T.nbe' (T.arrow(T.a',T.arrow(bitsCP,T.arrow(T.a',bitsC))))
      (Sy.VAR "Bitops.bitExtractX") (Sy.INT lsb) (b1,Sy.INT w1) (Sy.INT w)),
   w)
let bitInsert lsb ((t1,wide),w1) ((t2,narrow),w2) =
  ((Bits.BV,T.nbe' (T.arrow(T.a',T.arrow(bitsCP,T.arrow(bitsCP,bitsC))))
      (Sy.VAR "Bitops.bitInsertX") (Sy.INT lsb) (wide,Sy.INT w1) (narrow,Sy.INT w2)),
   w2)

let float_lt = unimp "floating-point stuff"
let float_gt = unimp "floating-point stuff"
let float_eq = unimp "floating-point stuff"
let unordered = unimp "floating-point stuff"

let round_nearest = unimp "floating-point stuff"
let round_zero = unimp "floating-point stuff"
let round_down = unimp "floating-point stuff"
let round_up = unimp "floating-point stuff"
