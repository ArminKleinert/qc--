% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% inc: \usepackage{url,longtable}

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------
\section{Backplane}
% ------------------------------------------------------------------

% ------------------------------------------------------------------
\subsection{Overview}
% ------------------------------------------------------------------

The backplane allows the user to customize the backend of the compiler. The
building blocks of the backplane are the stages between which the user can
define a control flow. Stages represent compiler components, such as the
optimizer or the register allocator. The backplane can also be used with a
finer level of granularity of compiler components, such as individual
optimization stages.

Each stage is a record containing information about the semantic properties
of the stage, as well as a function that carries out the action of the
stage. The semantic properties indicate program state that is expected at
the start of the stage, as well as state that is created and destroyed by
the stage. If it is possible to reach a stage without satisfying the expected
properties of the stage, then the control flow is invalid. Validity of the
control flow is verified in a static checking phase.

\newcommand\vfb[1]
  {\vskip 0pt plus #1\baselineskip \penalty-200 \vskip 0pt plus -#1\baselineskip}

\vfb4

\setlongtables
The properties used in Quick~{\PAL} are as follows:
\begin{longtable}[l]{@{\hskip1.5em}>{\ttfamily}lp{3in}@{}}
sensible source&
  The source code uses well-known operators and sensible variable sizes.
  Presumably a back end advertises what these are.  
  In the long run, we would like to make every operator ``well
  known,'' by implementation in software if need be.
  A~variable, on the other hand, is probably sensible only if it fits
  in a word on the target machine.  For a first cut, 8-, 16-, and
  32-bit variables should probably be considered sensible on a 32-bit
  machine.  We also want 1-bit variables, although that may be
  problematic for our first release.  
  In the long run, our users might like us to simulate large variables
  using, e.g., large arithmetic.
  \par
  This property is established by the \emph{front end}.
  \\ 
proper widths&
  Every operator is specialzed at widths that are
  appropriate to the target machine.  For example, on a 32-bit machine
  that supports no smaller arithmetic, all operators
  would be used at 32~bits.
  (There may be an extension for [[sx]] and [[zx]] operators, which are
  used to load narrow values into wide registers, and for the
  [[lobits]] operator, which is used to store only part of a wide register.)
  This property is established by the \emph{widener}.
  \\ 
no vars& 
  No {\PAL} variable appears in any RTL.

  This property is established by the \emph{variable placer}.
  We imagine four variable placers:
\begin{itemize}
\item 
The Fortran placer (a temporary expedient)
\item
Each variable goes into a temporary
\item
Each variable goes into a stack slot, from which an optimizer might
one day promote it
\item
A few frequently used variables go into hardware registers, and the
rest go onto the stack (the \texttt{lcc} placement)
\end{itemize}
  A variable placer may put a variable in the least significant
  $k$~bits of an $n$-bit temporary.
  \\ 
\emph{machine} invariant& 
  Each RTL, under an appropriate substitution, is
  representable as a single instruction on the target machine.
  Or possibly a more complicated invariant involving the nefarious
  ``assember temporary'' as documented in
  \url{~nr/papers/stack/three.tex} and to appear in the stack paper.
  This property is established by a target-dependent \emph{code expander}.
  \\ 
no temps& 
  No temporary register appears in any RTL.
  This property is established by the \emph{register allocator}.
  \\ 
\rlap{no compile-time constants}&\mbox{}\break
  No compile-time constant appears in any RTL.
  This property is established by the \emph{stack-frame freezer}.
  \\ 
varmap& 
  The [[varmap]] field in the [[Proc.t]] is initialized.
  This property should be established by the variable placer.
  \\ 
live sets&
  The live set at each control-flow node (along each control-flow
  edge?) is accurate.\\ 
simple RHS&
  At most one operator appears on the right-hand side of any RTL,
  except possibly for an RTL that is representable as a single
  instruction on the target machine.  This invariant might be further
  elaborated; see one of the generic code expanders.\\
\end{longtable}
@


<<backplane.mli>>=
module SS : Set.S with type elt = string
type inputs = SS.t
type outputs = SS.t
type proc = Proc.t

type 'a camlFunction = 'a -> proc -> bool
<<stage type>>
<<action type>>
<<backplane types>>

val list2SSet : string list -> SS.t

module T : Lua.Lib.USERTYPE with type 'a t = 'a t'
module Make (T1 : Lua.Lib.TYPEVIEW with type 'a t = 'a t')
            (T2 : Lua.Lib.TYPEVIEW with type 'a t = Proc.t with type 'a combined
= 'a T1.combined)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a T1.combined
@



% ------------------------------------------------------------------
\subsubsection{Stages and Control Flow}
% ------------------------------------------------------------------

A stage represents an individual step of the compiler. This step is
performed by a function, which may expect a single input parameter. Each stage
also expects a particular set of states to be valid when this stage begins;
states may be created or destroyed during the execution of the function.
The state fields are represented by sets instead of lists to facilitate set
operations such as union and intersection, which will be useful during
the semantic checking phase.
<<stage type>>=
type 'a stage = { name : string
                ; fn   : 'a camlFunction
                ; paramExpected  : string option
                ; stateCreated   : outputs
                ; stateDestroyed : outputs
                ; stateUsed      : inputs
                }
@

The [[action]] determines the control flow when a program is
executed.
<<action type>>=
type 'a action = Seq       of 'a action list
               | When_Do   of 'a action * 'a action
               | Unless_Do of 'a action * 'a action
               | Fix       of 'a action
               | Share     of 'a * string * 'a action
               | Ignore    of 'a action
               | Single    of 'a stage
@


To clarify the meanings of the action types, we provide the operational
semantics for the execution of an action. Each action is $a$ is executed from
the starting configuration $\langle a, x, \sigma \rangle$ and ends in the
configuration $\langle v, \sigma'\rangle$. When a [[Share]] action is used,
the shared variable is the $x$ that is passed to all actions within the
scope of the [[Share]] action. If [[Share]] actions are nested, the innermost
[[Share]] action will outscope all others. $\sigma$ represents the current
state of the world, including the \cfg \ and other stored information that
may be modified imperatively. The action results in the Boolean value $v$,
and the state after execution is represented by $\sigma'$. We use $T$ and $F$
to represent the Boolean constants true and false. 


\noindent $[[Seq]](a_1, a_2, ..., a_n)$ performs a list of actions in sequence:
\[
\frac{\langle a_1 , x , \sigma_0\rangle \Downarrow \langle v_1 , \sigma_1 \rangle
      \ \ \ \ 
      \langle a_2 , x , \sigma_1\rangle \Downarrow \langle v_2 , \sigma_2 \rangle
      \ \ \ \ \dots \ \ \ \
      \langle a_n , x , \sigma_{n - 1}\rangle \Downarrow \langle v_n ,
      \sigma_n
\rangle}
     {\langle [[Seq]](a_1 ; a_2; \dots; a_n) , x , \sigma_0\rangle
         \Downarrow \langle v_1 \vee v_2 \vee \dots \vee v_n , \sigma_n\rangle}
\]

\noindent The action $[[When_Do]](cond, body)$ evaluates the $body$ action only
if the $cond$ action returns a true result:
\[
\frac{\langle cond , x , \sigma \rangle \Downarrow \langle F , \sigma' \rangle}
     {\langle [[When_Do]](cond, body) , x , \sigma \rangle \Downarrow \langle F ,
\sigma' \rangle}
\]
\[
\frac{\langle cond , x , \sigma \rangle \Downarrow \langle T , \sigma' \rangle
      \ \ \ \ \langle body , x , \sigma' \rangle \Downarrow \langle v_2 ,
      \sigma'' \rangle}
     {\langle [[When_Do]](cond, body) , x , \sigma \rangle \Downarrow
         \langle v_2 , \sigma'' \rangle}
\]

\noindent Conversely, $[[Unless_Do]](cond, body)$ evaluates the $body$ action only
if the $cond$ action returns a false result:
\[
\frac{\langle cond , x , \sigma \rangle \Downarrow \langle T , \sigma' \rangle}
     {\langle [[Unless_Do]](cond, body) , x , \sigma \rangle \Downarrow \langle
T , \sigma' \rangle}
\]
\[
\frac{\langle cond , x , \sigma \rangle \Downarrow \langle F , \sigma' \rangle
      \ \ \ \ \langle body , x , \sigma' \rangle \Downarrow \langle v_2 ,
\sigma'' \rangle}
     {\langle [[Unless_Do]](cond, body) , x , \sigma \rangle \Downarrow \langle
r_2 , \sigma'' \rangle}
\]

\noindent $[[Fix]](a)$ evaluates an action until it returns a false result:
\[
\frac{\langle a , x , \sigma \rangle \Downarrow \langle F , \sigma' \rangle}
     {\langle [[Fix]](a) , x , \sigma \rangle \Downarrow \langle F , \sigma' \rangle}
\]
\[
\frac{\langle a , x , \sigma \rangle \Downarrow \langle T , \sigma' \rangle
      \ \ \ \ \langle [[Fix]](a) , x , \sigma' \rangle \Downarrow \langle v ,
\sigma'' \rangle}
     {\langle [[Fix]](a) , x \rangle \Downarrow \langle v , \sigma'' \rangle}
\]

\noindent $[[Ignore]](a)$ evaluates an action and returns false, regardless of the
action's result:
\[
\frac{\langle a , x , \sigma \rangle \Downarrow \langle v , \sigma' \rangle}
     {\langle [[Ignore]](a) , x , \sigma \rangle \Downarrow \langle F , \sigma' \rangle}
\]

\noindent $[[Share]](a, x')$ supplies a new input parameter $x'$ for the action $a$:
\[
\frac{\langle a , x' , \sigma \rangle \Downarrow \langle v , \sigma' \rangle}
     {\langle [[Share]](a, x'), x , \sigma \rangle \Downarrow \langle v ,
         \sigma' \rangle}
\]

\noindent $[[Single]](f)$ evaluates the function $f$ ($f$ executes a a single
compiler stage):
\[
\frac{\langle f(x) , x , \sigma \rangle \Downarrow \langle v , \sigma' \rangle}
     {\langle [[Single]](f) , x , \sigma \rangle \Downarrow \langle v, \sigma' \rangle}
\]


Here's the code that implements the execution rules:

<<runProgram>>=
let rec runProgram arg proc = function
    | Seq actionList ->
        let seqHelp truth (action) =
            let result = runProgram arg proc action in
                truth || result in
        List.fold_left seqHelp false actionList
    | When_Do (whenExp, doExp) ->
           runProgram arg proc whenExp
        && runProgram arg proc doExp
    | Unless_Do (unlessExp, doExp) ->
           runProgram arg proc unlessExp
        || runProgram arg proc doExp
    | Fix action ->
           runProgram arg proc action
        && runProgram arg proc (Fix action)
    | Ignore action ->
        let _ = runProgram arg proc action in false
    | Single {fn = func; name = n} -> func arg proc
    | Share (param, _, action) -> runProgram param proc action
@


% ------------------------------------------------------------------
\subsection{Semantic Analysis}
% ------------------------------------------------------------------

A semantic analysis phase is performed to ensure that the control flow is
legal, based on the state information associated with each stage. A legal
control flow ensures that actions will always receive the variables they
expect (from an enclosing [[Share]] action) and the properties used by an
action ([[uses]]) will always reach the action.

In order to perform the semantic analysis, we walk the [[action]]'s in a
depth-first, reverse post-order traversal. At each [[action]], we make any
necessary recursive calls, then we return information about the state properties
for the current [[action]]. The information we return consists of the sets of
state properties that are either used, created, or destroyed in the current
[[action]]. We also return a closure that will compute the set of state
properties that must be live on entering the current [[action]] and the set
of errors that have been found. This closure depends on the input pair of
the errors that have already been found and the set of properties that must
be live after the action is completed (we know this information because we
are performing a reverse post-order traversal).

The use of a closure to compute the live set and errors is not strictly
necessary, but it provides a clean implementation. Each closure is
independent of context, depending only on the subtree which it represents;
the context (necessary for processing the live set and errors) is provided
through the arguments to this closure.

We define three types of errors that can cause an illegal control flow:
\begin{itemize}
\item A [[Sharing]] error occurs if an action expects an input parameter that
      is not provided by the [[Share]] action that is currently in scope. 
\item A [[NoProp]] error occurs if an action expects a state property, but
      this property is never established. This error occurs when we attempt
	  to use a control flow that expects input parameters we never provide -
	  this is not the result of a conflict between actions in the control
	  flow.
\item A [[DestProp]] error occurs if an action $a$ expects a state property, but
      another action has destroyed the property before it can reach $a$.
\end{itemize}

<<error types>>=
type prop = string
type destroysAction = string
type usesAction = string
type formal = string option
type actual = string option
type error = DestProp of prop * destroysAction * usesAction
           | NoProp of prop * usesAction
           | Sharing of formal * actual * usesAction
@

The following rules determine the set of information determined from each type
of [[action]]:

\noindent{Single $a$:}

    $live(live') = (live' - creates_a) \cup use_a$

    $errors(errors') = errors' \cup (live' \cap destroys_a)
                               \cup (creates_a \cap destroys_a)$

    $creates = creates_a$

    $destroys = destroys_a$

    $uses = uses_a$

\noindent{When\_Do ($cond$, $body$):}

    $live(live') = live_{cond}(live' \cup live_{body}(live'))$

    $errors(errors') = errors_{cond}(errors_{body}(errors'))$

    $creates = creates_{cond} - destroys_{body}$

    $destroys = destroys_{cond} \cup destroys_{body}$

    $uses = uses_{cond} \cup (uses_{body} - creates_{cond})$

\noindent{Fix ($a$):}

    $live(live') = (live' - {creates}_a) \cup {use}_a$

    $errors(errors') = errors' \cup (live' \cap destroys_a)
                               \cup (live \cap destroys_a)
                               \cup (creates_a \cap destroys_a)$

    $creates = creates_a$

    $destroys = destroys_a$

    $uses = uses_a$

\noindent{Sequence ($a_1$;...;$a_n$):}

    $live(live') = live_{a_1}(...(live_{a_{n-1}}(live_{a_n}(live'))))$

    $errors(errors') =
        errors_{a_1}(...(errors_{a_{n-1}}(errors_{a_n}(errors'))))$

    $accum\_creates_{a_i} = accum\_creates_{a_{i+1}} \cup
                            (creates_{a_i} - accum\_destroys_{a_{i+1}})$

    $accum\_creates_{a_{n+1}} = \emptyset$

    $creates = accum\_creates_{a_1}$

    $accum\_destroys_{a_i} = accum\_destroys_{a_{i+1}} \cup
                             (destroys_{a_i} - accum\_creates_{a_{i+1}})$

    $accum\_destroys_{a_{n+1}} = \emptyset$

    $destroys = accum\_destroys_{a_1}$

    $accum\_uses_{a_i} = uses_{a_{i+1}} \cup
                         (accum\_uses_{a_i} - creates_{a_{i+1}})$

    $accum\_uses_{a_{n+1}} = \emptyset$

    $uses = accum\_uses_{a_1}$

[[Ignore]] and [[Share]] simply make a recursive call on their sub-actions;
the rules for [[Unless_Do]] are the same as [[When_Do]].

[[walk]] implements these rules, and [[stateCheck]] initializes and calls
this traversal.

<<state checking>>=
let ( ++ ) = SP.union
let ( -- ) = SP.diff
let ( ** ) live destroys =
    let inter = SP.inter live destroys in
    let live = SP.filter (fun (x,_) -> SP.exists (fun (y,_) -> x = y) inter)
                         live in
    let makeError (l1, l2) rst =
        let dest = SP.filter (fun (d1,_) -> l1 = d1) destroys in
        let _ = assert (SP.cardinal dest = 1) in
        let (_, d2) = SP.choose dest in
            (* prop, destroys, uses *)
            DestProp (l1, d2, l2) :: rst
    in
        SP.fold makeError live []
        

(* should find errors of destruction here *)

let checkArg formal actual fnName = match formal, actual with
    | None, _ -> []
    | f, a when f != a -> [Sharing (f, a, fnName)]
    | _ -> []

let spSet_from_sSet name sSet =
    SS.fold (fun elt set -> SP.add (name, elt) set) sSet SP.empty


(* walk : action -> string option -> create * destroy * use *
                                     (live' * errors' -> live * errors)
    where create, destroy, use, live, and live' are of type string * string *)
let rec walk arg a =
    match a with
    | Seq aList ->
        let seqWalk a (seqcreates, seqdestroys, sequses, seqMkLive) =
            let (creates, destroys, uses, mkLive) = walk arg a in
            (seqcreates ++ (creates -- seqdestroys),
             seqdestroys ++ (destroys -- seqcreates),
             uses ++ (sequses -- creates),
             fun (live', errors') ->
                let (seqlive, seqerrors) = seqMkLive (live', errors') in
                    mkLive (seqlive, seqerrors))
        in
            List.fold_right seqWalk aList
                            (SP.empty, SP.empty, SP.empty, fun a -> a)
    | When_Do (cond, body) ->
        let ccreates, cdestroys, cuses, cMkLive = walk arg cond in
        let bcreates, bdestroys, buses, bMkLive = walk arg body in
            (ccreates -- bdestroys,
             cdestroys ++ bdestroys,
             cuses ++ (buses -- ccreates),
             fun (live', errors') ->
                let (blive, berrors) = bMkLive (live', errors') in
                    cMkLive (live' ++ blive, berrors))
    | Unless_Do (cond, body) -> walk arg (When_Do (cond, body))
    | Fix a ->
        let creates, destroys, uses, mkLive = walk arg a in
            (creates, destroys, uses,
             fun (live', errors') ->
                let (flive, ferrors) = mkLive (live', errors') in
                    (flive,
                     ferrors @ (flive ** destroys)))
                             
    | Ignore a -> walk arg a
    | Single {name = fnName; stateUsed = uses; stateCreated = creates;
	          stateDestroyed = destroys; paramExpected = formal} ->
		(match List.map (spSet_from_sSet fnName) [creates; destroys; uses] with
		 | [creates; destroys; uses] ->
			(creates, destroys, uses,
			 fun (live', errors') ->
				((live' -- creates) ++ uses,
				 errors' @ (live' ** destroys) @ (creates ** destroys)
						 @ (checkArg formal arg fnName)))
		 | _ -> assert false)
	| Share (_, localArg, a) -> walk (Some localArg) a

let stateCheck a =
    let (_, _, _, check) = walk None a in
        check (SP.empty, [])
@


% ------------------------------------------------------------------
\subsubsection{Running}
% ------------------------------------------------------------------

To run a program of [[action]]'s, we first perform a semantic check, and barring
errors, we run the program.

<<run>>=
exception MismatchedParameters of string

let run main proc input =
(*
    let _ = backSay ["Running stateCheck()\n"] in
*)
    let (liveIn, errors) = stateCheck main
    in
        match errors with
        | [] ->
(*
            (backSay ["No Errors. Running runProgram()\n"]
*)
             runProgram V.Nil proc main
        | _ ->
            (backSay ["Errors in control flow.\n"]; false)

@

The backplane introduces three new types. A [[StageFn]] is the function that
actually executes the compiler step represented by a stage. [[Stage]]'s include
the state property information that is associated with a [[StateFn]].
[[Action]]'s, as before, are the types that indicate a control flow between
these stages.

<<backplane types>>=
    type 'a t' = Action of 'a action
               | Stage of 'a stage
@

Putting it all together:

<<backplane.ml>>=
module StringMod = struct
    type t = string
    let compare = compare
end
module SS = Set.Make(StringMod)
module StringPairMod = struct
    type t = string * string
    let compare = fun (a,_) (b,_) -> compare a b
end
module SP = Set.Make(StringPairMod)

let list2SSet lst = List.fold_right SS.add lst SS.empty

type inputs = SS.t
type outputs = SS.t

type proc = Proc.t
type 'a camlFunction = 'a -> proc -> bool

let backSay = Verbose.say 10
<<stage type>>
<<action type>>
<<backplane types>>
<<error types>>
<<printing>>
<<runProgram>>

<<lua library modules>>
@

To construct a Lua interpreter, we need two modules: T and Make.

<<lua library modules>>=
module T : Lua.Lib.USERTYPE with type 'a t = 'a t' = struct
    type 'a t = 'a t'
    let tname = "Backplane"
    let eq veq x y = match x, y with
    | Action  x, Action  y -> x = y
    | Stage  x, Stage  y -> x = y
    | _, _ -> false
    let to_string vs = function
    | Action a -> printAction  (makeIndent 26) a
    | Stage s -> "<stage>"
end

module Make (T1 : Lua.Lib.TYPEVIEW with type 'a t = 'a t')
            (T2 : Lua.Lib.TYPEVIEW with type 'a t = Proc.t with type 'a combined
= 'a T1.combined)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a T1.combined =
  struct
    type 'a combined = 'a T1.combined
    module M (Interp : Lua.Lib.CORE with type 'a V.userdata' = 'a
combined) =
      struct
        module V = Interp.V
        <<state checking>>
        <<backplane builtins>>

        type state = Interp.V.state
        let init g = Interp.register_module "Backplane" backplane_builtins g;
          Lua.Lib.StringList.empty (* FIX *)
     end
  end
@


We provide embedding/projection pairs for each of the backplane types.

LARGE UGLY BOGON!  THE ACTION MAP, IF IT IS PASSED A TABLE, SHOULD GO
AHEAD AND ATTEMPT TO PROJECT THAT TABLE INTO A STAGE.  IF SUCCESSFUL,
IT SHOULD THEN APPLY SINGLE TO THE RESULT.  THIS WAY, SINGLE NEVER
SHOWS UP AT THE LUA LEVEL. ---NR
<<backplane builtins>>=
let {V.embed = embed; V.project = project} = T1.makemap V.userdata V.projection

let ( **-> ) = V.( **-> )
let proc    = T2.makemap V.userdata V.projection
let stageFn = V.pfunc (V.value **-> proc **-> V.result V.bool)

<<stage map>>

let projectAsAction v =
  match project v with
  | Action a -> a
  | _ -> raise (V.Projection (v, "action"))
  
let projectAction v = match v with
  | V.Userdata _ -> projectAsAction v
  | V.Table _    -> single (projectStage v)
  | _ -> raise (V.Projection (v, "action"))

let action = { V.embed   = (fun a -> embed (Action a))
             ; V.project = projectAction 
             }
let inputs = { V.embed = (fun s -> (V.list V.string).V.embed (SS.elements s))
             ; V.project = (fun v ->
                               try List.fold_left (fun a b -> SS.add b a)
                                      SS.empty ((V.list V.string).V.project v)
                               with _ -> raise (V.Projection (v, "inputs")))
             }
@


Finally, we make the list of builtins that will be visible in Lua.

<<backplane builtins>>=
<<run>>
let ( **-> ) = V.( **-> )

let backplane_builtins =
  [ "seq",       (V.pfunc ((V.list action)     **-> V.result action)).V.embed seq
  ; "when_do",   (V.pfunc (action  **-> action **-> V.result action)).V.embed when_do
  ; "unless_do", (V.pfunc (action  **-> action **-> V.result action)).V.embed unless_do
  ; "fix",       (V.pfunc (action  **->             V.result action)).V.embed fix
  ; "share",     (V.pfunc (V.value **-> V.string **-> action **->
                                                    V.result action)).V.embed share
  ; "ignore",    (V.pfunc (action  **->             V.result action)).V.embed ignore
  ; "single",    (V.pfunc (stage   **->             V.result action)).V.embed single
  ; "run",       (V.pfunc (action **-> proc **-> inputs **-> 
                                                    V.result V.bool)).V.embed run
  ]
@


In order to use the Lua interpreter to control the backplane, we must
provide the embedding/projection pair for a stage. When we project a stage into
Caml, we provide sensible defaults for unspecified members of the stage record.

<<stage map>>=
let embedString = V.string.V.embed
let projectString = V.string.V.project

let projectStage stage' = match stage' with
  | (V.Table stage) ->
    { name = (match V.Table.find stage (embedString "name") with
              | V.Nil ->
                  (match V.objname (V.state ()) stage' with
                   | None -> "<anonymous stage>"
                   | Some (V.Fallback s) -> s
                   | Some (V.Global s) -> s
                   | Some (V.Element (s, _)) -> s)
              | s -> projectString s)
    ; fn = stageFn.V.project (V.Table.find stage (embedString "fn"))
    ; paramExpected = (V.option V.string).V.project
                          (V.Table.find stage (embedString "paramExpected"))
    ; stateCreated = list2SSet
                 (match (V.Table.find stage (embedString "creates")) with
                  | V.Nil -> [] 
                  | x -> ((V.list V.string).V.project x))
    ; stateDestroyed = list2SSet
                 (match (V.Table.find stage (embedString "destroys")) with
                  | V.Nil -> [] 
                  | x -> ((V.list V.string).V.project x))
    ; stateUsed = list2SSet 
                     (match (V.Table.find stage (embedString "uses")) with
                      | V.Nil -> [] 
                      | x -> ((V.list V.string).V.project x))
    }
  | _ -> raise (V.Projection (stage', "stage"))


let embedStage stage =
    let stageLabels =
        [ embedString "name"
        ; embedString "fn"
        ; embedString "paramExpected"
        ; embedString "stateCreated"
        ; embedString "stateDestroyed"
        ; embedString "stateUsed"
        ] in
    let stageValues =
        [ embedString stage.name
        ; stageFn.V.embed stage.fn
        ; (V.option V.string).V.embed stage.paramExpected
        ; (V.list V.string).V.embed (SS.elements stage.stateCreated)
        ; (V.list V.string).V.embed (SS.elements stage.stateDestroyed)
        ; (V.list V.string).V.embed (SS.elements stage.stateUsed)
        ] in
    let newTab = (V.Table.create (List.length stageLabels)) in
    let _ = List.iter2 
                (fun key data -> V.Table.bind newTab ~key ~data) 
                stageLabels stageValues
    in
        V.Table newTab

let stage = { V.embed = embedStage
            ; V.project = projectStage
            }
@


We set up wrappers to create the [[action]] types. These functions will
be the primitives visible in Lua.

<<stage map>>=
let seq alst = Seq alst
let when_do a1 a2 = When_Do(a1, a2)
let unless_do a1 a2 = Unless_Do(a1, a2)
let fix a = Fix a
let share value name a = Share(value, name, a)
let ignore a = Ignore a
let single a = Single a
@



% ------------------------------------------------------------------
\subsection{Miscellaneous Procedures}
% ------------------------------------------------------------------

% ------------------------------------------------------------------
\subsubsection{Printing}
% ------------------------------------------------------------------

We provide relatively straightforward printing functions for [[action]]'s,
macro [[definition]]'s, [[program]]'s, and [[error]]'s. [[makeIndent]] is
used to create a blank indentation of the input size, and [[printList]] is
a higher-order function used to print a list of any type, when passed an
appropriate output function for that type.

<<printing>>=
let makeIndent length =
    let blank = " " in
    let rec makeIndentHelp indent = function
        | 0 -> indent
        | num -> makeIndentHelp (indent ^ blank) (num - 1)
    in
        makeIndentHelp "" length
let noIndent = makeIndent 0

let rec printList indent separator appFn = function
    | [] -> ""
    | [el] -> appFn indent el
    | el::rst ->
        (appFn indent el) ^
        (separator ^ indent) ^
        (printList indent separator appFn rst)

let rec printAction indent =
    let printActionList indent =
        printList indent ",\n" printAction
    in function
    | Seq actions ->
        let text = "Seq[" in
        let newIndent = indent ^ (makeIndent (String.length text)) in
            text ^ printActionList newIndent actions ^
            "]"
    | When_Do (whenExp, doExp) ->
        let text = "When_Do(" in
        let newIndent = indent ^ (makeIndent (String.length text)) in
            text ^ printAction newIndent whenExp ^
            ",\n" ^ indent ^ printAction newIndent doExp ^ ")"
    | Unless_Do (unlessExp, doExp) ->
        let text = "Unless_Do(" in
        let newIndent = indent ^ (makeIndent (String.length text)) in
            text ^ printAction newIndent unlessExp ^
            ",\n" ^ indent ^ printAction newIndent doExp ^ ")"
    | Fix action ->
        let text = "Fix(" in
        let newIndent = indent ^ (makeIndent (String.length text)) in
            text ^ printAction newIndent action ^ ")"
    | Ignore action ->
        let text = "Ignore(" in
        let newIndent = indent ^ (makeIndent (String.length text)) in
            text ^ printAction newIndent action ^ ")"
    | Single {name = name} -> name
    | Share (param, paramType, action) ->
        let text = "Share(" ^ paramType ^ ", " in
        let newIndent = indent ^ (makeIndent (String.length text)) in
            text ^ printAction newIndent action ^ ")"



let printError err =
    let printOpt opt = match opt with
        | None -> "Nil"
        | Some a -> noIndent ^ a in
    let identity x y = x ^ y in
    let error text = "Error: " ^ text
    in
        match err with
        | DestProp (prop, dest, uses) ->
            error (String.concat " "
                       [ "Property"
                       ; prop
                       ; "needed by"
                       ; uses
                       ; "is destroyed by"
                       ; dest
                       ; ".\n"
                       ])
        | NoProp (prop, uses) ->
            error (String.concat " "
                       [ "Property"
                       ; prop
                       ; "needed by"
                       ; uses
                       ; "is never provided"
                       ; ".\n"
                       ])
        | Sharing (formal, actual, fnName) ->
            let valOf = function
                | None -> "None"
                | Some v -> v in
            let formal = valOf formal in
            let actual = valOf actual in
            error (String.concat " "
                       [ "Variable type mismatch:"
                       ; fnName
                       ; "expects"
                       ; actual
                       ; "but was passed type"
                       ; actual
                       ; ".\n"
                       ])

                       (*
        | Arg (formal, actual, action) ->
            error ("Cannot convert actual argument " ^ (printOpt actual) ^
                   " to formal argument " ^ (printOpt formal) ^ " in action\n" ^
                   (printAction noIndent action))
        | Live (prop, action) -> 
            error ("State property " ^ prop ^
                   " that is used in a future stage is destroyed by action\n" ^
                   (printAction noIndent action))
            *)


@


