% -*- mode: Noweb; noweb-code-mode: caml-mode -*-


% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon


% ------------------------------------------------------------------ 
\section{Auxiliaries}
% ------------------------------------------------------------------ 

This module provides functions we found too useful to hide them in a
specific module. They are usually small and generic and one could
argue that we found them missing in {\ocaml} standard library.

<<aux.mli>>=
val round_up_to : multiple_of:int -> int -> int
  (* round_up_to n k rounds k up to the nearest multiple of n.
     n must be positive and k must be nonnegative *)

val foldri : (int -> 'a -> 'b -> 'b) -> 'a list -> 'b -> 'b
  (* fold list elements right to left, passing index for List.nth *)

val from: int -> upto:int -> int list
  (* from x ~upto:y is the list of integers x, .., y *)

module Option : sig 
    val get: 'a -> 'a option -> 'a
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<aux.ml>>=
module Option = struct
    let get x = function
        | Some y -> y
        | None   -> x
end

<<aux.ml>>=
let round_up_to ~multiple_of:n k = n * ((k+(n-1)) / n)

<<aux.ml>>=
let foldri f l z =
  let rec next n = function
    | [] -> z
    | x :: xs -> f n x (next (n+1) xs) in
  next 0 l

let rec from first ~upto = 
    if first > upto then [] else first :: from (first+1) ~upto
