% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{X86 calling conventions}

My goal here is to avoid knowing anything about instructions.
The parameters represent the machine instructions to implement
[[return]] and [[cut to]].
<<x86call.mli>>=
val c : return_to:(Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
  (* C calling convention *)
val cmm : return_to:(Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
  (* C-- calling convention *)
val notail: return_to:(Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
  (* C-- calling convention without tail calls *)
@ 

\paragraph{Debugging support}

Dumps automata to [[stdout]]. The two arguments are the widths and hints
to try in every state of the automaton to reach the next state. These
functions are exported to Lua.

<<x86call.mli>>=
val dump_c_proc:    int list -> string list -> unit
val dump_c_cutto:   int list -> string list -> unit
val paths_c_proc:    int list -> string list -> unit
val paths_c_cutto:   int list -> string list -> unit
@

\section{Implementation of X86 calling conventions}
We use these abbreviations:
<<x86call.ml>>=
module A  = Automaton
module C  = Call
module R  = Rtl
module RP = Rtl.Private
module RS = Register.Set
module RU = Rtlutil
module T  = Target
@ 
\paragraph{General information}
Information on the C~calling convention is from the SYSV ABI, Third
Edition, ISBN 0-13-104670-5. 

Values are aligned on 1-, 2-, or 4-byte boundaries.
Doubles and long doubles are 4-byte aligned; others have the alignment
of their size.

Structures, arrays, and unions take the alignment of their most
aligned component.

From Figure 3-14,
the return register is  [[eax]], and the volatile registers are
[[ebx]], [[esi]], and [[edi]].
@ 
\paragraph{X86 registers and their conventional uses}
Calling conventions refer to registers frequently, so it is
appropriate to be able to refer to them by name.
Lua code would do something similar.
<<x86call.ml>>=
let eax = ('r', 0, 32)
let ecx = ('r', 1, 32)
let edx = ('r', 2, 32)
let ebx = ('r', 3, 32)
let esp = ('r', 4, 32)
let ebp = ('r', 5, 32)
let esi = ('r', 6, 32)
let edi = ('r', 7, 32)
let vfp = Vfp.mk 32
@ 
Here are the volatile and nonvolatile registers.
N.B. In position-independent code, [[ebx]] is reserved to point to the
global offset table.
Flags are also volatile, except that the direction flag must be set to
``forward'' (that is, zero) on entry and exit.
<<x86call.ml>>=
let volregs = RS.of_list [eax; ecx; edx]
let nvregs  = RS.of_list [ebx; esi; edi; ebp]
let allregs = RS.elements (RS.union volregs nvregs)
@  N.B. We omit all floating-point registers.
These are all volatile and available for allocation, although
[[%st(0)]] can used to return a floating-point result.
The ABI says that all these registers ``must be empty'' at entry and
exit (except that [[%st(0)]] need not be empty if it holds a result).
Understanding ``empty'' requires understanding $x$86 floating-point.
@ 
For now, we save a nonvolatile register anywhere.
Later, we may want mechanisms for saving them in conventional locations.
<<x86call.ml>>=
let saved_nvr temps =
  let t = Talloc.Multiple.loc temps 't' in
  fun (_, _, w) -> t w
@
\paragraph{Conventions governing the stack}
Page 3-10.  The stack is word-aligned.
The stack pointer points at the last item on the stack, \emph{not} at
an empty slot.
<<x86call.ml>>=
let sp       = R.reg esp
let spval    = R.fetch sp 32
let sp_align = 4
let growth   = Memalloc.Down
let bo       = R.LittleEndian
@
\paragraph{Generic automaton support}
The two infix operators both represent the basic composition operator,
which must instantiated at two types:
stage followed by stage is stage,
and 
stage followed by implementation is implementation.
<<x86call.ml>>=
let ( **> ) f x = f x
let ( *> ) f1 f2 x = f1 (f2 x)
@ 
We provide error parameters to automata.
<<x86call.ml>>=
let badwidth what w = Impossible.impossible
    ("Unsupported (rounded) width " ^ string_of_int w ^ " in x86 " ^ what)
let imp _ = Impossible.impossible "grave miscalculation in automaton"
@ 
\paragraph{Automata for passing values---C~convention}

For results,
we cheat a bit: this convention is
strictly more permissive than~C, as it permits returning one integer
\emph{and} one floating result.
Any floating-point result is automatically widened to 80~bits, and
an integer result is widened to 32~bits.
<<x86call.ml>>=
let results iregs = 
  A.choice
     [ A.is_hint "float",  A.widen  (Aux.round_up_to ~multiple_of:80) *>
                           A.widths [80] ~errormsg:(badwidth "x86 floating return") *>
                           A.useregs [('f', 0, 80)] ~errormsg:imp
     ; A.is_any,           A.widen  (Aux.round_up_to ~multiple_of:32) *>
                           A.widths [32] ~errormsg:(badwidth "x86 return convention") *>
                           A.useregs iregs ~errormsg:imp
     ]
let c_results = results [eax] **> A.no_overflow 4 "multiple return values for x86 C"
@
When passing procedure parameters, we put
earlier arguments in lower addresses, so even though the
stack grows down, the overflow block grows up.
An argument's size is increased, if necessary, to make it a multiple
of words.  The ABI specifies padding, but we'll use [[widen]] because
the machine is little-endian.
<<x86call.ml>>=
let c_arguments = 
  A.widen  (Aux.round_up_to ~multiple_of:32) **>
  A.overflow ~memsize:8 ~byteorder:bo ~growth:Memalloc.Up ~max_alignment:sp_align
let _ = (c_arguments : A.implementation)
@ 
When passing cut-to parameters, we use all the registers---there's no
reason not to.
<<x86call.ml>>=
let cut_args = 
  A.widen  (Aux.round_up_to ~multiple_of:32) **>
  A.widths [32] ~errormsg:(badwidth "x86 cut-to convention") **>
  A.useregs allregs ~errormsg:imp **>
  A.overflow ~memsize:8 ~byteorder:bo ~growth:Memalloc.Up ~max_alignment:sp_align
@ 
It's worth studying these automata to see what's likely to remain
unchanged across conventions:
memsize, byte order, stack alignment, and growth direction are good
candidates for defaulting.
@
\paragraph{Automata for passing values---{\PAL}~convention}
N.B. YOU CANNOT AFFORD TO TAKE \emph{ALL} THE SCRATCH REGISTERS AWAY
FROM THE ALLOCATOR.
WE NEED A BETTER WAY OF DETECTING THIS ERROR OTHER THAN HAVING THE
REGISTER ALLOCATOR DUMP CORE.
<<x86call.ml>>=
let cmm_results =
  results [eax; ecx] **>
  A.overflow ~memsize:8 ~byteorder:bo ~growth:Memalloc.Down ~max_alignment:sp_align

let cmm_arguments = 
  A.widen (Aux.round_up_to ~multiple_of:32) **>
  A.useregs [eax; ecx] ~errormsg:imp **>
  A.overflow ~memsize:8 ~byteorder:bo ~growth:Memalloc.Up ~max_alignment:sp_align
@
\paragraph{Managing the stack pointer and return address}
On entry, the stack pointer points to the return address.
This needs some aliasing info?
<<x86call.ml>>=
let amem = R.mem (R.aligned 4) 'm' bo 32 
let ra = amem vfp
let const x _ = x
@ 
The ``normal'' location for the stack pointer is at the bottom of the
frame. 
This line of code should be the \emph{only} place in the compiler
where the constant [["minus frame size"]] is mentioned.
Clients should use the base of the appropriate block in the calling convention.
<<x86call.ml>>=
let addk = RU.addk 32
let add  = RU.add  32
let std_sp_location = add vfp (R.late "minus frame size" 32)
@ 
TROUBLESOME STUFF: [[~autosp]] SEEMS TO BE USED ONLY TO SET
[[Call.insp]], WHICH ONE THINKS WOULD BE USEFUL ONLY FOR INCOMING GOO.
IT'S UNCLEAR WHETHER THE [[~postsp]] WOULD BE USED ONLY FOR OUTGOING
OR FOR BOTH.

N.B. the call instruction moves the stack pointer.
<<functions to transform automata>>=
let call_actuals  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out call parms" A.at specs.call)
    ~autosp:(fun r -> Block.base r.A.overflow)
    ~postsp:(fun _ sp -> sp) in  (* was ~postsp:(fun _ -> std_sp_location) *)
let prolog  =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> A.at (addk vfp 4) specs.call)
    ~autosp:(fun _ -> vfp)
    ~postsp:(fun _ _ -> std_sp_location) in
   (* alternate: ~mkauto:Block.relative vfp "in call parms" specs.call *)
   (*   ~autosp:(fun r -> addk (Block.base r.A.overflow) (-4)) *)
@ 
<<functions to transform automata>>=
let call_results  =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" A.at specs.results)
    ~autosp:(fun r -> Block.base r.A.overflow)
    ~postsp:(fun _ _ -> std_sp_location) in  (* irrelevant? *)
let epilog  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" A.at specs.results)
    ~autosp:(fun r -> Block.base r.A.overflow)
    ~postsp:(fun _ r -> addk r (-4)) in
@ 
We need an assertion here!
<<functions to transform automata>>=
let also_cuts_to =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in cont parms" A.at specs.cutto)
    ~autosp:(fun r -> std_sp_location)
    ~postsp:(fun _ _ -> std_sp_location) in

let cut_actuals base  =
  C.outgoing ~growth ~sp ~mkauto:(fun () -> A.at base specs.cutto)
     ~autosp:(fun r -> spval)  (* should this be std_sp_location? *)
     ~postsp:(fun _ _ -> spval) in
@ 
\paragraph{Putting together the whole convention}
<<x86call.ml>>=
type ('a, 'b, 'c) specs = { call : 'a; results : 'b; cutto : 'c }
let conv name jump specs ~return_to cut =
  <<functions to transform automata>>
  let return k n ~ra =
    if k = 0 & n = 0 then return_to ra
    else Impossible.impossible "alternate return using C calling convention" in
  { C.name       = name
  ; C.jump_ok    = jump
  ; C.call_parms = { C.in' = prolog;       C.out = call_actuals}
  ; C.cut_parms  = { C.in' = also_cuts_to; C.out = cut_actuals}
  ; C.results    = { C.in' = call_results; C.out = epilog}

  ; C.stack_growth     = Memalloc.Down
  ; C.stable_sp_loc    = std_sp_location
  ; C.replace_vfp      = Cfgx.Vfp.replace_with ~sp
  ; C.sp_align         = 4               (* alignment of stack pointer at call/cut *)
  ; C.ra_on_entry      = const (R.fetch ra 32)   (* where return address is on entry *)
  ; C.where_to_save_ra = if jump then (fun _ t -> Talloc.Multiple.loc t 't' 32)
                         else         (fun _ _ -> ra)
  ; C.ra_on_exit       = if jump then (fun _ b _ -> amem (addk (Block.base b) (-4)))
                         else         (fun _ _ _ -> ra)
  ; C.pre_nvregs       = nvregs          (* registers preserved across calls *)
  ; C.volregs          = volregs         (* registers not preserved across calls *)
  ; C.saved_nvr        = saved_nvr
  ; C.cutto            = cut
  ; C.return           = return
  } 

let c   = conv "C"   false { call = c_arguments;   results=c_results;   cutto=cut_args}
let cmm = conv "C--" true  { call = cmm_arguments; results=cmm_results; cutto=cut_args}
let notail= conv "notail" false
              { call = cmm_arguments; results=cmm_results; cutto=cut_args}

let dump what automaton widths hints = 
        what
        ~mk:(fun () -> A.at (Rtl.bits (Bits.zero 32) 32) automaton)
        ~widths
        ~hints
        
let dump_c_proc   = dump Automatongraph.print c_arguments 
let dump_c_cutto  = dump Automatongraph.print cut_args
let paths_c_proc  = dump Automatongraph.paths c_arguments 
let paths_c_cutto = dump Automatongraph.paths cut_args
@

              
