% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Intel $x$86 Recognizer} \label{x86rec.sec}
% ------------------------------------------------------------------ 

%%Grades: B Subsystem Later

This module provides functions that recognize an Intel
$x$86 RTL.
As an experiment, the recognizer is implemented using BURG rules.
If the instruction is recognized, it is coverable with small cost.
(Perhaps one day, the cost could be bytes of code.)
If it is not recognized, there is a catchall rule that recognizes
anything with cost~100 (I~hope).

WARNING: THIS RECOGNIZER DOES NOT (YET) RECOGNIZE KILLS.

The level of indirection is an artifact from the old days.
We keep it because in the future, the recognizer might want to take a
module parameter.
N.B.~A~recognizer takes two forms: one to say if we have an
instruction, and one to convert to an assembly-language string.
<<x86rec.mli>>=
module M : sig
  val is_instruction : Rtl.rtl -> bool
  val to_asm         : Rtl.rtl -> string
end
@ 
<<x86rec.mlb>>=
%head {: <<modules>> 
         module M = struct
           <<code to precede the labeler>>
      :}
%tail {:   <<code to follow the labeler>>
         end (* of M *) 
      :}

%term <<names of types of terminals>>

%type ah {: string :}
%type ahval {: string :}
%type any {: string :}
%type ax {: string :}
%type const {: string :}
%type const8 {: string :}
%type disp {: string :}
%type eaddr {: string :}
%type eaddrl {: string :}
%type eax {: unit :}
%type ecx {: unit :}
%type edi {: unit :}
%type eight {: unit :}
%type eip {: unit :}
%type esi {: unit :}
%type esp {: unit :}
%type fiadd {: int * string :}
%type i2f_mem {: int * string :}
%type four {: unit :}
%type fpccl {: unit :}
%type fppop {: unit :}
%type fppop2 {: unit :}
%type fppush {: unit :}
%type fpsp {: unit :}
%type fpstack1 {: unit :}
%type fpstack1l {: unit :}
%type fpstacknext {: unit :}
%type fpstacknextl {: unit :}
%type fpstacktop {: unit :}
%type fpstacktopl {: unit :}
%type fpustatus {: unit :}
%type fpustatusl {: unit :}
%type immed {: string :}
%type immed8 {: string :}
%type inst {: string :}
%type lconst {: string :}
%type mem {: string :}
%type meml {: string :}
%type minusfour {: unit :}
%type one3 {: unit :}
%type pop {: unit :}
%type push {: unit :}
%type reg {: string :}
%type reg8 {: string :}
%type regabcd {: string :}
%type regabcdl {: string :}
%type regl {: string :}
%type regl8 {: string :}
%type regpair {: string :}
%type regpairl {: string :}
%type stacknext {: unit :}
%type stacktop {: unit :}
%type target {: string :}
%type two3 {: unit :}
%type zero {: unit :}


%%
<<rules>>
@
A few abbreviations.
<<modules>>=
module RP = Rtl.Private
module RU = Rtlutil
module SS = Space.Standard32
module Down  = Rtl.Dn      (* Convert Down  to private repr. *)
module Up    = Rtl.Up       (* Convert Up    to abstract repr. *)
@
If something goes wrong during recognition, we raise this exception.
It's different from merely ``unrecognized;'' it means something
happened that shouldn't have.
<<code to precede the labeler>>=
exception Error of string
let error msg = raise (Error msg)
@
We should be using [[sprintf]] more.
<<code to precede the labeler>>=
let sprintf = Printf.sprintf
@ 


% ------------------------------------------------------------------ 
\subsection{Utilities}
% ------------------------------------------------------------------ 

We've had some mystery problems; in particular, we've seen the integer
$-4$ get converted to 32~bits with its sign bit clear.
<<code to precede the labeler>>=
let weirdb = Bits.S.of_int (-4) 32
let weird = Nativeint.to_string (Bits.S.to_native weirdb)
 (* let _ = List.iter prerr_string ["Weird integer is "; weird; "\n"] *)
let native' w b = 
  assert (Bits.width b = w);
  Nativeint.to_string (Bits.U.to_native b)
let native = native' 32
let cat = String.concat ""
@   
The [[guard]] function turns a predicate into a cost.
<<code to precede the labeler>>=
let infinity = Camlburg.inf_cost
let guard b = if b then 0 else infinity
@ 
The $x$86 uses a suffix to denote width.
<<code to precede the labeler>>=
let suffix w = match w with
| 8  -> "b"
| 16 -> "w"
| 32 -> "l"
| _ -> Impossible.impossible "width in x86 not 8/16/32"
let fsuffix w = match w with
| 32 -> "s"
| 64 -> "l"
| 80 | 96 -> "t"
| _ -> Impossible.impossible "floating-point width in x86 not 32/64/80"
let fisuffix w = match w with
| 16 -> "w"
| 32 -> "l"
| 64 -> "q"
| _ -> Impossible.impossible "int to/from fpregs width in x86 not 16/32/64"
@
% ------------------------------------------------------------------ 
\subsection{Register names}
% ------------------------------------------------------------------ 
<<code to precede the labeler>>=
let r8_names  = [| "%al"; "%cl"; "%dl"; "%bl"; "%ah"; "%ch"; "%dh"; "%bh" |]
let r16_names = [| "%ax"; "%cx"; "%dx"; "%bx"; "%sp"; "%bp"; "%si"; "%di" |]
let r32_names = [| "%eax"; "%ecx"; "%edx"; "%ebx"; "%esp"; "%ebp"; "%esi"; "%edi" |]
let reg_names w = match w with
| 8  -> r8_names
| 16 -> r16_names
| 32 -> r32_names
| _  -> Impossible.impossible "x86 register width not 8/16/32"
let regname w = Array.get (reg_names w)
let hregname r = sprintf "%%%ch" r.[2]  (* pass %eax, get back %ah *)
@ 
\subsection{Other machine info}
<<code to precede the labeler>>=
let fpcc = Down.loc X86.fpcc
let fpustatus = Down.loc X86.fpustatus
@     



% ------------------------------------------------------------------ 
\subsection{Recognizer terminals, nonterminals, and constructors}
% ------------------------------------------------------------------ 

In a {\burg} pattern, a name denotes either a polymorphic nonterminal
symbol or a monomorphic terminal symbol. 
We distinguish terminals from nonterminals by name, so we have to
announce the names of the nonterminals.
<<names of types of terminals>>=
n w bits symbol
@ Terminals [[n]] and [[w]] are an index and width; both are integers.
Terminal [[bits]] is a constant of types [[Bits.bits]]; terminal
[[symbol]] is a string.
@
The recognizer uses these nonterminals:
\begin{quote}
\begin{tabularx}{\linewidth}{@{}>{\ttfamily}lX@{}}
    \emph{Nonterminal} & \emph{Meaning} \\ 
regl& A location corresponding to a register\\
regpairl& A location corresponding to a register pair\\
reg& A value corresponding to a register\\
regpair& A value corresponding to a register pair\\
meml& A location in memory\\
mem& A value in memory\\
eaddrl& An effective address in an lvalue context (a location to be
assigned to)\\
eaddr& An effective address in an rvalue context (a value)\\
lconst& A link-time constant\\
const& A compile-time constant\\
immed& An ``immediate'' constant expression as supported in the
assembly language\\
disp& An expression of the form $r+k$ or $k+r$ (displacement address)\\
inst& An instruction\\
any& Any tree (used for debugging)\\
\end{tabularx}
\end{quote}
@
The recognizer uses constructors that correspond to RTL
operations, including [[Fetch]], [[Store]], [[Guarded]], and [[Par]].
It also uses a separate, eponymous constructor for each RTL operator.
Finally, it uses these special constructors:
\begin{quote}
\begin{tabularx}{\linewidth}{@{}>{\ttfamily}lX@{}}
    \emph{Nonterminal} & \emph{Meaning} \\ 
Withaflags& An operation that sets flags using the arithmetic flag
convention (with two operands)\\
Withlflags& An operation that sets flags using the logical flag
convention (with one result)\\
Setflags& Assign the flags\\
Llr& An effect of the form $L \mathrel{:=} L \oplus R$\\
Jcc& A jump conditional on the condition codes (flags)\\
Nop& A no-op\\
\end{tabularx}
\end{quote}
It's tempting to eliminate [[Fetch]], which would simplify rules, but
which would mean including widths on at least some operators.
@

% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
% ------------------------------------------------------------------ 

\paragraph{Constants}
First, constants of various sorts.
The constant~4 plays a key role because it is used to adjust the stack
pointer. 
<<rules>>=
lconst : Link(symbol, w) {: symbol#mangled_text :}
pic    : Diff(c1:lconst,c2:lconst) {: c1 ^ " - " ^ c2 :}
const  : Bits(b:bits)  [{: guard (Bits.width b = 32) :}]  {: native b :}
const8 : Bits(b:bits)  [{: guard (Bits.width b = 8) :}]  {: native' 8 b :}
four   : Bits(b:bits)
    [{: guard (Bits.Ops.eq (Bits.U.of_int 4 (Bits.width b)) b) :}] {: () :}
minusfour : Bits(b:bits)
    [{: guard (Bits.Ops.eq (Bits.S.of_int (-4) (Bits.width b)) b) :}] {: () :}
@ 
\paragraph{Locations and effective addresses}
Here are the basic locations.
We can't refer to just any location in memory, but only to one that is
accessible using the standard addressing modes.
We've omitted the indexed modes, which use two registers.
<<rules>>=
regl : Reg('r', n, w) {: regname w n :}
regabcdl : Reg('r', n, w) [{: guard (n < 4) :}] {: regname w n :}
regl8: Reg('r', n, w) {: regname 8 n :}
regl8H  : Slice(w, i:n, regabcdl) [{: guard (w=8 && i=8) :}] {: hregname regabcdl :}
regl_ecx: Reg('r', n, rw:w) [{: guard (n=1) :}] {: () :}
regpairl : RegPair(reg1:regl,reg2:regl) {: reg2 :}
meml : Mem(reg,  w)   {: "(" ^ reg ^ ")" :}  -- indir
meml : Mem(disp, w)   {: disp :}
meml : Mem(lconst, w) {: lconst :}
disp : Add(reg, const) {:  const ^ "(" ^ reg ^ ")" :}
disp : Add(const, reg) {:  const ^ "(" ^ reg ^ ")" :}
@ 
An effective address is either a register or a memory location.
<<rules>>=
eaddrl : regl {: regl :}
eaddrl : meml {: meml :}
@
To get a value for any of these, we fetch.
We can also use a link-time constant as an effective address.
<<rules>>=
reg     : Fetch(regl    , w) {: regl     :}
regabcd : Fetch(regabcdl, w) {: regabcdl :}
reg8    : Lobits(Fetch(regl8, w), nw:w) [{: guard (nw=8) :}] {: regl8     :}
reg8H   : BitExtract(eight, regabcd, w) [{: guard (w=8) :}] {: hregname regabcd :}
reg8H   : Fetch(regl8H, w) {: regl8H :}
reg_cl  : Lobits(Fetch(regl_ecx, w), nw:w) [{: guard (nw=8) :}] {: () :}
regpair : Fetch(regpairl, w) {: regpairl :}
mem     : Fetch(meml    , w) {: meml     :}
eaddr   : Fetch(eaddrl  , w) {: eaddrl   :}
-- eaddr : lconst {: lconst :} -- absolute addressing mode
-- indexed modes to come
@ 
I'm not at all sure about the rules for immediate constants, but here
goes a guess.  One problem is that I think the assembly-language
syntax for an immediate address depends on the context in which it
appears. 
<<rules>>=
-- immed : lconst {: lconst :}
immed  : const   {: "$" ^ const :}
immed8 : const8  {: "$" ^ const8 :}
-- immed : Add(lconst, const) {:  lconst ^ "+" ^ const :}
-- immed : Add(const, lconst) {:  lconst ^ "+" ^ const :}
@ 
\paragraph{Data movement}
Move, load, and store instructions.
Because the machine can do eaddr/reg
and reg/eaddr but not eaddr/eaddr, there are two varieties of each.
<<rules>>=
-- pic code
inst : Store(dst:eaddrl, pic, w)
  {: cat ["mov"; suffix w; " "; pic; ","; dst] :}

inst : Store(dst:eaddrl, src:immed, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

inst : Store(dst:eaddrl, src:lconst, w) 
  {: cat ["lea"; suffix w; " "; src; ","; dst] :}

-- straight load/store/move
inst : Store(dst:eaddrl, src:reg, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

inst : Store(dst:regl, src:eaddr, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

-- sign extension
inst : Store(dst:eaddrl, Sx(Fetch(src:regl, nw:w)), w)
  {: cat ["movs"; suffix nw; suffix w; " "; src; ","; dst] :}

inst : Store(dst:regl, Sx(Fetch(src:eaddrl, nw:w)), w)
  {: cat ["movs"; suffix nw; suffix w; " "; src; ","; dst] :}

-- zero extension
inst : Store(dst:eaddrl, Zx(Fetch(src:regl, nw:w)), w)
  {: cat ["movz"; suffix nw; suffix w; " "; src; ","; dst] :}

inst : Store(dst:regl, Zx(Fetch(src:eaddrl, nw:w)), w)
  {: cat ["movz"; suffix nw; suffix w; " "; src; ","; dst] :}

-- moving low bits (relies on proper name of source)
inst : Store(dst:eaddrl, Lobits(Fetch(Reg('r', n, rw:w), fw:w), lw:w), nw:w)
  {: cat ["mov"; suffix nw; " "; regname nw n; ","; dst] :}

inst : Store(dst:regl, Lobits(src:mem, sw:w), nw:w)
  {: cat ["mov"; suffix nw; " "; src; ","; dst] :}

-- block copy
inst : Par(Llr(ecx1:ecx, "sub", n0:const, w1:w),
       Par(Llr(esi1:esi, "sub", n1:const, w2:w),
       Par(Llr(edi1:edi, "sub", n2:const, w3:w),
       Par(Store(Mem(Fetch(esi2:esi, w4:w), w11:w),
                 Fetch(Mem(Fetch(edi2:edi, w5:w), w6:w),w7:w),w8:w),
           Guarded(Fetch(ecx2:ecx,w9:w),Goto(Fetch(eip, w10:w)))
          ))))
  {: "rep movsb" :}

@ 
\paragraph{Simple arithmetic}
These are the well-behaved instructions, which don't require hairy
special registers.
<<rules>>=
inst : Store(dst:regl, disp, w) [{:guard (w = 32):}]
  {: cat ["leal "; disp; ", "; dst] :}

inst : Llr(dst:regl, "add", const, w) [{:guard (w=32):}]
  {: cat ["leal "; const; "("; dst; ")"; ", "; dst] :}

inst : Withaflags(dst:eaddrl, "add", src:reg, w, "x86_addflags")
  {: cat ["add"; suffix w; " "; src; ","; dst] :}

inst : Withaflags(dst:regl, "add", src:eaddr, w, "x86_addflags")
  {: cat ["add"; suffix w; " "; src; ","; dst] :}

inst : Withaflags(dst:eaddrl, "sub", src:reg, w, "x86_subflags")
  {: cat ["sub"; suffix w; " "; src; ","; dst] :}

inst : Withaflags(dst:regl, "sub", src:eaddr, w, "x86_subflags")
  {: cat ["sub"; suffix w; " "; src; ","; dst] :}

inst : Withaflagsunary("neg", dst:eaddrl, w, "x86_negflags")
  {: cat ["neg"; suffix w; " "; dst] :}

inst : Withaflags(dst:eaddrl, "mul", src:reg, w, "x86_mulflags")
  {: cat ["imul "; suffix w; " "; src; ", "; dst] :}

inst : Withaflags(dst:regl, "mul", src:eaddr, w, "x86_mulflags")
  {: cat ["imul"; suffix w; " "; src; ","; dst] :}

inst : Withundefflags(dst:regpairl, "quot", src:reg, w)
  {: cat ["idiv"; suffix w; " "; src; ", "; dst] :}

inst : Withundefflags(dst:regpairl, "divu", src:reg, w)
  {: cat ["div"; suffix w; " "; src; ", "; dst] :}

inst : Withaflags(dst:regl, "shl", reg_cl, w, "x86_shlflags")
  {: sprintf "shl%s %%cl, %s" (suffix w) dst :}

inst : Withaflags(dst:regl, "shra", reg_cl, w, "x86_shraflags")
  {: sprintf "sar%s %%cl, %s" (suffix w) dst :}

inst : Withaflags(dst:regl, "shrl", reg_cl, w, "x86_shrlflags")
  {: sprintf "shr%s %%cl, %s" (suffix w) dst :}

inst : Llr(dst:regl, "shl", immed, w)
  {: sprintf "shl%s %s, %s" (suffix w) immed dst :}

inst : Llr(dst:regl, "shra", immed, w)
  {: sprintf "sar%s %s, %s" (suffix w) immed dst :}

inst : Llr(dst:regl, "shrl", immed, w)
  {: sprintf "shr%s %s, %s" (suffix w) immed dst :}

@ 
N.B. The crazy AT\&T assembly language does comparisons backward.
<<rules>>=
inst : Setflags(X86_subflags(l:eaddr, r:reg))
  {: cat ["cmp"; suffix 32; " "; r; ","; l] :} -- POSSIBLE BUG IN WIDTH
inst : Setflags(X86_subflags(l:reg, r:eaddr))
  {: cat ["cmp"; suffix 32; " "; r; ","; l] :} -- POSSIBLE BUG IN WIDTH

inst : UnaryInPlace(dst:regl, "com", w) {: cat ["not"; suffix w; " "; dst] :} 

inst : Withlflags(dst:eaddrl, logical:string, src:reg, w, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: cat [logical; suffix w; " "; src; ","; dst] :}

inst : Withlflags(dst:regl, logical:string, src:eaddr, w, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: cat [logical; suffix w; " "; src; ","; dst] :}

inst : Withlflags(dst:regl8H, logical:string, src:immed8, w, "x86_logicflags")
  [{: (guard (w=8)) + match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: sprintf "%s%s %s,%s" logical (suffix 8)  src dst :}

inst : Withlflags8H(dst:regabcdl, logical:string, src:reg8H, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: sprintf "%s%s %s,%s" logical (suffix 8)  src (hregname dst) :}

inst : Withlflags8H(dst:regabcdl, logical:string, src:immed8, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: sprintf "%s%s %s,%s" logical (suffix 8) src (hregname dst) :}
@ 
\paragraph{Control flow}
The simple jumps are easy.
<<rules>>=
target : Fetch(eaddrl, w) {: "*" ^ eaddrl :}
target : lconst {: lconst :} 
inst : Goto(target)            {: "jmp " ^ target :}
inst : Jcc(cc:string, lconst) {: "j" ^ cc ^ " " ^ lconst :}
@ 
Call, [[cut to]],  and return require manipulating the stack pointer
[[esp]] and 
program counter [[eip]].
<<rules>>=
esp : Reg('r', n, w) [{: guard (n = 4 && w = 32):}]                {: () :}
eip : Reg('c', n, w) [{: guard (n = SS.indices.SS.pc && w = 32):}] {: () :}
@ 
The [[cut to]] is supposed to look atomic, but it is a sequence of two
instructions. 
<<rules>>=
inst : Par(Goto(target),Store(esp,frame:eaddr,w))
  {: cat ["movl "; frame; ", %esp; jmp "; target] :}
@ 
There are two ways to recognize a pop, depending on whether the ML
code sees it as an $L \mathrel{:=} L \oplus R$ instruction.
<<rules>>=
pop  : Store(esp, Add(Fetch(esp, w), four), sw:w) {: () :}
pop  :  Llr(esp, "add", four, w) {: () :}
push : Llr(esp, "sub", four, w) {: () :}
push : Llr(esp, "add", minusfour, w) {: () :}
stacktop  : Mem(Fetch(esp, w), mw:w)            [{:guard (mw = 32):}] {: () :}
stacknext : Mem(Sub(Fetch(esp, w), four), mw:w) [{:guard (mw = 32):}] {: () :}
inst : Par(Goto(Fetch(stacktop, w)),pop) 
        {: "ret" :}
inst : Par(Goto(eaddr),Par(Store(stacknext, Fetch(eip, x:w), y:w), push))
        {: "call *" ^ eaddr :}
inst : Par(Goto(lconst),Par(Store(stacknext, Fetch(eip, x:w), y:w), push))
        {: "call " ^ lconst :}
@ 
\paragraph{Floating point}
<<rules>>=
one3  : Bits(b:bits)
    [{: guard (Bits.width b = 3 && Bits.Ops.eq (Bits.U.of_int 1 3) b) :}]
    {: () :}
two3  : Bits(b:bits)
    [{: guard (Bits.width b = 3 && Bits.Ops.eq (Bits.U.of_int 2 3) b) :}]
    {: () :}
zero  : Bits(b:bits) [{: guard (Bits.Ops.eq (Bits.U.of_int 0 (Bits.width b)) b) :}]
             {: () :}
eight : Bits(b:bits) [{: guard (Bits.width b > 3 &&
                                Bits.Ops.eq (Bits.U.of_int 8 (Bits.width b)) b) :}]
             {: () :}
fpsp   : Reg('F', n, w) [{: guard (n = 0 && w = 3):}] {: () :}
fppop  : Llr(fpsp, "add", one3, w) {: () :}
fppop2 : Llr(fpsp, "add", two3, w) {: () :}
fppush : Llr(fpsp, "sub", one3, w) {: () :}
<<rules>>=
fpstacktopl  : Fpreg(Fetch(fpsp, w))            {: () :}
fpstacktopl  : Fpreg(Add(Fetch(fpsp, w), zero)) {: () :}
fpstack1l    : Fpreg(Add(Fetch(fpsp, w), one3)) {: () :}
fpstacknextl : Fpreg(Sub(Fetch(fpsp, w), one3)) {: () :}

fpstacktop  : Fetch(fpstacktopl,  w) [{: guard (w=80) :}] {: fpstacktopl :}
fpstack1    : Fetch(fpstack1l,    w) [{: guard (w=80) :}] {: fpstack1l :}
fpstacknext : Fetch(fpstacknextl, w) [{: guard (w=80) :}] {: fpstacknextl :}
<<rules>>=
inst : Par(Store(fpstacknextl, F2f(s:w, d:w, mem), w2:w), fppush)
  {: sprintf "fld%s %s" (fsuffix s) mem :}
inst : Par(Store(dst:meml, F2f(s:w, d:w, fpstacktop), w2:w), fppop)
  {: sprintf "fstp%s %s" (fsuffix d) dst :}
<<rules>>=
inst : Par(Store(fpstacknextl, I2f(s:w, d:w, mem), w2:w), fppush)
  {: sprintf "fild%s %s" (fisuffix s) mem :}
inst : Par(Store(dst:meml, F2i(s:w, d:w, fpstacktop), w2:w), fppop)
  {: sprintf "fistp%s %s" (fisuffix d) dst :}
<<rules>>=
inst : Par(Store(fpstack1l, Fadd(fpstacktop, fpstack1), w), fppop)
  {: "faddp" :}
inst : Par(Store(fpstack1l, Fsub(fpstacktop, fpstack1), w), fppop)
  {: "fsubp" :}
inst : Par(Store(fpstack1l, Fdiv(fpstacktop, fpstack1), w), fppop)
  {: "fdivp" :}
inst : Par(Store(fpstack1l, Fmul(fpstacktop, fpstack1), w), fppop)
  {: "fmulp" :}
<<rules>>=
inst : UnaryInPlace(fpstacktopl, "fabs", w) {: "fabs" :}
inst : UnaryInPlace(fpstacktopl, "fneg", w) {: "fchs" :}
inst : Store(fpstacktopl, Frnd(fpstacktop), w) {: "frndint" :}
@ 
It will be good to remove the ugly wart on ocamlburg that makes it
impossible to nest constructors and get to the free variables.
<<rules>>=
i2f_mem : I2f(s:w, d:w, mem) [{: guard (s = 32 || s = 16) :}] {: s, mem :}
fiadd : Fadd(fpstacktop, i2f_mem) {: i2f_mem :}
inst : Store(fpstacktopl, fiadd, w)
   {: let s, mem = fiadd in sprintf "fiadd%s %s" (suffix s) mem :}
<<rules>>=
fpccl : Fpccl() {: () :}
fpustatusl : Fpustatusl() {: () :}
fpustatus : Fetch(fpustatusl, w) {: () :}
inst : Store(fpccl, Fcmp(fpstacktop, fpstack1), w)
  {: "fcom" :}
inst : Par(Store(fpccl, Fcmp(fpstacktop, fpstack1), w), fppop)
  {: "fcomp" :}
inst : Par(Store(fpccl, Fcmp(fpstacktop, fpstack1), w), fppop2)
  {: "fcompp" :}
@ 
<<rules>>=
eax : Reg('r', n, w) [{: guard (n = 0 && w = 32):}]  {: () :}
ecx : Reg('r', n, w) [{: guard (n = 1 && w = 32):}]  {: () :}
esi : Reg('r', n, w) [{: guard (n = 6 && w = 32):}]  {: () :}
edi : Reg('r', n, w) [{: guard (n = 7 && w = 32):}]  {: () :}
ax  : Slice(w, lsb:n, eax) [{: guard (w = 16 && lsb = 0):}]  {: "%ax" :}
ah  : Slice(w, lsb:n, eax) [{: guard (w = 8  && lsb = 8):}]  {: "%ah" :}
ahval : BitExtract(eight, Fetch(eax, fw:w), w) [{: guard (w = 8) :}] {: "%ah" :}
ahval : Fetch(ah, w) [{: guard (w=8) :}] {: ah :}

inst : Store(eax, BitInsert(zero, Fetch(eax, w), fpustatus), sw:w) {: "fstsw %ax" :}
inst : Store(ax,  fpustatus, w) [{: guard (w = 16) :}] {: cat ["fstsw "; ax] :}
inst : Setflags(Ah2flags(ahval)) {: "sahf" :}
@ 
\paragraph{Other instructions}
<<rules>>=
inst : Nop() {: "nop" :}
@ 
\paragraph{Support for debugging}
If an RTL should fail to match, one can uncomment the following rule
and get a printout of exactly how that RTL is represented using {\burg}
constructors. 
<<rules>>=
inst: any [100] {: "<" ^ any ^ ">" :}

any : True  () {: "True"  :}
any : False () {: "False" :}
any : Link(symbol, w) {: "Link(" ^ symbol#mangled_text ^ "," ^ string_of_int w ^ ")" :}
any : Late(string, w) {: "Late(" ^ string ^ "," ^ string_of_int w ^")" :}
any : Diff(c1:any,c2:any) {: "Diff(" ^ c1 ^ "," ^ c2 ^ ")" :}
any : Bits(bits)     {: sprintf "Bits(%s)" (Bits.to_string bits) :}

any : Fetch (any, w) {: "Fetch(" ^ any ^ "," ^ string_of_int w ^ ")" :}

any : And(x:any, y:any) {: "And(" ^ x ^ ", " ^ y ^ ")" :}
any : Or(x:any, y:any)  {: "Or("  ^ x ^ ", " ^ y ^ ")" :}
any : Xor(x:any, y:any) {: "Xor(" ^ x ^ ", " ^ y ^ ")" :}
any : Com(x:any) {: "Com(" ^ x ^ ")" :}


any : Add(x:any, y:any) {: "Add(" ^ x ^ ", " ^ y ^ ")" :}
any : Mul(x:any, y:any) {: "Mul(" ^ x ^ ", " ^ y ^ ")" :}
any : Fadd(x:any, y:any) {: sprintf "Fadd(%s, %s)" x y :}
any : Fsub(x:any, y:any) {: sprintf "Fsub(%s, %s)" x y :}
any : Fmul(x:any, y:any) {: sprintf "Fmul(%s, %s)" x y :}
any : Fdiv(x:any, y:any) {: sprintf "Fdiv(%s, %s)" x y :}

any : Fneg(any) {: sprintf "Fneg(%s)" any :}
any : Fabs(any) {: sprintf "Fabs(%s)" any :}

any : Fpccl() {: "Fpcc()" :}
any : Fpustatusl() {: "Fpustatus()" :}
any : BitInsert(x:any, y:any, z:any) {: sprintf "BitInsert(%s, %s, %s)" x y z :}
any : BitExtract(lsb:any, y:any, n:w) {: sprintf "BitExtract(%s, %s, %d)" lsb y n :}
any : Slice(n:w, lsb:n, y:any) {: sprintf "Slice(%d, %d, %s)" n lsb y :}
any : Ah2flags(any) {: sprintf "Ah2flags(%s)" any :}

any : Sx(any) {: "Sx(" ^ any ^ ")" :}
any : Zx(any) {: "Zx(" ^ any ^ ")" :}
any : F2f(n:w, w, any) {: sprintf "F2f(%d, %d, %s)" n w any :}
any : F2i(n:w, w, any) {: sprintf "F2i(%d, %d, %s)" n w any :}
any : I2f(n:w, w, any) {: sprintf "I2f(%d, %d, %s)" n w any :}
any : Lobits(any, w) {: "Lobits(" ^ any ^ ", " ^ string_of_int w ^ ")" :}
any : X86_subflags(l:any, r:any) {: "X86_subflags(" ^ l ^ ", " ^ r ^ ")" :}

any : Mem(any, w) {: "Mem(" ^any ^ "," ^ string_of_int w ^ ")" :}
any : Reg  (char, n, w) {: sprintf "Reg(%s, %d, %d)"   (Char.escaped char) n w :}
any : Fpreg(any) {: sprintf "Fpreg(%s)" any :}

any : Store (dst:any, src:any, w)
 {: "Store(" ^ dst ^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}
any : Kill(any) {: "Kill(" ^ any ^ ")" :}

any : Repmovs(esi:any, edi:any, ecx:any)
 {: "Repmovs(" ^ esi ^ "," ^ edi ^ "," ^ ecx ^ ")" :}

any : Guarded(guard:any, any) {: "Guarded(" ^ guard ^ "," ^ any ^ ")" :}
any : Par(l:any, r:any) {: "Par(" ^ l ^ "," ^ r ^ ")" :}
any : Goto(any) {: "Goto(" ^ any ^ ")" :}
any : Setflags(any) {: "Setflags(" ^ any ^ ")" :}
any : Llr(dst:any, string, src:any, w) 
  {: "Llr(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}
any : UnaryInPlace(dst:any, string, w) 
  {: "UnaryInPlace(" ^ dst ^","^string^ "," ^ string_of_int w ^ ")" :}

any : Withaflags(dst:any, string, src:any, w, fo:string) 
  {: "Withaflags(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ 
      ","^ fo ^ ")" :}

any : Withlflags(dst:any, string, src:any, w, fo:string) 
  {: "Withlflags(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ 
      ","^ fo ^ ")" :}

any : Withlflags8H(dst:any, string, src:any, fo:string) 
  {: "Withlflags8H(" ^ dst ^","^string^ "," ^ src ^ "," ^ fo ^ ")" :}

any : Jcc(string, any) {: "Jcc(" ^ string ^ "," ^ any ^ ")" :}
@


% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

The code in this section walks an RTL and calls suitable \burg\
constructors. 
The most interesting code is probably the code that maps the
general representation of application into one that uses a unique
constructor for each operator.
<<special cases for particular operators>>=
| RP.App(("and", [w]), [x; y]) -> conAnd (exp x) (exp y)
| RP.App(("or",  [w]), [x; y]) -> conOr (exp x) (exp y)
| RP.App(("xor", [w]), [x; y]) -> conXor (exp x) (exp y)
| RP.App(("com", [w]), [x])    -> conCom (exp x)
| RP.App(("add", [w]), [x; y]) -> conAdd (exp x) (exp y)
| RP.App(("sub", [w]), [x; y]) -> conSub (exp x) (exp y)
(*| RP.App(("neg", [w]), [x])    -> conNeg (exp x)*)
| RP.App(("mul", [w]), [x; y]) -> conMul (exp x) (exp y)
| RP.App(("sx",  [n;w]), [x])   -> conSx  (exp x)
| RP.App(("zx",  [n;w]), [x])   -> conZx  (exp x)
| RP.App(("f2f", [n;w]), [x; rm])   -> conF2f n w (exp x) (* need to assert rm *)
| RP.App(("f2i", [n;w]), [x; rm])   -> conF2i n w (exp x) (* need to assert rm *)
| RP.App(("i2f", [n;w]), [x; rm])   -> conI2f n w (exp x) (* need to assert rm *)
| RP.App(("fadd", [w]), [x; y; rm]) -> conFadd (exp x) (exp y) (* need to assert rm *)
| RP.App(("fsub", [w]), [x; y; rm]) -> conFsub (exp x) (exp y) (* need to assert rm *)
| RP.App(("fmul", [w]), [x; y; rm]) -> conFmul (exp x) (exp y) (* need to assert rm *)
| RP.App(("fdiv", [w]), [x; y; rm]) -> conFdiv (exp x) (exp y) (* need to assert rm *)
| RP.App(("fneg", [w]), [x]) -> conFneg (exp x)
| RP.App(("fabs", [w]), [x]) -> conFabs (exp x)
| RP.App(("x86_fcmp", [w]), [x; y]) -> conFcmp (exp x) (exp y)
| RP.App(("lobits", [w;n]), [x])   -> conLobits (exp x) n
| RP.App(("x86_subflags", [w]), [x; y]) -> conX86_subflags (exp x) (exp y)
| RP.App(("x86_ah2flags", []), [x]) -> conAh2flags (exp x)
| RP.App(("x86_repmovs",   [w]), [x;y;z]) -> conRepmovs (exp x) (exp y) (exp z)
| RP.App(("bitInsert", [w; n]), [lsb; dst; src]) ->
    conBitInsert (exp lsb) (exp dst) (exp src)
| RP.App(("bitExtract", [w; n]), [lsb; src]) -> conBitExtract (exp lsb) (exp src) n
| RP.App((("add"|"sub"|"mul"|"sx"|"zx"|"lobits"|"x86_subflags"|"bitInsert"|
           "bitExtract"|"fabs"|"fneg"|"fdiv"|"fmul"|"fsub"|"fadd"|"f2f"|"f2i"|
           "i2f"|"and"|"or"|"xor"|"com") as op, ws), xs)->
    Impossible.impossible
      (Printf.sprintf
         "operator %%%s specialized to %d widths & applied to %d arguments"
         op (List.length ws) (List.length xs))
@ 
Here is the rest of the mapping.  
<<code to follow the labeler>>=  
let rec const = function
  | RP.Bool(true)             -> conTrue  ()
  | RP.Bool(false)            -> conFalse ()
  | RP.Link(s,_,w)            -> conLink s w
  | RP.Diff(c1,c2)            -> conDiff (const c1) (const c2)
  | RP.Late(s,w)              -> conLate s w
  | RP.Bits(b)                -> conBits(b)
<<code to follow the labeler>>=  
let rec exp = function
  | RP.Const(k)               -> const (k)
  | RP.Fetch(l,w)             -> conFetch (loc l) w
  <<special cases for particular operators>>
  | RP.App((o,_),_)           -> error ("unknown operator " ^ o)
<<code to follow the labeler>>=  
and loc l = match l with
  | RP.Mem('m', aff, w, e, ass) -> conMem (exp e) w
  | RP.Mem('f', aff, w, e, ass) -> conFpreg (exp e)
  | (RP.Reg(_, _, _) | RP.Slice(_, _, _)) when l = fpcc -> conFpccl ()
  | RP.Reg(sp, i, w) when l = fpustatus -> conFpustatusl()
  | RP.Reg(sp, i, w)          -> conReg sp i w 
  | RP.Mem(_, _, _, _, _)     -> error "non-mem, non-reg cell"
  | RP.Var _ | RP.Global _    -> error "var found"
  | RP.Slice(w,i,l)           -> (*error "cannot handle slice"*)
      conSlice w i (loc l)
@ 
Things start to get a bit baroque here, as we recognize different
special forms a single effect can take.
<<code to follow the labeler>>=  
and effect = function
  | RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r]), w) 
    when l = l'                       -> conLlr (loc l) o (exp r) w
  | RP.Store(l, RP.App((o, [w']), [RP.Fetch(l',_)]), w)
    when l = l' && w = w'             -> conUnaryInPlace (loc l) o w
  | RP.Store(RP.Reg('c',i, w),r,_) 
    when (i = SS.indices.SS.pc)       -> conGoto (exp r)
  | RP.Store(RP.Reg('c', i, w),r,_)
    when (i = SS.indices.SS.cc)       -> conSetflags (exp r)
  | RP.Store(RP.Reg('c', i, _), r, w) -> error ("set $c["^string_of_int i^"]")
  | RP.Store(l,e,w)                   -> conStore (loc l) (exp e) w
  | RP.Kill(l)                        -> conKill (loc l)
@
We attempt to recognize register pairs.
<<code to follow the labeler>>=  
and regpair = function
  | RP.App(("or",_),[ RP.App(("shl",_), [RP.App(("zx",_), [RP.Fetch(r1,_)]);_])
                    ; RP.App(("zx",_),                    [RP.Fetch(r2,_)])])
      -> conRegPair (loc r1) (loc r2)
  | x -> Impossible.impossible "Argument is not a register pair"
@
The truly ghastly stuff is the stuff that recognizes multiple
effects that set flags.
<<code to follow the labeler>>=  
and rtl (RP.Rtl es) = geffects es
and geffects = function
    | [] -> conNop ()
    | [g, s] -> guarded g s
    <<horrible pattern match for [[Withflags]]>>
    | (g, s) :: t -> conPar (guarded g s) (geffects t)
and is8 b =
  Bits.width b > 3 & Bits.Ops.eq b (Bits.U.of_int 8  (Bits.width b))
and is64 b =
  Bits.width b > 6 & Bits.Ops.eq b (Bits.U.of_int 64 (Bits.width b))
@ 
Dealing with a guard is straightforward.
Either it's trivial, it's a conditional branch, or we pass it off to
the recognizer (which currently falls on the floor).
<<code to follow the labeler>>=  
and guarded g eff = match g with
| RP.Const(RP.Bool b) -> if b then effect eff else conNop()
| RP.App((compare, [32]), [RP.Fetch(RP.Reg('c', n, _), _)])
    when n = SS.indices.SS.cc && begins_x86_ compare ->
      (match eff with
      | RP.Store(RP.Reg('c', i, _), r, w)
        when (i = SS.indices.SS.pc) ->
          conJcc (String.sub compare 4 (String.length compare - 4)) (exp r)
      | _ -> error "guard on x86 non-branch")
| _ -> conGuarded (exp g) (effect eff)
and begins_x86_ s =
  String.length s >= 4 && s.[0] = 'x' && s.[1] = '8' && s.[2] = '6' && s.[3] = '_'
@
Oh, the joy of the flags\ldots
<<truepat>>=
RP.Const(RP.Bool true)
<<unused, horrible pattern match for [[Withflags]]>>=
| [ (<<truepat>>, <<pattern for [[hi]] := hi32([[l]] [[o]] [[r]] at 32)>>)
  ; (<<truepat>>, <<pattern for [[lo]] := lo32([[l']] [[o']] [[r']] at 32)>>)
  ; (<<truepat>>, <<pattern for flags := [[fo]] ([[l'']], [[r'']])>>)
  ] when l = l' && o = o' && r = r' && l = RP.Fetch(l'', 32) && r = r'' && is64 k64 
      && flag_index = SS.indices.SS.cc ->
        conPairdestwithflags (loc hi) (loc lo) (exp l) o (exp r) fo
<<horrible pattern match for [[Withflags]]>>=
| [ (<<truepat>>, <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>)
  ; (<<truepat>>, <<pattern for flags := [[%x86_undefflags()]]>>)
  ] when l = l' && flag_index = SS.indices.SS.cc ->
      conWithundefflags (loc l) o (exp r) w
<<horrible pattern match for [[Withflags]]>>=
| [ (<<truepat>>, <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>)
  ; (<<truepat>>, <<pattern for flags := [[fo]] ([[l'']], [[r']])>>)
  ] when l = l' && l = l'' && r = r' && flag_index = SS.indices.SS.cc ->
      conWithaflags (loc l) o (exp r) w fo
| [ (<<truepat>>, <<pattern for [[l]] := [[o]] [[l']] at [[w]]>>)
  ; (<<truepat>>, <<pattern for flags := [[fo]] [[l'']])>>)
  ] when l = l' && l = l'' && flag_index = SS.indices.SS.cc ->
      conWithaflagsunary o (loc l) w fo
| [ (<<truepat>>, <<pattern for [[d]] := rp:[[l1/l2]] [[o]] [[r]] at [[w]]>>)
  ; (<<truepat>>, <<pattern for flags := [[fo]] ([[l1'/l2']], [[r']])>>)
  ] when l1 = l1' && l2 = l2' && r = r' && flag_index = SS.indices.SS.cc ->
      conWithaflags (regpair rp) o (exp r) w fo
| [ (<<truepat>>, <<pattern for [[d]] := rp:[[l1/l2]] [[o]] [[r]] at [[w]]>>)
  ; (<<truepat>>, <<pattern for flags := [[%x86_undefflags()]]>>)
  ] when flag_index = SS.indices.SS.cc ->
      conWithundefflags (regpair rp) o (exp r) w
| [ (<<truepat>>, <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>)
  ; (<<truepat>>, <<pattern for flags := [[fo]] ([[l'']] [[o']] [[r']])>>)
  ] when l = l' && l = l'' && r = r' && o = o'
    && flag_index = SS.indices.SS.cc ->
      conWithlflags (loc l) o (exp r) w fo
| [ (<<truepat>>, <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]] at H register>>)
  ; (<<truepat>>, <<pattern for flags := [[fo]] [[flag_left']]>>)
  ] when is8 eightbits && is8 eightbits' && l = l' && l = l''
      && flag_left = flag_left' && flag_index = SS.indices.SS.cc ->
      conWithlflags8H (loc l) o (exp r) fo

| [ (<<truepat>>, <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]] at H register>>)
  ; _
  ] when is8 eightbits && is8 eightbits' && l = l' && l = l'' ->
      conWithlflags8H (loc l) o (exp r) "x86_mumbojumbo"
(*
  $r[0] := %%bitInsert(8, $r[0], %%and(%%bitExtract(8, $r[0]), 69)) 
| $c[2] := %%x86_logicflags(%%and(%%bitExtract(8, $r[0]), 69))
*)

<<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]] at H register>>=
RP.Store(l, RP.App(("bitInsert", [32; 8]),
                   [RP.Const (RP.Bits eightbits);
                    RP.Fetch(l', _);
                    RP.App((o, _),
                        [ RP.App(("bitExtract", [32; 8]),
                                   [RP.Const (RP.Bits eightbits'); RP.Fetch(l'',_)]);
                            r]) as flag_left]),
         w)
<<pattern for flags := [[%x86_undefflags()]]>>=
RP.Store(RP.Reg('c', flag_index, _), RP.App(("x86_undefflags", _), []), _)
<<pattern for flags := [[fo]] [[flag_left']]>>=
RP.Store(RP.Reg('c', flag_index, _), RP.App((fo, _), [flag_left']), _)
<<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>=
RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r]), w) 
<<pattern for flags := [[fo]] ([[l'']], [[r']])>>=
RP.Store(RP.Reg('c', flag_index, _),
         RP.App((fo, _), [RP.Fetch(l'',_); r']), _)
<<pattern for flags := [[fo]] ([[l'']], [[r'']])>>=
RP.Store(RP.Reg('c', flag_index, _),
         RP.App((fo, _), [RP.Fetch(l'',_); r'']), _)
<<pattern for [[l]] := [[o]] [[l']] at [[w]]>>=
RP.Store(l, RP.App((o, _), [RP.Fetch(l',_)]), w) 
<<pattern for [[hi]] := hi32([[l]] [[o]] [[r]] at 32)>>=
RP.Store(hi, RP.App (("lobits", [64;32]),
                     [RP.App (("shrl", [64]), 
                              [RP.App((o, _), [l; r]);
                               RP.Const (RP.Bits k32)])]), 32)
<<pattern for [[lo]] := lo32([[l']] [[o']] [[r']] at 32)>>=
RP.Store(lo, RP.App (("lobits", [64;32]), [RP.App((o', _), [l'; r'])]), 32)
<<pattern for flags := [[fo]] [[l'']])>>=
RP.Store(RP.Reg('c', flag_index, _),
         RP.App((fo, _), [RP.Fetch(l'',_)]), _)
<<pattern for [[d]] := rp:[[l1/l2]] [[o]] [[r]] at [[w]]>>=
RP.Store(d, RP.App((o, _),
  [ (RP.App(("or",_), [ RP.App(("shl",_),
                               [RP.App(("zx",_), [RP.Fetch(l1,_)]);_]);
                                RP.App(("zx",_), [RP.Fetch(l2,_)])]) as rp);
    r]), w)
<<pattern for flags := [[fo]] ([[l1'/l2']], [[r']])>>=
RP.Store(RP.Reg('c', flag_index, _),
         RP.App((fo, _), 
              [ RP.App(("or",_), [ RP.App(("shl",_),
                                     [RP.App(("zx",_), [RP.Fetch(l1',_)]);_])
                     ;                RP.App(("zx",_), [RP.Fetch(l2',_)])])
              ; r']), _)
<<pattern for flags := [[fo]] ([[l'']] [[o']] [[r']])>>=
RP.Store(RP.Reg('c', flag_index, _),
         RP.App((fo, _), [RP.App ((o', _), [RP.Fetch(l'',_); r'])]), _)
@
\subsection{The exported recognizers}

The only tricky bits here are what we do when something goes wrong.
In a production compiler, we should always halt the compiler.
But here, it is more informative to drop an error message into the
assembly language and to allow the assembler to barf downstream.
<<code to follow the labeler>>=
let errmsg r msg =
  List.iter prerr_string
    [ "recognizer error: "; msg; " on "; RU.ToReadableString.rtl r; "\n" ]

let to_asm r =
  try
    let plan = rtl (Down.rtl r) in
    plan.inst.Camlburg.action ()
  with 
  | Camlburg.Uncovered -> cat [" not an instruction: " ; RU.ToReadableString.rtl r]
  | Error msg -> (errmsg r msg; " error in recognizer: " ^ msg)

let is_instruction r =
  try
    let plan = rtl (Down.rtl r) in
    plan.inst.Camlburg.cost < 100  (* should be true, but shade this... *)
  with 
  | Camlburg.Uncovered -> false
  | Error msg -> (errmsg r msg; false)
@                        
