% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------ 
\section{Intel $x$86 Recognizer}
% ------------------------------------------------------------------ 

This module provides a [[to_asm]] function that recognizes an Intel
$x$86 RTL.
As an experiment, the recognizer is implemented using BURG rules.
If the instruction is recognized, it is coverable with cost~0.
If it is not recognized, there is a catchall rule that recognizes
anything with cost~1 (I~hope).

<<x86rec.mli>>=
module M (* (I: X86i.S with type t = Sledlib.String.t)*) : sig
  val to_string : Rtl.rtl -> string
end
<<x86rec.mlb>>=
%head {: <<modules>> :}
%head {: 
    module M (*
        (I:     X86i.S with type t      = Sledlib.String.t) *)
         =
    struct    
:}

%head {: <<head>> :}
%tail {: <<tail>> :}
%tail {: end (* of Make *) :}

%term <<terminal types>>
%%
<<rules>>
@


<<modules>>=
module B  = Bits 
module C  = Camlburg
module Down  = Rtl.Convert      (* Convert Down  to private repr. *)
module G  = Cfg4             (* for expanding all RTLs in a CFG *)
module GU = Cfgutil
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module N  = Nativeint
module S  = Space
module T  = Target2
module Up  = Rtl.Revert       (* Convert Up    to abstract repr. *)
module W  = Rtlutil.Width 
@
<<head>>=
exception Error of string
let error msg     = raise (Error msg)
let error_rtl rtl = error (RU.ToReadableString.rtl rtl) 
@



% ------------------------------------------------------------------ 
\subsection{Utilities}
% ------------------------------------------------------------------ 

<<head>>=
let weirdb = B.S.of_int (-4) 32
let weird = Nativeint.to_string (B.S.to_native weirdb)
 (* let _ = List.iter prerr_string ["Weird integer is "; weird; "\n"] *)
let native b = 
  assert (B.width b = 32);
  Nativeint.to_string (B.U.to_native b)
let cat = String.concat ""
@   
The [[guard]] function turns a predicate into a cost.
<<head>>=
let infinity = C.inf_cost
let guard b = if b then 0 else C.inf_cost
@ 
<<head>>=
let suffix w = match w with
| 8  -> "b"
| 16 -> "w"
| 32 -> "l"
| _ -> Impossible.impossible "width in x86 not 8/16/32"
@
% ------------------------------------------------------------------ 
\subsection{Register names}
% ------------------------------------------------------------------ 
<<head>>=
let r8_names  = [| "%al"; "%cl"; "%dl"; "%bl"; "%ah"; "%ch"; "%dh"; "%bh" |]
let r16_names = [| "%ax"; "%cx"; "%dx"; "%bx"; "%sp"; "%bp"; "%si"; "%di" |]
let r32_names = [| "%eax"; "%ecx"; "%edx"; "%ebx"; "%esp"; "%ebp"; "%esi"; "%edi" |]
let reg_names w = match w with
| 8  -> r8_names
| 16 -> r16_names
| 32 -> r32_names
| _  -> Impossible.impossible "x86 register width not 8/16/32"
let regname w = Array.get (reg_names w)
@     



% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
% ------------------------------------------------------------------ 

In a {\burg} pattern variables hold either polymorphic nonterminal
values, or monomorphic terminal ({\ocaml}) values. Terminal types must
be declared:
<<terminal types>>=
n w space
k width opr exps agg ass index bool bits link late x symbol
@

The following table summarizes the nonterminals from the rule set. \\
\begin{tabularx}{\linewidth}{@{\hskip1.5em}llX@{}}
    Nonterminal & Type & Meaning \\ 
    \hline
    [[const]]       & [[nativeint]]
                & a compile-time constant\\
    [[mem]]     & [[string?]]
                & a reference to memory\\
    [[eaddr]]   & [[string]]
                & An effective address\\
\end{tabularx}

It's tempting to eliminate [[Fetch]], which would simplify rules, but
which would mean including widths on at least some operators.


First, link-time constants.
<<rules>>=
lconst: Link(symbol, width) {: symbol#text :}
const :  Bits(b:bits)        {: native b :}
four  :  Bits(b:bits) [{: guard (Bits.U.to_int b = 4) :}] {: native b :}
<<rules>>=
regl:      Reg('r', n, w) {: regname w n :}
eaddrl: regl  {: regl :}
reg: Fetch(regl, w) {: regl :}
meml:   Mem(reg, w) {: "(" ^ reg ^ ")" :}  -- indir
disp: App2("add", reg, const) {:  const ^ "(" ^ reg ^ ")" :}
disp: App2("add", const, reg) {:  const ^ "(" ^ reg ^ ")" :}
meml: Mem(disp, w) {: disp :}
meml: Mem(lconst, w) {: lconst :}
eaddrl: meml {: meml :}
eaddr: Fetch(eaddrl, w) {: eaddrl :}
eaddr: lconst {: lconst :} -- absolute
mem: Fetch(meml, w) {: meml :}
-- indexed modes to come
@ 
I'm not at all sure about the rules for immediate constants, but here
goes.
<<rules>>=
immed : lconst {: lconst :}
immed : const  {: "$" ^ const :}
immed : App2("add", lconst, const) {:  lconst ^ "+" ^ const :}
immed : App2("add", const, lconst) {:  lconst ^ "+" ^ const :}
@ 
Move, load, and store instructions.
Because the machine can do eaddr/reg
and reg/eaddr but not eaddr/eaddr, there are two varieties of each.
<<rules>>=
inst: Store(dst:eaddrl, src:immed, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

-- straight load/store/move
inst: Store(dst:eaddrl, src:reg, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

inst: Store(dst:regl, src:eaddr, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

-- sign extension
inst: Store(dst:eaddrl, App1("sx", Fetch(src:regl, nw:w)), w)
  {: cat ["movs"; suffix nw; suffix w; " "; src; ","; dst] :}

inst: Store(dst:regl, App1("sx", Fetch(src:eaddrl, nw:w)), w)
  {: cat ["movs"; suffix nw; suffix w; " "; src; ","; dst] :}

-- zero extension
inst: Store(dst:eaddrl, App1("zx", Fetch(src:regl, nw:w)), w)
  {: cat ["movz"; suffix nw; suffix w; " "; src; ","; dst] :}

inst: Store(dst:regl, App1("zx", Fetch(src:eaddrl, nw:w)), w)
  {: cat ["movz"; suffix nw; suffix w; " "; src; ","; dst] :}

-- moving low bits (relies on proper name of source)
inst: Store(dst:eaddrl, App1("lobits", Fetch(Reg('r', n, rw:w), fw:w)), nw:w)
  {: cat ["mov"; suffix nw; " "; regname nw n; ","; dst] :}

inst: Store(dst:regl, App1("lobits", src:mem), nw:w)
  {: cat ["mov"; suffix nw; " "; src; ","; dst] :}
@ 
Arithmetic.
<<rules>>=
inst: Withaflags(dst:eaddrl, "add", src:reg, w, "x86_addflags")
  {: cat ["add"; suffix w; " "; src; ","; dst] :}

inst: Withaflags(dst:regl, "add", src:eaddr, w, "x86_addflags")
  {: cat ["add"; suffix w; " "; src; ","; dst] :}

inst: Withaflags(dst:eaddrl, "sub", src:reg, w, "x86_subflags")
  {: cat ["sub"; suffix w; " "; src; ","; dst] :}

inst: Withaflags(dst:regl, "sub", src:eaddr, w, "x86_subflags")
  {: cat ["sub"; suffix w; " "; src; ","; dst] :}

inst: Setflags(App2("x86_subflags", l:eaddr, r:reg))
  {: cat ["cmp"; suffix 32; " "; l; ","; r] :} -- POSSIBLE BUG IN WIDTH
inst: Setflags(App2("x86_subflags", l:reg, r:eaddr))
  {: cat ["cmp"; suffix 32; " "; l; ","; r] :} -- POSSIBLE BUG IN WIDTH

inst: Withlflags(dst:eaddrl, logical:string, src:reg, w, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: cat [logical; suffix w; " "; src; ","; dst] :}

inst: Withlflags(dst:regl, logical:string, src:eaddr, w, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: cat [logical; suffix w; " "; src; ","; dst] :}




@ 
Return.
<<rules>>=
esp : Reg('r', n, w) [{: guard (n = 4 && w = 32):}] {: () :}
eip : Reg('c', n, w) [{: guard (n = 0 && w = 32):}] {: () :}
pop: Store(esp, App2("add", Fetch(esp, w), four), sw:w) {: () :}
pop:  Llr(esp, "add", four, w) {: () :}
push: Llr(esp, "sub", four, w) {: () :}
stacktop: Mem(Fetch(esp, w), mw:w) [{:guard (mw = 32):}] {: () :}
stacknext: Mem(App2("sub", Fetch(esp, w), four), mw:w) [{:guard (mw = 32):}] {: () :}
inst: Par(Goto(Fetch(stacktop, w)),pop) {: "ret" :}
inst: Par(Goto(eaddr),Par(Store(stacknext, Fetch(eip, x:w), y:w), push))
        {: "call " ^ eaddr :}
inst: Goto(eaddr)            {: "jmp " ^ eaddr :}
inst: Jcc(cc:string, lconst) {: "j" ^ cc ^ " " ^ lconst :}
@ 
Debugging rules.
<<rules>>=
inst: Store(meml, Fetch(reg, nw:w), w) [1] {: "<store reg into mem>" :}
inst: Store(meml, Fetch(reg, nw:w), w) [1] {: "<store eaddr into mem>" :}

inst: Store(meml, any, w) [2] {: "<store " ^ any ^ " into mem>" :}
inst: Store(any, eaddr, w) [2] {: "<store " ^ eaddr ^ " into " ^ any ^ ">" :}


inst: Store (dst:any, src:any, w) [5]
  {: "Store(" ^ dst ^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}

-- inst: any [10] {: "<" ^ any ^ ">" :}

<<rules>>=
inst: Nop() {: "nop" :}

<<rules>>=
any: True () {: "True" :}
any: False () {: "False" :}
any: Link(symbol, width) {: "Link(" ^ symbol#text ^ "," ^ string_of_int width ^ ")" :}
any: Late(string, width) {: "Late(" ^ string ^ "," ^ string_of_int width ^")" :}
any: Bits(bits) {: "Bits(b)" :}
any: Fetch (any, w) {: "Fetch(" ^ any ^ "," ^ string_of_int w ^ ")" :}
any: App1(string, any)       {: "App1(" ^ string ^ "," ^ any ^ ")" :}
any: App2(string, one:any, two:any)  {: "App2(" ^ string ^ "," ^ one ^ "," ^ two ^ ")" :}
any: App3(string, one:any, two:any, three:any)
    {: "App3(" ^ string ^ "," ^ one ^ "," ^ two ^ "," ^ three ^ ")" :}
any: Mem(any, w) {: "Mem(" ^any ^ "," ^ string_of_int w ^ ")" :}
any: Reg(char, n, w) {: "Reg('" ^ Char.escaped char ^ "'," ^ string_of_int n ^ "," ^ string_of_int w ^ ")" :}
any: Store (dst:any, src:any, w) {: "Store(" ^ dst ^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}

any: Guarded(guard:any, any) {: "Guarded(" ^ guard ^ "," ^ any ^ ")" :}
any: Par(l:any, r:any) {: "Par(" ^ l ^ "," ^ r ^ ")" :}
any: Goto(any) {: "Goto(" ^ any ^ ")" :}
any: Setflags(any) {: "Setflags(" ^ any ^ ")" :}
any: Llr(dst:any, string, src:any, w) 
  {: "Llr(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}

any: Withaflags(dst:any, string, src:any, w, fo:string) 
  {: "Withaflags(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ 
      ","^ fo ^ ")" :}

any: Withlflags(dst:any, string, src:any, w, fo:string) 
  {: "Withlflags(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ 
      ","^ fo ^ ")" :}

any: Jcc(string, any) {: "Jcc(" ^ string ^ "," ^ any ^ ")" :}


<<more rules>>=
guard:      True()  {: return I.ba :}
guard:      False() {: return I.bn :}

<<more rules>>=
guard:      App2("eq",  reg, rc) [1]     {: branch I.be      reg rc :}
guard:      App2("ge",  reg, rc) [1]     {: branch I.bge     reg rc :}
guard:      App2("geu", rc, reg) [1]     {: branch I.bleu    reg rc :}
guard:      App2("gt",  reg, rc) [1]     {: branch I.bg      reg rc :}
guard:      App2("gtu", reg, rc) [1]     {: branch I.bgu     reg rc :}
guard:      App2("le",  reg, rc) [1]     {: branch I.ble     reg rc :}
guard:      App2("leu", reg, rc) [1]     {: branch I.bleu    reg rc :}
guard:      App2("lt",  reg, rc) [1]     {: branch I.bl      reg rc :}
guard:      App2("ltu", rc, reg) [1]     {: branch I.bgu     reg rc :}
guard:      App2("ne",  reg, rc) [1]     {: branch I.bne     reg rc :}
@

{\PAL}'s primitive operators show up in expressions and are mapped to
{\sparc} instructions.

<<head>>=
let iprim2 i reg rc = assert false
let iprim1 i reg = assert false
<<more rules>>=
reg:        App2("add", reg, rc) [1]    {: iprim2  I.add   reg rc :}
reg:        App2("and", reg, rc) [1]    {: iprim2  I.and_  reg rc :}
reg:        App2("sub", reg, rc) [1]    {: iprim2  I.sub   reg rc :}
reg:        App2("shl", reg, rc) [1]    {: iprim2  I.sll   reg rc :}
reg:        App2("shra", reg, rc) [1]   {: iprim2  I.sra   reg rc :}
reg:        App2("shrl", reg, rc) [1]   {: iprim2  I.srl   reg rc :}
reg:        App2("xor", reg, rc) [1]    {: iprim2  I.xor   reg rc :}
reg:        App1("com", reg) [1]        {: iprim1  I.not2  reg :}
reg:        App1("neg", reg) [1]        {: iprim1  I.neg2  reg :}
@

Here are rule to cover opeartors we cannot handle.

<<more rules>>=
reg:        App1(o:string, reg)     [2] {: error ("cannot handle "^o) :}
reg:        App2(o:string, reg, rc) [2] {: error ("cannot handle "^o) :}
reg:        App3(string, x:reg, y:reg, z:reg)  [2] {: error "app3" :}
@

Instructions are classified into branches, calls, and so on. 

<<more rules>>=
rtl:        Branch(guard, reloc) [1]
            {:
                guard >>= fun branch ->
                exec (branch reloc) >>= fun () ->
                exec (I.nop)    (* delay slot *)
            :}

rtl:        Goto(reloc) [1]     {: exec (I.ba reloc) >>= fun () ->
                                   exec (I.nop) (* delay slot *)
                                :}
rtl:        Return()            {: exec (ret) (* jmpl %r31+8, %g0 *) :}
rtl:        Simple(stmt) [1]    {: stmt >>= fun s -> return ()   :}    
@


% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

Because it is much easier in {\ocaml} than in {\burg}, we
decompose applications and complex {\rtl}s here.

<<tail>>=  
let const = function
  | RP.Bool(true)             -> conTrue  ()
  | RP.Bool(false)            -> conFalse ()
  | RP.Link(s,w)              -> conLink s w
  | RP.Late(s,w)              -> conLate s w
  | RP.Bits(b)                -> conBits(b)

let rec exp = function
  | RP.Const(k)               -> const (k)
  | RP.Fetch(l,w)             -> conFetch (loc l) w
  | RP.App((o,_),[x])         -> conApp1 o (exp x)
  | RP.App((o,_),[x;y])       -> conApp2 o (exp x) (exp y)
  | RP.App((o,_),[x;y;z])     -> conApp3 o (exp x) (exp y) (exp z)
  | RP.App(_,_)               -> error "too many arguments in application"

and loc = function
  | RP.Cell('m', aff, w, e, ass) -> conMem (exp e) w
  | RP.Cell(sp, aff, w, RP.Const(RP.Bits b), ass)
                              -> conReg sp (Bits.U.to_int b) w
  | RP.Cell(_, _, _, _, _)    -> error "non-mem, non-reg cell"
  | RP.Var(s, i, w)           -> error "var found"
  | RP.Slice(w,i,loc)         -> error "cannot handle slice"
    
and stmt = function
  | RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r]), w) when l = l' ->
      conLlr (loc l) o (exp r) w
  | RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits b), ass), r, w)
    when (Bits.U.to_int b = 0) ->
      conGoto (exp r)
  | RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits b), ass), r, w)
    when (Bits.S.to_int b = 1) ->
      conSetflags (exp r)
  | RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits b), ass), r, w) ->
      error ("set $c["^string_of_int (Bits.U.to_int b)^"]")
  | RP.Store(RP.Cell('c', _, _, index, ass), r, w) ->
      error ("set $c["^RU.ToReadableString.exp (Up.exp index)^"]")
  | RP.Store(l,e,w)           -> conStore (loc l) (exp e) w
  | RP.Kill(loc)              -> error "cannot handle kill"
@
<<horrible pattern match for [[Withflags]]>>=
| [ (RP.Const(RP.Bool true), <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>)
  ; (RP.Const(RP.Bool true), <<pattern for flags := [[fo]] ([[l'']], [[r']])>>)
  ] when l = l' && l = l'' && r = r' && Bits.U.to_int flag_index = 1 ->
      conWithaflags (loc l) o (exp r) w fo
| [ (RP.Const(RP.Bool true), <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>)
  ; (RP.Const(RP.Bool true), <<pattern for flags := [[fo]] ([[l'']] [[o']] [[r']])>>)
  ] when l = l' && l = l'' && r = r' && o = o' && Bits.U.to_int flag_index = 1 ->
      conWithlflags (loc l) o (exp r) w fo
<<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>=
RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r]), w) 
<<pattern for flags := [[fo]] ([[l'']], [[r']])>>=
RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits flag_index), ass), 
         RP.App((fo, _), [RP.Fetch(l'',_); r']), _)
<<pattern for flags := [[fo]] ([[l'']] [[o']] [[r']])>>=
RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits flag_index), ass), 
         RP.App((fo, _), [RP.App ((o', _), [RP.Fetch(l'',_); r'])]), _)
@ 
We classify an {\rtl} here and pass it to the appropriate rule in the
rule set. The encoding of special instructions is shared between the
code expander and a target description. See module \module{targets}.
The ``special'' instructions are identified by a false guard and capital
letters in a cell.

<<tail>>=  
and rtl (RP.Rtl es) = geffects es
and geffects = function
    | [] -> conNop ()
    | [g, s] -> guarded g s
    <<horrible pattern match for [[Withflags]]>>
    | (g, s) :: t -> conPar (guarded g s) (geffects t)
and guarded g s = match g with
| RP.Const(RP.Bool b) -> if b then stmt s else conNop()
| RP.App((compare, [32]), [RP.Fetch(RP.Cell('c', _, _, RP.Const(RP.Bits n), _), _)])
    when Bits.U.to_int n = 1 && begins_x86_ compare ->
      (match s with
      | RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits b), _), r, w)
        when (Bits.U.to_int b = 0) ->
          conJcc (String.sub compare 4 (String.length compare - 4)) (exp r)
      | _ -> error "guard on x86 non-branch")
| _ -> conGuarded (exp g) (stmt s)
and begins_x86_ s =
  String.length s >= 4 && s.[0] = 'x' && s.[1] = '8' && s.[2] = '6' && s.[3] = '_'
@

The [[rtl]] function returns (the best) plan to rewrite a given {\rtl}.
When this plan is executed, it returns a monadic value that includes the
desired expanded instructionss.

<<tail>>=
let to_string (r: R.rtl) = 
    try
        let plan = rtl (Down.rtl r) in
        plan.inst.Camlburg.action ()
    with 
        | Camlburg.Uncovered -> 
            cat [ " not an instruction: " ; RU.ToReadableString.rtl r]
        | Error(msg) ->
            ( List.iter prerr_endline
                [ msg
                ; RU.ToString.rtl r
                ]
            ; " error in recognizer: " ^ msg (*assert false*)
            )

@                        
