% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------ 
\section{Intel $x$86 Recognizer}
% ------------------------------------------------------------------ 

This module provides a [[to_asm]] function that recognizes an Intel
$x$86 RTL.
As an experiment, the recognizer is implemented using BURG rules.
If the instruction is recognized, it is coverable with cost~0.
If it is not recognized, there is a catchall rule that recognizes
anything with cost~1 (I~hope).

<<x86rec.mlb>>=
%head {: <<modules>> :}
%head {: 
(*
    module Make 
        (Reloc: Sledlib.RELOCATABLE with type symbol = Symbol.t) 
        (I:     Msparcenc.S with type t      = Rtl.rtl
                            with type target = nativeint Reloc.relocatable         
        ) =
    struct    
*)
:}

%head {: <<head>> :}
%tail {: <<tail>> :}
%tail {: (* end of Make *) :}

%term <<terminal types>>
%%
<<rules>>
@


<<modules>>=
module B  = Bits 
module C  = Camlburg
module Down  = Rtl.Convert      (* Convert Down  to private repr. *)
module G  = Cfg4             (* for expanding all RTLs in a CFG *)
module GU = Cfgutil
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module N  = Nativeint
module S  = Space
module T  = Target2
module Up  = Rtl.Revert       (* Convert Up    to abstract repr. *)
module W  = Rtlutil.Width 
@
<<head>>=
exception Error of string
let error msg     = raise (Error msg)
let error_rtl rtl = error (RU.ToReadableString.rtl rtl) 
@

% ------------------------------------------------------------------ 
\subsection{Utilities}
% ------------------------------------------------------------------ 

<<head>>=
let native      = B.U.to_native

let is_imm b = 
    let i:nativeint = native b in 
        (N.of_int (-4096) <= i) or i <= (N.of_int 4095)
@   
The [[guard]] function turns a predicate into a cost where [[n]] is the
cost for the [[true]] case.
<<head>>=
let guard n = function
    | true  -> n
    | false -> C.inf_cost 
@

% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
% ------------------------------------------------------------------ 

In a {\burg} pattern variables hold either polymorphic nonterminal
values, or monomorphic terminal ({\ocaml}) values. Terminal types must
be declared:
<<terminal types>>=
k width opr exps agg ass index bool bits link late x symbol
@

The following table summarizes the nonterminals from the rule set. \\
\begin{tabularx}{\linewidth}{@{\hskip1.5em}llX@{}}
    Nonterminal & Type & Meaning \\ 
    \hline
    [[const]]       & [[nativeint]]
                & a compile-time constant\\
    [[mem]]     & [[string?]]
                & a reference to memory\\
    [[eaddr]]   & [[string]]
                & An effective address\\
\end{tabularx}

<<rules>>=
const:      Bits(b:bits)        {: native b :}
@
<<rules>>=
eaddr:      const {: Nativeint.to_string const :}
@
<<rules>>=
rplusk:       App2("add", reg, const)
            {:  Nativeint.to_string const ^ "(" ^ reg ^ ")" :}

eaddr:      reg         {: reg :}

addr: rplusk {: rplusk :}
addr: reg    {: "(" ^ reg ^ ")" :}
mem:        Cell('m', agg, width, addr, ass) {: addr :}
eaddr: mem   {: mem :}
@

Fetches from registers.
<<rules>>=
reg:        Fetch(rcell, width)     {: rcell :}
freg:       Fetch(fcell, width)     {: fcell :}
@
Registers are categorized into interger, floating point, and control
registers. Note, that temporaries are treated like hardware registers.
<<rules>>=
rcell:      Cell('r', agg, width, k:const, ass) 
            {: (*I.reg width (N.to_int k)*) "a register" :} 
            
fcell:      Cell('f', agg, width, k:const, ass)
            {: (*I.freg (N.to_int k)*) "a floating-point register" :}
@

Moves between registers.
<<more rules>>=
stmt:       Store(rcell, rc, width) [1]
            {: rcell >>= fun r  -> rc  >>= fun rc -> exec (I.mov rc r) :}
            
stmt:       Store(fcell, freg, width) [1]
            {: fcell >>= fun f1 -> freg >>= fun f2 -> exec (I.fmovs f2 f1) :}
@ 

<<rules>>=
any: True () {: () :}
any: False () {: () :}
any: Link(symbol, width) {: () :}
any: Late(string, width) {: () :}
any:        App1("neg", any)       {: () :}
any: App3(string, one:any, two:any, three:any) {: () :}
any:       Store(fcell, freg, width) {: () :}
any: Nop() {: () :}
any: Simple (any) {: () :}
any: Branch(any, two:any) {: () :}
any: Goto(any) {: () :}
any: Return() {: () :}




<<more rules>>=
guard:      True()  {: return I.ba :}
guard:      False() {: return I.bn :}

<<more rules>>=
guard:      App2("eq",  reg, rc) [1]     {: branch I.be      reg rc :}
guard:      App2("ge",  reg, rc) [1]     {: branch I.bge     reg rc :}
guard:      App2("geu", rc, reg) [1]     {: branch I.bleu    reg rc :}
guard:      App2("gt",  reg, rc) [1]     {: branch I.bg      reg rc :}
guard:      App2("gtu", reg, rc) [1]     {: branch I.bgu     reg rc :}
guard:      App2("le",  reg, rc) [1]     {: branch I.ble     reg rc :}
guard:      App2("leu", reg, rc) [1]     {: branch I.bleu    reg rc :}
guard:      App2("lt",  reg, rc) [1]     {: branch I.bl      reg rc :}
guard:      App2("ltu", rc, reg) [1]     {: branch I.bgu     reg rc :}
guard:      App2("ne",  reg, rc) [1]     {: branch I.bne     reg rc :}
@

{\PAL}'s primitive operators show up in expressions and are mapped to
{\sparc} instructions.

<<head>>=
let iprim2 i reg rc = assert false
let iprim1 i reg = assert false
<<more rules>>=
reg:        App2("add", reg, rc) [1]    {: iprim2  I.add   reg rc :}
reg:        App2("and", reg, rc) [1]    {: iprim2  I.and_  reg rc :}
reg:        App2("sub", reg, rc) [1]    {: iprim2  I.sub   reg rc :}
reg:        App2("shl", reg, rc) [1]    {: iprim2  I.sll   reg rc :}
reg:        App2("shra", reg, rc) [1]   {: iprim2  I.sra   reg rc :}
reg:        App2("shrl", reg, rc) [1]   {: iprim2  I.srl   reg rc :}
reg:        App2("xor", reg, rc) [1]    {: iprim2  I.xor   reg rc :}
reg:        App1("com", reg) [1]        {: iprim1  I.not2  reg :}
reg:        App1("neg", reg) [1]        {: iprim1  I.neg2  reg :}
@

Here are rule to cover opeartors we cannot handle.

<<more rules>>=
reg:        App1(o:string, reg)     [2] {: error ("cannot handle "^o) :}
reg:        App2(o:string, reg, rc) [2] {: error ("cannot handle "^o) :}
reg:        App3(string, x:reg, y:reg, z:reg)  [2] {: error "app3" :}
@

Instructions are classified into branches, calls, and so on. 

<<more rules>>=
rtl:        Branch(guard, reloc) [1]
            {:
                guard >>= fun branch ->
                exec (branch reloc) >>= fun () ->
                exec (I.nop)    (* delay slot *)
            :}

rtl:        Goto(reloc) [1]     {: exec (I.ba reloc) >>= fun () ->
                                   exec (I.nop) (* delay slot *)
                                :}
rtl:        Return()            {: exec (ret) (* jmpl %r31+8, %g0 *) :}
rtl:        Simple(stmt) [1]    {: stmt >>= fun s -> return ()   :}    
rtl:        Nop() [1]           {: exec I.nop  :}
@


% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

Because it is much easier in {\ocaml} than in {\burg}, we
decompose applications and complex {\rtl}s here.

<<tail>>=  
let const = function
    | RP.Bool(true)             -> conTrue  ()
    | RP.Bool(false)            -> conFalse ()
    | RP.Link(s,w)              -> conLink s w
    | RP.Late(s,w)              -> conLate s w
    | RP.Bits(b)                -> conBits(b)

let rec exp = function
    | RP.Const(k)               -> const (k)
    | RP.Fetch(l,w)             -> conFetch (loc l) w
    | RP.App((o,_),[x])         -> conApp1 o (exp x)
    | RP.App((o,_),[x;y])       -> conApp2 o (exp x) (exp y)
    | RP.App((o,_),[x;y;z])     -> conApp3 o (exp x) (exp y) (exp z)
    | RP.App(_,_)               -> error "too many arguments in application"

and loc = function
    | RP.Cell(char, aff, w, e, ass) -> conCell char aff w (exp e) ass 
    | RP.Var(s, i, w)           -> error "var found"
    | RP.Slice(w,i,loc)         -> error "cannot handle slice"
    
and stmt = function
    | RP.Store(l,e,w)           -> conStore (loc l) (exp e) w
    | RP.Kill(loc)              -> error "cannot handle kill"
@

We classify an {\rtl} here and pass it to the appropriate rule in the
rule set. The encoding of special instructions is shared between the
code expander and a target description. See module \module{targets}.
The ``special'' instructions are identified by a false guard and capital
letters in a cell.

<<tail>>=  
and rtl = function
    | RP.Rtl([])                            -> conNop ()
    | RP.Rtl([(RP.Const(RP.Bool(true)),s)]) -> conSimple (stmt s)
    | RP.Rtl([(g,RP.Store(RP.Cell(sp,_,_,_,_),e,_))]) as rtl ->
        ( match sp with
        | 'B' -> conBranch (exp g) (exp e) 
        | 'G' -> conGoto   (exp e)
        | 'R' -> conReturn ()
        | _   -> error_rtl (Up.rtl rtl)
        )
    | RP.Rtl(_) as rtl -> error "cannot expand this RTL"
@

The [[rtl]] function returns (the best) plan to rewrite a given {\rtl}.
When this plan is executed, it returns a monadic value that includes the
desired expanded instructionss.

<<tail>>=
let expand tmps (r: R.rtl) = 
    try
        let plan = rtl (Down.rtl r) in
        ()
    with 
        | Camlburg.Uncovered -> 
            ( List.iter prerr_endline
                [ "cannot expand this RTL:"
                ; RU.ToString.rtl r
                ]
            ; assert false
            )
        | Error(msg) ->
            ( List.iter prerr_endline
                [ msg
                ; RU.ToString.rtl r
                ]
            ; assert false
            )

@                        
