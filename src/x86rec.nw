% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------ 
\section{Intel $x$86 Recognizer}
\label{x86rec.sec}

% ------------------------------------------------------------------ 

%%Grades: B Subsystem Later

This module provides functions that recognize an Intel
$x$86 RTL.
As an experiment, the recognizer is implemented using BURG rules.
If the instruction is recognized, it is coverable with small cost.
(Perhaps one day, the cost could be bytes of code.)
If it is not recognized, there is a catchall rule that recognizes
anything with cost~100 (I~hope).

WARNING: THIS RECOGNIZER DOES NOT (YET) RECOGNIZE KILLS.

<<x86rec.mli>>=
module M : sig
  val to_asm      : Rtl.rtl -> string
  val is_instruction : Rtl.rtl -> bool
end
<<x86rec.mlb>>=
%head {: <<modules>> :}
%head {: 
    module M (*
        (I:     X86i.S with type t      = Sledlib.String.t) *)
         =
    struct    
:}

%head {: <<head>> :}
%tail {: <<tail>> :}
%tail {: end (* of Make *) :}

%term <<terminal types>>
%%
<<rules>>
@


<<modules>>=
module B  = Bits 
module C  = Camlburg
module Down  = Rtl.Convert      (* Convert Down  to private repr. *)
module G  = Cfg4             (* for expanding all RTLs in a CFG *)
module GU = Cfgutil
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module N  = Nativeint
module S  = Space
module SS = Space.Standard32
module T  = Target2
module Up  = Rtl.Revert       (* Convert Up    to abstract repr. *)
module W  = Rtlutil.Width 
@
<<head>>=
exception Error of string
let error msg     = raise (Error msg)
let error_rtl rtl = error (RU.ToReadableString.rtl rtl) 
@



% ------------------------------------------------------------------ 
\subsection{Utilities}
% ------------------------------------------------------------------ 

<<head>>=
let weirdb = B.S.of_int (-4) 32
let weird = Nativeint.to_string (B.S.to_native weirdb)
 (* let _ = List.iter prerr_string ["Weird integer is "; weird; "\n"] *)
let native b = 
  assert (B.width b = 32);
  Nativeint.to_string (B.U.to_native b)
let cat = String.concat ""
@   
The [[guard]] function turns a predicate into a cost.
<<head>>=
let infinity = C.inf_cost
let guard b = if b then 0 else C.inf_cost
@ 
<<head>>=
let suffix w = match w with
| 8  -> "b"
| 16 -> "w"
| 32 -> "l"
| _ -> Impossible.impossible "width in x86 not 8/16/32"
@
% ------------------------------------------------------------------ 
\subsection{Register names}
% ------------------------------------------------------------------ 
<<head>>=
let r8_names  = [| "%al"; "%cl"; "%dl"; "%bl"; "%ah"; "%ch"; "%dh"; "%bh" |]
let r16_names = [| "%ax"; "%cx"; "%dx"; "%bx"; "%sp"; "%bp"; "%si"; "%di" |]
let r32_names = [| "%eax"; "%ecx"; "%edx"; "%ebx"; "%esp"; "%ebp"; "%esi"; "%edi" |]
let reg_names w = match w with
| 8  -> r8_names
| 16 -> r16_names
| 32 -> r32_names
| _  -> Impossible.impossible "x86 register width not 8/16/32"
let regname w = Array.get (reg_names w)
@     



% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
% ------------------------------------------------------------------ 

In a {\burg} pattern variables hold either polymorphic nonterminal
values, or monomorphic terminal ({\ocaml}) values. Terminal types must
be declared:
<<terminal types>>=
n w space
k width opr exps agg ass index bool bits link late x symbol
@

The following table summarizes the nonterminals from the rule set. \\
\begin{tabularx}{\linewidth}{@{\hskip1.5em}llX@{}}
    Nonterminal & Type & Meaning \\ 
    \hline
    [[const]]       & [[nativeint]]
                & a compile-time constant\\
    [[mem]]     & [[string?]]
                & a reference to memory\\
    [[eaddr]]   & [[string]]
                & An effective address\\
\end{tabularx}

It's tempting to eliminate [[Fetch]], which would simplify rules, but
which would mean including widths on at least some operators.


First, link-time constants.
<<rules>>=
lconst: Link(symbol, width) {: symbol#text :}
const :  Bits(b:bits)        {: native b :}
four  :  Bits(b:bits) [{: guard (Bits.U.to_int b = 4) :}] {: native b :}
<<rules>>=
regl:      Reg('r', n, w) {: regname w n :}
eaddrl: regl  {: regl :}
reg: Fetch(regl, w) {: regl :}
meml:   Mem(reg, w) {: "(" ^ reg ^ ")" :}  -- indir
disp: Add(reg, const) {:  const ^ "(" ^ reg ^ ")" :}
disp: Add(const, reg) {:  const ^ "(" ^ reg ^ ")" :}
meml: Mem(disp, w) {: disp :}
meml: Mem(lconst, w) {: lconst :}
eaddrl: meml {: meml :}
eaddr: Fetch(eaddrl, w) {: eaddrl :}
eaddr: lconst {: lconst :} -- absolute
mem: Fetch(meml, w) {: meml :}
-- indexed modes to come
@ 
I'm not at all sure about the rules for immediate constants, but here
goes.
<<rules>>=
immed : lconst {: lconst :}
immed : const  {: "$" ^ const :}
immed : Add(lconst, const) {:  lconst ^ "+" ^ const :}
immed : Add(const, lconst) {:  lconst ^ "+" ^ const :}
@ 
Move, load, and store instructions.
Because the machine can do eaddr/reg
and reg/eaddr but not eaddr/eaddr, there are two varieties of each.
<<rules>>=
inst: Store(dst:eaddrl, src:immed, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

-- straight load/store/move
inst: Store(dst:eaddrl, src:reg, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

inst: Store(dst:regl, src:eaddr, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

-- sign extension
inst: Store(dst:eaddrl, Sx(Fetch(src:regl, nw:w)), w)
  {: cat ["movs"; suffix nw; suffix w; " "; src; ","; dst] :}

inst: Store(dst:regl, Sx(Fetch(src:eaddrl, nw:w)), w)
  {: cat ["movs"; suffix nw; suffix w; " "; src; ","; dst] :}

-- zero extension
inst: Store(dst:eaddrl, Zx(Fetch(src:regl, nw:w)), w)
  {: cat ["movz"; suffix nw; suffix w; " "; src; ","; dst] :}

inst: Store(dst:regl, Zx(Fetch(src:eaddrl, nw:w)), w)
  {: cat ["movz"; suffix nw; suffix w; " "; src; ","; dst] :}

-- moving low bits (relies on proper name of source)
inst: Store(dst:eaddrl, Lobits(Fetch(Reg('r', n, rw:w), fw:w)), nw:w)
  {: cat ["mov"; suffix nw; " "; regname nw n; ","; dst] :}

inst: Store(dst:regl, Lobits(src:mem), nw:w)
  {: cat ["mov"; suffix nw; " "; src; ","; dst] :}
@ 
Arithmetic.
<<rules>>=
inst: Withaflags(dst:eaddrl, "add", src:reg, w, "x86_addflags")
  {: cat ["add"; suffix w; " "; src; ","; dst] :}

inst: Withaflags(dst:regl, "add", src:eaddr, w, "x86_addflags")
  {: cat ["add"; suffix w; " "; src; ","; dst] :}

inst: Withaflags(dst:eaddrl, "sub", src:reg, w, "x86_subflags")
  {: cat ["sub"; suffix w; " "; src; ","; dst] :}

inst: Withaflags(dst:regl, "sub", src:eaddr, w, "x86_subflags")
  {: cat ["sub"; suffix w; " "; src; ","; dst] :}

inst: Setflags(X86_subflags(l:eaddr, r:reg))
  {: cat ["cmp"; suffix 32; " "; l; ","; r] :} -- POSSIBLE BUG IN WIDTH
inst: Setflags(X86_subflags(l:reg, r:eaddr))
  {: cat ["cmp"; suffix 32; " "; l; ","; r] :} -- POSSIBLE BUG IN WIDTH

inst: Withlflags(dst:eaddrl, logical:string, src:reg, w, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: cat [logical; suffix w; " "; src; ","; dst] :}

inst: Withlflags(dst:regl, logical:string, src:eaddr, w, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: cat [logical; suffix w; " "; src; ","; dst] :}




@ 
Return.
<<rules>>=
esp : Reg('r', n, w) [{: guard (n = 4 && w = 32):}] {: () :}
eip : Reg('c', n, w) [{: guard (n = SS.indices.SS.pc && w = 32):}] {: () :}
pop: Store(esp, Add(Fetch(esp, w), four), sw:w) {: () :}
pop:  Llr(esp, "add", four, w) {: () :}
push: Llr(esp, "sub", four, w) {: () :}
stacktop: Mem(Fetch(esp, w), mw:w) [{:guard (mw = 32):}] {: () :}
stacknext: Mem(Sub(Fetch(esp, w), four), mw:w) [{:guard (mw = 32):}] {: () :}
inst: Par(Goto(Fetch(stacktop, w)),pop) {: "ret" :}
inst: Par(Goto(eaddr),Par(Store(stacknext, Fetch(eip, x:w), y:w), push))
        {: "call " ^ eaddr :}
inst: Goto(eaddr)            {: "jmp " ^ eaddr :}
inst: Jcc(cc:string, lconst) {: "j" ^ cc ^ " " ^ lconst :}

<<rules>>=
inst: Nop() {: "nop" :}
@ 
Debugging rules.
<<rules>>=
-- inst: any [100] {: "<" ^ any ^ ">" :}

any: True  () {: "True"  :}
any: False () {: "False" :}
any: Link(symbol, width) {: "Link(" ^ symbol#text ^ "," ^ string_of_int width ^ ")" :}
any: Late(string, width) {: "Late(" ^ string ^ "," ^ string_of_int width ^")" :}
any: Bits(bits) {: "Bits(b)" :}
any: Fetch (any, w) {: "Fetch(" ^ any ^ "," ^ string_of_int w ^ ")" :}

any: Add(x:any, y:any) {: "Add(" ^ x ^ ", " ^ y ^ ")" :}
any: Sx(any) {: "Sx(" ^ any ^ ")" :}
any: Zx(any) {: "Zx(" ^ any ^ ")" :}
any: Lobits(any) {: "Lobits(" ^ any ^ ")" :}
any: X86_subflags(l:any, r:any) {: "X86_subflags(" ^ l ^ ", " ^ r ^ ")" :}


any: Mem(any, w) {: "Mem(" ^any ^ "," ^ string_of_int w ^ ")" :}
any: Reg(char, n, w)
  {: "Reg('" ^ Char.escaped char ^ "'," ^ string_of_int n ^ "," ^
               string_of_int w ^ ")"
   :}

any: Store (dst:any, src:any, w)
 {: "Store(" ^ dst ^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}
any: Kill(any) {: "Kill(" ^ any ^ ")" :}

any: Guarded(guard:any, any) {: "Guarded(" ^ guard ^ "," ^ any ^ ")" :}
any: Par(l:any, r:any) {: "Par(" ^ l ^ "," ^ r ^ ")" :}
any: Goto(any) {: "Goto(" ^ any ^ ")" :}
any: Setflags(any) {: "Setflags(" ^ any ^ ")" :}
any: Llr(dst:any, string, src:any, w) 
  {: "Llr(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}

any: Withaflags(dst:any, string, src:any, w, fo:string) 
  {: "Withaflags(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ 
      ","^ fo ^ ")" :}

any: Withlflags(dst:any, string, src:any, w, fo:string) 
  {: "Withlflags(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ 
      ","^ fo ^ ")" :}

any: Jcc(string, any) {: "Jcc(" ^ string ^ "," ^ any ^ ")" :}
@


% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

Because it is much easier in {\ocaml} than in {\burg}, we
decompose applications and complex {\rtl}s here.
<<special cases for particular operators>>=
| RP.App(("add", [w]), [x; y]) -> conAdd (exp x) (exp y)
| RP.App(("sub", [w]), [x; y]) -> conSub (exp x) (exp y)
| RP.App(("sx", [n;w]), [x])   -> conSx  (exp x)
| RP.App(("zx", [n;w]), [x])   -> conZx  (exp x)
| RP.App(("lobits", [w;n]), [x])   -> conLobits (exp x)
| RP.App(("x86_subflags", [w]), [x; y]) -> conX86_subflags (exp x) (exp y)
| RP.App((("add"|"sub"|"sx"|"zx"|"lobits"|"x86_subflags") as op, _), _) ->
    Impossible.impossible ("ill-formed " ^ op)

<<tail>>=  
let const = function
  | RP.Bool(true)             -> conTrue  ()
  | RP.Bool(false)            -> conFalse ()
  | RP.Link(s,w)              -> conLink s w
  | RP.Late(s,w)              -> conLate s w
  | RP.Bits(b)                -> conBits(b)

let rec exp = function
  | RP.Const(k)               -> const (k)
  | RP.Fetch(l,w)             -> conFetch (loc l) w
  <<special cases for particular operators>>
  | RP.App((o,_),_)           -> error ("unknown operator " ^ o)

and loc = function
  | RP.Cell('m', aff, w, e, ass) -> conMem (exp e) w
  | RP.Cell(sp, aff, w, RP.Const(RP.Bits b), ass)
                              -> conReg sp (Bits.U.to_int b) w
  | RP.Cell(_, _, _, _, _)    -> error "non-mem, non-reg cell"
  | RP.Var(s, i, w)           -> error "var found"
  | RP.Slice(w,i,loc)         -> error "cannot handle slice"
    
and stmt = function
  | RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r]), w) when l = l' ->
      conLlr (loc l) o (exp r) w
  | RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits b), ass), r, w)
    when (Bits.U.to_int b = SS.indices.SS.pc) ->
      conGoto (exp r)
  | RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits b), ass), r, w)
    when (Bits.S.to_int b = SS.indices.SS.cc) ->
      conSetflags (exp r)
  | RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits b), ass), r, w) ->
      error ("set $c["^string_of_int (Bits.U.to_int b)^"]")
  | RP.Store(RP.Cell('c', _, _, index, ass), r, w) ->
      error ("set $c["^RU.ToReadableString.exp (Up.exp index)^"]")
  | RP.Store(l,e,w)           -> conStore (loc l) (exp e) w
  | RP.Kill(l)                -> conKill (loc l)
@
<<horrible pattern match for [[Withflags]]>>=
| [ (RP.Const(RP.Bool true), <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>)
  ; (RP.Const(RP.Bool true), <<pattern for flags := [[fo]] ([[l'']], [[r']])>>)
  ] when l = l' && l = l'' && r = r' && Bits.U.to_int flag_index = SS.indices.SS.cc ->
      conWithaflags (loc l) o (exp r) w fo
| [ (RP.Const(RP.Bool true), <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>)
  ; (RP.Const(RP.Bool true), <<pattern for flags := [[fo]] ([[l'']] [[o']] [[r']])>>)
  ] when l = l' && l = l'' && r = r' && o = o'
    && Bits.U.to_int flag_index = SS.indices.SS.cc ->
      conWithlflags (loc l) o (exp r) w fo
<<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>=
RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r]), w) 
<<pattern for flags := [[fo]] ([[l'']], [[r']])>>=
RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits flag_index), ass), 
         RP.App((fo, _), [RP.Fetch(l'',_); r']), _)
<<pattern for flags := [[fo]] ([[l'']] [[o']] [[r']])>>=
RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits flag_index), ass), 
         RP.App((fo, _), [RP.App ((o', _), [RP.Fetch(l'',_); r'])]), _)
@ 
We classify an {\rtl} here and pass it to the appropriate rule in the
rule set. The encoding of special instructions is shared between the
code expander and a target description. See module \module{targets}.
The ``special'' instructions are identified by a false guard and capital
letters in a cell.

<<tail>>=  
and rtl (RP.Rtl es) = geffects es
and geffects = function
    | [] -> conNop ()
    | [g, s] -> guarded g s
    <<horrible pattern match for [[Withflags]]>>
    | (g, s) :: t -> conPar (guarded g s) (geffects t)
and guarded g s = match g with
| RP.Const(RP.Bool b) -> if b then stmt s else conNop()
| RP.App((compare, [32]), [RP.Fetch(RP.Cell('c', _, _, RP.Const(RP.Bits n), _), _)])
    when Bits.U.to_int n = SS.indices.SS.cc && begins_x86_ compare ->
      (match s with
      | RP.Store(RP.Cell('c', _, _, RP.Const(RP.Bits b), _), r, w)
        when (Bits.U.to_int b = SS.indices.SS.pc) ->
          conJcc (String.sub compare 4 (String.length compare - 4)) (exp r)
      | _ -> error "guard on x86 non-branch")
| _ -> conGuarded (exp g) (stmt s)
and begins_x86_ s =
  String.length s >= 4 && s.[0] = 'x' && s.[1] = '8' && s.[2] = '6' && s.[3] = '_'
@

The [[rtl]] function returns (the best) plan to rewrite a given {\rtl}.
When this plan is executed, it returns a monadic value that includes the
desired expanded instructionss.

<<tail>>=
let to_asm (r: R.rtl) = 
    try
        let plan = rtl (Down.rtl r) in
        plan.inst.Camlburg.action ()
    with 
        | Camlburg.Uncovered -> 
            cat [ " not an instruction: " ; RU.ToReadableString.rtl r]
        | Error(msg) ->
            ( List.iter prerr_endline
                [ msg
                ; RU.ToString.rtl r
                ]
            ; " error in recognizer: " ^ msg (*assert false*)
            )

let is_instruction r =
    try
        let plan = rtl (Down.rtl r) in
        plan.inst.Camlburg.cost < 100  (* should be true, but shade this... *)
    with 
        | Camlburg.Uncovered -> false
        | Error(msg) ->
            ( List.iter prerr_string
                [ "recognizer error: "; msg; " on "; RU.ToReadableString.rtl r; "\n"
                ]
            ; false
            )
@                        
