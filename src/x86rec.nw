% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------ 
\section{Intel $x$86 Recognizer}
% ------------------------------------------------------------------ 

This module provides a [[to_asm]] function that recognizes an Intel
$x$86 RTL.
As an experiment, the recognizer is implemented using BURG rules.
If the instruction is recognized, it is coverable with cost~0.
If it is not recognized, there is a catchall rule that recognizes
anything with cost~1 (I~hope).

<<x86rec.mli>>=
module M (* (I: X86i.S with type t = Sledlib.String.t)*) : sig
  val to_string : Rtl.rtl -> string
end
<<x86rec.mlb>>=
%head {: <<modules>> :}
%head {: 
    module M (*
        (I:     X86i.S with type t      = Sledlib.String.t) *)
         =
    struct    
:}

%head {: <<head>> :}
%tail {: <<tail>> :}
%tail {: end (* of Make *) :}

%term <<terminal types>>
%%
<<rules>>
@


<<modules>>=
module B  = Bits 
module C  = Camlburg
module Down  = Rtl.Convert      (* Convert Down  to private repr. *)
module G  = Cfg4             (* for expanding all RTLs in a CFG *)
module GU = Cfgutil
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module N  = Nativeint
module S  = Space
module T  = Target2
module Up  = Rtl.Revert       (* Convert Up    to abstract repr. *)
module W  = Rtlutil.Width 
@
<<head>>=
exception Error of string
let error msg     = raise (Error msg)
let error_rtl rtl = error (RU.ToReadableString.rtl rtl) 
@



% ------------------------------------------------------------------ 
\subsection{Utilities}
% ------------------------------------------------------------------ 

<<head>>=
let native b = Nativeint.to_string (B.U.to_native b)
let cat = String.concat ""
@   
The [[guard]] function turns a predicate into a cost where [[n]] is the
cost for the [[true]] case.
<<head>>=
let guard n = function
    | true  -> n
    | false -> C.inf_cost 
@ 
<<head>>=
let suffix w = match w with
| 8  -> "b"
| 16 -> "w"
| 32 -> "l"
| _ -> Impossible.impossible "width in x86 not 8/16/32"
@
% ------------------------------------------------------------------ 
\subsection{Register names}
% ------------------------------------------------------------------ 
<<head>>=
let r8_names  = [| "al"; "cl"; "dl"; "bl"; "ah"; "ch"; "dh"; "bh" |]
let r16_names = [| "ax"; "cx"; "dx"; "bx"; "sp"; "bp"; "si"; "di" |]
let r32_names = [| "eax"; "ecx"; "edx"; "ebx"; "esp"; "ebp"; "esi"; "edi" |]
let reg_names w = match w with
| 8  -> r8_names
| 16 -> r16_names
| 32 -> r32_names
| _  -> Impossible.impossible "x86 register width not 8/16/32"
let regname w = Array.get (reg_names w)
@     



% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
% ------------------------------------------------------------------ 

In a {\burg} pattern variables hold either polymorphic nonterminal
values, or monomorphic terminal ({\ocaml}) values. Terminal types must
be declared:
<<terminal types>>=
n w space
k width opr exps agg ass index bool bits link late x symbol
@

The following table summarizes the nonterminals from the rule set. \\
\begin{tabularx}{\linewidth}{@{\hskip1.5em}llX@{}}
    Nonterminal & Type & Meaning \\ 
    \hline
    [[const]]       & [[nativeint]]
                & a compile-time constant\\
    [[mem]]     & [[string?]]
                & a reference to memory\\
    [[eaddr]]   & [[string]]
                & An effective address\\
\end{tabularx}

First, link-time constants.
<<rules>>=
lconst: Link(symbol, width) {: symbol#text :}
const:  Bits(b:bits)        {: native b :}
<<rules>>=
reg:      Reg('r', n, w) {: regname w n :}
eaddrl: reg  {: reg :}
meml:   Mem(Fetch(reg, rw:w), w) {: "(" ^ reg ^ ")" :}  -- indir
disp: App2("add", reg, const) {:  const ^ "(" ^ reg ^ ")" :}
disp: App2("add", const, reg) {:  const ^ "(" ^ reg ^ ")" :}
meml: Mem(disp, w) {: disp :}
meml: Mem(lconst, w) {: lconst :}
eaddrl: meml {: meml :}
eaddr: Fetch(eaddrl, w) {: eaddrl :}
mem: Fetch(meml, w) {: meml :}
-- indexed modes to come
@ 
I'm not at all sure about the rules for immediate constants, but here
goes.
<<rules>>=
immed : lconst {: lconst :}
immed : const  {: "$" ^ const :}
immed : App2("add", lconst, const) {:  lconst ^ "+" ^ const :}
immed : App2("add", const, lconst) {:  lconst ^ "+" ^ const :}
@ 
Move, load, and store instruction.
<<rules>>=
inst: Store(dst:eaddrl, src:immed, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

inst: Store(dst:eaddrl, src:eaddr, w) 
  {: cat ["mov"; suffix w; " "; src; ","; dst] :}

inst: Store(dst:eaddrl, App1("sx", Fetch(src:eaddrl, nw:w)), w)
  {: cat ["movs"; suffix nw; suffix w; " "; src; ","; dst] :}

inst: Store(dst:eaddrl, App1("zx", Fetch(src:eaddrl, nw:w)), w)
  {: cat ["movz"; suffix nw; suffix w; " "; src; ","; dst] :}

inst: Store(dst:eaddrl, App1("lobits", src:mem), nw:w)
  {: cat ["mov"; suffix nw; " "; src; ","; dst] :}

inst: Store(dst:eaddrl, App1("lobits", Fetch(Reg('r', n, rw:w), w)), nw:w)
  {: cat ["mov"; suffix nw; " "; regname nw n; ","; dst] :}

@ 
Debugging rules.
<<rules>>=
inst: Store(meml, Fetch(reg, nw:w), w) [1] {: "<store reg into mem>" :}
inst: Store(meml, Fetch(reg, nw:w), w) [1] {: "<store eaddr into mem>" :}

inst: Store(meml, any, w) [2] {: "<store " ^ any ^ " into mem>" :}
inst: Store(any, eaddr, w) [2] {: "<store " ^ eaddr ^ " into " ^ any ^ ">" :}


inst: Store (dst:any, src:any, w) [5]
  {: "Store(" ^ dst ^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}

<<rules>>=
inst: Nop() {: "nop" :}

<<rules>>=
any: True () {: "True" :}
any: False () {: "False" :}
any: Link(symbol, width) {: "Link(" ^ symbol#text ^ "," ^ string_of_int width ^ ")" :}
any: Late(string, width) {: "Late(" ^ string ^ "," ^ string_of_int width ^")" :}
any: Bits(bits) {: "Bits(b)" :}
any: Fetch (any, w) {: "Fetch(" ^ any ^ "," ^ string_of_int w ^ ")" :}
any: App1(string, any)       {: "App1(" ^ string ^ "," ^ any ^ ")" :}
any: App2(string, one:any, two:any)  {: "App2(" ^ string ^ "," ^ one ^ "," ^ two ^ ")" :}
any: App3(string, one:any, two:any, three:any)
    {: "App3(" ^ string ^ "," ^ one ^ "," ^ two ^ "," ^ three ^ ")" :}
any: Mem(any, w) {: "Mem(" ^any ^ "," ^ string_of_int w ^ ")" :}
any: Reg(char, n, w) {: "Reg('" ^ Char.escaped char ^ "'," ^ string_of_int n ^ "," ^ string_of_int w ^ ")" :}
any: Store (dst:any, src:any, w) {: "Store(" ^ dst ^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}

any: Guarded(guard:any, any) {: "Guarded(" ^ guard ^ "," ^ any ^ ")" :}
any: Par(l:any, r:any) {: "Par(" ^ l ^ "," ^ r ^ ")" :}



<<more rules>>=
guard:      True()  {: return I.ba :}
guard:      False() {: return I.bn :}

<<more rules>>=
guard:      App2("eq",  reg, rc) [1]     {: branch I.be      reg rc :}
guard:      App2("ge",  reg, rc) [1]     {: branch I.bge     reg rc :}
guard:      App2("geu", rc, reg) [1]     {: branch I.bleu    reg rc :}
guard:      App2("gt",  reg, rc) [1]     {: branch I.bg      reg rc :}
guard:      App2("gtu", reg, rc) [1]     {: branch I.bgu     reg rc :}
guard:      App2("le",  reg, rc) [1]     {: branch I.ble     reg rc :}
guard:      App2("leu", reg, rc) [1]     {: branch I.bleu    reg rc :}
guard:      App2("lt",  reg, rc) [1]     {: branch I.bl      reg rc :}
guard:      App2("ltu", rc, reg) [1]     {: branch I.bgu     reg rc :}
guard:      App2("ne",  reg, rc) [1]     {: branch I.bne     reg rc :}
@

{\PAL}'s primitive operators show up in expressions and are mapped to
{\sparc} instructions.

<<head>>=
let iprim2 i reg rc = assert false
let iprim1 i reg = assert false
<<more rules>>=
reg:        App2("add", reg, rc) [1]    {: iprim2  I.add   reg rc :}
reg:        App2("and", reg, rc) [1]    {: iprim2  I.and_  reg rc :}
reg:        App2("sub", reg, rc) [1]    {: iprim2  I.sub   reg rc :}
reg:        App2("shl", reg, rc) [1]    {: iprim2  I.sll   reg rc :}
reg:        App2("shra", reg, rc) [1]   {: iprim2  I.sra   reg rc :}
reg:        App2("shrl", reg, rc) [1]   {: iprim2  I.srl   reg rc :}
reg:        App2("xor", reg, rc) [1]    {: iprim2  I.xor   reg rc :}
reg:        App1("com", reg) [1]        {: iprim1  I.not2  reg :}
reg:        App1("neg", reg) [1]        {: iprim1  I.neg2  reg :}
@

Here are rule to cover opeartors we cannot handle.

<<more rules>>=
reg:        App1(o:string, reg)     [2] {: error ("cannot handle "^o) :}
reg:        App2(o:string, reg, rc) [2] {: error ("cannot handle "^o) :}
reg:        App3(string, x:reg, y:reg, z:reg)  [2] {: error "app3" :}
@

Instructions are classified into branches, calls, and so on. 

<<more rules>>=
rtl:        Branch(guard, reloc) [1]
            {:
                guard >>= fun branch ->
                exec (branch reloc) >>= fun () ->
                exec (I.nop)    (* delay slot *)
            :}

rtl:        Goto(reloc) [1]     {: exec (I.ba reloc) >>= fun () ->
                                   exec (I.nop) (* delay slot *)
                                :}
rtl:        Return()            {: exec (ret) (* jmpl %r31+8, %g0 *) :}
rtl:        Simple(stmt) [1]    {: stmt >>= fun s -> return ()   :}    
@


% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

Because it is much easier in {\ocaml} than in {\burg}, we
decompose applications and complex {\rtl}s here.

<<tail>>=  
let const = function
    | RP.Bool(true)             -> conTrue  ()
    | RP.Bool(false)            -> conFalse ()
    | RP.Link(s,w)              -> conLink s w
    | RP.Late(s,w)              -> conLate s w
    | RP.Bits(b)                -> conBits(b)

let rec exp = function
    | RP.Const(k)               -> const (k)
    | RP.Fetch(l,w)             -> conFetch (loc l) w
    | RP.App((o,_),[x])         -> conApp1 o (exp x)
    | RP.App((o,_),[x;y])       -> conApp2 o (exp x) (exp y)
    | RP.App((o,_),[x;y;z])     -> conApp3 o (exp x) (exp y) (exp z)
    | RP.App(_,_)               -> error "too many arguments in application"

and loc = function
    | RP.Cell('m', aff, w, e, ass) -> conMem (exp e) w
    | RP.Cell(sp, aff, w, RP.Const(RP.Bits b), ass)
                                -> conReg sp (Bits.U.to_int b) w
    | RP.Cell(_, _, _, _, _)    -> error "non-mem, non-reg cell"
    | RP.Var(s, i, w)           -> error "var found"
    | RP.Slice(w,i,loc)         -> error "cannot handle slice"
    
and stmt = function
    | RP.Store(l,e,w)           -> conStore (loc l) (exp e) w
    | RP.Kill(loc)              -> error "cannot handle kill"
@

We classify an {\rtl} here and pass it to the appropriate rule in the
rule set. The encoding of special instructions is shared between the
code expander and a target description. See module \module{targets}.
The ``special'' instructions are identified by a false guard and capital
letters in a cell.

<<tail>>=  
and rtl (RP.Rtl es) = geffects es
and geffects = function
    | [] -> conNop ()
    | [g, s] -> guarded g s
    | (g, s) :: t -> conPar (guarded g s) (geffects t)
and guarded g s = match g with
| RP.Const(RP.Bool b) -> if b then stmt s else conNop()
| _ -> conGuarded (exp g) (stmt s)
@

The [[rtl]] function returns (the best) plan to rewrite a given {\rtl}.
When this plan is executed, it returns a monadic value that includes the
desired expanded instructionss.

<<tail>>=
let to_string (r: R.rtl) = 
    try
        let plan = rtl (Down.rtl r) in
        plan.inst.Camlburg.action ()
    with 
        | Camlburg.Uncovered -> 
            cat [ " # not an instruction: " ; RU.ToReadableString.rtl r]
        | Error(msg) ->
            ( List.iter prerr_endline
                [ msg
                ; RU.ToString.rtl r
                ]
            ; " # error in recognizer: " ^ msg (*assert false*)
            )

@                        
