% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Targets supported by the compiler}
% ------------------------------------------------------------------ 

This module is a central location holding all targets the compiler
supports.

<<targets.mli>>=
val dummy : Target2.t 
val sparc : Target2.t
val dummy_automaton : Rtl.aggregation -> Automaton2.spec
@

The targets are exported to Lua. When the following module is initalized
at program startup, the targets become global values and in the Lua
interpreter. 

\begin{quote}
    \begin{tabular}{ll}
        \bf O'Caml value & \bf Lua value \\
        \hline
        [[dummy]]        & [[Targets.dummy]]\\
        [[sparc]]        & [[Targets.sparc]]\\
    \end{tabular}
\end{quote}

<<targets.mli>>=
module MakeLib  (TargetV : Lua.Lib.TYPEVIEW with type 'a t = Target2.t)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a TargetV.combined 
@ 

In principle it would be good enough to export targets only to Lua.
However, the [[dummy]] target is used as model for the {\PAL} assembly
output and must be visible in {\ocaml}. 

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<targets.ml>>=
module R  = Rtl
module D  = Rtl.Convert (* Down *)
module U  = Rtl.Revert  (* Up *)
module RP = Rtl.Private
module S  = Space
module T  = Target2

<<target-independent utilities>>
@

We have one sub-module per target to keep the name space clean.


<<targets.ml>>=
module DummyTarget = struct 
    <<DummyTarget>>
end
let dummy = DummyTarget.target

module SparcTarget = struct
    <<SparcTarget>>
end   
let sparc = SparcTarget.target
@

All targets are exported as Lua values. The [[register_module]] function
creates a new name space [[Targets]] if it does not yet exist.

<<targets.ml>>=
module MakeLib  (TargetV : Lua.Lib.TYPEVIEW with type 'a t = Target2.t)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a TargetV.combined  = 
struct
    type 'a combined = 'a TargetV.combined
    module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
    struct
        let target = TargetV.makemap C.V.userdata C.V.projection
        let targets =
            [ "dummy",  target.C.V.embed dummy 
            ; "sparc",  target.C.V.embed SparcTarget.target
            ]
        let init g =
          C.register_module "Targets" targets g;
          Lua.Lib.StringList.empty
    end (*M*)
end 

@ 

% ------------------------------------------------------------------ 
\subsection{Target-independent Utilities}
% ------------------------------------------------------------------ 

A target description is a collection of lists and maps. The [[StrUtil]]
and [[CharUtil]] functions provide [[lookup]] and [[list2map]] to work
with them.

<<target-independent utilities>>=
module StrMap  = Map.Make(struct type t=string let compare=compare end)
module CharMap = Map.Make(struct type t=char   let compare=compare end)

module MapUtil (M: Map.S) = struct
    let lookup map key =
        try  M.find key map 
        with Not_found -> Impossible.impossible ("Target.lookup key not found")

    let list2map assoc =
        let add map (key,value) = M.add key value map in
        List.fold_left add M.empty assoc  
end

module StrUtil  = MapUtil(StrMap)
module CharUtil = MapUtil(CharMap) 
@

The [[assign]] function converts both registers to [[Rtl.loc]] values
and then uses the [[Rtl]] framework to create an assignment. Because
register allocation (and therefore spilling) happens after code
expansion, returned {\rtl}s must respect the machine invariant. This is
currently not the case! The spilling code will thus have to become
target specific.

<<target-independent utilities>>=
module Spill = struct
    let assign lookup ~src:(src_sp,_,src_w as src) 
                      ~dst:(dst_sp,_,dst_w as dst) =
        if src_w <> dst_w then
            invalid_arg 
                "Target2.assign source and destination width don't match"
        else
            let src_loc = Rtl.reg src  in
            let dst_loc = Rtl.reg dst  in
                Rtl.store dst_loc (Rtl.fetch src_loc src_w)  dst_w

    let spill lookup (sp,index,w as reg) loc =
        let w' = Rtlutil.Width.loc loc in
        if w <> w' then invalid_arg 
            (Printf.sprintf "Target2.spill size mismatch: %d <- %c(%d)" w' sp w)
        else
            let reg_loc = Rtl.reg reg in
            let rtl     = Rtl.store loc (Rtl.fetch reg_loc w) w in
                [rtl]

    let reload lookup (sp,index,width as reg) loc =
        if Rtlutil.Width.loc loc <> width then
            invalid_arg "Register.spill size mismatch"
        else
            let reg_loc = Rtl.reg reg  in
            let rtl     = Rtl.store reg_loc (Rtl.fetch loc width) width in
                [rtl]
end
@ 

% ------------------------------------------------------------------ 
\subsection{Dummy Target}
% ------------------------------------------------------------------ 

<<DummyTarget>>=
let memsize       = 8
let wordsize      = 32
let pointersize   = 32
let alignment     = 1
let const n width = Rtl.bits (Bits.U.of_int n width) width
let fpcond n      = Rtl.cell Rtl.none 'd' Rtl.Identity  2 (const n 2)
let reg n         = Rtl.cell Rtl.none 'r' Rtl.Identity 32 (const n 5)
let pc            = Rtl.cell Rtl.none 'c' Rtl.Identity 32 (const 0 1)
let mem addr      = Rtl.cell Rtl.none 'm' Rtl.LittleEndian 32 addr
let assign loc e  = Rtl.store loc e (Rtlutil.Width.exp e)       

(* THIS CODE SHOULD BE CHANGED TO USE Spaces.Standard32 *)
let spaces = 
    [     { S.space = 'r'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 5
          ; S.indexlimit  = None
          ; S.widths      = [32]
          ; S.classification = S.Reg
          ; S.doc         = "general-purpose registers"
          } 

    ;     { S.space = 'f'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 5
          ; S.indexlimit  = None
          ; S.widths      = [32]
          ; S.classification = S.Reg
          ; S.doc         = "floating-point registers"
          } 

(*
    ;     { S.space = 'g'
          ; S.cellwidth   = 8
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 5
          ; S.indexlimit  = None
          ; S.widths      = [8]
          ; S.classification = S.Reg
          ; S.doc         = "generail-purpose registers"
          } 
          *)

    ;     { S.space = 'd'
          ; S.cellwidth   = 2
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 1
          ; S.indexlimit  = Some 2
          ; S.widths      = [2]
          ; S.classification = S.Reg
          ; S.doc         = "floating-point condition and mode registers"
          } 

    ;     { S.space = 'm'
          ; S.cellwidth   = 8
          ; S.aggregation = Rtl.BigEndian
          ; S.indexwidth  = 32
          ; S.indexlimit  = None
          ; S.widths      = [8;16;32]
          ; S.classification = S.Mem
          ; S.doc         = "main memory"
          
          }
          
    ;     { S.space = 't'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 16
          ; S.indexlimit  = None
          ; S.widths      = [32]
          ; S.classification =
               S.Temp { S.stands_for = 'r'
                      ; S.index_ok   = (fun _ -> true)
                      ; S.set_doc    = "any register"
                      } 
          ; S.doc         = "general-purpose temporaries"
          }

    ;     { S.space = 'u'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 16
          ; S.indexlimit  = None
          ; S.widths      = [32; 64]
          ; S.classification =
               S.Temp { S.stands_for = 'f'
                      ; S.index_ok   = (fun _ -> true)
                      ; S.set_doc    = "fp register"
                      } 
          ; S.doc         = "floating-point temporaries"
          }

    ;     { S.space = 'v'
          ; S.cellwidth   = 8
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 16
          ; S.indexlimit  = None
          ; S.widths      = [8]
          ; S.classification =
               S.Temp { S.stands_for = 'g'
                      ; S.index_ok   = (fun _ -> true)
                      ; S.set_doc    = "any register"
                      } 
          ; S.doc         = "8-bit temporaries"
          }

    ;     { S.space = 'c'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 1
          ; S.indexlimit  = Some 2
          ; S.widths      = [32]
          ; S.classification = S.Fixed
          ; S.doc         = "control and status registers"
          } 

    ]     

(* this is total nonsense - it's just for toying around *)

let goto_embed e     = assign pc e
let goto_project rtl = match R.Convert.rtl rtl with
    | RP.Rtl([(_,RP.Store(loc,exp,width))]) -> R.Revert.exp exp
    | _                                     -> assert false


let goto =
    { T.embed   = goto_embed
    ; T.project = goto_project
    }

let cutto =
    { T.embed   = (fun (sp,newsp,newpc) -> 
                       let assign loc e  =
                           Rtl.store loc e (Rtlutil.Width.exp e) in
                       Rtl.par [assign sp newsp; assign pc newpc])
    ; T.project = (fun r -> match D.rtl r with
                  | RP.Rtl [ (_, RP.Store(sp, nsp, _))
                           ; (_, RP.Store(_ , npc, _))] ->
                       (U.loc sp, U.exp nsp, U.exp npc)
                  | _ -> Impossible.impossible "projected non-cutto")
    }

let branch_embed (e,addr) = R.guard e (assign pc addr)
let branch_project rtl  = match R.Convert.rtl rtl with
    | RP.Rtl([(e,RP.Store(loc,addr,width))]) -> ( R.Revert.exp e
                                                , R.Revert.exp addr
                                                )
    | _                                      -> assert false

let branch =
    { T.embed   = branch_embed
    ; T.project = branch_project
    }
@

Each target includes at least five automata that encapsulate important
target-specific resource allocation policies. In a calling convention
three automata had out location for paramter passing. The fourth
automaton controls how global variables in a {\PAL} program are assigned
to hardware registers, and a fifth automaton provides spill slots for
the register allocator.

Until the [[Automaton]] module provides constructor functions for these
automata, we use the class based approach that is in its place for now.

An [[Automaton.location]] captures a potentially complex location
returned by an automaton. In our case such a location is basically an
{\rtl} cell.

<<DummyTarget>>=
class loc (loc:Rtl.loc): Automaton2.location =
object
    val _loc   = loc
    
    method store expr width = Rtl.store _loc expr width 
    method fetch width      = Rtl.fetch _loc width
    method to_loc           = _loc
end
@

The [[simple]] automaton is a toy that we use for all purposes. All
location it hands out are in memory, except when a hardware register is
explicitly requested.

PLEASE EXPLAIN THE USE OF MUTABLE STATE HERE.  IF THE RESULT OF 
[[new simple']] IS AN [[Automaton2.spec]], WHY CAN'T EVERYTHING HERE
SHARE A SINGLE MUTABLE OBJECT?  AND IF THE OBJECT CAN'T SAFELY BE
SHARED BY ALL TARGETS, THEN HOW CAN IT SAFELY BE SHARED BY MULTIPLE
PROCEDURES IN A COMPILATION UNIT?

In response to above: I don't understand the question about sharing and
don't know what ``everything'' refers to. A specification
[[Automaton2.spec]] is a function that returns a (new) automaton when
provided with a an address for overflow parameters. The automaton itself
is mutable because it keeps track of the resources it has handed out.  A
[[new simple' byteorder]] is an [[Automaton2.spec]] value which is
immutable and can be shared. --CL

<<DummyTarget>>=
class simple' (byte_order) (base:Rtl.exp): Automaton2.automaton =
object (this)
    val mutable _block  = Block.mk base (*size*) 0 (*align*) 8  (* block *)
    val mutable _frozen = false
    
    method freeze () =
        let _ = _frozen <- true in _block  (* return block *)
    
    method private memloc addr w = 
        new loc (Rtl.cell Rtl.none 'm' byte_order w addr)
    
    method private hardware hint = match hint with 
    | "IEEE 754 rounding modes"         -> new loc (fpcond 0)
    | "IEEE 754 rounding mode"          -> new loc (fpcond 0)
    | "IEEE 754 comparison results"     -> new loc (fpcond 1)
    | r     -> Impossible.impossible ("unknown hardware register "^r) 
    
    method private slotaddress = (* base + v *)
        let add = Rtl.opr "add" [pointersize] in
        Rtl.app add [base; Rtl.late (Idgen.slot "slots") pointersize]
    
    method allocate width hint = 
        let ()      = assert (_frozen = false) in          
        match hint with 
        | Some x -> this#hardware x
        | None ->
            let ()      = assert (width mod memsize = 0) in
            let slot    = Block.mk this#slotaddress 
                                   (width / memsize) pointersize in
            ( _block <- Block.cathl slot _block 
            ; this#memloc (Block.base slot) width
            )
end
<<targets.ml>>=
let dummy_automaton order = new DummyTarget.simple' order
@

The [[cc]] value describes a calling convention. It is just a toy and
probably is not good for anything.

<<DummyTarget>>=
let cc =
    { T.sp              = reg 31
    ; T.return          = assign pc (R.fetch (mem (R.fetch (reg 31) 32)) 32)
    ; T.proc            = new simple' Rtl.BigEndian
    ; T.cont            = new simple' Rtl.BigEndian
    ; T.ret             = new simple' Rtl.BigEndian
    ; T.stack_slots     = new simple' Rtl.BigEndian
    ; T.allocatable     = List.concat 
    (*
          [ List.map (fun n -> ('r',n,32)) [0;1]
          ; List.map (fun n -> ('f',n,32)) [0;1]
          [ List.map (fun n -> ('r',n,32)) [0;1;2]
          ; List.map (fun n -> ('f',n,32)) [0;1;2]
          [ List.map (fun n -> ('r',n,32)) [0;1;2;3;4;5;6]
          ; List.map (fun n -> ('f',n,32)) [0;1;2;3;4;5;6]
     *)
          [ List.map (fun n -> ('r',n,32)) [0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15
                                           ;16;17;18;19;20;21;22;23]
          ; List.map (fun n -> ('f',n,32)) [0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15
                                           ;16;17;18;19;20;21;22;23]
                      (*
          [ List.map (fun n -> ('r',n,32)) [0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15
                                           ;16;17;18;19;20;21;22;23;24;25;26;27
                                           ;28;29;30;31]
          ; List.map (fun n -> ('f',n,32)) [0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15
                                           ;16;17;18;19;20;21;22;23;24;25;26;27
                                           ;28;29;30;31]
                     *)
                            (*
                            ; List.map (fun n -> ('g',n,8))  [1;2;3]
                            *)
                            ]
    }
 
@

Finally, this is the complete description of the [[Dummy]] target.

<<DummyTarget>>=
let target = 
    { T.name            = "dummy"
    ; T.byteorder       = Rtl.BigEndian
    ; T.wordsize        = 32
    ; T.pointersize     = 32
    ; T.vfp             = Vfp.mk 32
    ; T.alignment       = 1
    ; T.memsize         = 8
    ; T.float           = "ieee754"
    ; T.charset         = "latin1"
    ; T.globals         = new simple' Rtl.BigEndian
    ; T.goto            = goto
    ; T.jump            = goto
    ; T.cutto           = cutto
    ; T.call            = goto
    ; T.branch          = branch
    ; T.cc              = StrUtil.lookup (StrUtil.list2map [("C--",cc)])
    ; T.spaces          = spaces 
(*    ; T.assign          = Spill.assign *)
    ; T.spill           = Spill.spill
    ; T.reload          = Spill.reload
    ; T.data_section    = "data"
    }
@ 

% ------------------------------------------------------------------ 
\subsection{Sparc Target}
% ------------------------------------------------------------------ 

The target description of the Sparc is pretty similar to the one for the
Dummy above. There are probably some mistakes here.


<<SparcTarget>>=
let memsize       = 8
let wordsize      = 32
let pointersize   = 32

let spaces = 
    [     { S.space = 'r'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 5
          ; S.indexlimit  = None
          ; S.widths      = [1]
          ; S.classification = S.Reg
          ; S.doc         = "general-purpose registers"
          } 

    ;     { S.space = 'f'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 5
          ; S.indexlimit  = None
          ; S.widths      = [1]
          ; S.classification = S.Reg
          ; S.doc         = "floating-point registers"
          } 

    ;     { S.space = 'm'
          ; S.cellwidth   = 8
          ; S.aggregation = Rtl.BigEndian
          ; S.indexwidth  = 32
          ; S.indexlimit  = None
          ; S.widths      = [1;2;4]
          ; S.classification = S.Mem
          ; S.doc         = "main memory"
          
          }
          
    ;     { S.space = 't'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 16
          ; S.indexlimit  = None
          ; S.widths      = [1]
          ; S.classification =
               S.Temp { S.stands_for = 'r'
                      ; S.index_ok   = (fun _ -> true)
                      ; S.set_doc    = "any register"
                      } 
          ; S.doc         = "general-purpose temporaries"
          }

    ;     { S.space = 'u'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 16
          ; S.indexlimit  = None
          ; S.widths      = [1; 2]
          ; S.classification =
               S.Temp { S.stands_for = 'f'
                      ; S.index_ok   = (fun _ -> true)
                      ; S.set_doc    = "any register"
                      } 
          ; S.doc         = "floating-point temporaries"
          }

    ;     { S.space = 'i'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 3
          ; S.indexlimit  = Some 6
          ; S.widths      = [1]
          ; S.classification = S.Fixed
          ; S.doc         = "control and status registers"
          } 

    ]      
@
Here is our automaton for resource allocation. It now is similar to the
one for Dummy but will diverge from it once we become more realistic.

An [[Automaton.location]] captures a potentially complex location
returned by an automaton. In our case such a location is basically an
{\rtl} cell.

<<SparcTarget>>=
class loc (loc:Rtl.loc): Automaton2.location =
object
    val _loc   = loc
    
    method store expr width = Rtl.store _loc expr width 
    method fetch width      = Rtl.fetch _loc width
    method to_loc           = _loc
end
@

The [[simple]] automaton is a toy that we use for all purposes. All
location it hands out are in memory, except when a hardware register is
explicitly requested.

The automaton that works with our new Automaton and Block modules. This
will replace the automaton above.

<<SparcTarget>>=
class simple' (byte_order) (base:Rtl.exp): Automaton2.automaton =
object (this)
    val mutable _block  = Block.mk base (*size*) 0 (*align*) 8  (* block *)
    val mutable _frozen = false
    
    method freeze () =
        let _ = _frozen <- true in _block  (* return block *)
    
    method private memloc addr w = 
        new loc (Rtl.cell Rtl.none 'm' byte_order w addr)
    
    method private hardware hint = match hint with 
    | r     -> Impossible.impossible ("unknown hardware register "^r) 
    
    method private slotaddress = (* base + v *)
        let add = Rtl.opr "add" [pointersize] in
        Rtl.app add [base; Rtl.late (Idgen.slot "slots") pointersize]
    
    method allocate width hint = 
        let ()      = assert (_frozen = false)           
        and ()      = assert (width mod memsize = 0) in
        match hint with 
        | Some x -> this#hardware x
        | None ->
            let slot    = Block.mk this#slotaddress 
                                   (width / memsize) pointersize in
            ( _block <- Block.cathl slot _block 
            ; this#memloc (Block.base slot) width
            )
end
@


The following functions encode special {\rtl}s and must be recognized by
the code expander as such. It is not important that these {\rtl}s
represent real machine instructions. All special instructions have are
predicated with a value different from [[true]]. In addition, I am
encoding the meaning of the instruction into otherwise unused {\rtl}
spaces. This encoding is private between a target and its code expander.

<<SparcTarget>>=
let special sp guard exp =
    let const n width = Rtl.bits (Bits.U.of_int n width) width in
    let cell          = R.cell R.none sp R.Identity 32 (const 0 32) in
        R.guard guard (R.store cell exp 32)

let project rtl = match D.rtl rtl with
    | RP.Rtl([guard, RP.Store(_, exp, 32)]) -> 
        ( U.exp guard
        , U.exp exp
        )
    | _ -> assert false      
        
let false'      = R.bool false
let (>>) f g x  = f (g x)


let goto  =
    { T.embed   = special 'G' false' 
    ; T.project = snd >> project
    }

let jump =
    { T.embed   = special 'J' false' 
    ; T.project = snd >> project
    }

(* XXXXXXXXXXXX *)
let cutto = (* XXXXXXXXXXXX *)
    let const n width = Rtl.bits (Bits.U.of_int n width) width in
    let cell          = R.cell R.none 'T' R.Identity 32 (const 0 32) in
    { T.embed   =
        (fun (a,b,c) -> R.guard false' (R.store cell c 32))
    ; T.project =
        (fun _ -> (cell,const 0 32,const 0 32))
    }

let call =
    { T.embed   = special 'S' false' 
    ; T.project = snd >> project
    }

let branch =
    { T.embed   = (fun (x,y) -> special 'B' x y)
    ; T.project = project
    }

let sp = 
    let r14 = R.bits (Bits.U.of_int 14 5) 5 in
    R.cell R.none 'r' R.Identity 32 r14

let cc =
    { T.sp              = sp
    ; T.return          = special 'R' false' 
                            (R.bits (Bits.U.of_int 12345 32) 32)
    ; T.proc            = new simple' Rtl.BigEndian
    ; T.cont            = new simple' Rtl.BigEndian
    ; T.ret             = new simple' Rtl.BigEndian
    ; T.stack_slots     = new simple' Rtl.BigEndian
    ; T.allocatable     = List.concat 
                            [ List.map (fun n -> ('r',n,32)) [1;2;3;4;5;6;7;8;9;10;11;12;13;14;15
                                                             ;16;17;18;19;20;21;22;23;24;25;26;27
                                                             ;28;29;30;31;32]
                            ; List.map (fun n -> ('f',n,32)) [1;2;3;4;5;6;7;8;9;10;11;12;13;14;15
                                                             ;16;17;18;19;20;21;22;23;24;25;26;27
                                                             ;28;29;30;31;32]
                            ]
    }

let target = 
    { T.name            = "sparc"
    ; T.byteorder       = Rtl.BigEndian
    ; T.wordsize        = 32
    ; T.pointersize     = 32
    ; T.vfp             = Vfp.mk 32
    ; T.alignment       = 1
    ; T.memsize         = 8
    ; T.float           = "ieee754"
    ; T.charset         = "latin1"
    ; T.globals         = new simple' Rtl.BigEndian
    ; T.goto            = goto
    ; T.jump            = jump
    ; T.cutto           = cutto
    ; T.call            = call
    ; T.branch          = branch
    ; T.cc              = StrUtil.lookup (StrUtil.list2map [("C--",cc)])
    ; T.spaces          = spaces 
(*    ; T.assign          = Spill.assign *)
    ; T.spill           = Spill.spill
    ; T.reload          = Spill.reload
    ; T.data_section    = "data"
    }
@ 

