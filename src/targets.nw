% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Targets supported by the compiler}
% ------------------------------------------------------------------ 

\emph{This module will go away. We try to define each target in an
individual file.}


This module is a central location holding all targets the compiler
supports.

<<targets.mli>>=
val sparc : Target2.t
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<targets.ml>>=
module A  = Automaton2
module R  = Rtl
module D  = Rtl.Dn (* Down *)
module U  = Rtl.Up  (* Up *)
module RP = Rtl.Private
module S  = Space
module T  = Target2

<<target-independent utilities>>
@

We have one sub-module per target to keep the name space clean.


<<targets.ml>>=
module SparcTarget = struct
    <<SparcTarget>>
end   
let sparc = SparcTarget.target
@

% ------------------------------------------------------------------ 
\subsection{Target-independent Utilities}
% ------------------------------------------------------------------ 

A target description is a collection of lists and maps. The [[StrUtil]]
and [[CharUtil]] functions provide [[lookup]] and [[list2map]] to work
with them.

<<target-independent utilities>>=
module StrMap  = Map.Make(struct type t=string let compare=compare end)
module CharMap = Map.Make(struct type t=char   let compare=compare end)

module MapUtil (M: Map.S) = struct
    let lookup map key =
        try  M.find key map 
        with Not_found -> Impossible.impossible ("Target.lookup key not found")

    let list2map assoc =
        let add map (key,value) = M.add key value map in
        List.fold_left add M.empty assoc  
end

module StrUtil  = MapUtil(StrMap)
module CharUtil = MapUtil(CharMap) 
@

The [[assign]] function converts both registers to [[Rtl.loc]] values
and then uses the [[Rtl]] framework to create an assignment. Because
register allocation (and therefore spilling) happens after code
expansion, returned {\rtl}s must respect the machine invariant. This is
currently not the case! The spilling code will thus have to become
target specific.

<<target-independent utilities>>=
module Spill = struct
    let assign lookup ~src:(src_sp,_,src_w as src) 
                      ~dst:(dst_sp,_,dst_w as dst) =
        if src_w <> dst_w then
            invalid_arg 
                "Target2.assign source and destination width don't match"
        else
            let src_loc = Rtl.reg src  in
            let dst_loc = Rtl.reg dst  in
                Rtl.store dst_loc (Rtl.fetch src_loc src_w)  dst_w

    let spill lookup (sp,index,w as reg) loc =
        let w' = Rtlutil.Width.loc loc in
        if w <> w' then invalid_arg 
            (Printf.sprintf "Target2.spill size mismatch: %d <- %c(%d)" w' sp w)
        else
            let reg_loc = Rtl.reg reg in
            let rtl     = Rtl.store loc (Rtl.fetch reg_loc w) w in
                [rtl]

    let reload lookup (sp,index,width as reg) loc =
        if Rtlutil.Width.loc loc <> width then
            invalid_arg "Register.spill size mismatch"
        else
            let reg_loc = Rtl.reg reg  in
            let rtl     = Rtl.store reg_loc (Rtl.fetch loc width) width in
                [rtl]
end
@ 

% ------------------------------------------------------------------ 
\subsection{Sparc Target}
% ------------------------------------------------------------------ 

The target description of the Sparc is pretty similar to the one for the
Dummy above. There are probably some mistakes here.



<<SparcTarget>>=
let memsize       = 8
let wordsize      = 32
let pointersize   = 32
let const n width = Rtl.bits (Bits.U.of_int n width) width
let fpcond n      = Rtl.reg  ('d',n,2)

let spaces = 
    [     { S.space = 'r'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 5
          ; S.indexlimit  = None
          ; S.widths      = [1]
          ; S.classification = S.Reg
          ; S.doc         = "general-purpose registers"
          } 

    ;     { S.space = 'f'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 5
          ; S.indexlimit  = None
          ; S.widths      = [1]
          ; S.classification = S.Reg
          ; S.doc         = "floating-point registers"
          } 

    ;     { S.space = 'm'
          ; S.cellwidth   = 8
          ; S.aggregation = Rtl.BigEndian
          ; S.indexwidth  = 32
          ; S.indexlimit  = None
          ; S.widths      = [1;2;4]
          ; S.classification = S.Mem
          ; S.doc         = "main memory"
          
          }
          
    ;     { S.space = 't'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 16
          ; S.indexlimit  = None
          ; S.widths      = [1]
          ; S.classification =
               S.Temp { S.stands_for = 'r'
                      ; S.index_ok   = (fun _ -> true)
                      ; S.set_doc    = "any register"
                      } 
          ; S.doc         = "general-purpose temporaries"
          }

    ;     { S.space = 'u'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 16
          ; S.indexlimit  = None
          ; S.widths      = [1; 2]
          ; S.classification =
               S.Temp { S.stands_for = 'f'
                      ; S.index_ok   = (fun _ -> true)
                      ; S.set_doc    = "any register"
                      } 
          ; S.doc         = "floating-point temporaries"
          }

    ;     { S.space = 'd'
          ; S.cellwidth   = 2
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 1
          ; S.indexlimit  = Some 2
          ; S.widths      = [2]
          ; S.classification = S.Reg
          ; S.doc         = "floating-point condition and mode registers"
          } 

    ;     { S.space = 'i'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 3
          ; S.indexlimit  = Some 6
          ; S.widths      = [1]
          ; S.classification = S.Fixed
          ; S.doc         = "control and status registers"
          } 

    ]      
@

The following functions encode special {\rtl}s and must be recognized by
the code expander as such. It is not important that these {\rtl}s
represent real machine instructions. All special instructions have are
predicated with a value different from [[true]]. In addition, I am
encoding the meaning of the instruction into otherwise unused {\rtl}
spaces. This encoding is private between a target and its code expander.

<<SparcTarget>>=
let special sp guard exp =
    let const n width = Rtl.bits (Bits.U.of_int n width) width in
    let cell          = R.cell R.none sp R.Identity 32 (const 0 32) in
        R.guard guard (R.store cell exp 32)

let project rtl = match D.rtl rtl with
    | RP.Rtl([guard, RP.Store(_, exp, 32)]) -> 
        ( U.exp guard
        , U.exp exp
        )
    | _ -> assert false      
        
let false'      = R.bool false
let (>>) f g x  = f (g x)


let goto  =
    { T.embed   = special 'G' false' 
    ; T.project = snd >> project
    }

let jump =
    { T.embed   = special 'J' false' 
    ; T.project = snd >> project
    }

let call =
    { T.embed   = special 'S' false' 
    ; T.project = snd >> project
    }

let branch =
    { T.embed   = (fun (x,y) -> special 'B' x y)
    ; T.project = project
    }

let sp = 
    let r14 = R.bits (Bits.U.of_int 14 5) 5 in
    R.cell R.none 'r' R.Identity 32 r14


let t = (* for generic automata, will go away *)
    { Automaton2.Sample.byteorder = Rtl.BigEndian
    ; Automaton2.Sample.wordsize  = 32
    ; Automaton2.Sample.memsize   = 8
    ; Automaton2.Sample.pointersize = 32
    ; Automaton2.Sample.registers =
            [ "IEEE 754 rounding mode", Rtl.reg ('d',0,2)
            ]
    }
let cc =
    { T.sp              = sp
    ; T.return          = special 'R' false' 
                            (R.bits (Bits.U.of_int 12345 32) 32)
    ; T.proc            = Automaton2.Sample.stack t
    ; T.cont            = Automaton2.Sample.stack t
    ; T.ret             = Automaton2.Sample.stack t
    ; T.stack_slots     = Automaton2.Sample.stack t
    ; T.cutto           =
                 { T.embed   =
                     (fun _ -> Impossible.unimp "sparc cutto embedding")
                 ; T.project = 
                     (fun _ -> Impossible.unimp "sparc cutto projection")
                 }
                 (* i don't know how to get the pc?
                   (fun (newpc, newsp) ->
                     let assign loc e =
                       Rtl.store loc e (Rtlutil.Width.exp e) in
                       Rtl.par [assign sp newsp; assign pc newpc])
                            (fun r -> match downrtl r with
                                  | RP.Rtl [ (_, RP.Store(_, nsp, _))
                                           ; (_, RP.Store(_ , npc, _))] ->
                                    (upexp nsp, upexp npc)
                                  | _ -> Impossible.impossible "projected non-cutto")
                 *)
    ; T.allocatable     = List.concat 
                            [ List.map (fun n -> ('r',n,32)) [1;2;3;4;5;6;7;8;9;10;11;12;13;14;15
                                                             ;16;17;18;19;20;21;22;23;24;25;26;27
                                                             ;28;29;30;31;32]
                            ; List.map (fun n -> ('f',n,32)) [1;2;3;4;5;6;7;8;9;10;11;12;13;14;15
                                                             ;16;17;18;19;20;21;22;23;24;25;26;27
                                                             ;28;29;30;31;32]
                            ]
    }


let target = 
    { T.name            = "sparc"
    ; T.byteorder       = Rtl.BigEndian
    ; T.wordsize        = 32
    ; T.pointersize     = 32
    ; T.vfp             = Vfp.mk 32
    ; T.alignment       = 1
    ; T.memsize         = 8
    ; T.float           = "ieee754"
    ; T.charset         = "latin1"
    ; T.globals         = Automaton2.Sample.global t
    ; T.is_rounding_mode = (fun loc -> loc = fpcond 0)
    ; T.goto            = goto
    ; T.jump            = jump
    ; T.call            = call
    ; T.branch          = branch
    ; T.cc              = StrUtil.lookup (StrUtil.list2map [("C--",cc)])
    ; T.spaces          = spaces 
(*    ; T.assign          = Spill.assign *)
    ; T.spill           = Spill.spill
    ; T.reload          = Spill.reload
    ; T.data_section    = "data"
    }
@ 

