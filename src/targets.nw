% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ------------------------------------------------------------------ 
\section{Targets supported by the compiler}
% ------------------------------------------------------------------ 

This module is a central location holding all targets the compiler
supports.
<<targets.mli>>=
val dummy : Target2.t
module MakeLib  
      (TargetV : Lua.Lib.TYPEVIEW with type 'a t = Target2.t)
        : Lua.Lib.TYPEFUL with type 'a combined = 'a TargetV.combined 
@ 

% ------------------------------------------------------------------ 
\subsection{Utilities and abbreviations}
% ------------------------------------------------------------------ 

<<targets.ml>>=
module R = Rtl
module RP = Rtl.Private
module S = Space
module T = Target2

module StrMap  = Map.Make(struct type t=string let compare=compare end)
module CharMap = Map.Make(struct type t=char   let compare=compare end)

module MapUtil (M: Map.S) = struct
    let lookup map key =
        try  M.find key map 
        with Not_found -> Impossible.impossible ("Target.lookup key not found")

    let list2map assoc =
        let add map (key,value) = M.add key value map in
        List.fold_left add M.empty assoc  
end

module StrUtil  = MapUtil(StrMap)
module CharUtil = MapUtil(CharMap) 

type 'a map = 'a T.map =
    { embed:    ('a -> Rtl.rtl)
    ; project:  (Rtl.rtl -> 'a)
    } 

@ 


% ------------------------------------------------------------------ 
\subsection{Dummy Target}
% ------------------------------------------------------------------ 

\begin{center}
    \begin{tabular}{ll}
    \hline
    \multicolumn{2}{c}{Memory Space \emph{R}}\\
    \hline
    Cellwidth    & 32                    \\
    Byteorder    & indentity             \\
    Addresswidth & 5                     \\
    \hline
    Index        & Purpose               \\
    \hline
    0            & PC                    \\
    1            & SP                    \\
    2            & Return                \\
    \dots        & general purpose       \\
    \end{tabular}
\end{center}    


<<targets.ml>>=
let const n width = Rtl.bits (Bits.of_int n width) width
let reg n         = Rtl.cell Rtl.none 'r' Rtl.Identity 32 (const n 5)
let assign loc e  = Rtl.store loc e (Rtlutil.Width.exp e)       
    
(* this is total nonsense - it's just for toying around *)

let goto_embed e     = assign (reg 0) e
let goto_project rtl = match R.Convert.rtl rtl with
    | RP.Rtl([(_,RP.Store(loc,exp,width))]) -> R.Revert.exp exp
    | _                                     -> assert false


let goto =
    { embed   = goto_embed
    ; project = goto_project
    }

let branch_embed (e,addr) = R.guard e (assign (reg 0) addr)
let branch_project rtl  = match R.Convert.rtl rtl with
    | RP.Rtl([(e,RP.Store(loc,addr,width))]) -> ( R.Revert.exp e
                                                , R.Revert.exp addr
                                                )
    | _                                      -> assert false

let branch =
    { embed   = branch_embed
    ; project = branch_project
    }


let cc =
    { T.sp      = reg 1
    ; T.return  = assign (reg 2) (R.fetch (reg 1) 32)
    ; T.proc    = Automaton.dummy
    ; T.cont    = Automaton.dummy
    ; T.ret     = Automaton.dummy
    }


let spaces = 
    [     { S.space = 'r'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 5
          ; S.indexlimit  = None
          ; S.aggsize     = [1]
          ; S.classification = S.Reg
          ; S.doc         = "hardware register"
          } 

    ;     { S.space = 'm'
          ; S.cellwidth   = Dummy.wordsize
          ; S.aggregation = Dummy.byteorder 
          ; S.indexwidth  = Dummy.pointersize
          ; S.indexlimit  = None
          ; S.aggsize     = [1;2;4]
          ; S.classification = S.Mem
          ; S.doc         = "main memory"
          
          }
          
    ;     { S.space = 't'
          ; S.cellwidth   = 32
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 16
          ; S.indexlimit  = None
          ; S.aggsize     = [1]
          ; S.classification = S.Reg
          ; S.doc         = "32 bit temporaries"
          }
          
    ;     { S.space = 'u'
          ; S.cellwidth   = 16
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 16
          ; S.indexlimit  = None
          ; S.aggsize     = [1]
          ; S.classification = S.Reg
          ; S.doc         = "16 bit temporaries"
          }
          
    ;     { S.space = 'v'
          ; S.cellwidth   = 8
          ; S.aggregation = Rtl.Identity
          ; S.indexwidth  = 16
          ; S.indexlimit  = None
          ; S.aggsize     = [1]
          ; S.classification = S.Reg
          ; S.doc         = "8 bit temporaries"
          }

    ]      
    

let tmp_counter = ref 0     

let new_tmp (sp,index,width) =
    incr tmp_counter;
    match width with
    | 8  -> ('v',!tmp_counter,width)
    | 16 -> ('u',!tmp_counter,width)
    | 32 -> ('t',!tmp_counter,width)
    | _  -> invalid_arg "unsupported register width in target2.nw"
@

The [[assign]] function converts both registers to [[Rtl.loc]] values and
then uses the [[Rtl]] framework to create an assignment. Returned
{\rtl}s must respect the machine invariant. This is currently not the
case!   

% XXX

<<targets.ml>>=
let assign lookup ~src:(src_sp,_,src_w as src) ~dst:(dst_sp,_,dst_w as dst) =
    if src_w <> dst_w then
        invalid_arg "Target2.assign source and destination width don't match"
    else
        let src_loc = Register.to_loc lookup src  in
        let dst_loc = Register.to_loc lookup dst  in
            Rtl.store dst_loc (Rtl.fetch src_loc src_w)  dst_w

let spill lookup ~reg:(sp,index,width as reg) ~loc =
    if Rtlutil.Width.loc loc <> width then
        invalid_arg "Target2.spill size mismatch"
    else
        let reg_loc = Register.to_loc lookup reg in
        let rtl     = Rtl.store loc (Rtl.fetch reg_loc width) width in
            [rtl]

let reload lookup ~reg:(sp,index,width as reg) ~loc =
    if Rtlutil.Width.loc loc <> width then
        invalid_arg "Register.spill size mismatch"
    else
        let reg_loc = Register.to_loc lookup reg  in
        let rtl     = Rtl.store reg_loc (Rtl.fetch loc width) width in
            [rtl]
    
let dummy = 
    { T.byteorder       = Dummy.byteorder         
    ; T.wordsize        = Dummy.wordsize
    ; T.pointersize     = Dummy.pointersize
    ; T.memsize         = Dummy.memsize
    ; T.float           = Dummy.float
    ; T.charset         = Dummy.charset
    ; T.globals         = Automaton.dummy
    ; T.register        = StrUtil.lookup StrMap.empty (* no registers *)
    ; T.goto            = goto
    ; T.jump            = goto
    ; T.cutto           = goto
    ; T.call            = goto
    ; T.branch          = branch
    ; T.cc              = StrUtil.lookup (StrUtil.list2map [("C--",cc)])
    ; T.fits            = (fun sp (sp',index,width) -> sp = sp')
    ; T.is_tmp          = (function 't' | 'u' | 'v' -> true | _ -> false)
    ; T.allocatable     = List.map (fun n -> ('r',n,5)) [3;4;5;6;7;8;9;10]
    ; T.spaces          = spaces 
    ; T.mk_tmp          = new_tmp 
    ; T.assign          = assign
    ; T.spill           = spill
    ; T.reload          = reload
    ; T.data_section    = "data"
    ; T.stack_slots     = Automaton.dummy
    }

@ 
Here's the Lua support for targets.
<<targets.ml>>=
module MakeLib  
      (TargetV : Lua.Lib.TYPEVIEW with type 'a t = Target2.t)
        : Lua.Lib.TYPEFUL with type 'a combined = 'a TargetV.combined  =
  struct
    type 'a combined = 'a TargetV.combined
    module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
      struct
        let target = TargetV.makemap C.V.userdata C.V.projection
        let targets =
          [ "dummy",  target.C.V.embed dummy 
          ]
        let init = C.register_module "Driver" targets
      end (*M*)
  end (*MakeLib*)

