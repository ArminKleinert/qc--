% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{Register Allocation}
% ------------------------------------------------------------------ 

The nodes of a control-flow graph (\cfg) initially contain temporary
registers and hardware registers.  For translation to machine
instructions, the temporary registers must be replaced by hardware
registers.  The register allocation process re-writes a control flow
graph such that nodes only use hardware registers.

Liveness analysis provides the accurate lifetime of each register. 
The register allocator then tries to map temporary registers to
hardware registers such that their lifetimes do not interfere.  If the
number of available hardware registers is too small to map temporary
registers, the register allocator runs out of registers.  The solution is
to store some temporaries in memory and re-load them to  hardware
registers only when they are needed; this is called \emph{spilling}.

The register allocator is a linear-scan allocator, basically modeled
after Traub et al.~\cite{traub:98:pldi} but without lazy spilling. 
It turned out that the simpler linear-scan register allocator by
Poletto \cite{poletto:99:toplas} can not handle pre-assigned hardware
registers as they are required by calling conventions.

% ------------------------------------------------------------------ 
\subsection{Overview}
% ------------------------------------------------------------------ 

Linear-scan register allocation works assumes a procedure is a linear
sequence of control-flow nodes, which represent instructions.  Such an
order can be easily obtained by enumerating the nodes in {\cfg}---of
course, many possible enumerations exist.  Liveness analysis
determines which registers, temporaries and hardware registers, are
live on any control-flow edge.  Each node is marked with the registers
that are live on its incoming edges.  These registers are said to be
\emph{live before} that node.  Linear Register-allocation needs a more
global perspective on liveness and computes a global map that
associates with every register the set of nodes at which the register
is \emph{live before}.  This situation is shown in Figure
\ref{fig:linscan:overview}:  from the linearized flow graph in (1) a
map in (2) is computed that shows at which regions the temporaries
$t_0$, $t_1$ and the hardware register $r_0$ are live.  Typically most
data lives in temporaries and only very few hardware registers are
used, typically for parameter passing.  

\begin{figure}[bh]
\centerline{\includegraphics[width=\hsize]{../figures/linscan-1}}
\caption{\label{fig:linscan:overview} Register allocation assigns
temporaries to hardware registers.}
\end{figure}

The aim of the register-allocator is to place every temporary into a
hardware register.  The allocator in this module implements basically
policy the policy described by Poletto \cite{poletto:99:toplas}:  it
scans the procedure in linear order and tries to place temporaries
that are live at the node at hand.  In Figure
\ref{fig:linscan:overview} the first live temporary is $t_0$.  The
policy described by Poletto mandates that the \emph{bounding box},
highlighted as a dotted rectangle, fits into the chose hardware
register.  This is the case in situation (3) for $r_0$ and thus $t_0$
is placed there.  Now every instruction in the {\cfg} that uses $t_0$
is re-written to use $r_0$ instead. 

Continuing scanning, the register allocator finds $t_1$.  However, the
bounding box of its lifetime collides with the lifetime of $r_0$ and
thus $r_0$ can not hold $t_1$.  Assuming that no other hardware
register is available, the register allocator decides to spill
temporary $t_1$.  This breaks $t_1$ into smaller intervals \emph{and}
creates new temporaries $t_2$ and $t_3$ for each usage of $t_1$, as
shown in Figure \ref{fig:linscan:overview} (5).  After a new round of
liveness analysis and and scanning $t_1$, $t_2$, and $t_3$ can be
assigned to $r_0$ and register allocation is complete. 
 

\begin{figure}[htb]
\centerline{\includegraphics[width=\hsize]{../figures/linscan-2}}
\caption{\label{fig:linscan:spilling} Spilling $x$.}
\end{figure}

Spilling deserves a closer look because it requires that new nodes are
added to a control-flow graph.  Figure \ref{fig:linscan:spilling}
shows a situation where a register $x$ is spilled in sequence of
nodes, called the spill region.  Outside the region $x$ is left
untouched, inside the region the value of $x$ is held in a memory
location, typically on the run-time stack.  Therefore on every edge
that enters or leaves the region \emph{and} on which $x$ is live nodes
must be inserted that transfer $x$ to or from memory.  These nodes are
depicted as grey nodes on the border of the rectangle that marks the
spill region. 

For every use of the spilled register inside the spill-region $x$ must
be re-loaded from memory and re-written, if it is live after the use. 
The corresponding nodes are the two grey nodes inside the spill
region.  However, $x$ is not re-loaded into $x$ but into a new
temporary ($z$) for every use inside the spill region.  This creates a
short-lived temporaries which can hopefully easyly assigned to
hardware registers.

\begin{quote}\it
The register allocator is quite simple and room for improvements
includes:

\begin{itemize}
\item Re-writing the nodes of a {\cfg} to reflect assignments can be
      delayed until spilling or register allocation is completed. 
       
\item The requirement that the bounding-box of a temporary's lifetime
      must not interfere with a hardware register's lifetime can probably
      be dropped. 
\end{itemize}
\end{quote}

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Linear-scan register allocation requires a linear representation of a
procedure.  This is provided by numbering nodes in the control-flow
graph {\cfg}.  Of course, any change to the structure of the {\cfg}
destroys a numbering.  This happens when code for spilling is inserted
into a {\cfg}.

Module type [[S]] summarizes the functionality we implement and export
for clients.  

<<exported module types>>=
module type G = sig
    include Cfg3.S

    val get_live: node -> locs          (* access to live sets *)
    val set_live: node -> locs -> unit
end

<<linscan.mli>>=
<<exported module types>>
module Make (A: Args) (G: G): sig
    val linscan: G.t -> Target2.t -> unit
end
@


% ------------------------------------------------------------------ 
\subsubsection{Things we want to get rid of}
% ------------------------------------------------------------------ 

The [[Arg]] module summarizes the functionality that we need from the
environment.  Since it is just a type, we can put here whatever we
want without having to provide an implementation.  Ultimately, we like
to implement everything that is provided by [[Arg]] and get rid of it.

<<exported module types>>=
module type Args = sig
    (* 
     * for spilling
     *)
    val mkTmp:      Rtl.loc -> Register.t
        (* create a new tmp for a value currently held by loc *)
    val spill:      dst:Rtl.loc    -> src:Register.t -> Rtl.rtl list
    val reload:     dst:Register.t -> src:Rtl.loc    -> Rtl.rtl list
        (* create an assignment rtl that transfers a value from src to dst.
         * The result types must become Rtl.rtl list because they have to
         * respect the machine invariant.
        *)
    val mkMem:      Register.t -> Rtl.loc
        (* create a new spill slot for a register. Incomplete - will 
           use Area.builder that maintains stack slots *)
end
@


% ------------------------------------------------------------------ 
\subsection{Construction of Register Lifetimes}
% ------------------------------------------------------------------ 

Liveness analysis (module \module{live}) annotates each node in the
control-flow graph with the set of registers live \emph{before} that
node.  From this we have to construct a global view that associates a
variable with its lifetime.  A lifetime is a set of nodes where a
register is live.  To make things easier, lifetimes are represented as
sets of intervals, where an interval is a sequence of consecutive
nodes with respect to the node numbering.  The first steps are
therefore to establish a numbering and to construct the lifetime of
each register.  The latter requires to walk over the control-flow
graph and recognize the opening and closing of intervals where a
particular variable is live.  Liveness intervals are then joined to
form \emph{lifetime} values.

Nodes in a {\cfg} are numbered with integers, called \emph{points}
here.  Points mark the opening and closing of liveness intervals. 

<<linscan.ml>>=
<<exported module types>>

module Make (A: Args) (G: G) = struct

    module P = struct
        type t = int
        let compare = compare
        let zero = 0 
    end
    
    module I        = Interval.Make(P)
    module LT       = Lifetime.Make(I)
    module LI       = Live.Make(G)
    module RM       = Register.Map
    module RS       = Register.Set
    module T        = Target2
 
    type lifetimes  = LT.t RM.t  (* lt *)  (* map from register to its lifetimes *)
    type loc        = Register.t    
 
    <<compute lifetimes>>
    
    let lookup table x = RM.find x table       (* lookup lifetime *)

    <<find tmp>>
    <<find reg>>
    <<find spillee>>
    
    <<replace>> 
    <<alloc>> 
    <<linscan>>   
    <<update>>        
    <<spill>>
end
@


To detect the opening and closing of liveness intervals the algorithm
compares the live-sets of two adjacent nodes $n_i$ and $n_{i+1}$. The
index $i$ is the point associated with a node $n$.

\begin{eqnarray*}
    \mathit{open}  &=& \mathit{live}(n_{i+1})\setminus \mathit{live}(n_i)\\ 
    \mathit{close} &=& \mathit{live}(n_{i})  \setminus \mathit{live}(n_{i+1})
\end{eqnarray*}

The registers in the $\mathit{open}$ set just became live and thus
each opens a live interval $(i+1,\dots)$; conversely, all registers in
the $\mathit{close}$ set close their previously opened interval. 
Because lifetime intervals are open on the right hand side (cf.~module
\module{lifetime}), the interval to be closed is $(\dots,i+1)$.  Once
an interval is closed, it can be added to the lifetime of the
respective variable.

The lifetimes for a control-flow graph are stored in a map that
associates registers with their lifetime.  An additional map holds the
opening point for registers that are currently live and have a not yet
closed their liveness interval.  In the functions traversing the
control-flow graph they are paired together as a value [[(op,lt)]].

The [[open_intv r p state]] function records the opening of an
interval for register [[t]] in the [[state]].  Dual to that,
[[close_intv]] closes a previously opened interval by removing the
register from [[op]] and adding a new interval to its lifetime in
[[lt]]. 

<<compute lifetimes>>=
type op    = P.t RM.t   (* map from register to opening point *)
type lt    = LT.t RM.t  (* map from register to lifetime      *)
type state = op * lt   
 
let open_intv  point (op,lt:state) reg = (Register.Map.add reg point op, lt)

let close_intv point (op,lt:state) reg = 
    let x = try Register.Map.find reg op with Not_found -> assert false in
    let y = point in
    let i = I.mk x y in
    let l = try Register.Map.find reg lt with Not_found -> LT.empty in
        ( Register.Map.remove reg op
        , Register.Map.add reg (LT.union (LT.mk i) l) lt
        ) 
@

Given a list of registers that open or close an interval we must fold
this list such that all registers in the list update the current
state. The state captures the lifetimes computed so far, plus the
currently open intervals.

<<compute lifetimes>>=
let open_regs  point regs state = List.fold_left (open_intv point)  state regs
let close_regs point regs state = List.fold_left (close_intv point) state regs
@

The [[lifetimes]] function computes a map that associates a register
with its lifetime.  The the lifetimes are inferred from the live sets
that are part of the control-flow graph.  The initial map [[lt]] is
constructed from the list of free registers provided by the client. 
After the last node of the control-flow graph is processed, all still
open intervals must be closed. 

<<compute lifetimes>>=
let lifetimes cfg registers =
    let lt          = List.fold_left (fun map r -> RM.add r LT.empty map) 
                                     RM.empty registers            in
    let initial     = (RM.empty, lt)                               in
    let domain map  = RM.fold (fun key _ list -> key::list) map [] in
    let scan node (oldset, state) =
        let point   = G.number node                                in
        let set     = G.get_live node                              in
        let opening = RS.diff set oldset                           in
        let closing = RS.diff oldset set                           in
        let state   = open_regs  point (RS.elements opening) state in
        let state   = close_regs point (RS.elements closing) state in
                      (set, state)                                 in
    let first       = G.number (G.first cfg)                       in
    let last        = G.number (G.last cfg)                        in
    let (set,(op,lt)) = G.scan_fwd cfg first last scan (RS.empty, initial) in
                      (* close all open intervals after the last node *)
    let     (_ ,lt) = close_regs (last+1) (domain op) (op,lt)      in
        lt
@

\begin{quote}\it
    I have to verify that the above code calculates the correct
    intervals with respect to the open interval semantics for lifetime
    intervals. --CL
\end{quote}


% ------------------------------------------------------------------ 
\subsection{Register Allocation Implementation}
% ------------------------------------------------------------------ 

The implementation must provide all the module types declared in the
interface.  The heart of the implementation is the functor [[Make]]
with code to

\begin{enumerate}
\item find a temporary in a node that needs to be placed into a register,
\item find a hardware register to accommodate a temporary,
\item find a register to spill (if we are stuck),
\item allocate registers for an entire {\cfg}, using the building
      blocks from above,
\item and to spill a register in a part of a {\cfg}.
\end{enumerate}

The linear-scan register allocator [[linscan]] visits all nodes of a
{\cfg} in a linear order and [[alloc]]'ates hardware register for their
temporaries.  The [[alloc]] function receives two continuations,
[[next_node]] and [[spill]].  It calls the latter, if no hardware register
can be found for a temporary.  Because spilling mutates the structure
of a {\cfg}, register allocation starts over after spilling.

\begin{quote}\it
    The [[lifetimes]] function must be supplied with a map that
    contains all hardware registers that are available for register
    allocation, not the [[empty]] set. --CL
\end{quote}

<<linscan>>=
let rec linscan cfg target =
    let _          = LI.liveness cfg     in
    let _          = G.gm_enumerate cfg  in
    let rec next_node lifetimes node = match node with 
        | None      -> ()
        | Some node -> alloc target node lifetimes next_node spill
    in
        next_node (lifetimes cfg target.T.allocatable) (Some (G.first cfg))
@
<<alloc>>=
let alloc target node lifetimes next_node spill =
    let rec next_tmp lifetimes = match find_tmp target node with
        | None     -> next_node lifetimes (G.next node)
        | Some tmp -> replace_tmp target node tmp lifetimes next_tmp spill      
    in
        next_tmp lifetimes 
@

The [[alloc]] function loops over all temporaries of a given node and
tries to replace each using [[replace_tmp]].  The [[replace_tmp]]
function again receives two continuation for the [[success]] and
[[spill]] cases.

The functions [[alloc]] and [[replace_tmp]] together implement an
algorithm of complexity $O(n^2)$, where $n$ is the number of nodes in
the {\cfg}:  as soon a temporary can can be placed into a hardware
register, the entire {\cfg} is updated, which affects $n$ nodes. 
Potentially this happens at every node during the linear scan and
hence we have an $O(n^2)$ complexity.  The obvious improvement is to
collect all changes and to apply them in a single run over the {\cfg}.

The real work is done in [[replace_tmp]].  For a given temporary
[[tmp]] a register [[r]] must by found by [[find_reg]].  If this
succeeds, the lifetime of [[tmp]] is joined with the register's
livetime, and all occurrences of [[tmp]] substituted by [[r]] in the
\emph{entire} {\cfg}. However, if no [[r]] can be found, we must spill:
[[find_spillee]] finds a candidate to spill and passes it to the
[[spill]] continuation.
  

<<replace>>=
let replace tmp reg      = fun t -> if t = tmp then reg else t

let replace_tmp target node tmp lifetimes next_tmp spill =
  let iter cfg f = G.fold_fwd cfg (fun node () -> G.set_rtl node f) () in
  let lifetime   = lookup lifetimes                                    in
  let cfg         = G.cfg node                                         in
  match find_reg target lifetimes tmp with
  | Some r -> (* successfully found a hardware register r *)
      let lifetimes = RM.add r (LT.union (lifetime r) (lifetime tmp))
                               lifetimes                               in
      let lifetimes = RM.remove tmp lifetimes                          in
      let ()        = iter cfg (Rtlutil.Subst.reg (replace tmp r))     in
          next_tmp lifetimes
  | None -> (* out of register - must spill *)
      let spillee, interval = find_spillee lifetimes tmp node          in
      let mem               = A.mkMem spillee                          in
          spill target cfg spillee mem interval
@

% ------------------------------------------------------------------ 
\subsection{Policies}
% ------------------------------------------------------------------ 

The [[linscan]] register allocator depends on a number of policies to
find temporaries and the hardware registers that replace them.  These
are described below and can be changed easily.

% ------------------------------------------------------------------ 
\subsubsection{Finding a Temporary}
% ------------------------------------------------------------------ 

The linear scan allocator replaces all temporaries at a given node by
hardware registers. The [[find_tmp]] function implements the policy to
select a temporary to be placed.

The [[find_tmp]] function returns a temporary used in [[node]] that
should be replaced by a hardware register. [[None]] is returned, if no
such register can be found.

Our implementation is simple and returns the first temporary it
finds. The [[read_write_lists]] functions returns all registers read
or written by an {\rtl} and thus we have to look for temporaries
explicitly.

<<find tmp>>=
let find_tmp target node = 
    let uses space index width = function
        | None when target.T.is_tmp space -> Some (space, index, width)
        | x                               -> x 
    in
        Rtlutil.read_write_lists uses uses (G.rtl node) None    
@       

\begin{quote}\it
    An alternative design would be to return a sorted list of all
    temporaries that need to be replaced.  Temporaries at the head of the
    list should be replaced first.  However, if we re-write all nodes
    in every allocation step, including the node at hand, the list may
    contain some temporaries no longer used by that node.  --CL
\end{quote}

% ------------------------------------------------------------------ 
\subsubsection{Finding a Hardware-Register}
% ------------------------------------------------------------------ 

After a temporary was selected to be placed into a hardware register,
an appropriate hardware register must be found.  The [[first_fit]]
function searches the domain of [[lifetimes]] to find a (hardware)
register that can hold temporary [[t]].  It returns the \emph{first}
register [[r]], that respects all of the following conditions, or
[[None]] otherwise.

\begin{enumerate}
\item The register [[r]] can hold the same values that [[t]] can hold. 
      This is decided using the target-specific [[fits]] function.
\item The bounding box of the lifetime of [[t]] does not overlap the 
      lifetimes of [[r]].      
\end{enumerate}

<<find reg>>=
let first_fit target lifetimes t =
    let fits' (sp,_,_ as t) r = 
        target.T.fits sp r &&
        not (LT.overlaps (LT.bbox (lookup lifetimes t)) 
                                (lookup lifetimes r))
    in
    let check r lt = function
        | None   when fits' t r -> Some r       
        | x (* otherwise *)     -> x      
    in
        RM.fold check lifetimes None

let find_reg = first_fit        (* first_fit is a possible find_reg impl *)
@


% ------------------------------------------------------------------ 
\subsubsection{Finding a Spillee}
% ------------------------------------------------------------------ 

When no register can be found to hold register [[tmp]], we have to
spill a register which can be either a hardware register, or a
temporary.  The [[find_spillee]] function receives the [[lifetimes]]
map, the register [[tmp]] that we could not find a register for, and
the [[node]] under consideration in the linear scan.  The function
returns a register to spill and a region in which the spillee is
spilled to memory.

For finding a spillee, we use the policy described by
\cite{poletto:99:toplas}:  consider the temporary that could not be
placed and all hardware registers currently in use and spill the one
that is used furthest\footnote{with respect to the node numbering} in
the program.  This means, we look at the bounding boxes of these
registers and spill the one that ends last.

Registers currently in use, or \emph{active}, are those whose
lifetime's bounding box overlaps with the current node.  This is a
superset of all nodes used by the current node.  The function
[[longest_active]] computes the node/lifetime pair that is used
longest in the program.  This is our spill candidate and we want to
spill it from the current node up to the end of the procedure.

<<find spillee>>=
let active point lifetimes =
    let here = I.mk point (point+1) in
    let find = fun loc lt active ->  
        if LT.overlaps here lt then (loc,lt) :: active else active
    in
        RM.fold find lifetimes []

<<longest active type>>=
G.node -> loc -> lifetimes -> loc * LT.t
<<find spillee>>=
let longest_active: <<longest active type>> = fun node tmp lifetimes ->
    let here   = G.number node        in
    let active = active here lifetimes  in
    let max (loc1,lt1 as x) (loc2,lt2 as y) = 
        if I.ends_after (LT.bbox lt1) (LT.bbox lt2) then x else y 
    in
        List.fold_left max (tmp,lookup lifetimes tmp) active

<<find spillee type>>= 
lifetimes -> loc -> G.node -> loc * I.t 
<<find spillee>>=
let find_spillee: <<find spillee type>> = fun lifetimes tmp node ->
    let cfg      = G.cfg node                     in
    let last     = G.number (G.last cfg)       in
    let loc,_    = longest_active node tmp lifetimes in
    let interval = I.mk (G.number node) (last+1)  in
        loc, interval
@

% ------------------------------------------------------------------ 
\subsection{Spilling Design}
% ------------------------------------------------------------------ 

This is intended to be a very simple specification of spilling, which
may be replaced by a more elaborate version.

We assume that we have a control-flow graph and that we want to spill
a register or temporary in a given region of the flow graph.  We write
[[member region n]] to indicate that a node~[[n]] lies in the region
of interest.  We contemplate an implementation in which the nodes of
the control-flow graph are placed in linear order, and in which
regions are intervals, but these assumptions are not necessary to this
specification.

We assume that we can find control-flow successors and predecessors
with functions [[succ]] and [[pred]].

The new graph for [[spill r region m g]] is computed as follows:

\begin{quote}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
for each node [[n]] in [[g]] such that [[member region n]] do\\
\> choose a fresh temporary [[t]]\\
\> for each node [[p]] in [[pred n]] such that \\ 
\>\> [[not (member region p)]] and [[r]] is live before [[n]] do\\
\>\> insert [[m := r]] on the edge from [[p]] to [[n]]\\
\> if [[n]] reads [[r]], insert [[t := m]] before [[n]]\\
\> if [[n]] writes [[r]], insert [[m := t]] after [[n]]\\
\> substitute [[t]] for [[r]] in [[n]]\\
\> for each node [[s]] in [[succ n]] such that  \\ 
\>\> [[not (member region p)]] and [[r]] is live before [[s]] do\\
\>\> insert [[r := m]] on the edge from [[n]] to [[s]]\\
\end{tabbing}
\end{quote}

It would be highly desirable to be able to separate the liveness tests
here, so for example we could always insert [[r := m]] or [[m := r]]
on edges that cross region boundaries, and then remove the unnecessary
instructions with a post-pass.

% ------------------------------------------------------------------ 
\subsection{Spilling Implementation}
% ------------------------------------------------------------------ 

The spiller walks over a region [[interval]] of nodes and updates it
such that the [[spillee]] is help in memory [[mem]] most of the time. 
When the spillee is used, it is re-loaded into a temporary.

<<spill>>=
and spill target cfg spillee mem interval = 
    let first = I.left  interval in
    let last  = I.right interval in 
        ( G.scan_fwd cfg first last (fun n () -> update interval spillee mem n) ()
        ; linscan cfg target (* start over *)
        )
@

The [[reads_writes]] function checks whether a location [[loc]] is
read or written by an {\rtl}.  It returns a pair $(r,w)$ of [[bool]]
values.  The first component $r$ is true, iff [[loc]] is read by
[[rtl]], the second $w$, iff [[loc]] is written by [[rtl]], and false
otherwise.

<<update>>=
and reads_writes rtl loc =
    let reads  sp index width (r,w) = (r || loc = (sp,index,width), w) in
    let writes sp index width (r,w) = (r, w || loc = (sp,index,width)) in
        Rtlutil.read_write_lists reads writes rtl (false,false)
@

The [[extern]] function returns all nodes from a list of nodes that do
not belong to an [[interval]]. 

<<update>>=
and extern interval = 
    List.filter (fun n -> not (I.member (G.number n) interval)) 
@

Edges entering and leaving the spilling interval must be modified to
include assignment nodes:  outside the interval the [[spillee]] holds
a value, inside the interval [[mem]].  Incoming edges therefore must
spill the [[spillee]] to [[mem]], outgoing edges reload [[mem]] to
[[spillee]].  The following two functions [[upd_*]] functions update
edges for [[node]]. 

<<update>>=
and upd_incoming interval spillee mem node =
    let pred  = extern interval (G.pred node) in
    let spill = A.spill mem spillee          in
        List.iter (fun n -> G.gm_insert_assign_between spill n node) pred

and upd_outgoing interval spillee mem node = 
    let succ    = extern interval (G.succ node) in
    let reload  = A.reload spillee mem          in
        List.iter (fun n -> G.gm_insert_assign_between reload node n) succ
@

The heart of the spiller is [[update]] that is applied to every
[[node]] in an interval that undergoes spilling.  If [[node]] reads or
writes the [[spillee]], it must be updated such that it uses a new
temporary [[tmp]] instead.  Before and after the node [[tmp]] must be
read from or written to memory [[mem]] where the value of the spillee
is held inside the [[interval]].  Edges entering or leaving the
interval must be also updated such that the spillee's value is written
to and read from [[mem]]. 
    
<<update>>=
and update interval spillee mem node = 
    upd_incoming interval spillee mem node ;    
    let reads, writes = reads_writes (G.rtl node) spillee in
        if reads || writes then 
            ( let tmp   = A.mkTmp mem in
              let subst = fun x -> if x = spillee then tmp else x in 
              ( if reads  then 
                    (G.gm_insert_assign_before (A.reload tmp mem) node)
              ; if writes then 
                    (G.gm_insert_assign_after  (A.spill  mem tmp) node)
              ; G.set_rtl node (Rtlutil.Subst.reg subst)
              )
            );
    upd_outgoing interval spillee mem node       
@

\begin{quote}\it
    Spilling hardware registers is not save: if [[spillee]] is a
    hardware register, it is re-loaded into a new temporary that
    substitutes the hardware register in nodes. However, the hardware
    register might the there because a calling convention demands it.
    --CL
\end{quote}
