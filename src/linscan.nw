% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{Register Allocation}
% ------------------------------------------------------------------ 

The nodes of a control-flow graph (\cfg) initially contain temporary
registers and hardware registers.  For translation to machine
instructions, the temporary registers must be replaced by hardware
registers.  The register allocation process re-writes a control flow
graph such that nodes only use hardware registers.

Liveness analysis provides the accurate lifetime of each registers. 
The register allocator tries to map temporary registers to hardware
registers such that their lifetimes do not interfere.  If the number
of available hardware registers is too small to map temporary
registers the register allocator runs out registers.  The solution is
to store some temporaries in memory and re-load them to a hardware
register only when they are needed; this is called \emph{spilling}.

The register allocator is a linear-scan allocator, basically modeled
after Traub et al.~\cite{traub:98:pldi} but without lazy spilling. 
It turned out that the simpler linear-scan register allocator by
Poletto \cite{poletto:99:toplas} can not handle pre-assigned hardware
registers as they are required by calling conventions.

Linear-scan register allocation requires a linear representation of a
procedure.  This is provided by numbering nodes in the control-flow
graph {\cfg}.  Of course, any change to the structure of the {\cfg}
destroys a numbering.  This happens when code for spilling is inserted
into a {\cfg}.

The [[Arg]] module summarizes the functionality that we need from the
environment.  Since it is just a type, we can put here whatever we
want without having to provide an implementation.  Ultimately, we like
to implement everything that is provided by [[Arg]] and get rid of it.

<<exported module types>>=
module type Args = sig
    val fits : Rtl.space -> Register.t -> bool
        (* fits s r = true, iff r can hold any value from space s *) 
    val is_tmp : Rtl.space -> bool
        (* true, iff space belongs to the temporary space *)
    
    (* 
     * for spilling
     *)
     
    val mkTmp:      Rtl.loc -> Register.t
        (* create a new tmp for a value currently held by loc *)
    val assign_loc: dst:Rtl.loc    -> src:Register.t -> Rtl.rtl 
    val assign_reg: dst:Register.t -> src:Rtl.loc    -> Rtl.rtl 
        (* create an assignment rtl that transfers a value from src to dst *)
    val mkMem:      Register.t -> Rtl.loc
        (* create a new spill slot for a register. Incomplete - will 
           use Automaton.t *)
end
@

Module type [[S]] summarizes the functionality we implement and export
for clients.  

<<exported module types>>=
module type S = sig 
    val linscan: Cfg3.t -> unit
end 

<<linscan.mli>>=
<<exported module types>>
@

% ------------------------------------------------------------------ 
\subsection{Construction of Register Lifetimes}
% ------------------------------------------------------------------ 

Liveness analysis (module \module{live}) annotates each node in the
control-flow graph with the set of registers live \emph{before} that
node.  From this we have to construct a global view that associates a
variable with its lifetime.  A lifetime is a set of nodes where a
register is life.  To make things easier, lifetimes are represented as
sets of intervals, where an interval is a sequence of consecutive
nodes with respect to the node numbering.  The first steps are
therefore to establish a numbering and to construct the lifetime of
each register.  The latter requires to walk over the control-flow
graph and recognize the opening and closing of intervals where a
particular variable is live.  Liveness intervals are then joined to
form \emph{lifetime} values.

Node in a {\cfg} are numbered with integers, called \emph{points}
here.  Points mark the opening and closing of liveness intervals. 

<<linscan.ml>>=
module Point = struct
    type t = int
    let compare = compare
    let zero = 0 
end

module G        = Cfg3
module P        = Point
module I        = Interval.Make(Point)
module L        = Lifetime.Make(I)
module RM       = Register.Map
module RS       = Register.Set

type lifetimes  = L.t RM.t  (* lt *)  (* map from register to its lifetimes *)
type loc        = Register.t    
 
<<compute lifetimes>>
@

To detect the opening and closing of liveness intervals the algorithm
compares the live-sets of two adjacent nodes $n_i$ and $n_{i+1}$. The
index $i$ is the point associated with a node $n$.

\begin{eqnarray*}
    \mathit{open}  &=& \mathit{live}(n_{i+1})\setminus \mathit{live}(n_i)\\ 
    \mathit{close} &=& \mathit{live}(n_{i})  \setminus \mathit{live}(n_{i+1})
\end{eqnarray*}

The registers in the $\mathit{open}$ set just became live and thus
each opens a live interval $(i+1,\dots)$; conversely, all registers in
the $\mathit{close}$ set close their previously opened interval. 
Because lifetime intervals are open on the right hand side (cf.~module
\module{lifetime}), the interval to be closed is $(\dots,i+1)$.  Once
an interval is closed, it can be added to the lifetime of the
respective variable.

The lifetimes for a control-flow graph are stored in a map that
associates registers with their lifetime.  An additional map holds the
opening point for registers that are currently live and have a not yet
closed their liveness interval.  In the functions traversing the
control-flow graph they are paired together as a value [[(op,lt)]].

The [[open_intv r p state]] function records the opening of an
interval for register [[t]] in the [[state]].  Dual to that,
[[close_intv]] closes a previously opened interval by removing the
register from [[op]] and adding a new interval to its lifetime in
[[lt]]. 

<<compute lifetimes>>=
(* type op    = P.t RM.t  (* map from register to opening point *)
 * type lt    = L.t RM.t  (* map from register to lifetime      *)
 * type state = op * lt   
 *)
 
let open_intv  point (op,lt) reg = (Register.Map.add reg point op, lt)

let close_intv point (op,lt) reg = 
    let x = try Register.Map.find reg op with Not_found -> assert false in
    let y = point in
    let i = I.mk x y in
    let l = try Register.Map.find reg lt with Not_found -> L.empty in
        ( Register.Map.remove reg op
        , Register.Map.add reg (L.mk i) lt
        ) 
@

Given a list of registers that open or close an interval we must fold
this list such that all registers in the list update the current
state. The state captures the lifetimes computes so far, plus the
currently open intervals.

<<compute lifetimes>>=
let open_regs  point regs state = List.fold_left (open_intv point)  state regs
let close_regs point regs state = List.fold_left (close_intv point) state regs
@

The [[lifetimes]] function computes a map that associates a register
with its lifetime.  The the lifetimes are inferred from the live sets
that are part of the control-flow graph.  The initial map [[lt]] is
supplied by the client.  After the last node of the control-flow graph
is processed, all still open intervals must be closed. 

<<compute lifetimes>>=
let lifetimes cfg lt =
    let initial     = (RM.empty, lt)                               in
    let domain map  = RM.fold (fun key _ list -> key::list) map [] in
    let scan node (oldset, state) =
        let point   = G.number node                                in
        let set     = G.live node                                  in
        let opening = RS.diff set oldset                           in
        let closing = RS.diff oldset set                           in
        let state   = open_regs  point (RS.elements opening) state in
        let state   = close_regs point (RS.elements closing) state in
                      (set, state)                                 in
    let first       = G.number (G.first cfg)                       in
    let last        = G.number (G.last cfg)                        in
    let (set,(op,lt)) = G.scan_fwd cfg first last scan (RS.empty, initial) in
                      (* close all open intervals after the last node *)
    let     (_ ,lt) = close_regs (last+1) (domain op) (op,lt)      in
        lt
@

\begin{quote}\it
    I have to verify that the above code calculates the correct
    intervals with respect to the open interval semantics for lifetime
    intervals. --CL
\end{quote}


% ------------------------------------------------------------------ 
\subsection{Register Allocation Implementation}
% ------------------------------------------------------------------ 

The implementation must provided all the module types declared in the
interface.  The heart of the implementation is the functor [[Make]]
with code to

\begin{enumerate}
\item find a temporary in a node that need to be placed into a register,
\item find a hardware register to accommodate a temporary,
\item find a register to spill (if we are stuck),
\item allocate registers for an entire {\cfg}, using the building
      blocks from above,
\item and to spill a register in a part of a {\cfg}.
\end{enumerate}

<<linscan.ml>>=
<<exported module types>>
module Make (A : Args) : S = struct
    module A = A open A (* never do that *)

    let lookup table x = RM.find x table       (* lookup lifetime *)

    <<find tmp>>
    <<find reg>>
    <<find spillee>>
    
    <<replace>> 
    <<alloc>> 
    <<linscan>>
end
@

The linear-scan register allocator [[linscan]] visits all nodes of a
{\cfg} in a linear order and [[alloc]]'tes hardware register for their
temporaries.  The [[alloc]] function receives two continuations,
[[loop]] and [[spill]].  It calls the latter, if no hardware register
can be found for a temporary.  Because spilling mutates the structure
of a {\cfg}, register allocation starts over after spilling.

<<linscan>>=
let rec linscan cfg =
    let _          = Live.liveness cfg     in
    let _          = G.gm_enumerate cfg in
    let rec loop lifetimes = function (* over all nodes *)
        | None      -> ()
        | Some node -> alloc node lifetimes loop spill
    in
        loop (lifetimes cfg RM.empty) (Some (G.first cfg)) 

<<update>>        
and spill cfg spillee mem interval = 
    let first = I.left  interval     in
    let last  = I.right interval - 1 in (* open interval semantics strikes *)
        ( G.scan_fwd cfg first last (fun n () -> update interval spillee mem n) ()
        ; linscan cfg (* start over *)
        )
@

The [[alloc]] function loops over all temporaries of a given node and
tries to replace them using [[replace_tmp]].  The [[replace_tmp]]
function again receives two continuation for the [[success]] and
[[spill]] cases.

<<alloc>>=
let alloc node lifetimes success spill =
    let rec loop lifetimes = match find_tmp node with
        | None     -> success lifetimes (G.next node)
        | Some tmp -> replace_tmp node tmp lifetimes loop spill      
    in
        loop lifetimes 
@

The real work is done in [[replace_tmp]].  For a given temporary
[[tmp]] a register [[r]] must by found by [[find_reg]].  If this
succeeds, the lifetime of [[tmp]] is joined with the register's
livetime, and all occurrences of [[tmp]] substituted by [[r]] in the
entire {\cfg}. However, if no [[r]] can be found, we must spill:
[[find_spillee] finds a candidate to spill and passes it to the
[[spill]] continuation.

<<replace>>=
let replace tmp reg      = fun t -> if t = tmp then reg else t

let replace_tmp node tmp lifetimes success spill =
  let iter cfg f = G.fold cfg (fun node () -> G.set_rtl node f) () in
  let lifetime   = lookup lifetimes in
  let cfg         = G.cfg node    in
  match find_reg lifetimes tmp with
  | Some r -> (* successfully found a hardware register *)
      let lifetimes = RM.add r (L.union (lifetime r) (lifetime r)) lifetimes in
      let lifetimes = RM.remove tmp lifetimes                      in
      let ()        = iter cfg (Rtlutil.Subst.reg (replace tmp r)) in
          success lifetimes
  | None ->
      let spillee, interval = find_spillee lifetimes tmp node in 
      let mem               = A.mkMem spillee                 in
          spill cfg spillee mem interval
@

% ------------------------------------------------------------------ 
\subsubsection{Finding a Temporary}
% ------------------------------------------------------------------ 

The linear scan allocator replaces all temporaries at a given node by
hardware registers. The [[find_tmp]] function implements the policy to
select a temporary to be placed.

The [[find_tmp]] function returns a temporary used in [[node]] that
should be replaced by a hardware register. [[None]] is returned, if no
such register can be found.

Our implementation is simple and returns the first temporary it
finds. The [[read_write_lists]] functions returns all registers read
or written by an {\rtl} and thus we have to look for temporaries
explicitly.

<<find tmp>>=
let find_tmp node = 
    let uses space index width = function
        | None when is_tmp space -> Some (space, index, width)
        | x                      -> x 
    in
        Rtlutil.read_write_lists uses uses (G.rtl node) None    
@       

\begin{quote}\it
    An alternative design would be to return a sorted list of all
    temporaries that need to be replaced.  Temporaries at the head of the
    list should be replaced first.  However, if we re-write all nodes
    in every allocation step, including the node at hand, the list may
    contain some temporaries no longer used by that node.  --CL
\end{quote}

% ------------------------------------------------------------------ 
\subsubsection{Finding a Hardware-Register}
% ------------------------------------------------------------------ 

After a temporary was selected to be placed into a hardware register,
an appropriate hardware register must be found.  The [[first_fit]]
function searches the domain of [[lifetimes]] to find a (hardware)
register that can hold temporary [[t]].  It returns the \emph{first}
register [[r]], that respects all of the following conditions, or
[[None]] otherwise.

\begin{enumerate}
\item The register [[r]] can hold the same values that [[t]] can hold. 
      This is decided using the target-specific [[fits]] function.
\item The bounding box of the lifetime of [[t]] does not overlap the 
      lifetimes of [[r]].      
\end{enumerate}

<<find reg>>=
let first_fit lifetimes t =
    let fits' (sp,_,_ as t) r = 
        fits sp r &&
        not (L.overlaps (L.bbox (lookup lifetimes t)) 
                                (lookup lifetimes r))
    in
    let check r lt = function
        | None   when fits' t r -> Some r       
        | x (* otherwise *)     -> x      
    in
        RM.fold check lifetimes None

let find_reg = first_fit        (* first_fit is a possible find_reg impl *)
@


% ------------------------------------------------------------------ 
\subsubsection{Finding a Spillee}
% ------------------------------------------------------------------ 

When no register can be found to hold register [[tmp]], we have to
spill a register which can be either a hardware register, or a
temporary.  The [[find_spillee]] function receives the [[lifetimes]]
map, the register [[tmp]] that we could not find a register for, and
the [[node]] under consideration in the linear scan.  The function
returns a register to spill and a region, where to spill it.

For finding a spillee, we use the policy described by
\cite{poletto:99:toplas}:  consider the temporary that could not be
placed and all hardware registers currently in use and spill the one
that is used farest\footnote{with respect to the node numbering} in
the program.  This means, we look at the bounding boxes of these
registers and spill the one that ends last.

Registers currently in use, or \emph{active}, are those whose
lifetime's bounding box overlaps with the current node.  This is a
superset of all nodes used by the current node.  The function
[[longest_active]] computes the node, lifetime pair who is used
longest in the program.  This is our spill candidate and we want to
spill it from the current node up to the end of the procedure.

<<find spillee>>=
let active point lifetimes =
    let here = I.mk point (point+1) in
    let find = fun loc lt active ->  
        if L.overlaps here lt then (loc,lt) :: active else active
    in
        RM.fold find lifetimes []

<<longest active type>>=
G.node -> loc -> lifetimes -> loc * L.t
<<find spillee>>=
let longest_active: <<longest active type>> = fun node tmp lifetimes ->
    let here   = G.number node        in
    let active = active here lifetimes  in
    let max (loc1,lt1 as x) (loc2,lt2 as y) = 
        if I.behind (L.bbox lt1) (L.bbox lt2) then x else y 
    in
        List.fold_left max (tmp,lookup lifetimes tmp) active

<<find spillee type>>= 
lifetimes -> loc -> G.node -> loc * I.t 
<<find spillee>>=
let find_spillee: <<find spillee type>> = fun lifetimes tmp node ->
    let cfg      = G.cfg node                     in
    let last     = G.number (G.last cfg)       in
    let loc,_    = longest_active node tmp lifetimes in
    let interval = I.mk (G.number node) (last+1)  in
        loc, interval
@

% ------------------------------------------------------------------ 
\subsubsection{Spilling Design}
% ------------------------------------------------------------------ 

This is intended to be a very simple specification of spilling, which
may be replaced by a more elaborate version.

We assume that we have a control-flow graph and that we want to spill
a register or temporary in a given region of the flow graph.  We write
[[member region n]] to indicate that a node~[[n]] lies in the region
of interest.  We contemplate an implementation in which the nodes of
the control-flow graph are placed in linear order, and in which
regions are intervals, but these assumptions are not necessary to this
specification.

We assume that we can find control-flow successors and predecessors
with functions [[succ]] and [[pred]].

The new graph for [[spill r region m g]] is computed as follows:

\begin{quote}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
for each node [[n]] in [[g]] such that [[member region n]] do\\
\> choose a fresh temporary [[t]]\\
\> for each node [[p]] in [[pred n]] such that \\ 
\>\> [[not (member region p)]] and [[r]] is live before [[n]] do\\
\>\> insert [[m := r]] on the edge from [[p]] to [[n]]\\
\> if [[n]] reads [[r]], insert [[t := m]] before [[n]]\\
\> if [[n]] writes [[r]], insert [[m := t]] after [[n]]\\
\> substitute [[t]] for [[r]] in [[n]]\\
\> for each node [[s]] in [[succ n]] such that  \\ 
\>\> [[not (member region p)]] and [[r]] is live before [[s]] do\\
\>\> insert [[r := m]] on the edge from [[n]] to [[s]]\\
\end{tabbing}
\end{quote}

It would be highly desirable to be able to separate the liveness tests
here, so for example we could always insert [[r := m]] or [[m := r]]
on edges that cross region boundaries, and then remove the unnecessary
instructions with a post-pass.
Some building blocks.

% ------------------------------------------------------------------ 
\subsubsection{Spilling Implementation}
% ------------------------------------------------------------------ 

The [[reads_writes]] function checks whether a location [[loc]] is
read or written by an {\rtl}.  It returns a pair $(r,w)$ of [[bool]]
values.  The first component $r$ is true, iff [[loc]] is read by
[[rtl]], the second $w$, iff [[loc]] is written by [[rtl]], and false
otherwise.

<<update>>=
and reads_writes rtl loc =
    let f sp index width (r,w) = 
        let eq = (sp,index,width) = loc in (r || eq, w || eq) 
    in
        Rtlutil.read_write_lists f f rtl (false,false)
@

The [[extern]] function returns all nodes from a list of nodes that do
not belong to an [[interval]]. Edges from such nodes to nodes inside
the interval must be augmented with assignments; this is done by 

<<update>>=
and extern interval = 
    List.filter (fun n -> not (I.member (G.number n) interval)) 
@

Edges entering and leaving the spilling interval must be modified to
include assignment nodes:  outside the interval the [[spillee]] holds
a value, inside the interval [[mem]].  Incoming edges therefore must
write the [[spillee]] to [[mem]], outgoing edges [[mem]] to
[[spillee]].  The following two functions [[upd_*]] functions update
edges for [[node]]. 

<<update>>=
and upd_incoming interval spillee mem node =
    let pred  = extern interval (G.pred node) in
    let write = A.assign_loc mem spillee          in
        List.iter (fun n -> G.gm_insert_assign_between write n node) pred

and upd_outgoing interval spillee mem node = 
    let succ  = extern interval (G.succ node) in
    let read  = A.assign_reg spillee mem          in
        List.iter (fun n -> G.gm_insert_assign_between read node n) succ
@

The heart of the spiller is [[update]] that is applied to every
[[node]] in an interval that undergoes spilling.  If [[node]] reads or
writes the [[spillee]], it must be updated such that it uses a new
temporary [[tmp]] instead.  Before and after the node [[tmp]] must be
read from or written to memory [[mem]] where the value of the spillee
is held inside the [[interval]].  Edges entering or leaving the
interval must be also updated such that the spillee's value is written
to and read from [[mem]]. 
    
<<update>>=
and update interval spillee mem node = 
    let _ = upd_incoming interval spillee mem node        in
    let _ = upd_outgoing interval spillee mem node        in
    let reads, writes = reads_writes (G.rtl node) spillee in
        if (reads || writes) then 
            ( let tmp   = A.mkTmp mem in
              let subst = fun x -> if x = spillee then tmp else x in 
              ( if reads  then 
                    (G.gm_insert_assign_before  node (A.assign_reg tmp mem))
              ; if writes then 
                    (G.gm_insert_assign_after   node (A.assign_loc mem tmp))
              ; G.set_rtl node (Rtlutil.Subst.reg subst)
              )
            )
        else
            () (* done *)
@
