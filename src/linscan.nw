% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% :vim sw=4 et 
        
\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{Register Allocation}
% ------------------------------------------------------------------ 

The nodes of a control-flow graph (\cfg) initially contain temporary
registers and hardware registers.  For translation to machine
instructions, the temporary registers must be replaced by hardware
registers.  The register allocation process re-writes a control flow
graph such that nodes only use hardware registers.

Liveness analysis provides the accurate lifetime of each register. 
The register allocator then tries to map temporary registers to
hardware registers such that their lifetimes do not interfere.  If the
number of available hardware registers is too small to map temporary
registers, the register allocator runs out of registers.  The solution is
to store some temporaries in memory and re-load them to  hardware
registers only when they are needed; this is called \emph{spilling}.

The register allocator is a linear-scan allocator, basically modeled
after Traub et al.~\cite{traub:98:pldi} but without lazy spilling. 
It turned out that the simpler linear-scan register allocator by
Poletto \cite{poletto:99:toplas} can not handle pre-assigned hardware
registers as they are required by calling conventions.

% ------------------------------------------------------------------ 
\subsection{Overview}
% ------------------------------------------------------------------ 

Linear-scan register allocation assumes, a procedure is a linear
sequence of control-flow nodes, which represent instructions.  Such an
order can be easily obtained by enumerating the nodes in {\cfg}---of
course, many possible enumerations exist.  Liveness analysis determines
which registers, temporaries and hardware registers are live on any
control-flow edge.  Each node is marked with the registers that are live
on its outgoing edges.  These registers are said to be \emph{live after}
that node.  Linear-scan register allocation needs a broader perspective
on liveness and computes a global map that associates with every
register the set of nodes at which the register is \emph{live after}.
This situation is shown in Figure \ref{fig:linscan:overview}:  from the
linearized flow graph in (1) a map in (2) is computed that shows at
which regions the temporaries $t_0$, $t_1$ and the hardware register
$r_0$ are live.  Typically, most data lives in temporaries and a
few hardware registers are for parameter passing.  

\begin{figure}[bh]
\centerline{\includegraphics[width=\hsize]{../figures/linscan-1}}
\caption{\label{fig:linscan:overview} Register allocation assigns
temporaries to hardware registers.}
\end{figure}

The aim of the register-allocator is to place every temporary into a
hardware register.  The allocator in this module implements basically
the policy described by Poletto \cite{poletto:99:toplas}:  it
scans the procedure in linear order and tries to place temporaries
that are live at the node at hand.  In Figure
\ref{fig:linscan:overview} the first live temporary is $t_0$.  The
policy described by Poletto mandates that the \emph{bounding box},
highlighted as a dotted rectangle, fits into the chosen hardware
register.  This is the case in situation (3) for $r_0$ and thus $t_0$
is placed there.  Now every instruction in the {\cfg} that uses $t_0$
is re-written to use $r_0$ instead. 

Continuing scanning, the register allocator finds $t_1$.  However, the
bounding box of its lifetime collides with the lifetime of $r_0$ and
thus $r_0$ cannot hold $t_1$.  Assuming that no other hardware register
is available, the register allocator decides to spill temporary $t_1$.
This breaks $t_1$ into smaller intervals \emph{and} creates new
temporaries $t_2$ and $t_3$ for each usage of $t_1$, as shown in Figure
\ref{fig:linscan:overview} (5).  After a new round of liveness analysis
and scanning, temporaries $t_1$, $t_2$, and $t_3$ can be assigned to
$r_0$---register allocation is now complete. 
 
\begin{quote}\it
    We have changed the policy: only hardware registers are spilled, not
    temporaries. Because spilling a temporary does not guarantee, that
    we can find a hardware register for it after it was spilled and thus
    we might get stuck. When a hardware register $r$ is spilled, reloads
    use $r$ again, because the use of $r$ could have been demanded by a
    calling convention. We cannot reload into a different register or a
    temporary that might get assigned to a different register. The
    picture in Figure \ref{fig:linscan:spilling} is incorrect, as is the
    explanation in the text.
\end{quote}

\begin{figure}[htb]
\centerline{\includegraphics[width=\hsize]{../figures/linscan-2}}
\caption{\label{fig:linscan:spilling} Spilling $x$.}
\end{figure}

Spilling deserves a closer look because it requires that new nodes are
added to a control-flow graph.  Figure \ref{fig:linscan:spilling}
shows a situation where a register $x$ is spilled in a sequence of
nodes, called a spill region.  Outside the region $x$ is left
untouched, inside the region the value of $x$ is held in a memory
location, typically on the run-time stack.  Therefore on every edge
that enters or leaves the region \emph{and} on which $x$ is live nodes
must be inserted that transfer $x$ to or from memory.  These nodes are
depicted as grey nodes on the border of the rectangle that marks the
spill region. 

For every use of the spilled register inside the spill-region $x$ must
be re-loaded from memory and re-written, if it is live after the use. 
The corresponding nodes are the two grey nodes inside the spill
region.  


\begin{quote}\it
\begin{itemize}
\item Re-writing the nodes of a {\cfg} to reflect assignments can be
      delayed until spilling or register allocation is completed. 
       
\item The requirement that the bounding-box of a temporary's lifetime
      must not interfere with a hardware register's lifetime can probably
      be dropped. 
\end{itemize}
\end{quote}

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Linear-scan register allocation requires a linear representation of a
procedure.  This is provided by numbering nodes in the control-flow
graph {\cfg}.  Of course, any change to the structure of the {\cfg}
destroys a numbering.  This happens when code for spilling is inserted
into a {\cfg}. The  private area in the [[Proc.t]] argument supplies
spill locations in a 
procedure's activation record.


<<linscan.mli>>=
val linscan: Proc.t -> bool
@

We export the linear scan register allocator as a Lua function that fits
into the framework of the Optimization Backplane. In particular, we
export the allocator as the Lua function [[Linscan.allocate]]. 

<<linscan.mli>>=
module Make (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Proc.t): 
    Lua.Lib.TYPEFUL with type 'a combined = 'a ProcT.combined
@

% ------------------------------------------------------------------ 
\subsection{Construction of Register Lifetimes}
% ------------------------------------------------------------------ 

Liveness analysis (module \module{live}) annotates each node in the
control-flow graph with the set of registers live \emph{before} that
node.  From this we have to construct a global view that associates a
variable with its lifetime.  A lifetime is a set of nodes where a
register is live.  To make things easier, lifetimes are represented as
sets of intervals, where an interval is a sequence of consecutive
nodes with respect to the node numbering.  The first steps are
therefore to establish a numbering and to construct the lifetime of
each register.  The latter requires to walk over the control-flow
graph and recognize the opening and closing of intervals where a
particular variable is live.  Liveness intervals are then joined to
form \emph{lifetime} values.

Nodes in a {\cfg} are numbered with integers, called \emph{points}
here.  Points mark the opening and closing of liveness intervals. 

<<linscan.ml>>=
module G = Cfg4

module P = struct
    type t = int
    let compare = compare
    let zero = 0 
    let to_string = string_of_int
end

module I        = Interval.Make(P)
module LT       = Lifetime.Make(I)
module LI       = Live.Make(G)
module Pr       = Cfgprop
module RM       = Register.Map
module RS       = Register.Set
module T        = Target2
module S        = Space

module NodeSet = Set.Make (struct 
    type t = G.rtlnode
    let compare = compare
end)    

type lifetimes  = LT.t RM.t  (* lt *)  (* map from register to its lifetimes *)
type loc        = Register.t    

(* for debugging *)
let dump lifetimes =
    RM.iter (fun (sp,i,w) lt -> Printf.eprintf "(%c,%d,%d): %s\n"
              sp i w (LT.to_string lt)) lifetimes

let lookup table (sp,i,_ as x) = 
    try RM.find x table  with Not_found -> LT.empty

<<compute lifetimes>>

<<find tmp>>
<<find reg>>
<<find spillee>>

<<replace>> 
<<alloc>> 
<<linscan>>   
<<update>>        
<<spill>>
@


To detect the opening and closing of liveness intervals the algorithm
compares the live-sets of two adjacent nodes $n_i$ and $n_{i+1}$. The
index $i$ is the point associated with a node $n$.

\begin{eqnarray*}
    \mathit{open}  &=& \mathit{live}(n_{i+1})\setminus \mathit{live}(n_i)\\ 
    \mathit{close} &=& \mathit{live}(n_{i})  \setminus \mathit{live}(n_{i+1})
\end{eqnarray*}

The registers in the $\mathit{open}$ set just became live and thus
each opens a live interval $(i+1,\dots)$; conversely, all registers in
the $\mathit{close}$ set close their previously opened interval. 
Because lifetime intervals are open on the right hand side (cf.~module
\module{lifetime}), the interval to be closed is $(\dots,i+1)$.  Once
an interval is closed, it can be added to the lifetime of the
respective variable.

The lifetimes for a control-flow graph are stored in a map that
associates registers with their lifetime.  An additional map holds the
opening point for registers that are currently live and have a not yet
closed their liveness interval.  In the functions traversing the
control-flow graph they are paired together as a value [[(op,lt)]].

The [[open_intv r p state]] function records the opening of an
interval for register [[t]] in the [[state]].  Dual to that,
[[close_intv]] closes a previously opened interval by removing the
register from [[op]] and adding a new interval to its lifetime in
[[lt]]. 

<<compute lifetimes>>=
type op    = P.t RM.t   (* map from register to opening point *)
type lt    = LT.t RM.t  (* map from register to lifetime      *)
type state = op * lt   
 
let open_intv  point (op,lt:state) reg = (Register.Map.add reg point op, lt)

let close_intv point (op,lt:state) reg = 
    let x = try Register.Map.find reg op with Not_found -> assert false in
    let y = point in
    let i = I.mk x y in
    let l = try Register.Map.find reg lt with Not_found -> LT.empty in
        ( Register.Map.remove reg op
        , Register.Map.add reg (LT.union (LT.mk i) l) lt
        ) 
@

Given a list of registers that open or close an interval we must fold
this list such that all registers in the list update the current
state. The state captures the lifetimes computed so far, plus the
currently open intervals.

<<compute lifetimes>>=
let open_regs  point regs state = List.fold_left (open_intv point)  state regs
let close_regs point regs state = List.fold_left (close_intv point) state regs
@

The [[lifetimes]] function computes a map that associates a register
with its lifetime.  The the lifetimes are inferred from the live sets
that are part of the control-flow graph.  The initial map [[lt]] is
constructed from the list of free registers provided by the client. 
After the last node of the control-flow graph is processed, all still
open intervals must be closed. 

<<compute lifetimes>>=
let lifetimes proc =
    let cfg         = proc.Proc.cfg                                in
    let registers   = proc.Proc.cc.T.allocatable                   in
    let lt          = List.fold_left (fun map r -> RM.add r LT.empty map) 
                                     RM.empty registers            in
    let initial     = (RM.empty, lt)                               in
    let domain map  = RM.fold (fun key _ list -> key::list) map [] in
    let scan node (oldset, state) =
        let point   = G.number node                                in
        let set     = (G.property node).Pr.liveout                 in
        let opening = RS.diff set oldset                           in
        let closing = RS.diff oldset set                           in
        let state   = open_regs  point (RS.elements opening) state in
        let state   = close_regs point (RS.elements closing) state in
                      (set, state)                                 in
    let first       = G.number (G.first cfg)                       in
    let last        = G.number (G.last cfg)                        in
    let (set,(op,lt)) = G.scan_fwd cfg ~first ~limit:last 
                                scan (RS.empty, initial) in
                      (* close all open intervals after the last node *)
    let     (_ ,lt) = close_regs (last+1) (domain op) (op,lt)      in
    let _           = () (* dump lt *)   in

        lt
@


% ------------------------------------------------------------------ 
\subsection{Register Allocation Implementation}
% ------------------------------------------------------------------ 

The implementation must provide all the module types declared in the
interface.  The heart of the implementation is the functor [[Make]]
with code to

\begin{enumerate}
\item find a temporary in a node that needs to be placed into a register,
\item find a hardware register to accommodate a temporary,
\item find a register to spill (if we are stuck),
\item allocate registers for an entire {\cfg}, using the building
      blocks from above,
\item and to spill a register in a part of a {\cfg}.
\end{enumerate}

The linear-scan register allocator [[linscan]] visits all nodes of a
{\cfg} in a linear order and [[alloc]]'ates hardware register for their
temporaries.  The [[alloc]] function receives two continuations,
[[next_node]] and [[spill]].  It calls the latter, if no hardware register
can be found for a temporary.  Because spilling mutates the structure
of a {\cfg}, register allocation starts over after spilling.

The [[lifetimes]] function must be supplied with a map that contains all
hardware registers that are available for register allocation, not the
[[empty]] set. --CL

<<linscan>>=
let rec linscan proc =
    let _  = LI.liveness proc.Proc.cfg     in
    let _  = G.gm_enumerate proc.Proc.cfg  in
    let lt = lifetimes proc                in
    let rec next_node lt node = match node with 
        | None      -> true (* lies!  risky... *)
        | Some node -> alloc proc node lt next_node spill
    in
        (* G.dump proc.Proc.cfg "foo"; true *)
         next_node lt (Some (G.first proc.Proc.cfg)) 
@
<<alloc>>=
let alloc proc node lifetimes next_node spill =
    let rec next_tmp lifetimes = match find_tmp proc node with
        | None     -> next_node lifetimes (G.next node)
        | Some tmp -> replace_tmp proc node tmp lifetimes next_tmp spill      
    in
        next_tmp lifetimes 
@

The [[alloc]] function loops over all temporaries of a given node and
tries to replace each using [[replace_tmp]].  The [[replace_tmp]]
function again receives two continuation for the [[success]] and
[[spill]] cases.

The functions [[alloc]] and [[replace_tmp]] together implement an
algorithm of complexity $O(n^2)$, where $n$ is the number of nodes in
the {\cfg}:  as soon a temporary can can be placed into a hardware
register, the entire {\cfg} is updated, which affects $n$ nodes. 
Potentially this happens at every node during the linear scan and
hence we have an $O(n^2)$ complexity.  The obvious improvement is to
collect all changes and to apply them in a single run over the {\cfg}.

The real work is done in [[replace_tmp]].  For a given temporary
[[tmp]] a register [[r]] must by found by [[find_reg]].  If this
succeeds, the lifetime of [[tmp]] is joined with the register's
livetime, and all occurrences of [[tmp]] substituted by [[r]] in the
\emph{entire} {\cfg}. However, if no [[r]] can be found, we must spill:
[[find_spillee]] finds a candidate to spill and passes it to the
[[spill]] continuation.
  

<<replace>>=
let replace tmp reg      = fun t -> if t = tmp then reg else t

(* reserve a spill slot using automaton *)
let spill_slot (a:Automaton.t) ((_,w,_):Register.t) =
    Automaton.to_loc (Automaton.ty a w None)

let replace_tmp proc node tmp lifetimes next_tmp spill =
  let iter cfg f = Cfgutil.fold_fwd cfg (fun node ()-> G.upd_instr node f) () in
  let lifetime   = lookup lifetimes                                 in
  let cfg        = G.cfg node                                       in
  match find_reg proc lifetimes tmp with
  | Some r -> (* successfully found a hardware register r *)
      let lifetimes = RM.add r (LT.union (lifetime tmp)(lifetime r))
                               lifetimes                            in
      let lookup    = Target2.space proc.Proc.target                in
      let lifetimes = RM.remove tmp lifetimes                       in
      let ()        = iter cfg 
                        (Rtlutil.Subst2.reg ~lookup ~map:(replace tmp r)) in
          next_tmp lifetimes
  | None -> (* out of register - must spill *)
      let allocatable = proc.Proc.cc.T.allocatable              in 
      let is_tmp      = T.is_tmp proc.Proc.target in
      let spillable (sp,_,_ as loc) = 
        List.mem loc allocatable in
      let spillee, interval = find_spillee spillable lifetimes tmp node in 
      let mem               = spill_slot proc.Proc.priv spillee     in 
        spill proc spillee mem interval
@

% ------------------------------------------------------------------ 
\subsection{Policies}
% ------------------------------------------------------------------ 

The [[linscan]] register allocator depends on a number of policies to
find temporaries and the hardware registers that replace them.  These
are described below and can be changed easily.

% ------------------------------------------------------------------ 
\subsubsection{Finding a Temporary}
% ------------------------------------------------------------------ 

The linear scan allocator replaces all temporaries at a given node by
hardware registers. The [[find_tmp]] function implements the policy to
select a temporary to be placed.

The [[find_tmp]] function returns a temporary used in [[node]] that
should be replaced by a hardware register. [[None]] is returned, if no
such register can be found.

Our implementation is simple and returns the first temporary it
finds. The [[read_write_lists]] functions returns all registers read
or written by an {\rtl} and thus we have to look for temporaries
explicitly.

<<find tmp>>=
let find_tmp proc node = 
    let uses space index width = function
        | None when T.is_tmp proc.Proc.target space -> 
            Some (space, index, width)
        | x -> x 
    in
        Rtlutil.ReadWrite.fold ~read:uses ~write:uses (G.instr node) None    
@       

\begin{quote}\it
    An alternative design would be to return a sorted list of all
    temporaries that need to be replaced.  Temporaries at the head of the
    list should be replaced first.  However, if we re-write all nodes
    in every allocation step, including the node at hand, the list may
    contain some temporaries no longer used by that node.  --CL
\end{quote}

% ------------------------------------------------------------------ 
\subsubsection{Finding a Hardware-Register}
% ------------------------------------------------------------------ 

After a temporary was selected to be placed into a hardware register,
an appropriate hardware register must be found.  The [[first_fit]]
function searches the domain of [[lifetimes]] to find a (hardware)
register that can hold temporary [[t]].  It returns the \emph{first}
register [[r]], that respects all of the following conditions, or
[[None]] otherwise.

\begin{enumerate}
\item The register [[r]] can hold the same values that [[t]] can hold. 
      This is decided using the target-specific [[fits]] function.
\item The bounding box of the lifetime of [[t]] does not overlap the 
      lifetimes of [[r]].      
\end{enumerate}

<<find reg>>=
let first_fit proc lifetimes t =
    let fits' (sp,i,_ as t) (sp',i',_ as r) = 
        let x = T.fits proc.Proc.target sp r in
        let y = not (LT.overlaps (LT.bbox (lookup lifetimes t)) 
                    (lookup lifetimes r)) in
        (*
        let _ = Printf.eprintf "%c[%d] %s %c[%d]\n" 
                    sp i 
                    (if x&&y then "->" else "!->") 
                    sp' i'; flush stderr in  *)
            x && y            
    in
    let check r lt = function
        | None   when fits' t r -> Some r       
        | x (* otherwise *)     -> x      
    in
        RM.fold check lifetimes None

let find_reg = first_fit        (* first_fit is a possible find_reg impl *)
@


% ------------------------------------------------------------------ 
\subsubsection{Finding a Spillee}
% ------------------------------------------------------------------ 

When no register can be found to hold register [[tmp]], we have to
spill a register which can be either a hardware register, or a
temporary.  The [[find_spillee]] function receives the [[lifetimes]]
map, the register [[tmp]] that we could not find a register for, and
the [[node]] under consideration in the linear scan.  The function
returns a register to spill and a region in which the spillee is
spilled to memory.

For finding a spillee, we use the policy described by
\cite{poletto:99:toplas}:  consider the temporary that could not be
placed and all hardware registers currently in use and spill the one
that is used furthest\footnote{with respect to the node numbering} in
the program.  This means, we look at the bounding boxes of these
registers and spill the one that ends last.

Registers currently in use, or \emph{active}, are those whose
lifetime's bounding box overlaps with the current node.  This is a
superset of all nodes used by the current node.  The function
[[longest_active]] computes the node/lifetime pair that is used
longest in the program.  This is our spill candidate and we want to
spill it from the current node up to the end of the procedure.

<<find spillee>>=
let active point lifetimes spillable =
    let here = I.mk point (point+1) in
    let find = fun loc lt active ->  
        let ol = LT.overlaps here lt in
        let sp = spillable loc in
        (* let _  = Printf.eprintf "%s %s %s %s (%s)\n"
                 (I.to_string here)
                 (if ol then "overlaps" else "not overlaps")
                 (Register.print loc)
                 (LT.to_string lt)
                 (if sp then "spillable" else "not spillable") in *)
        if  ol && sp then
            (loc,lt) :: active 
        else 
            active
    in
        RM.fold find lifetimes []

<<find spillee>>=
let longest_active node tmp lifetimes spillable  =
    let here   = G.number node        in
    let active = active here lifetimes spillable in
    let max (loc1,lt1 as x) (loc2,lt2 as y) = 
        if I.ends_after (LT.bbox lt1) (LT.bbox lt2) then x else y in
    let _      = assert (active <> []) in    
    let r = List.fold_left max (List.hd active) (List.tl active) in
    (*
    let () = Printf.eprintf "active: %s longest: %s\n"
             (String.concat " " 
                (List.map (fun f -> Register.print (fst f)) active))
             (Register.print (fst r)) in
    *)    
        r         

<<find spillee>>=
let find_spillee spillable lifetimes tmp node =
    let cfg      = G.cfg node                     in
    let last     = G.number (G.last cfg)       in
    let loc,_    = longest_active node tmp lifetimes spillable in
    let interval = I.mk (G.number node) (last+1)  in
    (* let ()       = Printf.eprintf "spilling: %s in %s\n" 
                    (Register.print loc) (I.to_string interval) in
     *)   
        loc, interval
@

% ------------------------------------------------------------------ 
\subsection{Spilling Design}
% ------------------------------------------------------------------ 

This is intended to be a very simple specification of spilling, which
may be replaced by a more elaborate version.

We assume that we have a control-flow graph and that we want to spill
a register or temporary in a given region of the flow graph.  We write
[[member region n]] to indicate that a node~[[n]] lies in the region
of interest.  We contemplate an implementation in which the nodes of
the control-flow graph are placed in linear order, and in which
regions are intervals, but these assumptions are not necessary to this
specification.

We assume that we can find control-flow successors and predecessors
with functions [[succ]] and [[pred]].

The new graph for [[spill r region m g]] is computed as follows:

\begin{quote}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
for each node [[n]] in [[g]] such that [[member region n]] do\\
\> choose a fresh temporary [[t]]\\
\> for each node [[p]] in [[pred n]] such that \\ 
\>\> [[not (member region p)]] and [[r]] is live before [[n]] do\\
\>\> insert [[m := r]] on the edge from [[p]] to [[n]]\\
\> if [[n]] reads [[r]], insert [[t := m]] before [[n]]\\
\> if [[n]] writes [[r]], insert [[m := t]] after [[n]]\\
\> substitute [[t]] for [[r]] in [[n]]\\
\> for each node [[s]] in [[succ n]] such that  \\ 
\>\> [[not (member region p)]] and [[r]] is live before [[s]] do\\
\>\> insert [[r := m]] on the edge from [[n]] to [[s]]\\
\end{tabbing}
\end{quote}

It would be highly desirable to be able to separate the liveness tests
here, so for example we could always insert [[r := m]] or [[m := r]]
on edges that cross region boundaries, and then remove the unnecessary
instructions with a post-pass.

\begin{quote}\it Spilling hardware registers is not save: if [[spillee]]
    is a hardware register, it is re-loaded into a new temporary that
    substitutes the hardware register in nodes. However, the hardware
    register might the there because a calling convention demands it.
    Therefore the implemented algorithm spills the spillee to memory and
    reloads it into the spillee, rather into a temporary. This
    eliminates the substitution step as well. --CL
\end{quote}




% ------------------------------------------------------------------ 
\subsection{Spilling Implementation}
% ------------------------------------------------------------------ 

The spiller walks over a region [[interval]] of nodes and updates it
such that the [[spillee]] is held in memory [[mem]] most of the time. 
When the spillee is used, it is re-loaded into a temporary.

<<spill>>=

and spill proc spillee mem interval = 
    let first = I.left  interval in
    let last  = I.right interval in 
    let nodes = G.scan_fwd proc.Proc.cfg ~first ~limit:last
                    (fun n set -> NodeSet.add n set) NodeSet.empty in
        ( G.scan_fwd proc.Proc.cfg ~first ~limit:last 
            (fun n () -> update proc interval nodes spillee mem n) ()
        ; linscan proc (* start over *)
        )
@

The [[reads_writes]] function checks whether a location [[loc]] is
read or written by an {\rtl}.  It returns a pair $(r,w)$ of [[bool]]
values.  The first component $r$ is true, iff [[loc]] is read by
[[rtl]], the second $w$, iff [[loc]] is written by [[rtl]], and false
otherwise.

<<update>>=
and reads_writes rtl loc =
    let read  sp index width (r,w) = (r || loc = (sp,index,width), w) in
    let write sp index width (r,w) = (r, w || loc = (sp,index,width)) in
        Rtlutil.ReadWrite.fold ~read ~write rtl (false,false)
@

The [[extern]] function returns all nodes from a list of nodes that do
not belong to an [[interval]]. 

<<update>>=
and extern interval = 
    List.filter (fun n -> not (I.member (G.number n) interval)) 
@

Edges entering and leaving the spilling interval must be modified to
include assignment nodes:  outside the interval the [[spillee]] holds
a value, inside the interval [[mem]].  Incoming edges therefore must
spill the [[spillee]] to [[mem]], outgoing edges reload [[mem]] to
[[spillee]].  The following two functions [[upd_*]] functions update
edges for [[node]]. 

<<update>>=
and upd_incoming target extern spillee mem node =
    let spill = target.T.spill (T.space target) spillee mem in
    let upd n = if extern n (* && RS.mem spillee 
                                ((G.property n).Pr.liveout) *) then 
                    insert_between spill node n 
                else 
                    () in
        List.iter upd (G.pred node)

and upd_outgoing target extern spillee mem node = 
    let reload  = target.T.reload (T.space target) spillee mem          in
    let liveout = RS.mem spillee ((G.property node).Pr.liveout) in
    let upd n   = if extern n && liveout then
                    insert_between reload n node 
                  else () in
        List.iter upd (G.succ node)

and insert_between rtls node before =
    ignore (List.fold_right 
        (fun rtl n -> G.gm_insert_assign_between rtl before n) 
        rtls node)
@

The heart of the spiller is [[update]] that is applied to every
[[node]] in an interval that undergoes spilling.  If [[node]] reads or
writes the [[spillee]], it must be updated such that it uses a new
temporary [[tmp]] instead.  Before and after the node [[tmp]] must be
read from or written to memory [[mem]] where the value of the spillee
is held inside the [[interval]].  Edges entering or leaving the
interval must be also updated such that the spillee's value is written
to and read from [[mem]]. 

<<update>>=
and update proc interval nodes spillee mem node = 
    let extern n = not (NodeSet.mem n nodes) in
    upd_incoming proc.Proc.target extern spillee mem node ;    
    upd_outgoing proc.Proc.target extern spillee mem node;      
    let reads, writes = reads_writes (G.instr node) spillee in
    let target = proc.Proc.target in
    let lookup = Target2.space target in
        if reads || writes then 
            ( if reads  then 
                ignore (List.fold_right G.gm_insert_assign_before
                          (target.T.reload (T.space target) spillee mem) node)
            ; if writes then 
                ignore (List.fold_left G.gm_insert_assign_after node
                          (target.T.spill  (T.space target) spillee mem))
            )
@

% ------------------------------------------------------------------ 
\section{Backplane Interface}
% ------------------------------------------------------------------ 

We export the linear scan register allocator as a Lua function that fits
into the framework of the Optimization Backplane.

<<linscan.ml>>=
module Make (ProcT: Lua.Lib.TYPEVIEW with type 'a t = Proc.t): 
    Lua.Lib.TYPEFUL with type 'a combined = 'a ProcT.combined =
struct
    type 'a combined = 'a ProcT.combined
    module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
    struct
        <<export linear scan allocator>>
        let init = C.register_module "Linscan" builtins
    end (*M*)    
end (*Make*)            

<<export linear scan allocator>>=
module V  = C.V

let ( **-> ) = V.( **-> )
let proc     = ProcT.makemap V.userdata V.projection
let pf t     = (V.pfunc t).V.embed    (* pure Lua function *)
let allocate = fun _ -> linscan

let builtins =
    [ "allocate" , pf (V.value **-> proc **-> V.result V.bool) allocate
    ]
@
    
