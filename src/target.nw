
\input{macros.tex}


% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Target}
% ------------------------------------------------------------------ 

The {\qcc} compiler aims to be a cross-compiler which means the same
compiler can compile {\PAL} programs for different target platforms. 
Consequently, the current target must be described by an {\ocaml}
value rather than a module, since the latter can not be passed at
run-time of the compiler. 

Informations about the target do not only include the sizes of
pointers and the byte order, but also functions that create and
recognize {\rtl}s.  Although functions and simple values can be
combined in a tuple or record value, an object seems to be an even
better fit.  In addition, classes allow to exploit similarities
between targets by inheritance.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

A target platform includes informations about the target's hardware
architecture and conventions shared by other software running on the
platform.  An important aspect of the latter are the calling
conventions between code.

<<target.mli>>=
module StrMap:  Map.S with type key = string
<<class type cc>>
<<class type t>>
<<dummy target>>
@

In {\PAL} values are passed in three different contexts:  into a
procedures, returned by a procedure, into a continuation.  A calling
convention provides an automaton that models the convention for the
particular context and the stack pointer used by the convention.

<<class type cc>>=
class type cc = object
    method sp:             Rtl.Private.location    (* stack pointer *)
    method proc_param:     Automaton.t         
    method proc_result:    Automaton.t
    method cont_param:     Automaton.t  
end
@

A target is described by a lot of simple values denoting sizes of
pointers and such:

\begin{itemize}
\item The byteoreder, or endianness.
\item The sizes in bits for pointers and words
\item The smallest number of bits in an adresseable memory unit. This
      is typically a byte, i.e.~8 bits.
\item Norms that define the interpretation of characters and floating point
      numbers. \emph{This is more platform, than architecture specific.}
\item A map [[conv]] of calling conventions.
\item An automaton that determines the allocation of hardware registers
      for global registers.  
\item A map that provides a [[Rtl.location]] for the name of a
      hardware register.
\end{itemize}

<<class type t>>=
class type t = object
    <<class type t body>>
end
@

<<class type t body>>=
method name:           string                  (* like sparc or i386   *)
method byteorder:      Rtl.aggregation         (* big/small endian     *)
method wordsize:       int                     (* in bits              *)
method pointersize:    int                     (* in bits              *)
method memsize:        int                     (* in bits, 8 typical   *)
method float:          string                  (* "ieee754" typical    *)
method charset:        string                  (* "latin1"  typical    *)
method cc:             cc StrMap.t             (* calling conv by name *)
method cc':            string -> cc            (* Error.ErrorExn      *)
method globals:        Automaton.t             (* global reg alloc     *)
method registers:      Rtl.Private.location StrMap.t   (* registers by name    *)
@

A {\PAL} source code contains some informations about the target it is
intended for.  The [[validate]] method returns [[true]] if the actual
target is compatible to the claims in the source file, and raises the
[[Error.ErrorExn]] exception otherwise.

<<>>=
method validate: Fenv.Clean.env -> bool
@

The code-generation phase translates generic [[branch]] or [[call]]
nodes of the control flow graph (module \module{cfg})) into platform
specific {\rtl}s.  Each target platform provides methods for this
translation and an inverse function that recognizes the generated
{\rtl}.  If a recogonzier ([[match]]\dots]) fails, an assertion failure
will be raised because this is manifests an internal compiler error.

<<>>=
method mkGoto:          Rtl.expr -> Rtl.rtl
method matchGoto:       Rtl.rtl  -> Rtl.expr    

method mkJump:          Rtl.expr -> Rtl.rtl
method matchJump:       Rtl.rtl  -> Rtl.expr

method mkCutto:         Rtl.expr -> Rtl.rtl
method matchCutto:      Rtl.rtl  -> Rtl.expr

method mkCall:          Rtl.expr -> Rtl.rtl
method matchCall:       Rtl.rtl  -> Rtl.expr

method mkBranch:        Rtl.expr -> Rtl.rtl
method matchBranch:     Rtl.rtl  -> Rtl.expr
@

% ------------------------------------------------------------------ 
\subsubsection{Dummy Target}
% ------------------------------------------------------------------ 

The [[dummy]] target is a fictitious target to be used during
development.  Its main characteristic is the the lack of
sophistication, hence the name.

<<dummy target>>=
val dummy: t
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation first has to provide types declared in the
interface.  In addition, modules used by the implementation are
declared.

<<target.ml>>=
module E      = Error
module F      = Fenv.Clean
module StrMap = Map.Make(struct type t=string let compare=compare end)

<<class type cc>>
<<class type t>>
@

% ------------------------------------------------------------------ 
\subsubsection{The dummy target}
% ------------------------------------------------------------------ 

First some auxiliary functions.  The [[reg]] function creates a 32bit
register, addressed by 4 bit number [[n]].

<<>>=
let reg n = 
    Rtl.Private.Cell( 'r' 
            , Rtl.BigEndian 
            , 32
            , Rtl.Private.Const(Rtl.Private.Bits(Bits.of_int n 4,4))
            , -1
            ) 
@

The class for the dummy's calling convention. A single instance is
created below.

<<>>=
class dummycc: cc = object 
    method sp          = reg 8
    method proc_param  = Automaton.Build.cc   
    method proc_result = Automaton.Build.cc 
    method cont_param  = Automaton.Build.cc 
end

<<>>=
class dummytarget: t = object (self)
    <<dummy object body>>
end
@

We only need one instance of the [[dummytarget]] class. Since only the
instance is exported and not the class definition it is impossible for
clients to create more instances. 

<<>>=
let dummy = new dummytarget
@


<<dummy object body>>=
method name            = "dummy"
method byteorder       = Rtl.BigEndian 
method wordsize        = 32
method pointersize     = 32
method memsize         = 8
method float           = "ieee754"
method charset         = "latin1"
method cc              = StrMap.add "C--" (new dummycc) StrMap.empty
method globals         = Automaton.Build.globals
@

The [[dummy]] target has a set of 8 universal [[registers]] which we
construct below. The registers are addressed by 4-bit numbers $0--7$. 

<<>>=
method registers = 
    let name n = Printf.sprintf "r%d" n in
    let rec loop map = function
            | -1  -> map
            | n   -> loop (StrMap.add (name n) (reg n) map) (n-1)
        in
            loop StrMap.empty 7
@

The method [[cc]] is bad because it reveals the implementation how
calling conventions are stored. The following implementation [[cc']]
provides what a client really needs: a lookup function for calling
conventions. For compatibility bth [[cc]] and [[cc']] are provided, but
[[cc]] is deprecated. 

<<>>=
method cc' name = 
    try StrMap.find name (self#cc)
    with Not_found -> Error.error ("unknown calling convention: "^name)
@    

The [[validate]] predicate just checks entries that can be checked and
emits error messages if informations do not match.

<<>>=
method validate env = 
    let error x = 
        ( E.errorPrt ("The target declartion for "^x^" is not compatible with the actual target") 
        ; false
        ) in
        if      ( match (F.findEndianness env), self#byteorder with
                | F.Big   , Rtl.BigEndian    -> false
                | F.Little, Rtl.LittleEndian -> false 
                | _                          -> true
                )
        then    error "endianness"
        else if F.findMemsize env <> self#memsize
        then    error "memsize"
        else if F.findWordsize env <> self#wordsize
        then    error "wordsize"
        else if F.findPointersize env <> self#pointersize
        then    error "pointersize"
        else if F.findFloat env <> self#float
        then    error "float"
        else if F.findCharset env <> self#charset
        then    error "charset"
        else true
@

% ------------------------------------------------------------------ 
\subsubsection{Making and Matching RTLs}
% ------------------------------------------------------------------ 

A platform description provides methods to construct and deconstruct
platform specific {\rtl}s for some nodes in a control flow graph
(module \module{cfg}). Since I have yet have to look up what a real
platform does I'm am clueless what a dummy should do. The following
methods are almost useless.

<<>>=
method mkGoto expr    = assert false
method matchGoto rtl  = assert false

method mkJump expr    = assert false
method matchJump rtl  = assert false

method mkCutto expr   = assert false   
method matchCutto rtl = assert false    

method mkCall         = assert false        
method matchCall      = assert false    

method mkBranch       = assert false    
method matchBranch    = assert false    
@


