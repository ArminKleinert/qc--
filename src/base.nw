% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>(<a href="#$1.dvi">.dvi</a>)
% l2h macro exfile 1 <a href="#$1"><tt>#1</tt></a>
% l2h macro image 1 <img alt="Dependency graph" src="#1.gif" ALIGN=right></img>

\input{../macros.tex}

\section{Evaluating instance}
<<base.mli ((evaluating))>>=
type std_int = int
@ \subsection{Implementation}
<<base.ml ((evaluating))>>=
type std_int = int

@ 
\section{Residualising  instance of the standard primitives}

<<base.mli ((residualizing))>>=

  <<types>>

(*val evalOp : std_string * std_int list -> std_int*)

(*type mylocation = Syntax.exp*)

val qint : int -> std_int
val qword : int -> std_word
val qbool : bool -> std_bool
val qstring : string -> std_string
val qchar : char -> std_char

val intEq : std_int -> std_int  -> bool
val wordEq : std_word -> std_word  -> bool
val boolEq : std_bool -> std_bool  -> bool
val stringEq : std_string -> std_string  -> bool
val charEq : std_string -> std_string  -> bool

val eq : std_int -> std_int  -> bool
val lessthan : std_int -> std_int  -> bool

val eqId : std_int -> std_int  -> bool
    
val eqN : std_int -> std_int  -> std_bool
val lessthanN : std_int -> std_int  -> std_bool

val add : std_int -> std_int  -> std_int
val cond : std_bool -> (unit -> 'a)  -> (unit -> 'a) -> 'a

val not : std_bool -> std_bool
val lgand : std_bool -> std_bool -> std_bool

val print_std_int : std_int -> unit
val print_std_char : std_int -> unit
val print_std_word : std_word -> unit

val to_bool : std_bool -> bool
    
@ these are the types that we are going to see
<<types>>=
type std_int = MachineSyntax.exp
type std_word = MachineSyntax.exp
type std_bits = MachineSyntax.exp
type std_string = MachineSyntax.exp
type std_bool = MachineSyntax.exp
type std_char = MachineSyntax.exp
type std_unit = MachineSyntax.exp

type nativeint = MachineSyntax.exp

@ \section{Implementation}

<<base.ml ((residualizing))>>=

module S = MachineSyntax
module Sy = Syntax
module T = Tdpe
  
<<types>>
(*let evalOp(op,ls) = raise Error*)

(*type mylocation = Syntax.exp

let _MEMORY = raise Error
let _TEMPORARY x = raise Error
let _VARIABLE x = raise Error
let _REGISTER x = raise Error*)

let qint x = Sy.INT x
let qword x = Sy.INT x
let qbool x = Sy.BOOL x
let qstring s = Sy.STR s
let qchar s = Sy.CHR s

let eq e1 e2 =
  match (e1,e2) with
    (Sy.INT i1,Sy.INT i2) -> i1=i2
  | (Sy.BOOL i1,Sy.BOOL i2) -> i1=i2
  | (Sy.STR i1,Sy.STR i2) -> i1=i2
  | (Sy.CHR i1,Sy.CHR i2) -> i1=i2
(*  | (Sy.VAR x,Sy.VAR y) ->
      if x=y then true
      else T.nbe' (T.arrowN(T.a',T.arrowN(T.a',T.boo))) (Sy.VAR "=") e1 e2*)
  | (_,_) -> T.nbe' (T.arrowN(T.a',T.arrowN(T.a',T.booNone))) (Sy.VAR "=") e1 e2

let eqId e1 e2 =
  match (e1,e2) with
    (Sy.INT i1,Sy.INT i2) -> i1=i2
  | (Sy.BOOL i1,Sy.BOOL i2) -> i1=i2
  | (Sy.STR i1,Sy.STR i2) -> i1=i2
  | (Sy.CHR i1,Sy.CHR i2) -> i1=i2
  | (Sy.VAR x,Sy.VAR y) ->
      if x=y then true
      else T.nbe' (T.arrowN(T.a',T.arrowN(T.a',T.boo))) (Sy.VAR "=") e1 e2
  | (_,_) -> T.nbe' (T.arrowN(T.a',T.arrowN(T.a',T.booNone))) (Sy.VAR "=") e1 e2
        
let intEq = eq
let wordEq = eq
let boolEq = eq
let stringEq = eq
let charEq = eq

exception BadTypeError
    
let lessthan e1 e2 =
  match (e1,e2) with
    (Sy.INT i1,Sy.INT i2) -> i1<i2
  | (Sy.BOOL i1,Sy.BOOL i2) -> raise BadTypeError
  | (Sy.STR i1,Sy.STR i2) -> raise BadTypeError
  | (Sy.CHR i1,Sy.CHR i2) -> raise BadTypeError
  | (_,_) -> T.nbe' (T.arrowN(T.a',T.arrowN(T.a',T.booNone))) (Sy.VAR "<") e1 e2

let add e1 e2 =
  match (e1,e2) with
    (Sy.INT i1,Sy.INT i2) -> Sy.INT(i1+i2)
  | (Sy.BOOL i1,Sy.BOOL i2) -> raise BadTypeError
  | (Sy.STR i1,Sy.STR i2) -> raise BadTypeError
  | (Sy.CHR i1,Sy.CHR i2) -> raise BadTypeError
  | (_,_) -> T.nbe' (T.arrowN(T.a',T.arrowN(T.a',T.a'))) (Sy.VAR "+") e1 e2

let eqN e1 e2 =
  match (e1,e2) with
    (Sy.INT i1,Sy.INT i2) -> Sy.BOOL (i1=i2)
  | (Sy.BOOL i1,Sy.BOOL i2) -> Sy.BOOL (i1=i2)
  | (Sy.STR i1,Sy.STR i2) -> Sy.BOOL (i1=i2)
  | (Sy.CHR i1,Sy.CHR i2) -> Sy.BOOL (i1=i2)
(*  | (Sy.VAR x,Sy.VAR y) ->
      if x=y then
        Sy.BOOL (x=y)  (* here somethign may be fishy *)
      else T.nbe' (T.arrowN(T.a',T.arrowN(T.a',T.a'))) (Sy.VAR "=") e1 e2*) 
  | (_,_) -> T.nbe' (T.arrowN(T.a',T.arrowN(T.a',T.a'))) (Sy.VAR "=") e1 e2

let lessthanN e1 e2 =
  match (e1,e2) with
    (Sy.INT i1,Sy.INT i2) -> Sy.BOOL (i1<i2)
  | (Sy.BOOL i1,Sy.BOOL i2) -> raise BadTypeError
  | (Sy.STR i1,Sy.STR i2) -> raise BadTypeError
  | (Sy.CHR i1,Sy.CHR i2) -> raise BadTypeError
  | (_,_) -> T.nbe' (T.arrowN(T.a',T.arrowN(T.a',T.a'))) (Sy.VAR "<") e1 e2

let cond e f1 f2 =
  match e with
    Sy.BOOL true -> f1()
  | Sy.BOOL false -> f2()
  | _ ->
      if T.nbe' T.boo e
      then f1()
      else f2()
      (*Sy.COND (e,f1(),f2())*)
  
let not e =
  match e with
    (Sy.BOOL x) -> Sy.BOOL (not x)
  | _ -> T.nbe' (T.arrowN(T.a',T.a')) (Sy.VAR "not") e

let print_std_int = S.pprint
let print_std_char = S.pprint
let print_std_word = S.pprint

let to_bool e =
  match e with
    Sy.BOOL true -> true
  | Sy.BOOL false -> false
  | _ -> T.nbe' T.boo e

let lgand e1 e2 =
  match (e1,e2) with
    (Sy.BOOL i1,Sy.BOOL i2) -> Sy.BOOL(i1 && i2)
  | (_,_) -> T.nbe' (T.arrowN(T.a',T.arrowN(T.a',T.a'))) (Sy.VAR "&&") e1 e2
