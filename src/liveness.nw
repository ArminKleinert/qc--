% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Liveness analysis}

<<liveness.ml>>=


module type GRAPH = sig
  type set
  val union : set list -> set

  type node = { mutable live : set }
(* maybe better:*)
  val live : node -> set
  val set_live : node -> set -> unit
  type graph

  val visit_all_nodes : (node -> unit) -> graph -> unit

  val succ : node -> node list
  val exit : graph -> node
end

module Liveness (G: GRAPH) = struct
  let live (n:G.node) = 
    let l = G.union (List.map (fun n -> n.G.live) (G.succ n))  in
    let l = l in (* here, modify according to use/def info from n,
                    including n's associated RTL if any *)
    l

  let process changed (n:G.node) =
    let l = live n
    in  if l <> n.G.live then
          (changed := true; n.G.live <- l)
        else
          ()

  let analyze graph =
    let c = ref false in
    let rec run () = (G.visit_all_nodes (process c) graph;
                  if !c then (c := false; run ()) else ())
    in  run ()
        
end
    
    

