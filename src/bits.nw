% -*- mode: Noweb; noweb-code-mode: caml-mode -*-


% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

\input{macros.tex}

% ------------------------------------------------------------------ 
\section{Bits -- low level representation of values}
% ------------------------------------------------------------------ 

Values in {\PAL} can be either of type [[bool]] or [[bits]].  While
[[bool]] values can be represented by the {\ocaml} type [[bool]],
[[bits]] require a data structure.  Conceptually a [[bits]] value can
hold a declared but arbitrary large number of bits. 

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

A [[bits]] value has a [[width]] which is the number of bits it can
hold. The conversion of [[bits]] from and to other representations can
cause overflows which are reported by an exception [[Overflow]].
Requests for an unsupported [[width]] results in a [[Size]] exception.
Currently 64 bits and less are supported.

<<bits.mli ((evaluating))>>=
type width      = int
type bitvector (* abstract *)
type bits       = bitvector * width
@

The width of a [[bits]] value is determined when it is created. 
Even though it is exposed in the representation, we can also use the
[[width]] function to get access to it. In case the requested size
is not supported by the implementation [[Size]] is raised. The
[[maxwidth]] is the maximal width supported by an implementation.

<<bits.mli ((evaluating))>>=
val width       : bits -> width
val maxwidth    : width
@

The [[fits]] predicate is true, if and only if a given [[bits]] value
fits into width.  N.B. this is a property of the \emph{width} of the
argument, not of its \emph{value}.  In particular, a 32-bit
representation of the integer~1 does not ``[[fits]]'' into 16~bits,
even though the value can easily be represented in 16~bits.

The width must mot be greater than [[maxwidth]],
otherwise the [[Size]] exception is raised which indicates a problem
with the limits of an implementation.

<<bits.mli ((evaluating))>>=
val fits        : bits -> width -> bool
@

The [[setSize]] function updates the size information of a [[bits]]
value. This is a dangerous operation since the new size may violate
the assumption that the current value fits into that size. Thus,
[[Overflow]] is raised, when this assumption is violated by the new size.
\emph{NR finds this definition insufficiently precise.
It's only used in one place---\module{elab}.  Perhaps we can find a
better way to express this?}
<<bits.mli ((evaluating))>>=
val setSize     : bits -> width -> bits
@

% ------------------------------------------------------------------ 
\subsubsection{Creation of \texttt{bits} values}
% ------------------------------------------------------------------ 

A [[bits]] value is usuallu created from a string representation as
part of a {\PAL} source program. The string representation include
integer, floating point, and character representations:

\begin{enumerate}
\item The integer string representation can use a decimal, octal, or
      hexadecimal radix.  The characters to represent the respective
      radices in strings are shown below.  Conversion to and from
      strings always considers a [[bits]] value as an unsigned
      integer.

        \begin{tabular}{ll}
        Radix        & characters \\
        \hline
        octal        & \ttfamily 0 1 2 3 4 5 6 7     \\
        decimal      & \ttfamily 0 1 2 3 4 5 6 7 8 9 \\
        hexadecimal  & \ttfamily 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F \\
        \end{tabular}
 
      The radix of a string is determined by its first two characters:

      \begin{itemize}
      \item A string starting with [[0x]] or [[0X]] is considered a
            hexadecimal number.
      \item A string starting with [[0]] is considered a string of octal
            numbers.
      \item All other strings are considered as strings with decimal numbers.
      \end{itemize}

      A [[Failure "of_string"]] exception is raised when the string
      contains illegal characters. 

\item The floating point representation [[float]] can be decribed by the
      following small grammar that is also used in the {\PAL} lexer:

      \begin{quote}
      \begin{verbatim}
    let digit       = ['0'-'9']
    let nat         = digit+
    let frac        = nat '.' nat
    let exp         = ['e''E'] sign? nat
    let float       = frac exp? 
                    | nat exp
      \end{verbatim}
      \end{quote}

\item The character representation honors the C escape sequences.
      Otherwise stands each character for itself.
      
       \begin{quote}
        \begin{tabular}{ll}
            Escape Sequence & Interpretation \\ 
            \hline
            [[\a]]          & Alert (Bell) \\
            [[\b]]          & Backspace    \\
            [[\f]]          & Formfeed     \\
            [[\n]]          & Newline      \\
            [[\r]]          & Carriage Return \\
            [[\t]]          & Horizontal Tab \\
            [[\\]]          & Backslash    \\
            [[\']]          & Single Quote \\
            [[\"]]          & Double Quote \\
            [[\?]]          & Question Mark \\
            [[\x]]$\{\textit{hexdigit}\}$ 
                            & The value of \textit{hexdigit} sequence \\
            [[\]] $\{\textit{octdigit}\}$ 
                            & The value of \textit{octdigit} sequence \\
        \end{tabular}
        \end{quote} 
\end{enumerate}

The following functions create [[bits]] values from strings. The
exception [[E.Error]] is raised in case of syntactical errors of the
string representation.  [[Size]] is raised when the requested
[[[width]] is not supported by the implementation.  [[Overflow]] is
raised when the specified [[width]] is too small to hold the value
given by the string representation.

<<bits.mli ((evaluating))>>=
exception Overflow
exception Size

<<bits.mli ((evaluating))>>=
val of_stringi  : string -> width -> bits (* Size, Overflow, Error *)
val of_stringf  : string -> width -> bits
val of_stringc  : string -> width -> bits
@

[[bits]] values can be created from integers.
<<bits.mli ((evaluating))>>=
val of_int       : int       -> width -> bits  (* Size *)
val of_int64     : int64     -> width -> bits  (* Size *)
val of_nativeint : nativeint -> width -> bits  (* Size *)
@

% ------------------------------------------------------------------ 
\subsubsection{Converting \texttt{bits} values}
% ------------------------------------------------------------------ 

A [[bits]] value can be converted to an integer or string.  If the
[[bits]] do not fit into an [[int]], [[Overflow]] is raised. 

<<bits.mli ((evaluating))>>=
type radix      = Oct
                | Dec
                | Hex

val to_int      : bits -> int                       (* raises Overflow *)
val to_nativeint : bits -> nativeint                (* raises Overflow *)
val to_string   : radix option -> bits -> string    
@

% ------------------------------------------------------------------ 
\subsubsection{Operations on [[bits]]}
% ------------------------------------------------------------------ 

<<bits.mli ((evaluating))>>=
val zero        : width -> bits
@


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

A [[bits]] is represented as an [[int64]].  The reason not to
implement arbitrary large bit vectors is the need for IEEE 754
floating point operations:  an [[int64]] value can be considered as a
C [[float]] value of 64 bits for which floating point operations are
available. Unsigned operations on [[int64]] values are provided by the
[[Uint64]] module.

<<bits.ml ((evaluating))>>=
module E = Error
module I = Int64        (* signed   operations *)
module U = Uint64       (* unsigned operations *)

exception Overflow
exception Size
@

% ------------------------------------------------------------------ 
\subsubsection{Auxiliaries}
% ------------------------------------------------------------------ 

Values of type [[bits]] are represented as pairs of width and value.

<<bits.ml ((evaluating))>>=
type width      = int
type bitvector  = int64
type bits       = int64 * width
@

<<bits.ml ((evaluating))>>=
let maxwidth    = 64
let width (_,w) = w
@

Operations on [[bits]] frequently must [[check]] that the requested
with is inside the implementation's limits and an actual value fits
into that many bits.  The [[check]] function raises [[Size]] or
[[Overflow]] in case the mentioned rules are violated.

<<bits.ml ((evaluating))>>=
let fits (bits,width') width =
    if (width <= 0) || (width > 64) 
    then raise Size
    else (width = 64) || (U.le bits (U.shl width I.one))
@

 
<<bits.ml ((evaluating))>>=
let check width uint64 =
    if not (fits (uint64,maxwidth) width)
    then raise Overflow
    else () (* ok *)
@
[[setSize]] sets the size of a [[bits]] value and raises [[Overflow]]
in case the size is too small.
<<bits.ml ((evaluating))>>=
let setSize (b,w as bits) width =
    if not (fits bits width)
    then raise Overflow
    else (b,width)
@

% ------------------------------------------------------------------ 
\subsubsection{Creation of \texttt{bits} values}
% ------------------------------------------------------------------ 

<<bits.ml ((evaluating))>>=
let of_stringi str width =
    let len    = String.length str in
    let uint64 = ( match str.[0] with
                 | '0' when len > 1 -> U.of_string ("0o"^str)
                 | _                -> U.of_string str
                 ) in
        try
            ( check width uint64
            ; (uint64,width)
            )
        with
            Failure _ -> E.error ("syntax error in constant: "^str)
         
<<bits.ml ((evaluating))>>=
let of_stringf str width =
    if   width <> 64 
    then raise Size
    else try (U.of_float (float_of_string str),width) with
         | Failure _ -> E.error ("syntax error in constant: "^str)

<<bits.ml ((evaluating))>>=
let of_stringc str width =
    let len = String.length str in
    let c   = 
            try
                if   len = 0 
                then assert false
                else if str.[0] = '\\' && len > 1 
                then match str.[1] with
                | 'a'  when len = 2 -> U.of_int 7
                | 'b'  when len = 2 -> U.of_int 8
                | 'n'  when len = 2 -> U.of_int 10
                | 'r'  when len = 2 -> U.of_int 13
                | 't'  when len = 2 -> U.of_int 9
                | '\\' when len = 2 -> U.of_int 92
                | '\'' when len = 2 -> U.of_int 39
                | '"'  when len = 2 -> U.of_int 34
                | '?'  when len = 2 -> U.of_int 63
                | 'x'  when len = 2 -> U.of_string ("0"  ^ str)
                | '0' .. '7'        -> U.of_string ("0o" ^ str) 
                | _                 -> E.error ("syntax error: "^str)
                else                   U.of_int (Char.code str.[0])
            with Failure _          -> E.error ("syntax error: "^str)
        in
            ( check width c
            ; (c, width)
            ) 
    
<<bits.ml ((evaluating))>>=
let of_int i width =
    let uint64 = U.of_int i in
        ( check width uint64
        ; (uint64,width)
        )
<<bits.ml ((evaluating))>>=
let of_int64 i width =
    ( check width i
    ; (i,width)
    )

let of_nativeint i width = of_int64 (I.of_nativeint i) width
@
    
% ------------------------------------------------------------------ 
\subsubsection{Conversions}
% ------------------------------------------------------------------ 

The [[to_int]] function checks that the [[bits]] value can be
represented as a positive integer and raises [[Overflow]] otherwise. 

<<bits.ml ((evaluating))>>=
let to_int (uint64,width) =
    if uint64 > I.of_int(max_int) then
        raise (Overflow)
    else
        I.to_int uint64
@
Similarly for native integers.  The test is bogus, but there's no easy
way to find out if [[width]] is small enough to fit into the width of
[[nativeint]], because we're not given the width of [[nativeint]].
<<bits.ml ((evaluating))>>=
let to_nativeint (uint64,width) =
    if I.logand uint64 (I.of_nativeint Nativeint.max_int) = uint64 then
        I.to_nativeint uint64
    else
        raise (Overflow)
@
This is buggy: the [[I.to_string]] function considers the [[bits]]
value as a signed integer. We also ignore the radix for the moment.

<<bits.ml ((evaluating))>>=
type radix      = Oct
                | Dec
                | Hex

let to_string radix (uint64,width) = I.to_string uint64 (* wrong *)
@

% ------------------------------------------------------------------ 
\subsubsection{Operations on [[bits]]}
% ------------------------------------------------------------------ 

<<bits.ml ((evaluating))>>=
let zero w =
    let z = U.of_int 0 in
    ( check w z
    ; (z,w) 
    )
@

\section{Residualizing instantiation}

This section is written just as a copy-and-pase of the upper code. I'll
get into it later, and try to merge some of the definitions.


<<bits.mli ((residualizing))>>=

type tag = INT | NINT | INT64 | BV
type width      = int
type bitvector  = (tag * MachineSyntax.exp) (* abstract *)
type bits       = bitvector * width
@

The width of a [[bits]] value is determined when it is created. The
[[width]] function provides access to it. In case the requested size
is not supported by the implementation [[Size]] is raised. The
[[maxwidth]] is the maximal width supported by an implementation.

<<bits.mli ((residualizing))>>=
val width       : bits -> width
val maxwidth    : width
@

The [[fits]] predicate is true, if and only if a given [[bits]] value
fits into width.  N.B. this is a property of the \emph{width} of the
argument, not of its \emph{value}.  In particular, a 32-bit
representation of the integer~1 does not ``[[fits]]'' into 16~bits,
even though the value can easily be represented in 16~bits.

The width must mot be greater than [[maxwidth]],
otherwise the [[Size]] exception is raised which indicates a problem
with the limits of an implementation.

<<bits.mli ((residualizing))>>=
val fits        : bits -> width -> bool
@

The [[setSize]] function updates the size information of a [[bits]]
value. This is a dangerous operation since the new size may violate
the assumption that the current value fits into that size. Thus,
[[Overflow]] is raised, when this assumption is violated by the new size.

<<bits.mli ((residualizing))>>=
val setSize     : bits -> width -> bits
@

% ------------------------------------------------------------------ 
\subsubsection{Creation of \texttt{bits} values}
% ------------------------------------------------------------------ 

A [[bits]] value is usuallu created from a string representation as
part of a {\PAL} source program. The string representation include
integer, floating point, and character representations:

\begin{enumerate}
\item The integer string representation can use a decimal, octal, or
      hexadecimal radix.  The characters to represent the respective
      radices in strings are shown below.  Conversion to and from
      strings always considers a [[bits]] value as an unsigned
      integer.

        \begin{tabular}{ll}
        Radix        & characters \\
        \hline
        octal        & \ttfamily 0 1 2 3 4 5 6 7     \\
        decimal      & \ttfamily 0 1 2 3 4 5 6 7 8 9 \\
        hexadecimal  & \ttfamily 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F \\
        \end{tabular}
 
      The radix of a string is determined by its first two characters:

      \begin{itemize}
      \item A string starting with [[0x]] or [[0X]] is considered a
            hexadecimal number.
      \item A string starting with [[0]] is considered a string of octal
            numbers.
      \item All other strings are considered as strings with decimal numbers.
      \end{itemize}

      A [[Failure "of_string"]] exception is raised when the string
      contains illegal characters. 

\item The floating point representation [[float]] can be decribed by the
      following small grammar that is also used in the {\PAL} lexer:

      \begin{quote}
      \begin{verbatim}
    let digit       = ['0'-'9']
    let nat         = digit+
    let frac        = nat '.' nat
    let exp         = ['e''E'] sign? nat
    let float       = frac exp? 
                    | nat exp
      \end{verbatim}
      \end{quote}

\item The character representation honors the C escape sequences.
      Otherwise stands each character for itself.
      
       \begin{quote}
        \begin{tabular}{ll}
            Escape Sequence & Interpretation \\ 
            \hline
            [[\a]]          & Alert (Bell) \\
            [[\b]]          & Backspace    \\
            [[\f]]          & Formfeed     \\
            [[\n]]          & Newline      \\
            [[\r]]          & Carriage Return \\
            [[\t]]          & Horizontal Tab \\
            [[\\]]          & Backslash    \\
            [[\']]          & Single Quote \\
            [[\"]]          & Double Quote \\
            [[\?]]          & Question Mark \\
            [[\x]]$\{\textit{hexdigit}\}$ 
                            & The value of \textit{hexdigit} sequence \\
            [[\]] $\{\textit{octdigit}\}$ 
                            & The value of \textit{octdigit} sequence \\
        \end{tabular}
        \end{quote} 
\end{enumerate}

The following functions create [[bits]] values from strings. The
exception [[E.Error]] is raised in case of syntactical errors of the
string representation.  [[Size]] is raised when the requested
[[[width]] is not supported by the implementation.  [[Overflow]] is
raised when the specified [[width]] is too small to hold the value
given by the string representation.

<<bits.mli ((residualizing))>>=
exception Overflow
exception Size of string

<<bits.mli ((residualizing))>>=
val of_stringi  : string -> width -> bits (* Size, Overflow, Error *)
val of_stringf  : string -> width -> bits
val of_stringc  : string -> width -> bits
@

[[bits]] values can be created from integers.
<<bits.mli ((residualizing))>>=
val of_int       : int       -> width -> bits  (* Size *)
val of_int64     : int64     -> width -> bits  (* Size *)
val of_nativeint : Base.nativeint -> width -> bits  (* Size *)
@

% ------------------------------------------------------------------ 
\subsubsection{Converting \texttt{bits} values}
% ------------------------------------------------------------------ 

A [[bits]] value can be converted to an integer or string.  If the
[[bits]] do not fit into an [[int]], [[Overflow]] is raised. 

<<bits.mli ((residualizing))>>=
type radix      = Oct
                | Dec
                | Hex

val to_int      : bits -> Base.std_int                       (* raises Overflow *)
val to_nativeint : bits -> Base.nativeint                (* raises Overflow *)
val to_string   : radix option -> bits -> string    
@

% ------------------------------------------------------------------ 
\subsubsection{Operations on [[bits]]}
% ------------------------------------------------------------------ 

<<bits.mli ((residualizing))>>=
val zero        : width -> bits
@


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

A [[bits]] is represented as an [[int64]].  The reason not to
implement arbitrary large bit vectors is the need for IEEE 754
floating point operations:  an [[int64]] value can be considered as a
C [[float]] value of 64 bits for which floating point operations are
available. Unsigned operations on [[int64]] values are provided by the
[[Uint64]] module.

<<bits.ml ((residualizing))>>=
module E = Error
module I = Int64        (* signed   operations *)
module U = Uint64       (* unsigned operations *)


module Sy = Syntax
module T = Tdpe

exception Overflow
exception Size of string

exception BTA of string

@

% ------------------------------------------------------------------ 
\subsubsection{Auxiliaries}
% ------------------------------------------------------------------ 

Values of type [[bits]] are represented as pairs of width and value.

<<bits.ml ((residualizing))>>=

type tag = INT | NINT | INT64 | BV
type width      = int
type bitvector  = (tag * MachineSyntax.exp)
type bits       = bitvector * width (* width * int64 *)
@

<<bits.ml ((residualizing))>>=

let maxwidth    = 64

@ A useful function for me, let's see how it works
<<bits.ml ((residualizing))>>=


exception Error
  
let mkBitsINT width bits = ((INT,Sy.INT bits),width)
let mkBitsNINT width bits = ((NINT,Sy.NINT bits),width)
let mkBitsINT64 width bits = ((INT64,Sy.INT64 bits),width)
let mkBitsBV width bits =   raise Error

let width (_,w) = w

(*let width b =
  match b with
    (Sy.PAIR(Sy.INT w,_)) -> w
  |  _ -> raise (BTA "cant extract the width out of dynamic bits")*)

(*let getBits b =
  match b with
    (Sy.PAIR(_,Sy.INT64 bits)) -> bits
  |  _ -> raise (BTA "can't extract the bits out of dynamic bits")*)
@

Operations on [[bits]] frequently must [[check]] that the requested
with is inside the implementation's limits and an actual value fits
into that many bits.  The [[check]] function raises [[Size]] or
[[Overflow]] in case the mentioned rules are violated.

<<bits.ml ((residualizing))>>=

let fits (bits,width') width =
  let (tg,bits) = bits in
    if (width <= 0) || (width > 64) 
    then raise (Size ("does not fit in fits "^(string_of_int width)))
    else (width = 64) ||
    (T.nbe' (T.arrowN(T.pair(T.a',T.a'),T.arrowN(T.a',T.booNone)))
       (Sy.VAR "Bits.fits")
       (Sy.INT width',bits)
       (Sy.INT width))

@

 
<<bits.ml ((residualizing))>>=
let check width uint64 =
    (*if not (fits (maxwidth,(Sy.INT64 uint64)) width)
    then raise Overflow
    else () (* ok *)*)

  try (if (not(
           if (width <= 0) || (width > 64) 
           then
             raise (Size ("does not fit in check with "^(string_of_int width)))
           else (width = 64) || (U.le uint64 (U.shl width I.one))))
  then
    (T.nbe' (T.arrow(T.a',T.unit))
       (Sy.VAR "raise") (Sy.VAR "Overflow"))
  else ())
  with Size _ -> (T.nbe' (T.arrow(T.a',T.unit)) (Sy.VAR "raise") (Sy.VAR "Size"))

@

[[setSize]] sets the size of a [[bits]] value and raises [[Overflow]]
in case the size is too small.

<<bits.ml ((residualizing))>>=
let setSize (b,w as bits) width =
    if not (fits bits width)
    then raise Overflow
    else (b,width)

@

% ------------------------------------------------------------------ 
\subsubsection{Creation of \texttt{bits} values}
% ------------------------------------------------------------------ 

<<bits.ml ((residualizing))>>=
let of_stringi str width =
    let len    = String.length str in
    let uint64 = ( match str.[0] with
                 | '0' when len > 1 -> U.of_string ("0o"^str)
                 | _                -> U.of_string str
                 ) in
        try
            ( check width uint64
            ; mkBitsINT64 width uint64
            )
        with
            Failure _ -> E.error ("syntax error in constant: "^str)
         
<<bits.ml ((residualizing))>>=
let of_stringf str width =
    if   width <> 64 
    then raise (Size ("does not fit in 32"))
    else try mkBitsINT64 width (U.of_float (float_of_string str)) with
         | Failure _ -> E.error ("syntax error in constant: "^str)

<<bits.ml ((residualizing))>>=
let of_stringc str width =
    let len = String.length str in
    let c   = 
            try
                if   len = 0 
                then assert false
                else if str.[0] = '\\' && len > 1 
                then match str.[1] with
                | 'a'  when len = 2 -> U.of_int 7
                | 'b'  when len = 2 -> U.of_int 8
                | 'n'  when len = 2 -> U.of_int 10
                | 'r'  when len = 2 -> U.of_int 13
                | 't'  when len = 2 -> U.of_int 9
                | '\\' when len = 2 -> U.of_int 92
                | '\'' when len = 2 -> U.of_int 39
                | '"'  when len = 2 -> U.of_int 34
                | '?'  when len = 2 -> U.of_int 63
                | 'x'  when len = 2 -> U.of_string ("0"  ^ str)
                | '0' .. '7'        -> U.of_string ("0o" ^ str) 
                | _                 -> E.error ("syntax error: "^str)
                else                   U.of_int (Char.code str.[0])
            with Failure _          -> E.error ("syntax error: "^str)
        in
            ( check width c;
              mkBitsINT64 width c
            ) 

<<bits.ml ((residualizing))>>=
let of_int i width =
    let uint64 = U.of_int i in
        ( check width uint64
        ;
          (*let (b,w) = Tdpe.nbe' (Tdpe.arrowN(T.a',Tdpe.arrowN(T.a',T.pair(T.a',T.a'))))
              (Sy.VAR "Bits.of_int") (Sy.INT i) (Sy.INT width)
          in (b,width)*)
          mkBitsINT width i
        )
<<bits.ml ((residualizing))>>=
let of_int64 i width =
  ( check width i
      ; mkBitsINT64 width i
   )

@ This implementation of of_native int is a bit optimistic, and not
totally correct. The function returns the width of the bits as given,
and a piece of syntax for the bitvector, as the second projection of the
bits value.
<<bits.ml ((residualizing))>>=
let of_nativeint i width =
  (*let (b,_) = 
    Tdpe.nbe' (Tdpe.arrowN(Tdpe.a',Tdpe.arrowN(Tdpe.a',Tdpe.pair(Tdpe.a',Tdpe.a'))))
      (Sy.VAR "Bits.of_nativeint") i (Sy.INT width) in
  (b,width)*)
  ((NINT,i),width)

   

@
    
% ------------------------------------------------------------------ 
\subsubsection{Conversions}
% ------------------------------------------------------------------ 

The [[to_int]] function checks that the [[bits]] value can be
represented as a positive integer and raises [[Overflow]] otherwise. 

<<bits.ml ((residualizing))>>=
(*let to_int (width,uint64) =
    if uint64 > I.of_int(max_int) then
        raise (Overflow)
    else
        I.to_int uint64*)
(*let to_int dBits = raise (BTA "Can't convert to integer")*)

let bitPC = Tdpe.pair(Tdpe.a',Tdpe.a')
  
let to_int ((tag,bitv),w) =
  match tag with
    INT -> bitv
  | NINT ->
      (match bitv with
        Sy.INT64 i64 -> Sy.INT (Int64.to_int i64)
      | Sy.NINT ni -> bitv
      | Sy.INT _ -> bitv
      | _ ->
          (*let (v,w1) = Tdpe.nbe' (Tdpe.arrowN(Tdpe.a',Tdpe.arrowN(Tdpe.a',bitPC)))
             (Syntax.VAR "Bits.of_nativeint") bitv (Sy.INT w) in
             Tdpe.nbe' (Tdpe.arrow(bitPC,Tdpe.a'))
             (Syntax.VAR "Bits.to_int") (v,Sy.INT w)*)
          Tdpe.nbe' (Tdpe.arrowN(Tdpe.a',Tdpe.a'))
            (Syntax.VAR "Nativeint.to_int") bitv
      )
  | INT64 ->
      (match bitv with
        Sy.INT64 _ -> bitv
      | Sy.NINT ni -> Sy.INT64 (Int64.of_nativeint ni)
      | Sy.INT i -> Sy.INT64 (Int64.of_int i)
      | _ ->
          let (v,w1) = Tdpe.nbe' (Tdpe.arrowN(Tdpe.a',Tdpe.arrowN(Tdpe.a',bitPC)))
              (Syntax.VAR "Bits.of_int64")  bitv (Sy.INT w) in (* Bogus? *)
          Tdpe.nbe' (Tdpe.arrow(Tdpe.pair(Tdpe.a',Tdpe.a'),Tdpe.a'))
            (Syntax.VAR "Bits.to_int") (v,Sy.INT w))
  | BV -> Tdpe.nbe' (Tdpe.arrow(bitPC,Tdpe.a'))
        (Syntax.VAR "Bits.to_int") (bitv,Sy.INT w)

            

@
Similarly for native integers.  The test is bogus, but there's no easy
way to find out if [[width]] is small enough to fit into the width of
[[nativeint]], because we're not given the width of [[nativeint]].
<<bits.ml ((residualizing))>>=
(*let to_nativeint (width,uint64) =
    if I.logand uint64 (I.of_nativeint Nativeint.max_int) = uint64 then
        I.to_nativeint uint64
    else
        raise (Overflow)*)
let to_nativeint dBits = raise (BTA "Can't convert to native int")

@
This is buggy: the [[I.to_string]] function considers the [[bits]]
value as a signed integer. We also ignore the radix for the moment.

<<bits.ml ((residualizing))>>=
type radix      = Oct
                | Dec
                | Hex

(*let to_string radix (width,uint64) = I.to_string uint64 (* wrong *)*)
let to_string radix dBits = raise (BTA "Can't convert to string")
@

% ------------------------------------------------------------------ 
\subsubsection{Operations on [[bits]]}
% ------------------------------------------------------------------ 

<<bits.ml ((residualizing))>>=
let zero w =
    let z = U.of_int 0 in
    ( check w z
    ; mkBitsINT w 0
    )
@

