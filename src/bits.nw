% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

% ------------------------------------------------------------------ 
\section{Bits -- low level representation of values}
% ------------------------------------------------------------------ 

Values in {\PAL} can be either of type [[bool]] or [[bits]].  While
[[bool]] values can be represented by the {\ocaml} type [[bool]],
[[bits]] require a data structure.  Conceptually a [[bits]] value can
hold a declared but arbitrary large number of bits. 

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

A [[bits]] value has a [[width]] which is the number of bits it can
hold. The conversion of [[bits]] from and to other representations can
cause overflows which are reported by an exception [[Overflow]].
Requests for an unsupported [[width]] results in a [[Size]] exception.
Currently 64 bits and less are supported.

<<bits.mli>>=
type bits
type width      = int

The width of a [[bits]] value is determined when it is created. The
[[width]] function provides access to it. In case the requested size
is not supported by the implementation [[Size]] is raised.

<<>>=
val width       : bits -> width
@

% ------------------------------------------------------------------ 
\subsubsection{Creation of \texttt{bits} values}
% ------------------------------------------------------------------ 

A [[bits]] value is usuallu created from a string representation as
part of a {\PAL} source program. The string representation include
integer, floating point, and character representations:

\begin{enumerate}
\item The integer string representation can use a decimal, octal, or
      hexadecimal radix.  The characters to represent the respective
      radices in strings are shown below.  Conversion to and from
      strings always considers a [[bits]] value as an unsigned
      integer.

      \begin{quote}
        \begin{tabularx}{\hsize}{ll}
        Radix        & characters \\
        \hline
        octal        & \ttfamily 0 1 2 3 4 5 6 7     \\
        decimal      & \ttfamily 0 1 2 3 4 5 6 7 8 9 \\
        hexadecimal  & \ttfamily 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F \\
        \end{tabular}
      \end{quote}
 
      The radix of a string is determined by its first two characters:

      \begin{itemize}
      \item A string starting with [[0x]] or [[0X]] is considered a
            hexadecimal number.
      \item A string starting with [[0]] is considered a string of octal
            numbers.
      \item All other strings are considered as strings with decimal numbers.
      \end{itemize}

      A [[Failure "of_string"]] exception is raised when the string
      contains illegal characters. 

\item The floating point representation [[float]] can be decribed by the
      following small grammar that is also used in the {\PAL} lexer:

      \begin{quote}
      \begin{verbatim}
let digit       = ['0'-'9']
let nat         = digit+
let frac        = nat '.' nat
let exp         = ['e''E'] sign? nat
let float       = frac exp? 
                | nat exp
      \end{verbatim}
      \end{quote}

\item The character representation honors the C escape sequences.
      Otherwise stands each character for itself.
      
       \begin{quote}
        \begin{tabular}{ll}
            Escape Sequence & Interpretation \\ 
            \hline
            [[\a]]          & Alert (Bell) \\
            [[\b]]          & Backspace    \\
            [[\f]]          & Formfeed     \\
            [[\n]]          & Newline      \\
            [[\r]]          & Carriage Return \\
            [[\t]]          & Horizontal Tab \\
            [[\\]]          & Backslash    \\
            [[\']]          & Single Quote \\
            [[\"]]          & Double Quote \\
            [[\?]]          & Question Mark \\
            [[\x]]$\{\textit{hexdigit}\}$ 
                            & The value of \textit{hexdigit} sequence \\
            [[\]] $\{\textit{octdigit}\}$ 
                            & The value of \textit{octdigit} sequence \\
        \end{tabular}
        \end{quote} 
\end{itemize}

The following functions create [[bits]] values from strings. The
exception [[E.Error]] is raised in case of syntactical errors of the
string representation.  [[Size]] is raised when the requested
[[[width]] is not supported by the implementation.  [[Overflow]] is
raised when the specified [[width]] is too small to hold the value
given by the string representation.

<<>>=
exception Overflow
exception Size

<<>>=
val of_stringi  : string -> width -> bits (* Size, Overflow, Error *)
val of_stringf  : string -> width -> bits
val of_stringc  : string -> width -> bits
@

A [[bits]] value can be also created from an integer ([[of_int]]).

<<>>=
val of_int      : int    -> width -> bits  (* Size *)
val of_int64    : int64  -> width -> bits  (* Size *)
@

% ------------------------------------------------------------------ 
\subsubsection{Converting \texttt{bits} values}
% ------------------------------------------------------------------ 

A [[bits]] value can be converted to an integer or string.  If the
[[bits]] do not fit into an [[int]], [[Overflow]] is raised. 

<<>>=
type radix      = Oct
                | Dec
                | Hex

val to_int      : bits -> int                       (* raises Overflow *)
val to_string   : radix option -> bits -> string    
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

A [[bits]] is represented as an [[int64]].  The reason not to
implement arbitrary large bit vectors is the need for IEEE 754
floating point operations:  an [[int64]] value can be considered as a
C [[float]] value of 64 bits for which floating point operations are
available. Unsigned operations on [[int64]] values are provided by the
[[Uint64]] module.

<<bits.ml>>=
module E = Error
module I = Int64        (* signed   operations *)
module U = Uint64       (* unsigned operations *)

exception Overflow
exception Size
@

% ------------------------------------------------------------------ 
\subsubsection{Auxiliaries}
% ------------------------------------------------------------------ 

Values of type [[bits]] are represented as pairs of width and value.

<<>>=
type width      = int
type bits       = width * int64
@

Operations on [[bits]] frequently must [[check]] that the requested
with is inside the implementation's limits and an actual value fits
into that many bits.  The [[check]] function raises [[Size]] or
[[Overflow]] in case the mentioned rules are violated.
 
<<>>=
let check width uint64 =
    if (width <= 0) || (width > 64) then
        raise Size
    else if (width < 64) && (U.ge uint64 (U.shl width I.one)) then
        raise Overflow
    else 
        () (* ok *)
@

% ------------------------------------------------------------------ 
\subsubsection{Creation of \texttt{bits} values}
% ------------------------------------------------------------------ 

<<>>=
let of_stringi str width =
    let len    = String.length str in
    let uint64 = ( match str.[0] with
                 | '0' when len > 1 -> U.of_string ("0o"^str)
                 | _                -> U.of_string str
                 ) in
        try
            ( check width uint64
            ; (width,uint64)
            )
        with
            Failure _ -> E.error ("syntax error in constant: "^str)
         
<<>>=        
let of_stringf str width =
    if   width <> 64 
    then raise Size
    else try (width,U.of_float (float_of_string str)) with
         | Failure _ -> E.error ("syntax error in constant: "^str)

<<>>=
let of_stringc str width =
    let len = String.length str in
    let c   = 
            try
                if   len = 0 
                then assert false
                else if str.[0] = '\\' && len > 1 
                then match str.[1] with
                | 'a'  when len = 2 -> U.of_int 7
                | 'b'  when len = 2 -> U.of_int 8
                | 'n'  when len = 2 -> U.of_int 10
                | 'r'  when len = 2 -> U.of_int 13
                | 't'  when len = 2 -> U.of_int 9
                | '\\' when len = 2 -> U.of_int 92
                | '\'' when len = 2 -> U.of_int 39
                | '"'  when len = 2 -> U.of_int 34
                | '?'  when len = 2 -> U.of_int 63
                | 'x'  when len = 2 -> U.of_string ("0"  ^ str)
                | '0' .. '7'        -> U.of_string ("0o" ^ str) 
                | _                 -> E.error ("syntax error: "^str)
                else                   E.error ("syntax error: "^str)
            with Failure _          -> E.error ("syntax error: "^str)
        in
            ( check width c
            ; (width, c)
            ) 
    
<<>>=
let of_int width i =
    let uint64 = U.of_int i in
        ( check width uint64
        ; (width,uint64)
        )
<<>>=
let of_int64 width i =
    ( check width i
    ; (width,i)
    )
@
    
% ------------------------------------------------------------------ 
\subsubsection{Conversions}
% ------------------------------------------------------------------ 

The [[to_int]] function checks that the [[bits]] value can be
represented as a positive integer and raises [[Overflow]] otherwise. 

<<>>=
let to_int (width,uint64) =
    if uint64 > I.of_int(max_int) then
        raise (Overflow)
    else
        I.to_int uint64
@
This is buggy: the [[I.to_string]] function considers the [[bits]]
value as a signed integer. We also ignore the radix for the moment.

<<>>=        
let to_string radix (width,uint64) = I.to_string uint64 (* wrong *)
@

% ------------------------------------------------------------------ 
\subsubsection{Operations on [[bits]]}
% ------------------------------------------------------------------ 


