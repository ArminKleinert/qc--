% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

% ------------------------------------------------------------------ 
\section{Bits -- low level representation of values}
% ------------------------------------------------------------------ 

Values in {\PAL} can be either of type [[bool]] or [[bits]].  While
[[bool]] values can be represented by the {\ocaml} type [[bool]],
[[bits]] require a data structure.  Conceptually a [[bits]] value can
hold a declared but arbitrary large number of bits. 

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

A [[bits]] value has a [[width]] which is the number of bits it can
hold. The conversion of [[bits]] from and to other representations can
cause overflows which are reported by an exception [[Overflow]].
Requests for an unsupported [[width]] results in a [[Size]] exception.
Currently 64 bits and less are supported.

<<bits.mli>>=
type bits
type width      = int
@

The width of a [[bits]] value is determined when it is created. The
[[width]] function provides access to it. In case the requested size
is not supported by the implementation [[Size]] is raised. The
[[maxwidth]] is the maximal width supported by an implementation.

<<>>=
val width       : bits -> width
val maxwidth    : width
@

The [[fits]] predicate is true, if and only if a given [[bits]] value
fits into width.  N.B. this is a property of the \emph{width} of the
argument, not of its \emph{value}.  In particular, a 32-bit
representation of the integer~1 does not ``[[fits]]'' into 16~bits,
even though the value can easily be represented in 16~bits.

The width must mot be greater than [[maxwidth]],
otherwise the [[Size]] exception is raised which indicates a problem
with the limits of an implementation.

<<>>=
val fits        : bits -> width -> bool
@

The [[setSize]] function updates the size information of a [[bits]]
value. This is a dangerous operation since the new size may violate
the assumption that the current value fits into that size. Thus,
[[Overflow]] is raised, when this assumption is violated by the new size.

<<>>=
val setSize     : bits -> width -> bits
@

% ------------------------------------------------------------------ 
\subsubsection{Creation of \texttt{bits} values}
% ------------------------------------------------------------------ 

A [[bits]] value is usuallu created from a string representation as
part of a {\PAL} source program. The string representation include
integer, floating point, and character representations:

\begin{enumerate}
\item The integer string representation can use a decimal, octal, or
      hexadecimal radix.  The characters to represent the respective
      radices in strings are shown below.  Conversion to and from
      strings always considers a [[bits]] value as an unsigned
      integer.

        \begin{tabular}{ll}
        Radix        & characters \\
        \hline
        octal        & \ttfamily 0 1 2 3 4 5 6 7     \\
        decimal      & \ttfamily 0 1 2 3 4 5 6 7 8 9 \\
        hexadecimal  & \ttfamily 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F \\
        \end{tabular}
 
      The radix of a string is determined by its first two characters:

      \begin{itemize}
      \item A string starting with [[0x]] or [[0X]] is considered a
            hexadecimal number.
      \item A string starting with [[0]] is considered a string of octal
            numbers.
      \item All other strings are considered as strings with decimal numbers.
      \end{itemize}

      A [[Failure "of_string"]] exception is raised when the string
      contains illegal characters. 

\item The floating point representation [[float]] can be decribed by the
      following small grammar that is also used in the {\PAL} lexer:

      \begin{quote}
      \begin{verbatim}
    let digit       = ['0'-'9']
    let nat         = digit+
    let frac        = nat '.' nat
    let exp         = ['e''E'] sign? nat
    let float       = frac exp? 
                    | nat exp
      \end{verbatim}
      \end{quote}

\item The character representation honors the C escape sequences.
      Otherwise stands each character for itself.
      
       \begin{quote}
        \begin{tabular}{ll}
            Escape Sequence & Interpretation \\ 
            \hline
            [[\a]]          & Alert (Bell) \\
            [[\b]]          & Backspace    \\
            [[\f]]          & Formfeed     \\
            [[\n]]          & Newline      \\
            [[\r]]          & Carriage Return \\
            [[\t]]          & Horizontal Tab \\
            [[\\]]          & Backslash    \\
            [[\']]          & Single Quote \\
            [[\"]]          & Double Quote \\
            [[\?]]          & Question Mark \\
            [[\x]]$\{\textit{hexdigit}\}$ 
                            & The value of \textit{hexdigit} sequence \\
            [[\]] $\{\textit{octdigit}\}$ 
                            & The value of \textit{octdigit} sequence \\
        \end{tabular}
        \end{quote} 
\end{enumerate}

The following functions create [[bits]] values from strings. The
exception [[E.Error]] is raised in case of syntactical errors of the
string representation.  [[Size]] is raised when the requested
[[[width]] is not supported by the implementation.  [[Overflow]] is
raised when the specified [[width]] is too small to hold the value
given by the string representation.

<<>>=
exception Overflow
exception Size

<<>>=
val of_stringi  : string -> width -> bits (* Size, Overflow, Error *)
val of_stringf  : string -> width -> bits
val of_stringc  : string -> width -> bits
@

[[bits]] values can be created from integers.
<<>>=
val of_int       : int       -> width -> bits  (* Size *)
val of_int64     : int64     -> width -> bits  (* Size *)
val of_nativeint : nativeint -> width -> bits  (* Size *)
@

% ------------------------------------------------------------------ 
\subsubsection{Converting \texttt{bits} values}
% ------------------------------------------------------------------ 

A [[bits]] value can be converted to an integer or string.  If the
[[bits]] do not fit into an [[int]], [[Overflow]] is raised. 

<<>>=
type radix      = Oct
                | Dec
                | Hex

val to_int      : bits -> int                       (* raises Overflow *)
val to_nativeint : bits -> nativeint                (* raises Overflow *)
val to_string   : radix option -> bits -> string    
@

% ------------------------------------------------------------------ 
\subsubsection{Operations on [[bits]]}
% ------------------------------------------------------------------ 

<<>>=
val zero        : width -> bits
@


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

A [[bits]] is represented as an [[int64]].  The reason not to
implement arbitrary large bit vectors is the need for IEEE 754
floating point operations:  an [[int64]] value can be considered as a
C [[float]] value of 64 bits for which floating point operations are
available. Unsigned operations on [[int64]] values are provided by the
[[Uint64]] module.

<<bits.ml>>=
module E = Error
module I = Int64        (* signed   operations *)
module U = Uint64       (* unsigned operations *)

exception Overflow
exception Size
@

% ------------------------------------------------------------------ 
\subsubsection{Auxiliaries}
% ------------------------------------------------------------------ 

Values of type [[bits]] are represented as pairs of width and value.

<<>>=
type width      = int
type bits       = width * int64
@

<<>>=
let maxwidth    = 64
let width (w,_) = w
@

Operations on [[bits]] frequently must [[check]] that the requested
with is inside the implementation's limits and an actual value fits
into that many bits.  The [[check]] function raises [[Size]] or
[[Overflow]] in case the mentioned rules are violated.

<<>>=
let fits (width',bits) width =
    if (width <= 0) || (width > 64) 
    then raise Size
    else (width = 64) || (U.le bits (U.shl width I.one))
@

 
<<>>=
let check width uint64 =
    if not (fits (maxwidth,uint64) width)
    then raise Overflow
    else () (* ok *)
@

[[setSize]] sets the size of a [[bits]] value and raises [[Overflow]]
in case the size is too small.

<<>>=
let setSize (w,b as bits) width =
    if not (fits bits width)
    then raise Overflow
    else (width,b)
@

% ------------------------------------------------------------------ 
\subsubsection{Creation of \texttt{bits} values}
% ------------------------------------------------------------------ 

<<>>=
let of_stringi str width =
    let len    = String.length str in
    let uint64 = ( match str.[0] with
                 | '0' when len > 1 -> U.of_string ("0o"^str)
                 | _                -> U.of_string str
                 ) in
        try
            ( check width uint64
            ; (width,uint64)
            )
        with
            Failure _ -> E.error ("syntax error in constant: "^str)
         
<<>>=        
let of_stringf str width =
    if   width <> 64 
    then raise Size
    else try (width,U.of_float (float_of_string str)) with
         | Failure _ -> E.error ("syntax error in constant: "^str)

<<>>=
let of_stringc str width =
    let len = String.length str in
    let c   = 
            try
                if   len = 0 
                then assert false
                else if str.[0] = '\\' && len > 1 
                then match str.[1] with
                | 'a'  when len = 2 -> U.of_int 7
                | 'b'  when len = 2 -> U.of_int 8
                | 'n'  when len = 2 -> U.of_int 10
                | 'r'  when len = 2 -> U.of_int 13
                | 't'  when len = 2 -> U.of_int 9
                | '\\' when len = 2 -> U.of_int 92
                | '\'' when len = 2 -> U.of_int 39
                | '"'  when len = 2 -> U.of_int 34
                | '?'  when len = 2 -> U.of_int 63
                | 'x'  when len = 2 -> U.of_string ("0"  ^ str)
                | '0' .. '7'        -> U.of_string ("0o" ^ str) 
                | _                 -> E.error ("syntax error: "^str)
                else                   U.of_int (Char.code str.[0])
            with Failure _          -> E.error ("syntax error: "^str)
        in
            ( check width c
            ; (width, c)
            ) 
    
<<>>=
let of_int i width =
    let uint64 = U.of_int i in
        ( check width uint64
        ; (width,uint64)
        )
<<>>=
let of_int64 i width =
    ( check width i
    ; (width,i)
    )

let of_nativeint i width = of_int64 (I.of_nativeint i) width
@
    
% ------------------------------------------------------------------ 
\subsubsection{Conversions}
% ------------------------------------------------------------------ 

The [[to_int]] function checks that the [[bits]] value can be
represented as a positive integer and raises [[Overflow]] otherwise. 

<<>>=
let to_int (width,uint64) =
    if uint64 > I.of_int(max_int) then
        raise (Overflow)
    else
        I.to_int uint64
@ 
Similarly for native integers.  The test is bogus, but there's no easy
way to find out if [[width]] is small enough to fit into the width of
[[nativeint]], because we're not given the width of [[nativeint]].
<<>>=
let to_nativeint (width,uint64) =
    if I.logand uint64 (I.of_nativeint Nativeint.max_int) = uint64 then
        I.to_nativeint uint64
    else
        raise (Overflow)
@
This is buggy: the [[I.to_string]] function considers the [[bits]]
value as a signed integer. We also ignore the radix for the moment.

<<>>=
type radix      = Oct
                | Dec
                | Hex

let to_string radix (width,uint64) = I.to_string uint64 (* wrong *)
@

% ------------------------------------------------------------------ 
\subsubsection{Operations on [[bits]]}
% ------------------------------------------------------------------ 

<<>>=
let zero w =
    let z = U.of_int 0 in
    ( check w z
    ; (w,z) 
    )
@

