% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Control-Flow Graph Utilities}
% ------------------------------------------------------------------ 

The \module{cfg3} module provides the essential functionality for
control-flow graphs ({\cfg}s). In order to separate essential
functionality from nice-to-have functionality this module provides
additional functions on {\cfg}s whose implementation do not require
knowledge of the internal details of \module{cfg3}.

\begin{quote}\it
    As the number of functions grows it might be useful to organize them
    in sub-modules, similar to module \module{rtlutil}. --CL
\end{quote}

<<cfgutil.mli>>=
type cfg  = Cfg4.cfg
type node = Cfg4.node

val first   :   cfg -> int        (* number of first node -- req enumerated *)
val limit   :   cfg -> int        (* limiting number      -- req enumerated *)
val fold_fwd:   cfg -> (node -> 'a -> 'a) -> 'a -> 'a
val fold_bwd:   cfg -> (node -> 'a -> 'a) -> 'a -> 'a
val subst:      cfg -> (Rtl.rtl -> Rtl.rtl) -> unit
val cfg2dot:    compress:bool -> name:string -> cfg -> string
val emit    :   cfg -> (Rtl.rtl -> unit) -> (string -> unit) -> unit
val new_cfg2dot:    compress:bool -> name:string -> Rtl.rtl Cfgx.M.t -> string
val new_cfg2ast: ('i -> Ast.stmt) -> 'i Cfgx.M.t -> name:string -> Ast.proc
val new_emit  :   'i Cfgx.M.t -> ('i -> unit) -> (string -> unit) -> unit
@

\begin{itemize}
\item [[limit]], [[first]]: node numbers for {\cfg} traversing functions 
      in \module{cfg3}.
      
\item [[fold_fwd]], [[fold_bwd]]: work as their counterparts in [[Cfg]]
      except that they cover the entire {\cfg}. Note, that the [[cfg]]'s
      nodes must be enumerated.

\item [[subst]] substitutes {\rtl}s in all nodes of a [[cfg]].       

\item [[cfg2dot]]: returns a {\cfg} in the \textsc{dot} input language.
       The parameter [[compress]] tells \texttt{dot} to compress the
      output graph to fit on one sheet of paper (\texttt{ratio=compress}).

\item [[emit]]: Fold over {\cfg} in enumeration order and pass {\rtl}s
      and symbols to the provided functions. Enumerates the {\cfg} if is
      not already enumerated.
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

No surprises here.

<<cfgutil.ml>>=
module G  = Cfg4
type cfg  = G.cfg
type node = G.node
@

The [[G.fold]] functions use open intervals to specify a region to fold
over.  

<<cfgutil.ml>>=
let first cfg = G.number (G.first cfg)     (* smallest number *)
let limit cfg = G.number (G.last  cfg) + 1 (* highest number + 1 *)

let fold_fwd cfg f unit =
  G.gm_enumerate cfg;
  G.scan_fwd cfg ~first:(first cfg) ~limit:(limit cfg) f unit

let fold_bwd cfg f unit =
  G.gm_enumerate cfg;
  G.scan_bwd cfg ~first:(first cfg) ~limit:(limit cfg) f unit

let subst cfg (f:Rtl.rtl -> Rtl.rtl) = 
    fold_fwd cfg (fun node () -> G.upd_instr node f) () 
@ 

<<cfgutil.ml>>=
let emit cfg rtl_emit sym_emit =
    G.gm_enumerate cfg;
    let visit node () = match G.symbol node with
        | None   -> rtl_emit (G.instr node) 
        | Some s -> sym_emit (s#original_text)     (* skip null rtl of label nodes *) 
    in    
        fold_fwd cfg visit ()
        

<<cfgutil.ml>>=
let new_emit cfg rtl_emit sym_emit =
  let module G = Cfgx.M in
  let labels n = if G.kind n = G.Join then G.labels n else [] in
  let visit node =
    List.iter sym_emit (labels node);
    match G.to_instr node with
    | None   -> ()
    | Some i -> rtl_emit i in
  G.fold_nodes (fun n () -> visit n) () cfg
        

<<cfgutil.ml>>=
let number_and_rtl node =
    ( string_of_int (G.number node)
    ^ ": " 
   (**) 
    ^ String.escaped (Rtlutil.ToReadableString.rtl (G.instr node))
    (**)
    )

let cfg2dot ~compress ~name cfg =
  let nodename node = Printf.sprintf "\"N%d\"" (G.number node) in
  let dotnode  node = nodename node ^ " [label=\"" ^ number_and_rtl node ^ "\"]" in
  let edge_fwd from to' = nodename from ^ " -> " ^ nodename to'  ^ "\n" in
  let edge_bwd from to' = nodename to'  ^ " -> " ^ nodename from ^
                         "[dir=back,style=dotted]\n" in
  let edges_leaving node = (* quadratic! *)
    let add_edge dir edges n = dir node n ^ edges in
    let fwd = List.fold_left (add_edge edge_fwd) ""  (G.succ node) in
    let bwd = List.fold_left (add_edge edge_bwd) "" (G.pred node) in
    fwd ^ bwd in
  let _ = G.gm_enumerate cfg in
  let oldv = Rtlutil.ToAST.verbosity Rtlutil.ToAST.Low in
  let dotOpenGraph = "digraph " ^ name ^ " {\n" in
  let pagesize = "  page=\"8,10.5\"\n" in
  let compress = if compress then "  ratio=compress\n" else "" in
  let dotCloseGraph = "}\n" in
  let dotnodes = fold_bwd cfg (fun node rst -> dotnode node ^ "\n" ^ rst) "" in
  let dotedges = fold_bwd cfg (fun node rst -> edges_leaving node ^ rst) "" in
  let _ = Rtlutil.ToAST.verbosity oldv in
    dotOpenGraph ^ pagesize ^ compress ^ dotnodes ^ dotedges ^ dotCloseGraph

let extend_with preds nodes =
  let module G = Cfgx.M in
  let rec add_predecessors visited candidates = match candidates with
  | [] -> visited
  | node :: candidates ->
      if List.exists (G.eq node) visited then
        add_predecessors visited candidates
      else
        add_predecessors (node :: visited) (preds node @ candidates) in
  add_predecessors nodes (List.flatten (List.map preds nodes))

let new_cfg2dot ~compress ~name g =
  let module G = Cfgx.M in
  let original_nodes = G.fold_nodes (fun x y -> x :: y) [] g in
  let nodes = extend_with G.preds original_nodes in
  let nodes = extend_with G.succs nodes in
  let nnodes = Aux.foldri (fun i n ns -> (i, n) :: ns) nodes [] in
  let number node = fst (List.find (fun (i, n) -> G.eq node n) nnodes) in
  let nodename node = Printf.sprintf "\"N%d\"" (number node) in
  let number_and_rtl node =
    (if List.exists (G.eq node) original_nodes then "" else "*") ^
    let tag = "N" ^ string_of_int (number node) in
    match G.to_instr node with
    | Some rtl -> tag ^ ": " ^ String.escaped (Rtlutil.ToReadableString.rtl rtl)
    | None ->
        match G.kind node with
        | G.Join -> List.fold_right (fun l t -> l ^ ": " ^ t) (G.labels node) tag
        | G.Entry -> "Entry"
        | G.Exit  -> "Exit"
        | G.Illegal -> "<illegal>"
        | G.Impossible -> "<impossible>"
        | _ -> tag ^ "???" in
  let dotnode  node = nodename node ^ " [label=\"" ^ number_and_rtl node ^ "\"]" in
  let edge_fwd from to' = nodename from ^ " -> " ^ nodename to'  ^ "\n" in
  let edge_bwd from to' = nodename to'  ^ " -> " ^ nodename from ^
                         "[dir=back,style=dotted]\n" in
  let edges_leaving node tail =
    let add_edge dir edges n = dir node n :: edges in
    let tail = List.fold_left (add_edge edge_fwd) tail (G.succs node) in
    let tail = List.fold_left (add_edge edge_bwd) tail (G.preds node) in
    tail in
  let oldv = Rtlutil.ToAST.verbosity Rtlutil.ToAST.Low in
  let openg  = "digraph " ^ name ^ " {\n" in
  let closeg = "}\n" in
  let pagesize = "  page=\"8,10.5\"\n" in
  let compress = if compress then "  ratio=compress\n" else "" in
  let body = List.fold_right (fun n t -> edges_leaving n t)      nodes [closeg] in
  let body = List.fold_right (fun n t -> dotnode n :: "\n" :: t) nodes body     in
  let _ = Rtlutil.ToAST.verbosity oldv in
  String.concat "" (openg :: pagesize :: compress :: body)
@
THE FOLLOWING CODE IS BOGUS --- IT ACTUALLY NEEDS TO VISIT THE NODES
IN LAYOUT ORDER.
<<cfgutil.ml>>=
let new_cfg2ast instr g ~name =
  let module G = Cfgx.M in
  let module A = Ast in
  let node n tail = match G.to_instr n with
  | Some i ->
      let is = instr i :: tail in
      if G.kind n = G.Assertion then
        A.CommentStmt "the following node is merely asserted" :: is
      else
        is 
  | None ->
      match G.kind n with
      | G.Join -> List.fold_right (fun l t -> A.LabelStmt l :: t) (G.labels n) tail
      | G.Entry | G.Exit | G.Impossible -> tail
      | G.Illegal -> A.CommentStmt "dangling pointer in flow graph" :: tail
      | _ -> A.CommentStmt("unknown kind of node") :: tail
  in
  let graph = G.fold_nodes node [] g in
    ( None
    , name
    , []
    , List.map (fun s -> Ast.StmtBody s) graph
    )
