% -*- mode: Noweb; noweb-code-mode: caml-mode -*-


% ------------------------------------------------------------------ 
\section{Control-Flow Graph Utilities}
% ------------------------------------------------------------------ 

The \module{cfg3} module provides the essential functionality for
control-flow graphs ({\cfg}s). In order to separate essential
functionality from nice-to-have functionality this module provides
additional functions on {\cfg}s whose implementation do not require
knowledge of the internal details of \module{cfg3}.

\begin{quote}\it
    As the number of functions grows it might be useful to organize them
    in sub-modules, similar to module \module{rtlutil}. --CL
\end{quote}

<<cfgutil.mli>>=
type cfg  = Cfg3.cfg
type node = Cfg3.node

val first   :   cfg -> int        (* number of first node -- req enumerated *)
val limit   :   cfg -> int        (* limiting number      -- req enumerated *)
val fold_fwd:   cfg -> (node -> 'a -> 'a) -> 'a -> 'a
val fold_bwd:   cfg -> (node -> 'a -> 'a) -> 'a -> 'a
val subst:      cfg -> (Rtl.rtl -> Rtl.rtl) -> unit
val cfg2dot:    compress:bool -> name:string -> cfg -> string
val number_and_rtl : node -> string
@

\begin{itemize}
\item [[limit]], [[first]]: node numbers for {\cfg} traversing functions 
      in \module{cfg3}.
      
\item [[fold_fwd]], [[fold_bwd]]: work as their counterparts in [[Cfg3]]
      except that they cover the entire {\cfg}. Note, that the [[cfg]]'s
      nodes must be enumerated.

\item [[subst]] substitutes {\rtl}s in all nodes of a [[cfg]].       

\item [[cfg2dot]]: returns a {\cfg} in the \textsc{dot} input language.
       What does [[compress]]?

\item [[number_and_rtl]]: some documentation would be welcome.
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

No surprises here.

<<cfgutil.ml>>=
module G  = Cfg3
type cfg  = G.cfg
type node = G.node
@

The [[G.fold]] functions use open intervals to specify a region to fold
over.  

<<cfgutil.ml>>=
let first cfg = G.number (G.first cfg)     (* smallest number *)
let limit cfg = G.number (G.last  cfg) + 1 (* highest number + 1 *)

let fold_fwd cfg f unit =
  G.gm_enumerate cfg;
  G.scan_fwd cfg (first cfg) (limit cfg) f unit

let fold_bwd cfg f unit =
  G.gm_enumerate cfg;
  G.scan_bwd cfg (first cfg) (limit cfg) f unit

let subst cfg (f: Rtl.rtl -> Rtl.rtl) = 
    fold_fwd cfg (fun node () -> G.set_rtl node f) () 
@ 
<<cfgutil.ml>>=
module Cfg = Cfg3
let number_and_rtl node =
  string_of_int (Cfg.number node) ^ ": " ^ Rtlutil.ToString.rtl (Cfg.rtl node)

let cfg2dot compress name cfg =
  let nodename node = Printf.sprintf "N\"%d\"" (Cfg.number node) in
  let dotnode  node = nodename node ^ " [label=\"" ^ number_and_rtl node ^ "\"]" in
  let edge_fwd from to' = nodename from ^ " -> " ^ nodename to'  ^ "\n" in
  let edge_bwd from to' = nodename to'  ^ " -> " ^ nodename from ^
                         "[dir=back,style=dotted]\n" in
  let edges_leaving node = (* quadratic! *)
    let add_edge dir edges n = dir node n ^ edges in
    let fwd = List.fold_left (add_edge edge_fwd) ""  (Cfg.succ node) in
    let bwd = List.fold_left (add_edge edge_bwd) "" (Cfg.pred node) in
    fwd ^ bwd in
  let _ = Cfg.gm_enumerate cfg in
  let oldv = Rtlutil.ToAST.verbosity Rtlutil.ToAST.Low in
  let dotOpenGraph = "digraph " ^ name ^ " {\n" in
  let pagesize = "  size=\"8,10.5\"\n" in
  let compress = if compress then "  ratio=compress\n" else "" in
  let dotCloseGraph = "}\n" in
  let dotnodes = fold_bwd cfg (fun node rst -> dotnode node ^ "\n" ^ rst) "" in
  let dotedges = fold_bwd cfg (fun node rst -> edges_leaving node ^ rst) "" in
  let _ = Rtlutil.ToAST.verbosity oldv in
    dotOpenGraph ^ pagesize ^ compress ^ dotnodes ^ dotedges ^ dotCloseGraph
@

        


