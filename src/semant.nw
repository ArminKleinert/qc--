% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h substitution to ->

% ------------------------------------------------------------------ 
\section{Checking Static Semantics}
% ------------------------------------------------------------------  

In C~many symbols like procedures and constants have the compilation
unit as their scope. In order to check that all used names are indeed
declared checking is done in a stepwise approach:

\begin{enumerate}
\item Global symbols are entered into a symbol table. Except for 
      constants the types of all these symbols are known and entered into
      the table, too. For constants the abstract syntax of the defining
      expression is entered into the symbol table.

\item Constant evaluation and constant type checking. All constants in the
      symbol table are evaluated and type checked. The result of type and
      value replaces the abstract syntax in the symbol table.

\item With all global symbols and their types in the symbol table the
      a top-down traversal of the abstract syntax can check the static
      semantics (and emit intermediate code).
\end{enumerate}


% ------------------------------------------------------------------ 
\subsection{Symbol Table}
% ------------------------------------------------------------------ 

The symbol table maps identifiers [[id]] to their \textit{type} and
\textit{kind} ([[entry]]).  Since not all values of the same type are
interchangeable kinds distinguish between memory locations, registers,
and constants.  Constants have a value; before constants are evaluated
the value of a constant is the abstract syntax of the defining
expression.
 
<<symtab>>=
type value      = CharConst     of char
                | IntConst      of int
                | FloatConst    of float
                | BoolConst     of bool
                | ExprConst     of Ast.expr

type kind       = Register
                | Memory 
                | Continuation
                | Constant      of value

type id         = string


module ID       = struct type t=id let compare=compare end
module IDSet    = Set.Make(ID)
module Symbol   = Env.Make(ID)

type entry      = (Types.ty * kind) Error.error
type env        = entry Symbol.env
@

In \C~global symbols are never re-declared.  Thus a global symbol
should never be entered into the symbol table when the same symbol is
already part of it.  The [[enter]] function checks for this.  However,
during the evaluation of constants an existing entry for a constant
must be replaced with the one that holds the actual type and value of
a constant.  The [[shadow]] function allows to use the original


<<>>=
let enter key v env =
    if Symbol.domain key env then
        error ("identifier already declared: " ^ key)
    else
        Symbol.enter key v env        

let enter_ok key v env = enter key (Ok v) env

let shadow key v env =
    Symbol.enter key v env

let shadow_ok key v env =
    Symbol.enter key (Ok v) env

let lookup x env = 
    ( try Symbol.lookup x env with 
    | ErrorExn _ -> error ("unkown identifier: "^x)
    )

@


The type of labels in code and data depends on the natural word size
of an architecture. Currently there is no way to specify them so we
make an assumpion about it. This has to be fixed later.

During the first pass the types of constants are unknown. In order to
keep things simple we do not introduce an [[option]] type but simply
abuse the [[bool]] type.


% ------------------------------------------------------------------ 
\subsection{Printing the Symbol Table}
% ------------------------------------------------------------------  

During development we would like to know what actually is inside a
symbol table.  We provide [[ppEnv]] to pretty-print a symbol table to
a [[Pp.doc]] value.  The document simply associates each entry in the
table with its [[kind]] and [[Types.ty]]. 

<<print module>>=
module Print = struct 
    <<print>>
end

<<print>>=
let (~~) x = x 

let ppValue = function
    | CharConst(c)  -> text "char("  ^^ text (Char.escaped c)  ^^ text ")"
    | IntConst(i)   -> text "int("   ^^ text (string_of_int i) ^^ text ")"
    | FloatConst(f) -> text "float(" ^^ text (string_of_float f) ^^ text ")"
    | BoolConst(b)  -> text "bool("  ^^ text (if b then "t" else "f") ^^ text ")"
    | ExprConst(e)  -> text "<expr>"

let ppKind = function
    | Register      -> text "register"
    | Memory        -> text "memory"
    | Continuation  -> text "continuation"
    | Constant(v)   -> text "constant:" ^/ ppValue v


let ppEntry (key,v) = 
    agrp begin
    ~~ text key ^^ text ":"
    ^^ ( match v with
       | Ok (ty,kind) -> 
            nest 4 begin
            ~~ break
            ^^ Types.ppTy ty
            ^/ text "/"
            ^/ ppKind kind
            end
       | Error -> text "<error>"
       )
    end
 
let ppEnv env =
    let entries = Symbol.dump env in
    vgrp begin
    ~~ list break ppEntry entries
    ^^ break
    end      
@


% ------------------------------------------------------------------  
\subsection{Collecting Global Symbols}
% ------------------------------------------------------------------ 

In the first phase global symbols are entered into an initially empty
symbol table.  Except for constants all global symbols are either
given their declared type or [[code]] in case they denote a
procedure and [[data]] in case of a data label.  The functions that
implement the first phase take a symbol table [[env]] as one of their
arguments and return an enlarged symbol table that contains the global
symbols.  In case of an error the symbol table at the place where the
error is caught is returned as a result.  This throws away all
additions to the symbol table from a deeper nesting.  Currently only
multiple definitions of symbols can cause errors in the first phase.


\begin{table}
    \begin{center}
    \begin{tabular}{lll}
        Object      & Kind              & Type \\ \hline
        Procedure   & [[Memory]]        & [[code]]  \\
        Code Label  & [[Memory]]        & [[code]]  \\
        Data Label  & [[Memory]]        & [[data]]     \\
        Register    & [[Register]]      & as declared  \\
        Import      & [[Memory]]        & as declared  \\
        Constant    & [[Constant]]      & [[dummy]]    \\
        Continuation& [[Continuation]]  & [[data]]     \\
    \end{tabular}
    \caption{Informations recored for global symbols}
    \label{tab:phase1}
    \end{center}
\end{table}

<<type aliases>>=
let bitsc x         = Types.Bits(Types.Const(x))
let bitsv x         = Types.Bits(Types.Var(x))
let bits  x         = Types.Bits(x)
let bool            = Types.Bool
let proc args res   = Types.Procedure(args,res)
let word            = bits 32   (* for now *)
let code            = bits 32
let data            = bits 16
let char            = bits 8
let uchar           = bits 16
let dummy           = bool
@

<<phase1 module>>=
module Phase1 = struct
    <<phase1>>
end

<<phase1>>=
let foldl = List.fold_left

let rec ty = function
    | TyAt(x,_)       -> ty x
    | BitsTy(n)       -> Types.Bits(n)
    | FloatTy(n)      -> Types.Bits(n)

let rec datum env = function
    | DatumAt(x,r)        -> catch' env (errorRegPrt r) (datum env) x
    | Label(n)            -> enter_ok n (data,Memory) env
    | _                   -> env
    
let formal env ( h, v, t, n) = env
let formals env xs = env

let register env ( v , t, n, reg) = enter_ok n (ty t, Register) env

let rec stmt env = function
    | StmtAt(x,r)             -> catch' env (errorRegPrt r) (stmt env) x
    | IfStmt ( e, ss1, ss2)   -> let env' = stmts env ss1 in
                                    stmts env' ss2 
    | LabelStmt(n)            -> enter_ok n (code,Memory) env
    | SpanStmt(e1,e2,ss)      -> stmts env ss
    | _                       -> env
    
and stmts env ss = foldl stmt env ss
@

Constants are entered unevaluated into the symbol table. Their type is
not yet known, as is their value. During a second phase these entries
are replaced by the correct types and values.

<<>>=
let constant env (name,expr) = 
    enter_ok name (dummy,Constant(ExprConst(expr))) env
    
let procedure env (cc,n,fs, ds, ss) = 
    let env' = enter_ok n (code,Memory) env in 
        stmts env' ss 
            
let rec section env = function
    | SectionAt(x,r)         -> catch' env (errorRegPrt r) (section env) x
    | SSpan( e1, e2, ss)     -> foldl section env ss
    | Datum( d)              -> datum env d
    | SExport (t, ns)        -> env
    | Procedure(p)           -> procedure env p

let rec topdecl env = function
    | TopDeclAt(x,r)  -> catch' env (errorRegPrt r) (topdecl env) x
    | Import( t, ns)  -> let entry = (ty t, Memory) in
                         foldl (fun env n -> enter_ok n entry env) env ns 
    | Export( t, ns)  -> env
    | Const ( cs)     -> foldl constant env cs
    | Section( n, ss) -> foldl section env ss
    | Registers( rs)  -> foldl register env rs
    | TopProcedure(p) -> procedure env p
    | Pragma          -> env

let program ds srcmap = 
    let env = Symbol.empty     in
        foldl topdecl env ds  

@

% ------------------------------------------------------------------  
\subsection{Constant Evaluation}
% ------------------------------------------------------------------ 

After the first phase of checking the static semantics all global
symbols are entered into a symbol table. All Constants are unevaluated and
their recorded types are incorrect. The second phase walks over the
symbol table and evaluates all constants. This includes inferring
their types.

A constant definition must: 

\begin{itemize}
\item not refer to other symbols except constants,
\item not be directly or indirectly refer to the symbol being defined.
\end{itemize}

Since constant definitions can refer to each other in any order their
evaluation takes some care.  Basically two approaches are feasible: 
The first:  record all use-relationships and sort them topologically. 
This results in an order that every constant is evaluated after all
constants are evaluated that it depends on.  Recording the
relationships would be best implemented in [[Phase1]].  The second: 
start evaluating any constant definition and recursively evaluate all
definitions of referenced constants.  The tricky part is not to
evaluate any constant definition twice in case a constant is used in
multiple other constants.

The code below implements the second approach that interleaves
constant evaluation, type checking, and updating the symbol table. 
Every function of the implementation takes besides the object to
evaluate two more arguments:  [[set]] and [[env]].  The set [[set]]
contains names of constants that are currently being defined and thus
should not be part of the object under evaluation.  In case one of the
names in [[set]] is found this means a circular definition was
detected.  The symbol table [[env]] is the current symbol table.  It
contains evaluated and unevaluated symbols.  Whenever a symbol is
evaluated its value and type replaces the entry in the current symbol
table.  Since symbol tables are purely functional the updated symbol
table must be returned and used in all subsequent evaluation to avoid
multiple evaluations.  Thus all functions return a triple of type,
value and updated symbol table.  Passing around the symbol table
implements the tricky part mentioned above. 

This evaluation technique could be called \textit{lazy} because
evaluation is driven by demand.  However, the driving function
[[eval]] makes sure all constant definitions are evaluated even those,
which are never used.

Constant definitions can use primitive operations which, of course,
are evaluated at compile-time.  The available primitive operations and
their types are hold in a table [[constOps]].  Construction functions
help to build the type-schemes describing their types.  Infix and
binary operators are as abbreviations to primitive operations.  For
example, [[+]] and [[%add]] share the same type and implementation
[[add]]. 

<<primitives module>>=
module Prim = struct
    <<primitives>>
end
    
<<primitives>>=

let add  = function
    | [IntConst(x);IntConst(y)] -> IntConst(x+y)
    | _                         -> error "illegal operands"

let mult  = function
    | [IntConst(x);IntConst(y)] -> IntConst(x*y)
    | _                         -> error "illegal operands"

let eq    = function
    | [IntConst(x);IntConst(y)] -> BoolConst(x=y)
    | _                         -> error "illegal operands"

let constOps = Symbol.enterList
    [  "add"    , (add  , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "+"      , (add  , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "mult"   , (mult , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "*"      , (mult , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "eq"     , (eq   , proc [bitsv 1; bitsv 1] bool)
    ;  "=="     , (eq   , proc [bitsv 1; bitsv 1] bool)
    ] Symbol.empty

let primOps = Symbol.enterList
    [  "add"    ,  proc [bitsv 1; bitsv 1] (bitsv 1)
    ;  "+"      ,  proc [bitsv 1; bitsv 1] (bitsv 1)
    ;  "sub"    ,  proc [bitsv 1; bitsv 1] (bitsv 1)
    ;  "-"      ,  proc [bitsv 1; bitsv 1] (bitsv 1)
    ;  "mult"   ,  proc [bitsv 1; bitsv 1] (bitsv 1)
    ;  "*"      ,  proc [bitsv 1; bitsv 1] (bitsv 1)
    ;  "eq"     ,  proc [bitsv 1; bitsv 1] bool
    ;  "=="     ,  proc [bitsv 1; bitsv 1] bool
    ] Symbol.empty

@

The evaluation of the constants in the symbol table starts by
collecting all (global) names in the symbol table that refer to
constants and then passing them to [[evalConst]] one by one. Once a
constant is evaluatated and type checked its entry in the symbol is
replaced by the correct type and value. When the evaluation of a
constant fails its definition is replaced by [[Error]].

<<phase2 module>>=
module Phase2 = struct
    open Prim

    <<eval>>
    <<driver>>
end

<<driver>>=
let eval env =
    let rec accConst id entry l = 
        ( match entry with
        | Ok (_, Constant(_)) -> id::l
        | _                   -> l
        ) in
    let keys = Symbol.fold accConst env [] in
    let eval env id = 
        ( match evalConstID IDSet.empty env id with
        | Ok(_,_,env') -> env'
        | Error        -> shadow id Error env
        ) 
     in
        foldl eval env keys    
@ 

All literals are stored in the abstract syntax as strings.  Some
functions with names borrowed from the C libaray (atoi $\equiv$ ascii
to integer) help to get them out.

<<eval>>=
let atoi x      = try int_of_string x
                  with Failure _ -> assert false
let atof        = float_of_string
let atoc s      = Char.code (String.get s 0)
@

Because most functions return triples of [[Types.ty]], [[kind]], [[entry
Symbol.t]] some access functions are helpful.

<<>>=
let fst3 (x,_,_)    = x
let snd3 (_,x,_)    = x
let trd3 (_,_,x)    = x
let foldl           = List.fold_left

let rec evalFetch set env = function
    | LValueAt(v,_) -> evalFetch set env v
    | Mem (_,_,_)   -> error "memory access in const declaration"
    | Var(id)       -> evalConstID set env id
@

Only the application of primitive operators requires serious type
checking.  Just the argument positions are actually type checked
because we don't know about the return type.  The substitution
[[sigma]] returned by [[unify]] is applied to the type scheme [[t]] of
the primitive operation.  This instantiates the return type in [[t]]
which is bound to [[rt]].  When type checking succeeds the actual
values are applied to the implementation [[f]] of the primitive and
the result is returned together with its type [[rt]].

<<>>=

and evalPrimOp' set op (env',args) =
    let f, t     = lookup op constOps      in 
    let xt       = List.map fst args       in
    let xv       = List.map snd args       in
    let unused   = bool                    in
    let sigma    = ( try Types.unify t (proc xt unused) Types.empty with 
                   | Types.UnifyExn -> error "type mismatch"
                   ) in
    let rt       = ( match Types.subst sigma t with
                   | Types.Procedure(_,r) -> r
                   | _                    -> assert false
                   ) in
        rt, f xv, env'

and evalPrimOp set env op args = 
    emap (evalPrimOp' set op) (evalExprs set env args)

and evalExprs set env es = 
    let rec loop set env acc = function
        | []    -> Ok(env, List.rev acc)
        | e::es -> ( match evalExpr set env e with
                   | Ok (t, x, env') -> loop set env' ((t,x)::acc) es
                   | Error           -> Error
                   )
    in
        loop set env [] es

and evalExpr set env = function 
    | ExprAt(e,r)         -> catch (errorRegPrt r) (evalExpr set env) e
    | Int(i, None)        -> Ok(word     , IntConst(atoi i), env) 
    | Int(i, Some size)   -> Ok(bits size, IntConst(atoi i), env)
    | Float(f, None)      -> Ok(word     , FloatConst(atof f), env)
    | Float(f, Some size) -> Ok(bits size, FloatConst(atof f), env)
    | Char(c, None)       -> Ok(char     , IntConst(atoc c), env)
    | Char(c, Some size)  -> Ok(bits size, IntConst(atoc c), env)
    | Fetch(v)            -> evalFetch set env v
    | BinOp(l,op,r)       -> evalPrimOp set env op [l;r]
    | PrimOp(op,es)       -> evalPrimOp set env op (List.map snd es)
    | UnOp(op,e)          -> evalPrimOp set env op [e]
         
and evalConst set env id ty = function
    | ExprConst(e)  -> 
        ( match evalExpr (IDSet.add id set) env e with
        | Error          -> Error
        | Ok(t, x, env') -> Ok (t , x, shadow id (Ok(t,Constant(x))) env)
        )
    | x             -> Ok (ty, x , env)
        
and evalConstID set env id = 
    if IDSet.mem id set then 
        error ("constant defintion "^id^" is circular" )
    else match lookup id env with
        | Error              -> Error
        | Ok(t, Constant(x)) -> evalConst set env id t x
        | _                  -> error ("not a constant: "^id)
        
@

% ------------------------------------------------------------------ 
\subsection{Checking Static Semantics}
% ------------------------------------------------------------------ 

After phase two the symbol table contains all global symbols and their
types and kinds. Constants have been evaluated such that their actual value is
listed in the symbol Table. Symbols with an erroneous definition have
value [[Error]] in the symbol table. Now the static semantics of the
entire compilation unit can be checked.

The strategy is to check as much as possible even when an error was
found. Thus errors are marked but checking goes on in the hope to find
more errors.

<<phase3 module>>=
module Phase3 = struct
    open Prim
    <<phase3>>
end

<<phase3>>=

let foldl = List.fold_left

@
Alignments must be a power of two. This predicates is true, iff its argument
is a positive power of two.

<<>>=
let rec is2power = function
    | 1 -> true
    | x -> x > 0 && (x mod 2) = 0 && is2power (x/2)
@

The code for evaluating constant expressions is in [[Phase2]] where it
was needed for the evaluation of [[const]] blocks.  It is easiest to
reuse it by supplying an empty [[set]] to it.  The set is used to
detect circular constant definitions which no longer exist.

<<>>=

let constExpr env e =
    let set      = IDSet.empty in
        ( match Phase2.evalExpr set env e with
        | Error        -> Error
        | Ok(ty, x, _) -> Ok(ty, x)
        )
@
        
Expressions are type checked.  In [[Phase2]] constant definitions were
already type checked and there is some code for this.  But the
evaluation of constants interleaced type checking and evaluations in a
lazy style which has lead to relatively complicated functions.  It is
easier and cleaner to implement the type checking functions again.

<<>>=
let rec ty = function
    | TyAt(x,_)       -> ty x
    | BitsTy(n)       -> Types.Bits(n)
    | FloatTy(n)      -> Types.Bits(n)

let rec tyFetch env = function
    | LValueAt(v,r) -> catch (errorRegPrt r) (tyFetch env) v
    | Var(id)       -> ( match lookup id env with
                       | Error       -> Error 
                       | Ok(ty,kind) -> Ok(ty)
                       )
    | Mem (t,e,a)   -> 
        let tye   = tyExpr env e in
        let align = match a with
                    | None   -> 1
                    | Some a when is2power a -> a 
                    | Some a -> error "alignment not a power of 2"  
        in ( match tye with
           | Error               -> Error
           | Ok(t) when t = data -> Ok(t)
           | Ok(otherwise)       -> error "expression is not of pointer type"
           )

and applTy' opTy argTys =
   let s = ( try Types.unify opTy (proc argTys bool) (Types.empty) with
           | Types.UnifyExn -> error "type error in application"
           ) 
   in
        ( match Types.subst s opTy with
        | Types.Procedure(_,r) -> r
        | _                    -> assert false
        )  

and applTy opTy argTys = emap (applTy' opTy) argTys
           
and tyPrimOp env op args =
    let at    = List.map (tyExpr env) args in
    let ot    = lookup op primOps  in
        applTy ot (Raise.list at)

and tyExpr (env: env) = function
    | ExprAt(x,r)           -> catch (errorRegPrt r) (tyExpr env) x
    | Int( i, None)         -> Ok(word)
    | Int( i, Some size)    -> Ok(bits size) 
    | Float( f, None)       -> Ok(word)
    | Float( f, Some size)  -> Ok(bits size) 
    | Char( c, None)        -> Ok(char)
    | Char( c, Some size)   -> Ok(bits size) 
    | Fetch(v)              -> tyFetch env v
    | BinOp(l,op,r)         -> tyPrimOp env op [l;r]
    | UnOp(op,e)            -> tyPrimOp env op [e]
    | PrimOp(op,xs)         -> tyPrimOp env op (List.map snd xs)

    

let rec init env = function
    | InitAt(x,_)   -> init env x
    | InitExprs(es) -> Raise.list (List.map (tyExpr env) es)
    | InitStr(s)    -> Ok ([char])
    | InitUStr(s)   -> Ok ([uchar])

let memsize env = function
    | NoSize    -> Ok(Some 1)
    | DynSize   -> Ok(None)
    | FixSize e -> 
        let f' = function
            | Types.Bits(x), IntConst(size) when size > 0 -> Some size
            | Types.Bits(x), _  -> error "not a positive size"
            | otherwise         -> error "not a proper size constant" in
        let f x = emap f' x in
            f (constExpr env e) 

         
let memdecl env ty size = function
    | None   -> 
        ( match memsize env size with
        | Ok _  -> Ok()
        | Error -> Error
        )
    | Some (i) -> 
        ( match init env i with
        | Error  -> Error
        | Ok tys ->
            let n           = List.length tys in
            let consistent  = foldl (fun res t -> res && ty = t) true tys in
        
            if not consistent then
                error "initial values have types different from declared type" 
            else if n < 1 then
                assert false (* the grammar prevents this *)
            else ( match memsize env size with
                 | Ok(Some m) when n > m ->  error "too many initial values"
                 | Ok(Some m)            ->  Ok ()
                 | Ok(None)              ->  Ok ()
                 | Error                 ->  Error
                 )
        )
    

let rec datum env = function
    | DatumAt(x,r)   -> catch (errorRegPrt r) (datum env) x
    | Label(n)       -> Ok ()
    | Align(a)       -> if is2power a then Ok () 
                        else error ("illegal alignment: " ^ string_of_int a)
    | MemDecl(t,m,i) -> memdecl env (ty t) m i

let rec stackdatum env = function
    | DatumAt(x,r)      -> catch' env (errorRegPrt r) (stackdatum env) x
    | Label(n)          -> shadow_ok n (data,Memory) env
    | Align(a)          -> if is2power a then env
                           else error ("illegal alignment: " ^ string_of_int a)
    | MemDecl(t,m,None) -> ( match memsize env m with
                           | Ok _  -> env
                           | Error -> env
                           )
    | MemDecl(t,m,_   ) -> error "no initial values allowed for stackdata"

let checkJumpTarget env x =
    match lookup x env with
    | Error                         ->  Error
    | Ok(t, Memory) when t = code   ->  Ok ()
    | otherwise                     ->  error (x^" is not a label")
    
let targets env ts = Implode.map (checkJumpTarget env) ts 

let checkFlowTarget env x =
    match lookup x env with
    | Error              -> Error
    | Ok(_,Continuation) -> Ok()
    | _                  -> error (x^" is not a continuation")
       

let rec flow env = function
    | FlowAt(x,r)     -> catch (errorRegPrt r) (flow env) x
    | CutsTo(ns)      -> Implode.map (checkFlowTarget env) ns 
    | UnwindsTo(ns)   -> Implode.map (checkFlowTarget env) ns 
    | ReturnsTo(ns)   -> Implode.map (checkFlowTarget env) ns 
    | Aborts          -> Ok ()

let flows env fs = Implode.map (flow env) fs

let conv env = function
    | Some cc       -> () 
    | None          -> ()

let rec lvalue env lv =
    let align x = function
        | Some a when not (is2power a) -> error "alignment not a power of 2"
        | Some _ (* ok *)
        | None                         -> x
    in match lv with 
    | LValueAt (lv, r)   -> catch (errorRegPrt r) (lvalue env) lv
    | Var(name)          -> lookup name env
    | Mem(t, e, a)       -> 
        match tyExpr env e with
        | Ok(et) when et <> data -> error "expression is not a pointer type"
        | Error                  -> Error
        | Ok(et)                 -> align (Ok (ty t, Memory)) a

let rec lhs env = function
    | LValueAt (lv, r)   -> catch (errorRegPrt r) (lhs env) lv
    | Var(name)          -> 
        ( match lookup name env with
        | Ok(t,Register) -> Ok(t)
        | Error          -> Error
        | otherwise      -> error "lvalue must be a register"
        )
    | Mem(t, e, a)       -> error "lvalue must be a register"
    

let rec collectCont env ss = 
    let rec loop env = function
        | StmtAt(x,_)             -> loop env x
        | ContStmt(n,ns)          -> shadow_ok n (data,Continuation) env
        | SpanStmt(e1,e2,ss)      -> collectCont env ss
        | IfStmt ( e, ss1, ss2)   -> 
            let env'  = collectCont env  ss1 in
            let env'' = collectCont env' ss2 in
                env''
        | otherwise                           -> env
    in 
        foldl loop env ss

let rec ifStmt env e ss1 ss2 =
    match tyExpr env e with
    | Error                 -> Error
    | Ok(ty) when ty = bool -> Implode.pair (stmts env ss1, stmts env ss2)
    | otherwise             -> error "if-expression must be of type bool"
    
and spanStmt env e1 e2 ss =
    let f = function
        | Error                         -> Error
        | Ok (ty,kind) when ty != word  -> error "span arguments must be words"
        | Ok (_)                        -> Ok ()
    in
        Implode.triple ( f (constExpr env e1)
                       , f (constExpr env e2)
                       , stmts env ss
                       )

and gotoStmt env e ts = 
    let t = targets env ts in
    let e = match tyExpr env e with
            | Error               -> Error
            | Ok(t) when t = code -> Ok()
            | _                   -> 
                error "goto-expression does not evaluate to a pointer" 
    in
        Implode.pair (e,t)

and cutStmt env n args fs =
    let f    = flows env fs in
    let args = List.map (tyExpr env) (List.map snd args) in
    let nt   = match lookup n env with
                | Ok(_, Continuation) -> Ok ()
                | otherwise           -> error ("not a continuation: "^n)
    in
        Implode.triple (f,Raise.list args,nt)
    
and jumpStmt env cc e args ts =
    let t    = targets env ts in
    let args = List.map (tyExpr env) (List.map snd args) in
    let et   = match tyExpr env e with
                | Ok(t) when t = code  -> Ok ()
                | otherwise            -> error "jump target is not a pointer"
    in
        Implode.triple (t,Raise.list args, et)

and contStmt env n ns = 
    let check n = 
        let f = function
            | Ok(_, Register) -> Ok ()
            | Error           -> Error
            | otherwise       -> 
                error ("formal continuation parameter not a register: "^n)
        in
            f (lookup n env)
    in
        Implode.list (List.map check ns)
    
and returnStmt env cc alt args =
    let args  = List.map snd args  in
    let tys   = Implode.list (List.map (tyExpr env) args) in
    let f     = function
                | (tx, IntConst(x)),(ty, IntConst(y)) ->
                   tx = word && ty = word && x >= 0 && y >= 0 && x <= y    
                | otherwise -> error "<x/y> illegal values" 
    in 
        match alt with
        | None         -> tys
        | Some (e1,e2) -> let e1' = constExpr env e1 in
                          let e2' = constExpr env e2 in
                          ( match emap f (Raise.pair (e1',e2')) with
                          | Ok(true)  -> tys
                          | Ok(false) -> error "illegal <x/y> comnination"
                          | Error     -> Error
                          )
                

and assignStmt env pairs =
    let pair (lhs,expr) =  
        match lvalue env lhs, tyExpr env expr with
        | Ok (t, Register), Ok(tr) when t = tr -> Ok()
        | Ok (t, Memory  ), Ok(tr) when t = tr -> Ok()
        | Error           , _                  -> Error
        | _               , Error              -> Error
        | otherwise   -> error "type mismatch in assignment"
    in
        Implode.map pair pairs


and callStmt (env: env) (l,cc,e,args,ts,fs) =
    let lt      = Implode.map (lhs env) l        in
    let ts'     = targets env ts                 in
    let fs'     = flows env fs                   in
    let args'   = List.map snd args              in
    let argsTy  = Implode.map (tyExpr env) args' in
        match tyExpr env e with
        | Error               -> Error
        | Ok(t) when t = code -> Implode.quad (lt,ts',fs',argsTy)
        | otherwise           -> error "call-expression is not a pointer"
             
and primStmt env (l,cc,op,args,fs) =
    let l      = Implode.map (lhs env) l in
    let fs     = flows env fs                    in
    let opTy   = lookup op primOps               in
    let args'  = List.map snd args               in
    let argsTy = List.map (tyExpr env) args'     in
    let rTy    = applTy opTy (Raise.list argsTy) in
        Implode.triple (l,fs,rTy)

and stmt env = function
    | StmtAt(x,r)                 -> catch (errorRegPrt r) (stmt env) x
    | IfStmt ( e, ss1, ss2)       -> ifStmt env e ss1 ss2
    | SpanStmt(e1,e2,ss)          -> spanStmt env e1 e2 ss
    | AssignStmt(xs)              -> assignStmt env xs
    | CallStmt call               -> callStmt env call
    | PrimStmt call               -> primStmt env call
    | GotoStmt(e,ts)              -> gotoStmt env e ts
    | CutStmt(n, args, fs)        -> cutStmt env n args fs
    | ReturnStmt(cc, alt, args)   -> returnStmt env cc alt args
    | JumpStmt(cc,e,args,ts)      -> jumpStmt env cc e args ts
    | ContStmt(n,ns)              -> contStmt env n ns
    | LabelStmt(n)                -> Ok ()
    | EmptyStmt                   -> Ok ()

and stmts env ss = Implode.map (stmt env) ss

let formal env (hint, inv, t, name) =
    shadow_ok name (ty t, Register) env

let formals env fs = foldl formal env fs

let register env (inv, t, name, reg) =
    shadow_ok name (ty t, Register) env

let registers env rs = foldl register env rs

let rec decl env = function
    | DeclAt (d, r)     -> catch' env (errorRegPrt r) (decl env) d
    | LRegisters rs     -> registers env rs
    | Stackdata ds      -> foldl stackdatum env ds

let decls env ds = foldl decl env ds

let procedure env cc fs ds ss = 
    let env1  = formals env fs in
    let env2  = collectCont env1 ss in
    let env3  = decls env2 ds   in
        stmts env3 ss  

     
let export' env t n (t',kind) =
    ( match t, t', kind with
    | Some t , t', Memory when ty t = t' -> ()
    | None   , t', Memory                -> ()
    | Some t , t', Memory  -> error "declared type does not match actual type"
    | otherwise            -> error ("value "^n^" can't be exported")
    )
    
let export env ty n = emap (export' env ty n) (lookup n env) 
    
   
let rec section env = function
    | SectionAt(x,r)             -> catch (errorRegPrt r) (section env) x
    | SSpan( e1, e2, ss)         -> Implode.map (section env) ss
    | Datum( d)                  -> datum env d
    | SExport (t, ns)            -> Implode.map (export env t) ns
    | Procedure(cc,n,fs, ds, ss) -> procedure env cc fs ds ss
    

let rec topdecl env = function
    | TopDeclAt(x,r)  -> catch (errorRegPrt r) (topdecl env) x
    | Import( t, ns)  -> Ok ()
    | Export( t, ns)  -> Implode.map (export env t) ns
    | Const ( cs)     -> Ok () 
    | Section( n, ss) -> Implode.map (section env) ss
    | Registers( rs)  -> Ok ()
    | Pragma          -> Ok ()
    | TopProcedure(n,cc,fs,ds,ss) -> procedure env cc fs ds ss 
                                            
let program env ds srcmap =
        Implode.map (topdecl env) ds
@



% ------------------------------------------------------------------  
\subsection{Checking a File}
% ------------------------------------------------------------------ 

To actually scan, parse, and check a file we provide a function
[[check]] to be called with a file name.  It calls the parser to
create the abstract syntax and calls the different phases of checking.

<<check>>=
let check file =
    let fd          = try open_in file 
                      with Sys_error(msg) -> error msg               in
    let finally ()  = close_in fd                                       in
    let lexbuf      = Lexing.from_channel fd                            in
    let map         = Srcmap.empty                                      in
    let scanner     = Scan.scan map                                     in
        try
            ( Srcmap.sync map 0 (file,1,1) 
            ; let ast  = Parse.program scanner lexbuf in
              let env  = Phase1.program ast map in
              let env' = Phase2.eval env        in
                  Phase3.program env' ast map 
            ) 
        with
            | Parsing.Parse_error -> 
              ( finally()
              ; errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; Error
              )
            | ErrorExn msg ->
              ( finally()
              ; errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; Error
              )
            | e ->  
              ( finally()
              ; raise e
              )
@

% ------------------------------------------------------------------  
\subsection{Interface}
% ------------------------------------------------------------------  

<<semant.mli>>=
val check : string -> unit Error.error
@

% ------------------------------------------------------------------  
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<semant.ml>>=
open Ast
open Pp
open Error

<<type aliases>>
<<symtab>>

<<print module>>
<<primitives module>>
<<phase1 module>>
<<phase2 module>>
<<phase3 module>>

<<check>>

@

