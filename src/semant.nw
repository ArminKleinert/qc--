% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h substitution to ->

% ------------------------------------------------------------------ 
\section{Checking Static Semantics}
% ------------------------------------------------------------------  

In C~many symbols like procedures and constants have the compilation
unit as their scope. In order to check that all used names are indeed
declared checking is done in a stepwise approach:

\begin{enumerate}
\item Global symbols are entered into a symbol table. Except for 
      constants the types of all these symbols are known and entered into
      the table, too. For constants the abstract syntax of the defining
      expression is entered into the symbol table.

\item Constant evaluation and constant type checking. All constants in the
      symbol table are evaluated and type checked. The result of type and
      value replaces the abstract syntax in the symbol table.

\item With all global symbols and their types in the symbol table the
      a top-down traversal of the abstract syntax can check the static
      semantics (and emit intermediate code).
\end{enumerate}


% ------------------------------------------------------------------ 
\subsection{Symbol Table}
% ------------------------------------------------------------------ 

The symbol table maps identifiers [[id]] to their \textit{type} and
\textit{kind} ([[entry]]).  Since not all values of the same type are
interchangeable kinds distinguish between memory locations, registers,
and constants.  Constants have a value; before constants are evaluated
the value of a constant is the abstract syntax of the defining
expression.
 
<<symtab>>=
type value      = CharConst     of char
                | IntConst      of int
                | FloatConst    of float
                | BoolConst     of bool
                | ExprConst     of Ast.expr

type kind       = Register
                | Memory 
                | Constant      of value

type id         = string
type entry      = Types.ty * kind


module ID       = struct type t=id let compare=compare end
module IDSet    = Set.Make(ID)
module Symbol   = Env.Make(ID)
@

The type of labels in code and data depends on the natural word size
of an architecture. Currently there is no way to specify them so we
make an assumpion about it. This has to be fixed later.

During the first pass the types of constants are unknown. In order to
keep things simple we do not introduce an [[option]] type but simply
abuse the [[bool]] type.

<<>>=
let pointer     = Types.Bits(32) 
let dummy       = Types.Bool
@

% ------------------------------------------------------------------ 
\subsection{Printing the Symbol Table}
% ------------------------------------------------------------------  

During development we would like to know what actually is inside a
symbol table.  We provide [[ppEnv]] to pretty-print a symbol table to
a [[Pp.doc]] value.  The document simply associates each entry in the
table with its [[kind]] and [[Types.ty]]. 

<<print>>=
module Print = struct 

    let (~~) x = x 

    let ppValue = function
        | CharConst(c)  -> text "char("  ^^ text (Char.escaped c)  ^^ text ")"
        | IntConst(i)   -> text "int("   ^^ text (string_of_int i) ^^ text ")"
        | FloatConst(f) -> text "float(" ^^ text (string_of_float f) ^^ text ")"
        | BoolConst(b)  -> text "bool("  ^^ text (if b then "t" else "f") ^^ text ")"
        | ExprConst(e)  -> text "<expr>"

    let ppKind = function
        | Register    -> text "register"
        | Memory      -> text "memory"
        | Constant(v) -> text "constant:" ^/ ppValue v


    let ppEntry (key,(ty,kind)) =
        agrp begin
        ~~ text key ^^ text ":"
        ^^ nest 4 begin
           ~~ break
           ^^ Types.ppTy ty
           ^/ text "/"
           ^/ ppKind kind
           end
        end
     
    let ppEnv env =
        let entries = Symbol.dump env in
        vgrp begin
        ~~ list break ppEntry entries
        ^^ break
        end      
end
@

In \C~symbols are never re-declared.  Thus a symbol should never be
entered into the symbol table when the same symbol is already part of
it.  The [[enter]] function checks for this.  However, during the
evaluation of constants an existing entry for a constant must be
replaced with the one that holds the actual type and value of a
constant.  The [[replace]] function allows to use the original
semantics of [[Symbol.enter]]. 

<<>>=
let enter key v env =
    if Symbol.domain key env then
        error ("identifier already declared: " ^ key)
    else
        Symbol.enter key v env        

let replace key v env =
    Symbol.enter key v env

let lookup = Symbol.lookup
@



% ------------------------------------------------------------------  
\subsection{Collecting Global Symbols}
% ------------------------------------------------------------------ 

In the first phase global symbols are entered into an initially empty
symbol table.  Except for constants all global symbols are either
given their declared type or [[pointer]] in case they denote a label
or procedure. The functions that implement the first phase take a
symbol table [[env]] as one of their arguments and return an enlarged
symbol table that contains the global symbols. In case of an error the
symbol table at the place where the error is caught is returned as a
result. This throws away all additions to the symbol table from a
deeper nesting. Currently only multiple definitions of symbols can
cause errors in the first phase.


\begin{table}
    \begin{center}
    \begin{tabular}{lll}
        Object      & Kind          & Type \\ \hrule
        Procedure   & [[Memory]]    & [[pointer]]  \\
        Code Label  & [[Memory]]    & [[pointer]]  \\
        Data Label  & [[Memory]]    & [[pointer]]  \\
        Register    & [[Register]]  & as declared  \\
        Import      & [[Memory]]    & as declared  \\
        Constant    & [[Constant]]  & [[dummy]]    \\
    \end{tabular}
    \caption{Informations recored for global symbols}
    \label{tab:phase1}
    \end{center}
\end{table}

<<phase1>>=
    
module Phase1 = struct

    let foldl = List.fold_left

    let rec ty = function
        | TyAt(x,_)       -> ty x
        | BitsTy(n)       -> Types.Bits(n)
        | FloatTy(n)      -> Types.Bits(n)
    
    let rec datum env = function
        | DatumAt(x,r)        -> catch' env (errorRegPrt r) (datum env) x
        | Label(n)            -> enter n (pointer,Memory) env
        | _                   -> env
        
    let formal env ( h, v, t, n) = env
    let formals env xs = env

    let register env ( v , t, n, reg) = enter n (ty t, Register) env

    let rec stmt env = function
        | StmtAt(x,r)             -> catch' env (errorRegPrt r) (stmt env) x
        | IfStmt ( e, ss1, ss2)   -> let env' = stmts env ss1 in
                                        stmts env' ss2 
        | LabelStmt(n)            -> enter n (pointer,Memory) env
        | SpanStmt(e1,e2,ss)      -> stmts env ss
        | _                       -> env
        
    and stmts env ss = foldl stmt env ss
@

Constants are entered unevaluated into the symbol table. Their type is
not yet known, as is their value. During a second phase these entries
are replaced by the correct types and values.

<<>>=
    let constant env (name,expr) = 
        enter name (dummy,Constant(ExprConst(expr))) env
        
    let rec section env = function
        | SectionAt(x,r)         -> catch' env (errorRegPrt r) (section env) x
        | SSpan( e1, e2, ss)     -> foldl section env ss
        | Datum( d)              -> datum env d
        | SExport (t, ns)        -> env
        | Procedure(cc,n,fs, ds, ss) -> 
            let env' = enter n (pointer,Memory) env in 
                stmts env' ss 

    let rec topdecl env = function
        | TopDeclAt(x,r)  -> catch' env (errorRegPrt r) (topdecl env) x
        | Import( t, ns)  -> let entry = (ty t, Memory) in
                             foldl (fun env n -> enter n entry env) env ns 
        | Export( t, ns)  -> env
        | Const ( cs)     -> foldl constant env cs
        | Section( n, ss) -> foldl section env ss
        | Registers( rs)  -> foldl register env rs
        | TopProcedure(p) -> env
        | Pragma          -> env

    let program ds srcmap = 
        let env = Symbol.empty     in
            foldl topdecl env ds  

end (* of module Phase1 *)
@

% ------------------------------------------------------------------  
\subsection{Constant Evaluation}
% ------------------------------------------------------------------ 

After the first phase of checking the static semantics all global
symbols are entered into a symbol table. All Constants are unevaluated and
their recorded types are incorrect. The second phase walks over the
symbol table and evaluates all constants. This includes inferring
their types.

A constant definition must: 

\begin{itemize}
\item not refer to other symbols except constants,
\item not be directly or indirectly refer to the symbol being defined.
\end{itemize}

Since constant definitions can refer to each other in any order their
evaluation takes some care.  Basically two approaches are feasible: 
The first:  record all use-relationships and sort them topologically. 
This results in an order that every constant is evaluated after all
constants are evaluated that it depends on.  Recording the
relationships would be best implemented in [[Phase1]].  The second: 
start evaluating any constant definition and recursively evaluate all
definitions of referenced constants.  The tricky part is not to
evaluate any constant definition twice in case a constant is used in
multiple other constants.

The code below implements the second approach that interleaves
constant evaluation, type checking, and updating the symbol table. 
Every function of the implementation takes besides the object to
evaluate two more arguments:  [[set]] and [[env]].  The set [[set]]
contains names of constants that are currently being defined and thus
should not be part of the object under evaluation.  In case one of the
names in [[set]] is found this means a circular definition was
detected.  The symbol table [[env]] is the current symbol table.  It
contains evaluated and unevaluated symbols.  Whenever a symbol is
evaluated its value and type replaces the entry in the current symbol
table.  Since symbol tables are purely functional the updated symbol
table must be returned and used in all subsequent evaluation to avoid
multiple evaluations.  Thus all functions return a triple of type,
value and updated symbol table.  Passing around the symbol table
implements the tricky part mentioned above. 

This evaluation technique could be called \textit{lazy} because
evaluation are driven by demand.  However, the driving function
[[eval]] makes sure all constant definitions are evaluated even those,
which are never used.

Constant definitions can use primitive operations which, of course,
are evaluated at compile-time.  The available primitive operations and
their types are hold in a table [[primOps]].  Construction functions
help to build the type-schemes describing their types.  Infix and
binary operators are as abbreviations to primitive operations.  For
example, [[+]] and [[%add]] share the same type and implementation
[[add]]. 

<<primitives>>=
let bitsc x         = Types.Bits(Types.Const(x))
let bitsv x         = Types.Bits(Types.Var(x))
let bits  x         = Types.Bits(x)
let bool            = Types.Bool
let proc args res   = Types.Procedure(args,res)
let word            = bits 32   (* for now *)
let char            = bits 8

let add  = function
    | [IntConst(x);IntConst(y)] -> IntConst(x+y)
    | _                         -> assert false

let mult  = function
    | [IntConst(x);IntConst(y)] -> IntConst(x*y)
    | _                         -> assert false

let eq    = function
    | [IntConst(x);IntConst(y)] -> BoolConst(x=y)
    | _                         -> assert false

let primOps = Symbol.enterList
    [  "add"    , (add  , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "+"      , (add  , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "mult"   , (mult , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "*"      , (mult , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "eq"     , (eq   , proc [bitsv 1; bitsv 1] bool)
    ;  "=="     , (eq   , proc [bitsv 1; bitsv 1] bool)
    ] Symbol.empty
@

The evaluation of the constants in the symbol table starts by
collecting all (global) names in the symbol table that refer to
constants and then passing them to [[evalConst]] one by one. Once a
constant is evaluatated and type checked its entry in the symbol is
replaced by the correct type and value.

<<driver>>=
let eval env =
    let rec accConst id entry l = 
        ( match entry with
        | _, Constant(ExprConst(_))   -> id::l
        | _                           -> l
        ) in
    let keys = Symbol.fold accConst env [] in
    let eval env id = trd3 (evalConst IDSet.empty env id) in
        foldl eval env keys    
@ 

All literals are stored in the abstract syntax as strings.  Some
functions with names borrowed from the C libaray (atoi $\equiv$ ascii
to integer) help to get them out.

<<eval>>=
let atoi        = int_of_string
let atof        = float_of_string
let atoc s      = Char.code (String.get s 0)
@

Because most functions return triples of [[Types.ty]], [[kind]], [[entry
Symbol.t]] some access functions are helpful.

<<>>=
let fst3 (x,_,_)    = x
let snd3 (_,x,_)    = x
let trd3 (_,_,x)    = x
let foldl           = List.fold_left

let rec evalFetch set env = function
    | LValueAt(v,_) -> evalFetch set env v
    | Mem (_,_,_)   -> error "memory access in const declaration"
    | Var(n)        -> evalConst set env n
@

Only the application of primitive operators requires serious type
checking.  Just the argument positions are actually type checked
because we don't know about the return type.  The substitution
[[sigma]] returned by [[unify]] is applied to the type scheme [[t]] of
the primitive operation.  This instantiates the return type in [[t]]
which is bound to [[rt]].  When type checking succeeds the actual
values are applied to the implementation [[f]] of the primitive and
the result is returned together with its type [[rt]].

<<>>=
    
and evalPrimOp set env op args = 
    let env', xs = evalExprs set env args  in
    let f, t     = lookup op primOps       in 
    let xt       = List.map fst xs         in
    let xv       = List.map snd xs         in
    let unused   = bool                    in
    let sigma    = ( try Types.unify t (proc xt unused) Types.empty with 
                   | Types.UnifyExn -> error "type mismatch"
                   ) in
    let rt       = ( match Types.subst sigma t with
                   | Types.Procedure(_,r) -> r
                   | _                    -> assert false
                   ) in
        rt, f xv, env'

and evalExprs set env es = 
    let rec loop set env acc = function
        | []    -> env, List.rev acc
        | e::es -> let t,x,env' = evalExpr set env e in
                   loop set env' ((t,x)::acc) es
    in
        loop set env [] es

and evalExpr set env = function 
    | ExprAt(e,r)         -> evalExpr set env e
    | Int(i, None)        -> word     , IntConst(atoi i), env 
    | Int(i, Some size)   -> bits size, IntConst(atoi i), env
    | Float(f, None)      -> word     , FloatConst(atof f), env
    | Float(f, Some size) -> bits size, FloatConst(atof f), env
    | Char(c, None)       -> char     , IntConst(atoc c), env
    | Char(c, Some size)  -> bits size, IntConst(atoc c), env
    | Fetch(v)            -> evalFetch set env v
    | BinOp(l,op,r)       -> evalPrimOp set env op [l;r]
    | PrimOp(op,es)       -> evalPrimOp set env op (List.map snd es)
    | UnOp(op,e)          -> evalPrimOp set env op [e]
         

and evalConst set env id = 
    if IDSet.mem id set then 
        error "circular definition" 
    else match lookup id env with
    | (_,(Constant(ExprConst(e)) as c)) -> 
        let (t,x,env') = evalExpr (IDSet.add id set) env e in 
            (t,x, replace id (t,Constant(x)) env')
    | (t, Constant(x))                  -> (t,x,env)
    | x -> error (Printf.sprintf "reference to non-constant %s" id) 

<<driver>>
@

% ------------------------------------------------------------------  
\subsection{Checking a File}
% ------------------------------------------------------------------ 

To actually scan, parse, and check a file we provide a function
[[check]] to be called with a file name.  It calls the parser to
create the abstract syntax and calls the different phases of checking.

<<check>>=
let check file =
    let fd          = try open_in file 
                      with Sys_error(msg) -> error msg               in
    let finally ()  = close_in fd                                       in
    let lexbuf      = Lexing.from_channel fd                            in
    let map         = Srcmap.empty                                      in
    let scanner     = Scan.scan map                                     in
        try
            ( Srcmap.sync map 0 (file,1,1) 
            ; let ast  = Parse.program scanner lexbuf in
              let env  = Phase1.program ast map in
              let env' = eval env               in
                    Ok (ppToFile stdout 72 (Print.ppEnv env'))
            ) 
        with
            | Parsing.Parse_error -> 
              ( finally()
              ; errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; Error
              )
            | ErrorExn msg ->
              ( finally()
              ; errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; Error
              )
            | e ->  
              ( finally()
              ; raise e
              )
@

% ------------------------------------------------------------------  
\ubsection{Interface}
% ------------------------------------------------------------------  

<<semant.mli>>=
val check : string -> unit Error.error
@

% ------------------------------------------------------------------  
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<semant.ml>>=
open Ast
open Pp
open Error

<<symtab>>
<<print>>
<<phase1>>
<<primitives>>
<<eval>>
<<check>>
@

