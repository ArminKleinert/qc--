% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h substitution to ->

% ------------------------------------------------------------------ 
\section{Checking Static Semantics}
% ------------------------------------------------------------------  

In C~many symbols like procedures and constants have the compilation
unit as their scope. In order to check that all used names are indeed
declared checking is done in a stepwise approach:

\begin{enumerate}
\item Global symbols are entered into a symbol table. Except for 
      constants the types of all these symbols are known and entered into
      the table, too. For constants the abstract syntax of the defining
      expression is entered into the symbol table.

\item Constant evaluation and constant type checking. All constants in the
      symbol table are evaluated and type checked. The result of type and
      value replaces the abstract syntax in the symbol table.

\item With all global symbols and their types in the symbol table the
      a top-down traversal of the abstract syntax can check the static
      semantics (and emit intermediate code).
\end{enumerate}


% ------------------------------------------------------------------ 
\subsection{Symbol Table}
% ------------------------------------------------------------------ 

The symbol table maps identifiers [[id]] to their \textit{type} and
\textit{kind} ([[entry]]).  Since not all values of the same type are
interchangeable kinds distinguish between memory locations, registers,
and constants.  Constants have a value; before constants are evaluated
the value of a constant is the abstract syntax of the defining
expression.
 
<<symtab>>=
type value      = CharConst     of char
                | IntConst      of int
                | FloatConst    of float
                | BoolConst     of bool
                | ExprConst     of Ast.expr

type kind       = Register
                | Memory 
                | Continuation
                | Constant      of value

type id         = string
type entry      = Types.ty * kind


module ID       = struct type t=id let compare=compare end
module IDSet    = Set.Make(ID)
module Symbol   = Env.Make(ID)
@

In \C~global symbols are never re-declared.  Thus a global symbol
should never be entered into the symbol table when the same symbol is
already part of it.  The [[enter]] function checks for this.  However,
during the evaluation of constants an existing entry for a constant
must be replaced with the one that holds the actual type and value of
a constant.  The [[shadow]] function allows to use the original


<<>>=
let enter key v env =
    if Symbol.domain key env then
        error ("identifier already declared: " ^ key)
    else
        Symbol.enter key v env        

let enter_ok key v env = enter key (Ok v) env

let shadow key v env =
    Symbol.enter key v env

let shadow_ok key v env =
    Symbol.enter key (Ok v) env

let lookup x env = 
    ( try Symbol.lookup x env with 
    | ErrorExn _ -> error ("unkown identifier: "^x)
    )

@


The type of labels in code and data depends on the natural word size
of an architecture. Currently there is no way to specify them so we
make an assumpion about it. This has to be fixed later.

During the first pass the types of constants are unknown. In order to
keep things simple we do not introduce an [[option]] type but simply
abuse the [[bool]] type.

<<>>=
let pointer     = Types.Bits(32) 
let dummy       = Types.Bool
@

% ------------------------------------------------------------------ 
\subsection{Printing the Symbol Table}
% ------------------------------------------------------------------  

During development we would like to know what actually is inside a
symbol table.  We provide [[ppEnv]] to pretty-print a symbol table to
a [[Pp.doc]] value.  The document simply associates each entry in the
table with its [[kind]] and [[Types.ty]]. 

<<print module>>=
module Print = struct 
    <<print>>
end

<<print>>=
let (~~) x = x 

let ppValue = function
    | CharConst(c)  -> text "char("  ^^ text (Char.escaped c)  ^^ text ")"
    | IntConst(i)   -> text "int("   ^^ text (string_of_int i) ^^ text ")"
    | FloatConst(f) -> text "float(" ^^ text (string_of_float f) ^^ text ")"
    | BoolConst(b)  -> text "bool("  ^^ text (if b then "t" else "f") ^^ text ")"
    | ExprConst(e)  -> text "<expr>"

let ppKind = function
    | Register      -> text "register"
    | Memory        -> text "memory"
    | Continuation  -> text "continuation"
    | Constant(v)   -> text "constant:" ^/ ppValue v


let ppEntry (key,v) = 
    agrp begin
    ~~ text key ^^ text ":"
    ^^ ( match v with
       | Ok (ty,kind) -> 
            nest 4 begin
            ~~ break
            ^^ Types.ppTy ty
            ^/ text "/"
            ^/ ppKind kind
            end
       | Error -> text "<error>"
       )
    end
 
let ppEnv env =
    let entries = Symbol.dump env in
    vgrp begin
    ~~ list break ppEntry entries
    ^^ break
    end      
@


% ------------------------------------------------------------------  
\subsection{Collecting Global Symbols}
% ------------------------------------------------------------------ 

In the first phase global symbols are entered into an initially empty
symbol table.  Except for constants all global symbols are either
given their declared type or [[pointer]] in case they denote a label
or procedure. The functions that implement the first phase take a
symbol table [[env]] as one of their arguments and return an enlarged
symbol table that contains the global symbols. In case of an error the
symbol table at the place where the error is caught is returned as a
result. This throws away all additions to the symbol table from a
deeper nesting. Currently only multiple definitions of symbols can
cause errors in the first phase.


\begin{table}
    \begin{center}
    \begin{tabular}{lll}
        Object      & Kind          & Type \\ \hline
        Procedure   & [[Memory]]    & [[pointer]]  \\
        Code Label  & [[Memory]]    & [[pointer]]  \\
        Data Label  & [[Memory]]    & [[pointer]]  \\
        Register    & [[Register]]  & as declared  \\
        Import      & [[Memory]]    & as declared  \\
        Constant    & [[Constant]]  & [[dummy]]    \\
    \end{tabular}
    \caption{Informations recored for global symbols}
    \label{tab:phase1}
    \end{center}
\end{table}

<<phase1 module>>=
module Phase1 = struct
    <<phase1>>
end

<<phase1>>=
let foldl = List.fold_left

let rec ty = function
    | TyAt(x,_)       -> ty x
    | BitsTy(n)       -> Types.Bits(n)
    | FloatTy(n)      -> Types.Bits(n)

let rec datum env = function
    | DatumAt(x,r)        -> catch' env (errorRegPrt r) (datum env) x
    | Label(n)            -> enter_ok n (pointer,Memory) env
    | _                   -> env
    
let formal env ( h, v, t, n) = env
let formals env xs = env

let register env ( v , t, n, reg) = enter_ok n (ty t, Register) env

let rec stmt env = function
    | StmtAt(x,r)             -> catch' env (errorRegPrt r) (stmt env) x
    | IfStmt ( e, ss1, ss2)   -> let env' = stmts env ss1 in
                                    stmts env' ss2 
    | LabelStmt(n)            -> enter_ok n (pointer,Memory) env
    | SpanStmt(e1,e2,ss)      -> stmts env ss
    | _                       -> env
    
and stmts env ss = foldl stmt env ss
@

Constants are entered unevaluated into the symbol table. Their type is
not yet known, as is their value. During a second phase these entries
are replaced by the correct types and values.

<<>>=
let constant env (name,expr) = 
    enter_ok name (dummy,Constant(ExprConst(expr))) env
    
let rec section env = function
    | SectionAt(x,r)         -> catch' env (errorRegPrt r) (section env) x
    | SSpan( e1, e2, ss)     -> foldl section env ss
    | Datum( d)              -> datum env d
    | SExport (t, ns)        -> env
    | Procedure(cc,n,fs, ds, ss) -> 
        let env' = enter_ok n (pointer,Memory) env in 
            stmts env' ss 

let rec topdecl env = function
    | TopDeclAt(x,r)  -> catch' env (errorRegPrt r) (topdecl env) x
    | Import( t, ns)  -> let entry = (ty t, Memory) in
                         foldl (fun env n -> enter_ok n entry env) env ns 
    | Export( t, ns)  -> env
    | Const ( cs)     -> foldl constant env cs
    | Section( n, ss) -> foldl section env ss
    | Registers( rs)  -> foldl register env rs
    | TopProcedure(p) -> env
    | Pragma          -> env

let program ds srcmap = 
    let env = Symbol.empty     in
        foldl topdecl env ds  

@

% ------------------------------------------------------------------  
\subsection{Constant Evaluation}
% ------------------------------------------------------------------ 

After the first phase of checking the static semantics all global
symbols are entered into a symbol table. All Constants are unevaluated and
their recorded types are incorrect. The second phase walks over the
symbol table and evaluates all constants. This includes inferring
their types.

A constant definition must: 

\begin{itemize}
\item not refer to other symbols except constants,
\item not be directly or indirectly refer to the symbol being defined.
\end{itemize}

Since constant definitions can refer to each other in any order their
evaluation takes some care.  Basically two approaches are feasible: 
The first:  record all use-relationships and sort them topologically. 
This results in an order that every constant is evaluated after all
constants are evaluated that it depends on.  Recording the
relationships would be best implemented in [[Phase1]].  The second: 
start evaluating any constant definition and recursively evaluate all
definitions of referenced constants.  The tricky part is not to
evaluate any constant definition twice in case a constant is used in
multiple other constants.

The code below implements the second approach that interleaves
constant evaluation, type checking, and updating the symbol table. 
Every function of the implementation takes besides the object to
evaluate two more arguments:  [[set]] and [[env]].  The set [[set]]
contains names of constants that are currently being defined and thus
should not be part of the object under evaluation.  In case one of the
names in [[set]] is found this means a circular definition was
detected.  The symbol table [[env]] is the current symbol table.  It
contains evaluated and unevaluated symbols.  Whenever a symbol is
evaluated its value and type replaces the entry in the current symbol
table.  Since symbol tables are purely functional the updated symbol
table must be returned and used in all subsequent evaluation to avoid
multiple evaluations.  Thus all functions return a triple of type,
value and updated symbol table.  Passing around the symbol table
implements the tricky part mentioned above. 

This evaluation technique could be called \textit{lazy} because
evaluation is driven by demand.  However, the driving function
[[eval]] makes sure all constant definitions are evaluated even those,
which are never used.

Constant definitions can use primitive operations which, of course,
are evaluated at compile-time.  The available primitive operations and
their types are hold in a table [[constOps]].  Construction functions
help to build the type-schemes describing their types.  Infix and
binary operators are as abbreviations to primitive operations.  For
example, [[+]] and [[%add]] share the same type and implementation
[[add]]. 

<<primitives module>>=
module Prim = struct
    <<primitives>>
end
    
<<primitives>>=
let bitsc x         = Types.Bits(Types.Const(x))
let bitsv x         = Types.Bits(Types.Var(x))
let bits  x         = Types.Bits(x)
let bool            = Types.Bool
let proc args res   = Types.Procedure(args,res)
let word            = bits 32   (* for now *)
let char            = bits 8

let add  = function
    | [IntConst(x);IntConst(y)] -> IntConst(x+y)
    | _                         -> assert false

let mult  = function
    | [IntConst(x);IntConst(y)] -> IntConst(x*y)
    | _                         -> assert false

let eq    = function
    | [IntConst(x);IntConst(y)] -> BoolConst(x=y)
    | _                         -> assert false

let constOps = Symbol.enterList
    [  "add"    , (add  , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "+"      , (add  , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "mult"   , (mult , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "*"      , (mult , proc [bitsv 1; bitsv 1] (bitsv 1))
    ;  "eq"     , (eq   , proc [bitsv 1; bitsv 1] bool)
    ;  "=="     , (eq   , proc [bitsv 1; bitsv 1] bool)
    ] Symbol.empty

let primOps = Symbol.enterList
    [  "add"    ,  proc [bitsv 1; bitsv 1] (bitsv 1)
    ;  "+"      ,  proc [bitsv 1; bitsv 1] (bitsv 1)
    ;  "mult"   ,  proc [bitsv 1; bitsv 1] (bitsv 1)
    ;  "*"      ,  proc [bitsv 1; bitsv 1] (bitsv 1)
    ;  "eq"     ,  proc [bitsv 1; bitsv 1] bool
    ;  "=="     ,  proc [bitsv 1; bitsv 1] bool
    ] Symbol.empty

@

The evaluation of the constants in the symbol table starts by
collecting all (global) names in the symbol table that refer to
constants and then passing them to [[evalConst]] one by one. Once a
constant is evaluatated and type checked its entry in the symbol is
replaced by the correct type and value. When the evaluation of a
constant fails its definition is replaced by [[Error]].

<<phase2 module>>=
module Phase2 = struct
    open Prim

    <<eval>>
    <<driver>>
end

<<driver>>=
let eval env =
    let rec accConst id entry l = 
        ( match entry with
        | Ok (_, Constant(_)) -> id::l
        | _                   -> l
        ) in
    let keys = Symbol.fold accConst env [] in
    let eval env id = 
        ( match evalConstID IDSet.empty env id with
        | Ok(_,_,env') -> env'
        | Error        -> shadow id Error env
        ) 
     in
        foldl eval env keys    
@ 

All literals are stored in the abstract syntax as strings.  Some
functions with names borrowed from the C libaray (atoi $\equiv$ ascii
to integer) help to get them out.

<<eval>>=
let atoi        = int_of_string
let atof        = float_of_string
let atoc s      = Char.code (String.get s 0)
@

Because most functions return triples of [[Types.ty]], [[kind]], [[entry
Symbol.t]] some access functions are helpful.

<<>>=
let fst3 (x,_,_)    = x
let snd3 (_,x,_)    = x
let trd3 (_,_,x)    = x
let foldl           = List.fold_left

let rec evalFetch set env = function
    | LValueAt(v,_) -> evalFetch set env v
    | Mem (_,_,_)   -> error "memory access in const declaration"
    | Var(id)       -> evalConstID set env id
@

Only the application of primitive operators requires serious type
checking.  Just the argument positions are actually type checked
because we don't know about the return type.  The substitution
[[sigma]] returned by [[unify]] is applied to the type scheme [[t]] of
the primitive operation.  This instantiates the return type in [[t]]
which is bound to [[rt]].  When type checking succeeds the actual
values are applied to the implementation [[f]] of the primitive and
the result is returned together with its type [[rt]].

<<>>=

and evalPrimOp' set op (env',args) =
    let f, t     = lookup op constOps      in 
    let xt       = List.map fst args       in
    let xv       = List.map snd args       in
    let unused   = bool                    in
    let sigma    = ( try Types.unify t (proc xt unused) Types.empty with 
                   | Types.UnifyExn -> error "type mismatch"
                   ) in
    let rt       = ( match Types.subst sigma t with
                   | Types.Procedure(_,r) -> r
                   | _                    -> assert false
                   ) in
        rt, f xv, env'

and evalPrimOp set env op args = 
    emap (evalPrimOp' set op) (evalExprs set env args)

and evalExprs set env es = 
    let rec loop set env acc = function
        | []    -> Ok(env, List.rev acc)
        | e::es -> ( match evalExpr set env e with
                   | Ok (t, x, env') -> loop set env' ((t,x)::acc) es
                   | Error           -> Error
                   )
    in
        loop set env [] es

and evalExpr set env = function 
    | ExprAt(e,r)         -> catch (errorRegPrt r) (evalExpr set env) e
    | Int(i, None)        -> Ok(word     , IntConst(atoi i), env) 
    | Int(i, Some size)   -> Ok(bits size, IntConst(atoi i), env)
    | Float(f, None)      -> Ok(word     , FloatConst(atof f), env)
    | Float(f, Some size) -> Ok(bits size, FloatConst(atof f), env)
    | Char(c, None)       -> Ok(char     , IntConst(atoc c), env)
    | Char(c, Some size)  -> Ok(bits size, IntConst(atoc c), env)
    | Fetch(v)            -> evalFetch set env v
    | BinOp(l,op,r)       -> evalPrimOp set env op [l;r]
    | PrimOp(op,es)       -> evalPrimOp set env op (List.map snd es)
    | UnOp(op,e)          -> evalPrimOp set env op [e]
         
and evalConst set env id ty = function
    | ExprConst(e)  -> 
        ( match evalExpr (IDSet.add id set) env e with
        | Error          -> Error
        | Ok(t, x, env') -> Ok (t , x, shadow id (Ok(t,Constant(x))) env)
        )
    | x             -> Ok (ty, x , env)
        
and evalConstID set env id = 
    if IDSet.mem id set then 
        error ("constant defintion "^id^" is circular" )
    else match lookup id env with
        | Error              -> Error
        | Ok(t, Constant(x)) -> evalConst set env id t x
        | _                  -> error ("not a constant: "^id)
        
@

% ------------------------------------------------------------------ 
\subsection{Checking Static Semantics}
% ------------------------------------------------------------------ 

After phase two the symbol table contains all global symbols and their
types and kinds. Constants have been evaluated such that their actual value is
listed in the symbol Table. Symbols with an erroneous definition have
value [[Error]] in the symbol table. Now the static semantics of the
entire compilation unit can be checked.

<<phase3 module>>=
module Phase3 = struct
    open Prim

    <<phase3>>
end

<<phase3>>=

let foldl = List.fold_left

let rec is2power = function
    | 1 -> true
    | x -> x > 0 && (x mod 2) = 0 && is2power (x/2)
    
let strip = function
    | Ok(x) -> x
    | Error -> error "Error found - aborting"

let constExpr env e =
    let set      = IDSet.empty in
        ( match Phase2.evalExpr set env e with
        | Error        -> Error
        | Ok(ty, x, _) -> Ok(ty, x)
        )

let rec ty = function
    | TyAt(x,_)       -> ty x
    | BitsTy(n)       -> Types.Bits(n)
    | FloatTy(n)      -> Types.Bits(n)

let rec tyFetch env = function
    | LValueAt(v,_) -> tyFetch env v
    | Var(id)       -> let t, kind = strip (lookup id env) in t
    | Mem (t,e,a)   -> 
        let tye   = tyExpr env e in
        let align = match a with
                    | None   -> 1
                    | Some a when is2power a -> a 
                    | Some a -> error "alignment not a power of 2"  
        in match tye with
           | t when t = pointer -> t
           | otherwise          -> error "expression is not of pointer type"

and tyPrimOp env op args =
    let at    = List.map (tyExpr env) args in
    let ot    = lookup op primOps  in
    let sigma = ( try Types.unify ot (proc at bool) (Types.empty) with
                | Types.UnifyExn -> error "type error in application"
                ) in
        ( match Types.subst sigma ot with
        | Types.Procedure(_,r) -> r
        | _                    -> assert false
        ) 

and tyExpr env = function
    | ExprAt(x,_)           -> tyExpr env x
    | Int( i, None)         -> word
    | Int( i, Some size)    -> bits size 
    | Float( f, None)       -> word
    | Float( f, Some size)  -> bits size 
    | Char( c, None)        -> char
    | Char( c, Some size)   -> bits size 
    | Fetch(v)              -> tyFetch env v
    | BinOp(l,op,r)         -> tyPrimOp env op [l;r]
    | UnOp(op,e)            -> tyPrimOp env op [e]
    | PrimOp(op,xs)         -> tyPrimOp env op (List.map snd xs)
    

let rec init env = function
    | InitAt(x,_)   -> init env x
    | InitExprs(es) -> List.map (tyExpr env) es
    | InitStr(s)    -> [char]
    | InitUStr(s)   -> [bits 16]

let memsize env = function
    | NoSize    -> Some 1
    | DynSize   -> None
    | FixSize e -> 
        ( match strip (constExpr env e) with
        | Types.Bits(x), IntConst(size) when size > 0 -> Some size
        | Types.Bits(x), _  -> error "not a positive size"
        | otherwise         -> error "not a proper size constant"
        )

         
let memdecl env ty size = function
    | None   -> ( ignore (memsize env size) 
                ; ()
                )
    | Some (i) -> 
        let tys        = init env i in
        let n          = List.length tys in
        let consistent = foldl (fun res t -> res && ty = t) true tys
        in
            if not consistent then
                error "initial values have types different from declared type" 
            else if n < 1 then
                error "too few initial values"
            else match memsize env size with
                | Some m when n > m ->  error "too many initial values"
                | Some m            ->  ()
                | None              ->  ()
    

let rec datum env = function
    | DatumAt(x,_)   -> datum env x
    | Label(n)       -> ()
    | Align(a)       -> if is2power a then () 
                        else error ("illegal alignment: " ^ string_of_int a)
    | MemDecl(t,m,i) -> memdecl env (ty t) m i

let rec decl env = function
    | DeclAt(x,_)    -> Ok ()
    | LRegisters(rs) -> Ok ()
    | Stackdata( dd) -> Ok ()               

let checkJumpTarget env x =
    match strip (lookup x env) with
    | t, Memory when t = pointer -> ()
    | otherwise                  -> error (x^" is not a label")
    
let targets env ts = List.iter (checkJumpTarget env) ts 

let checkFlowTarget env x =
    if snd (strip (lookup x env)) = Continuation then
        ()
    else 
        error (x^" is not a continuation")
       

let rec flow env = function
    | FlowAt(x,r)     -> flow env x
    | CutsTo(ns)      -> List.iter (checkFlowTarget env) ns 
    | UnwindsTo(ns)   -> List.iter (checkFlowTarget env) ns 
    | ReturnsTo(ns)   -> List.iter (checkFlowTarget env) ns 
    | Aborts          -> ()

let flows env fs = List.iter (flow env) fs

let conv env = function
    | Some cc       -> () 
    | None          -> ()

let rec lvalue env = function
    | LValueAt (lv, r)   -> lvalue env lv
    | Var(name)          -> lookup name env
    | Mem(t, e, a)      -> 
        if tyExpr env e != pointer then 
            error "expression is not a pointer type"
        else 
        ( match a with
        | Some a when not (is2power a) -> error "alignment not a power of 2"
        | Some _
        | None                         -> Ok(ty t, Memory)
        )

let rec lhs env = function
    | LValueAt (lv, r)   -> lhs env lv
    | Var(name)          -> ( match strip (lookup name env) with
                            | t, Register -> t
                            | otherwise   -> error "lvalue must be a register"
                            )
    | Mem(t, e, a)       -> error "lvalue must be a register"
    

let rec collectCont env ss = 
    let rec loop env = function
        | StmtAt(x,_)             -> loop env x
        | ContStmt(n,ns)          -> shadow_ok n (pointer,Continuation) env
        | SpanStmt(e1,e2,ss)      -> collectCont env ss
        | IfStmt ( e, ss1, ss2)   -> 
            let env'  = collectCont env  ss1 in
            let env'' = collectCont env' ss2 in
                env''
        | otherwise                           -> env
    in 
        foldl loop env ss

let rec ifStmt env e ss1 ss2 =
    let ty = tyExpr env e in
        if ty != bool then
            error "if-expression must be of type bool"
        else
            ( stmts env ss1
            ; stmts env ss2
            )
    
and spanStmt env e1 e2 ss =
    let t1, x1 = strip (constExpr env e1) in
    let t2, x2 = strip (constExpr env e2) in
         ( stmts env ss
         ; if (t1 != word) then
                error "span key must be a natural word"
           else if (t2 != word) then
                error "span value must be a natural word"
         ) 

and gotoStmt env e ts = 
    ( targets env ts
    ; let et = tyExpr env e in
        if et != pointer then
            error "goto-expression does not evaluate to a pointer" 
        else
            ()
    )

and cutStmt env n args fs =
    ( flows env fs
    ; let _ = List.map (tyExpr env) (List.map snd args) in
      match strip (lookup n env) with
      | _, Continuation     -> ()
      | otherwise           -> error ("not a continuation: "^n)
    ) 
    
and jumpStmt env cc e args ts =
    ( targets env ts
    ; let _  = List.map (tyExpr env) (List.map snd args) in
      match tyExpr env e with
      | t when t = pointer   -> ()
      | otherwise            -> error "jump target is not a pointer"
    )

and contStmt env n ns = 
    let check n = 
        let f = function
            | _, Register -> ()
            | otherwise   -> 
                error ("formal continuation parameter not a register: "^n)
        in
            f (strip (lookup n env))
    in
        List.iter check ns
    
and returnStmt env cc alt args =
    let args' = List.map snd args in
    let tys   = List.map (tyExpr env) args' in
    match alt with
    | None         -> ()
    | Some (e1,e2) ->
        let t1,x1 = strip (constExpr env e1)  in
        let t2,x2 = strip (constExpr env e2)  in
            if t1 != word then
                error "first argument in <x/y> not a number"
            else if t2 != word then
                error "second argument in <x/y> not a number"
            else
                () 

and assignStmt env pairs =
    let pair (lhs,expr) =  
        let tr    = tyExpr env expr        in
        match strip (lvalue env lhs) with
        | t, Register when t = tr -> ()
        | t, Memory   when t = tr -> ()
        | otherwise   -> error "type mismatch in assignment"
    in
        List.iter pair pairs

and callStmt env (l,cc,e,args,ts,fs) =
    let lt    = List.map (lhs env) l     in
    let et    = tyExpr env e             in
    let args' = List.map snd args        in
    let _     = targets env ts           in
    let _     = flows env fs             in
    let at    = List.map (tyExpr env) args' in
        if et != pointer then
            error "call-expression is not a pointer"
        else 
            ()
             
and primStmt env (l,cc,op,args,fs) =
    let lt    = List.map (lhs env) l     in
    let ot    = lookup op primOps        in
    let args' = List.map snd args        in
    let _     = flows env fs             in
    let at    = List.map (tyExpr env) args' in
    let sigma = ( try Types.unify ot (proc at bool) (Types.empty) with
                | Types.UnifyExn -> error "type error in application"
                ) in
        ( match Types.subst sigma ot with
        | Types.Procedure(_,r) -> ()
        | _                    -> assert false
        ) 

and stmt env = function
    | StmtAt(x,_)                         -> stmt env x
    | IfStmt ( e, ss1, ss2)               -> ifStmt env e ss1 ss2
    | SpanStmt(e1,e2,ss)                  -> spanStmt env e1 e2 ss
    | AssignStmt(xs)                      -> assignStmt env xs
    | CallStmt call                       -> callStmt env call
    | PrimStmt call                       -> primStmt env call
    | GotoStmt(e,ts)                      -> gotoStmt env e ts
    | CutStmt(n, args, fs)                -> cutStmt env n args fs
    | ReturnStmt(cc, alt, args)           -> returnStmt env cc alt args
    | JumpStmt(cc,e,args,ts)              -> jumpStmt env cc e args ts
    | ContStmt(n,ns)                      -> contStmt env n ns
    | LabelStmt(n)                        -> ()
    | EmptyStmt                           -> ()

and stmts env ss = List.iter (stmt env) ss

let formal env (hint, inv, t, name) =
    shadow_ok name (ty t, Register) env

let formals env fs = foldl formal env fs

let register env (inv, t, name, reg) =
    shadow_ok name (ty t, Register) env

let registers env rs = foldl register env rs


let rec decl env = function
    | DeclAt (d, r)     -> decl env d
    | LRegisters rs     -> registers env rs
    | Stackdata ds      -> env (* XXX *)

let decls env ds =
    foldl decl env ds


let procedure env cc fs ds ss = 
    let env1  = formals env fs in
    let env2  = collectCont env1 ss in
    let env3  = decls env2 ds   in
        stmts env3 ss  

     
let export_ env t n (t',kind) =
    ( match t, t', kind with
    | Some t , t', Memory when ty t = t' -> ()
    | None   , t', Memory                -> ()
    | Some t , t', Memory  -> error "declared type does not match actual type"
    | otherwise            -> error ("value "^n^" can't be exported")
    )
    
let export env ty n = 
    export_ env ty n (strip (lookup n env))
    
   
let rec section env = function
    | SectionAt(x,_)             -> section env x
    | SSpan( e1, e2, ss)         -> List.iter (section env) ss
    | Datum( d)                  -> datum env d
    | SExport (t, ns)            -> List.iter (export env t) ns
    | Procedure(cc,n,fs, ds, ss) -> procedure env cc fs ds ss
    
let rec topdecl env = function
    | TopDeclAt(x,r)  -> topdecl env x
    | Import( t, ns)  -> ()
    | Export( t, ns)  -> List.iter (export env t) ns
    | Const ( cs)     -> () 
    | Section( n, ss) -> List.iter (section env) ss
    | Registers( rs)  -> ()
    | Pragma          -> ()
    | TopProcedure(n,cc,fs,ds,ss) -> procedure env cc fs ds ss 
                                            
let program env ds srcmap =
    ignore (List.map (topdecl env) ds) ; Ok ()  
@


% ------------------------------------------------------------------  
\subsection{Checking a File}
% ------------------------------------------------------------------ 

To actually scan, parse, and check a file we provide a function
[[check]] to be called with a file name.  It calls the parser to
create the abstract syntax and calls the different phases of checking.

<<check>>=
let check file =
    let fd          = try open_in file 
                      with Sys_error(msg) -> error msg               in
    let finally ()  = close_in fd                                       in
    let lexbuf      = Lexing.from_channel fd                            in
    let map         = Srcmap.empty                                      in
    let scanner     = Scan.scan map                                     in
        try
            ( Srcmap.sync map 0 (file,1,1) 
            ; let ast  = Parse.program scanner lexbuf in
              let env  = Phase1.program ast map in
              let env' = Phase2.eval env        in
                  ( match Phase3.program env' ast map with
                  | Error -> Error
                  | _     -> Ok ()
                  )
                    
            ) 
        with
            | Parsing.Parse_error -> 
              ( finally()
              ; errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; Error
              )
            | ErrorExn msg ->
              ( finally()
              ; errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; Error
              )
            | e ->  
              ( finally()
              ; raise e
              )
@

% ------------------------------------------------------------------  
\subsection{Interface}
% ------------------------------------------------------------------  

<<semant.mli>>=
val check : string -> unit Error.error
@

% ------------------------------------------------------------------  
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<semant.ml>>=
open Ast
open Pp
open Error

<<symtab>>

<<print module>>
<<primitives module>>
<<phase1 module>>
<<phase2 module>>
<<phase3 module>>

<<check>>

@

