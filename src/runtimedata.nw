% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et sts=4
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% inc: \usepackage{alltt}


% ------------------------------------------------------------------ 
\section{Collecting and emitting data for the run-time system}
% ------------------------------------------------------------------ 
The run-time system needs to examine stack frames that are suspended at call
sites or at continuations.
We refer to these locations collectively as {\em stopping points}.
For each stopping point, we emit information to tell the run-time system about
the stack frame.

The run-time system needs to know:
\begin{itemize}
\item the size of the frame,
\item the size of the incoming overflow block that must be deallocated by the
procedure,
\item the location of the return address,
\item the locations of stackdata,
\item the locations of values stored in callee-save registers on entry to the procedure,
\item the locations of local variables,
\item the locations of span data declared in the \pal~source, and
\item the locations of unwind continuations (currently unimplemented).
\end{itemize}

In order to avoid complications in threading this data through the compiler, 
we convert each type of data to spans.
Later, when we are ready to emit assembly code (compile-time constants have been
computed, etc.), we emit the spans as assembly code.

This module hides the representation of data as spans, as well as the encoding
of the spans as assembly.
The interface of the module provides functions to convert the different types of
data to spans and a single function to emit all the spans as assembly.

% ------------------------------------------------------------------ 
\subsection{The interface}
% ------------------------------------------------------------------ 
We expose two types of functions:
\begin{itemize}
\item Functions that convert data to a span.
\item A function that emits the spans as assembly.
\end{itemize}
The conversion functions for frame size and overflow-block size use
the number of variables and the virtual frame pointer in addition to
the expression representing the size.
These functions cannot ask for a record of type [[Ast2ir.proc]] because
they may be used before such a record exists. 
<<runtimedata.mli>>=
type span = Bits.bits * Rtl.exp
val frame_size_to_span    : vfp:Rtl.exp -> Rtl.exp -> span
val overflow_size_to_span : vfp:Rtl.exp -> Rtl.exp -> span
@
Occasionally, it is useful to represent a value as being dead at a stopping point.
For example, if a variable is not live, we represent it with the [[dead_value]].
<<runtimedata.mli>>=
val dead_value            : Rtl.exp
@
To facilitate unwinding the stack, we must be able to look up unwind continuations.
UNFORTUNATELY, WE DO NOT YET HAVE A USEFUL IMPLEMENTATION.
Note: Even if no continuations may be unwound to, this function must be called in order
to create the span for the number of continuations.
<<runtimedata.mli>>=
val conts_to_spans : wordsize:int -> span list
@
The locations of stackdata labels must be exposed through the run-time system.
<<runtimedata.mli>>=
val stackdata_to_spans : wordsize:int -> vfp:Rtl.exp -> Rtl.exp list -> span list
@
We can convert the return address, callee-save registers, and variable assignments
(from variable placement) to spans.
<<runtimedata.mli>>=
val ra_to_span        : wordsize:int -> Rtl.loc -> span
val csregs_to_spans   : wordsize:int -> nvars:int -> Register.Set.t ->
                        (Register.t * Rtl.loc) list -> span list
val var_asst_to_spans : Ast2ir.proc -> (int * Automaton.loc) list -> span list
@
After we have placed all the data in spans, we emit
the data as assembly by calling [[emit_as_asm]].
The function should be partially applied to an assembler, then added
to the optimization pipeline.
<<runtimedata.mli>>=
val emit_as_asm : Ast2ir.proc Asm.assembler -> 'v -> Ast2ir.proc-> bool
@

% ------------------------------------------------------------------ 
\subsection{Imports, type definitions, and utilities}
% ------------------------------------------------------------------ 
A number of shorthands are used throughout the implementation.
<<runtimedata.ml>>=
let verb   = 20
let imposs = Impossible.impossible
let unimp  = Impossible.unimp

type span  = Bits.bits * Rtl.exp

module A  = Automaton
module B  = Bits
module C  = Call
module RM = Register.Map
module RS = Register.Set
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module W  = Rtlutil.Width
module Dn = Rtl.Dn
module Up = Rtl.Up
module P  = Proc
module T  = Target
module V  = Verbose
@
We represent a dead value as the constant rtl expression [[false]].
<<runtimedata.ml>>=
let dead_value = R.bool false
@

% ------------------------------------------------------------------ 
\subsection{Converting data to spans and emitting spans as assembly}
% ------------------------------------------------------------------ 
This module hides three secrets:
\begin{itemize}
\item When a type of data is encoded as a span, what index is used?
\item When a type of data is encoded as a span, what expression is used?
\item How is assembly emitted for spans of each type of data?
\end{itemize}
We answer the first question in the next section.
The answers to the second and third questions are intertwined, so the
following section answers both together.

NOTE: IN A (NEAR) FUTURE REVISION, WE CAN SAVE A LOT OF EFFORT BY ARRANGING
TO CREATE THE SPANS SUCH THAT THEIR INDICES ARE THE ORDER IN WHICH THEY
ARE EMITTED AS ASSEMBLY.
THIS TRICK REQUIRES ADDING SOME COUNTS (I.E. NUMBER OF LOCALS) TO THE SPANS,
AS WELL AS PLACING THE SOURCE-LEVEL SPANS AT THE END.

% ------------------------------------------------------------------ 
\subsubsection{Mapping data to span indices}
% ------------------------------------------------------------------ 
Spans defined in the source code may only be indexed by whole numbers.
Consequently, the compiler can use the negative indices to store private data.
Given the maximum span index ([[max_span]]), the number of local variables ([[nvars]]),
the number of unwind continuations ([[num_conts]]),
and the number of callee-save registers ([[nregs]]), we layout the span
indices as follows:
\begin{verbatim}
                                     +-----------------------+
                           max_span: |                       |
                                     | source spans          |
                                  0: |                       |
                                     +-----------------------+
                                 -1: | frame size            +
                                     +-----------------------+
                                 -2: | overflow size         +
                                     +-----------------------+
                                 -3: | return address        +
                                     +-----------------------+
                                 -4: | stackdata table       +
                                     +-----------------------+
                                 -5: | num registers         +
                                     +-----------------------+
                                 -6: | num locals            +
                                     +-----------------------+
                                 -7: | num spans             +
                                     +-----------------------+
                                 -8: | num continuations     +
                                     +-----------------------+
                                 -9: |                       |
                                     | callee-save registers |
                     -(2*nregs + 8): |                       |
                                     +-----------------------+
                     -(2*nregs + 9): |                       |
                                     | local variables       |
             -(nvars + 2*nregs + 8): |                       |
                                     +-----------------------+
             -(nvars + 2*nregs + 9): |                       |
                                     | continuations         |
    -(nconts + nvars + 2*nregs + 8): |                       |
                                     +-----------------------+
\end{verbatim}

For each callee-save register, we use two slots: one for the register and the next
for the location in which it has been stored.

The careful reader will notice that we have not included stackdata in this mapping.
We handle stackdata separately because the stackdata values are visible throughout
the procedure.
We associate the stackdata with the procedure's label; the stackdata items are
0-indexed, in the order they appear in the procedure.

For most of the indices, the mapping is trivial; only the registers require
some work. We omit the identity function on source span indices.

The local variables, frame size, overflow size, and return-address location are simple:
<<runtimedata.ml>>=
let var_ix           nregs i = -(2*nregs + 9 + i)
let frame_size_ix            = -1
let overflow_size_ix         = -2
let ra_ix                    = -3
@
We also need an index for the label of the stackdata table, as well as the number
entries.
<<runtimedata.ml>>=
let sd_table_ix   = -4
let num_reg_ix    = -5
let num_locals_ix = -6
let num_spans_ix  = -7
let num_conts_ix  = -8
@
The callee-save registers are indexed in sorted order, where the order is defined
over the (space, index, width) type of a register.
Registers are sorted first by space (increasing alphanumeric order), then by index
(also increasing alphanumeric order).
IT MAY JUST BE WORTH USING THE ORDERING DEFINED OVER ALL HARDWARE REGISTERS IN THE
[[target.t]] RECORD.
<<runtimedata.ml>>=
let mk_csreg_ix_map nvregs = snd (Register.reg_int_map nvregs)
@
Using a map from registers to indices, we can easily look up the index for a
callee-save register.
<<runtimedata.ml>>=
let csreg_ix nvars r regmap = -(9 + 2*(RM.find r regmap))
@
The rest of the indices are straightforward.
<<runtimedata.ml>>=
let cont_ix nregs nvars cn  = -(nvars + 2*nregs + 9 + cn)
@
<<runtimedata.ml>>=
let pspan conv (b,e) =
  V.eprintf verb "span: (%d,%s)\n" (conv b) (RU.ToReadableString.exp e)
let print_span        = pspan Bits.S.to_int
let print_pseudo_span = pspan (fun x -> x)
@
Before emitting spans, we should always be sure to sort them in the proper order.
<<runtimedata.ml>>=
let sort_spans     ss = List.sort (fun (i1,_) (i2,_) -> compare i1 i2) ss
let sort_neg_spans ss = List.sort (fun (i1,_) (i2,_) -> compare i2 i1) ss
@

% ------------------------------------------------------------------ 
\subsubsection{Mapping data to expressions and emitting emitting spans as assembly}
% ------------------------------------------------------------------ 
At each stopping point, we emit information to tell the run-time system about
the stack frame.
We first separate out the spans that are visible throughout a procedure (stackdata).
The stackdata spans ([[sd_spans]]) are emitted in a separate table.
Then, for each stopping point, we emit the associated spans by calling
[[emit_site_spans]].
<<runtimedata.ml>>=
let emit_as_asm asm _ proc =
  let wordsize   = proc.P.target.T.wordsize in
  let to_bits  i = Bits.S.of_int i wordsize  in 
  let zero       = Bits.zero wordsize in
  let one        = to_bits 1 in
  <<define functions for emitting data>>
  <<define [[partition_site_spans]] [[emit_sd_spans]] and [[emit_site_spans]]>>
  let sd_spans, site_spans = partition_site_spans proc.P.spans in
  let prev_section = asm#current in
  emit_sd_spans sd_spans;
  List.iter emit_site_spans site_spans;
  asm#section prev_section;
  true
@
Stackdata spans have been paired with the label for the current procedure.
We separate out these spans from the spans that are valid only at particular stopping
points within the procedure.
For each set of site spans, we add a span pointing to the table of stackdata spans.
<<define [[partition_site_spans]] [[emit_sd_spans]] and [[emit_site_spans]]>>=
let sd_label = asm#local (Idgen.label "stackdata") in
let partition_site_spans spans =
  let sd_spans, site_spans =
    List.partition (fun (site,_) -> site = proc.P.symbol#original_text) spans in
  let sd_span = (to_bits sd_table_ix, Rtl.link sd_label proc.P.target.T.pointersize) in
  let site_spans = List.map (fun (l,ss) -> (l, sd_span::ss)) site_spans in
  sd_spans, site_spans in
@
\paragraph{Emitting Stackdata Spans}
A stackdata map for $n$ stackdata labels is of size $n + 1$ words.
The first word gives the number of stackdata labels.
The next $n$ words give the stackdata labels in order.
<<define [[partition_site_spans]] [[emit_sd_spans]] and [[emit_site_spans]]>>=
let emit_sd_spans sd_spans =
  match sd_spans with
  | [(_,spans)] ->
    asm#section "pcmap_data";
    asm#label   sd_label;
    asm#value   (Bits.U.of_int (List.length spans) proc.P.target.T.wordsize);
    List.iter   (fun (_,e) -> emit_val_loc e) (sort_spans spans)
  | _ -> imposs "More than one set of stackdata spans found for a procedure" in
@
\paragraph{Emitting Stopping-Point Spans}
For each stopping point labelled [[stop_l]], we must emit the information stored in
the [[spans]].
The information is organized in two distinct areas.
The first area is a map from stopping points in the procedure to run-time
data associated with the stopping points.
The run-time data for each stopping point begins at the label [[frame_label]].
This map is placed in the [[pcmap]] section of the assembly code.

The second area is the collection of run-time data for each stopping point.
This data is placed in the [[pcmap_data]] section of the assembly code.
<<define [[partition_site_spans]] [[emit_sd_spans]] and [[emit_site_spans]]>>=
let emit_site_spans (stop_l, spans) =
  let frame_label = asm#local (Idgen.label "frame") in
  <<emit proc to run-time data map>>
  <<emit frame data>>   in
@
The first area consist of two consecutive pointers, one to the stopping point
and the other to the data associated with the stopping point:
\begin{verbatim}
.section pcmap
+--------------------+
| stopping_point_lbl |
+--------------------+
| frame_data_lbl     |
+--------------------+
\end{verbatim}
<<emit proc to run-time data map>>=
  asm#section "pcmap";
  asm#addr (Reloc.Simple.of_sum (asm#local stop_l) zero);
  asm#addr (Reloc.Simple.of_sum frame_label        zero);
@
The second area keeps track of the size of the frame, the size of the incoming overflow
block that the procedure must deallocate, the location of the return address,
a pointer to the stackdata table, the locations of registers, the local variables,
the spans, and the continuations (CONTINUATIONS ARE NOT YET IMPLEMENTED).
The layout looks like:
\begin{verbatim}
.section pcmap_data
frame_data_lbl:
+--------------------+
| frame_size         |
+--------------------+
| overflow_size      |
+--------------------+
| return_address     |
+--------------------+
| stackdata_table    |
+--------------------+
| num registers      |
+--------------------+
| num locals         |
+--------------------+
| num spans          |
+--------------------+
| num continuations  |
+--------------------+
| registers          |
+--------------------+
| locals             |
+--------------------+
| continuations      |
+--------------------+
| spans              |
+--------------------+
\end{verbatim}
The compiler keeps track of all this information through the use of spans, which are
(index, Rtl.exp) pairs.
Because the frontend can only use whole numbers to index spans, we can easily
distinguish between user-defined spans and compiler-defined spans.

We fill in any gaps in the user-defined spans with 0's.
<<emit frame data>>=
asm#section "pcmap_data";
asm#label frame_label;
let source_spans, cmm_spans = 
  let spans       = List.map (fun (n,e) -> (Bits.S.to_int n,e)) spans in
  let ss, cs      = List.partition (fun (n,_) -> n >= 0) spans in
  let max_span_ix = List.fold_left (fun best (i,_) -> max i best) (-1) ss in
  let ss =
    let span_arr = Array.init (max_span_ix + 1) (fun i -> (i,dead_value)) in
    List.iter (fun (i,span) -> span_arr.(i) <- (i,span)) ss;
    Array.to_list span_arr in
  let num_span = (num_spans_ix,
                  R.bits (to_bits (max_span_ix+1)) proc.P.target.T.wordsize) in
  sort_spans ss, sort_neg_spans (num_span :: cs) in
List.iter (fun (_,v) -> emit_val_loc v) cmm_spans;
List.iter (fun (_,v) -> emit_val_loc v) source_spans;
@
We cover each section of the frame data in detail.
In addition to emitting spans as assembly data, we provide functions
to convert each type of data (frame size, register contents, locals, etc.)
to spans.

% ------------------------------------------------------------------ 
\subsubsection{Conversion to/from spans}
% ------------------------------------------------------------------ 
We provide conversion functions to store a value in a span,
and we provide the functions to emit the expressions in these spans as 
assembly.

We provide conversion functions from an offset from the vfp to an integral size.
<<runtimedata.ml>>=
let offset_to_span ix vfp exp =
  let w = W.exp exp in
  Bits.S.of_int ix w, R.app (R.opr "sub" [w]) [exp; vfp]
@
We define functions for emitting two possible types of data in a single word:
link-time constants and value locations.
A link-time constant can be emitted directly.
As a special case, we may encounter a constant false value when we expect a link-time
constant.
This case indicates that there the value is never used, so we emit 0.

A value location, on the other hand, is one of three types: dead, register, or
stack offset.
We distinguish between the three cases by using the two high bits as tags and using the
rest of the word to indicate the value's location.
\begin{enumerate}
\item Dead - The value is dead at this point in the procedure.
The two high bits are 0b00. Since a dead value has no location, we just emit 0x0.
\item Register - The value is stored in a register.
The two high bits are 0b01. Of the remaining $n$ bits, the low $n/2$
bits hold an index indicating the register, and the high $n/2$ bits hold an offset into
the register (in case the value is not stored in the low bits of the register).
\item Offset - The value is stored on the stack, at a fixed offset from the virtual
frame pointer.
The two high bits are 0b1s, where s is a sign bit.
The remaining bits store the magnitude of the offset from the virtual frame pointer.
\end{enumerate}

First, we define a slew of helpers to emit the different types of values.
<<define helpers to emit different values>>=
<<define [[simplify_exp]] to simplify rtl expressions>>
let reg_ix proc r =
  try RM.find r (snd proc.P.target.T.reg_ix_map)
  with Not_found -> imposs "Register not found in map" in
let emit_dead_var      ()    = asm#value zero in
let emit_link_const    sym   = asm#addr (Reloc.Simple.of_sum sym zero) in
let emit_offset bits =
  let value    = Bits.S.to_int bits in
  let offset_w = wordsize - 1 in
  (try ignore (Bits.S.of_int value offset_w)
   with Bits.Overflow -> imposs "Offset from vfp is too large for run-time encoding");
  asm#value (B.Ops.or' (B.Ops.shl  one (to_bits offset_w))
                         (B.Ops.shrl (B.Ops.shl (to_bits value) one) one)) in
let emit_reg ix offset =
  let offset_w = wordsize - 2 in
  let w'       = offset_w / 2 in
  (try ignore (Bits.S.of_int ix w'); ignore(Bits.S.of_int offset w')
   with Bits.Overflow -> imposs "Reg ix or offset is too large for run-time encoding");
  asm#value (B.Ops.or' (B.Ops.shl one (to_bits offset_w))
                         (B.Ops.or' (B.Ops.shl (to_bits offset) (to_bits w'))
                                      (to_bits ix))) in
@  
Then, we check the type of value (as encoded in the [[Rtl.exp]] type) and emit the
value in the proper format.
<<define functions for emitting data>>=
let emit_val_loc e =
  <<define helpers to emit different values>>
  match Dn.exp (simplify_exp e) with
  | RP.Const (RP.Bool false)               -> emit_dead_var ()
  | RP.Const (RP.Link (sym,_))             -> emit_link_const sym
  | RP.Const (RP.Bits bs)                  -> emit_offset   bs
  | RP.Fetch (RP.Reg r, _)                 -> emit_reg  (reg_ix proc r) 0
  | RP.Fetch (RP.Slice (_,i, RP.Reg r), _) -> emit_reg  (reg_ix proc r) i
  | _ -> imposs (Printf.sprintf "unexpected exp for span data: %s"
                                (RU.ToReadableString.exp e))  in
@
We provide a function to simplify an expression first by flattening slices such that
they consist of a single offset from a location (if applicable), then by calling
[[Simplify.exp]] on the expression.
<<define [[simplify_exp]] to simplify rtl expressions>>=
let simplify_exp exp =
  let vfp             = proc.P.target.T.vfp            in
  let check w = if w mod wordsize <> 0 || w < 0 then
                   unimp (Printf.sprintf "unsupported size or alignment %d" w) in
  let rec flatten offset l = match l with
    | RP.Mem (_,_,_,e,_) ->
       let w = Rtlutil.Width.exp (Up.exp e) in
       check offset; check w;
       (*V.eprintf verb "Adding an offset %d of width %d\n" offset w;*)
       Rtlutil.add w (R.app (R.opr "sub" [w]) [Up.exp e; vfp])
                            (R.bits (Bits.S.of_int offset w) w)
    | RP.Reg (_,_,w) ->
       check w; check offset;
       let l_up = Up.loc l in
       if offset <> 0 then
         R.fetch (R.slice w offset l_up) w
       else R.fetch l_up w
    | RP.Slice (_,i,l)   -> flatten (offset + i) l
    | RP.Var _ -> imposs "Var after variable placement" in
  match Dn.exp exp with
  | RP.Fetch (loc,_) -> Simplify.exp (flatten 0 loc)
  | _                -> Simplify.exp exp in
@

% ------------------------------------------------------------------ 
\subsubsection{Frame size and overflow size}
% ------------------------------------------------------------------ 
We encode the frame size and overflow size as offsets from the virtual frame pointer.
<<runtimedata.ml>>=
let frame_size_to_span    ~vfp = offset_to_span frame_size_ix    vfp
let overflow_size_to_span ~vfp = offset_to_span overflow_size_ix vfp
@

% ------------------------------------------------------------------ 
\subsubsection{Return Address and Stackdata Table Label}
% ------------------------------------------------------------------ 
The return address is some location.
<<runtimedata.ml>>=
let ra_to_span ~wordsize loc =
  let to_bits i = Bits.S.of_int i wordsize in
  (to_bits ra_ix, RU.fetch loc)
@

% ------------------------------------------------------------------ 
\subsubsection{Locations of stored registers}
% ------------------------------------------------------------------ 
Callee-save registers are stored as pairs of consecutive spans.
The first span indicates the callee-save register.
The second span indicates where it has been stored.
<<runtimedata.ml>>=
let csregs_to_spans ~wordsize ~nvars nvregs csregs =
  let to_bits i     = Bits.S.of_int i wordsize         in 
  let csreg_map     = mk_csreg_ix_map (RS.elements nvregs) in
  let num_span      =
    (to_bits num_reg_ix, R.bits (to_bits (2 * List.length csregs)) wordsize) in
  let to_span rst (r,loc) =
    let ix = csreg_ix nvars r csreg_map in
    (to_bits (ix-1), RU.fetch loc) ::
    (to_bits (ix), RU.fetch (R.reg r)) ::
    rst in
  num_span :: List.fold_left to_span [] csregs
@

% ------------------------------------------------------------------ 
\subsubsection{Location of stored locals}
% ------------------------------------------------------------------ 
Locals are stored as fetches from simple locations.
<<runtimedata.ml>>=
let var_asst_to_spans proc vars =
  let wordsize  = proc.P.target.T.wordsize in
  let to_bits i = Bits.S.of_int i wordsize in 
  let num_span  =
    (to_bits num_locals_ix, R.bits (to_bits (List.length vars)) wordsize) in
  num_span :: List.map (fun (var_num, loc) -> (to_bits (var_ix proc.P.nvregs var_num),
                                               A.fetch loc wordsize))
                       vars
@

% ------------------------------------------------------------------ 
\subsubsection{Location of stackdata}
% ------------------------------------------------------------------ 
Stackdata locations are offsets from the virtual frame pointer.
<<runtimedata.ml>>=
let stackdata_to_spans ~wordsize ~vfp sd_exps =
  snd (List.fold_left (fun (i,rst) e -> (i+1, offset_to_span i vfp e :: rst))
                      (0,[]) sd_exps)
@

% ------------------------------------------------------------------ 
\subsubsection{Location of continuations}
% ------------------------------------------------------------------ 
DUMMY IMPLEMENTATION
<<runtimedata.ml>>=
let conts_to_spans ~wordsize =
  let to_bits i     = Bits.S.of_int i wordsize         in 
  let num_span      =
    (to_bits num_conts_ix, R.bits (to_bits 0) wordsize) in
  [num_span]
@
