% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et sts=4
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% inc: \usepackage{alltt}


% ------------------------------------------------------------------ 
\section{Collecting and emitting data for the run-time system}
% ------------------------------------------------------------------ 
The run-time system needs to examine stack frames that are suspended at call
sites or at continuations.
We refer to these locations collectively as {\em stopping points}.
For each stopping point, we emit information to tell the run-time system about
the stack frame.

The run-time system needs to know:
\begin{itemize}
\item the size of the frame,
\item the size of the incoming overflow block that must be deallocated by the
procedure,
\item the location of the return address,
\item the locations of stackdata,
\item the locations of values stored in callee-save registers on entry to the procedure,
\item the locations of local variables,
\item the locations of span data declared in the \pal~source, and
\item the locations of unwind continuations (currently unimplemented).
\end{itemize}

In order to avoid complications in threading this data through the compiler, 
we convert each type of data to spans.
Later, when we are ready to emit assembly code (compile-time constants have been
computed, etc.), we emit the spans as assembly code.

This module hides the representation of data as spans, as well as the encoding
of the spans as assembly.
The interface of the module provides functions to convert the different types of
data to spans and a single function to emit all the spans as assembly.

% ------------------------------------------------------------------ 
\subsection{The interface}
% ------------------------------------------------------------------ 
We expose two types of functions:
\begin{itemize}
\item Functions that convert data to a span.
\item A function that emits the spans as assembly.
\end{itemize}
The first conversion function takes a user's key and value and produces a span.
<<runtimedata.mli>>=
type spans
exception DeadValue
type label = string
type link  = Bits.bits Reloc.Simple.relocatable
val to_spans : sp:Rtl.loc -> prev_sp:Rtl.loc -> ra:Rtl.loc ->
               users:((Bits.bits * link) list) ->
               csregs:((Register.t * Rtl.loc option) list) ->
               conts:((label * Rtl.loc * (string * int) list) list) ->
               sds:(Rtl.loc list)                          ->
               vars:(Rtl.loc option array)                 ->
               spans
val upd_spans : (Rtl.loc -> Rtl.loc) -> spans -> unit
                (* may raise DeadValue *)
@ 
The run-time system needs to know how the register are mapped to constants.
<<runtimedata.mli>>=
type tgt  = ((Rtl.exp -> Automaton.t), Call.t) Target.t
val print_reg_map : tgt -> unit
@
After we have placed all the data in spans, we emit
the data as assembly by calling [[emit_as_asm]].
The function should be partially applied to an assembler, then added
to the optimization pipeline.
<<runtimedata.mli>>=
val emit_as_asm : tgt -> 'a Asm.assembler -> procsym:Symbol.t ->
                  (Rtl.rtl Cfgx.M.node * spans) list-> bool
@
It appears that the interpreter needs to know about user-defined spans and
stackdata.
<<runtimedata.mli>>=
val user_spans : spans -> (Bits.bits * Bits.bits Reloc.Simple.relocatable) list
val stackdata  : spans -> Rtl.loc list
@

% ------------------------------------------------------------------ 
\subsection{Imports, type definitions, and utilities}
% ------------------------------------------------------------------ 
A number of shorthands are used throughout the implementation.
<<runtimedata.ml>>=
type tgt   = ((Rtl.exp -> Automaton.t), Call.t) Target.t
let imposs = Impossible.impossible
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let unimp  = Impossible.unimp

type label = string
type link  = Bits.bits Reloc.Simple.relocatable
type spans = { mutable sp            : Rtl.loc
             ; mutable prev_sp       : Rtl.loc
             ; mutable ra            : Rtl.loc
             ; mutable users         : (Bits.bits * link) list
             ; mutable csregs        : (Register.t * Rtl.loc option) list
             ; mutable conts         : (label * Rtl.loc * (string * int) list) list
                                    (* (ra, sp, (hint, var number) list) *)
             ; mutable sds           : Rtl.loc list
             ; mutable vars          : Rtl.loc option array
             }
exception DeadValue
let to_spans ~sp ~prev_sp ~ra ~users ~csregs ~conts ~sds ~vars =
  { sp = sp;       prev_sp = prev_sp; ra = ra; users = users; csregs = csregs;
    conts = conts; sds = sds;         vars = vars }

(* Don't touch the user-defined spans -- not necessary *)
let upd_spans upd spans =
  let maybe_upd l = match l with
    | Some l -> (try Some (upd l) with DeadValue -> None)
    | None   -> None in
  spans.sp      <- upd spans.sp;
  spans.prev_sp <- upd spans.prev_sp;
  spans.ra      <- upd spans.ra;
  spans.csregs  <- List.map (fun (r,l) -> (r, maybe_upd l)) spans.csregs;
  spans.conts   <- List.map (fun (pc,sp,vars) -> (pc, upd sp, vars)) spans.conts;
  spans.sds     <- List.map upd spans.sds;
  Array.iteri (fun i l -> spans.vars.(i) <- maybe_upd l) spans.vars

module B  = Bits
module G  = Cfgx.M
module CT = Ctypes
module RM = Register.Map
module RS = Register.Set
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module W  = Rtlutil.Width
module Dn = Rtl.Dn
module Up = Rtl.Up
module T  = Target

module IM = Map.Make (struct type t = int let compare = compare end)
@

% ------------------------------------------------------------------ 
\subsubsection{Mapping data to expressions and emitting emitting spans as assembly}
% ------------------------------------------------------------------ 
At each stopping point, we emit information to tell the run-time system about
the stack frame.
We first separate out the spans that are visible throughout a procedure (stackdata).
The stackdata spans ([[sd_spans]]) are emitted in a separate table.
Then, for each stopping point, we emit the associated spans by calling
[[emit_site_spans]].
<<runtimedata.ml>>=
let emit_as_asm target asm ~procsym node_spans =
  let wordsize   = target.T.wordsize in
  let to_bits  i = Bits.S.of_int i wordsize  in 
  let zero       = Bits.zero wordsize in
  let one        = to_bits 1 in
  <<define [[order]] to establish the order of the spans>>
  <<define functions for emitting data>>
  <<define [[emit_sd_spans]] and [[emit_site_spans]]>>
  let prev_section = asm#current in
  emit_sd_spans ();
  List.iter emit_site_spans (order node_spans);
  asm#section prev_section;
  true
@
Be emitting the spans in the same order that the labels are emitted,
we can use binary search to find a span (since the labels will be
ordered properly).
<<define [[order]] to establish the order of the spans>>=
let order node_spans =
  match node_spans with
  | []       -> node_spans
  | (n,_)::_ ->
    let g = G.of_node n in
    let (_, map) =
      G.fold_layout (fun n (i,m) -> (i+1, IM.add (G.num n) i m)) (0,IM.empty) g in
    let num n = IM.find (G.num n) map in
    List.sort (fun (n1,_) (n2,_) -> compare (num n1) (num n2)) node_spans in
@
\paragraph{Emitting Stackdata Spans}
Stackdata spans have been attached to all the span collections.
They should all be identical, so we just pick one.
<<define [[emit_sd_spans]] and [[emit_site_spans]]>>=
let sd_label = asm#local (Idgen.label "stackdata") in
@
A stackdata map for $n$ stackdata labels is of size $n + 1$ words.
The first word gives the number of stackdata labels.
The next $n$ words give the stackdata labels in order.
<<define [[emit_sd_spans]] and [[emit_site_spans]]>>=
let emit_sd_spans () =
  match node_spans with
  | (_, spans)::_ ->
      asm#section "pcmap_data";
      asm#label   sd_label;
      asm#value   (Bits.U.of_int (List.length spans.sds) target.T.wordsize);
      List.iter   emit_loc spans.sds
 | [] -> () in
@
\paragraph{Emitting Stopping-Point Spans}
For each stopping point, we must emit the information stored in
the [[spans]].
The information is organized in two distinct areas.
The first area is a map from stopping points in the procedure to run-time
data associated with the stopping points.
The run-time data for each stopping point begins at the label [[frame_label]].
This map is placed in the [[pcmap]] section of the assembly code.

The second area is the collection of run-time data for each stopping point.
This data is placed in the [[pcmap_data]] section of the assembly code.

If a stopping point is a call node, its successor is the label we are suspended at;
otherwise, we expect the argument node to have a label.
<<define [[emit_sd_spans]] and [[emit_site_spans]]>>=
let emit_site_spans (node, spans) =
  let stop_l = match G.kind node with
    | G.Call -> G.label (G.succ_n node (G.altrets node))
    | G.Join -> G.label node
    | _ -> imposs "Runtimedata expected call or join node" in
  let frame_label = asm#local (Idgen.label "frame") in
  <<emit proc to run-time data map>>
  <<emit frame data>>   in
@
The first area consist of two consecutive pointers, one to the stopping point
and the other to the data associated with the stopping point:
\begin{verbatim}
.section pcmap
+--------------------+
| stopping_point_lbl |
+--------------------+
| frame_data_lbl     |
+--------------------+
\end{verbatim}
<<emit proc to run-time data map>>=
  asm#section "pcmap";
  asm#addr (Reloc.Simple.of_sum Rtl.codesym (asm#local stop_l) zero);
  asm#addr (Reloc.Simple.of_sum Rtl.datasym frame_label        zero);
@
The second area keeps track of the size of the frame, the size of the incoming overflow
block that the procedure must deallocate, the location of the return address,
a pointer to the stackdata table, the locations of registers, the local variables,
the spans, and the continuations (CONTINUATIONS ARE NOT YET IMPLEMENTED).
The layout looks like:
\begin{verbatim}
.section pcmap_data
frame_data_lbl:
+--------------------+
| frame_size         |
+--------------------+
| overflow_size      |
+--------------------+
| return_address     |
+--------------------+
| stackdata_table    |
+--------------------+
| num registers * 2  |
+--------------------+
| num locals         |
+--------------------+
| num spans          |
+--------------------+
| cont block size    |
+--------------------+
| registers          |
+--------------------+
| locals             |
+--------------------+  <--- cont offsets are from here
| num continuations  |
| cont 1 offset      |
|     ...            |
| cont n offset      |
| --------------     |
| cont 1 block       |
|     ...            |
| cont n block       |
+--------------------+
| spans              |
+--------------------+
\end{verbatim}

We emit each of these blocks in order, beginning with the \PAL\ internal spans.
<<emit frame data>>=
asm#section "pcmap_data";
asm#label frame_label;
emit_loc spans.sp;
emit_loc spans.prev_sp;
emit_loc spans.ra;
asm#addr (Reloc.Simple.of_sum Rtl.datasym sd_label zero);
emit_int (List.length spans.csregs * 2);
emit_int (Array.length spans.vars);
@
The source spans are laid out by index.
Because the indices may be sparse, we fill in any gaps with zeroes.
<<emit frame data>>=
let users       = List.map (fun (n,e) -> (Bits.S.to_int n,e)) spans.users in
let max_span_ix = List.fold_left (fun best (i,_) -> max i best) (-1) users in
@
And now, we fill in the rest of the data.
<<emit frame data>>=
emit_int (max_span_ix + 1);
emit_int (size_cont_block spans.conts);
List.iter emit_csreg spans.csregs;
Array.iter emit_maybe_loc   spans.vars;
emit_conts spans.conts;
@
The source spans are laid out by index.
Because the indices may be sparse, we fill in any gaps with zeroes.
<<emit frame data>>=
let span_arr = Array.init (max_span_ix + 1) (fun _ -> None) in
List.iter (fun (i,span) -> span_arr.(i) <- Some span) users;
Array.iter emit_user_span span_arr;
@
We cover each section of the frame data in detail.
In addition to emitting spans as assembly data, we provide functions
to convert each type of data (frame size, register contents, locals, etc.)
to spans.

% ------------------------------------------------------------------ 
\subsubsection{Conversion to/from spans}
% ------------------------------------------------------------------ 
We provide conversion functions to store a value in a span,
and we provide the functions to emit the expressions in these spans as 
assembly.

We define functions for emitting two possible types of data in a single word:
link-time constants and value locations.
A link-time constant can be emitted directly.
As a special case, we may encounter a constant false value when we expect a link-time
constant.
This case indicates that there the value is never used, so we emit 0.

A value location, on the other hand, is one of three types: dead, register, or
stack offset.
We distinguish between the three cases by using the two high bits as tags and using the
rest of the word to indicate the value's location.
\begin{enumerate}
\item Dead - The value is dead at this point in the procedure.
The two high bits are 0b00. Since a dead value has no location, we just emit 0x0.
\item Register - The value is stored in a register.
The two high bits are 0b01. Of the remaining $n$ bits, the low $n/2$
bits hold an index indicating the register, and the high $n/2$ bits hold an offset into
the register (in case the value is not stored in the low bits of the register).
\item Offset - The value is stored on the stack, at a fixed offset from the virtual
frame pointer.
The two high bits are 0b1s, where s is a sign bit.
The remaining bits store the magnitude of the offset from the virtual frame pointer.
\end{enumerate}

First, we define a slew of helpers to emit the different types of values.
<<define functions for emitting data>>=
<<define [[simplify_exp]] to simplify rtl expressions>>
let reg_ix r =
  try  RM.find r (snd target.T.reg_ix_map)
  with Not_found -> imposs "Register not found in map" in
let emit_dead_loc      ()    = asm#value zero in
let emit_link_const mk sym   = asm#addr (Reloc.Simple.of_sum mk sym zero) in
let offset_w = wordsize - 1 in
let emit_offset bits = (* possibly an offset *)
  let value    = Bits.S.to_int bits in
  (try ignore (Bits.S.of_int value offset_w)
   with Bits.Overflow -> imposs "Offset from vfp is too large for run-time encoding");
  asm#value (B.Ops.or' (B.Ops.shl  one (to_bits offset_w))
                       (B.Ops.shrl (B.Ops.shl (to_bits value) one) one)) in
let emit_int i = emit_offset (Bits.S.of_int i offset_w) in
let emit_reg ix offset =
  let offset_w = wordsize - 2 in
  let w'       = offset_w / 2 in
  (try ignore (Bits.S.of_int ix w'); ignore(Bits.S.of_int offset w')
   with Bits.Overflow -> imposs "Reg ix or offset is too large for run-time encoding");
  asm#value (B.Ops.or' (B.Ops.shl one (to_bits offset_w))
                         (B.Ops.or' (B.Ops.shl (to_bits offset) (to_bits w'))
                                      (to_bits ix))) in
@  
Then, we check the type of value (as encoded in the [[Rtl.exp]] type) and emit the
value in the proper format.
<<define functions for emitting data>>=
let emit_loc l =
  let mklink kind s w = Up.exp (RP.Const (RP.Link(s, kind, w))) in
  match Dn.loc (simplify_loc l) with
  | RP.Mem (_,_, RP.Const (RP.Link (sym,kind,_)),_)  ->
     emit_link_const (mklink kind) sym
  | RP.Mem (_,_, RP.Const (RP.Bits bs),_)            -> emit_offset   bs
  | RP.Reg r                                         -> emit_reg  (reg_ix r) 0
  | RP.Slice (_, i, RP.Reg r)                        -> emit_reg  (reg_ix r) i
  | _ -> impossf "unexpected location for span data: %s" (RU.ToString.loc l)  in
let emit_maybe_loc l = match l with
  | Some l -> emit_loc l
  | None   -> emit_dead_loc () in

let emit_csreg (reg, l) = (emit_loc (R.reg reg); emit_maybe_loc l) in
let emit_user_span reloc = match reloc with
  | None   -> emit_dead_loc ()
  | Some reloc -> asm#addr reloc in
@
To check that the continuation index is within bounds, we first emit the number
of unwind continuations.
For each continuation, we have:
\begin{enumerate}
\item A 1-word offset to locate the block.
\item 2 words for each variable argument to the continuation.
\item A 1-word ``end of variable'' marker.
\item A 1-word stack-pointer offset.
\item A 1-word return address.
\end{enumerate}
<<define functions for emitting data>>=
let size_cont_block conts =
  let n = List.length conts in
  let nvars = List.fold_left (fun rst (_,_,vars) -> List.length vars + rst) 0 conts in
  1 + 2 * nvars + 4 * n in
@
We emit the following data in the continuation block:
\begin{enumerate}
\item The number of continuations.
\item The offsets of the continuations.
\item The blocks for the continuations.
\end{enumerate}
The sizes of these blocks are as described above.
<<define functions for emitting data>>=
let emit_conts conts =
  let n = List.length conts in
  emit_int n;
  ignore (List.fold_left (fun offset (_,_,vs) -> emit_int offset;
                                                 offset + 2 * List.length vs + 3)
                         (n+1) conts);
  let emit_cont_block (pc, sp, vars) =
    List.iter (fun (h,i) -> emit_int i; emit_int (Ctypes.enum_int h)) vars;
    asm#value zero;
    asm#addr (Reloc.Simple.of_sum Rtl.datasym (asm#local pc) zero);
    emit_loc sp in
  List.iter emit_cont_block conts in
@
We provide a function to simplify an expression first by flattening slices such that
they consist of a single offset from a location (if applicable), then by calling
[[Simplify.exp]] on any expressions.
<<define [[simplify_exp]] to simplify rtl expressions>>=
let simplify_loc loc =
  let vfp     = target.T.vfp in
  let check w = if w mod wordsize <> 0 || w < 0 then
                   unimp (Printf.sprintf "unsupported size or alignment %d" w) in
  let is_vfp_offset e =
    let rec exp e = match e with
      | RP.Fetch (l,_)  -> loc l
      | RP.App (_,exps) -> List.fold_left (fun v e -> v || exp e) false exps
      | RP.Const _      -> false
    and loc l = if Vfp.is_vfp l then true else match l with
      | RP.Mem   (_,_,e,_) -> exp e
      | RP.Slice (_,_,l)   -> loc l
      | _                  -> false in
    exp e in
  let rec flatten offset l = match l with
    | RP.Mem ((_,_,mcell as ms),_,e,ass) when is_vfp_offset e ->
        let w = Rtlutil.Width.exp (Up.exp e) in
        check offset; check w;
        (*V.eprintf verb "Adding an offset %d of width %d\n" offset w;*)
        let e' = Rtlutil.add w (R.app (R.opr "sub" [w]) [Up.exp e; vfp])
                               (R.bits (Bits.S.of_int offset w) w) in
        R.mem (Up.assertion ass) ms (Cell.to_count mcell w) (Simplify.exp e')
    | RP.Mem (ms,w,e,ass) -> (* not a VFP offset *)
        R.mem (Up.assertion ass) ms w (Simplify.exp (Up.exp e))
    | RP.Reg r ->
        let w = Register.width r in
        check w; check offset;
        let l_up = Up.loc l in
        if offset <> 0 then
          R.slice w offset l_up
        else l_up
    | RP.Slice (_,i,l)       -> flatten (offset + i) l
    | RP.Var _ | RP.Global _ -> Up.loc l in
  flatten 0 (Dn.loc loc) in
@
It appears that the interpreter needs to know about user-defined spans and
stackdata.
<<runtimedata.ml>>=
let user_spans spans = spans.users
let stackdata  spans = spans.sds
@
The run-time system needs to know how the register are mapped to constants.
<<runtimedata.ml>>=
let print_reg_map tgt =
  let (n, map) = tgt.T.reg_ix_map in
  Printf.printf "Target has %d registers:\n" n;
  RM.iter (fun ((s,_,_),i,_) n -> Printf.printf "  %c[%d] -> %d\n" s i n) map
@
