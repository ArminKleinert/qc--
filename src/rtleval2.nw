% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% Come for the emacs, stay for the vim: ts=8 sw=4 et: 

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{RTL Constant Folding}
% ------------------------------------------------------------------ 

An {\rtl} expression can denote a compile-time, link-time, or run-time
value. The goal is to evaluate any {\rtl} expression as early as
possible to minimize computation at run-time. This module provides
routines to evaluate {\rtl} expressions and to simplify {\rtl}s by
evaluating expressions inside of them. The promise is, that the returned
{\rtl}s and expressions are simpler as the ones provided.

<<rtleval2.mli>>=
val rtl:    Rtl.rtl -> Rtl.rtl
val exp:    Rtl.exp -> Rtl.exp
val bits:   Rtl.exp -> Bits.bits    (* Error.ErrorExn, convenient function *)
val bool:   Rtl.exp -> bool         (* Error.ErrorExn, convenient function *)
@

The [[Unsafe]] module provides an simplification of {\rtl}s tries to
evaluate guarding expressions by elimination of registers in relations
of the form $r+k = r+k'$. However, this elimination is not semantics
preserving if the $r+k$ would overflow, but $k$ not.  

<<rtleval2.mli>>=
module Unsafe: sig
    val rtl:    Rtl.rtl -> Rtl.rtl
end
@

We export the list of operators we can evaluate at compile time. 

<<rtleval2.mli>>=
val compile_time_ops: string list
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation relies on the following idea: we evaluate an
expression (or {\rtl}) bottom up as far as possible. The final result
will tell us whether it needs further ecaluation at link-time or
run-time.

<<rtleval2.ml>>=
module RS = Reloc.Simple
module R  = Rtl
module RP = Rtl.Private
module D  = Rtl.Dn 
module U  = Rtl.Up

exception Error of string
type reloc     = Bits.bits RS.relocatable

let error msg  = raise (Error msg)
let impossible = Impossible.impossible

module Safe = struct
    <<RTL operator implementations>>
    <<traverse RTL>>
end    
@

The [[Unsafe]] module implements a more agressive simplification of
{\rtl}s that requires certain pre-conditions to be met. In particular,
it tries to evaluate guarding relational expressions like $r+k < r+k'$.
The simplification assumes that it is safe to eliminate the $r$ on both
sides of the $<$ operator.

<<rtleval2.ml>>=
module Unsafe = struct
    <<unsafe RTL simplification>>
end
@

The exported function work on the public representation of {\rtl}s

<<rtleval2.ml>>=
let rtl r  = try U.rtl (Safe.rtl (D.rtl r))
             with Error msg -> Impossible.impossible msg

let exp e  = try U.exp (Safe.exp (D.exp e))
             with Error msg -> Impossible.impossible msg

let bits e = match Safe.exp (D.exp e) with
             | RP.Const(RP.Bits(b)) -> b
             | _                    -> Error.error "not a constant value"
             
let bool e = match Safe.exp (D.exp e) with
             | RP.Const(RP.Bool(b)) -> b
             | _                    -> Error.error "not a constant condition"

let compile_time_ops = 
    [ "add"; "and"; "div"; "eq"; "mul"; "neg"; "ne"; "shl"; "shra";
      "shrl"; " sub"; "sx"]
@

% ------------------------------------------------------------------ 
\subsection{RTL Traversal}
% ------------------------------------------------------------------ 

All operator implementations have an easy way out: they just construct a
run-time expression from their arguments and return it. 

<<RTL operator implementations>>=
let default op w args = RP.App((op,w),args)

<<traverse RTL>>=   
let app o w args = match o with
    |  "NaN" 		-> default o w args
    |  "add" 		-> add w args
    |  "and" 		-> and' w args
    |  "bit" 		-> default o w args
    |  "bool" 		-> default o w args
    |  "borrow" 	-> default o w args
    |  "carry" 		-> default o w args
    |  "com" 		-> default o w args
    |  "conjoin" 	-> default o w args
    |  "disjoin" 	-> default o w args
    |  "div" 		-> div w args
    |  "divu" 		-> divu w args
    |  "eq" 		-> eq w args
    |  "f2f" 		-> default o w args
    |  "f2i" 		-> default o w args
    |  "fabs" 		-> default o w args
    |  "fadd" 		-> default o w args
    |  "fcmp" 		-> default o w args
    |  "fdiv" 		-> default o w args
    |  "feq" 		-> default o w args
    |  "fge" 		-> default o w args
    |  "fgt" 		-> default o w args
    |  "fle" 		-> default o w args
    |  "float_eq" 	-> default o w args
    |  "float_gt" 	-> default o w args
    |  "float_lt" 	-> default o w args
    |  "flt" 		-> default o w args
    |  "fmul" 		-> default o w args
    |  "fmulx" 		-> default o w args
    |  "fne" 		-> default o w args
    |  "fneg" 		-> default o w args
    |  "fordered" 	-> default o w args
    |  "fsqrt" 		-> default o w args
    |  "fsub" 		-> default o w args
    |  "funordered" 	-> default o w args
    |  "ge" 		-> default o w args
    |  "geu" 		-> default o w args
    |  "gt" 		-> gt  w args
    |  "gtu" 		-> gtu w args
    |  "i2f" 		-> default o w args
    |  "le" 		-> default o w args
    |  "leu" 		-> default o w args
    |  "lobits" 	-> default o w args
    |  "lt" 		-> lt w args
    |  "ltu" 		-> ltu w args
    |  "minf" 		-> default o w args
    |  "mod" 		-> default o w args
    |  "modu" 		-> default o w args
    |  "mul" 		-> mul w args
    |  "mul_trunc" 	-> mul_trunc w args
    |  "mulu" 		-> mulu w args
    |  "mzero" 		-> default o w args
    |  "ne" 		-> ne w args
    |  "neg" 		-> neg w args
    |  "not" 		-> default o w args
    |  "or" 		-> default o w args
    |  "pinf" 		-> default o w args
    |  "popcnt" 	-> default o w args
    |  "pzero" 		-> default o w args
    |  "quot" 		-> default o w args
    |  "rem" 		-> default o w args
    |  "rotl" 		-> default o w args
    |  "rotr" 		-> default o w args
    |  "round_down" 	-> round_down w args
    |  "round_nearest" 	-> round_nearest w args
    |  "round_up" 	-> round_up w args
    |  "round_zero" 	-> round_zero w args
    |  "shl" 		-> shl w args
    |  "shra" 		-> shra w args
    |  "shrl" 		-> shrl w args
    |  "sub" 		-> sub w args
    |  "sx" 		-> sx w args
    |  "unordered" 	-> default o w args
    |  "xor" 		-> default o w args
    |  "zx" 		-> default o w args
    |  "bitExtract" 	-> default o w args
    |  "bitInsert" 	-> default o w args
    |  "bitTransfer" 	-> default o w args
    |  o                -> default o w args
                      
let rec exp = function
    | RP.Const _ as c               -> c
    | RP.Fetch (l, w)               -> RP.Fetch (loc l, w)
    | RP.App ((o,w),args)           -> app o w (List.map exp args) 
        
and loc = function    
    | RP.Mem(sp, agg, w, e, ass)    -> RP.Mem(sp, agg, w, exp e, ass)
    | RP.Slice(w,i,l)               -> RP.Slice(w, i, loc l)
    | RP.Reg(sp, i, w) as v         -> v
    | RP.Var(s,i,w) as v            -> v

let effect = function
    | RP.Store(l,e,w)               -> RP.Store(loc l, exp e, w)
    | RP.Kill(l)                    -> RP.Kill(loc l)


let guarded (e, eff)                = (exp e, effect eff)
let rtl (RP.Rtl(es))                = RP.Rtl(List.map guarded es)
@

% ------------------------------------------------------------------ 
\subsection{Unsafe Simplification}
% ------------------------------------------------------------------ 

[[reg_offset]] recognizes a $r+k$ expression, where $r$ is a register
and $k$ a constant, and returns either boths as a pair, or [[None]].

<<unsafe RTL simplification>>=
let zero w = RP.Const(RP.Bits (Bits.U.of_int 0 w))
let reg_offset = function
    | RP.App(("add", _), [RP.Fetch(RP.Reg(r),_); RP.Const(_) as k]) -> 
        Some (r,k)
    | RP.Fetch(RP.Reg r, w) -> Some (r, zero w)
    | _                     -> None
@

<<unsafe RTL simplification old>>=
let rec app o w args = match Safe.app o w args with
    | RP.App (("eq"|"ltu"|"gtu"|"lt"|"gt" as op, w),
        [ RP.App(("add", _), [RP.Fetch(RP.Reg(r1),_); RP.Const(_) as k1 ])
        ; RP.App(("add", _), [RP.Fetch(RP.Reg(r2),_); RP.Const(_) as k2 ])
        ]) when r1 = r2 -> app op w [k1;k2]
    | x -> x    
        
<<unsafe RTL simplification>>=
let rec app o w args = match Safe.app o w args with
    | RP.App (("eq"|"ltu"|"gtu"|"lt"|"gt" as op, w), [left;right]) as x ->
        ( match reg_offset left, reg_offset right with
        | Some(r1,k1), Some(r2,k2) when r1 = r2 -> 
            let r = app op w [k1;k2] in
                ( Printf.eprintf "Rtleval2.app %s `%s` %s = %s\n"
                    (Rtlutil.ToReadableString.exp (Rtl.Up.exp k1))
                    op
                    (Rtlutil.ToReadableString.exp (Rtl.Up.exp k2))
                    (Rtlutil.ToReadableString.exp (Rtl.Up.exp r))
                ; flush stderr    
                ; r
                )    
        | _                                     -> x
        )
    | x -> x

let rec exp = function
    | RP.Const _ as c               -> c
    | RP.Fetch (l, w)               -> RP.Fetch (loc l, w)
    | RP.App ((o,w),args)           -> app o w (List.map exp args) 
        
and loc = function
    | RP.Mem(sp, agg, w, e, ass)    -> RP.Mem(sp, agg, w, exp e, ass)
    | RP.Slice(w,i,l)               -> RP.Slice(w, i, loc l)
    | RP.Reg(sp, i, w) as v         -> v
    | RP.Var(s,i,w) as v            -> v

let effect = Safe.effect

let guarded (e, eff)                = (exp e, effect eff)
let rtl' (RP.Rtl(es))               = RP.Rtl(List.map guarded es)

let rtl r  = try U.rtl (rtl' (D.rtl r)) 
             with Error msg -> Impossible.impossible msg

@

% ------------------------------------------------------------------ 
\subsection{RTL Operator Implementations}
% ------------------------------------------------------------------ 

Here are some helper functions used below.

<<RTL operator implementations>>=
let int64 = function
    | RP.Const(RP.Bits(x)) -> Bits.S.to_int64 x
    | _                    -> assert false

let uint64 = function
    | RP.Const(RP.Bits(x)) -> Bits.U.to_int64 x
    | _                    -> assert false

let int = function
    | RP.Const(RP.Bits(x)) -> Bits.S.to_int x
    | _                    -> assert false

let to_bits i w = RP.Const(RP.Bits(Bits.S.of_int64 i w))
let to_bool b   = RP.Const(RP.Bool(b)) 

let is_bits = function
    | RP.Const(RP.Bits(_)) -> true
    | _                    -> false
@

\paragraph{IEEE 754 Constants} How a rounding mode is represented is
implementation specific. We just pick four values here.

<<RTL operator implementations>>=
let round_down    w args = RP.Const(RP.Bits(Bits.U.of_int 3 2))
let round_up      w args = RP.Const(RP.Bits(Bits.U.of_int 2 2))
let round_nearest w args = RP.Const(RP.Bits(Bits.U.of_int 1 2))
let round_zero    w args = RP.Const(RP.Bits(Bits.U.of_int 0 2))


let rec add w args = match (w,args) with
    | [w],[RP.App(("add", [w']), [x; RP.Const (RP.Bits k)]); RP.Const (RP.Bits k')] 
                -> assert (w=w');
                   add [w] [x; RP.Const (RP.Bits (Bits.Ops.add k k'))]
    | [w],[RP.Const (RP.Bits x); RP.Const (RP.Bits y)]
                -> RP.Const (RP.Bits (Bits.Ops.add x y))
    | _         -> default "add" w args
    

let and' w args = match (w,args) with
    | [w],[x;y] when is_bits x && is_bits y
                -> to_bits (Int64.logand (int64 x) (int64 y)) w
    | _ -> default "and" w args

let div w args  = match (w,args) with
    | [w],[x;y] when is_bits x && is_bits y 
                -> to_bits (Int64.div (int64 x) (int64 y)) w
    | _         -> default "div" w args
    
let divu w args = default "divu" w args

let eq w args   = match (w,args) with
    | [w],[x;y] when is_bits x && is_bits y 
                -> to_bool ((int64 x) = (int64 y)) 
    | _         -> default "eq" w args
    

let mul w args  = match (w,args) with
    | [_;r],[x;y] when is_bits x && is_bits y 
                -> to_bits (Int64.add (int64 x) (int64 y)) r
    | _         -> default "mul" w args

let mul_trunc w args  = match (w,args) with 
    | [n],[x;y] when is_bits x && is_bits y 
                -> to_bits (Int64.add (int64 x) (int64 y)) n
    | _         -> default "mul_trunc" w args  

let mulu w args = default "mulu" w args

let neg w args  = match (w,args) with
    | [w], [x]  when is_bits x 
                -> to_bits (Int64.neg (int64 x)) w
    | _         -> default "neg" w args

let ne w args = match (w,args) with
    | [w], [x;y]  when is_bits x && is_bits y 
                -> to_bool ((int64 x) <> (int64 y))
    | _         -> default "ne" w args
    
let shl w args  = match (w,args) with
    | [w], [x;y] when is_bits x && is_bits y 
                -> to_bits (Int64.shift_left (int64 x) (int y)) w 
    | _         -> default "shl" w args

let shra w args  = match (w,args) with
    | [w], [x;y] when is_bits x && is_bits y 
                 -> to_bits (Int64.shift_right (int64 x) (int y)) w 
    | _          -> default "shra" w args

let shrl w args  = match (w,args) with
    | [w], [x;y] when is_bits x && is_bits y 
                 -> to_bits (Int64.shift_right_logical (int64 x) (int y)) w 
    | _          -> default "shrl" w args

let sub w args  = match (w,args) with
    | [w],[x;y] when is_bits x && is_bits y  
                -> to_bits (Int64.sub (int64 x) (int64 y)) w
    | _         -> default "sub" w args
    
let sx w args   = match (w,args) with
    | [i;j],[x] when is_bits x
                -> to_bits (int64 x) j
    | _         -> default "sx" w args

let ltu w args  = match args with
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                -> to_bool (Bits.Ops.ltu x y)
    | _         -> default "ltu" w args

let gtu w args  = match args with
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                -> to_bool (Bits.Ops.gtu x y)
    | _         -> default "gtu" w args

let lt w args  = match args with
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                -> to_bool (Bits.Ops.lt x y)
    | _         -> default "lt" w args

let gt w args  = match args with
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))]
                -> to_bool (Bits.Ops.gt x y)
    | _         -> default "gt" w args
    

@
