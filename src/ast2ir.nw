% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

% ------------------------------------------------------------------ 
\section{Translation into Abstract {\PAL}}
% ------------------------------------------------------------------ 

After a source file has been successfully parsed and its static
semantics have been found correct it is translated into abstract 
{\PAL}. Abstract {\PAL} is defined by an {\asdl} description
[[ir.asdl]] in source file [[[ir.nw]].

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

This module is called from the [[Main.main]] function with the name of
the source file; function [[ast2ir]] takes care of everything and
reports success or failure with an [[Error.error]] value.

<<ast2ir.mli>>=
val ast2ir: string -> unit Error.error
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

This module need a whole bunch of other modules.

<<ast2ir.ml>>=
module A  = Ast
module E  = Error
module R  = Rtl
module FF = Fenv
module G  = Fgraph
@

<<>>=
let rec ty env ir = function
    | A.TyAt(x,_)       -> ty env ir x
    | A.BitsTy(n)       -> true
    | A.AliasTy(name)   -> true

<<>>=
let rec lvalue env ir = function
    | A.LValueAt(x,_)   -> lvalue env ir x
    | A.Var(None,x)     -> true
    | A.Var(Some h,x)   -> true
    | A.Mem(t,e,a)      -> true
     

<<>>=
and actual env ir = function
    | (Some hint, e) -> true
    | (None     , e) -> true

<<>>=
and actuals env ir xs = true

<<>>=
and expr env ir = function
    | A.ExprAt(x,_)             -> expr env ir x
    | A.Int( i, None)           -> true
    | A.Int( i, Some t)         -> true
    | A.Float( f, None)         -> true
    | A.Float( f, Some t)       -> true
    | A.Char( c, None)          -> true
    | A.Char( c, Some t)        -> true
    | A.Fetch(v)                -> true
    | A.BinOp(l,op,r)           -> true
    | A.UnOp(op,e)              -> true
    | A.PrimOp(n,xs)            -> true


<<>>=
let memsize env ir = function
    | A.NoSize        -> true
    | A.DynSize       -> true
    | A.FixSize(e)    -> true

<<>>=
let rec init env ir = function
    | A.InitAt(x,_)   -> init env ir x
    | A.InitExprs(es) -> true
    | A.InitStr(s)    -> true
    | A.InitUStr(s)   -> true

<<>>=
let rec datum env ir = function
    | A.DatumAt(x,_)        -> datum env ir x
    | A.Label(n)            -> true
    | A.Align(a)            -> true
    | A.MemDecl(t,m,Some i) -> true
    | A.MemDecl(t,m,None)   -> true

<<>>=
let formal (h, v, t, n) = true

<<>>=
let formals  env ir xs               = true
let register env ir (v , t, n, reg)  = true
let altcont  env ir (e1,e2)          = true   
let targets env ir                   = true 
    
<<>>=
let rec flow env ir = function
    | A.FlowAt(x,_)     -> flow env ir x
    | A.CutsTo(ns)      -> true
    | A.UnwindsTo(ns)   -> true
    | A.ReturnsTo(ns)   -> true
    | A.Aborts          -> true

<<>>=
let flows env ir       = true
let conv env ir        = true
let export env ir t ns = true

<<>>=
let range env ir = function
    | A.Point(e)        -> true
    | A.Range(e1,e2)    -> true

<<>>=
let rec stmt env ir = function
    | A.StmtAt(x,_)                        -> stmt env ir x
    | A.IfStmt ( e, ss1, ss2)              -> true
    | A.LabelStmt(n)                       -> true
    | A.ContStmt(n,ns)                     -> true
    | A.SpanStmt(e1,e2,ss)                 -> true
    | A.AssignStmt(lhs,rhs)                -> true
    | A.CallStmt(lhs, cc, e, args, ts, fs) -> true
    | A.PrimStmt(lhs, cc, n, args, fs)     -> true
    | A.GotoStmt(e,ts)                     -> true
    | A.CutStmt(e, args, fs)               -> true
    | A.ReturnStmt(cc, alt, args)          -> true
    | A.JumpStmt(cc,e,args,ts)             -> true
    | A.EmptyStmt                          -> true
    | A.SwitchStmt (r,e,arms)              -> true
        
<<>>=
and body env ir = function
    | A.BodyAt(x, _)    -> body env ir x
    | A.DeclBody(d)     -> true
    | A.StmtBody(s)     -> true
    | A.DataBody(dd)    -> true
    
<<>>=
and proc env ir (cc,n,fs,ss) =  true

<<>>=
and decl env ir = function
    | A.DeclAt(x,_)    -> decl env ir x
    | A.Import( t, ns) -> true
    | A.Export( t, ns) -> true
    | A.Const (t,n,e)  -> true
    | A.Registers( rs) -> true
    | A.Typedef (t,nn) -> true
    | A.Target (arch)  -> true
    | A.Pragma         -> true

<<>>=
and section env ir = function
    | A.SectionAt(x,_)     -> section env ir x
    | A.Decl(d)            -> true
    | A.Datum( d)          -> true
    | A.Procedure(p)       -> true
    | A.SSpan( e1, e2, ss) -> true
            
<<>>=
and arm env ir = function
    | A.ArmAt(x,_)          -> arm env ir x
    | A.Case(ranges, stmts) -> true
    
<<>>=
let rec toplevel env ir = function
    | A.ToplevelAt(x, _)  -> toplevel env ir x
    | A.Section(name, ss) -> true
    | A.TopDecl(d)        -> true
    | A.TopProcedure(p)   -> true

<<>>=
let program env ir ds = true

<<>>=
let check map program =
    let env        = FF.Dirty.create map                    in
    let env        = Elab.Env.global env program            in
    let env        = Elab.Check.global env program          in
        if   FF.Dirty.errorFlag env
        then E.error "compilation aborted due to errors in static semantics"
        env  FF.Clean.create env
@

The function [[ast2ir]] scans, parses, and checks a file before the
translation in this module can start.

<<ast2ir.ml>>=
let ast2ir file =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; let ast        = Parse.program scanner lexbuf in
              let env        = check map ast                in
                  E.Ok()
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.Error
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.Error
              )
            | e ->
              ( finally()
              ; raise e
              )
@
