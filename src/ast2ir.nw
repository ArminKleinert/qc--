% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{Translation to Abstract {\PAL}}
% ------------------------------------------------------------------ 

After a source file has been successfully parsed and its static
semantics have been found correct it is translated into abstract 
{\PAL}. Abstract {\PAL} is defined by an {\asdl} description
[[ir.asdl]] in source file \module{ir}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Currently empty.

<<ast2ir.mli>>=
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

This module need a whole bunch of other modules.

<<ast2ir.ml>>=
module A  = Ast
module T  = Types
module E  = Error
module F  = Fenv.Clean

<<auxiliaries>>

module R = struct
    <<module R>>
end

module Expr = struct
    <<module Expr>>
end

module Make (G : Agraph.S) = struct
    module GM = G.Make
    <<module Make>> 
end

<<toplevel>>
@
 

% ------------------------------------------------------------------ 
\subsubsection{Auxiliaries}
% ------------------------------------------------------------------ 

Some auxiliary bindings.  The \module{ir} module defines a [[char]]
view for [[Rtl.space]].  However, the [[char]] type is only used in
{\asdl} \emph{data types that use} the [[space]] type, but
[[Rtl.space]] itself is still [[int]].  So we can not use this type to
annotate the [[default_memory]] definition. 

<<auxiliaries>>=
let default_convention         = "C--"  (* gospel truth *)
let default_assertion          = -1     (* unused *)
let default_memory             = 'm'    (* Rtl.space *)
@

<<>>=
let dummy_expression    = Rtl.Const(Rtl.Bits(Bits.zero 32, 32))
@

[[bits]] extracts a [[width]] from a type, i.e.~the number of bits.
This must be never applied to a [[bool]] value.

<<>>=
let bits = function
    | T.Bits n -> n
    | _        -> assert false
@

[[byteorder]] returns the byteorder as recorded in the environment. 

<<>>=
let byteorder env = match F.findEndianness env with
    | F.Big     -> Rtl.BigEndian
    | F.Little  -> Rtl.LittleEndian
@

[[un_const]] should take a compile-time constant expression and
produce a small itneger.  [[un_const]] is surely the wrong name.

<<>>=
let un_const e = 333 (* bogus *)
@ 

The target dependent sizes of pointers and words are recorded in the
fat environment.  The following two functions provide access to them. 
Additionally [[wordBits]] and [[pointerBits]] provide the bit sizes of
both.

<<>>=
let wordBits env        = F.findWordsize env 
let wordTy env          = T.bits (wordBits env)
let pointerBits env     = F.findPointersize env
let pointerTy env       = T.bits (pointerBits env)
@

Function composition is not provided by the {\ocaml} standard library. 
We provide it here:  [[f << g]] is a function that applies [[f]] to
the result of [[g]].  Think of data flowing from right to left.

<<>>=
let (<<) f g   = fun x -> f (g x)
@

% ------------------------------------------------------------------ 
\subsubsection{Module \texttt{Make}}
% ------------------------------------------------------------------ 

The implementation [[Make]] is a functor that receives an abstract
view ([[Agraph]] -- \module{agraph}) of the flow graph as an argument.


The [[ty]] function returns the number of bits denoted by a type in
the {\small AST}.

<<module Make>>=
let rec ty env = function
    | A.TyAt(x,_)       -> ty env x
    | A.BitsTy(n)       -> n
    | A.AliasTy(name)   -> ( match F.findt name env with
                           | attr, T.Bits n -> n
                           | _              -> assert false
                           )
@

The [[idTy]] function returns the number of bits denoted by a name
[[n]] which is looked up in the fat environment.

<<>>=                           
let idTy n env = match F.findv n env with attr, (denot,ty) -> bits ty
@

<<>>=
let scope = function
    | F.Global -> Rtl.Global
    | F.Local  -> Rtl.Local
@
                             
The following function translates an [[Ast.actual]] parameter into a
[[Fgraph.actual]].

<<>>=
let rec actual env (hint, e) = 
    let width = bits (Expr.tyExpr env e) in
    let e     = expr env e               in
        (e, width, hint)
@
 

% ------------------------------------------------------------------ 
\paragraph{Expressions}
% ------------------------------------------------------------------ 

[[expr]] translates an {\small AST} expression into an [[Rtl.expr]].  

An assignment is an effect that is captured by an {\rtl}.  The lvalue
of an assignment becomes a {\rtl} [[location]].  We currently ignore
alignments and hints. The only names on the left hand side of an
assignment are registers; all syntactically possible names (like
labels, continuations) must have been rejected by the static semantics
check.

<<>>=
and lvalue env = function
    | A.LValueAt(x,_)          -> lvalue env x
    | A.Var(hint,x)            -> 
        let ((_,s),(denot,t)) = F.findv x env in 
            ( match denot with
            | F.Register(r)    -> let width = bits t in 
                                  Rtl.Var
                                      ( x
                                      , scope s
                                      , r.F.index
                                      , r.F.hwreg  
                                      , width
                                      )
            | _                -> assert false (* impossible *)
            )
    | A.Mem(t,e,a)             -> let width = ty env t      in
                                  Rtl.Cell
                                      ( default_memory
                                      , byteorder env 
                                      , width
                                      , expr env e
                                      , default_assertion
                                      )
@

Not all variables as part of a {\PAL} expression are equal:  we have
to look at a variable's denotation to check wheter they are constant
values or locations from wich a value must be fetched. 

<<>>=
and variable env = function
    | A.LValueAt(x,_) -> variable env x
    | A.Var(hint,x)   ->
        let ((_,s),(denot,t)) = F.findv x env in 
            ( match denot with
            | F.Constant(b)    -> Rtl.Const(Rtl.Bits(b, bits t))
            | F.Label(F.Proc _)-> Rtl.Const(Rtl.Link(x, bits t))
            | F.Label(F.Code)  -> Rtl.Const(Rtl.Link(x, bits t))
            | F.Label(F.Data)  -> Rtl.Const(Rtl.Link(x, bits t))
            | F.Label(F.Stack) -> assert false (* don't know how *)
            | F.Import         -> Rtl.Const(Rtl.Link(x, bits t))
            | F.Register(r)    -> let width = bits t in 
                                  let v = Rtl.Var
                                      ( x
                                      , scope s
                                      , r.F.index
                                      , r.F.hwreg
                                      , width
                                      ) 
                                  in Rtl.Fetch(v,width)
            | F.Continuation   -> assert false (* don't know how *)
            )
    | A.Mem (t,e,a)            -> let width = ty env t      in
                                  let cell = Rtl.Cell
                                      ( default_memory
                                      , byteorder env 
                                      , width
                                      , expr env e
                                      , default_assertion
                                      ) in 
                                   Rtl.Fetch(cell,width)
                                    
            
<<>>=
and primOp env op args =
    let o = Expr.op env op args 
    in
        Rtl.App(o, List.map (expr env) args)

and expr env = function 
    | A.ExprAt(x,_)         -> expr env x
    | A.Int( i, None)       -> Rtl.Const(Rtl.Bits(i,wordBits env))
    | A.Int( i, Some t)     -> Rtl.Const(Rtl.Bits(i,ty env t))
    | A.Float( f, None)     -> Rtl.Const(Rtl.Bits(f,wordBits env))
    | A.Float( f, Some t)   -> Rtl.Const(Rtl.Bits(f,ty env t))
    | A.Char( c, None)      -> Rtl.Const(Rtl.Bits(c,wordBits env))
    | A.Char( c, Some t)    -> Rtl.Const(Rtl.Bits(c,ty env t))
    | A.Fetch(v)            -> variable env v
    | A.BinOp(l,op,r)       -> primOp env op [l;r]
    | A.UnOp(op,e)          -> primOp env op [e]
    | A.PrimOp(op,xs)       -> primOp env op (List.map snd xs) (* ignore hints*)
@    
   
% ------------------------------------------------------------------ 
\paragraph{Memory declarations}
% ------------------------------------------------------------------ 


<<>>=
let memsize env ir = function
    | A.NoSize        -> true
    | A.DynSize       -> true
    | A.FixSize(e)    -> true

<<>>=
let rec init env ir = function
    | A.InitAt(x,_)   -> init env ir x
    | A.InitExprs(es) -> true
    | A.InitStr(s)    -> true
    | A.InitUStr(s)   -> true

<<>>=
let rec datum env ir = function
    | A.DatumAt(x,_)        -> datum env ir x
    | A.Label(n)            -> true
    | A.Align(a)            -> true
    | A.MemDecl(t,m,Some i) -> true
    | A.MemDecl(t,m,None)   -> true


<<>>=
let register env ir (v , t, n, reg)  = true
@

% ------------------------------------------------------------------ 
\paragraph{Flow Annotations}
% ------------------------------------------------------------------     

Flow annotations are translated to continuation bundles of type
[[Fgraph.cont]].  The [[flows]] function takes a list of flow
annotations and adds them to a provided [[Fgraph.cont]] value.

<<>>=
let rec flows cont = function 
| (A.FlowAt (x,_)):: xx -> flows cont (x::xx)
| (A.CutsTo n)    :: xx -> flows {cont with GM.cuts    = n@cont.GM.cuts } xx
| (A.UnwindsTo n) :: xx -> flows {cont with GM.unwinds = n@cont.GM.unwinds} xx 
| (A.ReturnsTo n) :: xx -> flows {cont with GM.returns = n@cont.GM.unwinds} xx 
| (A.Aborts)      :: xx -> flows {cont with GM.aborts  = true } xx
| []                    -> cont     
@

% ------------------------------------------------------------------ 
\paragraph{Statements} 
% ------------------------------------------------------------------ 

A statement is part of a [[body]]; the [[body]] function receives
arguments that we need for all statements:  [[env]] is the clean
environment, which doesn't change.  [[s]] is the statement being
translated.  We return a new flow-graph node.  [[after]] is a
representation of the entire flow graph, with a pointer to the node
that follows this statement. 

<<>>=
let rec body env props graph after bb =
    let decorate n       = G.bind props n           in
    let rec stmt s after = match s with
        | A.StmtAt(x,_)     -> stmt x after
        <<cases for translating statements>>        in
    let rec body b after = match b with
        | A.BodyAt(x, _)    -> body x after
        | A.DeclBody(d)     -> after (* ignore decls *)
        | A.StmtBody(s)     -> stmt s after
        | A.DataBody(dd)    -> after (* ignore data for the moment *)
                                                    in
    let exit             = decorate (GM.exit graph) in
        List.fold_right body bb exit
@

<<cases for translating statements>>=
| A.AssignStmt(lhs,rhs) ->
    let effects = 
        List.map2 (fun lhs rhs -> 
                   R.assign (lvalue env lhs) (expr env rhs)) lhs rhs
    in 
        decorate (GM.assign (R.par effects) after)

<<cases for translating statements>>=
| A.IfStmt ( e, ss1, ss2) ->
    let n1 = List.fold_right stmt ss1 after in
    let n2 = List.fold_right stmt ss2 after in
    decorate (GM.branch (expr env e) n1 n2)
@

<<cases for translating statements>>=
| A.ReturnStmt(cc, alt, args) ->
    let const n = A.Int (Bits.of_int n Bits.maxwidth, None)   in
    let (cont, count) = Aux.Option.get (const 0, const 0) alt in
    let cc = Aux.Option.get default_convention cc             in
        decorate (GM.copy_out (List.map (actual env) args) Fgraph.ProcResults cc (
        decorate (GM.return graph (un_const cont) (un_const count))))

<<cases for translating statements>>=
| A.LabelStmt(n)                       -> decorate (GM.label n after)
@


A call [[x,y = f(v,w)]] is translated into the following sequence of
nodes in the flow graph:

\begin{enumerate}
\item A [[CopyOut]] node for the parameters [[v]] and [[w]],
\item a [[Call]] node for [[f]],
\item a [[CopyIn]] node for the variables [[x]] and [[y]],
\item the passed in [[after]] node.
\end{enumerate}

The left hand side of a call is a list of variables that is translated
to a [[Fgraph.formal list]] value that is passed to the [[CopyIn]]
node. 

<<cases for translating statements>>=
| A.CallStmt(lhs, cc, e, args, ts, fs) ->
    let rec lvalue = function
                     | A.LValueAt(x,_) -> lvalue x
                     | A.Var(hint,n)   -> (n,idTy n env ,hint)
                     | A.Mem _         -> assert false            in
    let cc         = Aux.Option.get default_convention cc         in
    let cout after = if args <> []
                     then decorate (GM.copy_out (List.map (actual env) args)
                                    Fgraph.ProcParameters cc after)
                     else after                                   in
    let cont after = flows (GM.empty_cont after) fs               in
    let call after = decorate (GM.call (expr env e) (cont after)) in
    let cin  after = if lhs <> []
                     then decorate (GM.copy_in (List.map lvalue lhs)
                                       Fgraph.ProcResults cc after)
                     else after                                   in
        (cout << call << cin) after
@

A continuation is represented by a labeled node.  This node is a
[[CopyIn]] node in case the continuation receives arguments.
        
<<cases for translating statements>>=
| A.ContStmt(n,ns) -> 
    let cc        = default_convention                                  in
    let args      = List.map (fun (hint,n) -> (n, idTy n env, hint)) ns in
    let cin after = if ns <> []
                    then decorate (GM.copy_in args Fgraph.ContParameters cc after)
                    else after                                          in
    let lbl after = decorate (GM.label n after)                         in
        (lbl << cin) after

<<cases for translating statements>>=
| A.EmptyStmt -> after
@

A tail call is a [[jump]] statement. The parameters, if any, are
handled by a [[CopyOut]] node in the flow graph representation.  The
actual sequence is the [[CopyOut]] node, followed by the [[Jump]]
node. The [[after]] node is not used in since a jump always ends a
sequence of statements.

<<cases for translating statements>>=
| A.JumpStmt(cc,e,args,ts) ->
    let cc         = Aux.Option.get default_convention cc     in
    let args       = List.map (actual env) args               in
    let cout after = if args <> [] then 
                        decorate (GM.copy_out args Fgraph.ProcParameters cc after)
                     else after                               in
    let jump after = decorate (GM.jump graph (expr env e) ts) in
        (cout << jump) after
@

The translation of a [[goto]] statement is straight forward; the
[[after]] node is unused because it can't be reached.

<<cases for translating statements>>=
| A.GotoStmt(e,ts) -> decorate (GM.goto graph (expr env e) ts)
@

A [[span]]'s attributes are a compile-time constant value and a
link-time constant.

<<cases for translating statements>>=
| A.SpanStmt(e1,e2,ss) ->
    let key   = ( match dummy_expression with (* constant eval *)
                | Rtl.Const(Rtl.Bits(bits,w)) -> bits
                | _                           -> assert false
                ) in
    let value = ( match dummy_expression with (* link-time constant *)
                | Rtl.Const(c)                -> c
                | _                           -> assert false
                ) in
        body env (G.Props.add_span key value props) graph after ss
@


The following statements are just skipped for the moment.    

<<cases for translating statements>>=
| A.PrimStmt(lhs, cc, n, args, fs)     -> assert false
| A.CutStmt(e, args, fs)               -> assert false
| A.SwitchStmt (r,e,arms)              -> assert false
@

<<unused>>=
let range env ir = function
    | A.Point(e)        -> true
    | A.Range(e1,e2)    -> true
@ 
<<>>=
and arm env ir = function
    | A.ArmAt(x,_)          -> arm env ir x
    | A.Case(ranges, stmts) -> true

% ------------------------------------------------------------------ 
\paragraph{Procedures}
% ------------------------------------------------------------------ 

Each procedure is translated into a control flow graph that shares no
nodes with any other control flow graph.  A procedure's control flow
graph is anchored with a label in an [[Agraph.graph]] data structure
under the name of the procedure. 

A procedure starts with a [[CopyIn]] node that assigns the incoming
parameters to the named registers and ends with an [[Exit]] node.  The
types of the formal parameters are bound in the local environment
belonging to a procedure.  The local environment [[env]] for a
procedure is found in its entry in the fat environment.

<<module Make>>=
and proc env env props graph (cc,n,fs,bb) =  
    let decorate n = G.bind props n                       in
    let env        = match F.findv n env with 
                     | _,(F.Label(F.Proc e),_) -> e
                     | _  -> assert false                 in
    let cc         = Aux.Option.get default_convention cc in
    let frml       = fun (h,i,t,n) -> (n,ty env t,h)      in
    let label a    = decorate (GM.label n a)              in
    let copy  a    = decorate (GM.copy_in (List.map frml fs)
                     Fgraph.ProcParameters cc a)          in
    let bdy   a    = body env props graph a bb            in
    let exit       = decorate (GM.exit graph)             in
        (label << copy << bdy) exit
@
    
    
% ------------------------------------------------------------------ 
\paragraph{Unused}
% ------------------------------------------------------------------ 

<<unused>>=
and decl env ir = function
    | A.DeclAt(x,_)    -> decl env ir x
    | A.Import( t, ns) -> true
    | A.Export( t, ns) -> true
    | A.Const (t,n,e)  -> true
    | A.Registers( rs) -> true
    | A.Typedef (t,nn) -> true
    | A.Target (arch)  -> true
    | A.Pragma         -> true

<<>>=
and section env ir = function
    | A.SectionAt(x,_)     -> section env ir x
    | A.Decl(d)            -> true
    | A.Datum( d)          -> true
    | A.Procedure(p)       -> true
    | A.SSpan( e1, e2, ss) -> true
            
    
% ------------------------------------------------------------------ 
\paragraph{Toplevel}
% ------------------------------------------------------------------ 

<<>>=
let rec toplevel env ir = function
    | A.ToplevelAt(x, _)  -> toplevel env ir x
    | A.Section(name, ss) -> true
    | A.TopDecl(d)        -> true
    | A.TopProcedure(p)   -> true
@


% ------------------------------------------------------------------ 
\paragraph{Program}
% ------------------------------------------------------------------ 

<<>>=
let program env ir ds = true
@

% ------------------------------------------------------------------ 
\subsubsection{{\rtl} Auxiliaries}
% ------------------------------------------------------------------ 

Module [[R]] contains auxiliary functions for {\rtl}s.  We like to
collect some from the actual usage patterns and then put them in their
own module. 

<<module R>>=
  let truth      = Rtl.Const(Rtl.Bool(true))
  let width_of r = 77 (* all exprs 77 bits wide - bogus *)
  let assign l r = Rtl.Rtl [(truth, Rtl.Store(l, r, width_of r))]
  let skip       = Rtl.Rtl []
  let par l      = List.fold_right 
                   (fun (Rtl.Rtl l1) (Rtl.Rtl l2) -> Rtl.Rtl (l1 @ l2)) l skip
@
 
% ------------------------------------------------------------------ 
\subsubsection{Expression Evaluation}
% ------------------------------------------------------------------ 

The translation of {\PAL} expressions to {\rtl} expressions requires
the types of {\PAL} expression and sometimes their values as well. 
There is code for both in the \module{elab} module.  Unfortunately
they are implemented against the [[Fenv.Dirty]] environment. 
Factoring this out is no small job.  For the moment we provide some
new code here.

<<module Expr>>=
let rec evalTy env = function
    | A.TyAt(x,r)    -> evalTy env x
    | A.BitsTy(size) -> Types.Bits size
    | A.AliasTy(n)   -> snd (F.findt n env)

let rec tyFetch env = function
    | A.LValueAt(x,r) -> tyFetch env x
    | A.Var(hint,id)  -> (match F.findv id env with (attr,(_,t)) -> t)
    | A.Mem (t,e,a)   -> 
        let te    = tyExpr env e       in       (* unused *)
        let t'    = evalTy env t       in       
        let align = Aux.Option.get 1 a in
            t'
@       

For now we are using the types of the primitive constant operators. 
All primitive runtime operators will go into their own module
[[Primitives]].  So we have to fix the [[lookup]] later.

<<>>=
and tyPrimOp env op args =
    let at = List.map (tyExpr env) args          in
    let ot = snd (Value.Ops.lookup op Value.ops) in
        Types.appl ot at

and op env o args =
    let at = List.map (tyExpr env) args          in
    let ot = snd (Value.Ops.lookup o Value.ops) in
        o,Types.widthlist ot at

<<>>=
and tyExpr env = function
    | A.ExprAt(x,r)            -> tyExpr env x
    | A.Int   (str, Some t)    -> evalTy env t
    | A.Int   (str, None)      -> wordTy env
    | A.Float (str, Some t)    -> evalTy env t
    | A.Float (str, None)      -> wordTy env
    | A.Char  (str, Some t)    -> evalTy env t
    | A.Char  (str, None)      -> wordTy env
    | A.Fetch (v)              -> tyFetch env v
    | A.BinOp (l,op,r)         -> tyPrimOp env op [l;r]
    | A.UnOp  (op,expr)        -> tyPrimOp env op [expr]
    | A.PrimOp(op,args)        -> tyPrimOp env op (List.map snd args)
@


% ------------------------------------------------------------------ 
\subsubsection{Exported top-level functions}
% ------------------------------------------------------------------ 

We now leave the implementation of [[Make]] and return to the
top-level of our module.  It contains functions called from module
\module{main} in response to command line arguments to the compiler.

<<toplevel>>=
let check map program =
    let env        = Fenv.Dirty.empty map                   in
    let env        = Elab.Env.global env program            in
    let env        = Elab.Check.global env program          in
        if   Fenv.Dirty.errorFlag env
        then E.error "compilation aborted due to errors in static semantics"
        else Fenv.clean env
@
