% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{Translation to Abstract {\PAL}}
% ------------------------------------------------------------------ 

After a source file has been successfully parsed and its static
semantics have been found correct it is translated into abstract 
{\PAL}. Abstract {\PAL} is defined by an {\asdl} description
[[ir.asdl]] in source file \module{ir}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Currently empty.

<<ast2ir.mli>>=
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

This module need a whole bunch of other modules.

<<ast2ir.ml>>=
module A  = Ast
module T  = Types
module E  = Error
module F  = Fenv.Clean

<<auxiliaries>>

module R = struct
    <<module R>>
end

module Expr = struct
    <<module Expr>>
end

module Make
  (G   : Agraph.S) 
  (Asm : Asm.S with type instruction = G.node) = 
struct
    module GM = G.Make
    <<module Make>> 
end
@
 

% ------------------------------------------------------------------ 
\subsubsection{Auxiliaries}
% ------------------------------------------------------------------ 

Some auxiliary bindings.  The \module{ir} module defines a [[char]]
view for [[Rtl.space]].  However, the [[char]] type is only used in
{\asdl} \emph{data types that use} the [[space]] type, but
[[Rtl.space]] itself is still [[int]].  So we can not use this type to
annotate the [[default_memory]] definition. 

<<auxiliaries>>=
let default_convention         = "C--"  (* gospel truth *)
let default_assertion          = -1     (* unused *)
let default_memory             = 'm'    (* Rtl.space *)
let toplevel_section           = "toplevel" (* bogus *)
@

<<>>=
let dummy_expression    = Rtl.Const(Rtl.Bits(Bits.zero 32, 32))
@

[[bits]] extracts a [[width]] from a type, i.e.~the number of bits.
This must be never applied to a [[bool]] value.

<<>>=
let bits = function
    | T.Bits n -> n
    | _        -> assert false
@

[[byteorder]] returns the byteorder as recorded in the environment. 

<<>>=
let byteorder env = match F.findEndianness env with
    | F.Big     -> Rtl.BigEndian
    | F.Little  -> Rtl.LittleEndian
@

[[un_const]] should take a compile-time constant expression and
produce a small itneger.  [[un_const]] is surely the wrong name.

<<>>=
let un_const e = 333 (* bogus *)
@ 

The target dependent sizes of pointers and words are recorded in the
fat environment.  The following two functions provide access to them. 
Additionally [[wordBits]] and [[pointerBits]] provide the bit sizes of
both.

<<>>=
let wordBits env        = F.findWordsize env 
let wordTy env          = T.bits (wordBits env)
let pointerBits env     = F.findPointersize env
let pointerTy env       = T.bits (pointerBits env)
@

Function composition is not provided by the {\ocaml} standard library. 
We provide it here:  [[f << g]] is a function that applies [[f]] to
the result of [[g]].  Think of data flowing from right to left.

<<>>=
let (<<) f g   = fun x -> f (g x)
@

Fold is an old friend of us. We like to abbreviate its name.

<<>>=
let foldl = List.fold_left
let foldr = List.fold_right
@


% ------------------------------------------------------------------ 
\subsubsection{Module \texttt{Make}}
% ------------------------------------------------------------------ 

The implementation [[Make]] is a functor that receives two modules as
arguments: an abstract assembler interface [[Asm]] and an abstract
flow graph interface [[Agraph]]. The functions in [[Make]] create
(abstract) assembly code where an instruction in the assembly code is
a flow graph. The flow graph will in later steps replaced by real
machine instructions.

An assembly program is basically a list of [[Asm.action]] value. We
like to avoid building this list directly and instead use a new type
[[asm]] with a some operations.  This gives us the chance to maintain
some state about the list constructed in order to respect constraints
that may be attached to an assembly program.  Rather than using the
[[::]] operator to build the list we use a function that can check its
current argument against some state.  

<<module Make>>=
type asm                = ASM of Asm.action list
let  empty              = ASM []
let (^^) x (ASM y)      = ASM (x::y)
let actions (ASM x)     = x
@

The [[ty]] function returns the number of bits denoted by a type in
the {\small AST}.

<<module Make>>=
let rec ty env = function
    | A.TyAt(x,_)       -> ty env x
    | A.BitsTy(n)       -> n
    | A.AliasTy(name)   -> ( match F.findt name env with
                           | attr, T.Bits n -> n
                           | _              -> assert false
                           )
@

The [[idTy]] function returns the number of bits denoted by a name
[[n]] which is looked up in the fat environment.

<<>>=                           
let idTy n env = match F.findv n env with attr, (denot,ty) -> bits ty
@

<<>>=
let scope = function
    | F.Global -> Rtl.Global
    | F.Local  -> Rtl.Local
@
                             
The following function translates an [[Ast.actual]] parameter into a
[[Fgraph.actual]].

<<>>=
let rec actual env (hint, e) = 
    let width = bits (Expr.tyExpr env e) in
    let e     = expr env e               in
        (e, width, hint)
@
 

% ------------------------------------------------------------------ 
\paragraph{Expressions}
% ------------------------------------------------------------------ 

[[expr]] translates an {\small AST} expression into an [[Rtl.expr]].  

An assignment is an effect that is captured by an {\rtl}.  The lvalue
of an assignment becomes a {\rtl} [[location]].  We currently ignore
alignments and hints. The only names on the left hand side of an
assignment are registers; all syntactically possible names (like
labels, continuations) must have been rejected by the static semantics
check.

<<>>=
and lvalue env = function
    | A.LValueAt(x,_)          -> lvalue env x
    | A.Var(hint,x)            -> 
        let ((_,s),(denot,t)) = F.findv x env in 
            ( match denot with
            | F.Register(r)    -> let width = bits t in 
                                  Rtl.Var
                                      ( x
                                      , scope s
                                      , r.F.index
                                      , r.F.hwreg  
                                      , width
                                      )
            | _                -> assert false (* impossible *)
            )
    | A.Mem(t,e,a)             -> let width = ty env t      in
                                  Rtl.Cell
                                      ( default_memory
                                      , byteorder env 
                                      , width
                                      , expr env e
                                      , default_assertion
                                      )
@

Not all variables as part of a {\PAL} expression are equal:  we have
to look at a variable's denotation to check wheter they are constant
values or locations from wich a value must be fetched. 

<<>>=
and variable env = function
    | A.LValueAt(x,_) -> variable env x
    | A.Var(hint,x)   ->
        let ((_,s),(denot,t)) = F.findv x env in 
            ( match denot with
            | F.Constant(b)    -> Rtl.Const(Rtl.Bits(b, bits t))
            | F.Label(F.Proc _)-> Rtl.Const(Rtl.Link(x, bits t))
            | F.Label(F.Code)  -> Rtl.Const(Rtl.Link(x, bits t))
            | F.Label(F.Data)  -> Rtl.Const(Rtl.Link(x, bits t))
            | F.Label(F.Stack) -> assert false (* don't know how *)
            | F.Import(None)   -> Rtl.Const(Rtl.Link(x, bits t))
            | F.Import(Some n) -> Rtl.Const(Rtl.Link(n, bits t))
            | F.Register(r)    -> let width = bits t in 
                                  let v = Rtl.Var
                                      ( x
                                      , scope s
                                      , r.F.index
                                      , r.F.hwreg
                                      , width
                                      ) 
                                  in Rtl.Fetch(v,width)
            | F.Continuation   -> assert false (* don't know how *)
            )
    | A.Mem (t,e,a)            -> let width = ty env t      in
                                  let cell = Rtl.Cell
                                      ( default_memory
                                      , byteorder env 
                                      , width
                                      , expr env e
                                      , default_assertion
                                      ) in 
                                   Rtl.Fetch(cell,width)
                                    
            
<<>>=
and primOp env op args =
    let o = Expr.op env op args 
    in
        Rtl.App(o, List.map (expr env) args)

and expr env = function 
    | A.ExprAt(x,_)         -> expr env x
    | A.Int( i, None)       -> Rtl.Const(Rtl.Bits(i,wordBits env))
    | A.Int( i, Some t)     -> Rtl.Const(Rtl.Bits(i,ty env t))
    | A.Float( f, None)     -> Rtl.Const(Rtl.Bits(f,wordBits env))
    | A.Float( f, Some t)   -> Rtl.Const(Rtl.Bits(f,ty env t))
    | A.Char( c, None)      -> Rtl.Const(Rtl.Bits(c,wordBits env))
    | A.Char( c, Some t)    -> Rtl.Const(Rtl.Bits(c,ty env t))
    | A.Fetch(v)            -> variable env v
    | A.BinOp(l,op,r)       -> primOp env op [l;r]
    | A.UnOp(op,e)          -> primOp env op [e]
    | A.PrimOp(op,xs)       -> primOp env op (List.map snd xs) (* ignore hints*)
@    
   
% ------------------------------------------------------------------ 
\paragraph{Memory declarations}
% ------------------------------------------------------------------ 


<<>>=
let memsize env x asm = match x with
    | A.NoSize        -> true
    | A.DynSize       -> true
    | A.FixSize(e)    -> true

<<module Make>>=
let initialized_data asm expr = assert false

let rec init env x asm = match x with
    | A.InitAt(x,_)   -> init env x asm
    | A.InitExprs(es) -> foldr initialized_data es asm
    | A.InitStr(s)    -> assert false
    | A.InitUStr(s)   -> assert false

<<module Make>>=
let rec datum env x asm = match x with
    | A.DatumAt(x,_)        -> datum env x asm
    | A.Label(n)            -> assert false
    | A.Align(a)            -> Asm.Align a ^^ asm
    | A.MemDecl(t,m,Some i) -> assert false
    | A.MemDecl(t,m,None)   -> assert false


<<unused>>=
let register env ir (v , t, n, reg)  = true
@

% ------------------------------------------------------------------ 
\paragraph{Flow Annotations}
% ------------------------------------------------------------------     

Flow annotations are translated to continuation bundles of type
[[Fgraph.cont]].  The [[flows]] function takes a list of flow
annotations and adds them to a provided [[Fgraph.cont]] value.

<<module Make>>=
let rec flows cont = function 
| (A.FlowAt (x,_)):: xx -> flows cont (x::xx)
| (A.CutsTo n)    :: xx -> flows {cont with GM.cuts    = n@cont.GM.cuts } xx
| (A.UnwindsTo n) :: xx -> flows {cont with GM.unwinds = n@cont.GM.unwinds} xx 
| (A.ReturnsTo n) :: xx -> flows {cont with GM.returns = n@cont.GM.unwinds} xx 
| (A.Aborts)      :: xx -> flows {cont with GM.aborts  = true } xx
| []                    -> cont     
@

% ------------------------------------------------------------------ 
\paragraph{Procedure Body} 
% ------------------------------------------------------------------ 

A procedure's body includes statements, declarations, and stack data. 
Statements are translated into an abstract flow graph, while
declarations are translated into abstract assembly code.  Since
statements and declarations can be mixed arbitrarily, their
translation can not be separated.  So the translation of a body
produces two results:  a flwo graph, and abstract assembly code.  To
make the handling of this pair easier, and to anticipate future
additions, they are bundled together as a new type [[ic]]
(intermediate code).  \ocaml's [[with]] syntax for functional record
``updates'' makes the handling of this type especially easy.

<<>>=
type ic         = { node:       G.node
                  ; asm:        asm
                  }
@

A statement is part of a [[body]]; the [[body]] function receives
arguments that we need for all statements:  [[env]] is the clean
environment, which doesn't change.  [[s]] is the statement being
translated.  We return a new flow-graph node.  [[ic]] is a
representation of the node and assembly code following this statement. 

<<>>=
let rec body env props graph (ic: ic) bb =
    let decorate n       = G.bind props n           in
    let rec stmt s after = match s with
        | A.StmtAt(x,_)     -> stmt x after
        <<cases for translating statements>>        in
    let rec body b ic = match b with
        | A.BodyAt(x, _)    -> body x ic
        | A.DeclBody(d)     -> assert false  (* to do *)
        | A.StmtBody(s)     -> stmt s ic
        | A.DataBody(dd)    -> assert false  (* to do *)
    in
        List.fold_right body bb ic
@

<<cases for translating statements>>=
| A.AssignStmt(lhs,rhs) ->
    let effects = 
        List.map2 (fun lhs rhs -> 
                   R.assign (lvalue env lhs) (expr env rhs)) lhs rhs
    in 
        { ic with node = decorate (GM.assign (R.par effects) ic.node) }

<<cases for translating statements>>=
| A.IfStmt ( e, ss1, ss2) ->
    let ic1 = List.fold_right stmt ss1 ic in
    let ic2 = List.fold_right stmt ss2 ic1 in
    { ic2 with node = decorate (GM.branch (expr env e) ic1.node ic2.node) }
@

<<cases for translating statements>>=
| A.ReturnStmt(cc, alt, args) ->
    let const n         = A.Int (Bits.of_int n Bits.maxwidth, None)        in
    let (cont, count)   = Aux.Option.get (const 0, const 0) alt            in
    let cc              = Aux.Option.get default_convention cc             in
    let actuals         = List.map (actual env) args                       in
    let cout a          = decorate (GM.copy_out actuals G.ProcResults cc a)in
    let ret  a          = decorate (GM.return graph
                                    (un_const cont) (un_const count))      in
        { ic with node = (cout << ret) ic.node }

<<cases for translating statements>>=
| A.LabelStmt(n)       -> {ic with node = decorate (GM.label n ic.node)}
@


A call [[x,y = f(v,w)]] is translated into the following sequence of
nodes in the flow graph:

\begin{enumerate}
\item A [[CopyOut]] node for the parameters [[v]] and [[w]],
\item a [[Call]] node for [[f]],
\item a [[CopyIn]] node for the variables [[x]] and [[y]],
\item the passed in [[after]] node.
\end{enumerate}

The left hand side of a call is a list of variables that is translated
to a [[Fgraph.formal list]] value that is passed to the [[CopyIn]]
node. 

<<cases for translating statements>>=
| A.CallStmt(lhs, cc, e, args, ts, fs) ->
    let rec lvalue = function
                     | A.LValueAt(x,_) -> lvalue x
                     | A.Var(hint,n)   -> (n,idTy n env ,hint)
                     | A.Mem _         -> assert false            in
    let cc         = Aux.Option.get default_convention cc         in
    let cout after = if args <> []
                     then decorate (GM.copy_out (List.map (actual env) args)
                                    G.ProcParameters cc after)
                     else after                                   in
    let cont after = flows (GM.empty_cont after) fs               in
    let call after = decorate (GM.call (expr env e) (cont after)) in
    let cin  after = if lhs <> []
                     then decorate (GM.copy_in (List.map lvalue lhs)
                                       G.ProcResults cc after)
                     else after                                   in
        { ic with node = (cout << call << cin) ic.node }
@

A continuation is represented by a labeled node.  This node is a
[[CopyIn]] node in case the continuation receives arguments.
        
<<cases for translating statements>>=
| A.ContStmt(n,ns) -> 
    let cc        = default_convention                                  in
    let args      = List.map (fun (hint,n) -> (n, idTy n env, hint)) ns in
    let cin after = if ns <> []
                    then decorate (GM.copy_in args G.ContParameters cc after)
                    else after                                          in
    let lbl after = decorate (GM.label n after)                         in
        { ic with node = (lbl << cin) ic.node }

<<cases for translating statements>>=
| A.EmptyStmt -> after
@

A tail call is a [[jump]] statement. The parameters, if any, are
handled by a [[CopyOut]] node in the flow graph representation.  The
actual sequence is the [[CopyOut]] node, followed by the [[Jump]]
node. The [[after]] node is not used in since a jump always ends a
sequence of statements.

<<cases for translating statements>>=
| A.JumpStmt(cc,e,args,ts) ->
    let cc         = Aux.Option.get default_convention cc     in
    let args       = List.map (actual env) args               in
    let cout after = if args <> [] then 
                        decorate (GM.copy_out args G.ProcParameters cc after)
                     else after                               in
    let jump after = decorate (GM.jump graph (expr env e) ts) in
        { ic with node = (cout << jump) ic.node }
@

The translation of a [[goto]] statement is straight forward; the
[[after]] node is unused because it can't be reached.

<<cases for translating statements>>=
| A.GotoStmt(e,ts) -> 
        { ic with node = decorate (GM.goto graph (expr env e) ts) }
@

A [[span]]'s attributes are a compile-time constant value and a
link-time constant.

<<cases for translating statements>>=
| A.SpanStmt(e1,e2,ss) ->
    let key   = ( match dummy_expression with (* constant eval *)
                | Rtl.Const(Rtl.Bits(bits,w)) -> bits
                | _                           -> assert false
                ) in
    let value = ( match dummy_expression with (* link-time constant *)
                | Rtl.Const(c)                -> c
                | _                           -> assert false
                ) in
        body env (G.Props.add_span key value props) graph ic ss
@


The following statements are just skipped for the moment.    

<<cases for translating statements>>=
| A.PrimStmt(lhs, cc, n, args, fs)     -> assert false
| A.CutStmt(e, args, fs)               -> assert false
| A.SwitchStmt (r,e,arms)              -> assert false
@

<<unused>>=
let range env ir = function
    | A.Point(e)        -> true
    | A.Range(e1,e2)    -> true
@ 
<<>>=
and arm env ir = function
    | A.ArmAt(x,_)          -> arm env ir x
    | A.Case(ranges, stmts) -> true
@

% ------------------------------------------------------------------ 
\paragraph{Procedures}
% ------------------------------------------------------------------ 

Each procedure is translated into a control flow graph that shares no
nodes with any other control flow graph.  The generation of the label
for this procedure is handled at the assembly level and not on the
flow graph level.  Thus, the first node of the flow graph is the entry
node.

A procedure really starts with a [[CopyIn]] node that assigns the
incoming parameters to the named registers and ends with an [[Exit]]
node.  The types of the formal parameters are bound in the local
environment belonging to a procedure.  The local environment [[env]]
for a procedure is found in its entry in the fat environment.

<<module Make>>=
and proc env props (asm: asm) (cc,n,fs,bb) =  
    let decorate n = G.bind props n                                in
    let env        = match F.findv n env with
                     | _,(F.Label(F.Proc e),_) -> e
                     | _  -> assert false                          in
    let graph      = GM.graph () (* fresh graph for this proc *)   in
    let cc         = Aux.Option.get default_convention cc          in
    let frml       = fun (h,i,t,n) -> (n,ty env t,h)               in
    let entry ic   = { ic with node = decorate (GM.entry ic.node)} in
    let copy  ic   = { ic with node = decorate (GM.copy_in (List.map frml fs)
                       G.ProcParameters cc ic.node) }              in
    let bdy   ic   = body env props graph ic bb                    in
    let exit       = { node = decorate (GM.exit graph)
                     ; asm  = asm
                     }                                             in
    let ic         = (entry << copy << bdy) exit                   in
    let sym        = Asm.Local(n)                                  in
        (  Asm.Function sym
        ^^ Asm.DefineSymbolHere sym
        ^^ Asm.EmitInstruction ic.node
        ^^ ic.asm
        )
@   

<<>>=    
and decl env x (asm: asm) = asm
@

<<unused>>=
and decl env x (asm: asm) = match x with
    | A.DeclAt(x,_)    -> decl env x asm
    | A.Import( t, ns) -> 
        let import = function
            | (None        , name )   -> Asm.Import name 
            | (Some foreign, _    )   -> Asm.Import foreign
        in
            foldr (fun n asm -> import n ^^ asm) ns asm 
    | A.Export( t, ns) -> 
        let export = function 
            | (name, Some foreign)    -> Asm.Export foreign
            | (name, None        )    -> Asm.Export name
        in foldr (fun n asm -> export n ^^ asm) ns asm 
    | A.Const (t,n,e)  -> asm (* skip *)
    | A.Registers( rs) -> asm (* skip *)
    | A.Typedef (t,nn) -> asm (* skip *)
    | A.Target (arch)  -> asm (* skip *)
    | A.Pragma         -> asm (* skip *)

<<module Make>>=
let rec section env props x (asm: asm) = match x with
    | A.SectionAt(x,_)     -> section env props x asm 
    | A.Decl(d)            -> assert false
    | A.Datum( d)          -> assert false
    | A.Procedure(p)       -> proc env props asm p
    | A.SSpan( e1, e2, ss) -> assert false
@            
    
    
% ------------------------------------------------------------------ 
\paragraph{Toplevel}
% ------------------------------------------------------------------ 

What to do with top-level procedures? They should go into some section
because otherwise they will end up in whatever section is currently
active which just seems wrong.

<<module Make>>=
let rec toplevel env x asm = match x with
    | A.ToplevelAt(x, _)  -> toplevel env x asm 
    | A.Section(name, ss) -> let s = foldr (section env G.Props.empty) ss asm 
                             in Asm.Section(name) ^^ s
    | A.TopDecl(d)        -> decl env d asm 
    | A.TopProcedure(p)   -> (  Asm.Section(toplevel_section) 
                             ^^ proc env G.Props.empty asm p
                             )
@


% ------------------------------------------------------------------ 
\paragraph{Program}
% ------------------------------------------------------------------ 

<<>>=
let program env tt =
    let asm = foldr (toplevel env) tt empty in
        ([],actions asm) 
      
@

% ------------------------------------------------------------------ 
\subsubsection{{\rtl} Auxiliaries}
% ------------------------------------------------------------------ 

Module [[R]] contains auxiliary functions for {\rtl}s.  We like to
collect some from the actual usage patterns and then put them in their
own module. 

<<module R>>=
  let truth      = Rtl.Const(Rtl.Bool(true))
  let width_of r = 77 (* all exprs 77 bits wide - bogus *)
  let assign l r = Rtl.Rtl [(truth, Rtl.Store(l, r, width_of r))]
  let skip       = Rtl.Rtl []
  let par l      = List.fold_right 
                   (fun (Rtl.Rtl l1) (Rtl.Rtl l2) -> Rtl.Rtl (l1 @ l2)) l skip
@
 
% ------------------------------------------------------------------ 
\subsubsection{Expression Evaluation}
% ------------------------------------------------------------------ 

The translation of {\PAL} expressions to {\rtl} expressions requires
the types of {\PAL} expression and sometimes their values as well. 
There is code for both in the \module{elab} module.  Unfortunately
they are implemented against the [[Fenv.Dirty]] environment. 
Factoring this out is no small job.  For the moment we provide some
new code here.

<<module Expr>>=
let rec evalTy env = function
    | A.TyAt(x,r)    -> evalTy env x
    | A.BitsTy(size) -> Types.Bits size
    | A.AliasTy(n)   -> snd (F.findt n env)

let rec tyFetch env = function
    | A.LValueAt(x,r) -> tyFetch env x
    | A.Var(hint,id)  -> (match F.findv id env with (attr,(_,t)) -> t)
    | A.Mem (t,e,a)   -> 
        let te    = tyExpr env e       in       (* unused *)
        let t'    = evalTy env t       in       
        let align = Aux.Option.get 1 a in
            t'
@       

For now we are using the types of the primitive constant operators. 
All primitive runtime operators will go into their own module
[[Primitives]].  So we have to fix the [[lookup]] later.

<<>>=
and tyPrimOp env op args =
    let at = List.map (tyExpr env) args          in
    let ot = snd (Value.Ops.lookup op Value.ops) in
        Types.appl ot at

and op env o args =
    let at = List.map (tyExpr env) args          in
    let ot = snd (Value.Ops.lookup o Value.ops) in
        o,Types.widthlist ot at

<<>>=
and tyExpr env = function
    | A.ExprAt(x,r)            -> tyExpr env x
    | A.Int   (str, Some t)    -> evalTy env t
    | A.Int   (str, None)      -> wordTy env
    | A.Float (str, Some t)    -> evalTy env t
    | A.Float (str, None)      -> wordTy env
    | A.Char  (str, Some t)    -> evalTy env t
    | A.Char  (str, None)      -> wordTy env
    | A.Fetch (v)              -> tyFetch env v
    | A.BinOp (l,op,r)         -> tyPrimOp env op [l;r]
    | A.UnOp  (op,expr)        -> tyPrimOp env op [expr]
    | A.PrimOp(op,args)        -> tyPrimOp env op (List.map snd args)
@


