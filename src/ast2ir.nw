% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{Translation to Abstract {\PAL}}
% ------------------------------------------------------------------ 

After a source file has been successfully parsed and its static
semantics have been found correct it is translated into abstract 
{\PAL}. Abstract {\PAL} is defined by an {\asdl} description
[[ir.asdl]] in source file \module{ir}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

<<ast2ir.mli>>=
(* empty *)
@

% ------------------------------------------------------------------ 
\subsection{Implementation Overview}
% ------------------------------------------------------------------ 

The generator for the intermediate representation is parameterized
over the assembler we use.  The assembler interface in turn is
abstract as well and is parameterized over the instruction set.  As a
first step into code generation we generate assembly code that uses a
flow graph to represent the body of procedures. 

<<ast2ir.ml>>=
module A  = Ast
module T  = Types
module E  = Error
module F  = Fenv.Clean

<<auxiliaries>>

module R = struct
    <<module R>>        (* RTL stuff *)
end

module Expr = struct    (* Expressions *)
    <<module Expr>>
end


module Make
  (G   : Agraph.S with type Make.ginit  = unit  )      
  (Asm : Asm2.S   with type instruction = G.node) =
struct
    module GM = G.Make
    <<module Make>> 
end
@
 

% ------------------------------------------------------------------ 
\subsection{Auxiliaries}
% ------------------------------------------------------------------ 

Some auxiliary bindings.  The \module{ir} module defines a [[char]]
view for [[Rtl.space]].  However, the [[char]] type is only used in
{\asdl} data types that \emph{use} the [[space]] type, but
[[Rtl.space]] itself is still [[int]].  So we can not use this type to
annotate the [[default_memory]] definition. 

<<auxiliaries>>=
let default_convention         = "C--"              (* gospel truth *)
let default_assertion          = -1                 (* unused *)
let default_memory             = 'm'                (* Rtl.space *)
let toplevel_section           = "toplevel"         (* bogus *)
@

<<>>=
let dummy_expression    = Rtl.Const(Rtl.Bits(Bits.zero 32, 32))
@

[[bits]] extracts a [[width]] from a type, i.e.~the number of bits.
This must be never applied to a [[bool]] value.

<<>>=
let bits = function
    | T.Bits n -> n
    | _        -> assert false
@

[[un_const]] should take a compile-time constant expression and
produce a small itneger.  [[un_const]] is surely the wrong name.

<<>>=
let un_const e = 333 (* bogus *)
@ 

Function composition is not provided by the {\ocaml} standard library. 
We provide it here:  [[f << g]] is a function that applies [[f]] to
the result of [[g]].  Think of data flowing from right to left.

<<>>=
let (<<) f g   = fun x -> f (g x)
@

Fold is an old friend of us. We like to abbreviate its name.

<<>>=
let foldl = List.fold_left
let foldr = List.fold_right
@


% ------------------------------------------------------------------ 
\subsection{Module \texttt{Make}}
% ------------------------------------------------------------------ 

The implementation [[Make]] is a functor that receives two modules as
arguments:  an abstract assembler interface [[Asm]] and an abstract
flow graph interface [[Agraph]].  The functions in [[Make]] create
(abstract) assembly code where an instruction in the assembly code is
a flow graph.  The flow graph will in later steps replaced by real
machine instructions.

<<module Make>>=
let (++)    = Asm.append   (* infix, left associative *)
let mangle  = Asm.mangle   (* name mangler C-- -> ASM *)
@

The [[ty]] function returns the number of bits denoted by a type in
the {\small AST}.

<<module Make>>=
let rec ty env = function
    | A.TyAt(x,_)       -> ty env x
    | A.BitsTy(n)       -> n
    | A.AliasTy(name)   -> ( match F.findt name env with
                           | attr, T.Bits n -> n
                           | _              -> assert false
                           )
@

The [[idTy]] function returns the number of bits denoted by a name
[[n]] which is looked up in the fat environment.

<<>>=                           
let idTy n env = match F.findv n env with attr, (denot,ty) -> bits ty
@

<<>>=
let scope = function
    | F.Global -> Rtl.Global
    | F.Local  -> Rtl.Local
@
                             
The following function translates an [[Ast.actual]] parameter into a
[[Fgraph.actual]].

<<>>=
let rec actual env (target: Target.info) (hint, e) = 
    let width = bits (Expr.tyExpr env target e) in
    let e     = expr env target e               in
        (e, width, hint)
@
 

% ------------------------------------------------------------------ 
\subsubsection{Expressions}
% ------------------------------------------------------------------ 

[[expr]] translates an {\small AST} expression into an [[Rtl.expr]].  

An assignment is an effect that is captured by an {\rtl}.  The lvalue
of an assignment becomes a {\rtl} [[location]].  We currently ignore
alignments and hints. The only names on the left hand side of an
assignment are registers; all syntactically possible names (like
labels, continuations) must have been rejected by the static semantics
check.

<<>>=
and lvalue env (target: Target.info) = function
    | A.LValueAt(x,_)          -> lvalue env target x
    | A.Var(hint,x)            -> 
        let ((_,s),(denot,t)) = F.findv x env in 
            ( match denot with
            | F.Register(r)    -> let width = bits t in 
                                  Rtl.Var
                                      ( x
                                      , scope s
                                      , r.F.index
                                      , ( match r.F.rhint with 
                                        | F.RReg s -> Some s
                                        | F.RHint _
                                        | F.RNone  -> None
                                        )
                                      , width
                                      )
            | _                -> assert false (* impossible *)
            )
    | A.Mem(t,e,a)             -> let width = ty env t in
                                  Rtl.Cell
                                      ( default_memory
                                      , target.Target.byteorder
                                      , width
                                      , expr env target e
                                      , default_assertion
                                      )
@

Not all variables as part of a {\PAL} expression are equal:  we have
to look at a variable's denotation to check wheter they are constant
values or locations from wich a value must be fetched. 

During this first code generation step we do not translate anything
inside of procedures to {\rtl}s. This means, only global variables
must be translated and inparticular variables denoting stackdata and
continuations can't show up here.

<<>>=
and variable (env: F.env) (target: Target.info) = function
    | A.LValueAt(x,_) -> variable env target x
    | A.Var(hint,x)   ->
        let ((_,s),(denot,t)) = F.findv x env in 
            ( match denot with
            | F.Constant(b)    -> Rtl.Const(Rtl.Bits(b, bits t))
            | F.Label(F.Proc _)-> Rtl.Const(Rtl.Link(x, bits t))
            | F.Label(F.Code)  -> Rtl.Const(Rtl.Link(x, bits t))
            | F.Label(F.Data)  -> Rtl.Const(Rtl.Link(x, bits t))
            | F.Import(None)   -> Rtl.Const(Rtl.Link(x, bits t))
            | F.Import(Some n) -> Rtl.Const(Rtl.Link(n, bits t))
            | F.Register(r)    -> 
                let width = bits t in
                let loc = Rtl.Var
                  ( x
                  , scope s
                  , r.F.index
                  , ( match r.F.rhint with 
                    | F.RReg s  -> Some s
                    | F.RHint _ -> None
                    | F.RNone   -> None
                    )
                  , width
                  ) 
                in Rtl.Fetch(loc,width)
                                  
            | F.Label(F.Stack x) -> assert false (* impossible *)
            | F.Continuation     -> assert false (* impossible *)
            )
    | A.Mem (t,e,a)            -> let width = ty env t      in
                                  let cell = Rtl.Cell
                                      ( default_memory
                                      , target.Target.byteorder
                                      , width
                                      , expr env target e
                                      , default_assertion
                                      ) in 
                                   Rtl.Fetch(cell,width)
                                    
            
<<>>=
and primOp env (target: Target.info) op args =
    let o = Expr.op env target op args 
    in
        Rtl.App(o, List.map (expr env target) args)

and expr env (target: Target.info) = function 
    | A.ExprAt(x,_)         -> expr env target x
    | A.Int( i, None)       -> Rtl.Const(Rtl.Bits(i,target.Target.wordsize))
    | A.Int( i, Some t)     -> Rtl.Const(Rtl.Bits(i,ty env t))
    | A.Float( f, None)     -> Rtl.Const(Rtl.Bits(f,target.Target.wordsize))
    | A.Float( f, Some t)   -> Rtl.Const(Rtl.Bits(f,ty env t))
    | A.Char( c, None)      -> Rtl.Const(Rtl.Bits(c,target.Target.wordsize))
    | A.Char( c, Some t)    -> Rtl.Const(Rtl.Bits(c,ty env t))
    | A.Fetch(v)            -> variable env target v
    | A.BinOp(l,op,r)       -> primOp env target op [l;r]
    | A.UnOp(op,e)          -> primOp env target op [e]
    | A.PrimOp(op,xs)       -> primOp env target op (List.map snd xs) (* ignore hints*)
@    

% ------------------------------------------------------------------ 
\subsubsection{Flow Annotations}
% ------------------------------------------------------------------     

Flow annotations are translated to continuation bundles of type
[[Fgraph.cont]].  The [[flows]] function takes a list of flow
annotations and adds them to a provided [[Fgraph.cont]] value.

<<module Make>>=
let rec flows cont = function 
| (A.FlowAt (x,_)):: xx -> flows cont (x::xx)
| (A.CutsTo n)    :: xx -> flows {cont with GM.cuts    = n@cont.GM.cuts } xx
| (A.UnwindsTo n) :: xx -> flows {cont with GM.unwinds = n@cont.GM.unwinds} xx 
| (A.ReturnsTo n) :: xx -> flows {cont with GM.returns = n@cont.GM.unwinds} xx 
| (A.Aborts)      :: xx -> flows {cont with GM.aborts  = true } xx
| []                    -> cont     
@

% ------------------------------------------------------------------ 
\subsubsection{Procedure Body} 
% ------------------------------------------------------------------ 

A procedure's body includes statements, declarations, and stack data. 
A statement is part of a [[body]]; the [[body]] function receives
arguments that we need for all statements:  [[env]] is the clean
environment, which doesn't change.  [[s]] is the statement being
translated.  We return a new flow-graph node. 

<<>>=
let rec body env target props graph after bb =
    let decorate n       = G.bind props n           in
    let rec stmt s after = match s with
        | A.StmtAt(x,_)     -> stmt x after
        <<cases for translating statements>>        in
    let rec body b after = match b with
        | A.BodyAt(x, _)    -> body x after
        | A.DeclBody(d)     -> ldecl d after
        | A.StmtBody(s)     -> stmt s after
        | A.DataBody(dd)    -> after (* can be ignored *)
    in
        List.fold_right body bb after
@

<<cases for translating statements>>=
| A.AssignStmt(lhs,rhs) ->
    let effects = 
        List.map2 (fun lhs rhs -> 
                   R.assign (lvalue env target lhs) 
                            (expr env target rhs)) lhs rhs
    in 
        decorate (GM.assign (R.par effects) after) 

<<cases for translating statements>>=
| A.IfStmt ( e, ss1, ss2) ->
    let node1 = List.fold_right stmt ss1 after  in
    let node2 = List.fold_right stmt ss2 after  in
        decorate (GM.branch (expr env target e) node1 node2)
@

<<cases for translating statements>>=
| A.ReturnStmt(cc, alt, args) ->
    let const n         = A.Int (Bits.of_int n Bits.maxwidth, None)        in
    let (cont, count)   = Aux.Option.get (const 0, const 0) alt            in
    let cc              = Aux.Option.get default_convention cc             in
    let actuals         = List.map (actual env target) args                in
    let cout a          = decorate (GM.copy_out actuals G.ProcResults cc a)in
    let ret  a          = decorate (GM.return graph
                                    (un_const cont) (un_const count))      in
        (cout << ret) after

<<cases for translating statements>>=
| A.LabelStmt(n)       -> decorate (GM.label n after)
@


A call [[x,y = f(v,w)]] is translated into the following sequence of
nodes in the flow graph:

\begin{enumerate}
\item A [[CopyOut]] node for the parameters [[v]] and [[w]],
\item a [[Call]] node for [[f]],
\item a [[CopyIn]] node for the variables [[x]] and [[y]],
\item the passed in [[after]] node.
\end{enumerate}

The left hand side of a call is a list of variables that is translated
to a [[Fgraph.formal list]] value that is passed to the [[CopyIn]]
node. 

<<cases for translating statements>>=
| A.CallStmt(lhs, cc, e, args, ts, fs) ->
    let rec lvalue = function
                     | A.LValueAt(x,_) -> lvalue x
                     | A.Var(hint,n)   -> (n,idTy n env ,hint)
                     | A.Mem _         -> assert false            in
    let cc         = Aux.Option.get default_convention cc         in
    let cout after = if args <> []
                     then decorate (GM.copy_out 
                                   (List.map (actual env target) args)
                                    G.ProcParameters cc after)
                     else after                                   in
    let cont after = flows (GM.empty_cont after) fs               in
    let call after = decorate (GM.call (expr env target e) (cont after)) in
    let cin  after = if lhs <> []
                     then decorate (GM.copy_in (List.map lvalue lhs)
                                       G.ProcResults cc after)
                     else after                                   in
        (cout << call << cin) after
@

A continuation is represented by a labeled node.  This node is a
[[CopyIn]] node in case the continuation receives arguments.
        
<<cases for translating statements>>=
| A.ContStmt(n,ns) -> 
    let cc        = default_convention                                  in
    let args      = List.map (fun (hint,n) -> (n, idTy n env, hint)) ns in
    let cin after = if ns <> []
                    then decorate (GM.copy_in args G.ContParameters cc after)
                    else after                                          in
    let lbl after = decorate (GM.label n after)                         in
        (lbl << cin) after

<<cases for translating statements>>=
| A.EmptyStmt     -> after
| A.CommentStmt _ -> after
@

A tail call is a [[jump]] statement. The parameters, if any, are
handled by a [[CopyOut]] node in the flow graph representation.  The
actual sequence is the [[CopyOut]] node, followed by the [[Jump]]
node. The [[after]] node is not used in since a jump always ends a
sequence of statements.

<<cases for translating statements>>=
| A.JumpStmt(cc,e,args,ts) ->
    let cc         = Aux.Option.get default_convention cc     in
    let args       = List.map (actual env target) args               in
    let cout after = if args <> [] then 
                        decorate (GM.copy_out args G.ProcParameters cc after)
                     else after                               in
    let jump after = decorate (GM.jump graph (expr env target e) ts) in
        (cout << jump) after 
@

The translation of a [[goto]] statement is straight forward; the
[[after]] node is unused because it can't be reached.

<<cases for translating statements>>=
| A.GotoStmt(e,ts) -> decorate (GM.goto graph (expr env target e) ts) 
@

A [[span]]'s attributes are a compile-time constant value and a
link-time constant.

<<cases for translating statements>>=
| A.SpanStmt(e1,e2,ss) ->
    let key   = ( match dummy_expression with (* constant eval *)
                | Rtl.Const(Rtl.Bits(bits,w)) -> bits
                | _                           -> assert false
                ) in
    let value = ( match dummy_expression with (* link-time constant *)
                | Rtl.Const(c)                -> c
                | _                           -> assert false
                ) in
        body env target (G.Props.add_span key value props) graph after ss
@


The following statements are just skipped for the moment.    

<<cases for translating statements>>=
| A.PrimStmt(lhs, cc, n, args, fs)     -> assert false
| A.CutStmt(e, args, fs)               -> assert false
| A.SwitchStmt (r,e,arms)              -> assert false
@

<<unused>>=
let range env ir = function
    | A.Point(e)        -> true
    | A.Range(e1,e2)    -> true
@ 
<<>>=
and arm env ir = function
    | A.ArmAt(x,_)          -> arm env ir x
    | A.Case(ranges, stmts) -> true
@

% ------------------------------------------------------------------ 
\subsubsection{Procedures}
% ------------------------------------------------------------------ 

Each procedure is translated into a control flow graph that shares no
nodes with any other control flow graph.  The generation of the label
for this procedure is handled at the assembly level and not on the
flow graph level.  Thus, the first node of the flow graph is the entry
node.

A procedure really starts with a [[CopyIn]] node that assigns the
incoming parameters to the named registers and ends with an [[Exit]]
node.  The types of the formal parameters are bound in the local
environment belonging to a procedure.  The local environment [[env]]
for a procedure is found in its entry in the fat environment.

<<module Make>>=
and proc env (target: Target.info) props (asm: Asm.asm) (cc,n,fs,bb) =  
    let decorate n = G.bind props n                              in
    let env        = match F.findv n env with
                     | _,(F.Label(F.Proc {F.env = e}),_) -> e
                     | _  -> assert false                        in
    let graph      = GM.graph () (* fresh graph for this proc *) in
    let cc         = Aux.Option.get default_convention cc        in
    let frml       = fun (h,i,t,n) -> (n,ty env t,h)             in
    let entry a    = decorate (GM.entry a)                       in
    let copy  a    = decorate (GM.copy_in (List.map frml fs)
                                          G.ProcParameters cc a) in
    let bdy   a    = body env target props graph a  bb           in
    let exit       = decorate (GM.exit graph)                    in
    let node       = (entry << copy << bdy) exit                 in
         asm ++ Asm.instr node
         (* what about defining a symbol here, etc?? *)
        
@

Local declarations are ignored for the moment. 
 
<<>>=    
and ldecl env after = after
@
   
% ------------------------------------------------------------------ 
\subsubsection{Global Memory declarations}
% ------------------------------------------------------------------ 

<<module Make>>=
let initialized_data asm expr = assert false

let rec init env target asm = function
    | A.InitAt(x,_)   -> init env target asm x
    | A.InitExprs(es) -> foldl initialized_data asm es
    | A.InitStr(s)    -> assert false
    | A.InitUStr(s)   -> assert false
@

In order to reserve memory for data we have to know how many objects
an sequence of initializing expressions defined. This number is
returned by [[init_size]].

<<>>=
let rec init_size = function
    | None   -> 1
    | Some i -> let rec loop = function 
                    | A.InitAt(x,_)   -> loop x
                    | A.InitExprs(es) -> List.length es
                    | A.InitStr(s)    -> assert false
                    | A.InitUStr(s)   -> assert false
                in 
                    loop i 
@

Data can be declared initialized or un-initialized. The amount of
memory used by a declaration is the size of the base-type times the
number of values of this type. 

<<>>=
let memdecl env target asm t size ini = 
    let sizeof = ty env t / target.Target.memsize (* no. of memsized objs *) in
    let n      = ( match size with
                 | A.DynSize    -> init_size ini
                 | A.NoSize     -> 1
                 | A.FixSize(e) -> un_const e (* bogus *)
                 ) in
        ( match ini with
        | None    -> asm ++ Asm.zeroes (n * sizeof)
        | Some ii -> init env target asm ii
        )
@

Data can be declared globally inside a section or a section-level
[[span]] and locally, inside a procedure as [[stackdata]].  The former
is directly translated into assembly action that reserve memory inside
a section, the latter becomes just an amount of memory that is
allocated inside a procedure's activation record.  Since the amount of
stack allocated data and the offsets associated with labels inside of
it are already entered into the fat environment (by
[[Elab.Check.stackdatum]]), stack data declaration can be ignored. 
Global data declarations, on the other hand, must be translated to
assembly actions.
 
<<module Make>>=
let rec datum env target asm = function
    | A.DatumAt(x,_)        -> datum env target asm x
    | A.Label(n)            -> asm ++ Asm.define_local (mangle n)
    | A.Align(a)            -> asm ++ Asm.align a 
    | A.MemDecl(t,m,init)   -> memdecl env target asm t m init
@
    
% ------------------------------------------------------------------ 
\subsubsection{Toplevel}
% ------------------------------------------------------------------ 

All global declarations have been processed at this stage and thus can
be ignored.  The only exception are (global) register declarations. 
Global registers can name a hardware register they are placed in.  We
need so way to record such an assignment.  All other locations for
global registers are determined by an automaton, see module
\module{callconv}. 

<<module Make>>=
let rec section env target props (asm: Asm.asm) = function
    | A.SectionAt(x,_)     -> section env target props asm x
    | A.Decl(d)            -> asm
    | A.Datum( d)          -> datum env target asm d
    | A.Procedure(p)       -> proc env target props asm p
    | A.SSpan( e1, e2, ss) -> assert false (* how? *)
@            

What to do with top-level procedures? They should go into some section
because otherwise they will end up in whatever section is currently
active which just seems wrong.

<<module Make>>=
let rec toplevel env target asm = function
    | A.ToplevelAt(x, _)  -> toplevel env target asm x
    | A.Section(name, ss) -> let asm = asm ++ Asm.section name  
                             in  foldl (section env target G.Props.empty) 
                                       asm ss
    | A.TopDecl(d)        -> asm (* nothing to do here *)
    | A.TopProcedure(p)   -> let asm = asm ++ Asm.section toplevel_section  
                             in proc env target G.Props.empty asm p
@


% ------------------------------------------------------------------ 
\subsubsection{Program}
% ------------------------------------------------------------------ 

Imports and exports of assembly symbols are announced once at the top
of the assembly program.  The sets of imported and exported symbols
are registered in the fat environment.  For details, see modules
\module{mangle}, and \module{elab}. 

<<>>=
let exports env asm = 
    Fenv.StrSet.fold (fun s asm -> asm ++ Asm.export (Asm.mangle s)) 
    (F.exported env) asm

let imports env asm =
    Fenv.StrSet.fold (fun s asm -> asm ++ Asm.import (Asm.mangle s)) 
    (F.imported env) asm

(* assign global registers *)

<<>>=
let program env target asm tt = 
    let asm = exports env asm in
    let asm = imports env asm in
        foldl (toplevel env target) asm 
@

An assembly program is initialized with a list of strings.  These are
probably target dependent and should be provided by [[target]].

<<>>=
let translate env target prog =
    let asm = Asm.init [] in
        program env target asm prog
@    

% ------------------------------------------------------------------ 
\subsection{{\rtl} Auxiliaries}
% ------------------------------------------------------------------ 

Module [[R]] contains auxiliary functions for {\rtl}s.  We like to
collect some from the actual usage patterns and then put them in their
own module. 

<<module R>>=
  let truth      = Rtl.Const(Rtl.Bool(true))
  let width_of r = 77 (* all exprs 77 bits wide - bogus *)
  let assign l r = Rtl.Rtl [(truth, Rtl.Store(l, r, width_of r))]
  let skip       = Rtl.Rtl []
  let par l      = List.fold_right 
                   (fun (Rtl.Rtl l1) (Rtl.Rtl l2) -> Rtl.Rtl (l1 @ l2)) l skip
@
 
% ------------------------------------------------------------------ 
\subsection{Expression Evaluation}
% ------------------------------------------------------------------ 

The translation of {\PAL} expressions to {\rtl} expressions requires
the types of {\PAL} expression and sometimes their values as well. 
There is code for both in the \module{elab} module.  Unfortunately
they are implemented against the [[Fenv.Dirty]] environment. 
Factoring this out is no small job.  For the moment we provide some
new code here.

<<module Expr>>=
let rec evalTy env = function
    | A.TyAt(x,r)    -> evalTy env x
    | A.BitsTy(size) -> Types.Bits size
    | A.AliasTy(n)   -> snd (F.findt n env)

let rec tyFetch env (target: Target.info) = function
    | A.LValueAt(x,r) -> tyFetch env target x
    | A.Var(hint,id)  -> (match F.findv id env with (attr,(_,t)) -> t)
    | A.Mem (t,e,a)   -> 
        let te    = tyExpr env target e in       (* unused *)
        let t'    = evalTy env t        in       
        let align = Aux.Option.get 1 a  in
            t'
@       

For now we are using the types of the primitive constant operators. 
All primitive runtime operators will go into their own module
[[Primitives]].  So we have to fix the [[lookup]] later.

<<>>=
and tyPrimOp env target op args =
    let at = List.map (tyExpr env target) args          in
    let ot = snd (Value.Ops.lookup op Value.ops) in
        Types.appl ot at

and op env target o args =
    let at = List.map (tyExpr env target) args          in
    let ot = snd (Value.Ops.lookup o Value.ops) in
        o,Types.widthlist ot at

<<>>=
and tyExpr env (target: Target.info) = function
    | A.ExprAt(x,r)            -> tyExpr env target x
    | A.Int   (str, Some t)    -> evalTy env t
    | A.Int   (str, None)      -> T.bits target.Target.wordsize
    | A.Float (str, Some t)    -> evalTy env t
    | A.Float (str, None)      -> T.bits target.Target.wordsize
    | A.Char  (str, Some t)    -> evalTy env t
    | A.Char  (str, None)      -> T.bits target.Target.wordsize
    | A.Fetch (v)              -> tyFetch env target v
    | A.BinOp (l,op,r)         -> tyPrimOp env target op [l;r]
    | A.UnOp  (op,expr)        -> tyPrimOp env target op [expr]
    | A.PrimOp(op,args)        -> tyPrimOp env target op (List.map snd args)
@


