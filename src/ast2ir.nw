% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% ------------------------------------------------------------------ 
\section{Translation into Abstract {\PAL}}
% ------------------------------------------------------------------ 

After a source file has been successfully parsed and its static
semantics have been found correct it is translated into abstract 
{\PAL}. Abstract {\PAL} is defined by an {\asdl} description
[[ir.asdl]] in source file \module{ir}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

This module is called from the [[Main.main]] function with the name of
the source file; function [[ast2ir]] takes care of everything and
reports success or failure with an [[Error.error]] value.

<<ast2ir.mli>>=
val ast2ir: string -> unit Error.error
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

This module need a whole bunch of other modules.

<<ast2ir.ml>>=
module A  = Ast
module E  = Error
module F  = Fenv
@

Some auxiliary bindings.
<<>>=
let standard_convention = "C--"  (* gospel truth *)
@

Module [[R]] contains auxiliary functions for {\rtl}s.  We like to
collect some from the actual usage patterns and then put them in their
own module. 

<<>>=
module R = struct
  let truth = Rtl.Const(Rtl.Bool(true))
  let width_of r = 77 (* all exprs 77 bits wide - bogus *)
  let assign l r = Rtl.Rtl [(truth, Rtl.Store(l, r, width_of r))]
  let skip = Rtl.Rtl []
  let par l = List.fold_right 
               (function Rtl.Rtl l1 -> function Rtl.Rtl l2 -> Rtl.Rtl (l1 @ l2)) l skip
end
@
 
[[un_const]] should take a compile-time constant expression and
produce a small itneger.  [[un_const]] is surely the wrong name.

<<ast2ir.ml>>=
let un_const e = 333 (* bogus *)
@ 

The implementation [[Make]] is a functor that receives an abstract
view of the flow graph as an argument.

<<ast2ir.ml>>=
module Make (G : Agraph.S) = struct
    module GM = G.Make
    <<module Make>> 
end
@ 

<<module Make>>=
let rec ty env ir = function
    | A.TyAt(x,_)       -> ty env ir x
    | A.BitsTy(n)       -> true
    | A.AliasTy(name)   -> true

<<>>=
let dummy_lvalue = Rtl.Var("dummy_variable", 32)
let rec lvalue env = function
    | A.LValueAt(x,_)   -> lvalue env x
    | A.Var(None,x)     -> dummy_lvalue
    | A.Var(Some h,x)   -> dummy_lvalue
    | A.Mem(t,e,a)      -> dummy_lvalue
     

<<>>=
let actuals env ir xs = true

<<>>=
let dummy_expression = Rtl.Const(Rtl.Bits(Bits.zero 32)) 
let width env expr = 77 (* every expression is 77 bits wide *)
let const n = A.Int (Bits.of_int n Bits.maxwidth, None) (* ugly *)
let rec expr env = function
    | A.ExprAt(x,_)             -> expr env x
    | A.Int( i, None)           -> dummy_expression
    | A.Int( i, Some t)         -> dummy_expression
    | A.Float( f, None)         -> dummy_expression
    | A.Float( f, Some t)       -> dummy_expression
    | A.Char( c, None)          -> dummy_expression
    | A.Char( c, Some t)        -> dummy_expression
    | A.Fetch(v)                -> dummy_expression
    | A.BinOp(l,op,r)           -> dummy_expression
    | A.UnOp(op,e)              -> dummy_expression
    | A.PrimOp(n,xs)            -> dummy_expression

<<>>=
let actual env (hint, e) = (expr env e, width env e, hint)

<<>>=
let memsize env ir = function
    | A.NoSize        -> true
    | A.DynSize       -> true
    | A.FixSize(e)    -> true

<<>>=
let rec init env ir = function
    | A.InitAt(x,_)   -> init env ir x
    | A.InitExprs(es) -> true
    | A.InitStr(s)    -> true
    | A.InitUStr(s)   -> true

<<>>=
let rec datum env ir = function
    | A.DatumAt(x,_)        -> datum env ir x
    | A.Label(n)            -> true
    | A.Align(a)            -> true
    | A.MemDecl(t,m,Some i) -> true
    | A.MemDecl(t,m,None)   -> true

<<>>=
let formal (h, v, t, n) = true

<<>>=
let formals  env ir xs               = true
let register env ir (v , t, n, reg)  = true
let altcont  env ir (e1,e2)          = true   
let targets env ir                   = true 
    
<<>>=
let rec flow env ir = function
    | A.FlowAt(x,_)     -> flow env ir x
    | A.CutsTo(ns)      -> true
    | A.UnwindsTo(ns)   -> true
    | A.ReturnsTo(ns)   -> true
    | A.Aborts          -> true

<<>>=
let flows env ir       = true
let conv env ir        = true
let export env ir t ns = true

<<>>=
let range env ir = function
    | A.Point(e)        -> true
    | A.Range(e1,e2)    -> true

@ 
[[env]] is the clean environment, which doesn't change.  [[s]] is the
statement being translated.  We return a new flow-graph node. 
[[after]] is a representation of the entire flow graph, with a pointer
to the node that follows this statement. 

<<>>=
let body env props graph =
  let rec stmt s after = match s with
    | A.StmtAt(x,_) -> stmt x after
    <<cases for translating statements>>
    | _ -> assert false (* remove me in due time *)
  in fun s -> stmt s (G.bind G.Props.empty (GM.exit graph))
@ 
<<cases for translating statements>>=
| A.AssignStmt(lhs,rhs) ->
    let effects = 
      List.map2 (fun lhs rhs -> R.assign (lvalue env lhs) (expr env rhs)) lhs rhs
    in props (GM.assign (R.par effects) after)

<<cases for translating statements>>=
| A.IfStmt ( e, ss1, ss2) ->
    let n1 = List.fold_right stmt ss1 after in
    let n2 = List.fold_right stmt ss2 after in
    props (GM.branch (expr env e) n1 n2)
@
[[un_const]] should take a compile-time constant expression and
produce a small itneger.  [[un_const]] is surely the wrong name.

We have omitted the hints!!!

<<cases for translating statements>>=
| A.ReturnStmt(cc, alt, args) ->
    let (cont, count) = Aux.Option.get (const 0, const 0) alt in
    let cc = Aux.Option.get standard_convention cc in
    props (GM.copy_out (List.map (actual env) args) Fgraph.ProcResults cc (
    props (GM.return graph (un_const cont) (un_const count))))
<<more cases for translating statements>>=
| A.LabelStmt(n)                       -> true
| A.ContStmt(n,ns)                     -> true
| A.SpanStmt(e1,e2,ss)                 -> true
| A.CallStmt(lhs, cc, e, args, ts, fs) -> true
| A.PrimStmt(lhs, cc, n, args, fs)     -> true
| A.GotoStmt(e,ts)                     -> true
| A.CutStmt(e, args, fs)               -> true
| A.JumpStmt(cc,e,args,ts)             -> true
| A.EmptyStmt                          -> true
| A.SwitchStmt (r,e,arms)              -> true
        
<<>>=
let rec body env ir = function
    | A.BodyAt(x, _)    -> body env ir x
    | A.DeclBody(d)     -> true
    | A.StmtBody(s)     -> true
    | A.DataBody(dd)    -> true
    
<<>>=
and proc env ir (cc,n,fs,ss) =  true

<<>>=
and decl env ir = function
    | A.DeclAt(x,_)    -> decl env ir x
    | A.Import( t, ns) -> true
    | A.Export( t, ns) -> true
    | A.Const (t,n,e)  -> true
    | A.Registers( rs) -> true
    | A.Typedef (t,nn) -> true
    | A.Target (arch)  -> true
    | A.Pragma         -> true

<<>>=
and section env ir = function
    | A.SectionAt(x,_)     -> section env ir x
    | A.Decl(d)            -> true
    | A.Datum( d)          -> true
    | A.Procedure(p)       -> true
    | A.SSpan( e1, e2, ss) -> true
            
<<>>=
and arm env ir = function
    | A.ArmAt(x,_)          -> arm env ir x
    | A.Case(ranges, stmts) -> true
    
<<>>=
let rec toplevel env ir = function
    | A.ToplevelAt(x, _)  -> toplevel env ir x
    | A.Section(name, ss) -> true
    | A.TopDecl(d)        -> true
    | A.TopProcedure(p)   -> true

<<>>=
let program env ir ds = true
@

We now leave the implementation of [[Make]] and return to the
top-level of our module.  It contains functions called from module
\module{main} in response to command line arguments to the compiler.

<<ast2ir.ml>>=
let check map program =
    let env        = F.Dirty.empty map                      in
    let env        = Elab.Env.global env program            in
    let env        = Elab.Check.global env program          in
        if   F.Dirty.errorFlag env
        then E.error "compilation aborted due to errors in static semantics"
        else F.clean env
@

The function [[ast2ir]] scans, parses, and checks a file before the
translation in this module can start.

<<ast2ir.ml>>=
let ast2ir file =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; let ast        = Parse.program scanner lexbuf in
              let env        = check map ast                in
                  E.Ok()
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.Error
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.Error
              )
            | e ->
              ( finally()
              ; raise e
              )
@
