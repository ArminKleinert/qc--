% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{Translation to Abstract {\PAL}}
% ------------------------------------------------------------------ 

After a source file has been successfully parsed and its static
semantics have been found correct it is translated into abstract 
{\PAL}. Abstract {\PAL} is defined by an {\asdl} description
[[ir.asdl]] in source file \module{ir}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

<<ast2ir.mli>>=
module Make 
    (G      : Acfg.S with type    init       = string * Fenv.Clean.proc) 
    (Asm    : Asm2.S   with type instruction = G.cfg
                       with type init        = unit) :
sig
    module StrMap: Map.S with type key = string
    type program = Automaton.location StrMap.t * Asm.asm
    val translate: Fenv.Clean.env -> Target.t -> Ast.program -> program  
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation Overview}
% ------------------------------------------------------------------ 

The generator for the intermediate representation is parameterized
over the assembler we use.  The assembler interface in turn is
abstract as well and is parameterized over the instruction set.  As a
first step into code generation we generate assembly code that uses a
flow graph to represent the body of procedures. 

<<ast2ir.ml>>=
module A  = Ast
module T  = Types
module E  = Error
module F  = Fenv.Clean

<<auxiliaries>>

module R = struct
    <<module R>>        (* RTL stuff *)
end

module Expr = struct    (* Expressions *)
    <<module Expr>>
end


module Make
  (G         : Acfg.S   with type init = string * Fenv.Clean.proc)
  (Asm       : Asm2.S   with type instruction  = G.cfg
                        with type init = unit) =
struct
    module GM     = G
    module AG     = Acfg
    module StrMap = Map.Make(struct type t=string let compare=compare end)
    <<module Make>> 
end
@
 

% ------------------------------------------------------------------ 
\subsection{Auxiliaries}
% ------------------------------------------------------------------ 

Some auxiliary bindings.  The \module{ir} module defines a [[char]]
view for [[Rtl.space]].  However, the [[char]] type is only used in
{\asdl} data types that \emph{use} the [[space]] type, but
[[Rtl.space]] itself is still [[int]].  So we can not use this type to
annotate the [[default_memory]] definition. 

<<auxiliaries>>=
let default_convention         = "C--"              (* gospel truth *)
let default_assertion          = Rtl.none
let default_memory             = ('m' : Rtl.space)
@

Top-level procedures go into text [[text]] assembler section.

<<auxiliaries>>=
let toplevel_section           = "text"  
@

<<auxiliaries>>=
let dummy_expression    = Rtl.bits (Bits.zero 32) 32
@

[[bits]] extracts a [[width]] from a type, i.e.~the number of bits.
This must be never applied to a [[bool]] value.

<<auxiliaries>>=
let bits = function
    | T.Bits n -> n
    | _        -> assert false
@

[[un_const]] should take a compile-time constant expression and
produce a small itneger.  [[un_const]] is surely the wrong name.

<<auxiliaries>>=
let un_const e = 333 (* bogus *)
@

Function composition is not provided by the {\ocaml} standard library. 
We provide it here:  [[f @<< g]] is a function that applies [[f]] to
the result of [[g]].  Think of data flowing from right to left.

<<auxiliaries>>=
let (@<<) f g   = fun x -> f (g x)
@

Fold is an old friend of us. We like to abbreviate its name.

<<auxiliaries>>=
let foldl = List.fold_left
let foldr = List.fold_right
@

Calling conventions are accessed by name in the [[Target.info]] data
structure. Currently the \module{elab} module dos not check that a
given calling convention is known. Until this is fixed we will raise
an exception.

<<auxiliaries>>=
let find_cc cc target =
    try Target.StrMap.find cc target#cc
    with Not_found -> raise (E.ErrorExn ("unknown calling convention "^cc))
@

% ------------------------------------------------------------------ 
\subsection{Module \texttt{Make}}
% ------------------------------------------------------------------ 

The implementation [[Make]] is a functor that receives two modules as
arguments:  an abstract assembler interface [[Asm]] and an abstract
flow graph interface [[Agraph]].  The functions in [[Make]] create
(abstract) assembly code where an instruction in the assembly code is
a flow graph.  The flow graph will in later steps replaced by real
machine instructions.

<<module Make>>=
let (++)    = Asm.append   (* infix, left associative *)
@

The [[ty]] function returns the number of bits denoted by a type in
the {\small AST}.

<<module Make>>=
let rec ty env = function
    | A.TyAt(x,_)       -> ty env x
    | A.BitsTy(n)       -> n
    | A.AliasTy(name)   -> ( match F.findt name env with
                           | attr, T.Bits n -> n
                           | _              -> assert false
                           )
@

The [[idTy]] function returns the number of bits denoted by a name
[[n]] which is looked up in the fat environment.

<<module Make>>=
let idTy n env = match F.findv n env with attr, (denot,ty) -> bits ty
@
                             

[[formal]] builds the [[Agraph.formal]] record for a variable that is
a formal parameter. 

<<module Make>>=
let formal env n =
    ( match snd (F.findv n env) with 
    | (F.Register {F.index=i; F.rhint=h},ty) when F.is_localv n env  -> 
        { AG.name  = n
        ; AG.width = bits ty
        ; AG.hint  = ( match h with
                     | F.RReg _  -> assert false (* impossible *)
                     | F.RHint s -> Some s
                     | F.RNone   -> None
                     )
        ; AG.index = i
        } 
    | (F.Register {F.index=i; F.rhint=h},ty) ->
        assert false (* don't how to to translate global registers *)
    | _ -> assert false
    )
@
 
The following function translates an [[Ast.actual]] parameter into a
[[Fgraph.actual]].

<<module Make>>=
let rec actual env (target: Target.t) globals (hint, e) = 
    let width = bits (Expr.tyExpr env target e) in
    let e     = expr env target globals e       in
        (e, width, hint)
@

% ------------------------------------------------------------------ 
\subsubsection{Expressions}
% ------------------------------------------------------------------ 

[[expr]] translates an {\small AST} expression into an [[Rtl.exp]].  

A variable as part of an expression denotes a value; it is translated
into a [[Rtl.exp]].  Depending on the denotation of the variable it
becomes a constant of either link-time or compile-time, or something
more complicated.  If the variable is a local register, it becomes a
[[Rtl.var]] value, if it is global, it can be looked up in
[[globals]].

<<module Make>>=
and variable (env: F.env) (target: Target.t) globals = function
    | A.LValueAt(x,_) -> variable env target globals x
    | A.Var(hint,x)   ->
        let (_,(denot,t)) = F.findv x env in 
            ( match denot with
            | F.Constant(b)    -> Rtl.bits b (bits t)
            | F.Label(F.Proc _)-> Rtl.link x (bits t)
            | F.Label(F.Code)  -> Rtl.link x (bits t)
            | F.Label(F.Data)  -> Rtl.link x (bits t)
            | F.Import(None)   -> Rtl.link x (bits t)
            | F.Import(Some n) -> Rtl.link n (bits t)
            | F.Register(r)    -> 
                ( match F.is_localv x env with
                | false  -> let (write,read) = 
                                ( try StrMap.find x globals with
                                | Not_found -> assert false
                                )
                              in read
                | true   ->  
                    let width = bits t in
                    let loc   = Rtl.var x r.F.index width
                    in Rtl.fetch loc width
                )                  
            | F.Label(F.Stack (offset,label)) -> 
                E.error "access to stack data not implemented"
                
            | F.Continuation     -> assert false (* impossible *)
            )
    | A.Mem (t,e,a)            -> let width = ty env t      in
                                  let cell = Rtl.cell
                                      default_assertion
                                      default_memory
                                      target#byteorder
                                      width
                                      (expr env target globals e)
                                      in 
                                   Rtl.fetch cell width
                                    
            
<<module Make>>=
and primOp env (target: Target.t) globals op args =
    let (o, ws) = Expr.op env target op args 
    in
        Rtl.app (Rtl.opr o ws) (List.map (expr env target globals) args)

and expr env (target: Target.t) globals = function 
    | A.ExprAt(x,_)         -> expr env target globals x
    | A.Int( i, None)       -> Rtl.bits i (target#wordsize)
    | A.Int( i, Some t)     -> Rtl.bits i (ty env t)
    | A.Float( f, None)     -> Rtl.bits f (target#wordsize)
    | A.Float( f, Some t)   -> Rtl.bits f (ty env t)
    | A.Char( c, None)      -> Rtl.bits c (target#wordsize)
    | A.Char( c, Some t)    -> Rtl.bits c (ty env t)
    | A.Fetch(v)            -> variable env target globals v
    | A.BinOp(l,op,r)       -> primOp env target globals op [l;r]
    | A.UnOp(op,e)          -> primOp env target globals op [e]
    | A.PrimOp(op,xs)       -> primOp env target globals op (List.map snd xs) (* ignore hints*)
@    

% ------------------------------------------------------------------ 
\subsubsection{Flow Annotations}
% ------------------------------------------------------------------     

Flow annotations are translated to continuation bundles of type
[[Fgraph.cont]].  The [[flows]] function takes a list of flow
annotations and adds them to a provided [[Fgraph.cuts]] value.

<<module Make>>=
let flows ast =
    let rec loop c = function 
        | (A.FlowAt (x,_)):: xx -> loop c (x::xx)
        | (A.CutsTo n)    :: xx -> loop {c with AG.cuts    = n@c.AG.cuts } xx
        | (A.UnwindsTo n) :: xx -> loop {c with AG.unwinds = n@c.AG.unwinds} xx 
        | (A.ReturnsTo n) :: xx -> loop {c with AG.returns = n@c.AG.unwinds} xx 
        | (A.Aborts)      :: xx -> loop {c with AG.aborts  = true } xx
        | []                    -> c     
    in
    let empty = { AG.cuts    = []
                ; AG.unwinds = []
                ; AG.returns = []
                ; AG.aborts  = false
                }
    in
        loop empty ast 
@

An assignment is an effect that is captured by an {\rtl}.  The lvalue
of an assignment must be either a memory location, or a register.  For
global registers, [[globals]] provides the desired effect when
supplying the expression representing the value to be stored.  A Local
register is represented by an [[Rtl.var]] locations which a value can
be stored in.

The last two arguments to the [[assign]] function, [[lhs]] and [[e]],
denote the lvalue of the the assignment, and the expression [[e]]
computing the value to be stores.  The expression is already an
{\rtl}.

\emph{(There seems to be some duplication between [[assign]] and
[[variable]], but I haven't checked carefully. ---NR}

<<module Make>>=
let rec assign env target globals lhs (e: Rtl.exp) = match lhs with
    | A.LValueAt(x,_)  -> assign env target globals x e
    | A.Var(hint,x)    ->
        let (_,(denot,t)) = F.findv x env in
            ( match denot with
            | F.Register(r) ->
                let width = bits t in
                    ( match F.is_localv x env with
                    | false -> 
                        let (write,read) = ( try StrMap.find x globals with
                                           | Not_found -> assert false
                                           ) 
                        in write e
                    | true  ->
                        let loc = Rtl.var x r.F.index width
                        in  Rtl.store loc e width
                    )
            | _ -> assert false (* impossible *)
            )
    | A.Mem(t,addr,a)    -> 
        let width = ty env t in
        let loc   = Rtl.cell
              default_assertion
              default_memory
              target#byteorder
              width
              (expr env target globals addr)
        in
            Rtl.store loc e width
@


% ------------------------------------------------------------------ 
\subsubsection{Procedure Body} 
% ------------------------------------------------------------------ 

A procedure's body includes statements, declarations, and stack data. 
A statement is part of a [[body]]; the [[body]] function receives
arguments that we need for all statements:  [[env]] is the clean
environment, which doesn't change.  [[s]] is the statement being
translated.  We return a new flow-graph node. 

<<module Make>>=
let rec body env target globals props graph after bb =
    let decorate n       = G.bind props n           in
    let rec stmt s after = match s with
        | A.StmtAt(x,_)     -> stmt x after
        <<cases for translating statements>>        in
    let rec body b after = match b with
        | A.BodyAt(x, _)    -> body x after
        | A.DeclBody(d)     -> ldecl d after
        | A.StmtBody(s)     -> stmt s after
        | A.DataBody(dd)    -> after (* can be ignored *)
    in
        List.fold_right body bb after
@

<<cases for translating statements>>=
| A.AssignStmt(lhs,rhs) ->
    let effect lhs (guard, rhs) =
      let eff = assign env target globals lhs (expr env target globals rhs)  in
      match guard with
      | Some g -> Rtl.guard (expr env target globals g) eff
      | None -> eff                                           in
    let effects = List.map2 effect lhs rhs
    in 
        decorate (GM.assign (Rtl.par effects) after) 
@

The first branch of a [[branch]] node must be a label. So we have to
invent one.
        
<<cases for translating statements>>=
| A.IfStmt ( e, ss1, ss2) ->
    let node1  = List.fold_right stmt ss1 after  in
    let node2  = List.fold_right stmt ss2 after  in
    let label1 = GM.label (Idgen.id ()) node1    in 
    let e      = expr env target globals e       in
    let unode  = GM.branch e (decorate label1) node2 in
        decorate unode
@

<<cases for translating statements>>=
| A.ReturnStmt(cc, alt, args) ->
    let const n      = A.Int (Bits.of_int n Bits.maxwidth, None)             in
    let (cont,count) = Aux.Option.get (const 0, const 0) alt                 in
    let cc           = find_cc (Aux.Option.get default_convention cc) target in
    let actuals      = List.map (actual env target globals) args             in
    let cout a       = decorate (GM.copyo actuals AG.ProcResults cc a)     in
    let ret  a       = decorate (GM.return graph
                                 (un_const cont) (un_const count))           in
        (cout @<< ret) after

<<cases for translating statements>>=
| A.LabelStmt(n)       -> decorate (GM.label n after)
@


A call [[x,y = f(v,w)]] is translated into the following sequence of
nodes in the flow graph:

\begin{enumerate}
\item A [[CopyOut]] node for the parameters [[v]] and [[w]],
\item a [[Call]] node for [[f]],
\item a [[CopyIn]] node for the variables [[x]] and [[y]],
\item the passed in [[after]] node.
\end{enumerate}

The left hand side of a call is a list of variables that is translated
to a [[Fgraph.formal list]] value that is passed to the [[CopyIn]]
node. 

<<cases for translating statements>>=
| A.CallStmt(lhs, cc, e, args, ts, fs) ->
    let rec lvalue = function
         | A.LValueAt(x,_) -> lvalue x
         | A.Var(hint,n)   -> formal env n
         | A.Mem _         -> assert false            in
    let cc         = find_cc (Aux.Option.get default_convention cc) target in
    let cout after = if args <> []
                     then decorate (GM.copyo
                                   (List.map (actual env target globals) args)
                                    AG.ProcParameters cc after)
                     else after                                   in
    let call after = decorate (GM.call 
                        (expr env target globals e) 
                        after
                        (flows fs)) in
    let cin  after = if lhs <> []
                     then decorate (GM.copyi (List.map lvalue lhs)
                                       AG.ProcResults cc after)
                     else after                                   in
        (cout @<< call @<< cin) after
@

A continuation is represented by a labeled node.  This node is a
[[CopyIn]] node in case the continuation receives arguments.
        
<<cases for translating statements>>=
| A.ContStmt(n,ns) -> 
    let cc        = find_cc default_convention target in
    let args      = List.map (fun (_,n) -> formal env n) ns          in
    let cin after = if ns <> []
                    then decorate (GM.copyi args AG.ContParameters cc after)
                    else after                        in
    let lbl after = decorate (GM.label n after)       in
        (lbl @<< cin) after

<<cases for translating statements>>=
| A.EmptyStmt     -> after
| A.CommentStmt _ -> after
@

A tail call is a [[jump]] statement. The parameters, if any, are
handled by a [[CopyOut]] node in the flow graph representation.  The
actual sequence is the [[CopyOut]] node, followed by the [[Jump]]
node. The [[after]] node is not used in since a jump always ends a
sequence of statements.

<<cases for translating statements>>=
| A.JumpStmt(cc,e,args,ts) ->
    let cc         = find_cc (Aux.Option.get default_convention cc) target in
    let args       = List.map (actual env target globals) args             in
    let cout after = if args <> [] then 
                        decorate (GM.copyo    args AG.ProcParameters cc after)
                     else after                               in
    let jump after = decorate (GM.jump graph (expr env target globals e) ts) in
        (cout @<< jump) after 
@

The translation of a [[goto]] statement is straight forward; the
[[after]] node is unused because it can't be reached.

<<cases for translating statements>>=
| A.GotoStmt(e,ts) -> decorate (GM.goto graph (expr env target globals e) ts) 
@

A [[span]]'s attributes are a compile-time constant value and a
link-time constant.

\emph{Something is very wrong here, but NR is not sure what\ldots}
<<cases for translating statements>>=
| A.SpanStmt(e1,e2,ss) ->
    let key   = Consteval.compile (ignore e1; assert false) in
    let value = Consteval.link    (ignore e2; assert false) in
        body env target globals 
            (G.Props.add_span key value props) graph after ss
@


<<cases for translating statements>>=
| A.CutStmt(e, args, fs) -> 
    let cc         = find_cc default_convention target in
    let cout after = if args <> []
                     then decorate 
                        ( GM.copyo
                          (List.map (actual env target globals) args)
                          AG.ContParameters 
                          cc 
                          after
                        )
                     else after                                   in
    let cut  after = decorate 
                        ( GM.cutto graph 
                          (expr env target globals e) 
                          (flows fs)
                        )                                         in
        (cout @<< cut) after        
@

The following statements are just skipped for the moment.    

<<cases for translating statements>>=
| A.PrimStmt(lhs, cc, n, args, fs)     -> assert false
| A.SwitchStmt (r,e,arms)              -> assert false
@

<<unused>>=
let range env ir = function
    | A.Point(e)        -> true
    | A.Range(e1,e2)    -> true
@
<<unused>>=
and arm env ir = function
    | A.ArmAt(x,_)          -> arm env ir x
    | A.Case(ranges, stmts) -> true
@

% ------------------------------------------------------------------ 
\subsubsection{Procedures}
% ------------------------------------------------------------------ 

Each procedure is translated into a control flow graph that shares no
nodes with any other control flow graph.  The generation of the label
for this procedure is handled at the assembly level and not on the
flow graph level.  Thus, the first node of the flow graph is the entry
node.

A procedure really starts with a [[CopyIn]] node that assigns the
incoming parameters to the named registers and ends with an [[Exit]]
node.  The types of the formal parameters are bound in the local
environment belonging to a procedure.  The local environment [[env]]
for a procedure is found in its entry in the fat environment.

<<module Make>>=
and proc env (target: Target.t) globals props (asm: Asm.asm) (cc,n,fs,bb) =  
    let decorate n = G.bind props n                                    in
    let p          = match F.findv n env with
                     | _,(F.Label(F.Proc p),_) -> p 
                     | _  -> assert false                              in
    let env        = F.push env p.F.scope                              in
    let ginit      = (n, p)                                            in
    let graph      = GM.create ginit  (* fresh graph for this proc *)  in
    let cc         = find_cc (Aux.Option.get default_convention cc) target in
    let entry a    = decorate (GM.entry a)                             in
    let copy  a    = decorate (GM.copyi                                    
                        (List.map (fun (_,_,_,n) -> formal env n) fs)
                        AG.ProcParameters cc a)                        in
    let bdy   a    = body env target globals props graph a  bb         in
    let exit       = decorate (GM.exit graph)                          in
    let node       = (entry @<< copy @<< bdy) exit                       in
         asm ++ Asm.instr (GM.cfg_of node)
@

Local declarations are ignored for the moment. 
 
<<module Make>>=
and ldecl env after = after
@
   
% ------------------------------------------------------------------ 
\subsubsection{Global Memory declarations}
% ------------------------------------------------------------------ 

<<module Make>>=
let initialized_data asm expr = assert false

let rec init env target asm = function
    | A.InitAt(x,_)   -> init env target asm x
    | A.InitExprs(es) -> foldl initialized_data asm es
    | A.InitStr(s)    -> assert false
    | A.InitUStr(s)   -> assert false
@

In order to reserve memory for data we have to know how many objects
an sequence of initializing expressions defined. This number is
returned by [[init_size]].

<<module Make>>=
let rec init_size = function
    | None   -> 1
    | Some i -> let rec loop = function 
                    | A.InitAt(x,_)   -> loop x
                    | A.InitExprs(es) -> List.length es
                    | A.InitStr(s)    -> assert false
                    | A.InitUStr(s)   -> assert false
                in 
                    loop i 
@

Data can be declared initialized or un-initialized. The amount of
memory used by a declaration is the size of the base-type times the
number of values of this type. 

<<module Make>>=
let memdecl env target asm t size ini = 
    let sizeof = ty env t / target#memsize (* no. of memsized objs *) in
    let n      = ( match size with
                 | A.DynSize    -> init_size ini
                 | A.NoSize     -> 1
                 | A.FixSize(e) -> un_const e (* bogus *)
                 ) in
        ( match ini with
        | None    -> asm ++ Asm.zeroes (n * sizeof)
        | Some ii -> init env target asm ii
        )
@

Data can be declared globally inside a section or a section-level
[[span]] and locally, inside a procedure as [[stackdata]].  The former
is directly translated into assembly action that reserve memory inside
a section, the latter becomes just an amount of memory that is
allocated inside a procedure's activation record.  Since the amount of
stack allocated data and the offsets associated with labels inside of
it are already entered into the fat environment (by
[[Elab.Check.stackdatum]]), stack data declaration can be ignored. 
Global data declarations, on the other hand, must be translated to
assembly actions.
 
<<module Make>>=
let rec datum env target asm = function
    | A.DatumAt(x,_)        -> datum env target asm x
    | A.Label(n)            -> asm ++ Asm.define_local (Asm.mksym n)
    | A.Align(a)            -> asm ++ Asm.align a 
    | A.MemDecl(t,m,init)   -> memdecl env target asm t m init
@
    
% ------------------------------------------------------------------ 
\subsubsection{Toplevel}
% ------------------------------------------------------------------ 

All global declarations have been processed at this stage and thus can
be ignored.  The only exception are (global) register declarations. 
Global registers can name a hardware register they are placed in.  We
need so way to record such an assignment.  All other locations for
global registers are determined by an automaton, see module
\module{callconv}. 

A [[span]] on the section level must be pushed to the statement level: 
when we come across a [[span]] we modify the properties [[props]]
accordingly.  The next time we come across a procedure, the properties
including the span will be used.

<<module Make>>=
let rec sspan env target globals props asm (e1,e2,ss) =    
    let key   = Consteval.compile (e1; assert false) in
    let value = Consteval.link    (e2; assert false) in
    let props = G.Props.add_span key value props 
    in
        foldl (section env target globals props) asm ss 

<<module Make>>=
and section env target globals props (asm: Asm.asm) = function
    | A.SectionAt(x,_)     -> section env target globals props asm x
    | A.Decl(d)            -> asm
    | A.Datum( d)          -> datum env target asm d
    | A.Procedure(p)       -> proc env target globals props asm p
    | A.SSpan ss           -> sspan env target globals props asm ss
@            

What to do with top-level procedures? They should go into some section
because otherwise they will end up in whatever section is currently
active which just seems wrong.

<<module Make>>=
let rec toplevel env target globals asm = function
    | A.ToplevelAt(x, _)  -> toplevel env target globals asm x
    | A.Section(name, ss) -> 
        let asm = asm ++ Asm.section name in  
            foldl (section env target globals G.Props.empty) asm ss
    | A.TopDecl(d)        -> asm (* nothing to do here *)
    | A.TopProcedure(p)   -> let asm = asm ++ Asm.section toplevel_section  
                             in proc env target globals G.Props.empty asm p
@


% ------------------------------------------------------------------ 
\subsubsection{Program}
% ------------------------------------------------------------------ 

Imports and exports of assembly symbols are announced once at the top
of the assembly program.  The sets of imported and exported symbols
are registered in the fat environment.  For details, see modules
\module{mangle}, and \module{elab}. 

<<module Make>>=
let exports env asm = 
    Fenv.StrSet.fold (fun s asm -> asm ++ Asm.export (Asm.mksym s)) 
    (F.exported env) asm

let imports env asm =
    Fenv.StrSet.fold (fun s asm -> asm ++ Asm.import (Asm.mksym s)) 
    (F.imported env) asm
@



The global registers of a {\PAL} program are assigned to registers and
memory locations.  The assignment is performed by an automaton
provided by the [[target]] value.  The sequence of all global register
declarations can be obtained from the fat environment.  The result of
the assignment is a map, that associates the name of a global register
with an [[Automaton.location]].  Such a value consists of a function
to write a value to a register, and an expression to read a register's
value.

Hardware registers are known as [[Rtl.locs]], which differ from
an [[Automaton.location]]. The function [[reg2loc]] constructs an
[[Automaton.location]] for a hardware register.

<<module Make>>=
let reg2loc loc =
  let width = Rtlutil.locwidth loc in
    ( (fun e -> Rtl.store loc e width)  (* store e to loc         *)
    , Rtl.fetch loc width               (* value fetched from loc *)
    )

let globals (target:Target.t) decls =
    let unknown reg  = raise (E.ErrorExn ("unknown h/w reg: "^reg)) in
    let rec loop map dfa = function
        | []                          -> map
        | (name, F.RNone  , ty) :: rr -> (* no hint, no h/w register *)
            let (loc,dfa) = Automaton.Run.next dfa (ty,None) in
            let map       = StrMap.add name loc map in
                loop map dfa rr
            
        | (name, F.RHint h, ty) :: rr -> (* hint, no h/w register *)
            let (loc,dfa) = Automaton.Run.next dfa (ty, Some h) in
            let map       = StrMap.add name loc map in
                loop map dfa rr
        
        | (name, F.RReg  h, ty) :: rr -> (* hardware register! *)
            let reg = try Target.StrMap.find h target#registers
                      with Not_found -> unknown name in
            let map = StrMap.add name (reg2loc reg) map in
                loop map dfa rr in
    let dfa = target#globals in
    let map = StrMap.empty in
        loop map dfa decls
@

The assembler maintains a current section. To guarantee that
everything goes into a meaningful section, the first action is to
start the [[text]] section.



<<module Make>>=
let program env target globals asm tt = 
    let asm = asm ++ Asm.section "text"           in
    let asm = exports env asm                     in
    let asm = imports env asm                     in
        foldl (toplevel env target globals) asm tt
@

The initializing argument to [[Asm.init]] is probably target dependent
and should be provided by [[target]]. 

<<module Make>>=
type program = Automaton.location StrMap.t * Asm.asm

let translate env target prog =
    let regs   = globals target (F.regdecls env) in
    let asm    = Asm.init () in
        ( regs                         (* global register map *)
        , program env target regs asm prog  (* asm                 *)
        )
@    

% ------------------------------------------------------------------ 
\subsection{{\rtl} Auxiliaries}
% ------------------------------------------------------------------ 

Module [[R]] contains auxiliary functions for {\rtl}s.  We like to
collect some from the actual usage patterns and then put them in their
own module. 

<<module R>>=
let truth      = Rtl.bool true
let width_of r = 77 (* all exprs 77 bits wide - bogus *)
let assign l r = Rtl.store l r (width_of r)
@
 
% ------------------------------------------------------------------ 
\subsection{Expression Evaluation}
% ------------------------------------------------------------------ 

The translation of {\PAL} expressions to {\rtl} expressions requires
the types of {\PAL} expression and sometimes their values as well. 
There is code for both in the \module{elab} module.  Unfortunately
they are implemented against the [[Fenv.Dirty]] environment. 
Factoring this out is no small job.  For the moment we provide some
new code here.

<<module Expr>>=
let rec evalTy env = function
    | A.TyAt(x,r)    -> evalTy env x
    | A.BitsTy(size) -> Types.Bits size
    | A.AliasTy(n)   -> snd (F.findt n env)

let rec tyFetch env (target: Target.t) = function
    | A.LValueAt(x,r) -> tyFetch env target x
    | A.Var(hint,id)  -> (match F.findv id env with (attr,(_,t)) -> t)
    | A.Mem (t,e,a)   -> 
        let te    = tyExpr env target e in       (* unused *)
        let t'    = evalTy env t        in       
        let align = Aux.Option.get 1 a  in
            t'
@       

For now we are using the types of the primitive constant operators. 
All primitive runtime operators will go into their own module
[[Primitives]].  So we have to fix the [[lookup]] later.

<<module Expr>>=
and tyPrimOp env target op args =
    let at = List.map (tyExpr env target) args          in
    let ot = snd (Value.Ops.lookup op Value.ops) in
        Types.appl ot at

and op env target o args =
    let at = List.map (tyExpr env target) args          in
    let ot = snd (Value.Ops.lookup o Value.ops) in
        o,Types.widthlist ot at

<<module Expr>>=
and tyExpr env (target: Target.t) = function
    | A.ExprAt(x,r)            -> tyExpr env target x
    | A.Int   (str, Some t)    -> evalTy env t
    | A.Int   (str, None)      -> T.bits target#wordsize
    | A.Float (str, Some t)    -> evalTy env t
    | A.Float (str, None)      -> T.bits target#wordsize
    | A.Char  (str, Some t)    -> evalTy env t
    | A.Char  (str, None)      -> T.bits target#wordsize
    | A.Fetch (v)              -> tyFetch env target v
    | A.BinOp (l,op,r)         -> tyPrimOp env target op [l;r]
    | A.UnOp  (op,expr)        -> tyPrimOp env target op [expr]
    | A.PrimOp(op,args)        -> tyPrimOp env target op (List.map snd args)
@


