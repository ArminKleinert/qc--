% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% ------------------------------------------------------------------ 
\section{Translation into Abstract {\PAL}}
% ------------------------------------------------------------------ 

After a source file has been successfully parsed and its static
semantics have been found correct it is translated into abstract 
{\PAL}. Abstract {\PAL} is defined by an {\asdl} description
[[ir.asdl]] in source file \module{ir}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

This module is called from the [[Main.main]] function with the name of
the source file; function [[ast2ir]] takes care of everything and
reports success or failure with an [[Error.error]] value.

<<ast2ir.mli>>=
val ast2ir: string -> unit Error.error
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

This module need a whole bunch of other modules.

<<ast2ir.ml>>=
module A  = Ast
module T  = Types
module E  = Error
module F  = Fenv.Clean


module R = struct
    <<module R>>
end

module Expr = struct
    <<module Expr>>
end

<<auxiliaries>>

module Make (G : Agraph.S) = struct
    module GM = G.Make
    <<module Make>> 
end

<<toplevel>>
@ 

% ------------------------------------------------------------------ 
\subsubsection{Auxiliaries}
% ------------------------------------------------------------------ 

Some auxiliary bindings.

<<auxiliaries>>=
let default_convention  = "C--"  (* gospel truth *)
let default_assertion   = -1     (* unused *)
let default_memory      = 'm'    (* Rtl.space *)
@

<<>>=
let dummy_expression    = Rtl.Const(Rtl.Bits(Bits.zero 32, 32))
@

[[bits]] extracts a [[width]] from a type, i.e.~the number of bits.
This must be never applied to a [[bool]] type.

<<>>=
let bits = function
    | T.Bits n -> n
    | _        -> assert false
@

[[byteorder]] returns the byteorder as recorded in the environment. 

<<>>=
let byteorder env = match F.findEndianness env with
    | F.Big     -> Rtl.BigEndian
    | F.Little  -> Rtl.LittleEndian
@

[[un_const]] should take a compile-time constant expression and
produce a small itneger.  [[un_const]] is surely the wrong name.

<<>>=
let un_const e = 333 (* bogus *)
@ 

% ------------------------------------------------------------------ 
\subsubsection{Module \texttt{Make}}
% ------------------------------------------------------------------ 

The implementation [[Make]] is a functor that receives an abstract
view ([[Agraph]] -- \module{agraph}) of the flow graph as an argument.

<<module Make>>=
let rec ty env = function
    | A.TyAt(x,_)       -> ty env x
    | A.BitsTy(n)       -> n
    | A.AliasTy(name)   -> ( match F.findt name env with
                           | attr, T.Bits n -> n
                           | _              -> assert false
                           )

let tyOf n env = match F.findv n env with attr, (denot,ty) -> bits ty
                             
<<>>=
let actuals env ir xs = true
let actual env (hint, e) = (dummy_expression, 99, hint)
@
 
An assignment is an effect what captured by an {\rtl}.  The lvalue of
an assignment becomes a {\rtl} [[location]].  We currently ignore
alignments and hints.


<<>>=
let rec lvalue env = function
    | A.LValueAt(x,_)   -> lvalue env x
    | A.Var(hint,x)     -> let (attr,(_,t)) = F.findv x env in Rtl.Var(x,bits t)
    | A.Mem(t,e,a)      -> let width = ty env t      in
                             Rtl.Cell
                             ( default_memory
                             , byteorder env 
                             , width
                             , expr env e
                             , default_assertion
                             )
<<>>=
and primOp env op args =
    let o = Expr.op env op args 
    in
        Rtl.App(o, List.map (expr env) args)

<<>>=
and expr env = function 
    | A.ExprAt(x,_)         -> expr env x
    | A.Int( i, None)       -> Rtl.Const(Rtl.Bits(i,bits T.word))
    | A.Int( i, Some t)     -> Rtl.Const(Rtl.Bits(i,ty env t))
    | A.Float( f, None)     -> Rtl.Const(Rtl.Bits(f,bits T.word))
    | A.Float( f, Some t)   -> Rtl.Const(Rtl.Bits(f,ty env t))
    | A.Char( c, None)      -> Rtl.Const(Rtl.Bits(c,bits T.word))
    | A.Char( c, Some t)    -> Rtl.Const(Rtl.Bits(c, ty env t))
    | A.Fetch(v)            -> let width = bits (Expr.tyFetch env v) in 
                               Rtl.Fetch(lvalue env v,width)
    | A.BinOp(l,op,r)       -> primOp env op [l;r]
    | A.UnOp(op,e)          -> primOp env op [e]
    | A.PrimOp(op,xs)       -> primOp env op (List.map snd xs) (* ignore hints*)
    


<<>>=
let memsize env ir = function
    | A.NoSize        -> true
    | A.DynSize       -> true
    | A.FixSize(e)    -> true

<<>>=
let rec init env ir = function
    | A.InitAt(x,_)   -> init env ir x
    | A.InitExprs(es) -> true
    | A.InitStr(s)    -> true
    | A.InitUStr(s)   -> true

<<>>=
let rec datum env ir = function
    | A.DatumAt(x,_)        -> datum env ir x
    | A.Label(n)            -> true
    | A.Align(a)            -> true
    | A.MemDecl(t,m,Some i) -> true
    | A.MemDecl(t,m,None)   -> true

<<>>=
let formal (h, v, t, n) = true

<<>>=
let formals  env ir xs               = true
let register env ir (v , t, n, reg)  = true
let altcont  env ir (e1,e2)          = true   
let targets env ir                   = true 
    
<<>>=
let rec flow env ir = function
    | A.FlowAt(x,_)     -> flow env ir x
    | A.CutsTo(ns)      -> true
    | A.UnwindsTo(ns)   -> true
    | A.ReturnsTo(ns)   -> true
    | A.Aborts          -> true

<<>>=
let conv env ir        = true
let export env ir t ns = true

<<>>=
let range env ir = function
    | A.Point(e)        -> true
    | A.Range(e1,e2)    -> true

@ 

<<>>=
let rec flows cont = function 
| (A.FlowAt (x,_)):: xx -> flows cont (x::xx)
| (A.CutsTo n)    :: xx -> flows {cont with GM.cuts    = n @ cont.GM.cuts } xx
| (A.UnwindsTo n) :: xx -> flows {cont with GM.unwinds = n @ cont.GM.unwinds} xx 
| (A.ReturnsTo n) :: xx -> flows {cont with GM.returns = n @ cont.GM.unwinds} xx 
| (A.Aborts)      :: xx -> flows {cont with GM.aborts  = true } xx
| []                    -> cont     
@

% ------------------------------------------------------------------ 
\paragraph{Statements} 
% ------------------------------------------------------------------ 

A statement is part of a [[body]]; the [[body]] function receives
arguments that we need for all statements:  [[env]] is the clean
environment, which doesn't change.  [[s]] is the statement being
translated.  We return a new flow-graph node.  [[after]] is a
representation of the entire flow graph, with a pointer to the node
that follows this statement. 

<<>>=
let body env props graph s =
    let rec stmt s after = match s with
        | A.StmtAt(x,_) -> stmt x after
        <<cases for translating statements>>
        | _ -> assert false (* remove me in due time *)
    in 
        stmt s (G.bind G.Props.empty (GM.exit graph))
@ 

<<cases for translating statements>>=
| A.AssignStmt(lhs,rhs) ->
    let effects = 
      List.map2 (fun lhs rhs -> R.assign (lvalue env lhs) (expr env rhs)) lhs rhs
    in props (GM.assign (R.par effects) after)

<<cases for translating statements>>=
| A.IfStmt ( e, ss1, ss2) ->
    let n1 = List.fold_right stmt ss1 after in
    let n2 = List.fold_right stmt ss2 after in
    props (GM.branch (expr env e) n1 n2)
@

<<cases for translating statements>>=
| A.ReturnStmt(cc, alt, args) ->
    let const n = A.Int (Bits.of_int n Bits.maxwidth, None)   in
    let (cont, count) = Aux.Option.get (const 0, const 0) alt in
    let cc = Aux.Option.get default_convention cc             in
        props (GM.copy_out (List.map (actual env) args) Fgraph.ProcResults cc (
        props (GM.return graph (un_const cont) (un_const count))))

<<cases for translating statements>>=
| A.LabelStmt(n)                       -> props (GM.label n after)
    
@

A call [[x,y = f()]] is translated into a [[Call]]-node, followed by a
[[CopyIn]] node for the locations [[x]] and [[y]].  Since we build the
graph backwards the [[CopyIn]] node comes first.  The lvalue of a call
is guaranteed to be a variable.  It must be translated into a
[[Rtl.formal]] value which is done by the local [[lvalue]] function. 


<<cases for translating statements>>=
| A.CallStmt(lhs, cc, e, args, ts, fs) ->
    let rec lvalue = function
        | A.LValueAt(x,_) -> lvalue x
        | A.Var(hint,n)   -> (n,tyOf n env ,hint)
        | A.Mem _         -> assert false
    in     
    let cc   = Aux.Option.get default_convention cc in
    let copy = GM.copy_in (List.map lvalue lhs) Fgraph.ProcResults cc after in 
    let cont = GM.empty_cont (props copy)           in
    let call = GM.call (expr env e) cont            in
        props call
    
<<more cases for translating statements>>=
| A.ContStmt(n,ns)                     -> true
| A.SpanStmt(e1,e2,ss)                 -> true
| A.PrimStmt(lhs, cc, n, args, fs)     -> true
| A.GotoStmt(e,ts)                     -> true
| A.CutStmt(e, args, fs)               -> true
| A.JumpStmt(cc,e,args,ts)             -> true
| A.EmptyStmt                          -> true
| A.SwitchStmt (r,e,arms)              -> true
        
<<>>=
let rec body' env ir = function
    | A.BodyAt(x, _)    -> body env ir x
    | A.DeclBody(d)     -> true
    | A.StmtBody(s)     -> true
    | A.DataBody(dd)    -> true
    
<<>>=
and proc env ir (cc,n,fs,ss) =  true

<<>>=
and decl env ir = function
    | A.DeclAt(x,_)    -> decl env ir x
    | A.Import( t, ns) -> true
    | A.Export( t, ns) -> true
    | A.Const (t,n,e)  -> true
    | A.Registers( rs) -> true
    | A.Typedef (t,nn) -> true
    | A.Target (arch)  -> true
    | A.Pragma         -> true

<<>>=
and section env ir = function
    | A.SectionAt(x,_)     -> section env ir x
    | A.Decl(d)            -> true
    | A.Datum( d)          -> true
    | A.Procedure(p)       -> true
    | A.SSpan( e1, e2, ss) -> true
            
<<>>=
and arm env ir = function
    | A.ArmAt(x,_)          -> arm env ir x
    | A.Case(ranges, stmts) -> true
    
<<>>=
let rec toplevel env ir = function
    | A.ToplevelAt(x, _)  -> toplevel env ir x
    | A.Section(name, ss) -> true
    | A.TopDecl(d)        -> true
    | A.TopProcedure(p)   -> true

<<>>=
let program env ir ds = true
@

% ------------------------------------------------------------------ 
\subsubsection{{\rtl} Auxiliaries}
% ------------------------------------------------------------------ 

Module [[R]] contains auxiliary functions for {\rtl}s.  We like to
collect some from the actual usage patterns and then put them in their
own module. 

<<module R>>=
  let truth      = Rtl.Const(Rtl.Bool(true))
  let width_of r = 77 (* all exprs 77 bits wide - bogus *)
  let assign l r = Rtl.Rtl [(truth, Rtl.Store(l, r, width_of r))]
  let skip       = Rtl.Rtl []
  let par l      = List.fold_right 
                   (fun (Rtl.Rtl l1) (Rtl.Rtl l2) -> Rtl.Rtl (l1 @ l2)) l skip
@
 
% ------------------------------------------------------------------ 
\subsubsection{Expression Evaluation}
% ------------------------------------------------------------------ 

The translation of {\PAL} expressions to {\rtl} expressions requires
the types of {\PAL} expression and sometimes their values as well. 
There is code for both in the \module{elab} module.  Unfortunately
they are implemented against the [[Fenv.Dirty]] environment. 
Factoring this out is no small job.  For the moment we provide some
new code here.

<<module Expr>>=
let rec evalTy env = function
    | A.TyAt(x,r)    -> evalTy env x
    | A.BitsTy(size) -> Types.Bits size
    | A.AliasTy(n)   -> snd (F.findt n env)

let rec tyFetch env = function
    | A.LValueAt(x,r) -> tyFetch env x
    | A.Var(hint,id)  -> (match F.findv id env with (attr,(_,t)) -> t)
    | A.Mem (t,e,a)   -> 
        let te    = tyExpr env e       in       (* unused *)
        let t'    = evalTy env t       in       
        let align = Aux.Option.get 1 a in
            t'
@       

For now we are using the types of the primitive constant operators. 
All primitive runtime operators will go into their own module
[[Primitives]].  So we have to fix the [[lookup]] later.

<<>>=
and tyPrimOp env op args =
    let at = List.map (tyExpr env) args          in
    let ot = snd (Value.Ops.lookup op Value.ops) in
        Types.appl ot at

and op env o args =
    let at = List.map (tyExpr env) args          in
    let ot = snd (Value.Ops.lookup o Value.ops) in
        o,Types.widthlist ot at

<<>>=
and tyExpr env = function
    | A.ExprAt(x,r)            -> tyExpr env x
    | A.Int   (str, Some t)    -> evalTy env t
    | A.Int   (str, None)      -> T.word
    | A.Float (str, Some t)    -> evalTy env t
    | A.Float (str, None)      -> T.word
    | A.Char  (str, Some t)    -> evalTy env t
    | A.Char  (str, None)      -> T.word
    | A.Fetch (v)              -> tyFetch env v
    | A.BinOp (l,op,r)         -> tyPrimOp env op [l;r]
    | A.UnOp  (op,expr)        -> tyPrimOp env op [expr]
    | A.PrimOp(op,args)        -> tyPrimOp env op (List.map snd args)
@


% ------------------------------------------------------------------ 
\subsubsection{Exported top-level functions}
% ------------------------------------------------------------------ 

We now leave the implementation of [[Make]] and return to the
top-level of our module.  It contains functions called from module
\module{main} in response to command line arguments to the compiler.

<<toplevel>>=
let check map program =
    let env        = Fenv.Dirty.empty map                   in
    let env        = Elab.Env.global env program            in
    let env        = Elab.Check.global env program          in
        if   Fenv.Dirty.errorFlag env
        then E.error "compilation aborted due to errors in static semantics"
        else Fenv.clean env
@

The function [[ast2ir]] scans, parses, and checks a file before the
translation in this module can start.

<<ast2ir.ml>>=
let ast2ir file =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; let ast        = Parse.program scanner lexbuf in
              let env        = check map ast                in
                  E.Ok()
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.Error
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.Error
              )
            | e ->
              ( finally()
              ; raise e
              )
@
