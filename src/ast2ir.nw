% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et sts=4
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

%%Grades: C Central Immediate

% inc: \usepackage{alltt}


WORK STILL TO BE DONE:
\begin{itemize}
\item
RECORD SET OF THINGS DEFINED AT THE ``UNWOUND TO'' ENTRY POINT OF A CONTINUATION.
THERE IS A PROBLEM HERE, BECAUSE WE HAVE NO WAY TO RECORD
A DEFINITION OF A VARIABLE, BUT THIS IS WHAT THE UNWIND OPERATION
DOES.
PERHAPS THE ASSERTION NODE WILL DO THE TRICK.
\end{itemize}



@
% ------------------------------------------------------------------ 
\section{Translation to Intermediate Representation}
% ------------------------------------------------------------------ 

This module does \emph{lots} of translation: 
each procedure to a [[Proc.t]], and everything else down to the
assembly level.
The [[Proc.t]] is embedded into the assembly program as a single
instruction. 

We put the [[Target.t]] parameter first always because we first put
the less-specific information before the more-specific information.

The functor parameters and the parameter of type [[string->Call.t]]
will all go away once the new flow graph ([[Cfg]]) takes over the compiler.
<<ast2ir.mli>>=
type tgt  = ((Rtl.exp -> Automaton.t), Call.t) Target.t
type proc = (Automaton.t, Rtl.rtl Cfgx.M.cfg, Call.t, tgt) Proc.t
val translate :  tgt
                -> proc Fenv.Clean.env'
                -> optimizer: (proc -> unit)
                -> defineglobals: bool
                -> proc Nelab.compunit
                -> proc Asm.assembler
@

% ------------------------------------------------------------------ 
\section{Implementation: Translate to intermediate representation}
% ------------------------------------------------------------------ 

\subsection{Abbreviations, utilities, and type definitions}

We use these abbreviations.
<<ast2ir.ml>>=
module A  = Ast
module AT = Automaton
module C  = Call
module Dn = Rtl.Dn
module E  = Error
module F  = Fenv.Clean
module FE = Fenv
module G  = Cfgx.M  (* graph *)
module N  = Nelab
module R  = Rtl
module RP = Rtl.Private
module RT = Runtimedata
module RU = Rtlutil
module RS = Register.Set
module S  = Elabstmt
module T  = Target
module Up = Rtl.Up
module W  = Rtlutil.Width
@ 
Utility functions and so on.
<<ast2ir.ml>>=
<<utilities>>
@ 
Here are 
some of the usual suspects.
<<utilities>>=
let (<<) f g = fun x -> f (g x) (* function composition *)
let impossible = Impossible.impossible
let impossf x  = Printf.kprintf Impossible.impossible x
@ 
The [[**>]] function is an infix, right-associative function that
makes it easy to create sequences of flow-graph nodes.
(I'm always amazed at how useful it is to have an infix,
right-associative form of the identity function.)
<<utilities>>=
let ( **> ) f x = f ~succ:x
@
Some of these type definitions are called for in the interface; others
are internal.
The types in module [[K]] are used to translate continuations.
<<ast2ir.ml>>=
type tgt = ((Rtl.exp -> Automaton.t), C.t) Target.t
type proc = (Automaton.t, Rtl.rtl G.cfg, C.t, tgt) Proc.t
<<module [[K]], for continution info>>
<<types for nonvolatile registers>>
@ 
\subsection{Overall structure of the translation}

The translator has two major layers: the top-level layer, shown
here, and the single-procedure layer, shown in chunk
[[<<definition of [[proc]], which translates one procedure>>]].
Each layer comes with its own scope; we have top-level scope and
procedure scope. 
The denotation of an expression depends on what scope it's in, but we
prefer \emph{not} to pass a scope or environment everywhere.
Instead, we define a higher-order function [[exprfuns]], which gets
the scope information and returns three functions: [[expr]], 
[[typed_expr]], and [[lvalue]].
We use [[exprfuns]] to instantiate these three functions in two places:
once at top level and once inside each procedure.
The first instantiation is visible here; the second appears in 
[[<<definition of [[proc]], which translates one procedure>>]].
<<ast2ir.ml>>=
<<definition of type [[blocklists]]>>
let translate target env ~optimizer ~defineglobals =
  let pointersize = target.T.pointersize in
  let add = RU.add pointersize in
  let to_cc = Call.get_cc target in
  <<environment-independent support for formals, actuals, and results>> in
  <<definition of [[proc]], which translates one procedure>> in
  <<definition of [[globals]]>> in
  <<function [[datum]], for initialized and uninitialized data>> in
  <<function [[program]], which translates an entire program>> in
  program
@

@
\subsubsection {Translation of type and conversion from type to width}
\nwaddbox{tywidth  : 'a Types.t -> 'a}
\nwaddbox{astwidth : F.env -> A.ty -> int}
\deeperbox{2pt}
<<utilities>>=
let tywidth = function
  | Types.Bits n -> n
  | Types.Bool   -> impossible "width of type bool"
@ 
Help for fetching and storing automata locations.
<<utilities>>=
let atfetch (loc, w)     = loc.AT.fetch w
let atstore (loc, w) exp = loc.AT.store exp w
@
% ------------------------------------------------------------------
\subsection{The translation of actual parameters, formal parameters, and results}
% ------------------------------------------------------------------ 

For actuals, formals, or results, we need a sequence of hint/width pairs
to feed to the calling convention.
For a formal or result, we need the corresponding location, and for each
actual, the corresponding value.
We do the dirty work with a higher-order function.
Argument [[hint_parm]] splits the abstract syntax into a hint and
a ``parameter''.
Argument [[cvt]] takes a ``parameter'' and produces a converted
parameter (location or expression), plus the width of the parameter.
The later parameter [[conv]] is a calling convention, which we apply
here for convenience.
THIS OLD FUNCTION MAY BE SLATED FOR REPLACEMENT!!!
<<environment-independent support for formals, actuals, and results>>=
let convert_parms hint_parm cvt =
  let add x (hws, parms) =
    let hint, parm = hint_parm x in
    let parm, w = cvt parm in
    (hint, w) :: hws, parm :: parms in
  fun conv l ->
    let hws, parms = List.fold_right add l ([], []) in
    conv hws parms 
@ 
We instantiate this code four ways.
For an actual parameter, the [[cvt]] parameter is the function [[ew]],
which compiles an AST expression into an RTL expression plus a width.
For a formal parameter or result, we use [[lvalue_name_in_env]].
The environment must be a parameter, since we don't have it at the
time these functions are defined.
@
\subsection{The translation of continuations and flow annotations}

\label{ast2ir.sec:cont-trans}

We need three passes to translate continuations.
\begin{enumerate}
\item
The first pass finds each continuation and builds the first part of
its translation: representation, labels, and incoming-parameter
handling.
\item
The second pass, which is the main translation of a procedure, 
identifies the code point (flow-graph node) associated with each
continuation in the source code.
\item
The third pass checks how each continuation is used and adds
flow-graph code as needed to implement that continuation.
It also inserts any initializations that are needed.
\end{enumerate}
@


Here is the information we accumulate about each continuation.
There are potentially three entry points into a continuation: by cut,
by unwind, and by alternate return.
We eagerly assign a label to each potential entry point, even though
not every entry point is necessarily needed.
We provide mutable fields so that the second pass can track how a
continuation is actually used and therefore know which entry points
are needed.
If an entry point is needed, the third pass of translation ensures
that the
relevant label is associated with real flow-graph nodes that do
things.


When we encounter a continuation, we also have its formal parameters,
so we run the calling convention, again knowing that we may not need
the results.
We also compute the representation of the continuation in case it is
cut to or it escapes.
\nextchunklabel{ast2ir.K.t}%
<<module [[K]], for continution info>>=
module K = struct
  type label = string
  type 'i t =
    {         unwind_pc   : label       (* labels may or may not be used *)
    ;         cut_pc      : label
    ;         return_pc   : label
    ;         escapes     : bool        (* properties of how it is used *)
    ;         cut_to      : bool
    ;         returned_to : bool
    ;         unwound_to  : bool
    ;         cut_in      : (Block.t -> Rtl.rtl) C.answer    (* move vals at cut (uses rep) *)
    ;         return_in   : (Block.t -> Rtl.rtl) C.answer    (* move vals at also returns *)
    ;         rep         : Contn.t     (* representation as C-- value (incl block) *)
    ;         convention  : string
    ; mutable succ        : 'i G.node   (* filled in by 2nd pass time *)
    ; mutable spans       : Runtimedata.span list (* spans at the continuation *)
    }
  <<definition of [[K.mk]], which initializes continuation information>>
end
@
\subsubsection{First-pass translation of continuations}

Our state of knowledge when we first encounter a continuation.
<<definition of [[K.mk]], which initializes continuation information>>=
let mk name den rep g ~cut_in ~return_in  =
  { escapes     = den.FE.escapes
  ; cut_to      = den.FE.cut_to
  ; returned_to = den.FE.returned_to
  ; unwound_to  = den.FE.unwound_to
  ; unwind_pc   = Idgen.ContEntry.unwind name
  ; cut_pc      = Idgen.ContEntry.cut    name
  ; return_pc   = Idgen.ContEntry.return name
  ; rep         = rep
  ; convention  = den.FE.convention
  ; cut_in      = cut_in
  ; return_in   = return_in
  ; succ        = G.illegal g
  ; spans       = []
  }
@ 
It's a simple matter of finding the calling convention, running the
automata, and building the rep and the continuation.
<<function [[extend_cont]], for adding flow-graph info to continuations>>=
let extend_cont name den = 
  let cc        = to_cc den.FE.convention in
  let args      = den.FE.formals in
  let cut_in    = cformals cc.C.cut_parms.C.in' args in
  let return_in = cformals cc.C.results.C.in'   args in
  let rep       = Contn.with_overflow target cut_in.C.overflow in
  K.mk name den rep g ~cut_in ~return_in in
@
\subsubsection{Second pass: continuations and flow annotations}
The second pass fills in the mutable fields.
First, when we encounter the statement for the second time, we set its
successor.
We return an illegal node since nothing may fall through to a continuation.
<<supporting functions for translating statements>>=
let rec contStmt2 label succ =
  let k = continuation label in
  k.K.spans <- props;
  k.K.succ  <- succ;
  G.illegal g (* should be not reached *) 
@ 
As continuations appear in flow annotations, we set the [[cut_to]],
[[unwound_to]], and [[returned_to]] fields as needed.
We use the labels stored with the continuation to associate the
correct entry point with 
each continuation, depending on how the continuation is used.
This code appears in a context in which the [[continuation]] function
looks up a continuation by name.
<<function [[continuations]], which translates flow annotations>>=
let continuations cc ast =
  let volregs = cc.C.volregs in                 (* volatile registers *)
  let allregs = RS.union volregs cc.C.pre_nvregs in (* all registers *)
  let entry n = G.node_labeled g n in
  let (--)    = RS.diff in
  let as_cut_to k =
    let defs = k.K.cut_in.C.regs in
    { G.defs = defs;     G.kills = allregs -- defs; G.node = entry k.K.cut_pc    } in
  let as_unwinds k =
    { G.defs = RS.empty; G.kills = volregs;         G.node = entry k.K.unwind_pc } in
    (* defs are variables and so can't be a register set.  NEED ANOTHER MECHANISM *)
  let as_returns k =
    let defs = k.K.return_in.C.regs in
    { G.defs = defs;     G.kills = volregs -- defs; G.node=entry k.K.return_pc   } in
  let contmap f = List.map (f << continuation) in
  { S.cuts     = contmap as_cut_to  ast.S.cuts;
    S.unwinds  = contmap as_unwinds ast.S.unwinds;
    S.areturns = contmap as_returns ast.S.areturns;
    S.returns  = ast.S.returns; S.aborts = ast.S.aborts; } in
let ccontinuations cc ast =
  let ast' = { S.cuts = ast.S.ccuts; S.aborts = ast.S.caborts;
               S.unwinds = []; S.areturns = []; S.returns = false; } in
  let c = continuations cc ast' in
  { S.ccuts = c.S.cuts; S.caborts = c.S.aborts }
@
\subsubsection{Third pass: code for initializing and entering continuations}
@ 
The rest of the compilation happens at the end of the procedure.
There are three steps:
\begin{itemize}
\item
Store spans at each escaping continuation (for use by the runtime system).
\item
Initialize any escaping continuations ([[insert_init_cont_nodes]])
\item
Compile entry points for continuations as needed ([[finish_compiling_continuation]])
\end{itemize}
@
For each continuation we have reserved memory on the stack that must be
initialized when the procedure is entered. The following function
inserts code to do the initialization.

We also attach spans to each continuation that escapes.
<<definition of [[insert_init_cont_nodes]]>>=
let insert_init_cont_nodes contmap init_node =
  let one_node cname k succ = 
    if k.K.escapes then
      let pc              = exp_of_code_label k.K.cut_pc    in
      let sp              = proc_cc.C.stable_sp_loc         in
      let frame_size_span = RT.frame_size_to_span vfp proc_cc.C.stable_sp_loc in
      let cont_size_span  = RT.conts_to_spans target.T.wordsize in
      let () =
        add_spans (k.K.cut_pc, ra_span :: overflow_size_span :: frame_size_span ::
                               List.concat [cont_size_span; csregs_spans; k.K.spans])in
      let pc_sp = { Mflow.new_pc = pc; Mflow.new_sp = sp } in
      G.instruction g (Contn.init_code k.K.rep pc_sp) succ
    else
      succ in
  let next = G.succ init_node in
  G.set_succ init_node (G.illegal g);  (* avoid extra join before next *)
  G.set_succ init_node (Strutil.Map.fold one_node contmap next)
@ 
When we finish compiling a continuation, we make sure any label that
is used leads to sensible code.
A continuation that escapes but is never cut to presents a dilemma: 
it has to have a value (because it escapes), but the front end has
promised never to use that value in a [[cut to]].
For the moment, we treat the continuation just as if it could be cut
to, but we might go back later and find a way to change our minds.
<<functions that translate statements, including [[stmts]]>>=
let rec finish_compiling_continuation k =
  begin
    if k.K.cut_to then
      generate_cut_to_entry k
    else if k.K.escapes then
      generate_cut_to_entry k;
    if k.K.returned_to then
      generate_return_to_entry k;
    if k.K.unwound_to then
      generate_unwind_to_entry k;
  end
@ 
If we cut to a continuation, the overflow parameters live in its
representation on the stack, so we need only shuffle and manage the
stack pointer.
<<functions that translate statements, including [[stmts]]>>=
and generate_cut_to_entry k =
  let in' = k.K.cut_in in
  G.set_succ (G.node_labeled g k.K.cut_pc) (
  G.assertion    g (in'.C.insp (Contn.rep k.K.rep))     **>
  G.stack_adjust g in'.C.pre_sp   **>
  G.instruction  g in'.C.shuffle  **>
  G.stack_adjust g in'.C.post_sp  **>
  k.K.succ)
@ 
If we return to a continuation, we must remember the overflow block.
THERE'S A POTENTIAL PROBLEM WITH CALLING CONVENTION HERE---WE MIGHT
NEED A DIFFERENT ENTRY POINT DEPENDING ON THE CALLING CONVENTION OF
THE CALL SITE.  BLOG!
<<functions that translate statements, including [[stmts]]>>=
and generate_return_to_entry k = 
  let cc  = to_cc k.K.convention in
  let in' = k.K.return_in in
  let ()  = add youngblocks cc.C.overflow_alloc.C.result_allocator in'.C.overflow in
  G.set_succ (G.node_labeled g k.K.return_pc) (
  G.assertion    g (in'.C.insp (Contn.rep k.K.rep))    **>
  G.stack_adjust g in'.C.pre_sp    **>
  G.instruction  g in'.C.shuffle   **>
  G.stack_adjust g in'.C.post_sp   **>
  k.K.succ)
@ 
BUG ALERT! THIS CODE IS MISSING A NECESSARY ASSERTION ON THE VALUE
OF THE STACK POINTER.

LET'S JUST ADMIT IT: THIS FEATURE IS NOT YET IMPLEMENTED.
<<functions that translate statements, including [[stmts]]>>=
and generate_unwind_to_entry k = 
  Impossible.unimp "unwind to continuation";
  let assign_unspecified_to args = R.par [] in (* BOGUS *)
  G.set_succ (G.node_labeled g k.K.unwind_pc) (
  G.assertion g (assign_unspecified_to formals) **>  (* in lieu of dataflow *)
  k.K.succ) 
@

% ------------------------------------------------------------------ 
\subsection{Translations of statements}

@ 
\subsubsection{Simple statements}

We do the simple statements inline,
but interprocedural control flow is complicated enough to warrant
out-of-line functions (as will [[switch]]).
<<functions that translate statements, including [[stmts]]>>=
and stmts props ss succ = List.fold_left (fun node s -> stmt props s node) succ ss
and stmt  props s  succ =
  <<supporting functions for translating statements>> in
  match s with
  | S.If (e, so, not) ->
      G.cbranch g e ~ifso:(stmts props so succ) ~ifnot:(stmts props not succ)
  | S.Label n              -> let l = G.node_labeled g n in (G.set_succ l succ; l)
  | S.Switch _             -> Impossible.unimp "switch"
  | S.Cont (name, _, _)    -> contStmt2 name succ
  | S.Span (kv, bs)        -> stmts (kv :: props) bs succ
  | S.Assign rtl           -> G.instruction g rtl succ
  | S.Call (lhs, cc, e, args, targets, conts) -> call lhs cc e args targets conts succ
  | S.Goto (e, labels) ->
      (match Dn.exp e with
      | RP.Const (RP.Link (sym, _, w)) ->
             G.branch g ~target:(G.node_labeled g (sym#original_text))
      | _ -> let instr   = target.T.goto.T.embed e in
             let targets = List.map (G.node_labeled g) labels in
             G.mbranch g instr targets)
  | S.Jump (cc, e, args, targets) -> jump cc e args targets
  | S.Cut (cc, k, args, conts)    -> cut cc k args conts
  | S.Return (cc, i, n, args)     -> return cc i n args
@

\subsubsection{Statements that go between procedures}

\paragraph{Jumps}
The outgoing overflow parameters passed by a tail call go into the
\emph{young} end of the current activation.
N.B.~We don't use the [[targets]] list, which is there for future
interprocedural optimization and call-graph analysis.
<<supporting functions for translating statements>>=
and jump cconv e args targets(*unused*) = 
    let cc      = to_cc cconv in
    <<insist that [[cc]] matches [[proc_cc]] and supports jumps>>
    let out     = actuals cc.C.call_parms.C.out args in
    let ra_out  = cc.C.ra_on_exit saved_ra out.C.overflow temps in
    let jumpi   = target.T.jump.T.embed e in
    let jump_sp = cc.C.sp_on_jump out.C.overflow temps in
    let () =
      add oldblocks cc.C.overflow_alloc.C.parameter_deallocator out.C.overflow in
    G.stack_adjust g out.C.pre_sp                                  **>
    G.instruction  g out.C.shuffle                                 **>
    G.instruction  g restore_nvrs                                  **>
    G.instruction  g (RU.store ra_out (RU.fetch saved_ra))         **>
    G.stack_adjust g jump_sp                                       **>
    G.jump         g jumpi ~targets ~uses:(RS.union out.C.regs nvregs)
<<insist that [[cc]] matches [[proc_cc]] and supports jumps>>=
let () = if cc.C.name <> proc_cc.C.name then
           impossible "calling conv mismatch in jump" in
let () = if cc.C.overflow_alloc.C.parameter_deallocator <> C.Callee then
         impossible ("calling conv " ^ cc.C.name ^ " does not support jump") in
@
\paragraph{Calls}
<<supporting functions for translating statements>>=
and call lhs cconv e args targets(*unused*) conts succ = 
  let cc    = to_cc cconv                        in
  let out   = actuals cc.C.call_parms.C.out args in
  let in'   = results cc.C.results.C.in' lhs     in
  let calli = target.T.call.T.embed e            in
  let conts = continuations cc conts             in
  let () =
    add youngblocks cc.C.overflow_alloc.C.parameter_deallocator out.C.overflow in
                                        (* outgoing overflow parms *)
  let () = add youngblocks cc.C.overflow_alloc.C.result_allocator in'.C.overflow in
                                        (* incoming overflow results *)

  let frame_size_span =
    let base = Block.base out.C.overflow in
    if cc.C.overflow_alloc.C.parameter_deallocator = C.Caller then
      RT.frame_size_to_span vfp base
    else RT.frame_size_to_span vfp (Rtlutil.addk (W.exp base) base
                                                 (Block.size out.C.overflow)) in
  let up_to_call ~succ =
    G.stack_adjust g out.C.pre_sp                                        **>
    G.instruction  g out.C.shuffle                                       **>
    G.stack_adjust g out.C.post_sp                                       **>
    G.call g calli ~uses:out.C.regs ~defs:in'.C.regs ~kills:cc.C.volregs
                   ~altrets:conts.S.areturns ~unwinds_to:conts.S.unwinds
                   ~cuts_to:conts.S.cuts ~aborts:conts.S.aborts ~succ    in
  let call_succ  =
    G.assertion    g (in'.C.insp out.C.overflow)              **>
    G.stack_adjust g in'.C.pre_sp            **>  (* DOUBTS ABOUT THIS *)
    G.instruction  g in'.C.shuffle           **>
    G.stack_adjust g in'.C.post_sp           **>
    succ in
  let call_succ' = G.join_leading_to call_succ in
  let cont_spans = RT.conts_to_spans target.T.wordsize in (* BOGUS FOR NOW.... *)
  add_spans (G.label call_succ', ra_span :: overflow_size_span :: frame_size_span ::
                                 List.concat [cont_spans; csregs_spans; props]);
  up_to_call **> call_succ'
@
\paragraph{Returns}
In the presence of tail calls, [[f]] might call [[g]] with
convention~$A$,
[[g]]~might tail-call [[h]] with convention~$B$, and [[h]]~would need
to return to~[[f]] with convention~$A$.
Therefore, it is not only sensible but necessary to annotate the
[[return]] with its own convention.
<<supporting functions for translating statements>>=
and return cconv i n args = 
    let cc = to_cc cconv                       in
    let out = actuals cc.C.results.C.out args  in
    <<verbosely announce the registers used by the return>>
    let ra_out = cc.C.ra_on_exit saved_ra out.C.overflow temps in
    let reti   = cc.C.return i n (RU.fetch ra_out) in
    let () = add oldblocks cc.C.overflow_alloc.C.result_allocator out.C.overflow in
                        (* outgoing jump overflow = incoming *)
    G.stack_adjust g out.C.pre_sp            **>
    G.instruction  g out.C.shuffle           **>
    G.instruction  g (RU.store ra_out (RU.fetch saved_ra))  **>
    G.instruction  g restore_nvrs            **>
    G.stack_adjust g out.C.post_sp           **>
    G.return       g reti ~uses:(RS.union out.C.regs nvregs)
@ The code above is safe only so long as the outgoing area doesn't
overlap with the spill area.
This restriction is unfortunate, as if we could atomically shuffle
nonvolatile registesrs, outgoing parameters, and the return address
all in one go, we could overlap the two areas---except for spills.
@
<<verbosely announce the registers used by the return>>=
let () =
  let regstring (s, i, _) = Printf.sprintf "%c%d" s i in
  let used = List.map regstring (RS.elements out.C.regs) in
  Verbose.say 2 ["return statement uses regs: "; String.concat ", " used; "\n"] in
@
\paragraph{Cut to}
PERHAPS IT SHOULD BE POSSIBLE TO SET THE CALLING CONVENTION FOR CUT TO
     AND FOR CONTINUATION?

The overflow block is part of the representation of the continuation
and is placed in the stack elsewhere, but we need to remember any
constraints associated with this block.
<<supporting functions for translating statements>>=
and cut cc k args conts = 
  let cc    = to_cc cc in
  let out   = actuals (cc.C.cut_parms.C.out k) args in
  let cuti  = Contn.cutto target cc.C.cutto.Target.embed ~contn:k in
  let ()    = add_constraints (Block.constraints out.C.overflow) in
  let conts = ccontinuations cc conts in
  G.instruction g out.C.shuffle **>
  G.cut_to      g cuti ~cuts_to:conts.S.ccuts ~aborts: conts.S.caborts ~uses:out.C.regs
@ A couple of notes:
The constraints from [[out.C.overflow]] have to get to the solver in
order to resolve the addresses used in [[out.C.shuffle]].
Because the overflow block [[out.C.overflow]] is not part of the stack
frame, these constraints could go to the solver independently (and
right away).
But because the names used in each block are unique, it's just as
safe, and perhaps easier, to send these constraints to the solver
along with all the other constraints of this activation.
@

% ------------------------------------------------------------------ 
\subsection{Translating a procedure}
% ------------------------------------------------------------------ 

This section is a big ball of hair.
There are too many constraints about order.
@ 
\paragraph{Broadly useful values}
The procedure calling convention and virtual frame pointer are everywhere.
The temporaries are not everywhere, but it's convenient to have them
here anyway.
<<definition of [[proc]], which translates one procedure>>=
let proc global_map proc =
  let proc_cc  = to_cc proc.N.cc in
  let vfp      = target.T.vfp in (* virtual frame pointer *)
  let temps    = Talloc.Multiple.for_spaces target.T.spaces in
@ 
\paragraph{Setting up the control-flow graph}
First step is to set up  the control-flow graph.
We use [[exp_of_label]] below, but once symbols are expunged, it
should be simple enough to drop it (reducing the cognitive load on the
reader). 
<<definition of [[proc]], which translates one procedure>>=
  let exp_of_code_label l = R.codesym ((F.asm env)#local l) pointersize in
  let g =
    let exp_to_label e = match Dn.exp e with
    | RP.Const(RP.Link (l, _, _))
    | RP.Const(RP.Diff (RP.Link (l, _, _), _)) -> l#original_text
    | _ -> impossible "bad label projection" in
    let guarded_exp_of_code_label (g,l) =
      (g, (R.codesym ((F.asm env)#local l) pointersize)) in
    let guarded_exp_to_label (e1,e2) = match (e1, Dn.exp e2) with
    | (g, RP.Const(RP.Link (l, _, _)))
    | (g, RP.Const(RP.Diff (RP.Link (l, _, _), _))) -> (g, l#original_text)
    | _                           -> impossible "bad label projection" in
    let info = { G.goto = { T.embed = target.T.goto.T.embed << exp_of_code_label
                          ; T.project = exp_to_label << target.T.goto.T.project }
               ; G.branch = { T.embed = target.T.branch.T.embed
                                 << guarded_exp_of_code_label
                            ; T.project = guarded_exp_to_label
                                 << target.T.branch.T.project }
               ; G.bnegate = target.T.bnegate
               } in
    G.mk info Idgen.label in (* empty control-flow graph *)
@ 
\paragraph{Managing mutable state: blocks, constraints, and call site information}
The important state here is [[youngblocks]], [[oldblocks]], and
[[constraints]]. 
<<definition of type [[blocklists]]>>=
type 'a blocklists = { mutable caller : 'a list; mutable callee : 'a list }
<<definition of [[proc]], which translates one procedure>>=
  let youngblocks        = { caller = []; callee = [] } in
  let oldblocks          = { caller = []; callee = [] } in
  let add blocks party b = match party with
  | C.Caller -> blocks.caller <- b :: blocks.caller
  | C.Callee -> blocks.callee <- b :: blocks.callee in
  let constraints         = ref [] in
  let add_constraints  c  = constraints  := c :: !constraints        in
@   
To avoid threading state around, we store spans as mutable state.
Most spans are associated with specific call-sites.
However, some spans, such as stackdata information, are accessible globally within
the procedure; for these spans, we associate them with the current procedure's label.
<<definition of [[proc]], which translates one procedure>>=
  let spans        = ref [] in
  let add_spans s  = spans := s :: !spans              in
@   
\paragraph{Setting up the environment and functions that use it (stack
data, continuations, expressions, parameters)}
Here we rebind [[env]] to include local variables, stack data,
continuations, and so on.
We also bind a separate [[contenv]], which maps the name of a
continuation to its information as type [[K.t]] (see
chunk~\subpageref{ast2ir.K.t}). 
The [[stackdata]] function includes the first pass of translation of
continuations. 

We also gather all the stackdata labels and convert them to spans to pass on
to the run-time system.
Order is important -- an earlier span in the procedure must precede a later span in
the list passed to the runtime system.
Because stackdata labels are visible at any stopping point in a procedure, we associate
the spans with the label for the current procedure.
<<definition of [[proc]], which translates one procedure>>=
  let _ = 
    let stackdata_spans =
      RT.stackdata_to_spans ~wordsize:target.T.wordsize ~vfp proc.N.stacklabels in
    add_spans (proc.N.sym#original_text, stackdata_spans) in
@ 
<<definition of [[proc]], which translates one procedure>>=
let formals  = convert_parms (fun ((_, h, _, w, _) as parm) -> h, parm)
                             (fun (i, _, _, w, n) -> AT.of_loc (R.var n i w), w) in
let cformals = convert_parms (fun p -> p)
                             (fun v -> AT.of_loc v.FE.loc, RU.Width.loc v.FE.loc) in
let actuals  = convert_parms (fun ((h, _, _) as parm) -> h, parm)
                             (fun (_, e, w) -> e, w) in
let results  = convert_parms (fun p -> p) (fun (l, w) -> AT.of_loc l, w) in
@ 
@ 
We provide a lookup of continuation by name.
If a continuation is used as an rvalue, we get the address of its
representation.  
We also mark the continuation as escaping.
<<definition of [[proc]], which translates one procedure>>=
  <<function [[extend_cont]], for adding flow-graph info to continuations>>
  let contenv =
    let add env (n, k) = Strutil.Map.add n (extend_cont n k) env in
    List.fold_left add Strutil.Map.empty proc.N.continuations in
  let continuation l =
    try Strutil.Map.find l contenv with _ -> impossf "lost cont %s" l in
@ 
\paragraph{Nonvolatile registers, which are affected by incoming parameters}
We place a restriction on calling conventions supported by C--: a
parameter register is never nonvolatile.  
Therefore, for any particular procedure, we get the nonvolatile
registers for \emph{that} procedure by subtracting off those registers
used as parameters.
This choice constrains the set of calling conventions we can express,
but it makes it easy to express, e.g., the ``lightweight'' calling
convention, in which every register not a parameter is nonvolatile.
N.B. for a return or a jump, it is up to the specification of the
calling convention to avoid a conflict between result registers and
nonvolatile registers.

To figure out which registers are nonvolatile, we run the automaton
for the incoming parameters, putting results in~[[in']]. 
Don't overlook it.

For each nonvolatile register, we track the hardware register in
[[reg]] and the temporary location in [[tmp]].
If we ever want to save nonvolatile registers in conventional
locations, we will add two more pieces of information: a block for
the register and a mutable flag that tells whether the register is
spilled to that block.
<<types for nonvolatile registers>>=
type 'a nvr = { reg : 'a; tmp : 'a }   (* for callee-saves info *)
<<definition of [[proc]], which translates one procedure>>=
  let proc_in' = formals proc_cc.C.call_parms.C.in' proc.N.formals  in
  let nvregs = RS.diff proc_cc.C.pre_nvregs proc_in'.C.regs in
  let nvr_temps = 
    RS.fold (fun r i -> (r, proc_cc.C.saved_nvr temps r) :: i) nvregs [] in
  let nvr_info = List.map (fun (r,t) -> {reg = R.reg r; tmp = t}) nvr_temps in
  let save_nvrs =
    R.par (List.map (fun i -> RU.store i.tmp (RU.fetch i.reg)) nvr_info) in
  let restore_nvrs =
    R.par (List.map (fun i -> RU.store i.reg (RU.fetch i.tmp)) nvr_info) in
  let save_ra, saved_ra =
    let ra_in = proc_cc.C.ra_on_entry proc_in'.C.overflow in
    let loc   = proc_cc.C.where_to_save_ra ra_in temps in
    let w     = pointersize in
    R.store loc ra_in w, loc in
@
For each procedure, we create a span that represents the incoming stack
space that must be deallocated by the procedure.
<<definition of [[proc]], which translates one procedure>>=
  let overflow_size_span =
    let base = Block.base proc_in'.C.overflow in
    if proc_cc.C.overflow_alloc.C.parameter_deallocator = C.Callee then
      RT.overflow_size_to_span vfp
          (Rtlutil.addk (W.exp base) base (Block.size proc_in'.C.overflow))
    else RT.overflow_size_to_span vfp base in
@ 
Similarly, spans for the return address and callee-saves registers may be repeated
throughout a procedure.
<<definition of [[proc]], which translates one procedure>>=
  let ra_span = RT.ra_to_span ~wordsize:target.T.wordsize saved_ra in
  let csregs_spans = RT.csregs_to_spans ~wordsize:target.T.wordsize nvregs nvr_temps in
@ 
\paragraph{Supporting procedures}
We now have enough information in scope to drop in the definitions of
the translations for flow annotations, statements, and initialization
of continuations.
<<definition of [[proc]], which translates one procedure>>=
  <<function [[continuations]], which translates flow annotations>> in
  <<functions that translate statements, including [[stmts]]>> in
  <<definition of [[insert_init_cont_nodes]]>> in
@ 
\paragraph{Translation of the procedure body}

This is the ``second pass'' of section~\ref{ast2ir.sec:cont-trans}; it
builds most of the flow graph.
The initialization of continuations is delayed to a third pass, so we
create a label node [[initcont]] as a placeholder.
The initialization code is inserted at [[initcont]] after the translation.
<<definition of [[proc]], which translates one procedure>>=
  let initcont = G.node_labeled g (Idgen.label "initialize continuations") in
  let () = add oldblocks proc_cc.C.overflow_alloc.C.parameter_deallocator
                         proc_in'.C.overflow in
  let labelnode node ~succ = (G.set_succ node succ; node) in
  let () = 
    G.set_succ (G.entry g) (
    G.stack_adjust g proc_in'.C.pre_sp    **>
    G.instruction  g proc_in'.C.shuffle   **>
    G.stack_adjust g proc_in'.C.post_sp   **>
    G.instruction  g save_ra              **>
    G.instruction  g save_nvrs            **>
    labelnode initcont                    **>
    stmts proc.N.spans proc.N.code (G.exit g)) in 
@ And as promised, the third pass.
We initialize continuations, finish compiling them, and accumulate
their blocks into [[contblocks]].
<<definition of [[proc]], which translates one procedure>>=
  let () = insert_init_cont_nodes contenv initcont in
  let contblocks =
    let addblock name k blocks =
      finish_compiling_continuation k;
      if k.K.escapes then Contn.rep k.K.rep :: blocks else blocks in
    Block.cathl_list pointersize (Strutil.Map.fold addblock contenv []) in
@ 
\paragraph{Building and optimizing the [[Proc.t]]}
We take everything we know and combine it into a [[Proc.t]].
Then function [[optimize]], which is passed in, runs the rest of the
compiler. 
The main thing here is dealing with all the blocks.
<<definition of [[proc]], which translates one procedure>>=
  let formals = List.map (fun (i, h, v, w, n) -> i, (Some h, v, Ast.BitsTy w, n))
                proc.N.formals in
  let nvars = List.length proc.N.formals + List.length proc.N.locals in
  let i =    
    { Proc.symbol      = proc.N.sym
    ; Proc.cc          = proc_cc
    ; Proc.target      = target
    ; Proc.formals     = formals
    ; Proc.temps       = temps
    ; Proc.mk_symbol   = Fenv.Clean.symbol env
    ; Proc.cfg         = g
    ; Proc.oldblocks   = (* parms must be first, so call List.rev *)
        { C.callee = List.rev (oldblocks.callee); 
          C.caller = List.rev (oldblocks.caller); }
    ; Proc.youngblocks = (* order doesn't matter *)
        { C.callee = youngblocks.callee; 
          C.caller = youngblocks.caller; }
    ; Proc.stackd         = proc.N.stackmem     (* stack data block *)
    ; Proc.priv           = Block.relative vfp "private"
                            (aligned_mem ~align:proc_cc.C.sp_align) target 
    ; Proc.sp             = Block.at proc_cc.C.stable_sp_loc 0 proc_cc.C.sp_align 
    ; Proc.eqns           = List.concat (!constraints)
    ; Proc.conts          = contblocks
    ; Proc.vars           = nvars              (* number of variables *)
    ; Proc.nvregs         = RS.cardinal nvregs (* number of non-volatile regs *)
    ; Proc.var_map        = Array.make nvars None
    ; Proc.global_map     = global_map
    ; Proc.spans          = !spans
    } in
@ 
Before running the optimizer, we trim away any unreachable code,
as well as spans associated with unreachable code.
<<definition of [[proc]], which translates one procedure>>=
  let _ = Optimize.trim_unreachable_code () i in
  optimizer i (* runs optimizer, freezes, and assembles proc *)
@ 
We define an automaton to allocate suitably aligned locations. 
<<utilities>>=
let aligned_mem ~align ~base target = 
  let ( *> ) = AT.( *> ) in
  AT.at ~start:base ~memsize:target.T.memsize ~byteorder:target.T.byteorder (
    AT.align_to (fun w -> min align (w / target.T.memsize)) *>
    AT.overflow ~growth:Memalloc.Up ~max_alignment:align)
@
      
% ------------------------------------------------------------------ 
\subsection{Initialized and uninitialized data}
% ------------------------------------------------------------------ 

Initialized and uninitialized data translate to assembly directives.

A [[datum]] can appear globally inside a section or a section-level
[[span]] and locally inside a procedure as \texttt{stackdata}.  
This code translates global data into assembly actions;
the [[stackdata]] function handles stack data.
<<function [[datum]], for initialized and uninitialized data>>=
let rec datum global_map asm = 
  function
    | N.Datalabel l -> asm#label l  
    | N.Align n     -> asm#align n
    | N.InitializedData es -> List.iter (fun (k, t) -> asm#addr k) es
    | N.UninitializedData n -> asm#zeroes n
    | N.Procedure p -> proc global_map p
@


\subsection{Global Registers}
% ------------------------------------------------------------------ 

A global register either specifies a hardware register, or not. The
hardware register is lookeup up in the [[named_locs]] table and entered
into the register's symbol table entry. A register without a hardware
register are pushed trough the [[globals]] automaton and the resulting
location is entered into the register's symbol table entry. 

All compilation units in a program must declare exactly the same global
registers. We compute a cryptographic hash value for all global-register
declarations as a fingerprint. The fingerprint is a string of 16
characters, which may not be printable.

Function [[globals]] returns the enriched environment, the block of
memory that holds overflow global variables, and a fingerprint of the
declarations.

THIS CODE NEEDS TO BE REVISED ACCORDING TO THE NEW MANUAL: FIRST TABLE
LOOKUP, THEN IF NOT FOUND, ALLOCATION FROM AUTOMATON. -- NR
DONE; PLEASE REVIEW --CL

<<definition of [[globals]]>>=
let globals (base:Rtl.exp) vars =
    let t           = target.T.globals base in
    let decls       = Buffer.create 128 in (* initial size - grows as needed *)
    let rec assign bindings (name, var) = match var.FE.rhint with
    | FE.RNone | FE.RHint _ -> 
        (* global register w/o hardware annotation *)
        let w     = RU.Width.loc var.FE.loc in
        let sig'  = Printf.sprintf "[%s %d]" name w in
        let ()    = Buffer.add_string decls sig' in
        let loc   = AT.allocate t w "" in
        (var.FE.index, loc) :: bindings   (* could do even better here *)
    | FE.RReg hw ->
        (* global register with h/w annotation *)
        (try
          let loc   = AT.of_loc (Strutil.Map.find hw target.T.named_locs) in
          let sig'  = Printf.sprintf "[%s %s]" name hw in            
          let ()    = Buffer.add_string decls sig' in
          (var.FE.index, loc) :: bindings
        with Not_found -> impossible ("unknown h/w register: "^hw)) in
    let bindings = List.fold_left assign [] vars in
    let gmap =
      let var n = try List.assoc n bindings
                  with Not_found -> impossf "no global register %d" n in
      Array.init (List.length vars) var in
    gmap, AT.freeze t, Digest.string (Buffer.contents decls)    
@
We have to deal somehow with the global-register area, i.e., make it consistent.
The fingerprint [[digest]] for global register declarations is a
16-character string of unprintable characters. We make it printable by 
calling [[idcode]]; using [[String.escaped]] produces identifiers that
are too long for the linker.
<<supporting functions for fooling with the global-register area>>=
let emit_global_register_area ~export =
  let base_sym     = F.symbol env "Cmm.global_area" in
  let base         = Rtl.datasym base_sym pointersize in 
  let gmap, area, digest = globals base prog.N.globals in
  let area         = area.AT.overflow in
  let digest       = "Cmm.globalsig." ^ Idcode.encode digest in
  let asm          = F.asm env in
  let digest       = if export then asm#export digest else asm#import digest in
  (* must move to placevars and use gmap as a replacement map *)
  let _ = 
    if export then 
      begin
        asm#section (target.T.data_section);
        asm#comment "memory for global registers";
        asm#align (Block.alignment area);
        asm#label digest;     (* ensures desired definition is present *)
        asm#label base_sym;   (* ensures no multiple inconsistent definitions *)
        asm#addloc (Block.size area)
      end
    else
      let localref = asm#local "Cmm.ref_to_global_area" in
      begin
        asm#section (target.T.data_section);
        asm#label localref;
        asm#comment "reference to global-register signature";
        asm#addr (Reloc.Simple.of_sum digest (Bits.zero pointersize))
      end in
  gmap
@
 
% ------------------------------------------------------------------ 
\subsection{Translating a full compilation unit}
% ------------------------------------------------------------------ 

To translate a program, we work our ghastly magic on the
global-register overflow area, then emit all the sections.

THE TREATMENT OF THE GLOBAL-REGISTER AREA IS NOT YET CORRECT.
\begin{itemize}
\item
    The memory block for global registers should go into one compilation
    unit and be imported by all others.  OR PERHAPS IT SHOULD BE
    SUPPLIED AT RUN TIME BY THE FRONT END?
 Currently we just emit it
    because we are far from linking several {\PAL} compilation units.
\item
We don't correctly manage the fingerprint of the global-register
declarations.
\end{itemize}
<<function [[program]], which translates an entire program>>=
let program prog =
  let asm = F.asm env in
  <<supporting functions for fooling with the global-register area>> in
  let global_map = emit_global_register_area defineglobals in
  let section asm (name, data) =
    asm#section name; List.iter (datum global_map asm) data in
  List.iter (section asm) prog.N.sections;
  asm
@
