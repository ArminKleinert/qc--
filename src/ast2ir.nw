% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% ------------------------------------------------------------------ 
\section{Translation into Abstract {\PAL}}
% ------------------------------------------------------------------ 

After a source file has been successfully parsed and its static
semantics have been found correct it is translated into abstract 
{\PAL}. Abstract {\PAL} is defined by an {\asdl} description
[[ir.asdl]] in source file \module{ir}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

This module is called from the [[Main.main]] function with the name of
the source file; function [[ast2ir]] takes care of everything and
reports success or failure with an [[Error.error]] value.

<<ast2ir.mli>>=
val ast2ir: string -> unit Error.error
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

This module need a whole bunch of other modules.

<<ast2ir.ml>>=
module A  = Ast
module T  = Types
module E  = Error
module F  = Fenv.Clean

<<auxiliaries>>

module R = struct
    <<module R>>
end

module Expr = struct
    <<module Expr>>
end

module Make (G : Agraph.S) = struct
    module GM = G.Make
    <<module Make>> 
end

<<toplevel>>
@
 

% ------------------------------------------------------------------ 
\subsubsection{Auxiliaries}
% ------------------------------------------------------------------ 

Some auxiliary bindings.

<<auxiliaries>>=
let default_convention  = "C--"  (* gospel truth *)
let default_assertion   = -1     (* unused *)
let default_memory      = 'm'    (* Rtl.space *)
@

<<>>=
let dummy_expression    = Rtl.Const(Rtl.Bits(Bits.zero 32, 32))
@

[[bits]] extracts a [[width]] from a type, i.e.~the number of bits.
This must be never applied to a [[bool]] value.

<<>>=
let bits = function
    | T.Bits n -> n
    | _        -> assert false
@

[[byteorder]] returns the byteorder as recorded in the environment. 

<<>>=
let byteorder env = match F.findEndianness env with
    | F.Big     -> Rtl.BigEndian
    | F.Little  -> Rtl.LittleEndian
@

[[un_const]] should take a compile-time constant expression and
produce a small itneger.  [[un_const]] is surely the wrong name.

<<>>=
let un_const e = 333 (* bogus *)
@ 

The target dependent sizes of pointers and words are recorded in the
fat environment.  The following two functions provide access to them. 
Additionally [[wordBits]] and [[pointerBits]] provide the bit sizes of
both.

<<>>=
let wordBits env        = F.findWordsize env 
let wordTy env          = T.bits (wordBits env)
let pointerBits env     = F.findPointersize env
let pointerTy env       = T.bits (pointerBits env)
@

% ------------------------------------------------------------------ 
\subsubsection{Module \texttt{Make}}
% ------------------------------------------------------------------ 

The implementation [[Make]] is a functor that receives an abstract
view ([[Agraph]] -- \module{agraph}) of the flow graph as an argument.


The [[ty]] function returns the number of bits denoted by a type in
the {\small AST}.

<<module Make>>=
let rec ty env = function
    | A.TyAt(x,_)       -> ty env x
    | A.BitsTy(n)       -> n
    | A.AliasTy(name)   -> ( match F.findt name env with
                           | attr, T.Bits n -> n
                           | _              -> assert false
                           )
@

The [[idTy]] function returns the number of bits denoted by a name
[[n]] which is looked up in the fat environment.

<<>>=                           
let idTy n env = match F.findv n env with attr, (denot,ty) -> bits ty
@

                             
The following function translates an [[Ast.actual]] parameter into a
[[Fgraph.actual]].

<<>>=
let rec actual env (hint, e) = 
    let width = bits (Expr.tyExpr env e) in
    let e     = expr env e               in
        (e, width, hint)
    
@
 

% ------------------------------------------------------------------ 
\paragraph{Expressions}
% ------------------------------------------------------------------ 

[[expr]] translates an {\small AST} expression into an [[Rtl.expr]].  

An assignment is an effect that is captured by an {\rtl}.  The lvalue
of an assignment becomes a {\rtl} [[location]].  We currently ignore
alignments and hints.

<<>>=
and lvalue env = function
    | A.LValueAt(x,_)   -> lvalue env x
    | A.Var(hint,x)     -> let (attr,(_,t)) = F.findv x env in Rtl.Var(x,bits t)
    | A.Mem(t,e,a)      -> let width = ty env t      in
                             Rtl.Cell
                             ( default_memory
                             , byteorder env 
                             , width
                             , expr env e
                             , default_assertion
                             )
@

<<>>=
and primOp env op args =
    let o = Expr.op env op args 
    in
        Rtl.App(o, List.map (expr env) args)

and expr env = function 
    | A.ExprAt(x,_)         -> expr env x
    | A.Int( i, None)       -> Rtl.Const(Rtl.Bits(i,wordBits env))
    | A.Int( i, Some t)     -> Rtl.Const(Rtl.Bits(i,ty env t))
    | A.Float( f, None)     -> Rtl.Const(Rtl.Bits(f,wordBits env))
    | A.Float( f, Some t)   -> Rtl.Const(Rtl.Bits(f,ty env t))
    | A.Char( c, None)      -> Rtl.Const(Rtl.Bits(c,wordBits env))
    | A.Char( c, Some t)    -> Rtl.Const(Rtl.Bits(c, ty env t))
    | A.Fetch(v)            -> let width = bits (Expr.tyFetch env v) in 
                               Rtl.Fetch(lvalue env v,width)
    | A.BinOp(l,op,r)       -> primOp env op [l;r]
    | A.UnOp(op,e)          -> primOp env op [e]
    | A.PrimOp(op,xs)       -> primOp env op (List.map snd xs) (* ignore hints*)
@    
   
% ------------------------------------------------------------------ 
\paragraph{Memory declarations}
% ------------------------------------------------------------------ 


<<>>=
let memsize env ir = function
    | A.NoSize        -> true
    | A.DynSize       -> true
    | A.FixSize(e)    -> true

<<>>=
let rec init env ir = function
    | A.InitAt(x,_)   -> init env ir x
    | A.InitExprs(es) -> true
    | A.InitStr(s)    -> true
    | A.InitUStr(s)   -> true

<<>>=
let rec datum env ir = function
    | A.DatumAt(x,_)        -> datum env ir x
    | A.Label(n)            -> true
    | A.Align(a)            -> true
    | A.MemDecl(t,m,Some i) -> true
    | A.MemDecl(t,m,None)   -> true


<<>>=
let register env ir (v , t, n, reg)  = true
@

% ------------------------------------------------------------------ 
\paragraph{Flow Annotations}
% ------------------------------------------------------------------     

Flow annotations are translated to continuation bundles of type
[[Fgraph.cont]].  The [[flows]] function takes a list of flow
annotations and adds them to a provided [[Fgraph.cont]] value.

<<>>=
let rec flows cont = function 
| (A.FlowAt (x,_)):: xx -> flows cont (x::xx)
| (A.CutsTo n)    :: xx -> flows {cont with GM.cuts    = n @ cont.GM.cuts } xx
| (A.UnwindsTo n) :: xx -> flows {cont with GM.unwinds = n @ cont.GM.unwinds} xx 
| (A.ReturnsTo n) :: xx -> flows {cont with GM.returns = n @ cont.GM.unwinds} xx 
| (A.Aborts)      :: xx -> flows {cont with GM.aborts  = true } xx
| []                    -> cont     
@

% ------------------------------------------------------------------ 
\paragraph{Statements} 
% ------------------------------------------------------------------ 

A statement is part of a [[body]]; the [[body]] function receives
arguments that we need for all statements:  [[env]] is the clean
environment, which doesn't change.  [[s]] is the statement being
translated.  We return a new flow-graph node.  [[after]] is a
representation of the entire flow graph, with a pointer to the node
that follows this statement. 

<<>>=
let rec body env props graph after bb =
    let rec stmt s after = match s with
        | A.StmtAt(x,_)     -> stmt x after
        <<cases for translating statements>>
    in
    let rec body b after = match b with
        | A.BodyAt(x, _)    -> body x after
        | A.DeclBody(d)     -> after (* ignore decls *)
        | A.StmtBody(s)     -> stmt s after
        | A.DataBody(dd)    -> after (* ignore data for the moment *)
    in
        List.fold_right body bb (G.bind G.Props.empty (GM.exit graph))
        
@ 


<<cases for translating statements>>=
| A.AssignStmt(lhs,rhs) ->
    let effects = 
      List.map2 (fun lhs rhs -> R.assign (lvalue env lhs) (expr env rhs)) lhs rhs
    in props (GM.assign (R.par effects) after)

<<cases for translating statements>>=
| A.IfStmt ( e, ss1, ss2) ->
    let n1 = List.fold_right stmt ss1 after in
    let n2 = List.fold_right stmt ss2 after in
    props (GM.branch (expr env e) n1 n2)
@

<<cases for translating statements>>=
| A.ReturnStmt(cc, alt, args) ->
    let const n = A.Int (Bits.of_int n Bits.maxwidth, None)   in
    let (cont, count) = Aux.Option.get (const 0, const 0) alt in
    let cc = Aux.Option.get default_convention cc             in
        props (GM.copy_out (List.map (actual env) args) Fgraph.ProcResults cc (
        props (GM.return graph (un_const cont) (un_const count))))

<<cases for translating statements>>=
| A.LabelStmt(n)                       -> props (GM.label n after)
@


A call [[x,y = f(v,w)]] is translated into the following sequence of
nodes in the flow graph:

\begin{enumerate}
\item A [[CopyOut]] node for the parameters [[v]] and [[w]],
\item a [[Call]] node for [[f]],
\item a [[CopyIn]] node for the variables [[x]] and [[y]],
\item the passed in [[after]] node.
\end{enumerate}

Since the flow graph is build up backwards the [[CopyIn]] node comes first.

<<cases for translating statements>>=
| A.CallStmt(lhs, cc, e, args, ts, fs) ->
    let rec lvalue = function
        | A.LValueAt(x,_) -> lvalue x
        | A.Var(hint,n)   -> (n,idTy n env ,hint)
        | A.Mem _         -> assert false in     
    let cc    = Aux.Option.get default_convention cc in
    let copyi = if lhs <> []
                then props (GM.copy_in (List.map lvalue lhs)
                                       Fgraph.ProcResults cc after)
                else after                           in
    let cont  = flows (GM.empty_cont copyi) fs       in
    let call  = props (GM.call (expr env e) cont)    in
    let copyo = if args <> []
                then props (GM.copy_out (List.map (actual env) args)
                                        Fgraph.ProcParameters cc call)
                else call                            
    in
        copyo
@        

A continuation is represented by a labeled node.  This node is a
[[CopyIn]] node in case the continuation receives parameters. 
        
<<cases for translating statements>>=
| A.ContStmt(n,ns) -> 
    let hint  = None                                          in
    let cc    = default_convention                            in
    let args  = List.map (fun n -> (n, idTy n env, hint )) ns in
    let copy  = if ns <> []
                then props (GM.copy_in args Fgraph.ContParameters cc after)
                else after                           
    in
        props (GM.label n copy)

<<cases for translating statements>>=
| A.EmptyStmt -> after
@

A tail call is a [[jump]] statement. The parameters, if any, are
handled by a [[CopyOut]] node in the flow graph representation.  The
actual sequence is the [[CopyOut]] node, followed by the [[Jump]]
node. The [[after]] node is not used in since a jump always ends a
sequence of statements.

<<cases for translating statements>>=
| A.JumpStmt(cc,e,args,ts) ->
    let cc    = Aux.Option.get default_convention cc  in
    let args  = List.map (actual env) args            in
    let jump  = props (GM.jump graph (expr env e) ts) in
        if   args <> []
        then props (GM.copy_out args Fgraph.ProcParameters cc jump)
        else jump
@

The translation of a [[goto]] statement is straight forward; the
[[after]] node is unused.

<<cases for translating statements>>=
| A.GotoStmt(e,ts) -> props (GM.goto graph (expr env e) ts)
@

The following statements are just skipped for the moment.    

<<cases for translating statements>>=
| A.PrimStmt(lhs, cc, n, args, fs)     -> after
| A.SpanStmt(e1,e2,ss)                 -> after
| A.CutStmt(e, args, fs)               -> after
| A.SwitchStmt (r,e,arms)              -> after
@

<<unused>>=
let range env ir = function
    | A.Point(e)        -> true
    | A.Range(e1,e2)    -> true
@ 
<<>>=
and arm env ir = function
    | A.ArmAt(x,_)          -> arm env ir x
    | A.Case(ranges, stmts) -> true

% ------------------------------------------------------------------ 
\paragraph{Procedures}
% ------------------------------------------------------------------ 

Each procedure is translated into a control flow graph that shares no
nodes with any other control flow graph.  A procedure's control flow
graph is anchored with a label in an [[Agraph.graph]] data structure
under the name of the procedure. 

A procedure starts with a [[CopyIn]] node that assigns the incoming
parameters to the named registers and ends with an [[Exit]] node. The
types of the formal parameters are bound in the local environment
belonging to a procedure. 


<<module Make>>=
and proc env env props graph (cc,n,fs,bb) =  
    let env   = match F.findv n env with 
                | _,(F.Label(F.Proc e),_) -> e
                | _  -> assert false                                       in
    let cc    = Aux.Option.get default_convention cc                       in
    let exit  = G.bind G.Props.empty (GM.exit graph)                       in
    let bdy   = body env props graph exit bb                               in
    let frml  = fun (h,i,t,n) -> (n,ty env t,h)                            in
    let copy  = GM.copy_in (List.map frml fs) Fgraph.ProcParameters cc bdy in
        props (GM.label n (props copy))
@
    
    
% ------------------------------------------------------------------ 
\paragraph{Unused}
% ------------------------------------------------------------------ 

<<unused>>=
and decl env ir = function
    | A.DeclAt(x,_)    -> decl env ir x
    | A.Import( t, ns) -> true
    | A.Export( t, ns) -> true
    | A.Const (t,n,e)  -> true
    | A.Registers( rs) -> true
    | A.Typedef (t,nn) -> true
    | A.Target (arch)  -> true
    | A.Pragma         -> true

<<>>=
and section env ir = function
    | A.SectionAt(x,_)     -> section env ir x
    | A.Decl(d)            -> true
    | A.Datum( d)          -> true
    | A.Procedure(p)       -> true
    | A.SSpan( e1, e2, ss) -> true
            
    
% ------------------------------------------------------------------ 
\paragraph{Toplevel}
% ------------------------------------------------------------------ 

<<>>=
let rec toplevel env ir = function
    | A.ToplevelAt(x, _)  -> toplevel env ir x
    | A.Section(name, ss) -> true
    | A.TopDecl(d)        -> true
    | A.TopProcedure(p)   -> true
@


% ------------------------------------------------------------------ 
\paragraph{Program}
% ------------------------------------------------------------------ 

<<>>=
let program env ir ds = true
@

% ------------------------------------------------------------------ 
\subsubsection{{\rtl} Auxiliaries}
% ------------------------------------------------------------------ 

Module [[R]] contains auxiliary functions for {\rtl}s.  We like to
collect some from the actual usage patterns and then put them in their
own module. 

<<module R>>=
  let truth      = Rtl.Const(Rtl.Bool(true))
  let width_of r = 77 (* all exprs 77 bits wide - bogus *)
  let assign l r = Rtl.Rtl [(truth, Rtl.Store(l, r, width_of r))]
  let skip       = Rtl.Rtl []
  let par l      = List.fold_right 
                   (fun (Rtl.Rtl l1) (Rtl.Rtl l2) -> Rtl.Rtl (l1 @ l2)) l skip
@
 
% ------------------------------------------------------------------ 
\subsubsection{Expression Evaluation}
% ------------------------------------------------------------------ 

The translation of {\PAL} expressions to {\rtl} expressions requires
the types of {\PAL} expression and sometimes their values as well. 
There is code for both in the \module{elab} module.  Unfortunately
they are implemented against the [[Fenv.Dirty]] environment. 
Factoring this out is no small job.  For the moment we provide some
new code here.

<<module Expr>>=
let rec evalTy env = function
    | A.TyAt(x,r)    -> evalTy env x
    | A.BitsTy(size) -> Types.Bits size
    | A.AliasTy(n)   -> snd (F.findt n env)

let rec tyFetch env = function
    | A.LValueAt(x,r) -> tyFetch env x
    | A.Var(hint,id)  -> (match F.findv id env with (attr,(_,t)) -> t)
    | A.Mem (t,e,a)   -> 
        let te    = tyExpr env e       in       (* unused *)
        let t'    = evalTy env t       in       
        let align = Aux.Option.get 1 a in
            t'
@       

For now we are using the types of the primitive constant operators. 
All primitive runtime operators will go into their own module
[[Primitives]].  So we have to fix the [[lookup]] later.

<<>>=
and tyPrimOp env op args =
    let at = List.map (tyExpr env) args          in
    let ot = snd (Value.Ops.lookup op Value.ops) in
        Types.appl ot at

and op env o args =
    let at = List.map (tyExpr env) args          in
    let ot = snd (Value.Ops.lookup o Value.ops) in
        o,Types.widthlist ot at

<<>>=
and tyExpr env = function
    | A.ExprAt(x,r)            -> tyExpr env x
    | A.Int   (str, Some t)    -> evalTy env t
    | A.Int   (str, None)      -> wordTy env
    | A.Float (str, Some t)    -> evalTy env t
    | A.Float (str, None)      -> wordTy env
    | A.Char  (str, Some t)    -> evalTy env t
    | A.Char  (str, None)      -> wordTy env
    | A.Fetch (v)              -> tyFetch env v
    | A.BinOp (l,op,r)         -> tyPrimOp env op [l;r]
    | A.UnOp  (op,expr)        -> tyPrimOp env op [expr]
    | A.PrimOp(op,args)        -> tyPrimOp env op (List.map snd args)
@


% ------------------------------------------------------------------ 
\subsubsection{Exported top-level functions}
% ------------------------------------------------------------------ 

We now leave the implementation of [[Make]] and return to the
top-level of our module.  It contains functions called from module
\module{main} in response to command line arguments to the compiler.

<<toplevel>>=
let check map program =
    let env        = Fenv.Dirty.empty map                   in
    let env        = Elab.Env.global env program            in
    let env        = Elab.Check.global env program          in
        if   Fenv.Dirty.errorFlag env
        then E.error "compilation aborted due to errors in static semantics"
        else Fenv.clean env
@

The function [[ast2ir]] scans, parses, and checks a file before the
translation in this module can start.

<<ast2ir.ml>>=
let ast2ir file =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; let ast        = Parse.program scanner lexbuf in
              let env        = check map ast                in
                  E.Ok()
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.Error
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.Error
              )
            | e ->
              ( finally()
              ; raise e
              )
@
