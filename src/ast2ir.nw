% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et sts=4
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

%%Grades: C Central Immediate

% inc: \usepackage{alltt}


% Table of Contents
% egrep '^\\(sub)*section' ast2ir.nw 
%
% \section{Translation to Intermediate Representation}
% \subsection{Implementation}
% \subsection{Auxiliaries}
% \subsection{Expression Types}
% \subsection{Expression Translation}
% \subsection{Constant Evaluation}
% \subsection{Auxiliaries for Make}
% \subsection{Continuation Bundles}
% \subsection{Assignment}
% \subsection{Formal and Actual Parameters}
% \subsection{Global Registers}
% \subsection{Statements}
% \subsection{Procedure Translation}
% \subsection{Global Memory declarations}
% \subsection{Stack Data Declarations}
% \subsection{Toplevel}
% \subsubsection{Program}


WORK STILL TO BE DONE:
\begin{itemize}
\item
REPLACE STACK POINTER WITH VIRTUAL FRAME POINTER.
\item
RECORD SET OF THINGS DEFINED AT THE ``UNWOUND TO'' ENTRY POINT OF A CONTINUATION.
THERE IS A PROBLEM HERE, BECAUSE WE HAVE NO WAY TO RECORD
A DEFINITION OF A VARIABLE, BUT THIS IS WHAT THE UNWIND OPERATION
DOES.
PERHAPS THE ASSERTION NODE WILL DO THE TRICK.
\end{itemize}



@
% ------------------------------------------------------------------ 
\section{Translation to Intermediate Representation}
% ------------------------------------------------------------------ 

This module does \emph{lots} of translation: 
each procedure to a [[Proc.t]], and everything else down to the
assembly level.
The [[Proc.t]] is embedded into the assembly program as a single
instruction. 

We put the [[Target.t]] parameter first always because we first put
the less-specific information before the more-specific information.

The functor parameters and the parameter of type [[string->Call.t]]
will all go away once the new flow graph ([[Cfg]]) takes over the compiler.
<<ast2ir.mli>>=
module Make (G : Cfg.S) (*(Call : Call.S with type node = Rtl.rtl G.node)*) : sig
  type tgt  = ((Rtl.exp -> Automaton.t), Call.t) Target2.t'
  type proc = (Automaton.t, Rtl.rtl G.cfg, Call.t, tgt) Proc.t'
  val translate :  tgt
                -> Fenv.Clean.env 
                -> optimizer: (proc -> unit)
                -> Ast.program 
                -> Asm3.assembler
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

Typical abbreviations.
<<ast2ir.ml>>=
module T  = Target2
module A  = Ast
module E  = Error
module F  = Fenv.Clean
module AT = Automaton
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module RS = Register.Set
module Up = Rtl.Up
module Dn = Rtl.Dn
@ 
Utility functions and so on.
<<ast2ir.ml>>=
<<auxiliaries>>
@
The implementation is functorized because at the time this module was
first written, the flow-graph and calling-convention modules did not exist.

There's some trickiness in the denotations of expressions, because
there are two scopes: toplevel scope and procedure scope.
We therefore instantiate [[expr]], [[exprtype]], and [[lvalue]] twice:
once at top level and once instead each procedure.
The first instantiation is visible here; the second appears in 
[[<<definition of [[proc]], which translates one procedure>>]].
<<ast2ir.ml>>=
module Make (G : Cfg.S) (*(C : Call.S with type node = Rtl.rtl G.node)*) = struct
  module C = Call
  <<statement-related types>>
  <<module [[K]], for continution info>>
  <<types for gathering stack and continuation info>>
  type 'a nvr = { reg : 'a; tmp : 'a; w : int }   (* for callee-saves info *)

  type tgt = ((Rtl.exp -> Automaton.t), C.t) Target2.t'
  type proc = (Automaton.t, Rtl.rtl G.cfg, C.t, tgt) Proc.t'

  let translate target env ~optimizer =
    let pointersize = target.T.pointersize in
    let add = RU.add pointersize in
    let ccs = target.T.cc in
    let to_cc cconv = ccs (Aux.Option.get default_cc cconv) in
    <<definition of [[lvalue_name_in_env]]>> in
    <<environment-independent support for formals, actuals, and results>> in
    let exprfuns env contenv cont_rvalue =
      <<definition of function [[exprtype]]>> in
      let lvalue_name = lvalue_name_in_env env in
      <<definition of [[rvalue_name]]>> in
      <<mutually recursive nest of [[expr]] and [[lvalue]]>> in
      expr, exprtype, lvalue  in
    let expr, exprtype, lvalue = 
      let impcont _ _ _ = impossible "continuation at top level" in
      exprfuns env Strutil.Map.empty impcont in
    <<definitions of [[compile_const]], [[eval_const]], and [[link_const]]>> in
    <<definition of [[proc]], which translates one procedure>> in
    <<definition of [[globals]]>> in
    <<function [[datum]], for initialized and uninitialized data>> in
    <<function [[toplevel]], for emitting toplevel items>> in
    <<function [[program]], which translates an entire program>> in
  program
end
@

% ------------------------------------------------------------------
\subsection{Auxiliaries}
% ------------------------------------------------------------------ 

Some usual suspects.
<<auxiliaries>>=
let (<<) f g = fun x -> f (g x) (* function composition *)
let impossible = Impossible.impossible
@ 
Some defaults (probably should be elsewhere).
<<auxiliaries>>=
let default_cc          = "C--"
let default_space       = ('m':Rtl.space)
@
\subsubsection {Conversion from type to width}
\nwaddbox{tywidth  : 'a Types.t -> 'a}
\nwaddbox{astty    : F.env -> A.ty -> Types.ty}
\nwaddbox{astwidth : F.env -> A.ty -> int}
\deeperbox{2pt}
<<auxiliaries>>=
let tywidth = function
  | Types.Bits n -> n
  | Types.Bool   ->
      impossible "width of type bool"

let rec astty env = function
  | A.TyAt(x,r)  -> astty env x
  | A.BitsTy(n)  -> Types.bits n
  | A.AliasTy(x) -> snd (F.findt x env)

let astwidth env = tywidth << (astty env) 
@


@
\subsection{Names and expressions}
\subsubsection{The meanings of names}

Only the name of a {\PAL} register variable is meaningful in an lvalue
context.
The environment is explicit.
\nwaddbox{lvalue_name_in_inv : F.env -> name -> AT.loc * Rtl.width}
\deeperbox{16pt}
<<definition of [[lvalue_name_in_env]]>>=
let lvalue_name_in_env env x = 
  let (_,(denot,t)) = F.findv x env in
  let w = tywidth t                 in
  match denot with
  | F.Register({F.loc=Some l}) -> AT.of_old l, w
  | F.Register({F.index=i;F.loc=None}) ->
      if F.is_localv x env then
        AT.of_loc (Rtl.var x i w), w
      else 
        impossible "global variable without location"
  | _ -> impossible "asked for lvalue of non-register name"
@ 
Any name can be meaningful in an rvalue context.
The environment is implicit.
\nwaddbox{val rvalue_name : name -> Rtl.exp}
<<definition of [[rvalue_name]]>>=
let rvalue_name x =
  let (_,(denot,t)) = F.findv x env in
  let w = tywidth t in
  match denot with
  | F.Constant(bits)            -> Rtl.bits bits w
  | F.Label(F.Proc (s,_,_))     -> Rtl.link s w
  | F.Label(F.Code s)           -> Rtl.link s w
  | F.Label(F.Data s)           -> Rtl.link s w
  | F.Import(_,s)               -> Rtl.link s w
  | F.Continuation(st,_)        -> cont_rvalue x st w
  | F.Label(F.Stack(None))      -> impossible "Ast2ir.Make.variable"
  | F.Label(F.Stack(Some addr)) -> addr  (* a fetch would be wrong *)
  | F.Register _                -> atfetch (lvalue_name x)
@ 
Help for fetching and storing automata locations.
<<auxiliaries>>=
let atfetch (loc, w)     = loc.AT.fetch w
let atstore (loc, w) exp = loc.AT.store exp w
@ 
\subsubsection{General lvalues}

Again, the environment is implicit.
\nwaddbox{lvalue : Ast.lvalue -> AT.loc * Rtl.width}
\deeperbox{14pt}
<<mutually recursive nest of [[expr]] and [[lvalue]]>>=
let rec lvalue lhs = match lhs with
  | A.LValueAt(lhs,_)   -> lvalue lhs
  | A.Var(hint,x)       -> lvalue_name x 
  | A.Mem(t,addr,align) ->
      let w    = astwidth env t in
      let assn = match align with None -> Rtl.none | Some n -> Rtl.aligned n in
      AT.of_loc (Rtl.mem assn default_space target.T.byteorder w (expr addr)), w
@ 

% ------------------------------------------------------------------ 
\subsubsection{Expression Types}
% ------------------------------------------------------------------ 

We use the generic [[Expcheck]] module to find an expression's type.
Values from the environment are always [[Ok]] because at this stage we
have a clean environment.
IT SEEMS TO ME THAT THIS CODE IS A HEAVY-DUTY WRAPPER AROUND
[[Expcheck.check]]. 
CAN ANYTHING BE DONE, E.G., BY FUNCTORIZING [[Expcheck]]?
<<definition of function [[exprtype]]>>=
let exprtype exp =
    let word      = Error.Ok (Types.bits target.T.wordsize)    in
    let pointer   = Error.Ok (Types.bits pointersize) in
    let tlookup   = fun x -> Error.Ok (snd (F.findt x env))         in
    let vlookup   = fun x -> Error.Ok (match (F.findv x env) with
                                      | (_,(_,t)) -> t 
                                      ) in
    let e = { Expcheck.wordsize    = word
            ; Expcheck.pointersize = pointer
            ; Expcheck.tlookup     = tlookup
            ; Expcheck.vlookup     = vlookup
            } 
    in try ( match Expcheck.check e exp with
           | Error.Ok(t) -> t
           | Error.Error -> impossible "error exp post checking"
           )
       with Error.ErrorExn msg -> impossible "error exn post checking"
@

% ------------------------------------------------------------------ 
\subsubsection{Expression Translation}
% ------------------------------------------------------------------ 

It may be possible to evalute an expression at compile time, link time, or
run time. 
We should evaluate constant expressions as EARLY as possible. Module
\module{rtleval} does this for link-time expressions and could possibly
be extended.
@
\begin{quote}\it
    Since evaluation and type-checking are separated, types in nested
    expressions are checked multiple times. This introduces a
    quadratic complexity. QUADRATIC IN WHAT SIZE??
    The only way to avoid this, as far as I can
    see, is a combined bottom-up evaluation and type checking. --CL
    I THINK THIS WOULD BE AN EXCELLENT THING TO DO.  IT WOULD MEAN
    CHANGING THE POST-ELABORATION REPRESENTATION OF THE PROGRAM FROM
    AN ABSTRACT-SYNTAX TREE TO A SANER INTERMEDIATE FORM.  THIS TOO COULD
    BE A GOOD THING. ---NR
@
    Link-time constants are not atomic but have an expression structure.
    We should try to push some operators down into link time constants:
    The sum of a symbol and a constant can be represented as a link-time
    constant. This requires that [[Rtl.Link]] values carry a
    [[Reladdr.t]] value rather just a [[Reladdr.symbol]]. --CL
    RECOMMEND: TREAT LINK-TIME CONSTANT EXPRESSION AS AN ORDINARY [[Rtl.exp]].
    THE LINK-TIME CONSTANT NATURE OF THE EXPRESSION IS A DYNAMIC
    PROPERTY THAT SHOULD BE DEALT WITH BY THE ASSEMBLER OR CODE
    EXPANDER.  THIS MODULE WILL NEED SOME TARGET-DEPENDENT HELP TO
    IDENTIFY WHICH LINK-TIME CONSTANT EXPRESSIONS CAN BE EMITTED AS
    INIIALIZED DATA. ---NR
\end{quote}
<<mutually recursive nest of [[expr]] and [[lvalue]]>>=
and expr exp = 
  let prim op args =
    let argtys  = List.map exprtype args in
    let _,opr   = Rtlop.Translate.operator op argtys   in
    Rtl.app opr (List.map expr args) in
  let word = target.T.wordsize in
  let literal str width cvt = Rtl.bits (cvt str width) width in
  let const default_width = function
    | Some ty -> astwidth env ty
    | None    -> default_width in
  match exp with
  | A.ExprAt(x,_)     -> expr x
  | A.Int(str,t)      -> literal str (const word t) Bits.U.of_string
  | A.Float(str,t)    -> literal str (const word t) Bits.U.of_string
  | A.Char(str,t)     -> literal str (const word t) Bits.U.of_string
     (*FLOAT AND CHARACTER LITERALS LOOK SUSPICIOUS TO ME*)
  | A.Fetch(v)        -> atfetch (lvalue v)
  | A.BinOp (l,op,r)  -> prim op [l;r]
  | A.UnOp  (op,e)    -> prim op [e]
  | A.PrimOp(op,args) -> prim op (List.map snd args)
@

% ------------------------------------------------------------------ 
\subsection{Constant Evaluation}
% ------------------------------------------------------------------ 

We translate constants to {\rtl} expressions which we then evaluate.

THE TRANSLATION OF THE LINK-TIME CONSTANTS SHOULD BE DELEGATED TO THE
ASSEMBLER.
ONLY AN ASSEMBLER KNOWS WHAT LINK-TIME CONSTANTS IT CAN SUPPORT.
<<definitions of [[compile_const]], [[eval_const]], and [[link_const]]>>=
let compile_const exp     = Rtleval2.bits (expr exp)
and eval_const    asm exp = Rtleval2.exp  (expr exp)  
and link_const    asm exp = 
    match Dn.exp (Rtleval2.exp  (expr exp)) with
    | RP.Const(RP.Bits(b))   -> Reloc.Simple.of_const b
    | RP.Const(RP.Link(l,w)) -> Reloc.Simple.of_sum l (Bits.zero w)
    | RP.App(("add",_),[RP.Const(RP.Link(l,w)); RP.Const(RP.Bits(b))]) ->
        Reloc.Simple.of_sum l b
    | RP.App(("sub",_),[RP.Const(RP.Link(l,w)); RP.Const(RP.Link(l',w'))]) ->
        Impossible.unimp "difference of link-time constants"
    | e ->
        impossible
          ("Bad link-time constant " ^ Rtlutil.ToReadableString.exp (Up.exp e))
@

% ------------------------------------------------------------------ 
\subsection{Continuation Bundles}
% ------------------------------------------------------------------ 

A continuation bundle on the {\AST} level is a record of names.
At the flow-graph level we keep track of nodes and dataflow.
<<statement-related types>>=
type 'i conts = { cuts    : 'i G.contedge list
                ; unwinds : 'i G.contedge list
                ; returns : 'i G.contedge list
                ; aborts  : bool
                }
@ 
We use the remembered labels to associate the correct entry point with
each continuation, depending on how the continuation is used.
<<Make continuation bundles>>=
let continuations cc ast default_aborts =
  let volregs = cc.C.volregs in                 (* volatile registers *)
  let allregs = RS.union volregs cc.C.nvregs in (* all registers *)
  let entry n = G.node_labeled g n in
  let (--)    = RS.diff in
  let as_cut_to k =
    k.K.cut_to <- true;
    let defs = k.K.cut_in.C.regs in
    { G.defs = defs;   G.kills = allregs -- defs; G.node = entry k.K.cut_pc    } in
  let as_unwinds k =
    k.K.unwound_to <- true;
    { G.defs = noregs; G.kills = volregs;         G.node = entry k.K.unwind_pc } in
    (* defs are variables and so can't be a register set.  NEED ANOTHER MECHANISM *)
  let as_returns k =
    k.K.returned_to <- true;
    let defs = k.K.return_in.C.regs in
    { G.defs = defs;   G.kills = volregs -- defs; G.node=entry k.K.return_pc   } in
  let contmap f = List.map (f << continuation) in
  let rec add f cs = match f with (* avoid list reversal! *)
    | A.FlowAt(f,_)  -> add f cs
    | A.CutsTo    ns -> { cs with cuts    = contmap as_cut_to  ns @ cs.cuts    }
    | A.UnwindsTo ns -> { cs with unwinds = contmap as_unwinds ns @ cs.unwinds }
    | A.ReturnsTo ns -> { cs with returns = contmap as_returns ns @ cs.returns }
    | A.Aborts       -> { cs with aborts  = true                               } in
  (*| A.NeverAborts  -> { cs with aborts  = false                              } in*)
  (*| A.NeverReturns -> ??? *)
  let empty = { cuts = []; unwinds = []; returns = [] ; aborts = default_aborts } in
  List.fold_right add ast empty
@

% ------------------------------------------------------------------
\subsection{Actual Parameters, Formal Parameters, and Results}
% ------------------------------------------------------------------ 

For actuals, formals, or results, we need a sequence of hint/width pairs
to feed to the calling convention.
For a formal or result, we need the corresponding location, and for each
actual, the corresponding value.
We do the dirty work with a higher-order function.
Argument [[hint_parm]] splits the abstract syntax into a hint and
a ``parameter''.
Argument [[cvt]] takes a ``parameter'' and produces a converted
parameter (location or expression), plus the width of the parameter.
The later parameter [[conv]] is a calling convention, which we apply
here for convenience.
<<environment-independent support for formals, actuals, and results>>=
let convert_parms hint_parm cvt =
  let add x (hws, parms) =
    let hint, parm = hint_parm x in
    let hint = Aux.Option.get "" hint in
    let parm, w = cvt parm in
    (hint, w) :: hws, parm :: parms in
  fun conv l ->
    let hws, parms = List.fold_right add l ([], []) in
    conv hws parms in
@ 
We instantiate this code four ways.
For an actual parameter, the [[cvt]] parameter is the function [[ew]],
which compiles an AST expression into an RTL expression plus a width.
For a formal parameter or result, we use [[lvalue_name_in_env]].
The environment must be a parameter, since we don't have it at the
time these functions are defined.
<<environment-independent support for formals, actuals, and results>>=
let actuals'  ew  = convert_parms (fun (h, e)       -> h, e) ew                       
and formals'  env = convert_parms (fun (h, _, _, x) -> h, x) (lvalue_name_in_env env) 
and cformals' env = convert_parms (fun (h, x)       -> h, x) (lvalue_name_in_env env) 
and results'  env = 
  let rec hn = function
    | A.LValueAt (lv, _) -> hn lv
    | A.Var(h,x)         -> h, x
    | A.Mem(_, _, _)     -> impossible "mem ref as result" in
  convert_parms hn (lvalue_name_in_env env) 
@ 
At a later point, we can finish instantiating these functions.
<<using [[env]] and [[expr]], build funs for formals, actuals, and results>>=
let actuals  = actuals'  (fun e -> expr e, tywidth (exprtype e))
and formals  = formals'  env
and results  = results'  env
and cformals = cformals' env
@
\begin{quote}\it
    As NR pointed out, hints on global registers have no semantics in 
    {\qcc}. They thus must be ignored when computing parameter
    passing. --CL
    I DON'T UNDERSTAND THIS COMMENT.  PLEASE EXPLAIN.
\end{quote} 
@
    

% ------------------------------------------------------------------ 
\subsection{Global Registers}
% ------------------------------------------------------------------ 

The [[globals]] function pushes all global register variables through 
a target-specific automaton, which  assigns each global 
variable to  a hardware
register or memory location.
Each variable is represented by an [[AT.loc]], which is
added to the variable's denotation in the environment.
The location is also
entered under the name of the register to a map.
 
All compilation units in a program must
declare exactly the same global registers. We compute a cryptographic
hash value for all global-register declarations as a fingerprint. The
fingerprint is a string of 16 characters, which may not be
printable.

Function [[globals]] returns the enriched 
environment, the block of memory that holds overflow global variables,
and a fingerprint of the declarations.
<<definition of [[globals]]>>=
let globals (base:Rtl.exp) names =
    let t = target.T.globals base in
    let decls = Buffer.create 128 in (* initial size - grows as needed *)
    let rec assign env n =
        try 
            ( match F.findv n env with
            | rgn, (F.Register(reg), ty) ->
                let h  = match reg.F.rhint with
                         | F.RReg x -> x     (* h/w register *)
                         | _        -> "" in
                let w     = tywidth ty in
                (* sig is string representation of this declaration *)
                let sign  = Printf.sprintf "[%d <%s>]" w h  in
                let ()    = Buffer.add_string decls sign    in
                let loc   = AT.allocate t w h in
                let entry = ( rgn
                            , (F.Register({reg with F.loc = Some (AT.to_old loc)}),ty)
                            ) in F.rebindv n entry env
            | _ -> impossible ("global register " ^ n ^ " not in environment")
            )
        with Error.ErrorExn msg -> impossible msg
    in
    let env = List.fold_left assign env names in
        env, AT.freeze t, Digest.string (Buffer.contents decls)    
@


% ------------------------------------------------------------------ 
\subsection{Simple Statements}
% ------------------------------------------------------------------ 

The [[bodies]] and [[body]] functions simply thread the translations
of statements.
They maintain a current successor and a current set of (span)
properties.
<<functions that translate statements, including [[bodies]]>>=
let rec bodies props bs succ = List.fold_right (body props) bs succ
and     body   props b  succ = match b with
  | A.BodyAt(x, _)       -> body props x succ
  | A.DeclBody(d)        -> succ (* nothing to be done *)
  | A.StmtBody(s)        -> stmt props s succ
  | A.DataBody(dd)       -> succ (* already done *)
@ 
We do the simple statements inline,
but interprocedural control flow is complicated enough to warrant
out-of-line functions (as will [[switch]]).
<<functions that translate statements, including [[bodies]]>>=
and stmt props s succ =
  <<supporting functions for translating statements>> in
  match s with
  | A.StmtAt(x,r)              -> stmt props x succ
  | A.SpanStmt(key, value, bs) ->
      bodies ((compile_const key, expr value) :: props) bs succ
  | A.AssignStmt (lhs, rhs)    ->
      let effect lhs (guard,rhs) =
        let rtl = atstore (lvalue lhs) (expr rhs) in
        match guard with
        | None   -> rtl
        | Some g -> Rtl.guard (expr g) rtl in
      G.instruction g (Rtl.par (List.map2 effect lhs rhs)) succ
  | A.IfStmt (e, so, not)  ->
      G.cbranch g (expr e) ~ifso:(bodies props so succ) ~ifnot:(bodies props not succ)
  | A.LabelStmt n          -> G.node_labeled g n
  | A.GotoStmt (e, labels) ->
     (match Dn.exp (expr e) with
     | RP.Const (RP.Link (sym, w)) -> G.branch g ~target:(G.node_labeled g (sym#text))
     | e -> let instr   = target.T.goto.T.embed (Up.exp e) in
            let targets = List.map (G.node_labeled g) labels in
            G.mbranch g instr targets)
  | A.ContStmt    x -> contStmt   x succ
  | A.CallStmt    x -> callStmt   x succ
  | A.JumpStmt    x -> jumpStmt   x
  | A.CutStmt     x -> cutStmt    x 
  | A.ReturnStmt  x -> returnStmt x 
  | A.SwitchStmt  x -> Impossible.unimp "switch"
  | A.PrimStmt    x -> Impossible.unimp "primitive"
  | A.EmptyStmt     -> succ
  | A.CommentStmt _ -> succ
@
\subsection{Interprocedural control and data flow}
The outgoing overflow parameters passed by a tail-call go into the
\emph{incoming} area of the current activation.
N.B.~We don't use the [[targets]] list, which is there for future
interprocedural optimization and call-graph analysis.
<<supporting functions for translating statements>>=
let rec jumpStmt (cconv,e,args,targets (*unused*)) = 
    let cc    = to_cc cconv in
    let out   = actuals cc.C.call_actuals args in
    let jumpi = target.T.jump.T.embed (expr e) in
    let ()    = add_oldblock out.C.overflow    in  (* jump overflow = old *)
    G.instruction g out.C.pre_sp                                  **>
    G.instruction g out.C.shuffle                                 **>
    G.instruction g restore_nvrs                                  **>
    G.instruction g (R.store proc_cc.C.ra saved_ra pointersize)   **>
    G.instruction g out.C.post_sp                                 **>
    G.jump        g jumpi ~targets ~uses:(RS.union out.C.regs cc.C.nvregs)
<<auxiliaries>>=
let noregs = Register.Set.empty
@


% \begin{quote}\small
% \begin{verbatim}
% 
%             /   |
%             |   o  r0 = x  
%  copy-out:  |   |                      
%  defs r0,r1 |   o  r1 = y 
%             \   |
%              ------
%             | call | x = f(x,y) call: kills y, ... 
%            ///-----
%           ///   |
%          ///    o               data-flow: uses r0, r1; defs x 
%  continuations  |
%                 o  x = r0       copy-in:   uses r0
%                 |
%                         
% \end{verbatim}
% \end{quote}

<<supporting functions for translating statements>>=
and callStmt (lhs,cconv, e, args, targets (*unused*), conts) succ = 
  let cc    = to_cc cconv                     in
  let out   = actuals cc.C.call_actuals args  in
  let in'   = results cc.C.call_results lhs   in
  let calli = target.T.call.T.embed (expr e)  in
  let conts = continuations cc conts false    in
  let () = add_youngblock out.C.overflow      in  (* outgoing overflow parms *)
  let () = add_youngblock in'.C.overflow      in  (* incoming overflow results *)
  G.instruction g out.C.pre_sp                **>
  G.instruction g out.C.shuffle               **>
  G.instruction g out.C.post_sp               **>
  G.call        g calli ~uses:out.C.regs ~defs:in'.C.regs ~kills:cc.C.volregs
                        ~altrets:conts.returns ~unwinds_to:conts.unwinds
                        ~cuts_to:conts.cuts ~aborts:conts.aborts ~spans:props  **>
  G.assertion   g in'.C.insp              **>
  G.instruction g in'.C.pre_sp            **>  (* DOUBTS ABOUT THIS *)
  G.instruction g in'.C.shuffle           **>
  G.instruction g in'.C.post_sp           **>
  succ
<<auxiliaries>>=
let ( **> ) f x = f ~succ:x
let succfold f = List.fold_right (fun x y -> f x ~succ:y)
@
A procedure returns value in the \emph{incoming} area of its
activation but uses the \emph{copy-out} method.  Don't get confused
and refer to the big picture in \module{stack}. 
<<supporting functions for translating statements>>=
and returnStmt (cconv, kont, args) = 
  (* SHOULD RETURN BEAR A CALLING CONVENTION,
     OR DOES IT GET THE CONVENTION OF THE BODY? *)
    let cc = to_cc cconv                       in
    let out = actuals cc.C.return_actuals args in
      (* WHAT ABOUT cc.C.epilog??  DO WE NEED ALTERNATE CONVENTION
         FOR ALTERNATE RETURN? *)
    let reti =
      match kont with
      | None       ->
          cc.C.return 0 0 saved_ra (* default *)
      | Some (i,n) ->
          let k e = Bits.S.to_int (compile_const e) in
          cc.C.return (k i) (k n) saved_ra in
          (* WHY IS THIS Bits.S AND NOT Bits.U ??? *)
    let () = add_oldblock out.C.overflow in  (* outgoing jump overflow = incoming *)
    G.instruction g out.C.pre_sp            **>
    G.instruction g out.C.shuffle           **>
      (* SHOULD JUMP TO SHARED EPILOG HERE -- RESTORE REGS AND SP *)
    G.instruction g restore_nvrs            **>
    G.instruction g out.C.post_sp           **>
    G.return      g reti ~uses:(RS.union out.C.regs cc.C.nvregs)
@ 
A [[cut to]] instruction passes arguments according to a calling convention.
Each continuation has its own overflow area. The [[copyout]] routine returns
an [[area]] that corresponds to the overflow area. Since this area may
not belong on this stack, we will discard it. Because we discard
the area, late compile-time constants indexed into this area must be replaced
immediately.
We solve the constraints on the area and use the resulting substitution
to replace the late compile-time constants in the rtl's returned from
[[copyout]].

ALSO SHOULD USE [[Contn]]!!


NEED A SYSTEMATIC APPROACH TO ARGS/RESULTS, AS WELL AS TO DATAFLOW NODES.

<<supporting functions for translating statements>>=
and cutStmt (e, args, conts) = 
  (* PERHAPS IT SHOULD BE POSSIBLE TO SET THE CALLING CONVENTION FOR CUT TO
     AND FOR CONTINUATION? *)
  let cc    = ccs default_cc in
  let k     = expr e in
  let out   = actuals (cc.C.cut_to_actuals k) args in
  let cuti  = Contn.cutto target cc.C.cutto.Target2.embed ~contn:k in
  let ()    = add_constraints (Block.constraints out.C.overflow) in
  let conts = continuations cc conts true in
  G.instruction g out.C.shuffle **>
  G.cut_to      g cuti ~cuts_to:conts.cuts ~aborts: conts.aborts ~uses:out.C.regs
@
\subsubsection{Continuations and their entry points}
The continuation code fills in the blanks left during the first pass.
<<supporting functions for translating statements>>=
and contStmt (label,args) succ =
  (continuation label).K.succ <- succ;
  G.illegal g (* should be not reached *)
@ 
The rest of the compilation happens at the end of the procedure.
<<functions that translate statements, including [[bodies]]>>=
and finish_compiling_continuation k =
  begin
    if k.K.cut_to then
      generate_cut_to_entry k
    else if k.K.escapes then
      generate_cut_to_entry k; (* COULD DO LESS?  BIND LABEL SOMEWHERE SENSIBLE? *)
    if k.K.returned_to then
      generate_return_to_entry k;
    if k.K.unwound_to then
      generate_return_to_entry k;
  end

and generate_cut_to_entry k =
  let in' = k.K.cut_in in
  G.set_succ (G.node_labeled g k.K.cut_pc) (
  G.instruction g in'.C.pre_sp   **>
  G.instruction g in'.C.shuffle  **>
  G.instruction g in'.C.post_sp  **>
  k.K.succ)

and generate_return_to_entry k = 
  let cc = ccs default_cc in
  let in' = k.K.return_in in
  let () = add_youngblock in'.C.overflow in
  G.set_succ (G.node_labeled g k.K.return_pc) (
  G.instruction g in'.C.pre_sp    **>
  G.instruction g in'.C.shuffle   **>
  G.instruction g in'.C.post_sp   **>
  k.K.succ)

and generate_unwind_to_entry k = 
  let assign_unspecified_to args = R.par [] in (* BOGUS *)
  G.set_succ (G.node_labeled g k.K.unwind_pc) (
  G.assertion g (assign_unspecified_to formals) **>  (* in lieu of dataflow *)
  k.K.succ)
@

@

% ------------------------------------------------------------------ 
\subsection{Procedure Translation}
% ------------------------------------------------------------------ 

\begin{quote}\it
    Todo: callee saved registers, data-flow-nodes. Do we put a label here
    for the procedure or is this handled on the assembler level? --CL
\end{quote}

For each continuation we have reserved memory on the stack that must be
initialized when the procedure is entered. The following function
provides nodes that do the initialization.
<<definition of [[insert_init_cont_nodes]]>>=
let insert_init_cont_nodes contmap init_node =
  let one_node cname k succ = 
    if k.K.escapes then
      let pc = exp_of_label k.K.cut_pc in
      let sp = Block.base spblock in
      G.instruction g (Contn.init_code k.K.rep sp pc) succ
    else
      succ in
  let next = G.succ init_node in
  G.set_succ init_node (G.illegal g);  (* avoid extra join before next *)
  G.set_succ init_node (Strutil.Map.fold one_node contmap next)
@ 
<<definition of [[proc]], which translates one procedure>>=
let proc containing_spans (cconv,procname,args,procbody) = 
    let proc_cc = to_cc cconv in
    let symbol, scope, vars =
      match F.findv procname env with
      | _,(F.Label(F.Proc (sym,scope,i)),_) -> sym, scope, i
      | _ -> impossible "no environment for procedure" in

    let exp_of_label l = R.link ((F.asm env)#local l) pointersize in
    let exp_to_label e = match Dn.exp e with
    | RP.Const(RP.Link (l, _)) -> l # text
    | _ -> impossible "bad label projection" in
    let guarded_exp_of_label (g,l) =
     (g, (R.link ((F.asm env)#local l) pointersize)) in
    let guarded_exp_to_label (e1,e2) = match (e1, Dn.exp e2) with
    | (g, RP.Const(RP.Link (l, _))) -> (g, l # text)
    | _                           -> impossible "bad label projection" in
    let info = { G.goto = { T.embed = target.T.goto.T.embed << exp_of_label
                          ; T.project = exp_to_label << target.T.goto.T.project }
               ; G.branch = { T.embed = target.T.branch.T.embed
                                 << guarded_exp_of_label
                            ; T.project = guarded_exp_to_label
                                 << target.T.branch.T.project }
               } in
    let g = G.mk info Idgen.label in (* empty control-flow graph *)

    let vfp = target.T.vfp in (* virtual frame pointer *)
    let spblock =
      Block.relative vfp "sp" Block.at ~size:0 ~alignment:proc_cc.C.sp_align in

    (* calculate amount of user stack data - rebinds env! *)
    <<definition of [[stackdata]]>> in
    let env, stackd, contenv =
      let sdmem = Memalloc.relative vfp "stackdata" Memalloc.Up in
      stackdata target (F.push env scope) sdmem procbody in

    (* define all the mutable state here *)
    let youngblocks       = ref [] in
    let oldblocks         = ref [] in
    let add_youngblock b  = (youngblocks := b :: !youngblocks) in
    let add_oldblock   b  = (oldblocks   := b :: !oldblocks  ) in
    let constraints       = ref [] in
    let add_constraints c = (constraints := c :: !constraints) in


    let continuation l =
      try Strutil.Map.find l contenv with _ -> impossible "lost cont" in
    let cont_rvalue cname coffset w =
      (continuation cname).K.escapes <- true;
      add vfp (Rtl.late coffset w) in

    let expr, exprtype, lvalue = exprfuns env contenv cont_rvalue in

    (* compute temps, save_nvrs, restore_nvrs *)
    let temps = Talloc.Multiple.for_spaces target.T.spaces in
    let nvr_info =
      let info ((_, _, w) as r) =
        { reg = R.reg r; tmp = proc_cc.C.saved_nvr temps r; w = w } in
      RS.fold (fun r i -> info r :: i) proc_cc.C.nvregs [] in
    let save_nvrs =
      R.par (List.map (fun i -> R.store i.tmp (R.fetch i.reg i.w) i.w) nvr_info) in
    let restore_nvrs =
      R.par (List.map (fun i -> R.store i.reg (R.fetch i.tmp i.w) i.w) nvr_info) in
    let save_ra, saved_ra =
      let loc = proc_cc.C.saved_ra temps in
      let w   = pointersize in
      R.store loc (R.fetch proc_cc.C.ra w) w, R.fetch loc w in

    <<Make continuation bundles>> in
    <<using [[env]] and [[expr]], build funs for formals, actuals, and results>> in    
    <<functions that translate statements, including [[bodies]]>> in
    <<definition of [[insert_init_cont_nodes]]>> in


    (* translate body of procedure *)

    (* build CFG for body *)                    
    let in' = formals proc_cc.C.prolog args  in
      (* CALLING CONV PROBABLY NEEDS MORE INFO TO GET PROPER POST STACK POINTER *)
    let initcont = G.node_labeled g (Idgen.label "initialize continuations") in
    let labeln node ~succ = (G.set_succ node succ; node) in
    let () = G.set_succ (G.entry g) (
      G.instruction g in'.C.pre_sp    **>
      G.instruction g in'.C.shuffle   **>
      G.instruction g in'.C.post_sp   **>
      G.instruction g save_ra         **>
      G.instruction g save_nvrs       **>
      labeln initcont                 **>
      bodies containing_spans procbody (G.exit g)) in

    let () = insert_init_cont_nodes contenv initcont in
      (* THESE PLACEMENTS ARE WRONG.  THEY DEPEND ON THE DIRECTION OF STACK GROWTH *)
    let incoming = Block.overlap_list pointersize Block.Low  (!oldblocks)  in
    let outgoing = Block.overlap_list pointersize Block.High (!youngblocks) in
    
    let contblocks =
      let addblock name k blocks =
        finish_compiling_continuation k;
        if k.K.escapes then Contn.rep k.K.rep :: blocks else blocks in
      Block.cathl_list pointersize (Strutil.Map.fold addblock contenv []) in

    let i =    
        { Proc.symbol   = symbol
        ; Proc.cc       = proc_cc
        ; Proc.target   = target
        ; Proc.temps    = temps
        ; Proc.cfg      = g
        ; Proc.incoming = incoming   (* incoming   block *)   
        ; Proc.outgoing = outgoing   (* outgoing   block *)   
        ; Proc.stackd   = stackd     (* stack data block *)
        ; Proc.priv     = Block.relative vfp "private" aligned_mem target
        ; Proc.sp       = spblock
        ; Proc.eqns     = List.concat (!constraints)
        ; Proc.conts    = contblocks
        ; Proc.vars     = vars       (* number of variables *)
        ; Proc.varMap   = Proc.VarMap.empty
        } in
    optimizer i (* runs optimizer, freezes, and assembles proc *)
<<auxiliaries>>=
let aligned_mem ~base target = 
  let memsize = target.T.memsize in
  let t = AT.overflow memsize target.T.byteorder base Memalloc.Up 1 in
  let alloc ~width ~alignment ~hint =
    let alignment = width / memsize in
    t.AT.allocate width alignment hint
  in AT.mk { AT.freeze = t.AT.freeze; AT.allocate = alloc }
@
        
\subsection{Continuation hell}


As an example, we expect the following {\PAL} 
\begin{alltt}
p () {
    return k
    continuation k():
}
\end{alltt}
to be translated into the following:
\begin{alltt}
sym@p()
{
    $m[sp + sym@k + 4] = sym@k;
    $m[sp + sym@k]     = sp;
    return sp + sum@k
    sym@k:
}
\end{alltt}


If a continuation escapes, we need a representation.
If it is cut to, returned to, or unwound to, we need to make sure the
relevant label is associated with real flow-graph nodes that do
things.
This happens as a late step in translation.
<<module [[K]], for continution info>>=
module K = struct
  type label = string
  (* COULD THE FOLLOWING TYPE BECOME THE DENOTATION OF A CONTINUATION
     IN THE FAT ENVIRONMENT?? *)
  type 'i t =
    { mutable escapes     : bool        (* properties of how it is used *)
    ; mutable cut_to      : bool
    ; mutable returned_to : bool
    ; mutable unwound_to  : bool
    ;         unwind_pc   : label       (* labels may or may not be used *)
    ;         cut_pc      : label
    ;         return_pc   : label
    ;         rep         : Contn.t     (* representation as C-- value (incl block) *)
    ;         cut_in      : C.answer    (* move vals at cut (uses rep) *)
    ;         return_in   : C.answer    (* move vals at also returns *)
    ; mutable succ        : 'i G.node   (* filled in at translation time *)
    }


  let mk name args rep g ~cut_in ~return_in  =
    { escapes     = false
    ; cut_to      = false
    ; returned_to = false
    ; unwound_to  = false
(*    ; formals     = args *)
    ; unwind_pc   = Idgen.ContEntry.unwind name
    ; cut_pc      = Idgen.ContEntry.cut    name
    ; return_pc   = Idgen.ContEntry.return name
    ; rep         = rep
    ; cut_in      = cut_in
    ; return_in   = return_in
    ; succ        = G.illegal g
    }
end
@



% ------------------------------------------------------------------ 
\subsection{Stack Data Declarations and Continuations}
% ------------------------------------------------------------------ 

Stack data declarations may appear everywhere in a procedure body. We
process them in a single descent into the body. Allocated memory is
tracked with a [[Memalloc.t]] value in the [[mem]] field of a [[state]]
value.
<<types for gathering stack and continuation info>>=
type 'i stackdata_state = 
    { env:    F.env 
    ; mem:    Memalloc.t
    ; conts:  'i K.t Strutil.Map.t
    }
@ 
<<definition of [[stackdata]]>>=
let stackdata (target:tgt) env sd bb =
  <<definitions of stack-data procedures>> in
  let state = 
    { env    = env
    ; mem    = sd
    ; conts  = Strutil.Map.empty
    } in
  let state = bodies state bb in 
  state.env, Memalloc.freeze state.mem, state.conts

<<definitions of stack-data procedures>>=
let rec stackdatum state = function
    | A.DatumAt(x,_) -> stackdatum state x
    | A.Label(l) -> 
        let loc = Memalloc.current state.mem in
            let x = F.findv l env in
            ( match x with
            | (r,(F.Label(F.Stack(None)),t)) ->
                { state with env = 
                    F.rebindv l (r,(F.Label(F.Stack(Some loc)),t)) 
                              env
                }
            | _ -> impossible "duplicate stack labels"
            )
    | A.Align n -> { state with mem = Memalloc.align state.mem n} 
    | A.MemDecl(ty,size,None) ->
        let w = astwidth env ty in
        let s = ( match size with 
                | A.NoSize     -> 1 
                | A.DynSize    -> impossible "dynamic memory size"
                | A.FixSize(e) -> 
                    Bits.U.to_int (compile_const e)
                ) in
        let n = s * w / target.T.memsize in
            { state with mem = Memalloc.allocate state.mem n} 
                
    | _ -> impossible "initialized memory on stack"

and stmt state = function 
    | A.StmtAt(x,r)        -> stmt state x
    | A.SpanStmt(_,_,bs)   -> bodies state bs
    | A.IfStmt      x      -> ifStmt state x
    | A.SwitchStmt  x      -> Impossible.unimp "switch"
    | A.ContStmt(n,args)   ->
        let cc = ccs default_cc in
        let cut_in    = cformals' state.env cc.C.also_cuts_to    args in
        let return_in = cformals' state.env cc.C.also_returns_to args in
        let base = exp_of_label (n^"base for bogosity") in
        let rep  = Contn.with_overflow target base cut_in.C.overflow in
        let k    = K.mk n args rep g ~cut_in ~return_in in
        { state with conts = Strutil.Map.add n k state.conts }
    | _                    -> state

and bodies state = List.fold_left body state
and body   state = function 
    | A.BodyAt(x, _)        -> body state x
    | A.DeclBody(d)         -> state (* nothing to be done *)
    | A.StmtBody(s)         -> stmt state s 
    | A.DataBody(data)      -> List.fold_left stackdatum state data

and ifStmt state (e,ifso,ifnot) =
    let state = bodies state ifso  in
    let state = bodies state ifnot in
    state
@
      
% ------------------------------------------------------------------ 
\subsection{Initialized and uninitialized data}
% ------------------------------------------------------------------ 

A [[datum]] can appear globally inside a section or a section-level
[[span]] and locally inside a procedure as \texttt{stackdata}.  
This code translates global data into assembly actions;
the [[stackdata]] function handles stack data.
<<function [[datum]], for initialized and uninitialized data>>=
let rec datum asm = 
  <<support functions for initialized and uninitialized data>> in
  function
    | A.DatumAt(x,_)        -> datum asm x
    | A.Label(n)            -> let s = match F.findv n env with
                               | _,(F.Label(F.Data(s)),_) -> s 
                               | _ -> impossible "unbound data label" in 
                               asm#label s
    | A.Align(a)            -> asm#align a 
    | A.MemDecl(t,m,init)   -> memdecl asm t m init
@ 
\begin{quote}\it
    The [[Asm]] interface for emitting link-time expressions is
    incompatible with the [[Rtl]]s that represent link-time expressions.
    --CL
\end{quote}
Initialized data is handled by the [[init]] function.
<<support functions for initialized and uninitialized data>>=
let rec initialized_data asm expr = asm#addr (link_const asm expr)

and init asm = function
    | A.InitAt(x,_)   -> init asm x
    | A.InitExprs(es) -> List.iter (initialized_data asm) es
    | A.InitUStr(_)      
    | A.InitStr(_)    -> Impossible.unimp "strings as initialized data"
@
Uninitialized data gets an amount of memory equal to
the size of the base type times the
number of values of this type. 
<<support functions for initialized and uninitialized data>>=
and memdecl asm t size ini = 
  match ini with
  | Some ii -> init asm ii
  | None    -> 
      let count = match size with
        | A.DynSize   -> 1
        | A.NoSize    -> 1
        | A.FixSize e -> Bits.U.to_int (compile_const e) in
      let base_size = astwidth env t / target.T.memsize in
      asm#zeroes (count * base_size)
@

 
% ------------------------------------------------------------------ 
\subsection{Toplevel}
% ------------------------------------------------------------------ 

All global declarations have been processed at this stage and thus can
be ignored.  The only exception are (global) register declarations. 
Global registers can name a hardware register they are placed in.  We
need ia way to record such an assignment.  All other locations for
global registers are determined by an automaton.

A [[span]] on the section level must be pushed to the statement level: 
when we come across a [[span]] we modify the properties [[props]]
accordingly.  The next time we come across a procedure, the properties
including the span will be used.
<<supporting code for toplevel items>>=
let rec sspan props asm (e1,e2,ss) =    
    let key   = compile_const e1 in
    let value = expr          e2 in  (* must be link-time constant *)
    let props = (key, value) :: props in
    List.iter (section props asm) ss 

<<supporting code for toplevel items>>=
and section props asm = function
    | A.SectionAt(x,_) -> section props asm x
    | A.Decl(d)        -> ()
    | A.Datum( d)      -> datum asm d
    | A.Procedure(p)   -> proc  props p
    | A.SSpan ss       -> sspan props asm ss
@            

<<function [[toplevel]], for emitting toplevel items>>=
let rec toplevel asm = 
  <<supporting code for toplevel items>> in
  function
    | A.ToplevelAt(x, _)  -> toplevel asm x
    | A.Section(name, ss) -> begin asm#section name; List.iter (section [] asm) ss end
    | A.TopDecl(d)        -> ()
    | A.TopProcedure(p)   -> begin asm#section "text"; proc [] p end
@


% ------------------------------------------------------------------ 
\subsubsection{Program}
% ------------------------------------------------------------------ 

To translate a program, we emit all its top-level items.                      
THE TREATMENT OF THE GLOBAL-REGISTER AREA IS NOT YET CORRECT.
\begin{itemize}
\item
    The memory block for global registers should go into one compilation
    unit and be imported by all others.  OR PERHAPS IT SHOULD BE
    SUPPLIED AT RUN TIME BY THE FRONT END?
 Currently we just emit it
    because we are far from linking several {\PAL} compilation units.
\item
We don't correctly manage the fingerprint of the global-register
declarations.
\end{itemize}
<<function [[program]], which translates an entire program>>=
let program prog =
  let asm = F.asm env in
  <<supporting functions for fooling with the global-register area>> in
  export_global_register_area ();
  (* asm#section "text";  -- should be unnecessary *)
  List.iter (toplevel asm) prog;
  asm
@
The fingerprint [[digest]] for global register declarations is a
16-character string of unprintable characters. We make it printable by 
applying the {\ocaml} escaping rules. 
<<supporting functions for fooling with the global-register area>>=
let import_global_register area () =
  Impossible.unimp "cross-module linkage for global registers"

and export_global_register_area () =
  let base_sym = F.symbol env "Cmm_private_global_area" in
  let base     = Rtl.link base_sym pointersize in 
  let env
     ,area    
     ,digest   = globals base (F.globals env) in
  let area     = area.AT.overflow in
  let digest   = String.escaped digest in
  let asm      = F.asm env in
  let digest   = asm#export digest in
  begin
    asm#section (target.T.data_section);
    asm#comment "memory for global registers";
    asm#align (Block.alignment area);
    asm#label base_sym;
    asm#label digest;
    asm#addloc (Block.size area)
  end
@ This stuff should probably be imported by digest, not by the conventional
name [[base_sym]].
@
