%cg. -*- mode: Noweb; noweb-code-mode: caml-mode -*-

%-------------------------------------------------------------------
\section{Graph Coloring Register Allocation}
%-------------------------------------------------------------------



<<colorgraph.mli>>=
module GCT : Lua.Lib.USERTYPE
module Make (T1 : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.t')
            (T2 : Lua.Lib.TYPEVIEW with type 'a t = 'a GCT.t and type 'a
combined = 'a T1.combined)
            (T3 : Lua.Lib.TYPEVIEW with type 'a t = Proc.t and type 'a combined =
'a T1.combined)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a T1.combined
@


%-------------------------------------------------------------------
\subsection{Data Structures}
%-------------------------------------------------------------------
Information stored for each node:
\begin{itemize}
\item AdjListMap - a map to the adjacency list of nodes that interfere with
                   each node
\item degreeMap - a map containing the current degree of each node
\item moveListMap - a map from a node to the list of moves it's associated with
\item aliasMap - when a move is coalesced, the "discarded" node must be aliased
              to the one we keep
\item colorMap - map from node to assigned color
\end{itemize}

Every node is always in one and only one of these lists:
\begin{itemize}
\item precolored - machine registers, preassigned a color
        \begin{quote}\it does this apply to us? \end{quote}
\item initial - temporary registers, not yet processed
\item simplifyWorklist - list of low-degree non-move-related nodes
\item freezeWorklist - low-degree move-related nodes
\item spillWorklist - high-degree nodes
\item spilledNodes - potential spills
\item coalescedNodes - nodes that have been coalesced out of the graph
\item coloredNodes - nodes successfully colored
\item selectStack - stack of temps removed from the graph
\end{itemize}

Every move instruction is in one and only one of these lists:
\begin{itemize}
\item coalescedMoves - moves that have been coalesced
\item constrainedMoves - moves whose source and target interfere
\item frozenMoves - move that will no longer be considered for coalescing
\item worklistMoves - moves enabled for possible coalescing
\item activeMoves - moves not yet ready for coalescing
\end{itemize}

<<graph coloring types>>=

module G = Cfg3

module T = Target2


module CompareRegPair = struct
    type t = Register.t * Register.t
    let compare = compare
end
module RegPairSet = Set.Make(CompareRegPair)
module CompareMoves = struct
    type t = G.node
    let compare = compare
end
module MS = Set.Make(CompareMoves)
module P  = Cfgprop
module RM = Register.Map
module RS = Register.Set

module LI       = Live.Make(G)

type move = G.node
type color = Register.t
type colorGraph = { mutable adjSet : RegPairSet.t
                  ; mutable adjListMap : Register.t list RM.t
                  ; mutable degreeMap : int RM.t
                  ; mutable moveListMap : G.node list RM.t
                  ; mutable aliasMap : Register.t RM.t
                  ; mutable colorMap : color RM.t
                  ; mutable precolored : Register.t list
                  ; mutable initial : Register.t list
                  ; mutable spills : Register.t list
                  ; mutable simplifyWorklist : Register.t list
                  ; mutable freezeWorklist : Register.t list
                  ; mutable spillWorklist : Register.t list
                  ; mutable spilledNodes : Register.t list
                  ; mutable coalescedNodes : Register.t list
                  ; mutable coloredNodes : Register.t list
                  ; mutable selectStack : Register.t list
                  ; mutable coalescedMoves : move list
                  ; mutable constrainedMoves : move list
                  ; mutable frozenMoves : move list
                  ; mutable worklistMoves : move list
                  ; mutable activeMoves : move list
                  ; mutable colors : int list
                  ; mutable k : int
                  }
@

<<print CGInfo>>=
let regLists cgInfo =
               [ ("Precolored", cgInfo.precolored)
               ; ("Initial", cgInfo.initial)
               ; ("Spills", cgInfo.spills)
               ; ("SimplifyWorklist", cgInfo.simplifyWorklist)
               ; ("FreezeWorklist", cgInfo.freezeWorklist)
               ; ("SpillWorklist", cgInfo.spillWorklist)
               ; ("SpilledNodes", cgInfo.spilledNodes)
               ; ("CoalescedNodes", cgInfo.coalescedNodes)
               ; ("ColoredNodes", cgInfo.coloredNodes)
               ; ("SelectStack", cgInfo.selectStack)
               ]
let moveLists cgInfo =
                [ ("coalescedMoves", cgInfo.coalescedMoves)
                ; ("ConstrainedMoves", cgInfo.constrainedMoves)
                ; ("FrozenMoves", cgInfo.frozenMoves)
                ; ("WorklistMoves", cgInfo.worklistMoves)
                ; ("ActiveMoves", cgInfo.activeMoves)
                ]

let printReg (s, i, w) = prerr_char '('; prerr_char s;
                         prerr_string ", "; prerr_int i;
                         prerr_string ", "; prerr_int w; prerr_char ')'
let printMove node = printReg (Cheats.source node);
                     prerr_string " -> ";
					 printReg (Cheats.dest node)
let printColorMap cm =
	prerr_string "    ColorMap:\n";
	RM.iter (fun tmp reg -> prerr_string "        ";
							printReg tmp; prerr_string " -> ";
							printReg reg; prerr_newline ()) cm
let print_cgInfo cgInfo =
    let _ = prerr_string "\nCGINFO\n" in
    let printItemList pr (name, itemlist) = match itemlist with
        | [] -> ()
        | itemlist ->
            let indent = "        " in
            prerr_string ("    " ^ name ^ ":\n"); 
            List.iter (fun r -> prerr_string indent; pr r;
                               prerr_newline ()) itemlist in
	let printReglist lst  = printItemList printReg lst in
	let printMovelist lst = printItemList printMove lst in
	let printAdjListMember key lst =
		prerr_string "        "; printReg key; prerr_string ": ";
		List.iter (fun r -> prerr_string ", "; printReg r) lst;
		prerr_newline(); flush stderr in
	let printAdjListMap am =
		let _ = prerr_string "    AdjListMap:\n" in
		RM.iter printAdjListMember am
		
    in
	    printAdjListMap cgInfo.adjListMap;
        List.iter printReglist (regLists cgInfo);
        List.iter printMovelist (moveLists cgInfo);
	    printColorMap cgInfo.colorMap;
		flush stderr

let printCGInfo param _ = match T2'.map.V.project param with
    | CGInfo cg -> print_cgInfo cg; true
@

<<cheats>>=
module Cheats = struct
    let fold_fwd g = Cfg3.scan_fwd g (Cfg3.number (Cfg3.first g))
                                     (Cfg3.number (Cfg3.last g) + 1)
    (*
    let register_count _ = 15
    let possibleColors _ = List.map makeReg [1;2;3;4;5;6;7;8;9;10;11;12;13;14;15]
    *)
    let register_count cg = List.length cg.colors
    let makeReg i = 'r', i, 32
    let possibleColors cg = List.map makeReg cg.colors
        

    let reads_writes rtl loc =
        let reads  sp index width (r,w) = (r || loc = (sp,index,width), w) in
        let writes sp index width (r,w) = (r, w || loc = (sp,index,width)) in
        Rtlutil.ReadWrite.fold reads writes rtl (false,false)

    let gm_insert_lst_before lst node =
        let _ = List.fold_right G.gm_insert_assign_before lst node
        in ()
    let gm_insert_lst_after lst node =
        let _ = List.fold_left G.gm_insert_assign_after node lst
        in ()
    let update proc (spillee, mem) node =
        let target = proc.Proc.target in
        let reads, writes = reads_writes (G.rtl node) spillee in
            if reads || writes then
                    ( let tmp   = Talloc.Multiple.reg_like proc.Proc.temps spillee in
                      let subst = fun x -> if x = spillee then tmp else x in 
                      ( if reads  then 
                            (gm_insert_lst_before 
                                (target.T.reload (T.space target) tmp mem) node)
                      ; if writes then 
                            (gm_insert_lst_after  
                                (target.T.spill  (T.space target) tmp mem) node)
                      ; G.set_rtl node (Rtlutil.Subst.reg subst)
                      )
                    ; Some tmp
                    )
             else None

    let print_cfg cfg =
        prerr_string "CFG\n===\n";
        fold_fwd cfg (fun n () -> prerr_string (Cfg3.print_node n ^
                    "\n")) ();
        prerr_string "END CFG\n===\n";
        flush stderr
    let pCFG _ {Proc.cfg = cfg} = print_cfg cfg; false

    let rewrite ({Proc.cfg = cfg; Proc.priv = a; Proc.target = target}
            as proc) spillees coalescedMoves =
        let spill_slot ((_,_,w):Register.t) =
            Automaton.to_loc (Automaton.ty a w None) in
        let smPairs = List.map (fun s -> (s, spill_slot s)) spillees in 
        (* newTemps is an accumulating param *)
        let updateNode smPairs node newTemps =
            (List.fold_left
                (fun tmps sm -> match update proc sm node with
                                | None -> tmps
                                | Some tmp -> tmp::tmps)
                newTemps smPairs)
        in
            print_cfg cfg;
            List.iter (fun n -> Cfg3.gm_delete_assign n;
                    Cfg3.gm_enumerate cfg;
                    print_cfg cfg) coalescedMoves;
            fold_fwd cfg (updateNode smPairs) []
(*
(* reserve a spill slot using automaton *)


      let mem = spill_slot automaton spillee
*)
(*
    let (newTemps, newGraph) = Cheats.spill cfg cg.spilledNodes in (* set of all new temps added *)
*)

    (* Not really cheats anymore.... *)

    let source node =
        match Rtlutil.RTLType.singleAssignment (G.rtl node) with
        | Some (s, _) -> s
        | _ -> assert false
    let dest node =
        match Rtlutil.RTLType.singleAssignment (G.rtl node) with
        | Some (_, d) -> d
        | _ -> assert false

    (*
     * singleAssignment returns a (Register.t * Register.t) option
     * First get the assignment, then verify that the source and dest are
     * in the same reg. space
     *)
	let is_tmp (s,_,_) target = match (Target2.space target) s with
	  | {Space.classification = Space.Temp _} -> true
	  | _ -> false
    let isMoveInstruction node t =
        match Rtlutil.RTLType.singleAssignment (G.rtl node) with
        | Some ((s1,_,_) as r1, (s2,_,_) as r2)
			when is_tmp r1 t -> s1 = s2
        | _ -> false
end
@

%-------------------------------------------------------------------
\subsection{Coloring Algorithm}
%-------------------------------------------------------------------


from Appel 244:
\begin{quote}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
procedure Main()\\
    LivenessAnalysis()\\
    Build()\\
    MakeWorklist()\\
    [[repeat]]\\
\>      [[if]] simplifyWorklist != \{\} [[then]] Simplify()\\
\>      [[else if]] worklistMoves != \{\} [[then]] Coalesce()\\
\>      [[else if]] freezeWorklist != \{\} [[then]] Freeze()\\
\>      [[else if]] spillWorklist != \{\} [[then]] SelectSpill()\\
    [[until]] simplifyWorklist = \{\} [[and]] worklistMoves = \{\}\\
\>            [[and]] simplifyWorklist = \{\} [[and]] spillWorklist = \{\}\\
    AssignColors()\\
    [[if]] spilledNodes != \{\} [[then]]\\
\>      RewriteProgram(spilledNodes)\\
\>      Main()\\
\end{tabbing}
\end{quote}


<<color graph algorithm>>=
let initInfo = { adjSet = RegPairSet.empty
               ; adjListMap = RM.empty
               ; degreeMap = RM.empty
               ; moveListMap = RM.empty
               ; aliasMap = RM.empty
               ; colorMap = RM.empty
               ; precolored = []
               ; initial = []
               ; spills = []
               ; simplifyWorklist = []
               ; freezeWorklist = []
               ; spillWorklist = []
               ; spilledNodes = []
               ; coalescedNodes = []
               ; coloredNodes = []
               ; selectStack = []
               ; coalescedMoves = []
               ; constrainedMoves = []
               ; frozenMoves = []
               ; worklistMoves = []
               ; activeMoves = []
               ; colors = []
               ; k = 0
               }


let haveSpilledNodes param _ = match T2'.map.V.project param with
    | CGInfo cg -> not (empty cg.spilledNodes)

(*
let haveSpilledNodesStage = { Backplane.name = "haveSpilledNodes"
                            ; Backplane.fn = haveSpilledNodes
                            ; Backplane.paramExpected = Some "cgInfo"
                            ; Backplane.stateCreated = Backplane.list2SSet []
                            ; Backplane.stateDestroyed = Backplane.list2SSet []
                            ; Backplane.stateUsed = Backplane.list2SSet ["cfg"]
                            }
*)
@


%-------------------------------------------------------------------
\subsubsection{LivenessAnalysis}
%-------------------------------------------------------------------

The liveness analysis algorithm is implemented in the [[live]] module.
This algorithm annotates each node in the (\cfg) with a live-in set.

<<livenessAnalysis>>=
(* dummy implementation *)
let liveness _ {Proc.cfg = cfg} =
	prerr_string (Cfgutil.cfg2dot cfg); flush stderr;
	LI.liveness cfg; true

(*
let livenessStage = { Backplane.name = "liveness"
                    ; Backplane.fn = liveness
                    ; Backplane.paramExpected = None
                    ; Backplane.stateCreated = Backplane.list2SSet ["live_in sets"]
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet ["cfg"]
                    }
*)
@

%-------------------------------------------------------------------
\subsubsection{Build}
%-------------------------------------------------------------------

Each node in the CFG corresponds to one machine instruction - this is the
machine invariant.

<<build>>=
let numMapFind key listMap =
    try RM.find key listMap with Not_found -> 0
let listMapFind key listMap =
    try RM.find key listMap with Not_found -> []
let listMapAdd value key listMap =
    RM.add key (value::(listMapFind key listMap)) listMap
let listMapUnion value key listMap =
    RM.add key (value @ (listMapFind key listMap)) listMap


let addEdge u v cg =
    if not ((RegPairSet.mem (u, v) cg.adjSet) || (u = v))
    then
        let _ = cg.adjSet <- List.fold_right RegPairSet.add [(u, v); (v, u)]
                                             cg.adjSet in
        let _ =
            if not (List.mem u cg.precolored)
            then
                cg.adjListMap <- listMapAdd v u cg.adjListMap;
                cg.degreeMap <- RM.add u (numMapFind u cg.degreeMap + 1)
                                        cg.degreeMap in
        let _ =
            if not (List.mem v cg.precolored)
                 then
                    cg.adjListMap <- listMapAdd u v cg.adjListMap;
                     cg.degreeMap <- RM.add v (numMapFind v cg.degreeMap + 1)
                                           cg.degreeMap
            in ()

let resetDegree cg temp =
    cg.degreeMap <-
		RM.add temp (cg.k - (Cheats.register_count cg)) cg.degreeMap

let printCFGLive _ {Proc.cfg = cfg} =
	let printNodeLive node _ =
		let live = (G.property node).P.liveout in
		prerr_string "LIVE "; prerr_int (G.number node); prerr_string ": "; RS.iter printReg live; prerr_newline ();
	    flush stderr in
	Cheats.fold_fwd cfg printNodeLive (); false

let build colors cgInfo {Proc.cfg = cfg; Proc.target = target} =
match ((V.list V.int).V.project colors, T2'.map.V.project cgInfo) with
(colors, CGInfo cg) -> (cg.colors <- colors; cg.k <- List.length colors);
            let addInterference node () =
                let live = (G.property node).P.liveout in
                let defs = G.defs node in
                let uses = G.uses node in
                let live =
                    if Cheats.isMoveInstruction node target
                    then
                        (cg.moveListMap <- RS.fold (listMapAdd node)
                                            (RS.union defs uses) cg.moveListMap;
                        cg.worklistMoves <- node::cg.worklistMoves;
						RS.diff live uses)
					else live in
				let live = RS.union live defs in
                let _ = RS.iter (resetDegree cg) defs in
                let addAllEdges def =
                    RS.iter (fun liveNode -> addEdge liveNode def cg) live
                in
                    RS.iter addAllEdges defs in
            let _ = Cheats.fold_fwd cfg addInterference () in
            let regs = Cheats.fold_fwd cfg
                        (fun node rst ->
						    (Register.Set.union
							    (Register.Set.union (G.defs node)
								                    (G.uses node))
                                rst)) Register.Set.empty in
			let temps, pregs =
				List.partition (fun r -> Cheats.is_tmp r target)
                               (Register.Set.elements regs) in
			let _ = cg.initial <- temps in
			let _ = cg.precolored <- pregs in
                true
let makeBuildStage colors = build colors 
        

(*
let buildStage = {Backplane.name = "build"
                 ; Backplane.fn = build
                 ; Backplane.paramExpected = Some "cgInfo"
                 ; Backplane.stateCreated = Backplane.list2SSet ["interferenceGraph"]
                 ; Backplane.stateDestroyed = Backplane.list2SSet []
                 ; Backplane.stateUsed = Backplane.list2SSet ["cfg"; "live_in sets"]
                 }
*)
@

%-------------------------------------------------------------------
\subsubsection{MakeWorkList}
%-------------------------------------------------------------------

<<makeWorklist>>=
let filterOut el lst =
    List.fold_right (fun x rst -> if x = el then rst else x::rst) lst []

let setFromList lst = List.fold_right RS.add lst RS.empty
let moveSetFromList lst = List.fold_right MS.add lst MS.empty

let adjacent temp cg =
    RS.diff (setFromList (listMapFind temp cg.adjListMap))
            (setFromList (cg.selectStack @ cg.coalescedNodes))

let nodeMoves temp cg =
    MS.inter (moveSetFromList (listMapFind temp cg.moveListMap))
             (moveSetFromList (cg.activeMoves @ cg.worklistMoves))

let moveRelated temp cg =
    not (MS.is_empty (nodeMoves temp cg))

let makeWorklist param _ = 
match T2'.map.V.project param with
    | CGInfo cg ->
        let addToLists = function
            | temp when numMapFind temp cg.degreeMap >= cg.k ->
                cg.spillWorklist <- temp::cg.spillWorklist
            | temp when moveRelated temp cg ->
                cg.freezeWorklist <- temp::cg.freezeWorklist
            | temp ->
                cg.simplifyWorklist <- temp::cg.simplifyWorklist in
        let _ = List.iter addToLists cg.initial in
        let _ = cg.initial <- [] in
            true
             

(*
let makeWorklistStage = { Backplane.name = "makeWorklist"
                        ; Backplane.fn = makeWorklist
                        ; Backplane.paramExpected = Some "cgInfo"
                        ; Backplane.stateCreated = Backplane.list2SSet ["worklists"]
                        ; Backplane.stateDestroyed = Backplane.list2SSet []
                        ; Backplane.stateUsed = Backplane.list2SSet ["interferenceGraph"]
                       }
*)
@

%-------------------------------------------------------------------
\subsubsection{Simplify}
%-------------------------------------------------------------------

<<simplify>>=
let enableMoves temps cg =
    let enableMovesForTemp temp =
        let enableMove move =
            if List.mem move cg.activeMoves
            then cg.activeMoves <- filterOut move cg.activeMoves;
                 cg.worklistMoves <- union move cg.worklistMoves
        in
            MS.iter enableMove (nodeMoves temp cg)
    in
        RS.iter enableMovesForTemp temps

let listAdd el lst = if not (List.mem el lst) then el::lst else lst

let decrementDegree cg target temp =
    let d = RM.find temp cg.degreeMap in
    let _ = cg.degreeMap <- RM.add temp (d - 1) cg.degreeMap in
        if d = cg.k
        then
            enableMoves (RS.add temp (adjacent temp cg)) cg;
            cg.spillWorklist <- filterOut temp cg.spillWorklist;
            if moveRelated temp cg
            then cg.freezeWorklist <- listAdd temp cg.freezeWorklist
            else if Cheats.is_tmp temp target
			     then cg.simplifyWorklist <- listAdd temp cg.simplifyWorklist
				 else ()
        
exception GraphColoring

let simplify param {Proc.target = t} = (*match param with*)
match T2'.map.V.project param with
    | CGInfo cg ->
        (match cg.simplifyWorklist with
        | temp::rst ->
            let _ = cg.simplifyWorklist <- rst in
            let _ = cg.selectStack <- temp::cg.selectStack in
            let _ = RS.iter (decrementDegree cg t) (adjacent temp cg) in
                true
        | _ -> false)



(*
let simplifyStage = { Backplane.name = "simplify"
                    ; Backplane.fn = simplify
                    ; Backplane.paramExpected = Some "cgInfo"
                    ; Backplane.stateCreated = Backplane.list2SSet []
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet []
                    }
*)
@


%-------------------------------------------------------------------
\subsubsection{Coalesce}
%-------------------------------------------------------------------

<<coalesce>>=
let addWorklist temp cg =
    if not ((List.mem temp cg.precolored) || (moveRelated temp cg) ||
            (numMapFind temp cg.degreeMap >= cg.k))
    then
        cg.freezeWorklist <- filterOut temp cg.freezeWorklist;
        cg.simplifyWorklist <- temp::cg.simplifyWorklist

let ok tempt tempr cg =
    (numMapFind tempt cg.degreeMap < cg.k) || (List.mem tempt cg.precolored) ||
    (RegPairSet.mem (tempt, tempr) cg.adjSet)

let conservative nodes cg =
    cg.k > (List.fold_left
           (fun k node -> if numMapFind node cg.degreeMap >= cg.k then k + 1 else k)
            0 nodes)

let rec getAlias node cg =
    if List.mem node cg.coalescedNodes
    then getAlias (RM.find node cg.aliasMap) cg
    else node

let combine target u v cg =
    let _ = if List.mem v cg.freezeWorklist
            then cg.freezeWorklist <- filterOut v cg.freezeWorklist
            else cg.spillWorklist <- filterOut v cg.spillWorklist in
    let _ = cg.coalescedNodes <- union v cg.coalescedNodes in
    let _ = cg.aliasMap <- RM.add v u cg.aliasMap in
    let _ = cg.moveListMap <- listMapUnion (listMapFind v cg.moveListMap)
                                           u cg.moveListMap in
    let _ = enableMoves (RS.add v RS.empty) cg in
    let _ = RS.iter (fun temp -> addEdge temp u cg;
			                     decrementDegree cg target temp)
                      (adjacent v cg) in
        if (numMapFind u cg.degreeMap >= cg.k) && (List.mem u cg.freezeWorklist)
        then
            cg.freezeWorklist <- filterOut u cg.freezeWorklist;
            cg.spillWorklist <- filterOut u cg.spillWorklist


let coalesce param {Proc.target = target} =
match T2'.map.V.project param with
    | CGInfo cg ->
        (match cg.worklistMoves with
        | move::rstMoves ->
            let x = Cheats.source move in
            let y = Cheats.dest move in
            let (u, v) = if List.mem y cg.precolored then (y, x) else (x, y) in
            let _ = cg.worklistMoves <- rstMoves in
            let _ =
                if u = v
                then
                    (cg.coalescedMoves <- union move cg.coalescedMoves;
                     addWorklist u cg)
                else if (List.mem v cg.precolored) || (RegPairSet.mem (u, v) cg.adjSet)
                     then
                        (cg.constrainedMoves <- move::cg.constrainedMoves;
                         addWorklist u cg;
                         addWorklist v cg)
                else if ((List.mem u cg.precolored) &&
                         (RS.fold (fun t rst -> (ok t u cg) && rst)
                                        (adjacent v cg) true)
                        || ((not (List.mem u cg.precolored)) &&
                        (conservative (RS.elements (RS.union (adjacent u cg)
                                                           (adjacent v cg))))
                                          cg))
                     then
                        (cg.coalescedMoves <- union move cg.coalescedMoves;
                         combine target u v cg;
                         addWorklist u cg)
                else
                    cg.activeMoves <- move::cg.activeMoves
            in
                true
        | _ -> false)

(*
let coalesceStage = { Backplane.name = "coalesce"
                    ; Backplane.fn = coalesce
                    ; Backplane.paramExpected = Some "cgInfo"
                    ; Backplane.stateCreated = Backplane.list2SSet []
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet []
                    }

let recklessCoalesceStage = { Backplane.name = "recklessCoalesce"
                            ; Backplane.fn = recklessCoalesce
                            ; Backplane.paramExpected = Some "cgInfo"
                            ; Backplane.stateCreated = Backplane.list2SSet []
                            ; Backplane.stateDestroyed = Backplane.list2SSet []
                            ; Backplane.stateUsed = Backplane.list2SSet []
                            }
*)
@

%-------------------------------------------------------------------
\subsubsection{Freeze}
%-------------------------------------------------------------------

<<freeze>>=
let freezeMoves temp cg =
    let freezeMove move =
        let x = Cheats.source move in
        let y = Cheats.source move in
        let v = if (getAlias y cg) = (getAlias temp cg)
                then getAlias x cg
                else getAlias y cg in
        let _ = cg.activeMoves <- filterOut move cg.activeMoves in
        let _ = cg.frozenMoves <- move::cg.frozenMoves in
            if (MS.is_empty (nodeMoves v cg)) &&
               (numMapFind v cg.degreeMap < cg.k)
            then
                cg.freezeWorklist <- filterOut v cg.freezeWorklist;
                cg.simplifyWorklist <- v::cg.simplifyWorklist 
    in MS.iter freezeMove (nodeMoves temp cg)
        
let freeze param _ =
match T2'.map.V.project param with
    | CGInfo cg -> (match cg.freezeWorklist with
        | temp::rst ->
            (cg.freezeWorklist <- rst;
             cg.simplifyWorklist <- temp::cg.simplifyWorklist;
             freezeMoves temp cg;
             true)
        | _ -> false)
    

(*
let freezeStage = { Backplane.name = "freeze"
                  ; Backplane.fn = freeze
                  ; Backplane.paramExpected = Some "cgInfo"
                  ; Backplane.stateCreated = Backplane.list2SSet []
                  ; Backplane.stateDestroyed = Backplane.list2SSet []
                  ; Backplane.stateUsed = Backplane.list2SSet []
                  }
*)
@


%-------------------------------------------------------------------
\subsubsection{SelectSpill}
%-------------------------------------------------------------------

<<selectSpill>>=
let selectSpill param _ =
match T2'.map.V.project param with
    | CGInfo cg ->
        (match List.fold_right filterOut cg.spills cg.spillWorklist with
         | temp::rst ->
            let _ = cg.spillWorklist <- rst in
            let _ = cg.simplifyWorklist <- temp::cg.simplifyWorklist in
            let _ = freezeMoves temp cg in
                true
         | _ -> false)

let assignColors param {Proc.target = target} =
match T2'.map.V.project param with
    | CGInfo cg ->
		let colorLookup temp cmap =
			if Cheats.is_tmp temp target
			then RM.find (getAlias temp cg) cmap
		    else temp in
        let colorTemp temp =
            let removeUsedColor colors temp =
                if List.mem (getAlias temp cg) (cg.coloredNodes @ cg.precolored)
                then
                    filterOut (colorLookup (getAlias temp cg) cg.colorMap) colors
                else colors in
            let okColors =
                List.fold_left removeUsedColor (Cheats.possibleColors cg)
                               (listMapFind temp cg.adjListMap)
            in
                (match okColors with
                 | [] -> cg.spilledNodes <- temp::cg.spilledNodes
                 | color::rst ->
                    cg.coloredNodes <- union temp cg.coloredNodes;
                    cg.colorMap <- RM.add temp color cg.colorMap) in
        let colorSelectStack () =
            let _ = List.iter colorTemp cg.selectStack in
                cg.selectStack <- [] in
        let colorCoalescedNodes () =
            let setColor temp = 
                cg.colorMap <- RM.add temp (RM.find (getAlias temp cg)
                                            cg.colorMap) cg.colorMap
            in
                List.iter setColor cg.coalescedNodes in
        let _ = colorSelectStack () in
        let _ = colorCoalescedNodes () in
            (* remove short spill temps from the spill list *)
	let _ = cg.spilledNodes <- (List.fold_right filterOut cg.spills
	cg.spilledNodes @ cg.spills)in
	(*
        let _ = match cg.spilledNodes with
            | [] -> ()
            | _ -> cg.spilledNodes <- List.fold_right filterOut cg.spills
                                                      cg.spilledNodes;
print_cgInfo cg;
if empty cg.spilledNodes then raise GraphColoring
in
	*)
            true

exception UncoloredTemp of color
let applyColors param {Proc.cfg = cfg; Proc.mangle = mangle; Proc.target = target} =
    match T2'.map.V.project param with (CGInfo cg) ->
    let subst = function
      | temp when Cheats.is_tmp temp target ->
  		  (try RM.find temp cg.colorMap
                     with Not_found -> print_cgInfo cg;prerr_string "\n";
prerr_string (Register.print temp); prerr_newline(); flush stderr;raise
(UncoloredTemp temp))
	  | t -> t
    in
        ( Cheats.fold_fwd cfg
            (fun node () -> prerr_int (G.number node);
			 prerr_string (": " ^ Rtldebug.rtl_to_string (Cfg3.rtl node) ^ "\n"); flush stderr; G.set_rtl node (Rtlutil.Subst.reg subst)) ()
        ; true)


let resetProgram param proc =
    match T2'.map.V.project param with (CGInfo cg) ->
    (* handle addition of temps (those in spilledNodes) *)
    let newTemps = Cheats.rewrite proc cg.spilledNodes cg.coalescedMoves in (* set of all new temps added *)
    let _ = cg.adjSet <- RegPairSet.empty in
    let _ = cg.adjListMap <- RM.empty in
    let _ = cg.degreeMap <- RM.empty in
    let _ = cg.moveListMap <- RM.empty in
    let _ = cg.aliasMap <- RM.empty in
    let _ = cg.colorMap <- RM.empty in
    let _ = cg.simplifyWorklist <- [] in
    let _ = cg.freezeWorklist <- [] in
    let _ = cg.spillWorklist <- [] in
    let _ = cg.spilledNodes <- [] in
    let _ = cg.initial <- cg.coloredNodes @ cg.coalescedNodes @ newTemps in
    let _ = cg.coloredNodes <- [] in
    let _ = cg.coalescedNodes <- [] in
    let _ = cg.selectStack <- [] in
    let _ = cg.coalescedMoves <- [] in
    let _ = cg.constrainedMoves <- [] in
    let _ = cg.frozenMoves <- [] in
    let _ = cg.worklistMoves <- [] in
    let _ = cg.spills <- cg.spills @ newTemps in
    let _ = cg.activeMoves <- [] in
        true

let updateProgram param proc =
    match T2'.map.V.project param with (CGInfo cg) ->
    (* handle addition of temps (those in spilledNodes) *)
    let newTemps = Cheats.rewrite proc cg.spilledNodes cg.coalescedMoves in (* set of all new temps added *)
        true

(*
let selectSpillStage = { Backplane.name = "selectSpill"
                       ; Backplane.fn = selectSpill
                       ; Backplane.paramExpected = Some "cgInfo"
                       ; Backplane.stateCreated = Backplane.list2SSet []
                       ; Backplane.stateDestroyed = Backplane.list2SSet []
                       ; Backplane.stateUsed = Backplane.list2SSet []
                       }

let assignColorsStage = { Backplane.name = "assignColors"
                        ; Backplane.fn = assignColors
                        ; Backplane.paramExpected = Some "cgInfo"
                        ; Backplane.stateCreated = Backplane.list2SSet []
                        ; Backplane.stateDestroyed = Backplane.list2SSet []
                        ; Backplane.stateUsed = Backplane.list2SSet ["interferenceGraph"]
                        }

let rewriteProgramStage = { Backplane.name = "rewriteProgram"
                          ; Backplane.fn = rewriteProgram
                          ; Backplane.paramExpected = Some "cgInfo"
                          ; Backplane.stateCreated = Backplane.list2SSet []
                          ; Backplane.stateDestroyed = Backplane.list2SSet []
                          ; Backplane.stateUsed = Backplane.list2SSet []
                          }
*)
@


<<colorgraph.ml>>=
    exception IllegalParam of string
    let empty lst = match lst with
        | [] -> true
        | _ -> false
    let union move lst = if List.mem move lst then lst else move::lst


    <<graph coloring types>>

    type 'a t' = CGInfo of colorGraph
module GCT : Lua.Lib.USERTYPE with type 'a t = 'a t' = struct
    type 'a t = 'a t'
    let tname = "Graph Coloring"
    let eq _ x y = match x, y with
    | CGInfo x, CGInfo y -> x = y
    let to_string vs = function
    | CGInfo g -> "<cgInfo>"
end
module Make (T1 : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.t')
            (T2 : Lua.Lib.TYPEVIEW with type 'a t = 'a GCT.t and type 'a
combined = 'a T1.combined)
            (T3 : Lua.Lib.TYPEVIEW with type 'a t = Proc.t and type 'a combined =
'a T1.combined)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a T1.combined =
  struct
    type 'a combined = 'a T1.combined
    module M (Interp : Lua.Lib.CORE with type 'a V.userdata' = 'a T1.combined) = struct
        module V = Interp.V
        <<cheats>>
        module T1' = struct
            let map = T1.makemap V.userdata V.projection
        end
        module T2' = struct
            let map = T2.makemap V.userdata V.projection
        end
        module T3' = struct
            let map = T3.makemap V.userdata V.projection
        end

        <<graph coloring builtins>>

        let init g =
          Interp.register_globals graph_coloring_globals    g;
          Interp.register_module "CG" graph_coloring_module g
    end
  end
@



<<graph coloring builtins>>=
let {V.embed = embed; V.project = project} = T2.makemap V.userdata V.projection

    <<print CGInfo>>
    <<livenessAnalysis>>
    <<build>>
    <<makeWorklist>>
    <<simplify>>
    <<coalesce>>
    <<freeze>>
    <<selectSpill>>
    <<color graph algorithm>>



let proc = T3'.map
let ( **-> ) = V.( **-> )
let stageFnType = V.value **-> proc **-> V.result V.bool
let stageFn = (V.pfunc stageFnType).V.embed
let param2StageFn =
        (V.pfunc (V.value **->
                V.result (V.pfunc stageFnType))).V.embed

let graph_coloring_module =
        [ "liveness",         stageFn liveness
        ; "makeBuild",        param2StageFn makeBuildStage
        ; "makeWorklist",     stageFn makeWorklist
        ; "simplify",         stageFn simplify
        ; "coalesce",         stageFn coalesce
        ; "freeze",           stageFn freeze
        ; "selectSpill",      stageFn selectSpill
        ; "assignColors",     stageFn assignColors
        ; "haveSpilledNodes", stageFn haveSpilledNodes
        ; "resetProgram",   stageFn resetProgram
        ; "updateProgram",   stageFn updateProgram
        ; "applyColors",      stageFn applyColors
        ; "printCG",          stageFn printCGInfo
        ; "printCFGLive",     stageFn printCFGLive
        ; "pCFG",             stageFn Cheats.pCFG
        ]

let graph_coloring_globals =
        [ "initInfo", T2'.map.V.embed (CGInfo initInfo)
(*
        ; "dgraph", T3'.map.V.embed dgraph
*)
        ]
@









