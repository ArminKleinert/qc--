%cg. -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
%-------------------------------------------------------------------
\section{Graph Coloring Register Allocation}
%-------------------------------------------------------------------

Register allocation is responsible for replacing temporary registers (temps)
in the control-flow graph (\cfg) with hardware registers. Liveness analysis
is performed prior to register allocation, annotating each node of the 
\cfg \ with the list of registers (temps and pre-assigned hardware registers)
that are alive at the node. Using this information, we construct an
interference graph with nodes for each of the temporaries and edges between
temporaries that are live at the same time.

Temporaries that interfere must be placed in different registers. This
requirement reduces directly to the graph coloring goal of assigning
different colors to nodes that share graph edges. Register allocation
is carried out by performing graph coloring on the interference graph,
with the hardware registers serving as the colors. If the graph cannot
be colored, we spill the uncolorable temps to memory and attempt to color
the new graph.

% ------------------------------------------------------------------ 
\subsection{Overview}
% ------------------------------------------------------------------ 

We implement Lal George and Andrew Appel's iterated register coalescing
algorithm. Before the graph coloring begins, liveness analysis is performed,
and the interference graph is built. The interference graph is redundantly
represented by an adjacency set and by adjacency lists. The adjacency set
maintains a set of all the edges in the graph. The adjacency lists are
stored in a hash table, with each node mapped to the list of its neighbors.
The purpose of the redundancy is to optimize both the process of testing
whether two nodes are adjacent and of finding all neighbors of a node.

In addition to building the graph, we also initialize the degree of each
temp in the graph. The degree of a temp is the number of registers (both temps
and hardware registers) with which the temp interferes.

Before the actual graph coloring process begins, temps are separated into
worklists, based on their degree and whether they are involved in a move
instruction (move-related).

The basis of the graph coloring algorithm is the observation that low-degree
temps (temps that have fewer than K neighbors, where K is the number of colors)
can be colored easily, so they can be removed from the graph. If the rest of
the graph is colorable, then the graph will remain colorable when we restore
the temps we removed. As we remove these temps, we place them on the
[[selectStack]], which provides the order we will assign colors.

If there are no low-degree, non-move-related temps remaining in the graph,
we attempt to coalesce. We can coalesce two temps into a single temp by
removing move instructions involving two temps that do not interfere, and
using one of the temps in place of the other. By using conservative heuristics,
we can ensure that the graph will not be rendered uncolorable by the
coalescences. Two heuristics have been developed for conservative coalescing:
the Briggs heuristic and the George heuristic.

If there are no low-degree, non-move-related temps in the graph, we freeze
one of the move-related temps. Freezing a temp means that we will no longer
attempt to coalesce moves in which the temp is involved; this also frees the
temp for removal from the graph, since it becomes a low-degree,
non-move-related temp.

The graph may be uncolorable if only high-degree temps remain; however,
instead of assuming that we must spill a node, we choose a high-degree node,
remove it from the graph, and place it on the [[selectStack]].

This process of removing temps from the graph is summarized by the following
options. The first applicable choice is always selected, and the decision
is repeated until the graph is empty:
\begin{enumerate}
\item Attempt to remove non-move-related, low-degree temps from the graph and
      place them on the [[selectStack]].
\item If there are no low-degree temps, then attempt to coalesce move-related
      temps.
\item If there is a move-related temp of low-degree, then we [[freeze]] the
      moves in which this temp is involved (meaning we will no longer try to
      coalesce them), allowing this temp and possibly others to be placed on the
      [[selectStack]].
\item Otherwise, a significant-degree temp will be chosen as a potential spill
      candidate and placed on the [[selectStack]].
\end{enumerate}

After all the temps have been placed on the [[selectStack]], they must be
assigned colors. If a temp cannot be assigned a color (its neighbors are
using all the available colors), then it must be spilled to memory.
[[rewriteProgram]] is called to add spill temps, fetch instructions, and
store instructions to the \cfg. Graph coloring must start over from the
point of liveness analysis if any temps are spilled. If all the temps can
be assigned colors without requiring any spilling, then the temps are replaced
by the assigned registers in the \cfg, and register allocation is complete.

Additionally, register allocation must handle temporaries in different
register spaces and constructs of irregular architectures, including register
pairs. With multiple register spaces, we want to restrict each temp to the
set of hardware registers in which it will fit. This is equivalent to adding
interference edges between each temp and the hardware registers in which it
cannot be placed. However, we can avoid the trouble of adding these
edges by simply updating the degree of the node to indicate that it
interferes with physical registers in other register spaces.

Traditionally, register pairs have been handled by adding extra edges in the
interference graph, but this is not yet implemented in this allocator.
Additionally, Smith and Holloway suggest that this provides an inaccurate
representation - more thought must be committed here.



from Appel 244:
\begin{quote}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
procedure Main()\\
    LivenessAnalysis()\\
    Build()\\
    MakeWorklist()\\
    [[repeat]]\\
\>      [[if]] simplifyWorklist != \{\} [[then]] Simplify()\\
\>      [[else if]] worklistMoves != \{\} [[then]] Coalesce()\\
\>      [[else if]] freezeWorklist != \{\} [[then]] Freeze()\\
\>      [[else if]] spillWorklist != \{\} [[then]] SelectSpill()\\
    [[until]] simplifyWorklist = \{\} [[and]] worklistMoves = \{\}\\
\>            [[and]] simplifyWorklist = \{\} [[and]] spillWorklist = \{\}\\
    AssignColors()\\
    [[if]] spilledTemps != \{\} [[then]]\\
\>      RewriteProgram(spilledTemps)\\
\>      Main()\\
\end{tabbing}
\end{quote}



%-------------------------------------------------------------------
\subsection{Data Structures}
%-------------------------------------------------------------------

<<graph coloring types>>=
module G        = Cfg4
module T        = Target2
module P        = Cfgprop
module RM       = Register.Map
module RS       = Register.Set
module LI       = Live.Make(G)
@

<<graph coloring types>>=
module CompareSpace = struct
	type t = Rtl.space
	let compare = compare
end
module SpaceMap = Map.Make(CompareSpace)

module CompareEdge = struct
    type t = Register.t * Register.t
    let compare = compare
end
module EdgeSet = Set.Make(CompareEdge)

type move = G.node
module CompareMoves = struct
    type t = move
    let compare = compare
end
module MS = Set.Make(CompareMoves)

let fold_fwd = Cfgutil.fold_fwd
let is_tmp target (s,_,_) = Target2.is_tmp target s 
@

Temps and moves are stored in worklists. A temp can only be in one of these
worklists at a time.
We use imperative lists to improve the efficiency of removing items.

Worklists are gathered in related groups called [[impListGroup]];
a list item can only be on one of these lists at a time.
Each [[impListGroup]] is polymorphic over the type of the item it carries
and a [[list]] type.
Each item has a [[list]] value that indicates which list (of the list group)
to which the item belongs.
The [[impListGroup]] is represented as a function from the [[list]] type to
an imperative list.
It is a dynamic invariant that each member will have the same [[list]] type as
every other member of its imperative list.

<<imperative lists>>=
type ('a,'b) impListItem = { v : 'b
						   ; mutable list : 'a
						   ; mutable next : ('a,'b) impListItem option
						   ; mutable prev : ('a,'b) impListItem option
						   }

type ('a,'b) impListGroup = 'a -> ('a,'b) impListItem option ref
@

[[ilg_add]] makes a new item and adds it to the front of the given [[list]]. 
The new list item is returned.
[[ilg_switch]] removes a list item from its current list and placed it on
a new list.
[[ilg_iter]], [[ilg_map]], and [[ilg_filter]] act like their functional counterparts.

<<imperative lists>>=
let ilg_add group list value =
	let item = { v = value
		       ; list = list
			   ; next = !(group list)
			   ; prev = None
	           } in
	let () = match item.next with
			 | Some n -> n.prev <- Some item
			 | None   -> () in
	let () = group list := Some item in
	item

let ilg_switch group list item =
	begin
		  (match item.prev with
		  | Some p -> p.next <- item.next
		  | None   -> group item.list := item.next)
        ; (match item.next with
		  | Some n -> n.prev <- item.prev
		  | None   -> ())
		; item.list <- list
		; item.prev <- None
		; item.next <- !(group list)
		; group list := Some item
        ; (match item.next with
		  | Some n -> n.prev <- Some item
		  | None   -> ())
	end

let rec ilg_iter fn lst =
	match lst with
	| Some n ->
		let next = n.next in	
		let () = fn n     in
		ilg_iter fn next
	| None   -> ()

let rec ilg_map fn lst =
	match lst with
	| Some n -> fn n :: ilg_map fn n.next
	| None   -> []

let rec ilg_filter fn lst =
	match lst with
	| Some n when fn n -> n :: ilg_filter fn n.next
	| Some n -> ilg_filter fn n.next
	| None   -> []
@

For graph coloring, we need two list groups: one for temps and one for move instructions.

<<imperative lists>>=
type tempList = Precolored
			  | Initial
			  | SimplifyWorklist
			  | FreezeWorklist
			  | SpillWorklist
			  | Spilled
			  | Coalesced
			  | Colored
			  | SelectStack

type moveList = CoalescedMove
			  | ConstrainedMove
			  | FrozenMove
			  | WorklistMove
			  | ActiveMove
@


The [[colorGraph]] record type represents the interference graph and maintains
the current state of the graph coloring.

\begin{itemize}
\item [[adjSet]]      - a set of all edges in the interference graph, where an edge
                        is represented by a pair of registers
\item [[adjListMap]]  - a map from a temp [[t]] to the list of temps that
                        interfere with [[t]]
\item [[degreeMap]]   - a map containing the current degree of each temp
\item [[moveListMap]] - a map from a temp to the list of move instructions it is
                        involved in
\item [[aliasMap]]    - when a move is coalesced, the coalesced temp must be
                        aliased to the temp we maintain in the graph
\item [[colorMap]]    - map from temp to assigned color
\end{itemize}

Every temp is a member of exactly one of these lists:
\begin{itemize}
\item [[precolored]] - preassigned machine registers
\item [[initial]] - temps, not yet preprocessed for graph coloring
\item [[simplifyWorklist]] - low-degree non-move-related temps
\item [[freezeWorklist]] - low-degree move-related temps
\item [[spillWorklist]] - high-degree temps
\item [[spilledTemps]] - potential spills
\item [[coalescedTemps]] - temps that have been coalesced out of the graph
\item [[coloredTemps]] - temps successfully colored
\item [[selectStack]] - stack of temps removed from the graph
\end{itemize}
These lists are collected in the [[tempLG]] list group.

Every move instruction is in one and only one of these lists:
\begin{itemize}
\item [[coalescedMoves]] - moves that have been coalesced
\item [[constrainedMoves]] - moves whose source and target interfere
\item [[frozenMoves]] - move that will no longer be considered for coalescing
\item [[worklistMoves]] - moves enabled for possible coalescing
\item [[activeMoves]] - moves not yet ready for coalescing
\end{itemize}
These lists are collected in the [[moveLG]] list-group.

Additional information is also stored:
\begin{itemize}
\item [[regToItem]] - map from temps to list-group items
\item [[spills]]    - short-living temps introduced for spilling (spill temps)
\item [[allColors]] - list of all registers
\item [[colors]]    - map from register spaces to a list of available registers
\item [[k]]         - the number of physical registers
\end{itemize}

<<graph coloring types>>=
type color = Register.t
type colorGraph = { mutable adjSet : EdgeSet.t
                  ; mutable adjListMap : (tempList,Register.t) impListItem list RM.t
                  ; mutable degreeMap : int RM.t
                  ; mutable moveListMap : (moveList,G.node) impListItem list RM.t
                  ; mutable aliasMap : Register.t RM.t
                  ; mutable colorMap : color RM.t

                  ; mutable regToItem : (tempList,Register.t) impListItem RM.t
				  ; mutable tempLG : (tempList, Register.t) impListGroup

				  ; mutable moveLG : (moveList, move) impListGroup

                  ; mutable spills : Register.Set.t
                  ; mutable allColors : color list
                  ; mutable colors : RS.t SpaceMap.t
                  ; mutable k : int
                  }
@

[[makeInitInfo]] constructs an empty [[colorGraph]] record, initialized with
the set of valid colors.

<<init cgInfo>>=
let cgInfo = 
	let pre = ref None in
	let init = ref None in
	let simp = ref None in
	let freez = ref None in
	let spillw = ref None in
	let spilld = ref None in
	let coal = ref None in
	let colo = ref None in
	let sel = ref None in
	let tempFn = function
		| Precolored -> pre
		| Initial -> init
		| SimplifyWorklist -> simp
		| FreezeWorklist -> freez
		| SpillWorklist -> spillw
		| Spilled -> spilld
		| Coalesced -> coal
		| Colored -> colo
		| SelectStack -> sel      in
    let coalm = ref None in
    let constm = ref None in
    let frzm = ref None in
    let workm = ref None in
    let actvm = ref None in
	let moveFn = function
		| CoalescedMove   -> coalm
		| ConstrainedMove -> constm
		| FrozenMove      -> frzm
		| WorklistMove    -> workm
		| ActiveMove      -> actvm in
	   { adjSet = EdgeSet.empty
	   ; regToItem = RM.empty
	   ; adjListMap = RM.empty
	   ; degreeMap = RM.empty
	   ; moveListMap = RM.empty
	   ; aliasMap = RM.empty
	   ; colorMap = RM.empty
	   ; tempLG = tempFn
	   ; spills = RS.empty
	   ; moveLG = moveFn
	   ; colors = SpaceMap.empty
	   ; allColors = []
	   ; k = 0
	   }

let clearCGInfo cg {Proc.cc = colors} = 
	let pre = ref None in
	let init = ref None in
	let simp = ref None in
	let freez = ref None in
	let spillw = ref None in
	let spilld = ref None in
	let coal = ref None in
	let colo = ref None in
	let sel = ref None in
	let tempFn = function
		| Precolored -> pre
		| Initial -> init
		| SimplifyWorklist -> simp
		| FreezeWorklist -> freez
		| SpillWorklist -> spillw
		| Spilled -> spilld
		| Coalesced -> coal
		| Colored -> colo
		| SelectStack -> sel      in
    let coalm = ref None in
    let constm = ref None in
    let frzm = ref None in
    let workm = ref None in
    let actvm = ref None in
	let moveFn = function
		| CoalescedMove   -> coalm
		| ConstrainedMove -> constm
		| FrozenMove      -> frzm
		| WorklistMove    -> workm
		| ActiveMove      -> actvm in
	let () = cg.adjSet <- EdgeSet.empty in
	let () = cg.regToItem <- RM.empty in
	let () = cg.adjListMap <- RM.empty in
	let () = cg.degreeMap <- RM.empty in
	let () = cg.moveListMap <- RM.empty in
	let () = cg.aliasMap <- RM.empty in
	let () = cg.colorMap <- RM.empty in
	let () = cg.tempLG <- tempFn in
	let () = cg.spills <- RS.empty in
	let () = cg.moveLG <- moveFn in
	let () = cg.allColors <- colors.Target2.allocatable in
	let () = cg.k <- List.length colors.Target2.allocatable in
	false
@

We include two observers for the [[colorGraph]] type. [[possibleColors]]
returns a list of the registers in which the argument temp could be placed.
This list is cached for future lookup.
[[regs_in_space]] returns the number of possible registers in which the
argument temp could be placed.

<<graph coloring types>>=
let possibleColors target cg ((s,_,_) as tmp) =
	try SpaceMap.find s cg.colors
	with Not_found ->
		if is_tmp target tmp 
		then
			let colSet = List.fold_left (fun set reg -> if Target2.fits target s reg
							                            then RS.add reg set else set)
			                            RS.empty cg.allColors in
			let () = cg.colors <- SpaceMap.add s colSet cg.colors in
			colSet
		else RS.singleton tmp
 
let regs_in_space target cg temp =
	if is_tmp target temp
	then RS.cardinal (possibleColors target cg temp)
	else cg.k
@


%-------------------------------------------------------------------
\subsection{Graph Coloring Stages}
%-------------------------------------------------------------------

%-------------------------------------------------------------------
\subsubsection{Liveness Analysis}
%-------------------------------------------------------------------

The liveness analysis algorithm is implemented in the [[live]] module.
This algorithm annotates each node in the (\cfg) with a [[live_out]] set
containing the temps that are alive after the node.

<<livenessAnalysis>>=
let liveness _ {Proc.cfg = cfg} =
    LI.liveness cfg; true
@

%-------------------------------------------------------------------
\subsubsection{Build}
%-------------------------------------------------------------------

Using the liveness information, we can build the interference graph by
scanning the \cfg  and recording temps that interfere.
The build stage requires that liveness analysis has been performed on the
\cfg  and the cgInfo data structure has been initialized.

When we reset the degree of a temp, it should not necessarily be reset to 0
because the temp must interfere with registers in other register spaces.
Instead, we set degree[t] = K - R, where K is the total number of registers and
R is the number of registers in temp t's register space.

<<build>>=
let resetDegree target cg temp =
    cg.degreeMap <-
        RM.add temp (cg.k - (regs_in_space target cg temp)) cg.degreeMap
@

We don't add edges to the interference graph if they already exist or if
they do not actually interfere (e.g. they are in non-intersecting register
spaces). Also, we don't need to keep track of the neighbors of precolored temps.

<<build>>=
let addEdge target cg u v =
    if (not ((EdgeSet.mem (u, v) cg.adjSet) || (u = v))) &&
       Cheats.interfere u v target cg
    then
        let () = cg.adjSet <- List.fold_right EdgeSet.add [(u, v); (v, u)]
                                             cg.adjSet in
        let addToList a b =
            if is_tmp target a (*a <> Precolored*)
            then begin
                cg.adjListMap <- listMapAdd (RM.find b cg.regToItem) a cg.adjListMap;
                cg.degreeMap <- RM.add a (RM.find a cg.degreeMap + 1)
                                        cg.degreeMap
			end in
		let () = addToList u v in
		let () = addToList v u in
        ()
@

Before building the interference graph, we must reset the degree of every
temp in the \cfg. Also, we reset the [[initial]] and [[precolored]] sets of
the [[cg]] record.
Then, we build the interference graph by folding over every node of the \cfg,
adding interferences as necessary.

<<build>>=
let build cg {Proc.cfg = cfg; Proc.target = target} =
	let () = assert (!(cg.tempLG Initial) = None) in
    let regs = fold_fwd cfg
                (fun node rst ->
                    (Register.Set.union
                        (Register.Set.union (G.defs node) (G.uses node)) rst))
                Register.Set.empty in
    let regMap =
		RS.fold (fun r map -> resetDegree target cg r
			                ; if is_tmp target r
						      then RM.add r (ilg_add cg.tempLG Initial r) map
							  else RM.add r (ilg_add cg.tempLG Precolored r) map)
				regs cg.regToItem in
	let () = cg.regToItem <- regMap in
    <<addInterference>>
    let () = fold_fwd cfg addInterference () in
        true
@

We add an edge between the temps defined in an instruction and those that
are live after this instruction [[node]]. Note that the defined temps must
interfere with each other. If [[node]] is a move instruction of the form
$t_1 = t_2$, then $t_2$ will not be live after this instruction;
furthermore, we track this instruction and the temps involved for possible
coalescing.

TEST CASE: try a swap instruction (defs must interfere with each other).

<<addInterference>>=
    let addInterference node () =
        let live = (G.property node).P.liveout in
        let defs = G.defs node in
        let live =
            if isMoveInstruction node target
            then
                let uses = G.uses node in
                (let item = ilg_add cg.moveLG WorklistMove node in
					 cg.moveListMap <- RS.fold (listMapAdd item)
										(RS.union defs uses) cg.moveListMap;
                 RS.diff live uses)
            else live in
        let live = RS.union live defs in
        let addAllEdges def =
            RS.iter (fun liveNode -> addEdge target cg liveNode def) live
        in
            RS.iter addAllEdges defs in
@

%-------------------------------------------------------------------
\subsubsection{MakeWorkList}
%-------------------------------------------------------------------

Before beginning the graph coloring algorithm, the temps must be separated
into worklists:
\begin{itemize}
\item Temps with high degree are placed on the [[spillWorklist]]
\item Move-related temps are placed on the [[freezeWorklist]]
\item Low-degree, non-move-related temps are placed on the [[simplifyWorklist]]
\end{itemize}

<<makeWorklist>>=
<<temp observers>>

let makeWorklist cg _ = 
	let addToLists = function
		| temp when numMapFind temp.v cg.degreeMap >= cg.k ->
			ilg_switch cg.tempLG SpillWorklist temp
		| temp when moveRelated temp cg ->
			ilg_switch cg.tempLG FreezeWorklist temp
		| temp ->

			ilg_switch cg.tempLG SimplifyWorklist temp in
	let () = ilg_iter addToLists (!(cg.tempLG Initial)) in
		true
@

It is useful to have observers that take a [[temp]] as an argument and
return other temps with which [[temp]] interferes, moves in which [[temp]] is
involved, or whether [[temp]] is move-related.

<<temp observers>>=
let adjacent temp cg =
	List.filter (fun t -> t.list <> SelectStack && t.list <> Coalesced)
                (listMapFind temp cg.adjListMap)

let nodeMoves temp cg =
	List.filter (fun t -> t.list = ActiveMove || t.list = WorklistMove)
                (listMapFind temp.v cg.moveListMap)

let moveRelated temp cg =
    not (empty (nodeMoves temp cg))
@

%-------------------------------------------------------------------
\subsubsection{Simplify}
%-------------------------------------------------------------------

The [[simplify]] stage of graph coloring removes the easy-to-color temps in 
the [[simplifyWorklist]] from the interference graph. As temps are removed from
the graph, the degrees of adjacent temps will decrease, possibly changing
high-degree temps into easily colored low-degree temps and allowing
previously constrained moves to be coalesced.

<<simplify>>=
<<remove temp>>

let simplify cg {Proc.target = t} =
(*
let () = prerr_string "simplify()\n" in
let () = flush stderr in
*)
        (match !(cg.tempLG SimplifyWorklist) with
        | Some temp ->
			let () = ilg_switch cg.tempLG SelectStack temp in
            let () = List.iter (decrementDegree cg t) (adjacent temp.v cg) in
                true
        | None -> false)
@

For each of the [[temps]], [[enableMoves]] will allow previously uncoalescable
moves to be reconsidered in the next coalescing phase.

<<remove temp>>=
let enableMoves temps cg =
    let enableMove move =
        if move.list = ActiveMove
        then ilg_switch cg.moveLG WorklistMove move
    in
        List.iter (fun temp -> List.iter enableMove (nodeMoves temp cg)) temps
@

When the degree of a temp is decremented, we also check whether the temp is
now of low-degree. If so, we enable moves in which this temp is involved, and
we place the temp on the appropriate worklist.

\begin{quote} \it
I'm not sure about whether we ever need to go through the process of
decrementing the degree of a hardware register - the decrement of the degree
should do nothing, butwill this ever do anything useful with regards to move
instructions? Something to figure out...

-JD
\end{quote}

<<remove temp>>=
let decrementDegree cg target temp =
    let d = RM.find temp.v cg.degreeMap in
    let _ = cg.degreeMap <- RM.add temp.v (d - 1) cg.degreeMap in
        if d = cg.k
        then begin
            enableMoves (temp::(adjacent temp.v cg)) cg;
            if moveRelated temp cg
			then ilg_switch cg.tempLG FreezeWorklist temp
			else ilg_switch cg.tempLG SimplifyWorklist temp
		end
@

%-------------------------------------------------------------------
\subsubsection{Coalesce}
%-------------------------------------------------------------------

When two temps are connected by a move instruction, it is often possible to
coalesce them into a single temp and eliminate the move instruction. It may
not be possible to do this if the two temps interfere or if coalescing the
temps will yield a graph that can no longer be colored using K colors.
We use the Appel and George coalescing heuristic when attempting to coalesce
a pre-colored node with a non-precolored temp, and we use the Briggs coalescing
test for two non-precolored temps.

There are four possible cases for moves on the [[worklistMoves]] list:
\begin{itemize}
\item The source and destination of the move are the same temp
\item The source and destination of the move are both precolored, or they
      interfere; we will never be able to coalesce this move
\item The move may be safely coalesced
\item It is not yet safe to coalesce this move
\end{itemize}

<<coalesce>>=
let rec nodup cmp = function
    | x::(y::_ as tail) -> if cmp x y = 0
	                       then nodup cmp tail
						   else x :: nodup cmp tail
    | x                 -> x

let uniq nodes = nodup compare (List.sort compare nodes)

<<coalesce move>>

let coalesce cg ({Proc.target = target} as proc) =
(*
let () = prerr_string "coalesce()\n" in
let () = flush stderr in
*)
    (match !(cg.moveLG WorklistMove) with
    | Some move ->
        let x = RM.find (source move.v) cg.regToItem in
        let y = RM.find (dest move.v) cg.regToItem in
        let (u, v) = if y.list = Precolored then (y, x) else (x, y) in
		(*
        let _ = cg.worklistMoves <- rstMoves in
		*)
        let () =
            if u = v
            then
                (
	let nodes = fold_fwd proc.Proc.cfg ( fun x rst -> x::rst ) [] in
ilg_iter (fun n -> if not (List.mem n.v nodes) then assert false) (!(cg.moveLG CoalescedMove));
				 ilg_switch cg.moveLG CoalescedMove move
               ; addWorklist u cg)
            else if (v.list = Precolored) || (EdgeSet.mem (u.v, v.v) cg.adjSet)
                 then
                    (ilg_switch cg.moveLG ConstrainedMove move;
                     addWorklist u cg;
                     addWorklist v cg)
            else if ((u.list = Precolored) &&
                     (List.fold_left (fun rst t -> (ok t u cg) && rst)
                                    true (adjacent v.v cg) )
                    || ((not (u.list = Precolored)) &&
                        (conservative (uniq ((adjacent u.v cg) @ (adjacent v.v cg)))
                                      cg)))
                 then
				    (
	let nodes = fold_fwd proc.Proc.cfg ( fun x rst -> x::rst ) [] in
ilg_iter (fun n -> if not (List.mem n.v nodes) then
	(cfgSay [ string_of_int (G.number n.v)
		  ; ": "
		  ; Rtlutil.ToString.rtl (G.instr n.v)
		  ; "\n"
		  ; "\t"
		  ; G.node_info_string n.v
		  ; "\n"
		  ] ;
	 assert false)) (!(cg.moveLG CoalescedMove));
                     ilg_switch cg.moveLG CoalescedMove move;
                     combine target u v cg;
                     addWorklist u cg)
            else
                ilg_switch cg.moveLG ActiveMove move
        in
            true
    | None -> false)
@

When moves are coalesced or constrained, the temps involved are placed on
the [[simplifyWorklist]].

<<coalesce move>>=
let addWorklist temp cg =
    if not ((temp.list = Precolored) || (moveRelated temp cg) ||
            (numMapFind temp.v cg.degreeMap >= cg.k))
    then ilg_switch cg.tempLG SimplifyWorklist temp
@

[[ok]] is the heuristic for coalescing pre-colored temps. [[tempr]] is the
pre-colored temp, and [[tempt]] is a temp adjacent to $tempv$, where we are
trying to coalesce $tempv$ with [[tempr]], and $tempv$ is not pre-colored.

<<coalesce move>>=
let ok (tempt : ('a, 'b) impListItem) tempr cg =
       (numMapFind tempt.v cg.degreeMap < cg.k)
    || (tempt.list = Precolored)
    || (EdgeSet.mem (tempt.v, tempr.v) cg.adjSet)
@

[[conservative]] implements the Briggs coalescing heuristic, which verifies
that the temps we are trying to coalesce have fewer than K significant-degree
neighbors.

<<coalesce move>>=
let conservative neighbors cg =
    cg.k > (List.fold_left
               (fun k temp ->
                    if numMapFind temp.v cg.degreeMap >= cg.k then k + 1 else k)
                0 neighbors)
@

[[getAlias]] returns the temp with which [[node]] has been coalesced.

<<coalesce move>>=
let rec getAlias node cg =
    if node.list = Coalesced
    then getAlias (RM.find (RM.find node.v cg.aliasMap) cg.regToItem) cg
    else node.v
@

[[combine]] coalesces the temp [[v]] with the temp [[u]]. [[v]]'s neighbors
and moves must be added to [[u]].

<<coalesce move>>=
let combine target u v cg =
	(*
    let () = if v.list = FreezeWorklist
            then cg.freezeWorklist <- filterOut v cg.freezeWorklist
            else cg.spillWorklist <- filterOut v cg.spillWorklist in
	*)
    let () = ilg_switch cg.tempLG Coalesced v in
    let () = cg.aliasMap <- RM.add v.v u.v cg.aliasMap in
    let moves = listMapFind u.v cg.moveListMap @ listMapFind v.v cg.moveListMap in
    let () = cg.moveListMap <- RM.add u.v moves cg.moveListMap in
    let () = enableMoves [v] cg in
    let () = List.iter (fun temp -> addEdge target cg temp.v u.v ;
                                 decrementDegree cg target temp)
                      (adjacent v.v cg) in
        if (numMapFind u.v cg.degreeMap >= cg.k) && (u.list = FreezeWorklist)
        then ilg_switch cg.tempLG SpillWorklist u
@

%-------------------------------------------------------------------
\subsubsection{Freeze}
%-------------------------------------------------------------------

If we cannot simplify or coalesce a move, we choose a move-related,
low-degree temp and freeze the moves it is involved in. We will no longer
consider the frozen moves for coalescing, which will allow this temp to be
simplified. Also, other temps may become non-move-related, allowing them to
be simplified.

Their is a policy decision of which temp to freeze; currently, the choice is
rather arbitrary.

<<freeze>>=
<<freeze move>>

let freeze cg _ =
(*
let () = prerr_string "freeze()\n" in
let () = flush stderr in
*)
   (match !(cg.tempLG FreezeWorklist) with
        | Some temp ->
			(ilg_switch cg.tempLG SimplifyWorklist temp;
             freezeMoves temp cg;
             true)
        | None -> false)
@

When a move is frozen, it must be removed from the [[activeMoves]] list.  Also,
if a low-degree temp becomes non-move-related when a move is frozen, this
temp can be simplified from the interference graph.

<<freeze move>>=
let freezeMoves temp cg =
    let freezeMove move =
        let x = RM.find (source move.v) cg.regToItem in
        let y = RM.find (dest move.v) cg.regToItem in
        let v = if (getAlias y cg) = (getAlias temp cg)
                then RM.find (getAlias x cg) cg.regToItem
				else RM.find (getAlias y cg) cg.regToItem in
		let () = ilg_switch cg.moveLG FrozenMove move in
            if (empty (nodeMoves v cg)) &&
               (numMapFind v.v cg.degreeMap < cg.k)
            then ilg_switch cg.tempLG SimplifyWorklist v
    in List.iter freezeMove (nodeMoves temp cg)
@

%-------------------------------------------------------------------
\subsubsection{Select Spill}
%-------------------------------------------------------------------

We perform optimistic spilling, allowing high-degree nodes to be removed
from the graph as a last option, in the hope that we will still be able to
assign colors to these nodes.

The choice of which node to spill here is a potentially important policy
decision.

<<selectSpill>>=
let selectSpill cg _ =
(*
let () = prerr_string "selectSpill()\n" in
let () = flush stderr in
*)
	(match ilg_filter (fun t -> not (RS.mem t.v cg.spills)) (!(cg.tempLG SpillWorklist)) with
	 | temp::rst ->
(*
let () = prerr_string "spilling: " in
let () = prerr_string (printReg temp.v) in
let () = prerr_string "\n" in
let () = flush stderr in
*)
		let () = ilg_switch cg.tempLG SimplifyWorklist temp in
		let () = freezeMoves temp cg in
			true
	 | _ -> false)
@

%-------------------------------------------------------------------
\subsubsection{Assign Colors}
%-------------------------------------------------------------------

We attempt to color the graph by popping temps off the select stack and
choosing a color that is not used by the temp's neighbors. If there is no
such color, we must spill the temp. After coloring the temps on the select
stack, we assign colors to the coalesced nodes if there were no .

The [[GraphColoring]] exception is raised if the graph is uncolorable.

<<assignColors>>=
exception GraphColoring

let assignColors cg {Proc.target = target} =
(*
let () = prerr_string "assignColors()\n" in
let () = flush stderr in
*)
    <<colorTemp>>
    let colorSelectStack () =
        let () = ilg_iter colorTemp (!(cg.tempLG SelectStack)) in
			assert (!(cg.tempLG SelectStack) = None) in
    let colorCoalescedTemps () =
        let setColor temp = 
            cg.colorMap <- RM.add temp.v (RM.find (getAlias temp cg)
                                                cg.colorMap) cg.colorMap
        in
            ilg_iter setColor (!(cg.tempLG Coalesced)) in
    let _ = colorSelectStack () in
    let _ = match !(cg.tempLG Spilled) with
        | None -> colorCoalescedTemps ()
        | _ -> () in
        true
@

[[colorTemp]] is responsible for coloring a single temp. The possible colors
([[okColors]]) are calculated by excluding colors that used by neighbors
temps. If any colors remain, we color the temp with one of them; otherwise,
we must spill a temp. If the current temp is a spill temp (a short-lived temp
generated from a previous spill), there can be no benefit from spilling this
temp and replacing it with another spill temp. In this case, we call
[[spillNeighbor]] to spill one of this temp's already-colored neighbors (we
also make sure this temp is not a spill temp). If no such neighbor exists,
then the graph is uncolorable, and we raise [[GraphColoring]].
On the other hand, if the current temp is not a spill temp, then we choose to
spill it.

Otherwise, the choices of colors assigned and neighbors spilled is a policy
decision, currently arbitrary.

<<colorTemp>>=
    let colorLookup temp cmap =
        if is_tmp target temp
        then RM.find (getAlias (RM.find temp cg.regToItem) cg) cmap
        else temp in

    let colorTemp temp =
        (* Find a non-(spill temp) neighbor and spill it. *)
        let spillNeighbor temp = (print_cgInfo cg; prerr_string (printReg temp); flush
				stderr; assert false)
		(*
            let neigh =
                try (List.find (fun t -> (t.list = Colored)
                                         && not(RS.mem t.v cg.spills ||
                                                t.list = Spilled))
                       (listMapFind temp cg.adjListMap))
                with Not_found -> raise GraphColoring in
            ( cg.spilledTemps <- neigh::cg.spilledTemps
            ; cg.coloredTemps <- List.filter (fun n -> n <> neigh)
                                    cg.coloredTemps
            ; cg.colorMap <- RM.remove neigh cg.colorMap)
			*)
        in
        let removeUsedColor colors adjTemp =
			let t = RM.find (getAlias adjTemp cg) cg.regToItem in
            if t.list = Colored || t.list = Precolored
            then
               RS.remove (colorLookup (getAlias adjTemp cg) cg.colorMap) colors
            else colors in
        let okColors =
            List.fold_left removeUsedColor (possibleColors target cg temp.v)
                           (listMapFind temp.v cg.adjListMap) in
			if RS.is_empty okColors
			then begin
                if RS.mem temp.v cg.spills
                then spillNeighbor temp.v
				else ilg_switch cg.tempLG Spilled temp
			end else begin
					 ilg_switch cg.tempLG Colored temp
					; cg.colorMap <- RM.add temp.v (RS.choose okColors) cg.colorMap
			end in
@

%-------------------------------------------------------------------
\subsubsection{Apply Colors}
%-------------------------------------------------------------------

[[applyColors]] is used to replace the temps in the \cfg with the colors they
are assigned. If a temp has not been assigned a color yet, the [[UncoloredTemp]]
exception will be raised; This indicates an error in the graph coloring
implementation.

<<applyColors>>=
exception UncoloredTemp of Register.t
let applyColors cg {Proc.cfg = cfg; Proc.target = target} =
(*
let () = prerr_string "applyColors()\n" in
let () = flush stderr in
*)
    let lookup = Target2.space target in
    let subst = function
      | temp when is_tmp target temp ->
            (try RM.find temp cg.colorMap
                     with Not_found -> 
                                       cfgSay [ "\n"
									          ; "Error - uncolored temp: "
                                              ; (Register.print temp)
                                              ; "\nCGInfo:\n"
											  ];
                                       print_cgInfo cg;
                                       raise (UncoloredTemp temp))
      | t -> t
    in
        ( fold_fwd cfg
            (fun node () ->
          (*     cfgSay [ string_of_int (G.number node)
                      ; ": "
                      ; Rtlutil.ToString.rtl (G.instr node)
                      ; "\n"];
			 *)
               G.upd_instr node (Rtlutil.Subst2.reg ~lookup ~map:subst)) ()
        ;
		  true)
@

%-------------------------------------------------------------------
\subsubsection{Reset/Update Program}
%-------------------------------------------------------------------

After an iteration of graph coloring in which spilled temps are generated,
resetProgram inserts the necessary loads and stores to spill the temps in
the \cfg and resets the [[cg]] structure for another round of graph coloring.

<<resetProgram>>=
<<insert spills>>

let resetProgram cg proc =
    (* handle addition of new temps to the cfg (those in spilledTemps) *)
    let newTemps = rewrite proc (!(cg.tempLG Spilled)) in
	let () = assert (!(cg.tempLG Initial) = None) in

	(*
	let () = ilg_iter (ilg_switch cg.tempLG Initial) (!(cg.tempLG Colored)) in
	let () = ilg_iter (ilg_switch cg.tempLG Initial) (!(cg.tempLG Coalesced)) in
	*)

	let () = List.iter (fun t -> cg.spills <- RS.add t cg.spills) newTemps in

	(*
	let addTemp group lst reg =
		cg.regToItem <- RM.add reg (ilg_add group lst reg) cg.regToItem in 
	let () = List.iter (addTemp cg.tempLG Initial) newTemps in
	let () = List.iter (fun t -> cg.spills <- RS.add t cg.spills) newTemps in
	*)

	let () = cg.tempLG Precolored := None in
	let () = cg.tempLG Initial := None in
	let () = cg.tempLG SimplifyWorklist := None in
	let () = cg.tempLG FreezeWorklist := None in
	let () = cg.tempLG SpillWorklist := None in
	let () = cg.tempLG Spilled := None in
	let () = cg.tempLG Coalesced := None in
	let () = cg.tempLG Colored := None in
	let () = cg.tempLG SelectStack := None in

	let () = cg.moveLG CoalescedMove   := None in
	let () = cg.moveLG ConstrainedMove := None in
	let () = cg.moveLG FrozenMove      := None in
	let () = cg.moveLG WorklistMove    := None in
	let () = cg.moveLG ActiveMove      := None in

    let () = cg.adjSet <- EdgeSet.empty in
	let () = cg.regToItem <- RM.empty in
    let () = cg.adjListMap <- RM.empty in
    let () = cg.degreeMap <- RM.empty in
    let () = cg.moveListMap <- RM.empty in
    let () = cg.aliasMap <- RM.empty in
    let () = cg.colorMap <- RM.empty in
        true
@

The simple predicate [[haveSpilledTemps]] may be used to determine whether
the graph coloring algorithm has terminated.

<<resetProgram>>=
let haveSpilledTemps cg _ =
(*
let () = prerr_string "haveSpilledTemps()\n" in
let () = flush stderr in
*)
	not (!(cg.tempLG Spilled) = None)
@

[[updateProgram]] removes coalesced moves from the \cfg. It may be desirable
to call this stage even after graph coloring has succeeded in placing every
temp.

<<resetProgram>>=
let removeCoalescedMoves cfg coalescedMoves =
(*
    let _ = cfgSay ["CoalescedMoves\n===========\n"] in
*)

	let nodes = fold_fwd cfg ( fun x rst -> x::rst ) [] in

	(*
	let coalescedMoves = uniq coalescedMoves in
	*)
        ilg_iter (fun n -> 
				(*
			let () = if not (List.mem n.v nodes) then assert false in
			*)
			G.gm_delete_assign n.v) coalescedMoves

let updateProgram cg {Proc.cfg = cfg} =
(*
let () = prerr_string "updateProgram()\n" in
let () = flush stderr in
*)
(*
    let () = Printf.fprintf stdout "updateProgram()\n" in
	let () = flush stdout in
*)
    let () = removeCoalescedMoves cfg (!(cg.moveLG CoalescedMove)) in
(*
    let () = Printf.fprintf stdout "return updateProgram()\n" in
	let () = flush stdout in
*)
        true
@

A pair of convenience functions for adding lists of \cfg nodes:

<<insert spills>>=
    let cfg_ins_lst_before lst node =
        let _ = List.fold_right G.gm_insert_assign_before lst node
        in ()
    let cfg_ins_lst_after lst node =
        let _ = List.fold_left G.gm_insert_assign_after node lst
        in ()
@

The [[reads_writes]] function checks whether a location [[loc]] is
read or written by an {\rtl}.  It returns a pair $(r,w)$ of [[bool]]
values.  The first component $r$ is true iff [[loc]] is read by
[[rtl]], the second $w$ iff [[loc]] is written by [[rtl]].

<<insert spills>>=
    let reads_writes rtl loc =
        let read  sp index width (r,w) = (r || loc = (sp,index,width), w) in
        let write sp index width (r,w) = (r, w || loc = (sp,index,width)) in
        Rtlutil.ReadWrite.fold ~read ~write rtl (false,false)
@

The heart of the spiller is [[update]] that is applied to every
[[node]] in the \cfg.  If [[node]] reads or writes the [[spillee]],
it must be updated such that it uses a new temporary [[tmp]] instead.
Before and after the node, [[tmp]] must be read from or written to the
memory location [[mem]], where the value of the spillee is held.

<<insert spills>>=
    let update proc (spillee, mem) node =
        let target = proc.Proc.target in
        let reads, writes = reads_writes (G.instr node) spillee in
        let lookup = Target2.space target in
            if reads || writes then
                    ( let tmp   = Talloc.Multiple.reg_like proc.Proc.temps
                                                           spillee in
                      let subst = fun x -> if x = spillee then tmp else x in 
                      ( if reads  then 
                            (cfg_ins_lst_before 
                                (target.T.reload (T.space target) tmp mem) node)
                      ; if writes then 
                            (cfg_ins_lst_after  
                                (target.T.spill  (T.space target) tmp mem) node)
                      ; G.upd_instr node (Rtlutil.Subst2.reg ~lookup ~map:subst)
                      )
                    ; Some tmp
                    )
             else None
@

In addition to adding store and fetch instructions to replace the spilled
temps in the \cfg, [[rewrite]] returns the new spill temps that are
generated.

<<insert spills>>=
    let rewrite proc spillees =
        let spill_slot ((_,_,w):Register.t) =
            Automaton2.to_loc (Automaton2.allocate proc.Proc.priv w None) in
        let smPairs = ilg_map (fun s -> (s.v, spill_slot s.v)) spillees in 
        (* newTemps is an accumulating param *)
        let updateNode smPairs node newTemps =
            (List.fold_left
                (fun tmps sm -> match update proc sm node with
                                | None -> tmps
                                | Some tmp -> tmp::tmps)
                newTemps smPairs)
        in
            fold_fwd proc.Proc.cfg (updateNode smPairs) []
@






%-------------------------------------------------------------------
\subsubsection{Cheats and Common Utilities}
%-------------------------------------------------------------------


The [[Cheats]] module provides several dummy functions which need to be
replaced/patched.

<<cheats>>=
module Cheats = struct
    let luaTableMapApp fn tab =
        let rec mapRest fn key tab =
            try
                let key, value = Luahash.next tab key in
                    (fn key value)@(mapRest fn key tab)
            with Not_found -> []
        in
            try
                let key, value = Luahash.first tab in
                    (fn key value)@(mapRest fn key tab)
            with Not_found -> []

    (* OK, THIS HAS TO BE CHANGED... still assuming width 32 *)
    let makeRegs regTable =
        let reg space i = String.get (V.string.V.project space) 0, i, 32 in
        luaTableMapApp (fun space rlist ->
                        List.map (reg space) ((V.list V.int).V.project rlist))
                    regTable

    (* check whether two temps interfere - whether they have overlapping reg
     * sets. this is inefficient and must get better.
     * this may also be misleading - if they only partially overlap, this
     * may or may not be a good way to indicate interference - see the
     * smith, holloway paper....
     *)
    let interfere (s1,_,_ as t1) (s2,_,_ as t2) target cg =
		s1 = s2 ||
			let s1 = possibleColors target cg t1 in    
			let s2 = possibleColors target cg t2 in
				not (RS.is_empty (RS.inter s1 s2))
end
@


The node observers are mostly straightforward. [[isMoveInstruction]]
verifies that the instruction is an assignment from one temp to another,
where both are in the same register space.

<<node observers>>=
    let source inst =
        match Rtlutil.RTLType.singleAssignment (G.instr inst) with
        | Some (s, _) -> s
        | _ -> assert false
    let dest inst =
        match Rtlutil.RTLType.singleAssignment (G.instr inst) with
        | Some (_, d) -> d
        | _ -> assert false

    (*
     * singleAssignment returns a (Register.t * Register.t) option
     * First get the assignment, then verify that the source and dest are
     * in the same reg. space
     *)
    let isMoveInstruction inst t =
        match Rtlutil.RTLType.singleAssignment (G.instr inst) with
        | Some ((s1,_,_) as r1, (s2,_,_) as r2)
            when is_tmp t r1 -> s1 = s2
        | _ -> false
@










The interface provides the modules to embed the graph coloring functions in the
Lua interpreter.

<<colorgraph.mli>>=
module GCT : Lua.Lib.USERTYPE
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.action)
            (GCT : Lua.Lib.TYPEVIEW with type 'a t = 'a GCT.t
                                  and type 'a combined = 'a BackplaneT.combined)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Proc.t
                                  and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.TYPEFUL with type 'a combined = 'a BackplaneT.combined
@

A few convenience functions for handling lists. Perhaps the lists that use
the set operations should be converted to register sets.

<<list as set>>=
    let empty lst = match lst with
        | [] -> true
        | _ -> false

    let numMapFind key listMap =
        try RM.find key listMap with Not_found -> 0
    let listMapFind key listMap =
        try RM.find key listMap with Not_found -> []
    let listMapAdd value key listMap =
        RM.add key (value::(listMapFind key listMap)) listMap
@

\subsection{Lua registration}

<<colorgraph.ml>>=
<<imperative lists>>
<<graph coloring types>>
module GCT : Lua.Lib.USERTYPE with type 'a t = colorGraph = struct
    type 'a t = colorGraph
    let tname = "Graph Coloring"
    let eq _ x y = x = y
    let to_string vs _ = "<cgInfo>"
end
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.action)
            (GCT : Lua.Lib.TYPEVIEW with type 'a t = 'a GCT.t
                                  and type 'a combined = 'a BackplaneT.combined)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Proc.t
                                  and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.TYPEFUL with type 'a combined = 'a BackplaneT.combined =
  struct
    type 'a combined = 'a BackplaneT.combined
    module M (Interp : Lua.Lib.CORE
                with type 'a V.userdata' = 'a BackplaneT.combined) = struct
        module V = Interp.V
        let cgmap = GCT.makemap V.userdata V.projection

        <<graph coloring builtins>>

        let init g =
          (* PLEASE CHANGE 'CG' TO 'Colorgraph' *)
          Interp.register_module "CG" graph_coloring_module g;
          Lua.Lib.StringList.empty (* FIX -- replace with init code *)
    end
  end
@



<<graph coloring builtins>>=
    let cfgSay = Verbose.say 18
    let cgSay = cfgSay

    <<list as set>>
    <<node observers>>
    <<cheats>>
    <<print CGInfo>>
    <<init cgInfo>>
    <<livenessAnalysis>>
    <<build>>
    <<makeWorklist>>
    <<simplify>>
    <<coalesce>>
    <<freeze>>
    <<selectSpill>>
    <<assignColors>>
    <<applyColors>>
    <<resetProgram>>
@

Embedding the functions in the Lua interpreter.

<<graph coloring builtins>>=
let proc = ProcT.makemap V.userdata V.projection
let ( **-> ) = V.( **-> )
let stageFn  = cgmap **-> proc **-> V.result V.bool

let writedot compress _ proc =
    prerr_string (Cfgutil.cfg2dot compress "CFG" proc.Proc.cfg);
    flush stderr;
    true

let graph_coloring_module =
  [ "liveness",         V.efunc stageFn liveness
  ; "build",            V.efunc stageFn build
  ; "makeWorklist",     V.efunc stageFn makeWorklist
  ; "simplify",         V.efunc stageFn simplify
  ; "coalesce",         V.efunc stageFn coalesce
  ; "freeze",           V.efunc stageFn freeze
  ; "selectSpill",      V.efunc stageFn selectSpill
  ; "assignColors",     V.efunc stageFn assignColors
  ; "haveSpilledTemps", V.efunc stageFn haveSpilledTemps
  ; "clearCGInfo",      V.efunc stageFn clearCGInfo
  ; "resetProgram",     V.efunc stageFn resetProgram
  ; "updateProgram",    V.efunc stageFn updateProgram
  ; "applyColors",      V.efunc stageFn applyColors
  ; "printCG",          V.efunc stageFn printCGInfo
  ; "printCFGLive",     V.efunc stageFn printCFGLive
  ; "pCFG",             V.efunc stageFn pCFG
  ; "writedot",         V.efunc (V.bool **-> V.result (V.func stageFn)) writedot
  ; "cgInfo",           cgmap.V.embed cgInfo
  ]

@
\subsubsection{Lua startup code}
This startup code sets up the right passes.
<<Lua startup code for [[Colorgraph]] module>>=
------------------------------------------------------------------ 
-- Graph-Coloring Register Allocator
------------------------------------------------------------------ 

CG = CG or error('predefined CG is nil??') -- has some primitives
B  = Backplane

CG.makeGraph = B.seq 
    { CG.liveness
    , CG.build 
    }
    
function p() print("Start") end

CG.orderVars = B.seq 
    { CG.makeWorklist
    , B.fix(B.unless_do(CG.simplify,
                            B.unless_do(CG.coalesce,
                                B.unless_do(CG.freeze,
                                    CG.selectSpill))))
    }

CG.pcg = 
    B.ignore(CG.printCG)
CG.pcfg = 
    B.ignore(CG.pCFG)

CG.color = 
    B.share
	( CG.cgInfo
    , "cgInfo"
    , B.seq 
	    { CG.clearCGInfo
	    , p
        , B.fix 
            ( B.seq 
                { B.ignore (B.seq
                    { CG.makeGraph
                    , CG.orderVars
                    , CG.assignColors
                    })
                , 
			   	B.when_do
                    ( CG.haveSpilledTemps
                    , CG.resetProgram
                    )
                } 
            )    
        , B.seq 
			{ CG.updateProgram
            , CG.applyColors
            }
        }        
    )       
@

\subsection{Debugging support}

Printing functions used for debugging purposes. Functions are provided for
printing the [[cgInfo]] data structure.
<<print CGInfo>>=
let regILists cgInfo =
	   [ ("Precolored", !(cgInfo.tempLG Precolored))
	   ; ("Initial", !(cgInfo.tempLG Initial))
	   ; ("SimplifyWorklist", !(cgInfo.tempLG SimplifyWorklist))
	   ; ("FreezeWorklist", !(cgInfo.tempLG FreezeWorklist))
	   ; ("SpillWorklist", !(cgInfo.tempLG SpillWorklist))
	   ; ("spilledTemps", !(cgInfo.tempLG Spilled))
	   ; ("coalescedTemps", !(cgInfo.tempLG Coalesced))
	   ; ("coloredTemps", !(cgInfo.tempLG Colored))
	   ; ("SelectStack", !(cgInfo.tempLG SelectStack))
	   ]
let regLists cgInfo =
	   [ ("Spills", RS.elements cgInfo.spills)
	   ; ("AllColors", cgInfo.allColors)
	   ]
let moveILists cgInfo =
                [ ("coalescedMoves", !(cgInfo.moveLG CoalescedMove))
                ; ("ConstrainedMoves", !(cgInfo.moveLG ConstrainedMove))
                ; ("FrozenMoves", !(cgInfo.moveLG FrozenMove))
                ; ("WorklistMoves", !(cgInfo.moveLG WorklistMove))
                ; ("ActiveMoves", !(cgInfo.moveLG ActiveMove))
                ]
@

Several helper functions are provided for printing parts of the cgInfo
record.

<<print CGInfo>>=
let printReg = Register.print
let printMove node = printReg (source node)
                   ^ " -> "
                   ^ printReg (dest node)
let printColorMap cm =
    cgSay ["    ColorMap:\n"];
    RM.iter (fun tmp reg -> cgSay [ "        "
                                  ; printReg tmp
                                  ; " -> "
                                  ; printReg reg
                                  ; "\n"
                                  ]) cm
@

The [[print_cgInfo]] function prints the graph coloring information in a
readable format. [[printCGInfo]] is embedded in the Lua interpreter to
provide access to [[print_cgInfo]].
Printing functions for the [[cfInfo]] record.

<<print CGInfo>>=
let printCFGLive _ {Proc.cfg = cfg} =
    let printNodeLive node _ =
        let live = (G.property node).P.liveout in
        cfgSay ["LIVE "; string_of_int (G.number node); ": "];
        cfgSay (List.map printReg (RS.elements live)); cfgSay ["\n"]; in
    fold_fwd cfg printNodeLive (); false

let print_cgInfo cgInfo =
    let _ = cgSay ["\nCGINFO\n"] in
    let printList iter pr (name, itemlist) =
		let indent = "        " in
		cgSay ["    "; name; ":\n"]; 
		iter (fun r -> cgSay [indent; pr r; "\n"])
				  itemlist in
    let printItemList pr (name, itemlist) =
		match itemlist with
		| [] -> ()
		| i  -> printList List.iter pr (name, itemlist) in
    let printItemIList pr (name, itemlist) =
		match itemlist with
		| None -> ()
		| Some _  -> printList (fun fn -> ilg_iter (fun i -> fn i.v))
	                           pr (name, itemlist) in
    let printReglist lst  = printItemList printReg lst in
    let printRegIlist lst  = printItemIList printReg lst in
    let printMoveIlist lst = printItemIList printMove lst in
    let printAdjListMember key lst =
        cgSay ["        "; printReg key; ": "];
        List.iter (fun r -> cgSay [", "; printReg r.v]) lst;
        cgSay ["\n"]; in
    let printAdjListMap am =
        let _ = cgSay ["    AdjListMap:\n"] in
        RM.iter printAdjListMember am
    in
        printAdjListMap cgInfo.adjListMap;
        List.iter printReglist (regLists cgInfo);
		List.iter printRegIlist (regILists cgInfo);
		cgSay ["    K: "; string_of_int cgInfo.k; "\n"];
        List.iter printMoveIlist (moveILists cgInfo);
        printColorMap cgInfo.colorMap

let printCGInfo param _ = print_cgInfo param; false
@

<<print CGInfo>>=
    let print_cfg cfg =
		cfgSay ["CFG\n===\n"];
		G.gm_enumerate cfg;
        ( fold_fwd cfg
            (fun node () ->
				cfgSay [ string_of_int (G.number node)
					  ; ": "
					  ; Rtlutil.ToString.rtl (G.instr node)
					  ; "\n"
					  ; "\t"
					  ; G.node_info_string node
					  ; "\n"
					  ] )
			()) ;
        cfgSay ["END CFG\n===\n"]
    let pCFG _ {Proc.cfg = cfg} = print_cfg cfg; false
@

<<cg stages>>=
(*
let selectSpillStage = { Backplane.name = "selectSpill"
                       ; Backplane.fn = selectSpill
                       ; Backplane.paramExpected = Some "cgInfo"
                       ; Backplane.stateCreated = Backplane.list2SSet []
                       ; Backplane.stateDestroyed = Backplane.list2SSet []
                       ; Backplane.stateUsed = Backplane.list2SSet []
                       }

let assignColorsStage = { Backplane.name = "assignColors"
                        ; Backplane.fn = assignColors
                        ; Backplane.paramExpected = Some "cgInfo"
                        ; Backplane.stateCreated = Backplane.list2SSet []
                        ; Backplane.stateDestroyed = Backplane.list2SSet []
                        ; Backplane.stateUsed = Backplane.list2SSet ["interferenceGraph"]
                        }

let rewriteProgramStage = { Backplane.name = "rewriteProgram"
                          ; Backplane.fn = rewriteProgram
                          ; Backplane.paramExpected = Some "cgInfo"
                          ; Backplane.stateCreated = Backplane.list2SSet []
                          ; Backplane.stateDestroyed = Backplane.list2SSet []
                          ; Backplane.stateUsed = Backplane.list2SSet []
                          }
*)
(*
let haveSpilledTempsStage = { Backplane.name = "haveSpilledTemps"
                            ; Backplane.fn = haveSpilledTemps
                            ; Backplane.paramExpected = Some "cgInfo"
                            ; Backplane.stateCreated = Backplane.list2SSet []
                            ; Backplane.stateDestroyed = Backplane.list2SSet []
                            ; Backplane.stateUsed = Backplane.list2SSet ["cfg"]
                            }
*)
(*
let livenessStage = { Backplane.name = "liveness"
                    ; Backplane.fn = liveness
                    ; Backplane.paramExpected = None
                    ; Backplane.stateCreated = Backplane.list2SSet ["live_in sets"]
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet ["cfg"]
                    }
*)
(*
let buildStage = {Backplane.name = "build"
                 ; Backplane.fn = build
                 ; Backplane.paramExpected = Some "cgInfo"
                 ; Backplane.stateCreated = Backplane.list2SSet ["interferenceGraph"]
                 ; Backplane.stateDestroyed = Backplane.list2SSet []
                 ; Backplane.stateUsed = Backplane.list2SSet ["cfg"; "live_in sets"]
                 }
*)
(*
let makeWorklistStage = { Backplane.name = "makeWorklist"
                        ; Backplane.fn = makeWorklist
                        ; Backplane.paramExpected = Some "cgInfo"
                        ; Backplane.stateCreated = Backplane.list2SSet ["worklists"]
                        ; Backplane.stateDestroyed = Backplane.list2SSet []
                        ; Backplane.stateUsed = Backplane.list2SSet ["interferenceGraph"]
                       }
*)
(*
let simplifyStage = { Backplane.name = "simplify"
                    ; Backplane.fn = simplify
                    ; Backplane.paramExpected = Some "cgInfo"
                    ; Backplane.stateCreated = Backplane.list2SSet []
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet []
                    }
*)
(*
let coalesceStage = { Backplane.name = "coalesce"
                    ; Backplane.fn = coalesce
                    ; Backplane.paramExpected = Some "cgInfo"
                    ; Backplane.stateCreated = Backplane.list2SSet []
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet []
                    }

let recklessCoalesceStage = { Backplane.name = "recklessCoalesce"
                            ; Backplane.fn = recklessCoalesce
                            ; Backplane.paramExpected = Some "cgInfo"
                            ; Backplane.stateCreated = Backplane.list2SSet []
                            ; Backplane.stateDestroyed = Backplane.list2SSet []
                            ; Backplane.stateUsed = Backplane.list2SSet []
                            }
*)
(*
let freezeStage = { Backplane.name = "freeze"
                  ; Backplane.fn = freeze
                  ; Backplane.paramExpected = Some "cgInfo"
                  ; Backplane.stateCreated = Backplane.list2SSet []
                  ; Backplane.stateDestroyed = Backplane.list2SSet []
                  ; Backplane.stateUsed = Backplane.list2SSet []
                  }
*)
@
