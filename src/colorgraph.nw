%cg. -*- mode: Noweb; noweb-code-mode: caml-mode -*-

%-------------------------------------------------------------------
\section{Graph Coloring Register Allocation}
%-------------------------------------------------------------------

Register allocation is responsible for replacing temporary registers (temps)
in the control-flow graph (\cfg) with hardware registers. Liveness analysis
is performed before register allocation begins, annotating each node of the
\cfg with the list of registers (temps and pre-assigned hardware registers)
that are alive at the node. Using this information, we can construct an
interference graph with nodes for each of the temporaries and edges between
temporaries that are alive at the same time.

Temporaries that are alive at the same time must be placed in different
registers. This requirement reduces directly to the graph coloring
requirement that nodes sharing an edge must be assigned different colors.
Register allocation is carried out by performing graph coloring on the
interference graph, with the hardware registers serving as the colors. If
the graph cannot be colored with the given set of registers, then we spill
the uncolorable temps to memory and attempt to color the new graph.

Move instructions between two temporaries that do not interfere can be
removed from the graph in a process known as coalescing. Conservative
coalescing ensures that the graph will not be rendered uncolorable by the
coalescences. Two non-exclusive heuristics have been developed to determine
when it is safe to coalesce: the Briggs heuristic and the George and Appel
heuristic.

% ------------------------------------------------------------------ 
\subsection{Overview}
% ------------------------------------------------------------------ 

We implement Lal George and Andrew Appel's iterated register coalescing
algorithm. Before the grah coloring begins, liveness analysis is performed
and the interference graph is built. The interference graph is represented
redundantly by an adjacency set and by adjacency lists. The adjacency set
maintains a set of all the edges in the graph. The adjacency lists are
stored in a hash table, with each node mapped to a list of its neighbors.
The purpose of the redundancy is to optimize the processes of testing whether
two nodes are adjacent and of finding all neighbors of a node. Additionally,
the degree (approximately the number of neighbors) of each node is maintained.

The center of the algorithm is a choice between four possible actions. The
first possible choice is always selected:
\begin{enumerate}
\item Attempt to remove non-move-related, low-degree temps from the graph and
      place them on the [[selectStack]]. (Low-degree temps have fewer than K
      neighbors, where K is the number of colors.)
\item If there are no low-degree temps, then attempt to coalesce move-related
      temps.
\item If there is a move-related temp of low-degree, then we [[freeze]] the
      moves in which this temp is involved (meaning we will no longer try to
      coalesce them), allowing this temp and possibly others to be placed on the
      [[selectStack]].
\item Otherwise, a significant-degree temp will be chosen as a spill
      candidate and placed on the [[selectStack]].
\end{enumerate}

After all the temps have been placed on the [[selectStack]], they must be
assigned colors. If a temp cannot be assigned a color (it's neighbors are
using all the available colors), then it must be spilled. In this case, the
temp must be spilled to memory; [[rewriteProgram]] is called to add spill
temps, fetch instructiong, and store instructions to the \cfg. Graph coloring
must start over from the point of liveness analysis if any temps are spilled. 
If all the temps can be assigned colors without requiring any spilling, then
the temps are replaced by the assigned registers in the \cfg, and register
allocation is complete.

Register allocation must handle temporaries in different register spaces and
constructs of irregular architectures, including register pairs. Multiple
register spaces are supported by initializing the degree of each temp to
degree[t] = (K - R) + N, where K is the total number of registers in all
register spaces, R is the number of registers in the register space for temp
t, and N is the number of neighbors of t. This trick avoids the overhead of
having to actually create interferences between t and registers in different
register spaces.

Traditionally, register pairs have been handled by adding extra edges in the
interference graph, but this is not yet handled in this allocator.

handle multiple register spaces
K may be inaccurate on irregular register sets (smith, holloway)

from Appel 244:
\begin{quote}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
procedure Main()\\
    LivenessAnalysis()\\
    Build()\\
    MakeWorklist()\\
    [[repeat]]\\
\>      [[if]] simplifyWorklist != \{\} [[then]] Simplify()\\
\>      [[else if]] worklistMoves != \{\} [[then]] Coalesce()\\
\>      [[else if]] freezeWorklist != \{\} [[then]] Freeze()\\
\>      [[else if]] spillWorklist != \{\} [[then]] SelectSpill()\\
    [[until]] simplifyWorklist = \{\} [[and]] worklistMoves = \{\}\\
\>            [[and]] simplifyWorklist = \{\} [[and]] spillWorklist = \{\}\\
    AssignColors()\\
    [[if]] spilledTemps != \{\} [[then]]\\
\>      RewriteProgram(spilledTemps)\\
\>      Main()\\
\end{tabbing}
\end{quote}



%-------------------------------------------------------------------
\subsection{Data Structures}
%-------------------------------------------------------------------

<<graph coloring types>>=
module G        = Cfg3
module T        = Target2
module P        = Cfgprop
module RM       = Register.Map
module RS       = Register.Set
module LI       = Live.Make(G)
@

CHANGE THIS TO "EDGES"

<<graph coloring types>>=
module CompareRegPair = struct
    type t = Register.t * Register.t
    let compare = compare
end
module RegPairSet = Set.Make(CompareRegPair)

type move = G.node
module CompareMoves = struct
    type t = move
    let compare = compare
end
module MS = Set.Make(CompareMoves)

let fold_fwd = Cfgutil.fold_fwd
let is_tmp (s,_,_) target = Target2.is_tmp target s 
@

The [[colorGraph]] record type represents the interference graph and maintains
the current state of the graph coloring.
The choice between lists and sets is not always obvious and
should be revisited for each case individually. 

\begin{itemize}
\item AdjSet - a set of all edges in the interference graph, where an edge is
               represented by a pair of registers
\item AdjListMap - a map from a temp [[t]] to the list of temps that interfere
				   with [[t]]
\item degreeMap - a map containing the current degree of each temp
\item moveListMap - a map from a temp to the list of move instructions it is
                    involved in
\item aliasMap - when a move is coalesced, the coalesced temp must be aliased
                 to the temp we maintain in the graph
\item colorMap - map from temp to assigned color
\end{itemize}

Every temp is a member of exactly one of these lists:
\begin{itemize}
\item precolored - preassigned machine registers
\item initial - temps, not yet preprocessed for graph coloring
\item simplifyWorklist - low-degree non-move-related temps
\item freezeWorklist - low-degree move-related temps
\item spillWorklist - high-degree temps
\item spilledTemps - potential spills
\item spills - short-living temps introduced for spilling (spill temps)
\item coalescedTemps - temps that have been coalesced out of the graph
\item coloredTemps - temps successfully colored
\item selectStack - stack of temps removed from the graph
\end{itemize}

Every move instruction is in one and only one of these lists:
\begin{itemize}
\item coalescedMoves - moves that have been coalesced
\item constrainedMoves - moves whose source and target interfere
\item frozenMoves - move that will no longer be considered for coalescing
\item worklistMoves - moves enabled for possible coalescing
\item activeMoves - moves not yet ready for coalescing
\end{itemize}

<<graph coloring types>>=
type color = Register.t
type colorGraph = { mutable adjSet : RegPairSet.t
                  ; mutable adjListMap : Register.t list RM.t
                  ; mutable degreeMap : int RM.t
                  ; mutable moveListMap : G.node list RM.t
                  ; mutable aliasMap : Register.t RM.t
                  ; mutable colorMap : color RM.t
                  ; mutable precolored : Register.t list
                  ; mutable initial : Register.t list
                  ; mutable spills : Register.t list
                  ; mutable simplifyWorklist : Register.t list
                  ; mutable freezeWorklist : Register.t list
                  ; mutable spillWorklist : Register.t list
                  ; mutable spilledTemps : Register.t list
                  ; mutable coalescedTemps : Register.t list
                  ; mutable coloredTemps : Register.t list
                  ; mutable selectStack : Register.t list
                  ; mutable coalescedMoves : move list
                  ; mutable constrainedMoves : move list
                  ; mutable frozenMoves : move list
                  ; mutable worklistMoves : move list
                  ; mutable activeMoves : move list
                  ; mutable colors : color list
                  ; mutable k : int
                  }
@

[[makeInitInfo]] constructs an empty [[colorGraph]] record, initialized with
the set of valid colors.

<<init cgInfo>>=
	let makeInitInfo colors =
		let col = Cheats.makeRegs colors in
		   { adjSet = RegPairSet.empty
		   ; adjListMap = RM.empty
		   ; degreeMap = RM.empty
		   ; moveListMap = RM.empty
		   ; aliasMap = RM.empty
		   ; colorMap = RM.empty
		   ; precolored = []
		   ; initial = []
		   ; spills = []
		   ; simplifyWorklist = []
		   ; freezeWorklist = []
		   ; spillWorklist = []
		   ; spilledTemps = []
		   ; coalescedTemps = []
		   ; coloredTemps = []
		   ; selectStack = []
		   ; coalescedMoves = []
		   ; constrainedMoves = []
		   ; frozenMoves = []
		   ; worklistMoves = []
		   ; activeMoves = []
		   ; colors = col
		   ; k = List.length col
		   }
	let makeInitInfo colors = embed (makeInitInfo (V.table.V.project colors))
@

%-------------------------------------------------------------------
\subsection{Graph Coloring Algorithm}
%-------------------------------------------------------------------

%-------------------------------------------------------------------
\subsubsection{LivenessAnalysis}
%-------------------------------------------------------------------

The liveness analysis algorithm is implemented in the [[live]] module.
This algorithm annotates each node in the (\cfg) with a [[live_out]] set
containing the temps that are alive after the node.

<<livenessAnalysis>>=
let liveness _ {Proc.cfg = cfg} =
    LI.liveness cfg; true
@

%-------------------------------------------------------------------
\subsubsection{Build}
%-------------------------------------------------------------------

Using the liveness information, we can build the interference graph by
scanning the \cfg and recording temps that interfere.
The build stage requires that liveness analysis has been performed on the
\cfg and the cgInfo data structure has been initialized.

When we reset the degree of a temp, it should not necessarily be reset to 0
because the temp must interfere with registers in other register spaces.
Instead, we set degree[t] = K - R, where K is the total number of registers and
R is the number of registers in temp t's register space.

<<build>>=
let resetDegree target cg temp =
    cg.degreeMap <-
        RM.add temp (cg.k - (regs_in_space target cg temp)) cg.degreeMap
@

We don't add edges to the interference graph if they already exist. Also, we
don't need to keep track of the neighbors of precolored temps.

<<build>>=
let addEdge u v cg =
    if not ((RegPairSet.mem (u, v) cg.adjSet) || (u = v))
    then
        let _ = cg.adjSet <- List.fold_right RegPairSet.add [(u, v); (v, u)]
                                             cg.adjSet in
        let _ =
            if not (List.mem u cg.precolored)
            then
                cg.adjListMap <- listMapAdd v u cg.adjListMap;
                cg.degreeMap <- RM.add u (RM.find u cg.degreeMap + 1)
                                        cg.degreeMap in
        let _ =
            if not (List.mem v cg.precolored)
			then
				cg.adjListMap <- listMapAdd u v cg.adjListMap;
				cg.degreeMap <- RM.add v (RM.find v cg.degreeMap + 1)
									 cg.degreeMap
            in ()
@

<<build>>=
let build cg {Proc.cfg = cfg; Proc.target = target} =
			let _ = fold_fwd cfg (fun n () -> RS.iter (resetDegree target cg)
												(RS.union (G.defs n)
												          (G.uses n)))
											  () in
            let addInterference node () =
                let live = (G.property node).P.liveout in
                let defs = G.defs node in
                let uses = G.uses node in
                let live =
                    if isMoveInstruction node target
                    then
                        (cg.moveListMap <- RS.fold (listMapAdd node)
                                            (RS.union defs uses) cg.moveListMap;
                        cg.worklistMoves <- node::cg.worklistMoves;
                        RS.diff live uses)
                    else live in
                let live = RS.union live defs in
                let addAllEdges def =
                    RS.iter (fun liveNode -> addEdge liveNode def cg) live
                in
                    RS.iter addAllEdges defs in
            let _ = fold_fwd cfg addInterference () in
            let regs = fold_fwd cfg
                        (fun node rst ->
                            (Register.Set.union
                                (Register.Set.union (G.defs node)
                                                    (G.uses node))
                                rst)) Register.Set.empty in
            let temps, pregs =
                List.partition (fun r -> is_tmp r target)
                               (Register.Set.elements regs) in
            let _ = cg.initial <- temps in
            let _ = cg.precolored <- pregs in
                true
let build cg = build (project cg)
@

We include two observers for the [[colorGraph]] type. [[possibleColors]]
returns a list of the registers in which the argument temp could be placed.
[[regs_in_space]] returns the number of possible registers in which the
argument temp could be placed.

<<graph coloring types>>=
    let possibleColors target cg (s,_,_) =
		List.filter (Target2.fits target s) cg.colors
        
    let regs_in_space target cg temp =
		if is_tmp temp target
		then List.length (possibleColors target cg temp)
		else cg.k
@

The [[Cheats]] module provides several dummy functions which need to be
replaced/patched.

<<cheats>>=
module Cheats = struct
	let luaTableMapApp fn tab =
		let rec mapRest fn key tab =
			try
				let key, value = Luahash.next tab key in
					(fn key value)@(mapRest fn key tab)
			with Not_found -> []
		in
			try
				let key, value = Luahash.first tab in
					(fn key value)@(mapRest fn key tab)
			with Not_found -> []

	(* OK, THIS HAS TO BE CHANGED... still assuming width 32 *)
    let makeRegs regTable =
		let reg space i = String.get (V.string.V.project space) 0, i, 32 in
		luaTableMapApp (fun space rlist ->
						List.map (reg space) ((V.list V.int).V.project rlist))
	                regTable
end
@

<<insert spills>>=
    let cfg_ins_lst_before lst node =
        let _ = List.fold_right G.gm_insert_assign_before lst node
        in ()
    let cfg_ins_lst_after lst node =
        let _ = List.fold_left G.gm_insert_assign_after node lst
        in ()

    let reads_writes rtl loc =
        let reads  sp index width (r,w) = (r || loc = (sp,index,width), w) in
        let writes sp index width (r,w) = (r, w || loc = (sp,index,width)) in
        Rtlutil.ReadWrite.fold reads writes rtl (false,false)

    let update proc (spillee, mem) node =
        let target = proc.Proc.target in
        let reads, writes = reads_writes (G.rtl node) spillee in
        let lookup = Target2.space target in
            if reads || writes then
                    ( let tmp   = Talloc.Multiple.reg_like proc.Proc.temps spillee in
                      let subst = fun x -> if x = spillee then tmp else x in 
                      ( if reads  then 
                            (cfg_ins_lst_before 
                                (target.T.reload (T.space target) tmp mem) node)
                      ; if writes then 
                            (cfg_ins_lst_after  
                                (target.T.spill  (T.space target) tmp mem) node)
                      ; G.set_rtl node (Rtlutil.Subst2.reg lookup subst)
                      )
                    ; Some tmp
                    )
             else None


    let rewrite proc spillees =
        let spill_slot ((_,_,w):Register.t) =
            Automaton.to_loc (Automaton.ty proc.Proc.priv w None) in
        let smPairs = List.map (fun s -> (s, spill_slot s)) spillees in 
        (* newTemps is an accumulating param *)
        let updateNode smPairs node newTemps =
            (List.fold_left
                (fun tmps sm -> match update proc sm node with
                                | None -> tmps
                                | Some tmp -> tmp::tmps)
                newTemps smPairs)
        in
            fold_fwd proc.Proc.cfg (updateNode smPairs) []
@

<<node observers>>=
    let source node =
        match Rtlutil.RTLType.singleAssignment (G.rtl node) with
        | Some (s, _) -> s
        | _ -> assert false
    let dest node =
        match Rtlutil.RTLType.singleAssignment (G.rtl node) with
        | Some (_, d) -> d
        | _ -> assert false

    (*
     * singleAssignment returns a (Register.t * Register.t) option
     * First get the assignment, then verify that the source and dest are
     * in the same reg. space
     *)
    let is_tmp (s,_,_) target = Target2.is_tmp target s 
    let isMoveInstruction node t =
        match Rtlutil.RTLType.singleAssignment (G.rtl node) with
        | Some ((s1,_,_) as r1, (s2,_,_) as r2)
            when is_tmp r1 t -> s1 = s2
        | _ -> false
@

<<graph modifiers>>=

    let removeCoalescedMoves cfg coalescedMoves =
	(*
        let _ = cfgSay ["CoalescedMoves\n===========\n"] in
            List.iter (fun n -> cfgSay [ string_of_int (Cfg3.number n)
                                       ; " "
                                       ; Register.print (source n)
                                       ; " -> "
                                       ; Register.print (dest n)
                                       ; " "
                                       ; Rtldebug.rtl_to_string (Cfg3.rtl n)
                                       ; "\n"
                                       ]
                                       ;
	*)
			List.iter (fun n -> Cfg3.gm_delete_assign n(*; Cfg3.gm_enumerate
					cfg*))
		        	  coalescedMoves
@

%-------------------------------------------------------------------
\subsubsection{MakeWorkList}
%-------------------------------------------------------------------

<<makeWorklist>>=
let filterOut el lst =
    List.fold_right (fun x rst -> if x = el then rst else x::rst) lst []

let setFromList lst = List.fold_right RS.add lst RS.empty
let moveSetFromList lst = List.fold_right MS.add lst MS.empty

let adjacent temp cg =
    RS.diff (setFromList (listMapFind temp cg.adjListMap))
            (setFromList (cg.selectStack @ cg.coalescedTemps))

let nodeMoves temp cg =
    MS.inter (moveSetFromList (listMapFind temp cg.moveListMap))
             (moveSetFromList (cg.activeMoves @ cg.worklistMoves))

let moveRelated temp cg =
    not (MS.is_empty (nodeMoves temp cg))

let makeWorklist cg _ = 
        let addToLists = function
            | temp when numMapFind temp cg.degreeMap >= cg.k ->
                cg.spillWorklist <- temp::cg.spillWorklist
            | temp when moveRelated temp cg ->
                cg.freezeWorklist <- temp::cg.freezeWorklist
            | temp ->
                cg.simplifyWorklist <- temp::cg.simplifyWorklist in
        let _ = List.iter addToLists cg.initial in
        let _ = cg.initial <- [] in
            true
let makeWorklist cg = makeWorklist (project cg)
             

@

%-------------------------------------------------------------------
\subsubsection{Simplify}
%-------------------------------------------------------------------

<<simplify>>=
let enableMoves temps cg =
    let enableMovesForTemp temp =
        let enableMove move =
            if List.mem move cg.activeMoves
            then cg.activeMoves <- filterOut move cg.activeMoves;
                 cg.worklistMoves <- union move cg.worklistMoves
        in
            MS.iter enableMove (nodeMoves temp cg)
    in
        RS.iter enableMovesForTemp temps

let listAdd el lst = if not (List.mem el lst) then el::lst else lst

let decrementDegree cg target temp =
    let d = RM.find temp cg.degreeMap in
    let _ = cg.degreeMap <- RM.add temp (d - 1) cg.degreeMap in
        if d = cg.k
        then
            enableMoves (RS.add temp (adjacent temp cg)) cg;
            cg.spillWorklist <- filterOut temp cg.spillWorklist;
            if moveRelated temp cg
            then cg.freezeWorklist <- listAdd temp cg.freezeWorklist
            else if is_tmp temp target
                 then cg.simplifyWorklist <- listAdd temp cg.simplifyWorklist
                 else ()
        
exception GraphColoring

let simplify cg {Proc.target = t} =
        (match cg.simplifyWorklist with
        | temp::rst ->
            let _ = cg.simplifyWorklist <- rst in
            let _ = cg.selectStack <- temp::cg.selectStack in
            let _ = RS.iter (decrementDegree cg t) (adjacent temp cg) in
                true
        | _ -> false)
let simplify cg = simplify (project cg)
@


%-------------------------------------------------------------------
\subsubsection{Coalesce}
%-------------------------------------------------------------------

<<coalesce>>=
let addWorklist temp cg =
    if not ((List.mem temp cg.precolored) || (moveRelated temp cg) ||
            (numMapFind temp cg.degreeMap >= cg.k))
    then
        cg.freezeWorklist <- filterOut temp cg.freezeWorklist;
        cg.simplifyWorklist <- temp::cg.simplifyWorklist

let ok tempt tempr cg =
    (numMapFind tempt cg.degreeMap < cg.k) || (List.mem tempt cg.precolored) ||
    (RegPairSet.mem (tempt, tempr) cg.adjSet)

let conservative nodes cg =
    cg.k > (List.fold_left
           (fun k node -> if numMapFind node cg.degreeMap >= cg.k then k + 1 else k)
            0 nodes)

let rec getAlias node cg =
    if List.mem node cg.coalescedTemps
    then getAlias (RM.find node cg.aliasMap) cg
    else node

let combine target u v cg =
    let _ = if List.mem v cg.freezeWorklist
            then cg.freezeWorklist <- filterOut v cg.freezeWorklist
            else cg.spillWorklist <- filterOut v cg.spillWorklist in
    let _ = cg.coalescedTemps <- union v cg.coalescedTemps in
    let _ = cg.aliasMap <- RM.add v u cg.aliasMap in
    let _ = cg.moveListMap <- listMapUnion (listMapFind v cg.moveListMap)
                                           u cg.moveListMap in
    let _ = enableMoves (RS.add v RS.empty) cg in
    let _ = RS.iter (fun temp -> addEdge temp u cg;
                                 decrementDegree cg target temp)
                      (adjacent v cg) in
        if (numMapFind u cg.degreeMap >= cg.k) && (List.mem u cg.freezeWorklist)
        then
            cg.freezeWorklist <- filterOut u cg.freezeWorklist;
            cg.spillWorklist <- filterOut u cg.spillWorklist


let coalesce cg {Proc.target = target} =
        (match cg.worklistMoves with
        | move::rstMoves ->
            let x = source move in
            let y = dest move in
            let (u, v) = if List.mem y cg.precolored then (y, x) else (x, y) in
            let _ = cg.worklistMoves <- rstMoves in
            let _ =
                if u = v
                then
                    (cg.coalescedMoves <- union move cg.coalescedMoves;
                     addWorklist u cg)
                else if (List.mem v cg.precolored) || (RegPairSet.mem (u, v) cg.adjSet)
                     then
                        (cg.constrainedMoves <- move::cg.constrainedMoves;
                         addWorklist u cg;
                         addWorklist v cg)
                else if ((List.mem u cg.precolored) &&
                         (RS.fold (fun t rst -> (ok t u cg) && rst)
                                        (adjacent v cg) true)
                        || ((not (List.mem u cg.precolored)) &&
                        (conservative (RS.elements (RS.union (adjacent u cg)
                                                           (adjacent v cg))))
                                          cg))
                     then
                        (cg.coalescedMoves <- union move cg.coalescedMoves;
                         combine target u v cg;
                         addWorklist u cg)
                else
                    cg.activeMoves <- move::cg.activeMoves
            in
                true
        | _ -> false)
let coalesce cg = coalesce (project cg)

@

%-------------------------------------------------------------------
\subsubsection{Freeze}
%-------------------------------------------------------------------

<<freeze>>=
let freezeMoves temp cg =
    let freezeMove move =
        let x = source move in
        let y = source move in
        let v = if (getAlias y cg) = (getAlias temp cg)
                then getAlias x cg
                else getAlias y cg in
        let _ = cg.activeMoves <- filterOut move cg.activeMoves in
        let _ = cg.frozenMoves <- move::cg.frozenMoves in
            if (MS.is_empty (nodeMoves v cg)) &&
               (numMapFind v cg.degreeMap < cg.k)
            then
                cg.freezeWorklist <- filterOut v cg.freezeWorklist;
                cg.simplifyWorklist <- v::cg.simplifyWorklist 
    in MS.iter freezeMove (nodeMoves temp cg)
        
let freeze cg _ =
   (match cg.freezeWorklist with
        | temp::rst ->
            (cg.freezeWorklist <- rst;
             cg.simplifyWorklist <- temp::cg.simplifyWorklist;
             freezeMoves temp cg;
             true)
        | _ -> false)
let freeze cg = freeze (project cg)
@


%-------------------------------------------------------------------
\subsubsection{SelectSpill}
%-------------------------------------------------------------------

<<selectSpill>>=
let selectSpill cg _ =
        (match List.fold_right filterOut cg.spills cg.spillWorklist with
         | temp::rst ->
            let _ = cg.spillWorklist <- rst in
            let _ = cg.simplifyWorklist <- temp::cg.simplifyWorklist in
            let _ = freezeMoves temp cg in
                true
         | _ -> false)
let selectSpill cg = selectSpill (project cg)

let assignColors cg {Proc.target = target} =
        let colorLookup temp cmap =
            if is_tmp temp target
            then RM.find (getAlias temp cg) cmap
            else temp in
        let colorTemp temp =
            (* Find a non-spill neighbor and spill it. *)
            let spillNeighbor temp =
                let neigh =
                    try (List.find (fun t -> (List.mem t cg.coloredTemps)
                                             && not(List.mem t cg.spills ||
                                                    List.mem t cg.spilledTemps))
                           (listMapFind temp cg.adjListMap))
                    with Not_found -> raise GraphColoring in
                    ( cg.spilledTemps <- neigh::cg.spilledTemps
                    ; cg.coloredTemps <- List.filter (fun n -> n <> neigh)
                                            cg.coloredTemps
                    ; cg.colorMap <- RM.remove neigh cg.colorMap)
            in
            let removeUsedColor colors temp =
                if List.mem (getAlias temp cg) (cg.coloredTemps @ cg.precolored)
                then
                   filterOut (colorLookup (getAlias temp cg) cg.colorMap) colors
                else colors in
            let okColors =
                List.fold_left removeUsedColor (possibleColors target
						cg temp)
                               (listMapFind temp cg.adjListMap)
            in
                (match okColors with
                 | [] ->
                     if List.mem temp cg.spills
                    then spillNeighbor temp
                    else cg.spilledTemps <- temp::cg.spilledTemps
                 | color::rst ->
                    cg.coloredTemps <- union temp cg.coloredTemps;
                    cg.colorMap <- RM.add temp color cg.colorMap) in
        let colorSelectStack () =
            let _ = List.iter colorTemp cg.selectStack in
                cg.selectStack <- [] in
        let colorcoalescedTemps () =
            let setColor temp = 
                cg.colorMap <- RM.add temp (RM.find (getAlias temp cg)
                                            cg.colorMap) cg.colorMap
            in
                List.iter setColor cg.coalescedTemps in
        let _ = colorSelectStack () in
        let _ = match cg.spilledTemps with
            | [] -> colorcoalescedTemps ()
            | _ -> () in
            true
let assignColors cg = assignColors (project cg)
@

[[applyColors]] is used to replace the temps with the colors they are
assigned. If a temp has not been assigned a color yet, the [[UncoloredTemp]]
exception will be raised.

<<selectSpill>>=
exception UncoloredTemp of Register.t
let applyColors cg {Proc.cfg = cfg; Proc.target = target} =
    let lookup = Target2.space target in
    let subst = function
      | temp when is_tmp temp target ->
            (try RM.find temp cg.colorMap
                     with Not_found -> print_cgInfo cg;
                                       cfgSay [ "\n"
                                              ; (Register.print temp)
                                              ; "\n"
                                              ];
                                       raise (UncoloredTemp temp))
      | t -> t
    in
        ( fold_fwd cfg
            (fun node () -> cfgSay [string_of_int (G.number node)];
             cfgSay [ ": " ; Rtldebug.rtl_to_string (Cfg3.rtl node) ;
             "\n"]; G.set_rtl node (Rtlutil.Subst2.reg lookup subst)) ()
        ; true)
let applyColors cg = applyColors (project cg)
@

[[resetProgram]] is called when we have spilled temps on the previous
attempt at graph coloring, in preparation for the next iteration.
Temporaries are spilled and the [[cg]] record is reset.

<<selectSpill>>=
<<insert spills>>

let resetProgram cg proc =
    (* handle addition of new temps to the cfg (those in spilledTemps) *)
    let newTemps = rewrite proc cg.spilledTemps in
    let _ = cg.initial <- cg.coloredTemps @ cg.coalescedTemps @ newTemps in
    let _ = cg.spills <- cg.spills @ newTemps in
    let _ = cg.adjSet <- RegPairSet.empty in
    let _ = cg.adjListMap <- RM.empty in
    let _ = cg.degreeMap <- RM.empty in
    let _ = cg.moveListMap <- RM.empty in
    let _ = cg.aliasMap <- RM.empty in
    let _ = cg.colorMap <- RM.empty in
    let _ = cg.simplifyWorklist <- [] in
    let _ = cg.freezeWorklist <- [] in
    let _ = cg.spillWorklist <- [] in
    let _ = cg.spilledTemps <- [] in
    let _ = cg.coloredTemps <- [] in
    let _ = cg.coalescedTemps <- [] in
    let _ = cg.selectStack <- [] in
    let _ = cg.coalescedMoves <- [] in
    let _ = cg.constrainedMoves <- [] in
    let _ = cg.frozenMoves <- [] in
    let _ = cg.worklistMoves <- [] in
    let _ = cg.activeMoves <- [] in
        true
let resetProgram cg = resetProgram (project cg)

let haveSpilledTemps cg _ = not (empty (project cg).spilledTemps)

let updateProgram cg {Proc.cfg = cfg} =
    let _ = removeCoalescedMoves cfg cg.coalescedMoves in
        true
let updateProgram cg = updateProgram (project cg)
@

The interface enables the graph coloring functions to be embedded in the Lua
interpreter.

<<colorgraph.mli>>=
module GCT : Lua.Lib.USERTYPE
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.t')
            (GCT : Lua.Lib.TYPEVIEW with type 'a t = 'a GCT.t
		                          and type 'a combined = 'a BackplaneT.combined)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Proc.t
			                      and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.TYPEFUL with type 'a combined = 'a BackplaneT.combined
@

A few convenience functions for handling lists. Perhaps the lists that use
[[union]] should be converted to sets.

<<list as set>>=
    let empty lst = match lst with
        | [] -> true
        | _ -> false
    let union move lst = if List.mem move lst then lst else move::lst
	let numMapFind key listMap =
		try RM.find key listMap with Not_found -> 0
	let listMapFind key listMap =
		try RM.find key listMap with Not_found -> []
	let listMapAdd value key listMap =
		RM.add key (value::(listMapFind key listMap)) listMap
	let listMapUnion value key listMap =
		RM.add key (value @ (listMapFind key listMap)) listMap

@



<<colorgraph.ml>>=
<<graph coloring types>>
module GCT : Lua.Lib.USERTYPE with type 'a t = colorGraph = struct
    type 'a t = colorGraph
    let tname = "Graph Coloring"
    let eq _ x y = x = y
    let to_string vs _ = "<cgInfo>"
end
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.t')
            (GCT : Lua.Lib.TYPEVIEW with type 'a t = 'a GCT.t
		                          and type 'a combined = 'a BackplaneT.combined)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Proc.t
		                          and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.TYPEFUL with type 'a combined = 'a BackplaneT.combined =
  struct
    type 'a combined = 'a BackplaneT.combined
    module M (Interp : Lua.Lib.CORE
				with type 'a V.userdata' = 'a BackplaneT.combined) = struct
        module V = Interp.V
        let cgmap = GCT.makemap V.userdata V.projection
        let embed = cgmap.V.embed
        let project = cgmap.V.project

        <<graph coloring builtins>>

        let init g =
          Interp.register_globals graph_coloring_globals    g;
          Interp.register_module "CG" graph_coloring_module g
    end
  end
@



<<graph coloring builtins>>=
    let cfgSay = Verbose.say 18
	let cgSay = cfgSay

	<<list as set>>
	<<node observers>>
    <<cheats>>
    <<print CGInfo>>
    <<init cgInfo>>
	<<graph modifiers>>
    <<livenessAnalysis>>
    <<build>>
    <<makeWorklist>>
    <<simplify>>
    <<coalesce>>
    <<freeze>>
    <<selectSpill>>
@

Embedding the functions in the Lua interpreter.

<<graph coloring builtins>>=
let proc = ProcT.makemap V.userdata V.projection
let ( **-> ) = V.( **-> )
let stageFnType = V.value **-> proc **-> V.result V.bool
let stageFn = (V.pfunc stageFnType).V.embed
let param2StageFn =
        (V.pfunc (V.value **-> V.result (V.pfunc stageFnType))).V.embed
let param2value =
        (V.pfunc (V.value **-> V.result V.value)).V.embed

let writedot compress _ proc =
	prerr_string (Cfgutil.cfg2dot (V.bool.V.project compress)
			                      "CFG" proc.Proc.cfg);
	flush stderr;
	true

let graph_coloring_module =
        [ "liveness",         stageFn liveness
        ; "build",            stageFn build
        ; "makeWorklist",     stageFn makeWorklist
        ; "simplify",         stageFn simplify
        ; "coalesce",         stageFn coalesce
        ; "freeze",           stageFn freeze
        ; "selectSpill",      stageFn selectSpill
        ; "assignColors",     stageFn assignColors
        ; "haveSpilledTemps", stageFn haveSpilledTemps
        ; "resetProgram",     stageFn resetProgram
        ; "updateProgram",    stageFn updateProgram
        ; "applyColors",      stageFn applyColors
        ; "printCG",          stageFn printCGInfo
        ; "printCFGLive",     stageFn printCFGLive
        ; "pCFG",             stageFn pCFG
        ; "makeInitInfo",     param2value makeInitInfo
		; "writedot",         param2StageFn writedot
        ]

let graph_coloring_globals = []
@








Printing functions used for debugging purposes. Functions are provided for
printing the [[cgInfo]] data structure.

<<print CGInfo>>=
let regLists cgInfo =
               [ ("Precolored", cgInfo.precolored)
               ; ("Initial", cgInfo.initial)
               ; ("Spills", cgInfo.spills)
               ; ("SimplifyWorklist", cgInfo.simplifyWorklist)
               ; ("FreezeWorklist", cgInfo.freezeWorklist)
               ; ("SpillWorklist", cgInfo.spillWorklist)
               ; ("spilledTemps", cgInfo.spilledTemps)
               ; ("coalescedTemps", cgInfo.coalescedTemps)
               ; ("coloredTemps", cgInfo.coloredTemps)
               ; ("SelectStack", cgInfo.selectStack)
               ]
let moveLists cgInfo =
                [ ("coalescedMoves", cgInfo.coalescedMoves)
                ; ("ConstrainedMoves", cgInfo.constrainedMoves)
                ; ("FrozenMoves", cgInfo.frozenMoves)
                ; ("WorklistMoves", cgInfo.worklistMoves)
                ; ("ActiveMoves", cgInfo.activeMoves)
                ]
@

Several helper functions are provided for printing parts of the cgInfo
record.

<<print CGInfo>>=
let printReg = Register.print
let printMove node = printReg (source node)
                   ^ " -> "
                   ^ printReg (dest node)
let printColorMap cm =
    cgSay ["    ColorMap:\n"];
    RM.iter (fun tmp reg -> cgSay [ "        "
                                  ; printReg tmp
                                  ; " -> "
                                  ; printReg reg
                                  ; "\n"
                                  ]) cm
@

[[print_cgInfo]] prints the graph coloring information in a readable format.
[[printCGInfo]] is embedded in the Lua interpreter to provide access to
[[print_cgInfo]].
Printing functions for the [[cfInfo]] record.

<<print CGInfo>>=
let printCFGLive _ {Proc.cfg = cfg} =
    let printNodeLive node _ =
        let live = (G.property node).P.liveout in
        cfgSay ["LIVE "; string_of_int (G.number node); ": "];
        cfgSay (List.map printReg (RS.elements live)); cfgSay ["\n"]; in
    fold_fwd cfg printNodeLive (); false

let print_cgInfo cgInfo =
    let _ = cgSay ["\nCGINFO\n"] in
    let printItemList pr (name, itemlist) = match itemlist with
        | [] -> ()
        | itemlist ->
            let indent = "        " in
            cgSay ["    "; name; ":\n"]; 
            List.iter (fun r -> cgSay [indent; pr r; "\n"])
                      itemlist in
    let printReglist lst  = printItemList printReg lst in
    let printMovelist lst = printItemList printMove lst in
    let printAdjListMember key lst =
        cgSay ["        "; printReg key; ": "];
        List.iter (fun r -> cgSay [", "; printReg r]) lst;
        cgSay ["\n"]; in
    let printAdjListMap am =
        let _ = cgSay ["    AdjListMap:\n"] in
        RM.iter printAdjListMember am
    in
        printAdjListMap cgInfo.adjListMap;
        List.iter printReglist (regLists cgInfo);
        List.iter printMovelist (moveLists cgInfo);
        printColorMap cgInfo.colorMap

let printCGInfo param _ = match project param with cg ->
    print_cgInfo cg; true
@

<<print CGInfo>>=
    let print_cfg cfg =
        cfgSay ["CFG\n===\n"];
        fold_fwd cfg (fun n () -> cfgSay [Cfg3.print_node n; "\n"]) ();
        cfgSay ["END CFG\n===\n"]
    let pCFG _ {Proc.cfg = cfg} = print_cfg cfg; false
@

<<cg stages>>=
(*
let selectSpillStage = { Backplane.name = "selectSpill"
                       ; Backplane.fn = selectSpill
                       ; Backplane.paramExpected = Some "cgInfo"
                       ; Backplane.stateCreated = Backplane.list2SSet []
                       ; Backplane.stateDestroyed = Backplane.list2SSet []
                       ; Backplane.stateUsed = Backplane.list2SSet []
                       }

let assignColorsStage = { Backplane.name = "assignColors"
                        ; Backplane.fn = assignColors
                        ; Backplane.paramExpected = Some "cgInfo"
                        ; Backplane.stateCreated = Backplane.list2SSet []
                        ; Backplane.stateDestroyed = Backplane.list2SSet []
                        ; Backplane.stateUsed = Backplane.list2SSet ["interferenceGraph"]
                        }

let rewriteProgramStage = { Backplane.name = "rewriteProgram"
                          ; Backplane.fn = rewriteProgram
                          ; Backplane.paramExpected = Some "cgInfo"
                          ; Backplane.stateCreated = Backplane.list2SSet []
                          ; Backplane.stateDestroyed = Backplane.list2SSet []
                          ; Backplane.stateUsed = Backplane.list2SSet []
                          }
*)
(*
let haveSpilledTempsStage = { Backplane.name = "haveSpilledTemps"
                            ; Backplane.fn = haveSpilledTemps
                            ; Backplane.paramExpected = Some "cgInfo"
                            ; Backplane.stateCreated = Backplane.list2SSet []
                            ; Backplane.stateDestroyed = Backplane.list2SSet []
                            ; Backplane.stateUsed = Backplane.list2SSet ["cfg"]
                            }
*)
(*
let livenessStage = { Backplane.name = "liveness"
                    ; Backplane.fn = liveness
                    ; Backplane.paramExpected = None
                    ; Backplane.stateCreated = Backplane.list2SSet ["live_in sets"]
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet ["cfg"]
                    }
*)
(*
let buildStage = {Backplane.name = "build"
                 ; Backplane.fn = build
                 ; Backplane.paramExpected = Some "cgInfo"
                 ; Backplane.stateCreated = Backplane.list2SSet ["interferenceGraph"]
                 ; Backplane.stateDestroyed = Backplane.list2SSet []
                 ; Backplane.stateUsed = Backplane.list2SSet ["cfg"; "live_in sets"]
                 }
*)
(*
let makeWorklistStage = { Backplane.name = "makeWorklist"
                        ; Backplane.fn = makeWorklist
                        ; Backplane.paramExpected = Some "cgInfo"
                        ; Backplane.stateCreated = Backplane.list2SSet ["worklists"]
                        ; Backplane.stateDestroyed = Backplane.list2SSet []
                        ; Backplane.stateUsed = Backplane.list2SSet ["interferenceGraph"]
                       }
*)
(*
let simplifyStage = { Backplane.name = "simplify"
                    ; Backplane.fn = simplify
                    ; Backplane.paramExpected = Some "cgInfo"
                    ; Backplane.stateCreated = Backplane.list2SSet []
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet []
                    }
*)
(*
let coalesceStage = { Backplane.name = "coalesce"
                    ; Backplane.fn = coalesce
                    ; Backplane.paramExpected = Some "cgInfo"
                    ; Backplane.stateCreated = Backplane.list2SSet []
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet []
                    }

let recklessCoalesceStage = { Backplane.name = "recklessCoalesce"
                            ; Backplane.fn = recklessCoalesce
                            ; Backplane.paramExpected = Some "cgInfo"
                            ; Backplane.stateCreated = Backplane.list2SSet []
                            ; Backplane.stateDestroyed = Backplane.list2SSet []
                            ; Backplane.stateUsed = Backplane.list2SSet []
                            }
*)
(*
let freezeStage = { Backplane.name = "freeze"
                  ; Backplane.fn = freeze
                  ; Backplane.paramExpected = Some "cgInfo"
                  ; Backplane.stateCreated = Backplane.list2SSet []
                  ; Backplane.stateDestroyed = Backplane.list2SSet []
                  ; Backplane.stateUsed = Backplane.list2SSet []
                  }
*)
@
