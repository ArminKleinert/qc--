%cg. -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
%-------------------------------------------------------------------
\section{Graph Coloring Register Allocation}
%-------------------------------------------------------------------

Register allocation is responsible for replacing temporary registers (temps)
in the control-flow graph (\cfg) with hardware registers. Liveness analysis
is performed prior to register allocation, annotating each node of the 
\cfg \ with the list of registers (temps and pre-assigned hardware registers)
that are alive at the node. Using this information, we construct an
interference graph with nodes for each of the temporaries and edges between
temporaries that are live at the same time.

Temporaries that interfere must be placed in different registers. This
requirement reduces directly to the graph coloring goal of assigning
different colors to nodes that share graph edges. Register allocation
is carried out by performing graph coloring on the interference graph,
with the hardware registers serving as the colors. If the graph cannot
be colored, we spill the uncolorable temps to memory and attempt to color
the new graph.

% ------------------------------------------------------------------ 
\subsection{Overview}
% ------------------------------------------------------------------ 

We implement Lal George and Andrew Appel's iterated register coalescing
algorithm. Before the graph coloring begins, liveness analysis is performed,
and the interference graph is built. The interference graph is redundantly
represented by an adjacency set and by adjacency lists. The adjacency set
maintains a set of all the edges in the graph. The adjacency lists are
stored in a hash table, with each node mapped to the list of its neighbors.
The purpose of the redundancy is to optimize both the process of testing
whether two nodes are adjacent and of finding all neighbors of a node.

In addition to building the graph, we also initialize the degree of each
temp in the graph. The degree of a temp is the number of registers (both temps
and hardware registers) with which the temp interferes.

Before the actual graph coloring process begins, temps are separated into
worklists, based on their degree and whether they are involved in a move
instruction (move-related).

The basis of the graph coloring algorithm is the observation that low-degree
temps (temps that have fewer than K neighbors, where K is the number of colors)
can be colored easily, so they can be removed from the graph. If the rest of
the graph is colorable, then the graph will remain colorable when we restore
the temps we removed. As we remove these temps, we place them on the
[[selectStack]], which provides the order we will assign colors.

If there are no low-degree, non-move-related temps remaining in the graph,
we attempt to coalesce. We can coalesce two temps into a single temp by
removing move instructions involving two temps that do not interfere, and
using one of the temps in place of the other. By using conservative heuristics,
we can ensure that the graph will not be rendered uncolorable by the
coalescences. Two heuristics have been developed for conservative coalescing:
the Briggs heuristic and the George heuristic.

If there are no low-degree, non-move-related temps in the graph, we freeze
one of the move-related temps. Freezing a temp means that we will no longer
attempt to coalesce moves in which the temp is involved; this also frees the
temp for removal from the graph, since it becomes a low-degree,
non-move-related temp.

The graph may be uncolorable if only high-degree temps remain; however,
instead of assuming that we must spill a node, we choose a high-degree node,
remove it from the graph, and place it on the [[selectStack]].

This process of removing temps from the graph is summarized by the following
options. The first applicable choice is always selected, and the decision
is repeated until the graph is empty:
\begin{enumerate}
\item Attempt to remove non-move-related, low-degree temps from the graph and
      place them on the [[selectStack]].
\item If there are no low-degree temps, then attempt to coalesce move-related
      temps.
\item If there is a move-related temp of low-degree, then we [[freeze]] the
      moves in which this temp is involved (meaning we will no longer try to
      coalesce them), allowing this temp and possibly others to be placed on the
      [[selectStack]].
\item Otherwise, a significant-degree temp will be chosen as a potential spill
      candidate and placed on the [[selectStack]].
\end{enumerate}

After all the temps have been placed on the [[selectStack]], they must be
assigned colors. If a temp cannot be assigned a color (its neighbors are
using all the available colors), then it must be spilled to memory.
[[rewriteProgram]] is called to add spill temps, fetch instructions, and
store instructions to the \cfg. Graph coloring must start over from the
point of liveness analysis if any temps are spilled. If all the temps can
be assigned colors without requiring any spilling, then the temps are replaced
by the assigned registers in the \cfg, and register allocation is complete.

Additionally, register allocation must handle temporaries in different
register spaces and constructs of irregular architectures, including register
pairs. With multiple register spaces, we want to restrict each temp to the
set of hardware registers in which it will fit. This is equivalent to adding
interference edges between each temp and the hardware registers in which it
cannot be placed. However, we can avoid the trouble of adding these
edges by simply updating the degree of the node to indicate that it
interferes with physical registers in other register spaces.

Traditionally, register pairs have been handled by adding extra edges in the
interference graph, but this is not yet implemented in this allocator.
Additionally, Smith and Holloway suggest that this provides an inaccurate
representation - more thought must be committed here.



from Appel 244:
\begin{quote}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
procedure Main()\\
    LivenessAnalysis()\\
    Build()\\
    MakeWorklist()\\
    [[repeat]]\\
\>      [[if]] simplifyWorklist != \{\} [[then]] Simplify()\\
\>      [[else if]] worklistMoves != \{\} [[then]] Coalesce()\\
\>      [[else if]] freezeWorklist != \{\} [[then]] Freeze()\\
\>      [[else if]] spillWorklist != \{\} [[then]] SelectSpill()\\
    [[until]] simplifyWorklist = \{\} [[and]] worklistMoves = \{\}\\
\>            [[and]] simplifyWorklist = \{\} [[and]] spillWorklist = \{\}\\
    AssignColors()\\
    [[if]] spilledTemps != \{\} [[then]]\\
\>      RewriteProgram(spilledTemps)\\
\>      Main()\\
\end{tabbing}
\end{quote}



%-------------------------------------------------------------------
\subsection{Data Structures}
%-------------------------------------------------------------------

<<graph coloring types>>=
module T = Target
@

<<graph coloring types>>=
module CompareSpace = struct
    type t = Rtl.space
    let compare = compare
end
module SpaceMap = Map.Make(CompareSpace)

module CompareEdge = struct
    type t = Register.t * Register.t
    let compare = compare
end
module EdgeSet = Set.Make(CompareEdge)

type move = G.node
module CompareMoves = struct
    type t = move
    let compare = compare
end
module MS = Set.Make(CompareMoves)

let is_tmp target (s,_,_) = Target.is_tmp target s 
@

Temps and moves are stored in worklists. A temp can only be in one of these
worklists at a time.
We use imperative lists to improve the efficiency of removing items.
WHAT ARE THE MEASUREMENTS THAT JUSTIFY THIS USE?

Worklists are gathered in related groups called [[impListGroup]];
a list item can only be on one of these lists at a time.
Each [[impListGroup]] is polymorphic over the type of the item it carries
and a [[list]] type.
Each item has a [[list]] value that indicates which list (of the list group)
to which the item belongs.
The [[impListGroup]] is represented as a function from the [[list]] type to
an imperative list.
It is a dynamic invariant that each member will have the same [[list]] type as
every other member of its imperative list.

IS IT WORTH PUTTING IMPERATIVE LISTS IN A SEPARATE MODULE?
<<imperative lists>>=
type ('a,'b) impListItem = { v : 'b
                           ; mutable list : 'a
                           ; mutable next : ('a,'b) impListItem option
                           ; mutable prev : ('a,'b) impListItem option
                           }

type ('a,'b) impListGroup = 'a -> ('a,'b) impListItem option ref
@

[[ilg_add]] makes a new item and adds it to the front of the given [[list]]. 
The new list item is returned.
[[ilg_switch]] removes a list item from its current list and placed it on
a new list.
[[ilg_iter]], [[ilg_map]], and [[ilg_filter]] act like their functional counterparts.

<<imperative lists>>=
let ilg_add group list value =
    let item = { v = value
               ; list = list
               ; next = !(group list)
               ; prev = None
               } in
    let () = match item.next with
             | Some n -> n.prev <- Some item
             | None   -> () in
    let () = group list := Some item in
    item

let ilg_switch group list item =
    begin
          (match item.prev with
          | Some p -> p.next <- item.next
          | None   -> group item.list := item.next)
        ; (match item.next with
          | Some n -> n.prev <- item.prev
          | None   -> ())
        ; item.list <- list
        ; item.prev <- None
        ; item.next <- !(group list)
        ; group list := Some item
        ; (match item.next with
          | Some n -> n.prev <- Some item
          | None   -> ())
    end

let rec ilg_iter fn lst =
    match lst with
    | Some n ->
        let next = n.next in    
        let () = fn n     in
        ilg_iter fn next
    | None   -> ()

let rec ilg_map fn lst =
    match lst with
    | Some n -> fn n :: ilg_map fn n.next
    | None   -> []

let rec ilg_filter fn lst =
    match lst with
    | Some n when fn n -> n :: ilg_filter fn n.next
    | Some n -> ilg_filter fn n.next
    | None   -> []
@

For George-Appel iterated register coalescing, we need two list groups: one for temps and one
for move instructions.

<<imperative lists>>=
type tempList = Precolored
              | Initial
              | SimplifyWorklist
              | FreezeWorklist
              | SpillWorklist
              | Spilled
              | Coalesced
              | Colored
              | SelectStack
let str_of_list = function
  | Precolored       -> "Precolored"
	| Initial          -> "Initial"
	| SimplifyWorklist -> "Simplify"
	| FreezeWorklist   -> "Freeze"
	| SpillWorklist    -> "Spill Wlist"
	| Spilled          -> "Spilled Temp"
	| Coalesced        -> "Coalesced"
	| Colored          -> "Colored"
	| SelectStack      -> "Select"

type moveList = CoalescedMove
              | ConstrainedMove
              | FrozenMove
              | WorklistMove
              | ActiveMove
@


The [[colorGraph]] record type represents the interference graph and maintains
the current state of the graph coloring.

\begin{itemize}
\item [[adjSet]]      - a set of all edges in the interference graph, where an edge
                        is represented by a pair of registers
\item [[adjListMap]]  - a map from a temp [[t]] to the list of temps that
                        interfere with [[t]]
\item [[degreeMap]]   - a map containing the current degree of each temp
\item [[moveListMap]] - a map from a temp to the list of move instructions it is
                        involved in
\item [[aliasMap]]    - when a move is coalesced, the coalesced temp must be
                        aliased to the temp we maintain in the graph
\item [[colorMap]]    - map from temp to assigned color
\end{itemize}

Every temp is a member of exactly one of these lists:
\begin{itemize}
\item [[precolored]] - preassigned machine registers
\item [[initial]] - temps, not yet preprocessed for graph coloring
\item [[simplifyWorklist]] - low-degree non-move-related temps
\item [[freezeWorklist]] - low-degree move-related temps
\item [[spillWorklist]] - high-degree temps
\item [[spilledTemps]] - potential spills
\item [[coalescedTemps]] - temps that have been coalesced out of the graph
\item [[coloredTemps]] - temps successfully colored
\item [[selectStack]] - stack of temps removed from the graph
\end{itemize}
These lists are collected in the [[tempLG]] list group.

Every move instruction is in one and only one of these lists:
\begin{itemize}
\item [[coalescedMoves]] - moves that have been coalesced
\item [[constrainedMoves]] - moves whose source and target interfere
\item [[frozenMoves]] - move that will no longer be considered for coalescing
\item [[worklistMoves]] - moves enabled for possible coalescing
\item [[activeMoves]] - moves not yet ready for coalescing
\end{itemize}
These lists are collected in the [[moveLG]] list-group.

Additional information is also stored:
\begin{itemize}
\item [[regToItem]] - map from temps to list-group items
\item [[spills]]    - short-living temps introduced for spilling (spill temps)

\item [[luaColorOverride]] - value set in Lua to override the standard register list
\item [[allColors]] - list of all registers
\item [[colors]]    - map from register spaces to a list of available registers
\item [[k]]         - the number of physical registers
\end{itemize}

<<graph coloring types>>=
type color = Register.t
type 'a colorGraph = { mutable adjSet : EdgeSet.t
                     ; mutable adjListMap : (tempList,Register.t) impListItem list RM.t
                     ; mutable degreeMap : int RM.t
                     ; mutable moveListMap : (moveList,G.node) impListItem list RM.t
                     ; mutable aliasMap : Register.t RM.t
                     ; mutable colorMap : color RM.t
                     ; mutable spills : RS.t

                     ; mutable regToItem : (tempList,Register.t) impListItem RM.t
                     ; mutable tempLG : (tempList, Register.t) impListGroup

                     ; mutable moveLG : (moveList, move) impListGroup

                     ; mutable luaColorOverride : 'a
                     ; mutable allColors : color list
                     ; mutable colors : RS.t SpaceMap.t
                     ; mutable k : int
                     }
@

[[cgInfo]] is the mutable data structure passed around the register allocator.
A function with access to the target must be called to initialize the
information about registers.
[[clearCGInfo]] clears the data structure, leaving only the register lists.

<<init cgInfo>>=
let cgInfo = 
    let pre = ref None in
    let init = ref None in
    let simp = ref None in
    let freez = ref None in
    let spillw = ref None in
    let spilld = ref None in
    let coal = ref None in
    let colo = ref None in
    let sel = ref None in
    let tempFn = function
        | Precolored -> pre
        | Initial -> init
        | SimplifyWorklist -> simp
        | FreezeWorklist -> freez
        | SpillWorklist -> spillw
        | Spilled -> spilld
        | Coalesced -> coal
        | Colored -> colo
        | SelectStack -> sel      in
    let coalm = ref None in
    let constm = ref None in
    let frzm = ref None in
    let workm = ref None in
    let actvm = ref None in
    let moveFn = function
        | CoalescedMove   -> coalm
        | ConstrainedMove -> constm
        | FrozenMove      -> frzm
        | WorklistMove    -> workm
        | ActiveMove      -> actvm in
       { adjSet = EdgeSet.empty
       ; regToItem = RM.empty
       ; adjListMap = RM.empty
       ; degreeMap = RM.empty
       ; moveListMap = RM.empty
       ; aliasMap = RM.empty
       ; colorMap = RM.empty
       ; tempLG = tempFn
       ; spills = RS.empty
       ; moveLG = moveFn

       ; luaColorOverride = V.Nil
       ; colors = SpaceMap.empty
       ; allColors = []
       ; k = 0
       }

let clearCGInfo cg {Proc.cc = colors} = 
    let pre = ref None in
    let init = ref None in
    let simp = ref None in
    let freez = ref None in
    let spillw = ref None in
    let spilld = ref None in
    let coal = ref None in
    let colo = ref None in
    let sel = ref None in
    let tempFn = function
        | Precolored -> pre
        | Initial -> init
        | SimplifyWorklist -> simp
        | FreezeWorklist -> freez
        | SpillWorklist -> spillw
        | Spilled -> spilld
        | Coalesced -> coal
        | Colored -> colo
        | SelectStack -> sel      in
    let coalm = ref None in
    let constm = ref None in
    let frzm = ref None in
    let workm = ref None in
    let actvm = ref None in
    let moveFn = function
        | CoalescedMove   -> coalm
        | ConstrainedMove -> constm
        | FrozenMove      -> frzm
        | WorklistMove    -> workm
        | ActiveMove      -> actvm in
    let () = cg.adjSet <- EdgeSet.empty in
    let () = cg.regToItem <- RM.empty in
    let () = cg.adjListMap <- RM.empty in
    let () = cg.degreeMap <- RM.empty in
    let () = cg.moveListMap <- RM.empty in
    let () = cg.aliasMap <- RM.empty in
    let () = cg.colorMap <- RM.empty in
    let () = cg.tempLG <- tempFn in
    let () = cg.spills <- RS.empty in
    let () = cg.moveLG <- moveFn in

    let () = cg.allColors <- P.allocatable colors in
    let () =
		(match cg.luaColorOverride with
		 | V.Nil      -> ()
		 | V.Number x ->
			let rec firstn n lst =
				if n <= 0 then []
				else (match lst with 
					  | [] -> []
					  | a::rst -> a :: firstn (n - 1) rst) in
			cg.allColors <- firstn (V.int.V.project cg.luaColorOverride) cg.allColors
		| _ -> cg.allColors <- (V.list register).V.project cg.luaColorOverride) in

    let () = cg.k <- List.length cg.allColors in
    false
@

We include two observers for the [[colorGraph]] type. [[possibleColors]]
returns a list of the registers in which the argument temp could be placed.
This list is cached for future lookup.
This cache assumes that the space determines the available registers.
[[regs_in_space]] returns the number of possible registers in which the
argument temp could be placed.

<<graph coloring types>>=
let possibleColors target cg ((s,_,_) as tmp) =
    try SpaceMap.find s cg.colors
    with Not_found ->
        if is_tmp target tmp 
        then
            let colSet = List.fold_left (fun set reg -> if Target.fits target s reg
                                                        then RS.add reg set else set)
                                        RS.empty cg.allColors in
            let () = cg.colors <- SpaceMap.add s colSet cg.colors in
            colSet
        else RS.singleton tmp
 
let regs_in_space target cg temp =
    if is_tmp target temp
    then RS.cardinal (possibleColors target cg temp)
    else cg.k
@


%-------------------------------------------------------------------
\subsection{Graph Coloring Stages}
%-------------------------------------------------------------------

%-------------------------------------------------------------------
\subsubsection{Build}
%-------------------------------------------------------------------

Using the liveness information, we can build the interference graph by
scanning the \cfg  and recording temps that interfere.
The build stage requires that liveness analysis has been performed on the
\cfg  and the cgInfo data structure has been initialized.

[[resetDegree]] resets the degree of a temp. It should not necessarily be reset to 0
because the temp must interfere with registers in other register spaces.
Instead, we set $degree[t] = K - R$, where $K$ is the total number of registers and
$R$ is the number of registers in temp $t$'s register space.

The predicate [[interfere]] determines whether two registers interfere.

<<build>>=
let resetDegree target cg temp =
    cg.degreeMap <-
        RM.add temp (cg.k - (regs_in_space target cg temp)) cg.degreeMap

let interfere (s1,_,_ as t1) (s2,_,_ as t2) target cg =
    s1 = s2 ||
        let s1 = possibleColors target cg t1 in    
        let s2 = possibleColors target cg t2 in
            not (RS.is_empty (RS.inter s1 s2))
@

We don't add an edge to the interference graph if it already exists or if
the variables do not actually interfere (e.g. they are in non-intersecting register
spaces). Also, we don't need to keep track of the neighbors of precolored temps.

<<build>>=
let addEdge target cg u v =
    if (not ((EdgeSet.mem (u, v) cg.adjSet) || (u = v))) &&
       interfere u v target cg
    then begin
        let () = cg.adjSet <- List.fold_right EdgeSet.add [(u, v); (v, u)] cg.adjSet in
        let addToAdjList t1 t2 =
            if is_tmp target t1 (* t1 <> Precolored *)
            then begin
                cg.adjListMap <- listMapAdd (RM.find t2 cg.regToItem) t1 cg.adjListMap;
                cg.degreeMap  <- RM.add t1 (RM.find t1 cg.degreeMap + 1) cg.degreeMap
            end in
        let () = addToAdjList u v in
        let () = addToAdjList v u in
        ()
	end
@

Before building the interference graph, we must reset the degree of every
temp in the \cfg. Also, we reset the [[initial]] and [[precolored]] sets of
the [[cg]] record.
Then, we build the interference graph by folding over every node of the \cfg,
adding interferences as necessary.
We also build a map ([[regToItem]]) from a register to a listgroup item.

<<build>>=
let build cg {Proc.cfg = cfg; Proc.target = target} =
    let () = if not (!(cg.tempLG Initial) = None) then
               Impossible.impossible "Temps on initial list prematurely" in
    let regs =
      G.fold_nodes (fun node allregs -> G.defs node ++ G.uses node ++ allregs)
      RS.empty cfg in
    let regMap =
        RS.fold (fun r map -> resetDegree target cg r
                            ; if is_tmp target r
                              then RM.add r (ilg_add cg.tempLG Initial r) map
                              else RM.add r (ilg_add cg.tempLG Precolored r) map)
                regs cg.regToItem in
    let () = cg.regToItem <- regMap in
    <<addInterference>>
    G.iter_nodes addInterference cfg;
    true
@
We add an edge between the temps defined in an instruction and those that
are live after this instruction [[node]]. Note that the defined temps must
interfere with each other. If [[node]] is a move instruction of the form
$t_1 = t_2$, then $t_2$ will not be live after this instruction;
furthermore, we track this instruction and the temps involved for possible
coalescing.

TEST CASE: try an instruction with multiple defs. Each def must interfere with the
other defs.
<<addInterference>>=
let addInterference node =
  let live = LI.live_out node in
  let defs = G.defs node in
  let live =
    if isMoveInstruction target node then
      let uses = G.uses node in
      (let item = ilg_add cg.moveLG WorklistMove node in
      cg.moveListMap <- RS.fold (listMapAdd item)
	  (defs ++ uses) cg.moveListMap;
      RS.diff live uses)
    else
      live in
  let live = live ++ defs in
  let addAllEdges def =
    RS.iter (fun liveNode -> addEdge target cg liveNode def) live in
  RS.iter addAllEdges defs in
@

%-------------------------------------------------------------------
\subsubsection{MakeWorkList}
%-------------------------------------------------------------------

Before beginning the graph coloring algorithm, the temps must be separated
into worklists:
\begin{itemize}
\item Temps with high degree are placed on the [[spillWorklist]]
\item Move-related temps are placed on the [[freezeWorklist]]
\item Low-degree, non-move-related temps are placed on the [[simplifyWorklist]]
\end{itemize}

<<makeWorklist>>=
<<temp observers>>

let makeWorklist cg _ = 
    let addToLists = function
        | temp when RM.find temp.v cg.degreeMap >= cg.k ->
            ilg_switch cg.tempLG SpillWorklist temp
        | temp when moveRelated temp cg ->
            ilg_switch cg.tempLG FreezeWorklist temp
        | temp ->
           ilg_switch cg.tempLG SimplifyWorklist temp in
    let () = ilg_iter addToLists (!(cg.tempLG Initial)) in
        true
@

It is useful to have observers that take a [[temp]] as an argument and
return other temps with which [[temp]] interferes, moves in which [[temp]] is
involved, or whether [[temp]] is move-related.

<<temp observers>>=
let adjacent temp cg =
    List.filter (fun t -> t.list <> SelectStack && t.list <> Coalesced)
                (listMapFind temp cg.adjListMap)

let nodeMoves temp cg =
    List.filter (fun t -> t.list = ActiveMove || t.list = WorklistMove)
                (listMapFind temp.v cg.moveListMap)

let moveRelated temp cg =
    not (empty (nodeMoves temp cg))
@

%-------------------------------------------------------------------
\subsubsection{Simplify}
%-------------------------------------------------------------------

The [[simplify]] stage of graph coloring removes the easy-to-color temps in 
the [[simplifyWorklist]] from the interference graph. As temps are removed from
the graph, the degrees of adjacent temps will decrease, possibly changing
high-degree temps into easily colored low-degree temps and allowing
previously constrained moves to be coalesced.

<<simplify>>=
<<remove temp>>

let simplify cg {Proc.target = t} =
	(match !(cg.tempLG SimplifyWorklist) with
	| Some temp ->
		let () = ilg_switch cg.tempLG SelectStack temp in
		let () = List.iter (decrementDegree cg t) (adjacent temp.v cg) in
			true
	| None -> false)
@

For each of the [[temps]], [[enableMoves]] will allow previously uncoalescable
moves to be reconsidered in the next coalescing phase.

<<remove temp>>=
let enableMoves temps cg =
    let enableMove move =
        if move.list = ActiveMove
        then ilg_switch cg.moveLG WorklistMove move
    in
        List.iter (fun temp -> List.iter enableMove (nodeMoves temp cg)) temps
@

When the degree of a temp is decremented, we also check whether the temp is
now of low-degree. If so, we enable moves in which this temp is involved, and
we place the temp on the appropriate worklist.

<<remove temp>>=
let decrementDegree cg target temp =
    let d  = RM.find temp.v cg.degreeMap in
    let () = cg.degreeMap <- RM.add temp.v (d - 1) cg.degreeMap in
        if d = cg.k
        then begin
            enableMoves (temp::(adjacent temp.v cg)) cg;
            if moveRelated temp cg
            then ilg_switch cg.tempLG FreezeWorklist temp
            else ilg_switch cg.tempLG SimplifyWorklist temp
        end
@

%-------------------------------------------------------------------
\subsubsection{Coalesce}
%-------------------------------------------------------------------

When two temps are connected by a move instruction, it is often possible to
coalesce them into a single temp and eliminate the move instruction. It may
not be possible to do this if the two temps interfere or if coalescing the
temps will yield a graph that can no longer be colored using K colors.
We use the Appel and George coalescing heuristic when attempting to coalesce
a pre-colored node with a non-precolored temp, and we use the Briggs coalescing
test for two non-precolored temps.

There are four possible cases for moves on the [[worklistMoves]] list:
\begin{itemize}
\item The source and destination of the move are the same temp
\item The source and destination of the move are both precolored, or they
      interfere; we will never be able to coalesce this move
\item The move may be safely coalesced
\item It is not yet safe to coalesce this move
\end{itemize}

<<coalesce>>=
let rec nodup cmp = function
    | x::(y::_ as tail) -> if cmp x y = 0
                           then nodup cmp tail
                           else x :: nodup cmp tail
    | x                 -> x

let uniq nodes = nodup compare (List.sort compare nodes)

<<coalesce move>>

let coalesce cg ({Proc.target = target} as proc) =
    (match !(cg.moveLG WorklistMove) with
    | Some move ->
        let get m = RM.find (getAlias (RM.find m cg.regToItem) cg) cg.regToItem in
        let x = get (source move.v) in
        let y = get (dest   move.v) in
        let (u, v) = if y.list = Precolored then (y, x) else (x, y) in
        let () =
            if u = v
            then begin
                 ilg_switch cg.moveLG CoalescedMove move
               ; addWorklist u cg
            end else if (v.list = Precolored) || (EdgeSet.mem (u.v, v.v) cg.adjSet)
                then begin
                     ilg_switch cg.moveLG ConstrainedMove move
                   ; addWorklist u cg
                   ; addWorklist v cg
            end else if ((u.list = Precolored) &&
                     (List.fold_left (fun rst t -> (ok t u cg) && rst)
                                     true (adjacent v.v cg))
                    || ((not (u.list = Precolored)) &&
                        (conservative (uniq ((adjacent u.v cg) @ (adjacent v.v cg)))
                                      cg)))
                then begin
		               let (keep,coal) = if RS.mem u.v cg.spills then (v,u) else (u,v) in
										 ( ilg_switch cg.moveLG CoalescedMove move
										 ; combine target keep coal cg
										 ; addWorklist keep cg
										 )
            end else
                ilg_switch cg.moveLG ActiveMove move
        in true
    | None -> false)
@

When moves are coalesced or constrained, the temps involved are placed on
the [[simplifyWorklist]].

<<coalesce move>>=
let addWorklist temp cg =
    if not ((temp.list = Precolored) || (temp.list = Coalesced) ||
            (moveRelated temp cg) || (RM.find temp.v cg.degreeMap >= cg.k))
    then ilg_switch cg.tempLG SimplifyWorklist temp
@

[[ok]] is the heuristic for coalescing pre-colored temps. [[tempr]] is the
pre-colored temp, and [[tempt]] is a temp adjacent to $tempv$, where we are
trying to coalesce $tempv$ with [[tempr]], and $tempv$ is not pre-colored.

<<coalesce move>>=
let ok tempt tempr cg =
       (RM.find tempt.v cg.degreeMap < cg.k)
    || (tempt.list = Precolored)
    || (EdgeSet.mem (tempt.v, tempr.v) cg.adjSet)
@

[[conservative]] implements the Briggs coalescing heuristic, which verifies
that the temps we are trying to coalesce have fewer than K significant-degree
neighbors.

<<coalesce move>>=
let conservative neighbors cg =
    cg.k > (List.fold_left
               (fun k temp ->
                    if RM.find temp.v cg.degreeMap >= cg.k then k + 1 else k)
                0 neighbors)
@

[[getAlias]] returns the temp with which [[node]] has been coalesced.

<<coalesce move>>=
let rec getAlias node cg =
  try
    if node.list = Coalesced
    then getAlias (RM.find (RM.find node.v cg.aliasMap) cg.regToItem) cg
    else node.v
  with Not_found -> Impossible.impossible "Not_found in Colorgraph.getAlias"
@

[[combine]] coalesces the temp [[v]] with the temp [[u]]. [[v]]'s neighbors
and moves must be added to [[u]].

<<coalesce move>>=
let combine target u v cg =
    let () = ilg_switch cg.tempLG Coalesced v in
    let () = cg.aliasMap <- RM.add v.v u.v cg.aliasMap in
    let moves = listMapFind u.v cg.moveListMap @ listMapFind v.v cg.moveListMap in
    let () = cg.moveListMap <- RM.add u.v moves cg.moveListMap in
    let () = enableMoves [v] cg in
    let () = List.iter (fun temp -> addEdge target cg temp.v u.v
                                  ; decrementDegree cg target temp)
                       (adjacent v.v cg) in
	if (RM.find u.v cg.degreeMap >= cg.k) && (u.list = FreezeWorklist)
	then ilg_switch cg.tempLG SpillWorklist u
@

%-------------------------------------------------------------------
\subsubsection{Freeze}
%-------------------------------------------------------------------

If we cannot simplify or coalesce a move, we choose a move-related,
low-degree temp and freeze the moves it is involved in. We will no longer
consider the frozen moves for coalescing, which will allow this temp to be
simplified. Also, other temps may become non-move-related, allowing them to
be simplified.

Their is a policy decision of which temp to freeze; currently, the choice is
rather arbitrary.

<<freeze>>=
<<freeze move>>

let freeze cg _ =
   (match !(cg.tempLG FreezeWorklist) with
        | Some temp ->
            (ilg_switch cg.tempLG SimplifyWorklist temp
            ; freezeMoves temp cg
            ; true)
        | None -> false)
@

When a move is frozen, it must be removed from the [[activeMoves]] list.  Also,
if a low-degree temp becomes non-move-related when a move is frozen, this
temp can be simplified from the interference graph.

<<freeze move>>=
let freezeMoves temp cg =
    let freezeMove move =
        let x = RM.find (source move.v) cg.regToItem in
        let y = RM.find (dest move.v) cg.regToItem in
        let v = if (getAlias y cg) = (getAlias temp cg)
                then RM.find (getAlias x cg) cg.regToItem
                else RM.find (getAlias y cg) cg.regToItem in
        let () = ilg_switch cg.moveLG FrozenMove move in
		if (v.list <> Precolored && empty (nodeMoves v cg)) &&
		   (RM.find v.v cg.degreeMap < cg.k)
		then ilg_switch cg.tempLG SimplifyWorklist v
    in List.iter freezeMove (nodeMoves temp cg)
@

%-------------------------------------------------------------------
\subsubsection{Select Spill}
%-------------------------------------------------------------------

We perform optimistic spilling, allowing high-degree nodes to be removed
from the graph as a last option, in the hope that we will still be able to
assign colors to these nodes.

The choice of which node to spill here is an important policy decision.

<<selectSpill>>=
let selectSpill cg {Proc.cfg = cfg} =
	let rec findSpill lst =
		match lst with
		| Some t when not (RS.mem t.v cg.spills) ->
			let () = ilg_switch cg.tempLG SimplifyWorklist t in
			let () = freezeMoves t cg in
			true
		| Some t -> findSpill t.next
		| None when !(cg.tempLG SpillWorklist) = None -> false
		| None ->    (* only spill temps on spillworklist -> bug!!! *)
			( print_cfg    cfg
			; print_cgInfo cg
			; Impossible.impossible ("only spill temps remain on spillworklist!")
			) in
	findSpill (!(cg.tempLG SpillWorklist))
@

%-------------------------------------------------------------------
\subsubsection{Assign Colors}
%-------------------------------------------------------------------

We attempt to color the graph by popping temps off the select stack and
choosing a color that is not used by the temp's neighbors. If there is no
such color, we must spill the temp. After coloring the temps on the select
stack, we assign colors to the coalesced nodes if there were no .

The [[GraphColoring]] exception is raised if the graph is uncolorable.

<<assignColors>>=
exception GraphColoring

let assignColors cg {Proc.target = target; Proc.cfg = cfg} =
    <<colorTemp>>
    let colorSelectStack () =
        let () = ilg_iter colorTemp (!(cg.tempLG SelectStack)) in
		if not (!(cg.tempLG SelectStack) = None)
   		then Impossible.impossible "Failed to color a temp?"   in
    let colorCoalescedTemps () =
        let setColor temp = 
            cg.colorMap <- RM.add temp.v (colorLookup temp.v cg.colorMap) cg.colorMap in
		ilg_iter setColor (!(cg.tempLG Coalesced)) in
    let () = colorSelectStack () in
    let () = match !(cg.tempLG Spilled) with
             | None -> colorCoalescedTemps ()
             | _    -> () in
		true
@

[[colorTemp]] is responsible for coloring a single temp. The possible colors
([[okColors]]) are calculated by excluding colors that used by neighbors
temps. If any colors remain, we color the temp with one of them; otherwise,
we must spill a temp.

The choices of colors assigned and neighbors spilled is a policy
decision, currently arbitrary.

<<colorTemp>>=
let colorLookup temp cmap =
  let t = getAlias (RM.find temp cg.regToItem) cg in
  if is_tmp target t
  then try RM.find t cmap
       with Not_found -> Impossible.impossible "colorLookup(): uncolored temp"
  else t in

let colorTemp temp =
	let removeUsedColor colors adjTemp =
		let t = RM.find (getAlias adjTemp cg) cg.regToItem in
		if t.list = Colored || t.list = Precolored
		then RS.remove (colorLookup t.v cg.colorMap) colors
		else colors in
	let possColors = possibleColors target cg temp.v in
	let okColors =
		List.fold_left removeUsedColor possColors (listMapFind temp.v cg.adjListMap) in

	if RS.is_empty possColors
	then Impossible.impossible ("No hardware register available for " ^ (printReg temp.v))
	else if RS.is_empty okColors
	then begin
		if (RS.mem temp.v cg.spills)
		then begin
			  print_cfg    cfg
			; print_cgInfo cg
		  ; Impossible.impossible ("Spilling a spill temp: " ^ printReg temp.v)
		end 
		else ilg_switch cg.tempLG Spilled temp
	end else begin
		cg.colorMap <- RM.add temp.v (RS.choose okColors) cg.colorMap
	  ; ilg_switch cg.tempLG Colored temp
	end in
@

%-------------------------------------------------------------------
\subsubsection{Apply Colors}
%-------------------------------------------------------------------

[[applyColors]] is used to replace the temps in the \cfg with the colors they
are assigned. If a temp has not been assigned a color yet, the impossible
exception will be raised; This indicates an error in the graph coloring
implementation.

<<applyColors>>=
module CallVarMap = Map.Make (struct type t = G.node let compare = compare end)

let applyColors cg ({Proc.cfg = cfg; Proc.target = target; Proc.varMap = vMap}) =
  let () = print_cgInfo cg in
  let find ((s, i, _) as t) =
    try RM.find t cg.colorMap
    with
      Not_found -> Impossible.impossible (Printf.sprintf "Uncolored temp %c%d" s i) in
  let subst t = if is_tmp target t then find t else t in
  (* Will throw an exception on a variable that has been spilled - obviously
     it hasn't been assigned a register; dealing with spills must be thought
	 out and handled at spill time
  let new_placement var loc rst =
    match loc with
    | Rtl.Private.Reg t when is_tmp target t -> VM.add var (find t) rst
    | _ -> rst in
	*)
  let subst_rtl node call_varMap =
    begin
      G.upd_instr node (Rtlutil.Subst2.reg ~map:subst);
	  (*
      if G.is_call node then
        CallVarMap.add node (VM.fold new_placement vMap VM.empty) call_varMap
      else
        call_varMap
		*)
	  call_varMap
    end in
  let _ = G.fold_nodes subst_rtl CallVarMap.empty cfg in
  true
@

%-------------------------------------------------------------------
\subsubsection{Reset/Update Program}
%-------------------------------------------------------------------

After an iteration of graph coloring in which spilled temps are generated,
resetProgram inserts the necessary loads and stores to spill the temps in
the \cfg and resets the [[cg]] structure for another round of graph coloring.

<<resetProgram>>=
<<insert spills>>

let resetProgram cg proc =
    (* handle addition of new temps to the cfg (those in spilledTemps) *)
    let newTemps = rewrite proc (!(cg.tempLG Spilled)) in
    let () = if not (!(cg.tempLG Initial) = None)
             then Impossible.impossible "temps still on initial list" in

    let () = List.iter (fun t -> cg.spills <- RS.add t cg.spills) newTemps in

    let () = cg.tempLG Precolored := None in
    let () = cg.tempLG Initial := None in
    let () = cg.tempLG SimplifyWorklist := None in
    let () = cg.tempLG FreezeWorklist := None in
    let () = cg.tempLG SpillWorklist := None in
    let () = cg.tempLG Spilled := None in
    let () = cg.tempLG Coalesced := None in
    let () = cg.tempLG Colored := None in
    let () = cg.tempLG SelectStack := None in

    let () = cg.moveLG CoalescedMove   := None in
    let () = cg.moveLG ConstrainedMove := None in
    let () = cg.moveLG FrozenMove      := None in
    let () = cg.moveLG WorklistMove    := None in
    let () = cg.moveLG ActiveMove      := None in

    let () = cg.adjSet <- EdgeSet.empty in
    let () = cg.regToItem <- RM.empty in
    let () = cg.adjListMap <- RM.empty in
    let () = cg.degreeMap <- RM.empty in
    let () = cg.moveListMap <- RM.empty in
    let () = cg.aliasMap <- RM.empty in
    let () = cg.colorMap <- RM.empty in
        true
@

The simple predicate [[haveSpilledTemps]] may be used to determine whether
the graph coloring algorithm has terminated.

<<resetProgram>>=
let haveSpilledTemps cg _ =
    not (!(cg.tempLG Spilled) = None)
@

[[updateProgram]] removes coalesced moves from the \cfg. It may be desirable
to call this stage even after graph coloring has succeeded in placing every
temp.
<<resetProgram>>=
let updateProgram cg {Proc.cfg = cfg} =
  let delete_move n =
    let succ = G.succ n in
    G.set_succ n ~succ:(G.illegal cfg);
    G.set_succ (G.pred n) ~succ;
    G.delete cfg n                      in
  let () = ilg_iter (fun n -> delete_move n.v) (!(cg.moveLG CoalescedMove)) in
  true
@

A pair of convenience functions for adding lists of \cfg nodes:

<<insert spills>>=
let cfg_ins_lst_before lst node =
  ignore (List.fold_right G.gm_insert_assign_before lst node)
let cfg_ins_lst_after lst node =
  ignore (List.fold_left  G.gm_insert_assign_after node lst)
@

The [[reads_writes]] function checks whether a location [[loc]] is
read or written by an {\rtl}.  It returns a pair $(r,w)$ of [[bool]]
values.  The first component $r$ is true iff [[loc]] is read by
[[rtl]], the second $w$ iff [[loc]] is written by [[rtl]].

<<insert spills>>=
let reads_writes rtl loc =
	let read  reg (r,w) = (r || loc = reg, w) in
	let write reg (r,w) = (r, w || loc = reg) in
	Rtlutil.ReadWrite.fold ~read ~write rtl (false,false)
@

The heart of the spiller is [[update]] that is applied to every
[[node]] in the \cfg.  If [[node]] reads or writes the [[spillee]],
it must be updated such that it uses a new temporary [[tmp]] instead.
Before and after the node, [[tmp]] must be read from or written to the
memory location [[mem]], where the value of the spillee is held.

<<insert spills>>=
let update proc (spillee, mem) node =
  let target = proc.Proc.target in
  let reads, writes = reads_writes (G.instr node) spillee in
  let lookup = Target.space target in
  if reads || writes then
    let tmp   = Talloc.Multiple.reg_like proc.Proc.temps spillee in
    let subst = fun x -> if x = spillee then tmp else x in 
    ( if reads then 
        (cfg_ins_lst_before (target.T.reload lookup tmp mem) node)
    ; if writes then 
        (cfg_ins_lst_after  (target.T.spill  lookup tmp mem) node)
    ; G.upd_instr node (Rtlutil.Subst2.reg ~map:subst)
    ; Some tmp
    )
  else
    None
@

In addition to adding store and fetch instructions to replace the spilled
temps in the \cfg, [[rewrite]] returns the new spill temps that are
generated.

<<insert spills>>=
let rewrite proc spillees =
	let smPairs = ilg_map (fun s -> (s.v, P.spill_slot_for proc s.v)) spillees in 
	(* newTemps is an accumulating param *)
	let updateNode smPairs node newTemps =
		(List.fold_left
			(fun tmps sm -> match update proc sm node with
							| None -> tmps
							| Some tmp -> tmp::tmps)
			newTemps smPairs)
	in
		G.fold_nodes (updateNode smPairs) [] proc.Proc.cfg
@


%-------------------------------------------------------------------
\subsubsection{Common Utilities}
%-------------------------------------------------------------------

    (* check whether two temps interfere - whether they have overlapping reg
     * sets.
     * this may also be misleading - if they only partially overlap, this
     * may or may not be a good way to indicate interference - see the
     * smith, holloway paper....
     *)

The node observers are mostly straightforward. [[isMoveInstruction]]
verifies that the instruction is an assignment from one temp to another,
where both are in the same register space.

<<node observers>>=
let source inst =
	match Rtlutil.RTLType.singleAssignment (G.instr inst) with
	| Some (s, _) -> s
	| _           -> Impossible.impossible "bug in singleAssignment()"
let dest inst =
	match Rtlutil.RTLType.singleAssignment (G.instr inst) with
	| Some (_, d) -> d
	| _           -> Impossible.impossible "bug in singleAssignment()"

(*
 * singleAssignment returns a (Register.t * Register.t) option
 * First get the assignment, then verify that the source and dest are
 * in the same reg. space
 *)
let isMoveInstruction t inst =
  (* WE NEED TO DISCUSS HOW TO HANDLE THIS PROPERLY: V IS NOT A SPACE
     IN THE TARGET, WHICH MEANS THE FUNCTIONS IN TARGET2.NW DON'T WORK *)
  let isVFP (s,_,_) = s = 'V' in
  match Rtlutil.RTLType.singleAssignment (G.instr inst) with
	| Some (((s1,_,_) as r1), ((s2,_,_) as r2)) ->
	  (not (isVFP r1 || isVFP r2)) &&
   	  (s1 = s2 || (is_tmp t r1 && Target.fits t s1 r2)
               || (is_tmp t r2 && Target.fits t s2 r1))
	| _ -> false
@


The interface provides the modules to embed the graph coloring functions in the
Lua interpreter.

<<support for old backplane that can be removed from colorgraph.mli>>=
module GCT : Lua.Lib.USERTYPE
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.M.action)
            (GCT : Lua.Lib.TYPEVIEW with type 'a t = 'a GCT.t
                                  and type 'a combined = 'a BackplaneT.combined)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Proc.t
                                  and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.USERCODE with type 'a userdata' = 'a BackplaneT.combined

<<colorgraph.mli>>=
module NewGCT : Lua.Lib.USERTYPE
module NewMake (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.M'.action)
            (GCT : Lua.Lib.TYPEVIEW with type 'a t = 'a NewGCT.t
                                  and type 'a combined = 'a BackplaneT.combined)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Ast2ir.proc
                                  and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.USERCODE with type 'a userdata' = 'a BackplaneT.combined
@

A few convenience functions for handling lists. Perhaps the lists that use
the set operations should be converted to register sets.

<<list as set>>=
let empty lst = match lst with
	| [] -> true
	| _ -> false

let listMapFind key listMap =
	try RM.find key listMap with Not_found -> []
let listMapAdd value key listMap =
	RM.add key (value::(listMapFind key listMap)) listMap
@

\subsection{Lua registration}

<<colorgraph.ml>>=
module RM = Register.Map
module RS = Register.Set
let ( ++ ) = RS.union 
<<imperative lists>>
module type GRAPH = sig
  type cfg
  type node
  val instr    : node -> Rtl.rtl
  val num      : node -> int
  val illegal  : cfg -> node
	val print_node : node -> string
  val node_info_string : node -> string
  val defs : node -> Register.Set.t  (* includes kills!!! *)
  val uses : node -> Register.Set.t
  val upd_instr : node -> (Rtl.rtl -> Rtl.rtl) -> unit
  val is_call : node -> bool
  val set_succ: node -> succ:node -> unit
  val gm_insert_assign_after:     node -> Rtl.rtl -> node (* after assign! *)
  val gm_insert_assign_before:    Rtl.rtl -> node -> node (* any node   *)

	val preds : node -> node list
	val pred  : node -> node
	val succs : node -> node list
	val succ  : node -> node

  val delete     : cfg -> node -> unit
  val fold_nodes : (node->'a -> 'a) -> 'a -> cfg -> 'a
  val iter_nodes : (node->unit) -> cfg -> unit
  val eq : node -> node -> bool

end
<<colorgraph.ml>>=
module type LIVENESS = sig
  type node
  val live_out : node -> Register.Set.t
end

<<colorgraph.ml>>=
module NewG : GRAPH with type node = Rtl.rtl Cfgx.M.node
                    with type cfg  = Rtl.rtl Cfgx.M.cfg = struct
  module G = Cfgx.M
  type node = Rtl.rtl G.node
  type cfg  = Rtl.rtl G.cfg
	let print_node = G.print_node
  let node_info_string n = "???"

  let nop = Rtl.par []
  let instr n = Aux.Option.get nop (G.to_instr n)
  let illegal = G.illegal
	let preds = G.preds
	let pred  = G.pred
	let succs = G.succs
	let succ  = G.succ
  let num n = G.num n
  let iter_nodes = G.iter_nodes
  let fold_nodes = G.fold_nodes
  let eq = G.eq

  let irwk = Rtlutil.ReadWriteKill.sets
  let defs node =
    let defs = match G.to_instr node with
    | None   -> RS.empty
    | Some i -> let uses, defs, kills = irwk i in defs ++ kills in
    G.union_over_outedges node (fun n -> defs)
      (fun {G.node = n'; G.defs = d; G.kills = k} -> defs ++ d ++ k)
      
  let uses node =
    let uses = match G.to_instr node with
    | None   -> RS.empty
    | Some i -> let uses, defs, kills = irwk i in uses in
    G.add_inedge_uses node uses
    
  let upd_instr n f = G.update_instr f n
  let is_call n = G.kind n = G.Call

  let insert_assign splice node rtl =
    let g = G.of_node node in
    let n' = G.instruction g rtl (G.illegal g) in
    splice ~entry:n' ~exit:n' node;
    n'

  let set_succ = G.set_succ
  let gm_insert_assign_after = insert_assign G.splice_after
  let gm_insert_assign_before r n = insert_assign G.splice_before n r
  let delete = G.delete
end
<<colorgraph.ml>>=
module NewL : LIVENESS with type node = NewG.node = struct
  module G = Cfgx.M
  type node = Rtl.rtl G.node
  let live_out = Cfgx.Live.live_out
end
<<colorgraph.ml>>=
module type PROC = sig
  type automaton
  type cfg
  type cc
  type automatonspec
  type tgt = (automatonspec, cc) Target.t
  type t = (automaton, cfg, cc, tgt) Proc.t
  val allocatable : cc -> Register.t list
  val spill_slot_for : t -> Register.t -> Automaton.loc
  (* let spill_slot_for (_, _, w) proc = Automaton2.allocate proc.Proc.priv w None *)

end

<<colorgraph.ml>>=
module PreMake (G : GRAPH) (LI : LIVENESS with type node = G.node) 
               (P : PROC with type cfg = G.cfg) 
               (N : sig val name : string end) = struct

  <<graph coloring types>>
  module GCT : Lua.Lib.USERTYPE with type 'a t = 'a colorGraph = struct
      type 'a t = 'a colorGraph
      let tname = "Graph Coloring"
      let eq _ x y = x = y
      let to_string vs _ = "<cgInfo>"
  end
  module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.M'.action)
              (GCT : Lua.Lib.TYPEVIEW with type 'a t = 'a GCT.t
                                    and type 'a combined = 'a BackplaneT.combined)
              (ProcT : Lua.Lib.TYPEVIEW with type 'a t = P.t
                                    and type 'a combined = 'a BackplaneT.combined)
         : Lua.Lib.USERCODE with type 'a userdata' = 'a BackplaneT.combined =
    struct
      type 'a userdata' = 'a BackplaneT.combined
      module M (Interp : Lua.Lib.CORE
                  with type 'a V.userdata' = 'a BackplaneT.combined) = struct
          module V = Interp.V
          let cgmap = GCT.makemap V.userdata V.projection
  
                  module RT = Register.RT (Interp)
                  let register = RT.map
  
          <<graph coloring builtins>>
  
          let init g =
            Interp.register_module N.name graph_coloring_module g;
            Lua.Lib.StringList.empty (* FIX -- replace with init code *)
      end
    end
end
<<support for old backplane, can be removed from colorgraph.ml>>=
module OldProc = struct
  type automaton = Automaton2.t
  type automatonspec = Automaton2.spec
  type cfg = Cfg4.cfg
  type cc = Automaton2.spec Target.cc'
  type tgt = (Automaton2.spec, cc) Target.t'
  type t = (automaton, cfg, cc, tgt) Proc.t'
  let allocatable cc = cc.Target.allocatable
  let spill_slot_for proc (_, _, w)  =
    Automaton.of_old (Automaton2.allocate proc.Proc.priv w None)

end

module Old = PreMake (OldG) (OldL) (OldProc) (struct let name = "ColorGraph" end)
<<colorgraph.ml>>=
module NewProc = struct
  module C = Call
  type automaton = Automaton.t
  type automatonspec = Rtl.exp->Automaton.t
  type cfg = Rtl.rtl Cfgx.M.cfg
  type cc = Call.t
  type tgt = (automatonspec, cc) Target.t
  type t = (automaton, cfg, cc, tgt) Proc.t
  let allocatable cc = RS.elements (cc.C.pre_nvregs ++ cc.C.volregs)
  let spill_slot_for proc (_, _, w)  = Automaton.allocate proc.Proc.priv w ""
end

module New = PreMake (NewG) (NewL) (NewProc) (struct let name = "NewColorGraph" end)
@ 
<<support for olf backplane, can be removed from colorgraph.ml>>=
module GCT = Old.GCT
module Make = Old.Make

<<colorgraph.ml>>=
module NewGCT = New.GCT
module NewMake = New.Make
@



<<graph coloring builtins>>=
    let cfgSay = Verbose.say 18
    let cgSay = cfgSay

    <<list as set>>
    <<node observers>>
    <<print CGInfo>>
    <<init cgInfo>>
    <<build>>
    <<makeWorklist>>
    <<simplify>>
    <<coalesce>>
    <<freeze>>
    <<selectSpill>>
    <<assignColors>>
    <<applyColors>>
    <<resetProgram>>
@

Embedding the functions in the Lua interpreter.

<<graph coloring builtins>>=
let proc = ProcT.makemap V.userdata V.projection
let ( **-> ) = V.( **-> )
let stageFn  = cgmap **-> proc **-> V.result V.bool
let graph_coloring_module =
  [ "build",            V.efunc stageFn build
  ; "makeWorklist",     V.efunc stageFn makeWorklist
  ; "simplify",         V.efunc stageFn simplify
  ; "coalesce",         V.efunc stageFn coalesce
  ; "freeze",           V.efunc stageFn freeze
  ; "selectSpill",      V.efunc stageFn selectSpill
  ; "assignColors",     V.efunc stageFn assignColors
  ; "haveSpilledTemps", V.efunc stageFn haveSpilledTemps
  ; "clearCGInfo",      V.efunc stageFn clearCGInfo
  ; "resetProgram",     V.efunc stageFn resetProgram
  ; "updateProgram",    V.efunc stageFn updateProgram
  ; "applyColors",      V.efunc stageFn applyColors
  ; "printCG",          V.efunc stageFn printCGInfo
  ; "printCFGLive",     V.efunc stageFn printCFGLive
  ; "pCFG",             V.efunc stageFn pCFG
  ; "cgInfo",           cgmap.V.embed cgInfo
  ; "setRegisters",     V.efunc (V.value **-> V.result V.unit)
      (fun value -> cgInfo.luaColorOverride <- value
	          ; cgInfo.colors           <- SpaceMap.empty)
  ]
@

\subsubsection{Lua startup code}
This startup code sets up the right passes.
<<Lua startup code for [[Colorgraph]] module>>=
------------------------------------------------------------------ 
-- Graph-Coloring Register Allocator
------------------------------------------------------------------ 

Liveness = Liveness or {}
function Liveness.backend(v, proc) 
  return backend.liveness(v, proc)
end

function ColorGraph_init (CG, B) -- carefully don't define table
  CG = CG or error('predefined ColorGraph is nil??') -- has some primitives

  CG.makeGraph = 
    B.seq {
      { fn = Liveness.backend, creates = 'liveness' },
         -- can't use backend.liveness directly since it might change
      { fn = CG.build, uses = {'liveness', 'no vars'}, creates = 'no temps' }
    } 
      
  CG.pcg  = B.ignore(CG.printCG)
  CG.pcfg = B.ignore(CG.pCFG)
  
  CG.orderVars = B.seq 
      { CG.makeWorklist
      , B.fix(B.unless_do(CG.simplify,
                              B.unless_do(CG.coalesce,
                                  B.unless_do(CG.freeze,
                                      CG.selectSpill))))
      }

  CG.color = 
    B.share
      ( CG.cgInfo
      , "cgInfo"
      , B.seq 
          { CG.clearCGInfo
          , CG.pcfg
          , B.fix 
              ( B.seq 
                  { B.ignore (B.seq
                      { CG.makeGraph
        							, CG.pcg
                      , CG.orderVars
											, CG.pcg
                      , CG.assignColors
                      })
                  , 
                    B.when_do
                      ( CG.haveSpilledTemps
                      , CG.resetProgram
                      )
                  } 
              )
          , B.seq 
              { CG.updateProgram
              , CG.applyColors
    					, CG.pcg
    					, CG.pcfg
              }
          }        
      )
end

-- support for old code that can be removed
-- ColorGraph_init (ColorGraph, Backplane)
-- end of old code
ColorGraph_init (NewColorGraph, NewBackplane)
@

\subsection{Debugging support}

Printing functions used for debugging purposes. Functions are provided for
printing the [[cgInfo]] data structure.
<<print CGInfo>>=
let regILists cgInfo =
       [ ("Precolored", !(cgInfo.tempLG Precolored))
       ; ("Initial", !(cgInfo.tempLG Initial))
       ; ("SimplifyWorklist", !(cgInfo.tempLG SimplifyWorklist))
       ; ("FreezeWorklist", !(cgInfo.tempLG FreezeWorklist))
       ; ("SpillWorklist", !(cgInfo.tempLG SpillWorklist))
       ; ("spilledTemps", !(cgInfo.tempLG Spilled))
       ; ("coalescedTemps", !(cgInfo.tempLG Coalesced))
       ; ("coloredTemps", !(cgInfo.tempLG Colored))
       ; ("SelectStack", !(cgInfo.tempLG SelectStack))
       ]
let regLists cgInfo =
       [ ("Spills", RS.elements cgInfo.spills)
       ; ("AllColors", cgInfo.allColors)
       ]
let moveILists cgInfo =
                [ ("coalescedMoves", !(cgInfo.moveLG CoalescedMove))
                ; ("ConstrainedMoves", !(cgInfo.moveLG ConstrainedMove))
                ; ("FrozenMoves", !(cgInfo.moveLG FrozenMove))
                ; ("WorklistMoves", !(cgInfo.moveLG WorklistMove))
                ; ("ActiveMoves", !(cgInfo.moveLG ActiveMove))
                ]
@

Several helper functions are provided for printing parts of the cgInfo
record.

<<print CGInfo>>=
let printReg (s, i, w) = Printf.sprintf "%c%d" s i
let printMove node = printReg (source node)
                   ^ " -> "
                   ^ printReg (dest node)
let printMap p1 p2 mapName sm =
    cgSay ["    " ^ mapName ^ ":\n"];
    RM.iter (fun tmp s -> cgSay [ "        "
                                  ; p1 tmp
                                  ; " -> "
                                  ; p2 s
                                  ; "\n"
                                  ]) sm
let printStringMap mapName sm = printMap printReg (fun x -> x) mapName sm
let printAliasMap  mapName am = printMap printReg printReg     mapName am
@

The [[print_cgInfo]] function prints the graph coloring information in a
readable format. [[printCGInfo]] is embedded in the Lua interpreter to
provide access to [[print_cgInfo]].
Printing functions for the [[cfInfo]] record.

<<print CGInfo>>=
let printCFGLive _ {Proc.cfg = cfg} =
    let printNodeLive node =
        let nodes = G.fold_nodes (fun x y -> x :: y) [] cfg in
        let nnodes = Aux.foldri (fun i n ns -> (i, n) :: ns) nodes [] in
        let number node = fst (List.find (fun (i, n) -> G.eq node n) nnodes) in
        let live = LI.live_out node in
        cfgSay ["LIVE "; string_of_int (number node); ": "];
        cfgSay (List.map printReg (RS.elements live)); cfgSay ["\n"]; in
    G.iter_nodes printNodeLive cfg; false

let print_cgInfo cgInfo =
    let _ = cgSay ["\nCGINFO\n"] in
    let printList iter pr (name, itemlist) =
        let indent = "        " in
        cgSay ["    "; name; ":\n"]; 
        iter (fun r -> cgSay [indent; pr r; "\n"])
                  itemlist in
    let printItemList pr (name, itemlist) =
        match itemlist with
        | [] -> ()
        | i  -> printList List.iter pr (name, itemlist) in
    let printItemIList pr (name, itemlist) =
        match itemlist with
        | None -> ()
        | Some _  -> printList (fun fn -> ilg_iter (fun i -> fn i.v))
                               pr (name, itemlist) in
    let printReglist lst  = printItemList printReg lst in
    let printRegIlist lst  = printItemIList printReg lst in
    let printMoveIlist lst = printItemIList printMove lst in
    let printAdjListMember key lst =
        cgSay ["        "; printReg key; ": "];
        List.iter (fun r -> cgSay [", "; printReg r.v]) lst;
        cgSay ["\n"]; in
    let printAdjListMap am =
        let _ = cgSay ["    AdjListMap:\n"] in
        RM.iter printAdjListMember am
    in
        printAdjListMap cgInfo.adjListMap;
        List.iter printReglist (regLists cgInfo);
        List.iter printRegIlist (regILists cgInfo);
        cgSay ["    K: "; string_of_int cgInfo.k; "\n"];
        List.iter printMoveIlist (moveILists cgInfo);
        printAliasMap "aliasMap" cgInfo.aliasMap;
        printAliasMap "colorMap" cgInfo.colorMap;
				printStringMap "listMap"
            (RM.fold (fun r i map -> RM.add r (str_of_list i.list) map) cgInfo.regToItem RM.empty)

let printCGInfo param _ = print_cgInfo param; false
@

<<print CGInfo>>=
    let print_cfg cfg =
        let nodes = G.fold_nodes (fun x y -> x :: y) [] cfg in
        let nnodes = Aux.foldri (fun i n ns -> (i, n) :: ns) nodes [] in
        let number node = fst (List.find (fun (i, n) -> G.eq node n) nnodes) in
        cfgSay ["CFG\n===\n"];
        ( G.iter_nodes
            (fun node ->
              cfgSay (List.flatten
				     [ [G.print_node node]
						 ; ["    Live_out: "]
					   ; RS.fold (fun r rst -> Printf.sprintf "%s, " (printReg r)
						                          :: rst) (LI.live_out node) []
						 ; ["\n"]
					   ]))
            cfg);
        cfgSay ["END CFG\n===\n"]
    let pCFG _ {Proc.cfg = cfg} = print_cfg cfg; false
@

<<cg stages>>=
(*
let selectSpillStage = { Backplane.name = "selectSpill"
                       ; Backplane.fn = selectSpill
                       ; Backplane.paramExpected = Some "cgInfo"
                       ; Backplane.stateCreated = Backplane.list2SSet []
                       ; Backplane.stateDestroyed = Backplane.list2SSet []
                       ; Backplane.stateUsed = Backplane.list2SSet []
                       }

let assignColorsStage = { Backplane.name = "assignColors"
                        ; Backplane.fn = assignColors
                        ; Backplane.paramExpected = Some "cgInfo"
                        ; Backplane.stateCreated = Backplane.list2SSet []
                        ; Backplane.stateDestroyed = Backplane.list2SSet []
                        ; Backplane.stateUsed = Backplane.list2SSet ["interferenceGraph"]
                        }

let rewriteProgramStage = { Backplane.name = "rewriteProgram"
                          ; Backplane.fn = rewriteProgram
                          ; Backplane.paramExpected = Some "cgInfo"
                          ; Backplane.stateCreated = Backplane.list2SSet []
                          ; Backplane.stateDestroyed = Backplane.list2SSet []
                          ; Backplane.stateUsed = Backplane.list2SSet []
                          }
*)
(*
let haveSpilledTempsStage = { Backplane.name = "haveSpilledTemps"
                            ; Backplane.fn = haveSpilledTemps
                            ; Backplane.paramExpected = Some "cgInfo"
                            ; Backplane.stateCreated = Backplane.list2SSet []
                            ; Backplane.stateDestroyed = Backplane.list2SSet []
                            ; Backplane.stateUsed = Backplane.list2SSet ["cfg"]
                            }
*)
(*
let livenessStage = { Backplane.name = "liveness"
                    ; Backplane.fn = liveness
                    ; Backplane.paramExpected = None
                    ; Backplane.stateCreated = Backplane.list2SSet ["live_in sets"]
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet ["cfg"]
                    }
*)
(*
let buildStage = {Backplane.name = "build"
                 ; Backplane.fn = build
                 ; Backplane.paramExpected = Some "cgInfo"
                 ; Backplane.stateCreated = Backplane.list2SSet ["interferenceGraph"]
                 ; Backplane.stateDestroyed = Backplane.list2SSet []
                 ; Backplane.stateUsed = Backplane.list2SSet ["cfg"; "live_in sets"]
                 }
*)
(*
let makeWorklistStage = { Backplane.name = "makeWorklist"
                        ; Backplane.fn = makeWorklist
                        ; Backplane.paramExpected = Some "cgInfo"
                        ; Backplane.stateCreated = Backplane.list2SSet ["worklists"]
                        ; Backplane.stateDestroyed = Backplane.list2SSet []
                        ; Backplane.stateUsed = Backplane.list2SSet ["interferenceGraph"]
                       }
*)
(*
let simplifyStage = { Backplane.name = "simplify"
                    ; Backplane.fn = simplify
                    ; Backplane.paramExpected = Some "cgInfo"
                    ; Backplane.stateCreated = Backplane.list2SSet []
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet []
                    }
*)
(*
let coalesceStage = { Backplane.name = "coalesce"
                    ; Backplane.fn = coalesce
                    ; Backplane.paramExpected = Some "cgInfo"
                    ; Backplane.stateCreated = Backplane.list2SSet []
                    ; Backplane.stateDestroyed = Backplane.list2SSet []
                    ; Backplane.stateUsed = Backplane.list2SSet []
                    }

let recklessCoalesceStage = { Backplane.name = "recklessCoalesce"
                            ; Backplane.fn = recklessCoalesce
                            ; Backplane.paramExpected = Some "cgInfo"
                            ; Backplane.stateCreated = Backplane.list2SSet []
                            ; Backplane.stateDestroyed = Backplane.list2SSet []
                            ; Backplane.stateUsed = Backplane.list2SSet []
                            }
*)
(*
let freezeStage = { Backplane.name = "freeze"
                  ; Backplane.fn = freeze
                  ; Backplane.paramExpected = Some "cgInfo"
                  ; Backplane.stateCreated = Backplane.list2SSet []
                  ; Backplane.stateDestroyed = Backplane.list2SSet []
                  ; Backplane.stateUsed = Backplane.list2SSet []
                  }
*)
@
