% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Elaborating Statements}
% ------------------------------------------------------------------ 

<<exposed types>>=
type exp = Rtl.exp
type rtl = Rtl.rtl
type loc = Rtl.loc * Rtl.width
type convention = string
type hint = string
type actual = hint * exp * Rtl.width
type name = string
type linktime = Bits.bits Reloc.Simple.relocatable
type 'a hinted = hint * 'a
type range = Bits.bits * Bits.bits   (* lo `leu` x `leu` hi, as in manual *)
type procname = string
type 'a flow = { cuts : 'a list; unwinds : 'a list; areturns : 'a list;
              returns : bool; aborts : bool }
type 'a cflow = {
    ccuts : 'a list;
    caborts : bool;
  }

type stmt =
  | If     of exp * stmt list * stmt list
  | Label  of name
  | Switch of range option * exp * (range list * stmt list) list
  | Cont   of name * name hinted list
  | Span   of (Bits.bits * linktime) * stmt list
  | Assign of rtl
  | Call   of loc hinted list * convention * exp * actual list * procname list
            * name flow
  | Goto   of exp * name list
  | Jump   of convention * exp * actual list * procname list
  | Cut    of convention * exp * actual list * name cflow 
  | Return of convention * int * int * actual list
@
<<elabstmt.mli>>=
<<exposed types>>
val elab_stmts :
  Ast.region -> 'a Fenv.Dirty.env' -> Nast.stmt list -> stmt list Error.error
@ The [[elab_*]] functions work with incomplete information,
indicated by [[Error.Error]] values.  The policy is as follows:
\begin{itemize}
\item In case of a success, [[check]] returns the type of the
      expression at hand as a [[Error.Ok]] value.
\item If the type check must use an erroneous information from the
      environment, it propagates this error and returns [[E.Error]].
\item If the type check detects a new error, for example a type
      inconsistency, it issues an error message and returns
      [[E.Error]].
      The exception [[Error.ErrorExn]] may be used internally, but it
      should never be raised by a top-level function.
\end{itemize}
@
% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<elabstmt.ml>>=
<<exposed types>>
module A  = Ast
module E  = Error
module F  = Fenv.Dirty
module N  = Nast
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let is2power x = x > 0 && x land (x - 1) = 0
@

<<elabstmt.ml>>=
module M = Metrics
@ 
Parameter [[reachable]] means the statement is reachable by ordinary
control flow (i.e., not by continuation).
It is used to check the control-flow
restrictions: if a statement is reachable by ordinary control flow, it
 had better not be a continuation.
Similarly, it had better not be the end of the procedure body.
<<elabstmt.ml>>=
let elab_stmts r env =
  let eprint r = E.errorRegionPrt (F.srcmap env, r) in
  let errorf r = Printf.kprintf (fun s -> eprint r s; E.Error) in
  let exp = Elabexp.elab_exp env in
  let con = Elabexp.elab_con env in
  let loc = Elabexp.elab_loc env in
  let metrics = F.metrics env in
  let rec full_stmt r reachable s =
    <<elaboration utilities>>
    <<definitions of elaboration functions>>
    let rec stmt s = match s with
    | N.StmtAt (s, r) -> E.catch (eprint r) (full_stmt r reachable) s
    | N.If (c, t, f) -> 
        E.ematch3 (exp c) (stmts r true t) (stmts r true f) (fun (c, cty) t f ->
          match cty with
          | Types.Bool -> If (c, t, f)
          | Types.Bits n -> E.error "condition in `if' is not a Boolean")
    | N.Switch (range, e, arms) -> switch range e arms
    | N.Label n -> E.Ok (Label n)
    | N.Cont (name, formals) ->
        let c = E.ematch (E.Raise.list (List.map cformal formals)) (fun formals ->
                  Cont (name, formals)) in
        if reachable then
          E.error "control can fall through to continuation"
        else
          c
    | N.Span (k, v, ss)   -> span k v (stmts r reachable ss)
    | N.Assign (lhs, rhs) -> assign lhs rhs
    | N.Goto (tgt, tgts)  -> goto tgt tgts
    | N.Call (lhs, conv, p, args, tgts, flow) -> call lhs conv p args tgts flow
    | N.Jump (conv, p, args, tgts)            -> jump conv p args tgts
    | N.Cut  (conv, k, args, flow)            -> cut conv k args flow
    | N.Prim (lhs, conv, p, args, flow)       -> prim lhs conv p args flow
    | N.Return (conv, altcont, args)          -> return conv altcont args in
    stmt s
  and stmts r reachable ss = stmts' false r reachable ss
  and stmts' procbody r reachable ss =
    let rec stmts reachable = function
      | [] -> if procbody && reachable then
                [errorf r "control falls off end of procedure"]
              else
                []
      | N.Span (_, _, []) :: ss -> stmts reachable ss
      | s :: ss ->
          let s' = full_stmt r reachable s in  (* enforce order *)
          s' :: stmts (not (jumps s)) ss in
    Error.Raise.list (stmts reachable ss)
  and jumps = function N.Goto _ | N.Jump _ | N.Cut _ | N.Return _  -> true
                     | N.Call (_, _, _, _, _, fl) -> List.mem Ast.NeverReturns fl
                     | N.StmtAt (s, _) -> jumps s
                     | N.Span (_, _, ss) -> jumps (Aux.last ss)
                     | N.If (_, t, f) -> jumpsss t && jumpsss f
                     | N.Switch (_, _, arms) -> List.for_all jumpsarm arms
                     | _ -> false
  and jumpsss = function [] -> false | ss -> jumps (Aux.last ss)
  and jumpsarm (_, ss) = jumpsss ss in
  stmts' true r true
@ 
Here are a couple of basic utilities.
We sometimes do extra checking if an expression is just a name.
<<elaboration utilities>>=
let rec exp_as_name = function
  | A.ExprAt(x,_) -> exp_as_name x
  | A.Fetch(A.NameOrMemAt(x,_)) -> exp_as_name (A.Fetch x)
  | A.Fetch(A.Name(_,x)) -> Some x
  | _ -> None in
@ 
Lots of things have to be the native pointer type.
<<elaboration utilities>>=
let ispointer =
  function Types.Bits n when n = metrics.M.pointersize -> true | _ -> false in
let insist_pointer what t =
  if ispointer t then ()
  else E.error (what ^ " must be a bit vector of the native pointer type") in
@ 
A formal parameter to a continuation must be a local register variable.
<<elaboration utilities>>=
let cformal (hint, name) =
  E.seq (snd (F.findv name env)) (fun den ->
    match den with
    | F.Variable _, _ when F.is_localv name env -> E.Ok (hint, name)
    | F.Variable _, _ ->
        errorf r "continuation parameter '%s' may not be a global variable" name
    | d, _ ->
        errorf r "continuation parameter '%s' is a %s, not a local register variable"
          name (F.denotation's_category d)) in
@
The type of the switch expression must be matched by the guarding
ranges of the arms.  An empty switch-statement is an error because no
arm can match the value of the switch-expression at run-time.
<<definitions of elaboration functions>>=
let switch rg e arms =
  let rg = E.Raise.option (Aux.Option.map range rg) in
  let arms = E.Raise.list (List.map arm arms) in
  E.ematch3 (exp e) rg arms (fun (e, et) rg arms ->
    match et with
    | Types.Bool -> E.error "switch statement scrutinee is a Boolean"
    | Types.Bits w ->
        let rg = Aux.Option.map (striprange w) rg in
        let arms = striparms w arms in
        if null arms then E.error "empty switch statement"
        else Switch(rg, e, arms)) in
@
A range has two constant expressions of the same width.
<<elaboration utilities>>=
let range = function
  | A.Range (l, h) -> E.ematch2 (con l) (con l) (fun (l, lw) (h, hw) ->
      if lw = hw then (l, h), lw
      else E.errorf "constants in range %s..%s have different types bits%d and bits%d"
          (Bits.to_string l) (Bits.to_string h) lw hw)
  | A.Point e -> E.ematch (con e) (fun (n, w) -> (n, n), w) in
@ 
An arm is guarded by a nonempty list of ranges, each of the same width.
<<elaboration utilities>>=
let arm (rgs, ss) =
  E.ematch2 (E.Raise.list (List.map range rgs)) (stmts r true ss) (fun rgs ss ->
    match rgs with
    | [] -> impossf "parser produced case arm with empty range list"
    | (rg, w) :: rgs ->
        let strip w (rg, w') = if w = w' then rg else <<exn on range type mismatch>> in
        ((rg :: List.map (strip w) rgs), ss), w) in
@ 
The width of every range that appears in a [[switch]] arm must match
the type of the scrutinee ([[switch]]-expression).
We check this requirement and strip the width off everything in sight.
<<elaboration utilities>>=
let striprange w (rg, w') =
  if w = w' then rg else <<exn on case range type mismatch>> in
let striparms w =
  let strip (arm, w') = if w = w' then arm else <<exn on arm type mismatch>> in
  List.map strip in
<<exn on range type mismatch>>=
E.errorf "ranges in case arm have different types bits%d and bits%d" w w'
<<exn on arm type mismatch>>=
E.errorf "case arm uses range of type bits%d but scrutinee has type bits%d" w' w
<<exn on case range type mismatch>>=
E.errorf "switch statement range has type bits%d but scrutinee has type bits%d" w' w
@ 


@ 
A [[span]] statement has key and value expressions.
The key must be a constant native word and the value a link-time (data)
pointer.  Of course, all statement inside the span must be checked as
well. Currently we don't check the link-time property of [[e2]].
<<definitions of elaboration functions>>=
let span k v ss =
  E.ematch3 (con k) (Elabexp.elab_link env v) ss (fun (k, kw) (v, vw) ss ->
    if kw <> metrics.M.wordsize then
      E.error "span token (key) must be a bit vector of native word size";
    insist_pointer "span value" (Types.Bits vw);
    Span ((k, v), ss)) in
@
Two two sides of an assign statement must match: the number and types
of lvalues and expressions are checked against each other.  For
improved error messages [[List.combine]] is re-implemented. Details
of the left hand side are handled by the [[lvalue]] function.

The right hand side may contain optional guarding expressions of type
[[bool]].
<<definitions of elaboration functions>>=
let assign lhs rhs =
  try E.ematch (E.Raise.list (List.map2 effect lhs rhs)) (fun es -> Assign(Rtl.par es))
  with Invalid_argument _ -> <<complain about length mismatch in assignment>> in
<<elaboration utilities>>=
let effect lhs (guard,rhs) =
  let guard = Aux.Option.map exp guard in
  E.seq2 (loc lhs) (exp rhs) (fun (loc, w) (e, ty) ->
    if ty <> Types.Bits w then
      errorf r "location of type bits%d cannot hold value of type %s" w
        (Types.to_string ty)
    else
      let rtl = Rtl.store loc e w in
      match guard with
      | None   -> E.Ok rtl
      | Some g -> E.seq g (fun (g, ty) ->
          if ty = Types.Bool then E.Ok (Rtl.guard g rtl)
          else errorf r "guard must have type bool, not %s" (Types.to_string ty))) in
@ 
<<complain about length mismatch in assignment>>=
if List.length lhs < List.length rhs then
  errorf r
    "assignment has %d expressions on the right but only %d locations on the left"
    (List.length rhs) (List.length lhs)
else
  errorf r
    "assignment has %d locations on the left but only %d expressions on the right"
    (List.length lhs) (List.length rhs)
@
A [[goto]] statement must name all possible (local) targets [[ts]] for
its code pointer expression [[e]].  Targets may be omitted only if the
expression is a statically known target, i.e.~a local code label. 
<<definitions of elaboration functions>>=
let goto tgt tgts =
  let tgts = E.Raise.list (List.map (goto_target r) tgts) in
  E.ematch2 (exp tgt) tgts (fun (te, t) tgts ->
    insist_pointer "target of goto" t;
    if null tgts && not (exp_is_local_code_label r tgt) then
      E.error "target list omitted and target is not a local code label";
    Goto (te, tgts)) in 
@
A name appearing in a targets list must denote a local label,
as must an expression without a targets list.
We have two functions so we can issue suitable error messages.
<<elaboration utilities>>=
let goto_target r x = E.seq (snd (F.findv x env)) (fun (d, t) ->
  match d with 
  | F.Label (F.Code _) when F.is_localv x env -> E.Ok x
  | F.Label (F.Code _) -> errorf r "may not goto %s (label in another procedure)" x
  | _                  -> errorf r "may not goto %s %s" (F.denotation's_category d)x)in
let exp_is_local_code_label r e = match exp_as_name e with
| None -> false
| Some x -> match snd (F.findv x env) with
  | E.Ok (F.Label (F.Code _), _) when F.is_localv x env -> true
  | E.Ok _ -> false
  | E.Error -> impossf "good target name came back as error" in
@ 

\subsection{Value-passing statements: calls and so on}
A call need not name targets;
the only requirement is that the expression by of the native pointer
type.  
The
details of the assignment in a [[Call]] context are handled by
[[lvalue]].  To make sure all errors are recorded in [[env]] the
argument to [[E.seq']] includes [[left]] and [[at]] although only the
type of [[exp]] is used.
<<definitions of elaboration functions>>=
let call left conv p args targets flows =
  let left = E.Raise.list (List.map (Elabexp.elab_hinted_name env) left) in
  let args = E.Raise.list (List.map (actual r) args) in
  let tgts = E.Raise.list (List.map (call_target r) targets) in
  let flow = call_flow r flows in
  reject_uncallable p;
  E.ematch5 left args (exp p) tgts flow (fun left args (p,pt) tgts flow ->
    insist_pointer "procedure value" pt;
    Call (left, conv, p, args, tgts, flow)) in
@
The jump expression must be a (code) pointer.
<<definitions of elaboration functions>>=
let jump conv p args targets =
  let args = E.Raise.list (List.map (actual r) args) in
  let tgts = E.Raise.list (List.map (call_target r) targets) in
  reject_uncallable p;
  E.ematch3 args (exp p) tgts (fun args (p,pt) tgts ->
    insist_pointer "procedure value" pt;
    Jump (conv, p, args, tgts)) in
@ 
Why is there no analog of [[reject_uncallable]]?
Only Christian knows\ldots
<<definitions of elaboration functions>>=
let cut conv k args flows =
  let args = E.Raise.list (List.map (actual r) args) in
  let flow = cut_flow r flows in
  E.ematch3 args (exp k) flow (fun args (k,kt) flow ->
    insist_pointer "continuation value" kt;
    Cut (conv, k, args, flow)) in
@ 
@
A [[return]] may specify alternate return continuations.  The
expressions $e_1/e_2$ must be both of the native word type and $0 \leq
e1 \leq e_2$.
<<definitions of elaboration functions>>=
let return conv alt args =
  let args = E.Raise.list (List.map (actual r) args) in
  let i, n = match alt with
  | None -> E.Ok 0, E.Ok 0
  | Some (i, n) ->
      let okbits f x = E.Ok (Bits.S.to_int (f x)) in
      let const k = E.seq (exp k) (fun (k, kt) ->
        E.catch (eprint r) (okbits Simplify.bits) k) in
      const i, const n in
  E.ematch3 i n args (fun i n args ->
    if i >= 0 && n >= 0 && i <= n then
      Return (conv, i, n, args)
    else
      <<raise error exn with bad continuation numbers>>) in
@ 
<<raise error exn with bad continuation numbers>>=
if i < 0 then
  E.errorf "in return <i/n>, i must be nonnegative but you have i = %d" i
else if n < 0 then
  E.errorf "in return <i/n>, n must be nonnegative but you have n = %d" n
else if i > n then
  E.errorf "in return <i/n>, i must be at most n but you have i = %d and n = %d" i n
else
  impossf "bad <i/n> with i = %d and n = %d, but no better error message" i n
<<elaboration utilities>>=
let actual r (hint, e) = E.seq (exp e) (fun (e, ty) ->
  match ty with
  | Types.Bits w -> E.Ok (hint, e, w)
  | Types.Bool   -> errorf r "an actual parameter may not be a Boolean") in
@ 
As target of a call or jump,
we reject out of hand (by raising [[E.ErrorExn]]) any name that is
obviously not a procedure. 
<<elaboration utilities>>=
let reject_uncallable e = match exp_as_name e with
| None -> ()
| Some x -> match (snd (F.findv x env)) with
  | E.Ok ((F.Label (F.Proc _) | F.Import (_, _) | F.Variable _), _) | E.Error -> ()
  | E.Ok (d, _) -> 
      E.errorf "cannot call or jump to %s %s" (F.denotation's_category d) x in
@    
\paragraph{Checking flow annotations}
For the moment, we elaborate flow of names into flow of names, doing only checking.
But at some point we might want to elaborate flow of names into flow
of denotations.  This might require extending the denotations.
We'll know when we revise [[Ast2ir]].
<<elaboration utilities>>=
let flow r default_aborts default_returns =
  let as_cut_to  k = k.F.cut_to <- true in
  let as_unwinds k = k.F.unwound_to <- true in
  let as_returns k = k.F.returned_to <- true in
  let rec ks r as_what prev' ns =
    let continuation n = E.seq (snd (F.findv n env)) (function
      | F.Continuation k, _ -> as_what k; E.Ok n
      | _ -> errorf r "%s is not a continuation" n) in
    match ns with
    | [] -> prev'
    | n :: ns -> ks r as_what (continuation n :: prev') ns in
  let rec flow r c' u' r' aborts returns = function
    | [] -> finish_flow c' u' r' aborts returns
    | A.FlowAt(f,r)  :: fs -> flow r c' u' r' aborts returns (f :: fs)
    | A.CutsTo    ns :: fs -> flow r (ks r as_cut_to c' ns) u' r' aborts returns fs
    | A.UnwindsTo ns :: fs -> flow r c' (ks r as_unwinds u' ns) r' aborts returns fs
    | A.ReturnsTo ns :: fs -> flow r c' u' (ks r as_returns r' ns) aborts returns fs
    | A.Aborts       :: fs -> flow r c' u' r' true returns fs
  (*| A.NeverAborts  :: fs -> flow r c' u' r' false returns fs *)
    | A.NeverReturns :: fs -> flow r c' u' r' aborts false fs 
  and finish_flow c' u' r' aborts returns =
    let list ns = E.Raise.list (List.rev ns) in
    E.ematch3 (list c') (list u') (list r') (fun c u r ->
      { cuts = c; unwinds = u; areturns = r; aborts = aborts; returns = returns }) in
  flow r [] [] [] default_aborts default_returns in
@ 
The rules for flow are slightly different for calls and cuts.
<<elaboration utilities>>=
let call_flow r fs = flow r false true fs in
let null = function [] -> true | _ :: _ -> false in
let cut_flow r fs =
  E.seq (flow r true false fs) (fun f ->
    if not (null f.unwinds) then
      errorf r "'also unwinds to' is meaningless on a 'cut to'"
    else if not (null f.areturns) then
      errorf r "'also returns to' is meaningless on a 'cut to'"
    else if f.returns then
      impossf "a 'cut to' returns? I think not!"
    else
      E.Ok { ccuts = f.cuts; caborts = f.aborts }) in
@ 
A call target must be either a procedure or an imported symbol with
the native pointer type.
<<elaboration utilities>>=
let call_target r x = E.seq (snd (F.findv x env)) (function
  | (F.Label (F.Proc _) | F.Import _), t when ispointer t -> E.Ok x
  | _ -> errorf r "target %s is not a procedure or imported pointer" x) in
@
A call of a primitive is type checked: argument types must have the
expected types. This is done by [[Rtlop.Translate.check]].
<<definitions of elaboration functions>>=
let prim lhs conv op args flows =
  let lhs  = E.Raise.list (List.map (Elabexp.elab_hinted_name env) lhs) in
  let args = E.Raise.list (List.map (fun (h, e) -> E.Raise.right (h, exp e)) args) in
  let flow = prim_flow r flows in
  E.ematch3 lhs args flow (fun lhs args flow ->
    let nonempty_hint (h, _) = h <> "" in
    if List.exists nonempty_hint lhs || List.exists nonempty_hint args then
      E.error "calls to primitive operators may use only empty hints"
    else
      match lhs with
      | [_, (result, w)] ->
          let argtys  = List.map (fun (_, (_, t)) -> t) args in
          let argexps = List.map (fun (_, (e, _)) -> e) args in
          let t, opr  = Rtlop.Translate.operator op argtys in
          if t <> Types.Bits w then
            <<raise error exn on primop type mismatch>>
          else
            Assign (Rtl.store result (Rtl.app opr argexps) w)
      | _ -> E.error "primitive operator produces exactly one result") in
<<raise error exn on primop type mismatch>>=
Printf.kprintf E.error
  "left-hand side has type bits%d, but primitive operator produces results of type %s"
  w (Types.to_string t)
@ 
<<elaboration utilities>>=
let prim_flow r fs =
  E.seq (flow r false true fs) (fun f ->
    if not (null f.unwinds) then
      errorf r "'also unwinds to' is meaningless on a primitive operator"
    else if not (null f.cuts) then
      errorf r "'also cuts to' is meaningless on a primitive operator"
    else if not (null f.areturns) then
      errorf r "alternate returns on primitive operators are not yet implemented"
    else if f.aborts then
      errorf r "'also aborts' is meaningless on a primitive operator"
    else if not f.returns then
      errorf r "'never returns' is meaningless on a primitive operator"
    else
      E.Ok f) in
@ 
