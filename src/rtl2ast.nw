% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% :vim sw=4 tw=8 et sts=4

\input{../config/macros.tex}


% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Translation of {\rtl}s to {\PAL} syntax}
% ------------------------------------------------------------------ 

For debugging we like to make the intermediate code visible by
translating it back to {\PAL} syntax.  Technically this means, that
{\rtl}s are translated to the {\PAL} abstract syntax ({\AST}); for the
{\AST} a pretty printer (in module \module{ast}) translates it back to
{\small ASCII} codes. This module provides a translation from an {\rtl}
to a {\PAL} statement.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[translate]] function takes an {\rtl} and produces a statement
list, describing the effect of the {\rtl}.  

<<rtl2ast.mli>>=
val expr:           Rtl.exp  -> Ast.expr 
val rtl:            Rtl.rtl  -> Ast.stmt 

type verbosity =    Low | High             (* default is High   *)
val verbosity:      verbosity -> verbosity (* returns old value *)
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtl2ast.ml>>=
module R = Rtl.Private
module A = Ast
module T = Types
@

<<rtl2ast.ml>>=
type verbosity = Low | High  (* default is High --- more accurate *)
let the_verbosity = ref High
let verbosity v =
  let v' = !the_verbosity in
  the_verbosity := v;
  v'

<<rtl2ast.ml>>=
let bits n             = A.BitsTy n

let const = function
    | R.Bool(_)      -> assert false    (* impossible *)
    | R.Bits(b,w)    ->  A.Int((b,w)
                              ,if !the_verbosity = High 
                               then Some (bits w) 
                               else None)
                     
    | R.Link(sym,w)  -> A.Fetch(A.Var(None, (sym#text)))
    | R.Late(name,w) -> A.Fetch(A.Var(None, name)) (*XXX ok? *)
@

<<rtl2ast.ml>>=
let rec expr' = function
    | R.Const c         -> const c
    | R.Fetch(loc,_)    -> A.Fetch(location' loc)
    | R.App((op,ww),ee) -> let actual e = (None, expr' e) in
                           match ee with
                           | [l; r] when op = "add" || op = "sub" ->
                                  let op = if op = "add" then "+" else "-" in
                                  A.BinOp(expr' l, op, expr' r)
                           | _ -> A.PrimOp(op, List.map actual ee)
@

N.B. This code might possibly look up the location in a machine-dependent map
in case it needs to the name of a hardware register variable.

A translation of {\rtl} locations to {\PAL} is not semantic preserving
because {\PAL} has no notion of spaces. The translation here turns a
space into a (named) type, which is neither wrong nor right.

<<rtl2ast.ml>>=
and location' = function 
    | R.Cell (sp,agg,width,e,ass) ->
     (* let space   =  Printf.sprintf "$%c" sp           in *)
        let space   =  Printf.sprintf "$%c(%d)" sp width in   
        let aligned = if ass = 1 then None else Some ass in 
        A.Mem(A.AliasTy space,expr' e,aligned)
    | R.Var (name,_,width)       -> A.Var(None,name)
    | R.Slice _                  -> assert false 
                                    (*should convert as special reg name*)

let (@<<) f g  = fun x -> f (g x)
let expr       = expr'     @<< Rtl.Convert.exp
let location   = location' @<< Rtl.Convert.loc

@

A [[kill]] is translated into an assignment of [[%undef()]].

<<rtl2ast.ml>>=
let rec effect guard = function
    | R.Kill   loc       -> 
        let width = Rtlutil.Width.loc  (Rtl.Revert.loc loc)       in
        let undef = R.App(("undef",[width]),[]) in
            effect guard (R.Store(loc, undef, width))
    | R.Store  (loc,e,w) ->
            (location' loc,(guard, expr' e))

let guard = function
  | R.Const (R.Bool true) -> None
  | g -> Some (expr' g)  

let guarded (g, eff) = effect (guard g) eff

let rtl' (R.Rtl gg) = 
  match gg with
  | [] -> A.EmptyStmt
  | _ :: _ ->
    let pairs    = List.map (guarded ) gg in
    let lhs, rhs = List.split pairs             in
        A.AssignStmt(lhs,rhs)
let rtl = rtl' @<< Rtl.Convert.rtl
@

