% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}


% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Translation of {\rtl}s to {\PAL} syntax}
% ------------------------------------------------------------------ 

For debugging we like to make the intermediate code visible by
translating it back to {\PAL} syntax.  Technically this means, that
{\rtl}s are translated to the {\PAL} abstract syntax ({\AST}); for the
{\AST} a pretty printer (in module \module{ast}) translates it back to
{\small ASCII} codes. This module provides a translation from an {\rtl}
to a {\PAL} statement.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[translate]] function takes an {\rtl} and produces a statement
list, describing the effect of the {\rtl}.  When a variable name is
created from a name found in an {\rtl}, it is passed through a
mangling function that is also passed to [[rtl]].  This gives [[rtl]]
a chance to re-write names such that they obey to the {\PAL} syntax. 
See also module \module{mangle}.

<<rtl2ast.mli>>=
val expr:      (string -> string) -> Rtl.expr  -> Ast.expr 
(*val const:     (string -> string) -> Rtl.const -> Ast.expr *)
val rtl:       (string -> string) -> Rtl.rtl   -> Ast.stmt 
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtl2ast.ml>>=
module R = Rtl.Private
module A = Ast
module T = Types
@

<<rtl2ast.ml>>=
let bits n             = A.BitsTy n

let const mangle = function
    | R.Bool(_)      -> assert false
    | R.Bits(b,w)    -> A.Int(b, Some (bits w))
    | R.Link(name,w) -> A.Fetch(A.Var(None, mangle name))
@

<<rtl2ast.ml>>=
@
    
Primitive operators in {\PAL} are monomorphic, whereas they are
polymorphic in {\rtl}s.  The translatation to {\PAL} thus must
specialize an operator if it is polymorphic.  Currently not
implemented.

<<rtl2ast.ml>>=
let rec expr' mangle = function
    | R.Const c         -> const mangle c
    | R.Fetch(loc,_)    -> A.Fetch(location' mangle loc)
    | R.App((op,ww),ee) -> let actual e = (None, expr' mangle e)
                           in 
                                A.PrimOp(op, List.map actual ee)
@

N.B. This code might possibly look up the location in a machine-dependent map
in case it needs to mangle as the name of a hardware register variable.
<<rtl2ast.ml>>=
and location' mangle = function 
    | R.Cell('m',agg,width,e,_)  -> A.Mem(bits width, expr' mangle e, None)
    | R.Cell('r',agg,width,R.Const(R.Bits(n,3)),_) ->  
        let r = Printf.sprintf "r%d " (Bits.to_int n) in
            A.Var(None, mangle r)
    | R.Cell _                   -> assert false
    | R.Var (name,_,width)       -> A.Var(None,mangle name)
    | R.Slice _                  -> assert false (*should convert as special reg name*)

let (@<<) f g   = fun x -> f (g x)
let expr m = expr' m @<< Rtl.Convert.expr
let location m = location' m @<< Rtl.Convert.location

@

A [[kill]] is translated into an assignment of [[%undef()]].

<<rtl2ast.ml>>=
let rec effect mangle guard = function
    | R.Kill   loc       -> 
        let width = Rtlutil.locwidth' loc                in
        let undef = R.App(("undef",[width]),[]) in
            effect mangle guard (R.Store(loc, undef, width))
    | R.Store  (loc,e,w) -> 
            (location' mangle loc,(guard, expr' mangle e))

let guard mangle = function
  | R.Const (R.Bool true) -> None
  | g -> Some (expr' mangle g)  

let guarded mangle (g, eff) = effect mangle (guard mangle g) eff

let rtl' mangle (R.Rtl gg) = 
    let pairs    = List.map (guarded mangle) gg in
    let lhs, rhs = List.split pairs             in
        A.AssignStmt(lhs,rhs)
let rtl mangle = rtl' mangle @<< Rtl.Convert.rtl
@

