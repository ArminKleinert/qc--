% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% :vim sw=4 tw=8 et sts=4

\input{../config/macros.tex}


% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Translation of {\rtl}s to {\PAL} syntax}
% ------------------------------------------------------------------ 

For debugging we like to make the intermediate code visible by
translating it back to {\PAL} syntax.  Technically this means, that
{\rtl}s are translated to the {\PAL} abstract syntax ({\AST}); for the
{\AST} a pretty printer (in module \module{ast}) translates it back to
{\small ASCII} codes. This module provides a translation from an {\rtl}
to a {\PAL} statement.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[translate]] function takes an {\rtl} and produces a statement
list, describing the effect of the {\rtl}.  When a variable name is
created from a name found in an {\rtl}, it is passed through a mangling
function that is also passed to [[translate]].  This gives [[translate]]
a chance to re-write names such that they obey to the {\PAL} syntax.
See also module \module{mangle}.

<<rtl2ast.mli>>=
val expr:      (string -> string) -> Rtl.exp  -> Ast.expr 
val rtl:       (string -> string) -> Rtl.rtl  -> Ast.stmt 
type verbosity = Low | High  (* default is High --- more accurate *)
val verbosity : verbosity -> verbosity (* returns old value *)
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtl2ast.ml>>=
module R = Rtl.Private
module A = Ast
module T = Types
@

<<rtl2ast.ml>>=
type verbosity = Low | High  (* default is High --- more accurate *)
let the_verbosity = ref High
let verbosity v =
  let v' = !the_verbosity in
  the_verbosity := v;
  v'

<<rtl2ast.ml>>=
let bits n             = A.BitsTy n

let const mangle = function
    | R.Bool(_)      -> assert false    (* impossible *)
    | R.Bits(b,w)    ->  A.Int((b,w)
                              ,if !the_verbosity = High 
                               then Some (bits w) 
                               else None)
                     
    | R.Link(sym,w)  -> A.Fetch(A.Var(None, mangle (sym#text)))
    | R.Late(name,w) -> A.Fetch(A.Var(None, mangle name)) (*XXX ok? *)
@

<<rtl2ast.ml>>=
let rec expr' mangle = function
    | R.Const c         -> const mangle c
    | R.Fetch(loc,_)    -> A.Fetch(location' mangle loc)
    | R.App((op,ww),ee) -> let actual e = (None, expr' mangle e) in
                           match ee with
                           | [l; r] when op = "add" || op = "sub" ->
                                  let op = if op = "add" then "+" else "-" in
                                  A.BinOp(expr' mangle l, op, expr' mangle r)
                           | _ -> A.PrimOp(op, List.map actual ee)
@

N.B. This code might possibly look up the location in a machine-dependent map
in case it needs to mangle the name of a hardware register variable.

A translation of {\rtl} locations to {\PAL} is not semantic preserving
because {\PAL} has no notion of spaces. The translation here turns a
space into a (named) type, which is neither wrong nor right.

<<rtl2ast.ml>>=
and location' mangle = function 
    | R.Cell (sp,agg,width,e,ass) ->
        let space   = mangle (Printf.sprintf "$%c" sp) in
        let aligned = if ass = 1 then None else Some ass in 
        A.Mem(A.AliasTy space,expr' mangle e,aligned)
    | R.Var (name,_,width)       -> A.Var(None,mangle name)
    | R.Slice _                  -> assert false 
                                    (*should convert as special reg name*)

let (@<<) f g  = fun x -> f (g x)
let expr m     = expr' m @<< Rtl.Convert.exp
let location m = location' m @<< Rtl.Convert.loc

@

A [[kill]] is translated into an assignment of [[%undef()]].

<<rtl2ast.ml>>=
let rec effect mangle guard = function
    | R.Kill   loc       -> 
        let width = Rtlutil.Width.loc  (Rtl.Revert.loc loc)       in
        let undef = R.App(("undef",[width]),[]) in
            effect mangle guard (R.Store(loc, undef, width))
    | R.Store  (loc,e,w) ->
            (location' mangle loc,(guard, expr' mangle e))

let guard mangle = function
  | R.Const (R.Bool true) -> None
  | g -> Some (expr' mangle g)  

let guarded mangle (g, eff) = effect mangle (guard mangle g) eff

let rtl' mangle (R.Rtl gg) = 
  match gg with
  | [] -> A.EmptyStmt
  | _ :: _ ->
    let pairs    = List.map (guarded mangle) gg in
    let lhs, rhs = List.split pairs             in
        A.AssignStmt(lhs,rhs)
let rtl mangle = rtl' mangle @<< Rtl.Convert.rtl
@

