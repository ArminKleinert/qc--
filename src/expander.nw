% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Toy code expander}

The goal here is to create a toy code expander so that we can test
register allocation and some other kinds of analyses and
transformations.
To explain what is happening, I use the following conventions:\\
\begin{tabular}{@{\quad}ll}
$t$& any temporary or register-like space\\
$m$& any memory-like space\\
$k$& any constant\\
$\oplus$& any RTL operator\\
\end{tabular}
Our goal is to reduce RTLs to the following forms:

{\def\gets{\mathrel{:=}}%
$$\begin{array}{rcl}
m[t_l] & \gets & t\\
t      & \gets & m[t_l]\\
t_1    & \gets & t_2\\
t      & \gets & k\\
t      & \gets & \oplus(t_1, \ldots, t_n)
\end{array}
$$}

This is not quite what a real code expander does, but it should
suffice for experiments.

<<expander.mli>>=
type context 
  = (Rtl.Private.loc -> bool)           (* say if a location is memory-like *)
  * (char -> int -> Rtl.loc)            (* get a temp for space and width *)
val expand : context -> Rtl.rtl -> Rtl.rtl list
  (* returns *last* instruction at *head* of list (reverse execution order) *)
@ 
Here are some abbreviations and utilities.
<<expander.ml>>=
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
let up   = Rtl.Revert.exp
let down = Rtl.Convert.exp
let uploc= Rtl.Revert.loc
let downloc= Rtl.Convert.loc

let fetch l = RP.Fetch (downloc l, RU.Width.loc l)

let width e = RU.Width.exp (up e)

let space_for _ = 't'  (* choose a space suitable for an expression *)
@ 
To avoid quadratric list append, I use John Hughes's
continuation-passing list operations.
<<expander.ml>>=
let empty = fun l -> l
let unit x = fun l -> x :: l
let (@::) x f = fun l -> x :: f l
let (@@) f1 f2 = fun l -> f1 (f2 l)
let rec concat = function
  | [] -> empty
  | [x] -> x  (* premature optimization is the root of all evil *)
  | [x; y] -> x @@ y  (* premature optimization is the root of all evil *)
  | [x; y; z] -> x @@ y @@ z (* premature optimization is the root of all evil *)
  | h::t -> h @@ concat t
@ 
The core of the expander is a function [[to_temp]], which takes an
expression and returns a pair containing a list of instructions and a
temporary such that executing those instructions develops the
expression into that temporary.
<<expander.ml>>=
type context = (RP.loc -> bool) * (char -> int -> R.loc)

let expand ((mem_like : RP.loc -> bool), (temp_for : char -> int -> R.loc)) =
  let rec to_temp e = match e with
    | RP.Const k ->
        let w = width e in
        let t = temp_for (space_for e) w in
        (t:R.loc), unit (R.store t (up e) w)
    | RP.Fetch (l, w) ->
        if mem_like l then
          let t = temp_for (space_for e) w in
          (t:R.loc), rtl (R.store t (up e) w)
        else
          uploc l, empty
    | RP.App (op, args) ->
        let (temps, is) = List.split (List.map to_temp args) in
        let w = width e in
        let t = temp_for (space_for e) w in
        t, (R.store t (up (RP.App (op, List.map fetch temps))) w @:: concat is)
  <<other expander functions>>
  and rtl r = match Rtl.Convert.rtl r with
  | RP.Rtl [(g, RP.Store (left, right, w))] ->
      assign g left right w
  | _ -> unit r (* no expansion takes place *)
  in fun r -> rtl r []
@ 

It would be good to do something with multiple assignments and with
guards, but for now I keep things very simple.

The remaining functions are simple.
<<other expander functions>>=
and assign g left right w =
  let r, is  = to_temp right in
  let l, is' = loc left in
  R.guard (up g) (R.store l (R.fetch r w) w) @:: is @@ is'

and loc l =
  if mem_like l then
    match l with
    | RP.Cell (space, agg, w, addr, prop) ->
        let addr, is = to_temp addr in
        uploc (RP.Cell (space, agg, w, fetch addr, prop)), is
    | _ -> assert false (* any mem-like location must be a cell *)
  else
    uploc l, empty
@

% ------------------------------------------------------------------ 
\subsection{Test Code}
% ------------------------------------------------------------------ 

This is some code I wrote to play with the expander in an interactive
interpreter.

<<expander.ml>>=
module Test = struct
    <<Test>>
end    

<<Test>>=
let truth      = RP.Const(RP.Bool true)
let const n    = RP.Const(RP.Bits(Bits.of_int n 32))
let loc n      = RP.Cell('m', R.Identity, 32, const n, 1)
let add x y    = RP.App(("add",[32]),[x; y])
let assign l r = RP.Store(l,r,32)

let mem_like = function
    | RP.Cell('m',_,_,_,_) -> true
    | _                    -> false

let count = ref 0
let tmp_for sp width =
    let () = count := !count + 1 in
    let l  = RP.Cell(sp, R.Identity, width, const !count, 1) in
        Rtl.Revert.loc l

let rtl        = let left  = loc 0 in
                 let right = add (const 2) (add (const 3) (const 4)) in
                    RP.Rtl([truth,assign left right])
@


