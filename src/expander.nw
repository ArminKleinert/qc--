% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

%%Grades: A Subsystem Later

\section{A generic, parameterized code expander}

\label{expander.sec}

A back end is obligated to expand code to RTLs.
To make retargeting easier, we provide here a generic code expander
that reduces the machine-dependent obligation.
If the machine can move data, operate on temporary registers, and
provide a few simple control-flow operations, this module does the
rest.
In other words, this module expands an RTL into a sequence of much
simpler RTLs.
The target-dependent code is relegated to a \emph{postexpander}.

To explain what is happening, I use the following
conventions:\\
\begin{tabular}{@{\quad}cl}
$t$& any temporary or register-like space\\
$m$& any memory-like space\\
$k$& any compile-time constant\\
$L$& any label or link-time constant\\
$\oplus$& any RTL value operator\\
$?$& any RTL comparison operator\\
\end{tabular}

We reduce RTLs to the following forms:
{\def\gets{\mathrel{:=}}%
$$\begin{array}{r@{}c@{}l@{\mskip10mu}ll}
m[t_l] & {}\gets{} & t     &\mbox{\texttt{store}}\\
t      & \gets & m[t_l]&\mbox{\texttt{load}} \\
t_1    & \gets & t_2   &\mbox{\texttt{move}} \\
t      & \gets & k     &\mbox{\texttt{li} (load immediate constant)}\\
t      & \gets & \oplus(t_1, \ldots, t_n) & 
  \mbox{ALU operations (\texttt{binop}, \texttt{rtlop}, etc)}\\
m[t_l] & \gets & \mathtt{lobits}_n(t)     &\mbox{\texttt{lostore} (store byte/halfword)}\\
t      & \gets & \mathtt{sx}(m[t_l])       &\mbox{\texttt{sxload} (load signed b/h)} \\
t      & \gets & \mathtt{zx}(m[t_l])       &\mbox{\texttt{zxload} (load unsigned b/h)} \\
\mathit{PC}& \gets & L &\mbox{\texttt{b} (branch)}\\
\mathit{PC}& \gets & t &\mbox{\texttt{br} (branch register)}\\
t \mathbin? t \rightarrow \mathit{PC}& \gets & L &\mbox{\texttt{bc} (branch conditional)}\\
\mathit{PC}& \gets & \rlap{t}\phantom{L/t} \mid t_l \gets t_r&\mbox{\texttt{cut\_to}}\\
\mathit{PC}& \gets & L/t \mid \cdots \mathit{PC} \cdots&\mbox{\texttt{call}/\texttt{callr}}\\
\end{array}
$$}
The treatment of [[call]] and [[cut to]] needs some explanation.
Both instructions change the program counter while also assigning to a
register.
In the case of [[call]], the program counter appears on the right-hand
side of some additional effect.
The generic expander assumes that this RTL originated in a call to
[[t.Target.call]], and that its only obligation is to expand the
expression denoting the callee.
The other effects are assumed not to need expansion, and they aren't
touched.
It's up to the [[t.Target.call]] to know what it's doing, although the
postexpander can validate the RTL if it wants.
In any case, we maintain the call as an atomic RTL. 

In the case of \mbox{[[cut to]]}, the program counter isn't mentioned
in an rvalue context, but some register (probably the stack
pointer) is modified along with the branch.
Here we don't need to know the details; all the expander needs to do is
preserve the atomicity of the assignment, but it can (and does) expand
out the right-hand sides.
In the case of cut to, the atomicity is not real; 
the illusion of atomicity is the result of
a conspiracy among the [[Target.t]], the expander, and the recognizer.
@
Driving the design is the following classification of operators:
\begin{itemize}
\item
A \emph{standard value operator} takes some bit vectors of reasonable
width and returns a result of that width.
\item
A \emph{weird value operator} takes some bit vectors of reasonable
width and returns a result of some other width.
The obvious weird operators are multiply (which doubles with width of
its operands) and multiprecision operators such as carry and borrow.
A~full classification awaits careful study of the list of operators.
\item
A \emph{size-changing operator} widens or narrows a bit vector.
I~believe there are only three such operators: [[sx]], [[zx]], and
[[lobits]].
\item
A \emph{comparison operator} takes one or more bit vectors and returns
a Boolean.
This category includes not only the usual integer and floating
comparisons but some machine-dependent condition-code testers and the
unnecessary [[bool]] operator.
\item
A \emph{Boolean operator} takes one or more Booleans and returns a
Boolean.
The only Boolean operators are [[conj]], [[disj]], and [[not]], and
I'm inclined to think they should be compiled to control flow.
\item
The elusive [[bit]] operator is the only operator to take a Boolean
and return a bit vector.
It's not supported here, but it could possibly be compiled to control
flow.
N.B.~Machines such as MIPS support [[bit]] by instructions such as SLT
(set less than), so it probably should not be compiled away by the
front end (sadly).
\end{itemize}
@
\begin{quote}\em
Aside:
I'm contemplating how we might create a hand-written expander that can
easily be specialized to establish ``most of'' the machine invariant
for many different targets, without relying so heavily on peephole
optimization \emph{post facto}.
For example, it's legitimate to think of $\mathtt{\$m}[\cdot]$ as an
``address context.''
Any machine should be able to deal with $t$~in an address context, but
many machines will also be able to deal with $t_1+t_2$ and $t+k$ (though
on some machines $k$~may not be too large).
Some machines can even deal with $t_1+4\times t_2$!
One possibility, then, would be to make an ``address context''
function dynamic through Lua.
Care would have to be taken to avoid paying for an expensive identity
function (embedding/projection) at every application of such a function.
\end{quote}
@
\subsection{The target-dependent postexpander}

\label{expander.sec:Postexpander.S}

Here is a signature for a postexpander for an integer/float/address
machine.
These are the operations every target must implement.
<<postexpander.mli>>=
<<postexpander>>
<<postexpander.ml>>=
<<postexpander>>
<<postexpander>>=
module type S = sig
  val byte_order : Rtl.aggregation (* used on all access to memory *)
  val wordsize   : int             (* used as width of register number! *)

  type temp      = Register.t
  type rtl       = Rtl.rtl
  type width     = Rtl.width
  type assertion = Rtl.assertion
  type operator  = Rtl.Private.opr

  <<generic expansion operations>>
end
@ 
We provide basic load and store.
<<generic expansion operations>>=
module Address : sig
  type t
  val reg : temp -> t
end

val load  : dst:temp  -> addr:Address.t -> assertion -> rtl list
val store : addr:Address.t -> src:temp -> assertion -> rtl list
@
We also provide sign-extending and zero extending loads
as well as low-bit--extracting stores, all of which are used only
with integer registers.
This is the only place the back end is required to support
size-changing operators; other uses, such as compositions of widens
and narrows, should be compiled to suitable code (shifts or identity)
somewhere upstream.
<<generic expansion operations>>=
val sxload  : dst:temp  -> addr:Address.t -> width -> assertion -> rtl list
val zxload  : dst:temp  -> addr:Address.t -> width -> assertion -> rtl list
val lostore : addr:Address.t  -> src:temp -> width -> assertion -> rtl list
@
We need a move operation.
<<generic expansion operations>>=
val move : dst:temp -> src:temp -> rtl list
@ 
Load immediate can take any constant except a Boolean.
<<generic expansion operations>>=
val li  : dst:temp -> Rtl.Private.const -> rtl list
@ 
An extended load-immediate can take sums and differences of
compile-time constants (including late compile-time constants). 
<<generic expansion operations>>=
val lix : dst:temp -> Rtl.exp           -> rtl list
@ 
We provide simple shortcuts for binary and unary operators.
I don't know if the shortcuts are worthwhile.
N.B.~no operator passed to any of these functions expects or returns a
Boolean! 
Ordinary value operators are expected to be supported by these
operations, but only at their natural widths.
Perhaps the weird value operators should be supported also.
<<generic expansion operations>>=
val binop : dst:temp -> operator -> temp -> temp -> rtl list
val unop  : dst:temp -> operator -> temp         -> rtl list
val rtlop : dst:temp -> operator -> temp list    -> rtl list
@
The arguments to the functions above must satisfy the invariants that the
temporaries are in the spaces the expander expects.
It announces these spaces through argument and result contexts.
The context names a temporary space from which to draw temporaries and
it also says when a temporary satisfies that context.
\nextchunklabel{expander.Postexpander.context}%
<<generic expansion operations>>=
type context = Rtl.space * (Register.t -> bool)
val icontext : context (* for ints *)
val fcontext : context (* for floats *)
val acontext : context (* for addresses *)
val arg_contexts   : operator -> context list
val result_context : operator -> context
@ 
To recognize control flow, the expander must be able to identify the
program counter.
We could provide an abstract test of type [[Rtl.loc -> bool]],
but until we need the extra generality, we avoid it.
On the other hand, we \emph{do} need a different representation of the
program counter on the left and the right of an assignment, in order
to handle the SPARC \emph{PC}/\emph{nPC} duo.
<<generic expansion operations>>=
val pc_lhs : Rtl.loc                    (* program counter as assigned by branch *)
val pc_rhs : Rtl.loc                    (* program counter as captured by call *)
@ 
To create control flow, the postexpander must provide an RTL that
includes an assignment to [[pc_lhs]].
This RTL must be the last in the execution sequence (and therefore the
head of the list that is returned.
We can branch to a temporary drawn from [[acontext]] or to a constant. 
<<generic expansion operations>>=
val br : tgt:temp -> rtl list               (* branch register *)
val b  : tgt:Rtl.Private.const -> rtl list  (* branch *)
@ 
For a conditional branch,  the target must be a static label, but the
postexpander provides any Boolean condition 
applied to temporaries.
Furthermore, it must be the case that the final, actual branch
instruction can have its sense reversed with [[bnegate]], and the
result is still representable by a single instruction on the target
machine.
<<generic expansion operations>>=
val bc      : temp -> operator -> temp -> tgt:Rtl.Private.const -> rtl list
val bnegate : rtl -> rtl  (* swap the condition in a conditional branch *)
@ The last (head) instruction from [[bc]] is the \emph{only}
instruction that may legitimately be passed to [[bnegate]].
@ 
The postexpander must be able to call direct and indirect.
<<generic expansion operations>>=
val callr : tgt:temp              -> others:Rtl.Private.effect list -> rtl list
val call  : tgt:Rtl.Private.const -> others:Rtl.Private.effect list -> rtl list
@
The [[cut to]] is as created by the target-dependent code, except
right-hand sides have been expanded to temporaries.
<<generic expansion operations>>=
val cut_to : Rtl.Private.effect list -> rtl list
@
The postexpander may insist on having some instructions untouched.
This is possible only for an instruction with multiple effects and a
single guard.
<<generic expansion operations>>=
val don't_touch_me : Rtl.Private.effect list -> bool
@

\subsection{Implementation outline}

The [[Proc.t]] gives the expander a supply of temporaries.
<<expander.mli>>=
module type S = sig
  val expand : ('a, 'b, 'c, 'd) Proc.t' -> Rtl.rtl -> Rtl.rtl list
  val cfg    : 'a -> Proc.t ->      bool
  val new_cfg: 'a -> Ast2ir.proc -> bool
end 
module IntFloatAddr (Post : Postexpander.S) : S
@ 
Here are some abbreviations and utilities.
<<expander.ml>>=
module type S = sig
  val expand : ('a, 'b, 'c, 'd) Proc.t' -> Rtl.rtl -> Rtl.rtl list
  val cfg    : 'a -> Proc.t -> bool
  val new_cfg: 'a -> Ast2ir.proc -> bool
end 

module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target2

module Up   = Rtl.Up
module Down = Rtl.Dn

let upassn = Rtl.Up.assertion
@ 
\subsection{Utilities and debugging code}
<<expander.ml>>=
let fetch l = RP.Fetch (Down.loc l, RU.Width.loc l)
let width e = RU.Width.exp (Up.exp e)
@ 
To avoid quadratric list append, I use John Hughes's
continuation-passing list representation.
<<expander.ml>>=
let empty       = fun l -> l
let unit x      = fun l -> x :: l
let (@::) x f   = fun l -> x :: f l
let (@@) f1 f2  = fun l -> f1 (f2 l)
let to_hughes l = fun l' -> l @ l'
let rec concat = function
  | [] -> empty
  | [x] -> x  (* premature optimization is the root of all evil *)
  | [x; y] -> x @@ y  (* premature optimization is the root of all evil *)
  | [x; y; z] -> x @@ y @@ z (* premature optimization is the root of all evil *)
  | h::t -> h @@ concat t
@ 
Some debugging code is most helpful.
The expander writes debugging information as it goes;
to activate it, try \texttt{VERBOSITY=5~qc--}.
<<expander.ml>>=
module D = struct (* debugging *)
    let strings = Verbose.say 5 
    let int n = string_of_int n
    let exp e = Rtlutil.ToReadableString.exp (Up.exp e) 
    let rtl r = Rtlutil.ToReadableString.rtl r 
    let pr_is   is = List.iter (fun r -> strings ["  "; rtl r; "\n"]) (List.rev (is[]))
    let pr_rtls rs = List.iter (fun r -> strings ["  "; rtl r; "\n"]) (List.rev rs)
    let temp (s, n, w) =
      "$" ^ Char.escaped s ^ "[" ^ int n ^ "] : " ^ int w ^ " loc" 
end
@ 
This little hack
enables statement-count profiling to work even when the expander loops infinitely.
It was useful in debugging the expander.
<<expander.ml>>=
let _ = Sys.set_signal Sys.sigterm (Sys.Signal_handle (fun _ -> exit 0))
@ 

@ 
% ----------------------------------------------------------------
\subsection{A generic expander}
% ----------------------------------------------------------------

This expander is intended for machines with integer, floating, and
address register spaces.
It will also work with integer/float machines, since we can make
address registers a synonym for integer registers.
<<expander.ml>>=
module IntFloatAddr (Post : Postexpander.S) = struct
  let pc_lhs = Down.loc Post.pc_lhs
  let pc_rhs = Down.loc Post.pc_rhs
  <<generic expander>>
  <<generic flow-graph expander>>
end
@ 
Within the expander, we need to be able to turn a temporary into a
location. 
For this we need the postexpander.
It's questionable whether the byte order of a register should be fixed
to that of memory, but so be it.
When we refactor the compiler to support register locations directly,
this function should go away.
<<generic expander>>=
let temploc (space, n, w) = R.reg (space, n, w)
@ 
\subsection{Creating temporaries in allocation contexts}
Much of the expander involves computing subexpressions into
temporaries.
To choose the right temporary for an expression, we need to know the
\emph{context}.
The context tells us what sort of temporary is appropriate
(typically integer, float, or address).
Sadly, there are two representations of contexts.
\begin{itemize}
\item
A \emph{dynamic} context provides two items: an infinite
supply of temporaries, and a predicate that says whether an existing
temporary can be used in the context.
The supply of temporaries must be shared with the rest of the
compiler, including the variable placer and
register allocator.
Because the supply of temporaries is new for each procedure, we can't
provide one at compile-compile time.
This is why the context is \emph{dynamic}.
\item
A \emph{static} context provides, instead of a supply of temporaries,
the name of the space from which the temporaries should be drawn.
(The static context also includes the checking predicate.)
We can therefore create a static context at compile-compile time, and
in fact we require the postexpander to supply three of them (see
chunk~\subpageref{expander.Postexpander.context}). 
\end{itemize}
We use the allocator in the [[Proc.t]] to convert from a static
context to a dynamic context; see function [[contextmap]] in
chunk~\subpageref{expander.contextmap}. 
@
Here we define the [[alloc]] and [[check]] functions, which use a
dynamic context.
(Actually [[check]] can use either kind.)
<<generic expander>>=
let alloc (allocate, check) w = allocate w
let ok    (allocate, check) reg = check reg
@ 
Function [[temp_in_context]] takes an existing temporary and a
context, and returns a (possibly new) temporary that is OK for the
context (along with instructions that make it so). 
<<generic expander>>=
let temp_in_context ((space, n, w) as t) context instructions =
  if ok context t then
    t, instructions
  else
    let t' = alloc context w in
    t', to_hughes (Post.move t' t) @@ instructions
@ 
Within the expander, we eagerly build some dynamic contexts:
[[icontext]], [[acontext]], and [[fcontext]].
We also keep function [[contextmap]] for those times when we get a
context that's not known at compile-compile time.
\nextchunklabel{expander.contextmap}%
<<generic expander>>=
let expand proc =
  let contextmap (space, checker) =
    (Talloc.Multiple.reg proc.Proc.temps space, checker) in
  let icontext = contextmap Post.icontext in
  let acontext = contextmap Post.acontext in
  let fcontext = contextmap Post.fcontext in
  <<context guessing>>
  let alloc_direct (space, _) = Talloc.Multiple.reg proc.Proc.temps space in
  <<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>
  in fun r -> rtl r []
@ 
To find the context for the operands of a comparison, I use the
dreadful hack that every floating-point 
comparison begins with [[f]] and no other comparison does.
This code probably should be replaced with a call to
[[Post.arg_contexts]].
<<context guessing>>=
let cmp_context (oprname, ws) =
  if oprname.[0] = 'f' then fcontext else icontext in
@
In other situations, we may have to guess a context based on a
right-hand side. 
<<context guessing>>=
let guess_context = function
  | RP.Const k -> icontext
  | RP.Fetch(RP.Reg (('f'|'u'), _, _),_) -> fcontext
  | RP.Fetch _ -> icontext
  | RP.App (op, args) -> contextmap (Post.result_context op) in
@ 
\subsection{Expanding an expression}
The core of the expander is a function [[to_temp]], which takes an
expression and returns a pair containing a list of instructions and a
temporary such that executing those instructions develops the
expression into that temporary.

Unprimed versions of functions issue debugging screeds; primed
versions do the real work.
Here we define the primed and use the unprimed; the two are connected
with debugging code below.

Most cases identify what postexpander function should be used and
create suitable temporaries.%
\footnote{We have a small problem with register targeting; the problem
effects the size of the expanded code and therefore the compile-time
efficiency.
We wish to avoid generating superfluous move
instructions.
There are two possible contexts: if a right-hand side is already a temporary, we avoid
allocating a second temporary.
But if a left-hand side is already a temporary, we fail to ``target''
the right-hand side into that temporary.
It is not obvious to NR how to write an expander that achieves both.}
<<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>=
let rec to_temp' context e = match e with
  | RP.Const k ->
      let w = width e in
      let t = alloc context w in
      t, to_hughes (Post.li t k)
  | RP.App (_, _) when is_compile_time_constant e ->
      let w = width e in
      let t = alloc context w in
      t, to_hughes (Post.lix t (Up.exp e))
  | RP.Fetch (RP.Mem ('m', agg, w, addr, assn), w') ->
      let t = alloc context w in
      let a, is = address addr in
      assert (agg = Post.byte_order);
      assert (w = w');
      t, to_hughes (Post.load t a (upassn assn)) @@ is
  | RP.Fetch (RP.Reg (space, i ,w), w') ->
      assert (w = w');
      temp_in_context (space, i, w) context empty
  | RP.Fetch _ ->
      Impossible.impossible "memory-like access to non-memory space"
  <<cases for sign-extending and zero-extending loads>>
  <<cases for sign-extending and zero-extending divides>>
  | RP.App (op, args) ->
      let (temps, is) =
        List.split (List.map2 (fun c e -> to_temp (contextmap c) e)
                      (Post.arg_contexts op) args)
      in
      let w = width e in
      let t = alloc_direct (Post.result_context op) w in
      let compute = match temps with
      | [x; y] -> Post.binop t op x y  (* see note on binary operators below *)
      | [x]    -> Post.unop  t op x
      | _      -> Post.rtlop t op temps
      in
      temp_in_context t context (to_hughes compute @@ concat is)
<<other generic expander functions>>
@ The note on binary operators is that eventually the generic expander
might be extended so it can deal with a two-address target machine.
The generic expander might (somehow) divine whether the operation is 
in $L \mathrel{:=} L \oplus R$ form or in $R \mathrel{:=} L \oplus R$ form,
and it could call appropriate supporting functions in the target.
On the other hand, we could just rely on peephole optimization\ldots
@
Sign-extending and zero-extending loads are done into integer registers only.
This fact is documented in the postexpander interface.
<<cases for sign-extending and zero-extending loads>>=
| RP.App (("sx", [n; w]), [RP.Fetch (RP.Mem ('m', agg, n', addr, assn), n'')]) ->
    assert (n == n' && n' == n'');
    let t = alloc icontext w in
    let a, is = address addr in
    assert (agg = Post.byte_order);
    temp_in_context t context (to_hughes (Post.sxload t a n (upassn assn)) @@ is)
| RP.App (("zx", [n; w]), [RP.Fetch (RP.Mem ('m', agg, n', addr, assn), n'')]) ->
    assert (n == n' && n' == n'');
    let t = alloc icontext w in
    let a, is = address addr in
    assert (agg = Post.byte_order);
    temp_in_context t context (to_hughes (Post.zxload t a n (upassn assn)) @@ is)
@ 
Division is going to be a real problem; I can just tell.
Here's a hack which is untested and probably useless.
<<cases for sign-extending and zero-extending divides>>=
| RP.App ((("divu"|"modu") as divmod, [w; n]), [RP.App (("zx", [n'; w']), [x]); y])
  when w = w' && n = n' ->
    let t = alloc icontext n in
    let tx, isx = to_temp icontext x in
    let ty, isy = to_temp icontext y in
    let divmod = Post.binop t ((divmod ^ "_trunc"), [n]) tx ty in
    temp_in_context t context (to_hughes (divmod) @@ isy @@ isx)
@
We might one day support multiple addressing modes, but for now, just registers. 
<<other generic expander functions>>=
and address exp =
  let t, is = to_temp acontext exp
  in  Post.Address.reg t, is
@
A compile-time constant is a sum or difference of compile-time constants.
<<other generic expander functions>>=
and is_compile_time_constant = function
  | RP.Const (RP.Bits _ | RP.Late (_, _)) -> true
  | RP.App   ((("add"|"sub"), [w]), es)   -> List.for_all is_compile_time_constant es
  | _ -> false
@ 

\subsection{Expanding RTLs}

This part of the generic expander is currently simpler than it really
needs to be.
The main simplification is it doesn't deal with multiple effects.
In particular, it can't expand a call or a cut to node.
This flaw should be corrected soon.

In the longer term,
it would be good to do something more general with multiple assignments and with
guards. {For example, if a guard uses a non-comparison, Boolean
operator, it would be a fine thing to compile it to control flow.}
@
The expander is divided into three layers:
\begin{itemize}
\item
Function [[rtl]] expands a general RTL.
This function will need future work as noted above.
\item
Function [[guarded]] expands a single guarded effect.
Except for conditional branch, it currently handles only trivial
guards.
Because a nontrivial guard may appear only on a conditional branch,
this expander can't handle predicated instructions.
\item
Function [[assign]] expands an assignment with no guard.
\end{itemize}
@
Because there's no support for multiple assignment yet, the [[rtl']]
function is trivial.
<<other generic expander functions>>=
and rtl' r = match Down.rtl r with
| RP.Rtl [(g, RP.Store (left, right, w))] -> guarded g left right w
| RP.Rtl [(g, RP.Kill _)] -> unit (R.par []) (* IS THIS A CHEAT? *)
| RP.Rtl [] -> unit r  (* a nop is a nop is a nop *)
| RP.Rtl ((_::_::_) as effs) -> (<<handle RTL with multiple effects [[effs]]>>)
@ 
The type system tells us that anything in a guard must be a Boolean
operator or a comparison operator.\footnote
{Finally we get a payoff from NR's obsession with the distinction
between [[bool]] and \mbox{[[#1 bits]]}.}
To compile a Boolean, we require that
a guarded effect with a nontrivial guard always be expanded into
a sequence that ends in a conditional branch.
To compile a comparison, we rely on the postexpander.
<<other generic expander functions>>=
and guarded g left right w =
  match g with
  | RP.Const (RP.Bool b) -> if b then assign left right w else empty
  | RP.Const _ -> Impossible.impossible "non-Bool constant as guard"
  | RP.Fetch _ -> Impossible.impossible "fetch as guard"
  | RP.App (("not", []), [g]) ->
      let is = guarded g left right w in
      (match is [] with
      | h :: t -> to_hughes (Post.bnegate h :: t)
      | [] -> Impossible.impossible "empty list of instructions for cond. branch")
  | RP.App ((("conj" | "disj"), []), [g]) ->
      Impossible.unimp "conjunction or disjunction in generic code expander"
      (* one day to be expanded into control flow *)
  | RP.App (cmp, [x; y]) ->
      if left = pc_lhs then
        let context = cmp_context cmp in
        let xt, xis = to_temp context x in
        let yt, yis = to_temp context y in
        match right with
        | RP.Const c -> to_hughes (Post.bc xt cmp yt c) @@ yis @@ xis
        | _ -> Impossible.unimp "conditional branch to computed location"
      else
        Impossible.unimp "guard on other than conditional branch";
  | RP.App (cmp, _) ->
      Impossible.unimp "non-binary comparison in guard"
@ POSSIBLY  REFERENCES TO [[pc_lhs]] SHOULD BE REPLACED BY USING
[[Target2.goto.project]] AND FRIENDS.  IN GENERAL, WE NEED TO SEE
ABOUT MERGING SIMILAR INFORMATION IN THE [[Target]] AND
[[Postexpander.S]] INTERFACES.
@
An assignment is either a goto, a store, or a computation where we put
something in a temporary.
<<other generic expander functions>>=
and assign left right w =
  if left = pc_lhs then  (* unconditional branch *)
    match right with
    | RP.Const c -> to_hughes (Post.b c)
    | _ ->
        let r, is = to_temp acontext right in
        to_hughes (Post.br r) @@ is
  else
    match left with
    | RP.Mem ('m', agg, w, addr, assn) ->  (* some kind of store *)
        assert (agg = Post.byte_order || agg = Rtl.Identity);
        let a, is' = address addr in
        (match right with
        | <<\emph{pattern [[->]] action} for low-bit store>>
        | _ ->
            let r, is = to_temp (guess_context right) right in
            to_hughes (Post.store a r (upassn assn)) @@ is' @@ is)
    | RP.Mem (_, _, _, _, _) ->
        Impossible.unimp "memory space other than 'm'"
    | RP.Reg (space, i, w) -> (* computation *)
        let r, is = to_temp (guess_context right) right in
        to_hughes (Post.move ~dst:(space, i, w) ~src:r) @@ is
    | RP.Var (_,_,_) -> Impossible.impossible "variable passed to code expander"
    | RP.Slice (_,_,_) -> Impossible.unimp "slice"
<<\emph{pattern [[->]] action} for low-bit store>>=
RP.App (("lobits", [w; n]), [rhs]) ->
  let r, is = to_temp icontext rhs in
  to_hughes (Post.lostore a r n (upassn assn)) @@ is' @@ is
@ 
Something with multiple effects is either a call, a [[cut to]], or a
shuffle.
In all three cases, the guard had better be trivial.
<<handle RTL with multiple effects [[effs]]>>=
let strip_trivial_guards l =
  List.fold_right
    (fun (g, e) l ->
      match g with RP.Const (RP.Bool b) -> if b then e :: l else l
      | _ -> Impossible.unimp "multiple effects with a nontrivial guard") l [] in
let has_pc_on_left = function
  | RP.Store (pc, _, _) -> pc = pc_lhs
  | RP.Kill _ -> false in
let has_pc_on_right = function
  | RP.Store (_, e, _) -> RU.HasLoc.exp ((=) pc_rhs) e
  | RP.Kill _ -> false in
<<support for call, [[cut to]], and shuffle>>
let effs = strip_trivial_guards effs in
if Post.don't_touch_me effs then
  R.par (List.map Up.effect effs) @:: empty
else
  if List.exists has_pc_on_left effs then
    if List.exists has_pc_on_right effs then
      make_call effs
    else
      make_cut_to effs
  else
    make_shuffle effs
@ 
<<support for call, [[cut to]], and shuffle>>=
let (<<) f g x = f (g x) in
let make_call effs = 
  let others = List.filter (not << has_pc_on_left) effs in
  match List.filter has_pc_on_left effs with
  | [RP.Store(pc, RP.Const c, _)] -> to_hughes (Post.call c others)
  | [RP.Store(pc, e, _)] ->
      let t, is = to_temp acontext e in
      to_hughes (Post.callr t others) @@ is
  | _ -> Impossible.impossible "multiple pc := e in call" in
@ 
<<support for call, [[cut to]], and shuffle>>=
let make_cut_to effs =
  let expand e (preds, effs) = match e with
    | RP.Store (l, r, w) ->
        let t, is = to_temp (guess_context r) r in
        (is @@ preds, RP.Store(l, RP.Fetch(RP.Reg t, w), w) :: effs)
    | RP.Kill l -> (preds, RP.Kill l :: effs) in
  let preds, effs = List.fold_right expand effs (empty, []) in
  to_hughes (Post.cut_to effs) @@ preds in
@ 
Shuffle would be cooler if we carefully arranged to make things
push-like, but never mind.
As it is, we look for an effect that can go first (because its
left-hand side doesn't alias with any other right-hand-side), and if
we don't find one, we introduce a new temporary.
<<support for call, [[cut to]], and shuffle>>=
let make_shuffle effs =
  let strip_store = function
    | RP.Store (l, r, w) -> (l, r, w)
    | RP.Kill _ -> Impossible.impossible "kill in shuffle" in
  let rec shuffle =
    let assign = noisy_assign in
    function
    | [(l, r, w)] -> assign l r w
    | [] -> empty
    | ((l, (r:RP.exp), w) :: rest) as effs ->
        <<definition of [[try_first_effect]]>>
        try_first_effect effs
          (fun (l, r, w) rest -> shuffle rest @@ assign l r w)
          (fun () ->
            let t = alloc (guess_context r) w in
            assign l (RP.Fetch (RP.Reg t, w)) w @@
            shuffle rest @@
            assign (RP.Reg t) r w)
  in shuffle (List.map strip_store effs) in
<<definition of [[try_first_effect]]>>=
let try_first_effect effects succ fail =
  let rec maybe bad = function
    | [] -> fail()
    | (l, r, w) :: rest ->
        let alias (_, r, _) = RU.MayAlias.exp' l r in
        if not (List.exists alias bad || List.exists alias rest) then
          succ (l, r, w) (List.rev_append bad rest)
        else
          maybe ((l, r, w) :: bad) rest in
  maybe [] effects in
@ 
\subsection{Debugging the expander}
These wrapper functions show what the expander [[rtl]] and register
targeter [[to_temp]] are doing.
<<other generic expander functions>>=
and rtl r =
  let is = rtl' r in
  let _ = D.strings ["Expanded "; D.rtl r; " into\n"]; D.pr_is is in
  is
and noisy_assign l r w =
  let is = assign l r w in
  let r = R.store (Up.loc l) (Up.exp r) w in
  let _ = D.strings ["Shuffling "; D.rtl r; " into\n"]; D.pr_is is in
  is
and to_temp context e =
  let _ = D.strings ["Targeting "; D.exp e; "...\n"] in
  let t, is = to_temp' context e in
  let _ = D.strings ["Targeted "; D.exp e; " => "; D.temp t; " by \n"] in
  let _ = D.pr_is is in
  t, is
@   
\subsection{Old code no longer relevant}
This is old stuff left over, which I might want to resurrect some day
when I try to expand general guards.
<<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>=
in let rec old_general_guard g left right w =
  (* this case is bogus *)
  let r, is  = to_temp (guess_context right) right in
  let l, is' = old_loc left in
  R.guard (Up.exp g) (R.store l (R.fetch (temploc r) w) w) @:: is @@ is'
and old_loc l =
  match l with
  | RP.Mem ('m', agg, w, addr, assn) ->
      let addr, is = to_temp (acontext) addr in
      Up.loc (RP.Mem ('m', agg, w, fetch (temploc addr), assn)), is
  | _ -> Up.loc l, empty
@
\subsection{The flow-graph expander}
Here we expand every RTL in a flow graph.
<<generic flow-graph expander>>=
module G  = Cfg4
module GU = Cfgutil
let cfg _ proc =
  let g = proc.Proc.cfg in
  let t = proc.Proc.target in
  let _ = G.gm_enumerate g in
  let nodes = GU.fold_bwd g (fun x y -> x::y) [] in
  let modified = ref false in
  let exp n =
      match expand proc (G.instr n) with
      | last :: preds ->
          ignore (List.fold_left (fun n i -> G.gm_insert_assign_before i n) n preds);
          G.upd_instr n (fun _ -> last);
          (match preds with [] -> () | _ :: _ -> modified := true)
      | [] ->
          G.upd_instr n (fun _ -> R.par [])
            (*don't set modified := true --- hope for the best*)
  in
  List.iter exp nodes;
  !modified
<<generic flow-graph expander>>=
let new_cfg _ proc =
  let module G = Cfgx.M in
  let g = proc.Proc.cfg in
  let t = proc.Proc.target in
  let modified = ref false in
  let exp n =
    match G.to_instr n with
    | None -> ()
    | Some i ->
        match expand proc i with
        | []     -> G.update_instr (fun _ -> R.par []) n
        | [last] -> G.update_instr (fun _ -> last)     n
        | last :: last_new :: preds ->
            let last_new = G.instruction g last_new ~succ:(G.illegal g) in
            let insert   = List.fold_left (fun next i -> G.instruction g i ~succ:next)
                           last_new preds in
            G.splice_before ~entry:insert ~exit:last_new n;
            G.update_instr (fun _ -> last) n;
            modified := true in
  G.iter_nodes exp g;
  !modified
@

\subsection{Compilation of Boolean expressions into control flow.}

THIS CODE SHOULD BE MOVED TO THE GENERIC CODE EXPANDER.

An if-statement is governed by a boolean expression that has no side
effects. A simple translation is to use this expression as a guard for a
conditional branch to implement the if-statement. The guard finally
becomes a guard in the {\rtl} that implements the conditional branch.
The problem is, that the guarding expression can be quite complex and
must be simplified before a machine instruction can be found that
implements it. We translate a boolean expression $e$ into a sequence of
nodes. If $e$ evaluates to true, the control flow reaches the end of the
sequence, otherwise it branches to a provided label. 


\begingroup % keeps definitions local
\def\C#1{{\cal C}[\![#1]\!]}
\let\i\textit

The translation is summarized by the following function $\C{\cdot}~f$
that takes a boolean expression $e$ and a continuation $f$ to branch if
the expression evaluates to false. The result is a sequence of nodes,
that branches to $f$ if $e$ is false, and falls through otherwise.

\begin{center}
\begin{eqnarray*}
    \C{\i{true}}~f              & \to & \i{nop}\\
    \C{\i{false}}~f             & \to & \i{goto}~f\\
    \C{x \vee y}~f              & \to & \C x~l; l: \C y~f\\
    \C{x \wedge y}~f            & \to & \C x~f; \C y~f\\
    \C{\lnot x}~f               & \to & \C x~l; \i{goto}~f; l:\\
    \C{\oplus(e_1, \dots, e_n)} & \to & 
        \i{if}(\lnot \oplus(e_1, \dots, e_n)\{\i{goto}~f\}
\end{eqnarray*}
\end{center}

The last line covers the case of an application with a boolean result
but non-boolean arguments. Currently only the logical operators $\lnot$,
$\vee$, and $\wedge$ \emph{take} boolean arguments.

The implementation first translates the governing expression into an
{\rtl} and then tranlate it into the sequence of nodes.

\begin{quote}\it
    I think the code below shows a design weakness: we have decided to
    have explicit label nodes in the {\cfg}. In order to jump or branch
    to a node one needs the symbol associated with the label. This,
    however, cannot be observed. This means, labels can only be used
    where they are constructed. In the implementation of the {\cfg}
    labels could be made a sub-class of nodes. However, since we shield
    the object-oriented nature of nodes behind standard types, this is
    not easily possible. Nodes must be more abstract or labels must
    become special.  --CL
\end{quote}

\endgroup

<<old Make statements>>=
and guard state succ fail e = 
    let rec guard' succ fail = function

    | RP.Const(RP.Bool(true))         -> succ
    | RP.Const(RP.Bool(false))        -> fail
    | RP.Const(_)                     -> assert false
    | RP.Fetch(_)                     -> assert false
    <<special cases that match floating-point comparisons>>
    | RP.App(("conjoin",_), [x;y])    -> 
        let ll    = Idgen.label state.proc    in
        let ls    = F.symbol env ll     in
        let fail  = G.gm_label state.cfg ll ls fail in
            let tail = guard' succ fail y in
            let head = guard' tail fail x in
                head
    | RP.App(("not",_), [x])          -> guard' fail succ x
    | RP.App(("disjoin",_), [x;y])    ->
        let ll    = Idgen.label state.proc    in
        let ls    = F.symbol env ll     in
        let succ  = G.gm_label state.cfg ll ls succ in
        let y     = guard' succ fail y    in
        let lexp  = Rtl.link ls state.target.T.pointersize in
        let lrtl  = state.target.T.goto.T.embed lexp in
        let succ  = G.gm_goto state.cfg lrtl [G.lookup state.cfg ll] in
                guard' succ y x              
    | RP.App(opr, args) as e -> 
        let sl    = Idgen.label state.proc    in
        let ss    = F.symbol env sl     in
        let succ  = G.gm_label state.cfg sl ss succ in
        
        let fl    = Idgen.label state.proc    in
        let fs    = F.symbol env fl     in
        let fail  = G.gm_label state.cfg fl fs fail in
        
        let oexp  = Rtl.link fs state.target.T.pointersize in
        let ortl  = state.target.T.goto.T.embed oexp in
        let fail  = G.gm_goto state.cfg ortl [G.lookup state.cfg fl] in
        
        let e     = R.Revert.exp e in
        let link  = Rtl.link ss state.target.T.pointersize in
        let rtl   = state.target.T.branch.T.embed (e,link)  in
            G.gm_branch state.cfg rtl succ fail 
    in
        { state with node = guard' succ fail e }
        
@
<<special cases that match floating-point comparisons>>=
(* the evil empire *)
@
