% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

%%Grades: A Subsystem Later

\section{Things yet to be covered in this document}
\begin{enumerate}
\item
Kill effects
\item
When to use [[don't_touch_me]]
\item
The problem of instructions with multiple effects:
The generic expander can't expand while maintaining multiple effects
\item
Contexts really aren't general enough---need to say something about
widths, and hardware registers would be nice
\item
Not covered to sufficient detail: mutual recursion between generic
expander and postexpander 
(e.g., tying of recursive knot places restrictions on use)
\end{enumerate}


\section{A generic, parameterized code expander}

\label{expander.sec}

A back end is obligated to expand code in such a way that each node in
the flow graph bears an RTL that can be represented as a single
instruction on the target machine (with a few exceptions noted below).
To make retargeting easier, we provide here a generic code expander
that reduces the machine-dependent obligation.
If the machine can move data, operate on temporary registers, and
provide a few simple control-flow operations, this module does the
rest.
In other words, this module expands a flow-graph node into a subgraph of
simpler nodes.
The target-dependent code is relegated to a \emph{postexpander}.

To explain what is happening, I use the following
conventions:\\
\begin{tabular}{@{\quad}cl}
$t$& any temporary or register-like space\\
$m$& any memory-like space\\
$k$& any compile-time constant\\
$L$& any label or link-time constant\\
$\oplus$& any RTL value operator\\
$?$& any RTL comparison operator\\
\end{tabular}

For a register machine, we reduce RTLs to the following forms:
{\def\gets{\mathrel{:=}}%
$$\begin{array}{r@{}c@{}l@{\mskip10mu}ll}
m[t_l] & {}\gets{} & t     &\mbox{\texttt{store}}\\
t      & \gets & m[t_l]&\mbox{\texttt{load}} \\
t_1    & \gets & t_2   &\mbox{\texttt{move}} \\
t      & \gets & k     &\mbox{\texttt{li} (load immediate constant)}\\
t      & \gets & \oplus(t_1, \ldots, t_n) & 
  \mbox{ALU operations (\texttt{binop}, \texttt{rtlop}, etc)}\\
m[t_l] & \gets & \mathtt{lobits}_n(t)     &\mbox{\texttt{lostore} (store byte/halfword)}\\
t      & \gets & \mathtt{sx}(m[t_l])       &\mbox{\texttt{sxload} (load signed b/h)} \\
t      & \gets & \mathtt{zx}(m[t_l])       &\mbox{\texttt{zxload} (load unsigned b/h)} \\
\mathit{PC}& \gets & L &\mbox{\texttt{b} (branch)}\\
\mathit{PC}& \gets & t &\mbox{\texttt{br} (branch register)}\\
t \mathbin? t \rightarrow \mathit{PC}& \gets & L &\mbox{\texttt{bc} (branch conditional)}\\
\mathit{PC}& \gets & \rlap{t}\phantom{L/t} \mid t_l \gets t_r&\mbox{\texttt{cut\_to}}\\
\mathit{PC}& \gets & L/t \mid \cdots \mathit{PC} \cdots&\mbox{\texttt{call}/\texttt{callr}}\\
\end{array}
$$}
The treatment of [[call]] and [[cut to]] needs some explanation.
Both instructions change the program counter while also assigning to a
register.
In the case of [[call]], the program counter appears on the right-hand
side of some additional effect.
The generic expander assumes that this RTL originated in a call to
[[t.Target.call]], and that its only obligation is to expand the
expression denoting the callee.
The other effects are assumed not to need expansion, and they aren't
touched.
It's up to the [[t.Target.call]] to know what it's doing, although the
postexpander can validate the RTL if it wants.
In any case, we maintain the call as an atomic RTL. 

In the case of \mbox{[[cut to]]}, the program counter isn't mentioned
in an rvalue context, but some register (probably the stack
pointer) is modified along with the branch.
Here we don't need to know the details; all the expander needs to do is
preserve the atomicity of the assignment, but it can (and does) expand
out the right-hand sides.
In the case of \mbox{[[cut to]]}, the atomicity is not real; 
the illusion of atomicity is the result of
a conspiracy among the [[Target.t]], the expander, and the recognizer.
(The reason for the illusion is that between the time the stack
pointer is mutated and the time the branch is taken, the program's
internal invariants are no longer satisfied---in particular, it is not
safe to spill at that point.)
@
Some machines, notably the Pentium floating-point unit, are not
register machines but stack machines.
The classification above is not useful because there are few
operations that can work with an arbitrary temporary~$t$.
@
Driving the design is the following classification of operators:
\begin{itemize}
\item
A \emph{standard value operator} takes some bit vectors of reasonable
width and returns a result of that width.
\item
A \emph{weird value operator} takes some bit vectors of reasonable
width and returns a result of some other width.
The obvious weird operators are multiply (which doubles with width of
its operands) and multiprecision operators such as carry and borrow.
A~full classification awaits careful study of the list of operators.
\item
A \emph{size-changing operator} widens or narrows a bit vector.
I~believe there are only three such operators: [[sx]], [[zx]], and
[[lobits]].
\item
A \emph{comparison operator} takes one or more bit vectors and returns
a Boolean.
This category includes not only the usual integer and floating
comparisons but some machine-dependent condition-code testers and the
unnecessary [[bool]] operator.
\item
A \emph{Boolean operator} takes one or more Booleans and returns a
Boolean.
The only Boolean operators are [[conj]], [[disj]], and [[not]], and
I'm inclined to think they should be compiled to control flow.
\item
The elusive [[bit]] operator is the only operator to take a Boolean
and return a bit vector.
It is compiled to control flow below.
N.B.~Machines such as MIPS support [[bit]] by instructions such as SLT
(set less than), so it probably should not be compiled away by the
front end (sadly).
\end{itemize}
This classification speaks to the properties of the operators
themselves.
As such, it
 is orthogonal to the distinction between a
register machine and a stack machine, which speaks to how operators
are implemented on particular hardware.
@
\begin{quote}\em
Aside:
I'm contemplating how we might create a hand-written expander that can
easily be specialized to establish ``most of'' the machine invariant
for many different targets, without relying so heavily on peephole
optimization \emph{post facto}.
For example, it's legitimate to think of $\mathtt{\$m}[\cdot]$ as an
``address context.''
Any machine should be able to deal with $t$~in an address context, but
many machines will also be able to deal with $t_1+t_2$ and $t+k$ (though
on some machines $k$~may not be too large).
Some machines can even deal with $t_1+4\times t_2$!
One possibility, then, would be to make an ``address context''
function dynamic through Lua.
Care would have to be taken to avoid paying for an expensive identity
function (embedding/projection) at every application of such a function.
\end{quote}
@
\subsection{Support for expansion---the postexpander module}

The [[Postexpander]] module does two jobs:
\begin{itemize}
\item
It exports a signature (module type)~[[S]], which defines the
interface that every target-dependent postexpander must implement.
\item
It defines some types and utility functions that can be used by
postexpanders. 
\end{itemize}

The overall structure of the postexpander is as follows:
<<postexpander.mli>>=
<<abstract types for postexpanders>>
<<types for postexpanders>>
<<exported utility functions for postexpanders>>
<<exported utility functions for use by the generic expander>>
<<signature of a postexpander>>
<<postexpander.ml>>=
type uid = int
<<types for postexpanders>>
<<signature of a postexpander>>
@ 
To make the interfaces more readable, we use these type abbreviations:
<<types for postexpanders>>=
type temp      = Register.t
type rtl       = Rtl.rtl
type exp       = Rtl.exp
type width     = Rtl.width
type assertion = Rtl.assertion
type operator  = Rtl.Private.opr
@
@
\paragraph{Fragments of flow graphs}

Working with the mutable control-flow graph is awkward and
error-prone.
We therefore define some special, immutable types to represent
fragments of the flow graph (subgraphs) both before and after expansion.
What kind of fragment we have depends on what sort of flow-graph node
we are expanding.
\begin{itemize}
\item
A node that represents straight-line control flow is expanded into a
[[block]].
A~[[block]] represents a subgraph with a single entry and single exit.
\item
A~node that represents unconditional control transfer  (including
unconditional branch,  multiway branch, call, return, [[cut to]], etc.)
is expanded
into a [[branch]].
The [[branch]] consists of a (possibly empty) [[block]] followed by an
RTL.
The trailing RTL is always the control-transfer instruction.
A  subgraph represented by a [[branch]] has a single entry, and while
it may have multiple 
exits, all those exits are reached by the same instruction: the final
RTL.
\item
A conditional branch is expanded into a [[cbranch]].
This subgraph is somewhat more complicated because it has \emph{two}
exits, which are designated by the Boolean values [[true]] and
[[false]].
The subgraph represents decision logic \emph{only}; the sole job of
the subgraph is to decide on one of the two exits.\footnote
{Later in compilation, the peephole optimizer may combine computation
with decision.}

Unlike the unconditional or multiway branches, the [[cbranch]] can
have multiple internal nodes that reach one or both of the exits.
This happens any time the condition involves the short-circuit Boolean
operators [[%conjoin]] or [[%disjoin]].

Unlike the other subgraphs, the [[cbranch]] can represent a DAG, not
just a tree---hence the [[Shared]] node.
\end{itemize}
<<abstract types for postexpanders>>=
type uid
<<types for postexpanders>>=
type block   = Rtl   of rtl
             | Seq   of block * block
             | If    of cbranch * block * block
             | While of cbranch * block
             | Nop
and  branch  = block * rtl (* block ending in branch, including multiway branch *)
and  cbranch = Exit   of bool
             | Test   of block * cbinst
             | Shared of uid * cbranch  (* don't duplicate this node *)
and  cbinst  = exp * cbranch * cbranch
@ Note that since the only purpose of a conditional branch is to reach
one of the two exits, there is never any straight-line code that
intervenes between a conditional branch and the exit.
Also note that a conditional branch can be simplified to
unconditional; that's what a bare [[Exit]]  means.
@
We now explain what each of the above constructors and types means,
and under what conditions it is deemed to satisfy the machine invariant.
\begin{itemize}
\item [[Rtl]] wraps a \emph{non-branching} RTL.
It satisfies the machine invariant if the RTL  can be represented by a single
instruction on the target machine, with this exception:
\begin{itemize}
\item
\label{sec:optimism}
An RTL may be representible as a single instruction only under the
optimistic assumption that a late compile-time constant is ``small.''
If the assumption is violated, it must be possible for the recognizer
to emit a sequence of instructions that together implement the RTL.
Either this sequence can be generated without using an additional
register, or else the recognizer will have to reserve to itself a
register for this purpose.
\end{itemize}
@
\item
An [[rtl]] in a [[branch]] pair represents an unconditional
control-transfer instruction.
It satisfies the machine invariant if it can be represented by a
single instruction on the target 
machine, with these exceptions:
\begin{itemize}
\item
If the target machine has delayed control-transfer instructions
(branch\slash call\slash etc), we may use a single RTL to represent an atomic
two-instruction package consisting of the control transfer and the
instruction in the delay slot.
We do this because at present, we have no other way to constrain
layout.
@
\item
For implementing [[cut to]], we use a single RTL that represents two
instructions: one that adjusts the stack pointer and one that
branches.
We need to package these atomically because once the stack pointer has
been adjusted, the internal assumptions of the compiler are no longer
valid.
For example, it is not safe to spill a register after the stack
pointer has been adjusted.
We therefore treat the two instructions as an atomic unit by packaging
them as one RTL.
\end{itemize}
@
\item
A [[Seq]] node represents a sequence of instructions and executes
first the left half, then the right.
@
\item
A [[If]] node makes a decision and executes one of its two blocks,
depending on the outcome of the condition.
The decision is represented by a [[cbranch]] node.
@
\item
The [[While]] node corresponds to a C-style [[while]] statement:
as long as the decision is for the [[true]] exit, it executes the body.
@
\item
[[Nop]] represents an empty sequence of instructions.
[[Nop]] may be useful in [[If]], as the first part of a [[branch]],
and in various places in the 
generic expander.
@
\item
A [[branch]] represents a [[block]] that is followed by a branch
instruction, which is represented by an RTL that satisfies the machine
invariant for branch instructions as described above.
Typically the [[block]] is empty, or it computes the address used in
the branch.
@
\item
A [[cbranch]] represents the ability to make a decision:
\begin{itemize}
\item
An [[Exit]] node makes the decision for the exit identified by the
Boolean.
\item
A [[Test]] node makes the decision by executing a 
[[block]], then a
conditional-branch instruction.
Typically the [[block]] sets condition codes.
\item
A [[Shared]] node wraps another node with a unique identifier, which
keeps it from being duplicated when the [[cbranch]] tree is converted
to a flow graph.
A~[[Shared]] node can be created only by the [[shared]] function
exported by the [[Postexpander]] interface.
Typically, [[Shared]] nodes are created only by the generic expander,
when it compiles [[%conjoin]] and [[%disjoin]].
But if a postexpander should use a [[cbranch]] in two different
contexts, it should apply [[shared]] first.
\end{itemize}
@
\item
A [[cbinst]] represents a conditional-branch
instruction.
The [[exp]] must be a Boolean expression.
If [[cbinst = (exp, t, f)]], its semantics are that if [[exp]] is
true, execution continues with~[[t]]; otherwise it
continues with~[[f]].
To satisfy the machine invariant,
the [[cbinst]] must satisfy two properties:
\begin{itemize}
\item
If [[target.branch.embed]] is applied to the [[exp]] and a label, it
produces an RTL that can be represented as a single conditional-branch
instruction on the target machine.
\item
The resulting RTL can be changed with [[bnegate]] and still be
representable as a single instruction on the target machine.
@
\item
The [[Exit]] continuation represents control flow to one of the two
exits of the subgraph.
An [[Exit]] always satisfies the machine invariant.
@
\item
The [[Continue]] continuation represents additional control flow which
eventually leads to an exit.
It satisfies the machine invariant if its [[cbranch]] does.
\end{itemize} 
\end{itemize}
@
An example may help with the conditional branch.
If the source code contains
\begin{verbatim}
if (n == 1 `disjoin` n == 2) {
  ...
} else {
  ...
}
\end{verbatim}
The generic expander may translate the [[if]] expression to the
following conditional branch:
\begin{verbatim}
  Test (Nop, (n == 1, Exit true, Test (Nop, (n == 2, Exit true, Exit false))))
\end{verbatim}
On many machines this subgraph would be expanded further with the help
of the postexpander.
For example, each [[Nop]] might be replaced by a compare instruction,
and the equality tests might be replaced by tests of the condition codes.
@
\paragraph{Postexpander utility functions}

A postexpander may need to allocate a temporary or a slot in the stack
frame, or it may need to emit initialized data (e.g., for a
floating-point load). 
At present, only allocation of a temporary or a stack
slot is supported.
<<exported utility functions for postexpanders>>=
module Alloc : sig
  val temp : char -> width -> temp
  val slot : width -> Automaton.loc
end
@ 
The postexpander might also like to create a loop or conditional and
have the generic expander expand it further.
These functions achieve mutual recursion
between the generic expander and the postexpander;
it is up to the postexpander to be sure that this recursion
terminates. 
Only a postexpander may safely call these functions;
to call the functions while the generic expander is not active is an
\emph{unchecked} run-time error.
<<exported utility functions for postexpanders>>=
module Expand : sig
  val block   : block   -> block
  val branch  : branch  -> branch
  val cbranch : cbranch -> cbranch
end
@ 
Sequential composition of blocks is also useful for the generic expander.
It eliminates [[Nop]].
<<exported utility functions for postexpanders>>=
val (<:>) : block -> block -> block
@ 
The [[shared]] function makes a node shared, so that it will not be
duplicated on conversion to a flow graph.
The [[shared]] function guarantees uniqueness of the identifier, and
it avoids wrapping [[Shared]] in [[Shared]].
<<exported utility functions for postexpanders>>=
val shared : cbranch -> cbranch
@
To convert a condition for use in [[If]] or [[While]], use [[cond]]. 
<<exported utility functions for postexpanders>>=
val cond : exp -> cbranch  (* branch taken iff exp true *)
@
To help deal with expansion of DAGs containing [[Shared]] nodes, 
we provide support for a set of nodes.
<<exported utility functions for postexpanders>>=
type 'a nodeset
val empty : 'a nodeset
val lookup : uid -> 'a nodeset -> 'a   (* raises Not_found *)
val insert : uid -> 'a -> 'a nodeset -> 'a nodeset
@

\paragraph {The target-dependent postexpander}
\label{expander.sec:Postexpander.S}

Here is a signature for a postexpander for an integer/float/address
machine.
These are the operations every target must implement.
The [[byte_order]] is used to check that access to memory uses the
target's byte order.
<<signature of a postexpander>>=
module type S = sig
  val byte_order : Rtl.aggregation (* used to check access to memory *)

  module Address : sig
    type t
    val reg : temp -> t
  end

  <<generic expansion operations for register machines>>
  <<generic expansion operations for stack machines>>
end
@ A value of type [[Address.t]] is a target-dependent way of holding
an address.  At present, the only way to create an address is by using
a temporary, which is expected to hold the address.
A~typical implementation will let [[Address.t]] be [[Rtl.exp]] and
will define a [[reg]] function that simply fetches the address.
(WORTH PUTTING IN A [[Standard.Address]]?)
@ 
\subsubsection{Postexpander operations for register machines}
We provide basic load and store.
The [[assertion]] gives the alignment of the [[Address.t]], which
tells the postexpander 
whether it can use a normal load or may (on some targets) need special
unaligned load and store instructions (e.g., ``load unaligned left''
or ``load unaligned right'').
<<generic expansion operations for register machines>>=
val load  : dst:temp  -> addr:Address.t -> assertion -> block
val store : addr:Address.t -> src:temp -> assertion -> block
@
We also provide sign-extending and zero extending loads
as well as low-bit--extracting stores, all of which are used only
with integer registers.
This is the only place the back end is required to support
size-changing operators; other uses, such as compositions of widens
and narrows, should be compiled to suitable code (shifts or identity)
somewhere upstream.
In each case, the [[width]] is the width of the value loaded and
stored, and the [[assertion]] gives the alignment of the
[[Address.t]].
<<generic expansion operations for register machines>>=
val sxload  : dst:temp  -> addr:Address.t -> width -> assertion -> block
val zxload  : dst:temp  -> addr:Address.t -> width -> assertion -> block
val lostore : addr:Address.t  -> src:temp -> width -> assertion -> block
@ For example, an [[sxload]] with width of~16 on a 32-bit machine
might correspond to a ``load signed halfword'' instruction.
A~[[lostore]] with width of~8 might correspond to ``store byte.''
@
We need a move operation.
It has to handle not only moves within a single register space but
also moves from space to space (e.g., move a value from an integer register into a
floating-point register).
<<generic expansion operations for register machines>>=
val move : dst:temp -> src:temp -> block
@ 
Load immediate can take any constant except a Boolean.
<<generic expansion operations for register machines>>=
val li  : dst:temp -> Rtl.Private.const -> block
@ Usage note:
\begin{quote}\slshape
Depending on the capabilities of the target machine, there are three
common strategies for implementing load-immediate:
\begin{enumerate}
\item
The target machine can hold the entire constant in an immediate field
of an instruction (e.g., integer values on Pentium and other CISC
machines).
On this sort of machine, the postexpander can just issue a single
load-immediate instruction.
\item
The target machine can hold some constants in an immediate field, but
not a constant as large as the one being loaded.
On a machine like this, it typically requires a two-instruction
sequence to load an immediate constant.
Different machines use different sequences:
\begin{itemize}
\item
MIPS: ``load upper immediate; or immediate''
\item
SPARC: ``sethi; or immediate''
\item
PPC: some sort of load-upper instruction followed by ``add immediate''
\end{itemize}
Machines vary depending on where in word the split is made (e.g,
$16/16$ versus $22/10$) and whether the constant can simply be split
or whether something more complicated has to happen because low bits
are going to be sign-extended then added.
Ideally, we would have some generic support for such machines.
\end{enumerate}
\end{quote}
@
An extended load-immediate can take sums and differences of
compile-time constants (including late compile-time constants). 
The [[lix]] may make optimistic assumptions about the size of
constants, as noted above on page~\pageref{sec:optimism}.
<<generic expansion operations for register machines>>=
val lix : dst:temp -> Rtl.exp           -> block
@ 
We provide simple shortcuts for binary and unary operators.
I don't know if the shortcuts are worthwhile.
N.B.~no operator passed to any of these functions expects or returns a
Boolean! 
Ordinary value operators are expected to be supported by these
operations, but only at their natural widths.
Weird value operators such as carry, borrow, or multiply-extended are
supported by special-purpose functions described further below.
<<generic expansion operations for register machines>>=
val binop : dst:temp -> operator -> temp -> temp -> block
val unop  : dst:temp -> operator -> temp         -> block
val rtlop : dst:temp -> operator -> temp list    -> block
@ 
We support the width-doubling weird value operators with the
[[dblop]] function.
(Currently these are only the extended integer multiplies.
Perhaps one day we will understand the role of the extended
floating-point multiplies as well.)
<<generic expansion operations for register machines>>=
val dblop : dsthi:temp -> dstlo:temp -> operator -> temp -> temp -> block
@ 
A weird value operator that has a 1-bit or 2-bit argument, but a
normal result, is
supported by  [[wrdop]].
These operators include [[addc]] and [[subb]] (as well as a host of
floating-point operators that are not actually supported in this
interface at this time).
<<generic expansion operations for register machines>>=
val wrdop  : dst:temp  -> operator -> temp -> temp -> warg -> block
@ A~weird value operator that has a weird argument and also a weird
result is supported by [[wrdrop]].
These operators include only [[carry]] and [[borrow]].
<<generic expansion operations for register machines>>=
val wrdrop : dst:wtemp -> operator -> temp -> temp -> warg -> block
@
If it is not a constant, a~weird (narrow) value must be stored in an
ordinary temporary. 
The narrow value is in the low bits, and we record a fill type,
which may be either guaranteed (in argument position) or demanded (in
result position).
A~weird argument may also be a literal.
<<types for postexpanders>>=
type wtemp = fill * temp
and  fill  = HighS | HighZ | HighAny  
and  warg  = WBits of Bits.bits
           | WTemp of temp  (* the high bits could contain anything *)
@ 
Usage notes:
\begin{quote}
\slshape
The interface contains multiple functions to make life easy for those
writing postexpanders by hand.
If the target machine is sufficiently regular, the postexpander may
certainly use an implementation such as
\begin{verbatim}
let binop ~dst op x y = rtlop ~dst op [x; y]
\end{verbatim}

It is almost certainly true that not every operator is implemented on
every machine.
The ability to expand blocks recursively is intended to make it easy
to use algebraic equivalents.
Our library of equivalents lives in the [[Rewrite]] module.
\end{quote}
@
The generic expander guarantees that
the arguments to functions above satisfy the precondition that the
temporaries are in the spaces the postexpander expects.
The postexpander must announce these spaces through argument and result contexts.
A~context has two parts.
The first part provides the ability to allocate temporaries, perhaps
of more than one width.\footnote
{For example, the SPARC floating-point context should support both 32-
  and 64-bit floats.}
The second part provides a predicate that says when a temporary
satisfies that context. 
\nextchunklabel{expander.Postexpander.context}%
<<generic expansion operations for register machines>>=
type context = (Talloc.Multiple.t -> int -> Register.t) * (Register.t -> bool)
val icontext : context (* for ints *)
val fcontext : context (* for floats *)
val acontext : context (* for addresses *)
val constant_context : width    -> context
val arg_contexts     : operator -> context list
val result_context   : operator -> context
@ It probably would be a good idea if a context were extended to say
exactly what widths are supported by the target machine.
@
THE REAL STORY HAS GOT TO BECOME MORE COMPLICATED.
HERE ARE THE CONTEXTS WE FIND ON THE X86:
\begin{itemize}
\item
A TEMPORARY THAT CAN BE ALLOCATED BY THE REGISTER ALLOCATOR
\item
A LOCATION ON THE FLOATING-POINT STACK
\item
A LOCATION IN MEMORY WITH KNOWN SIZE AND ALIGNMENT
\item 
A FIXED HARDWARE REGISTER SUCH AS ROUNDING MODES
\end{itemize}
THE EXPANDER SHOULD BE UPDATED TO PROVIDE THIS FULL INFORMATION AS THE
ARGUMENT AND RESULT CONTEXT FOR EVERY OPERATOR.
THEN IT CAN BE THE JOB OF THE EXPANDER TO DO SUCH THINGS AS ALLOCATE
MEMORY SLOTS, ETC.

@ 
We have to know when a right-hand side is too big to try to cram into
a single temporary.
<<generic expansion operations for register machines>>=
val itempwidth : int  (* maximum width for one integer temporary *)
@
Every machine should be able to do a block copy.
<<generic expansion operations for register machines>>=
val block_copy :
  dst:Address.t -> assertion -> src:Address.t -> assertion -> width -> block
@ 
\paragraph{Control flow}
To recognize control flow, the expander must be able to identify the
program counter.
We could provide an abstract test of type [[Rtl.loc -> bool]],
but until we need the extra generality, we avoid it.
On the other hand, we \emph{do} need a different representation of the
program counter on the left and the right of an assignment, in order
to handle the SPARC \emph{PC}/\emph{nPC} duo.
<<generic expansion operations for register machines>>=
val pc_lhs : Rtl.loc                    (* program counter as assigned by branch *)
val pc_rhs : Rtl.loc                    (* program counter as captured by call *)
@ 
To create control flow, the postexpander must provide an RTL that
includes an assignment to [[pc_lhs]].
This RTL must be the last in the execution sequence (and therefore the
head of the list that is returned).
We can branch to a temporary drawn from [[acontext]] or to a constant. 
<<generic expansion operations for register machines>>=
val br : tgt:temp -> branch               (* branch register *)
val b  : tgt:Rtl.Private.const -> branch  (* branch *)
@ The implementation of [[b]] will normally assume, optimistically,
that the branch target is within range of a PC-relative branch
instruction. 
@
For a conditional branch,  the target must be a static label, but the
postexpander provides any Boolean condition 
applied to temporaries.
Furthermore, it must be the case that the final, actual branch
instruction can have its sense reversed with [[bnegate]], and the
result is still representable by a single instruction on the target
machine.
<<generic expansion operations for register machines>>=
val bc      : temp -> operator -> temp -> ifso:cbranch -> ifnot:cbranch -> cbranch
val bnegate : rtl -> rtl  (* swap the condition in a conditional branch *)
@ The [[rtl]] part of the [[cbranch]] from [[bc]] is the \emph{only}
instruction that may legitimately be passed to [[bnegate]].

Usage notes:
\begin{quote}
\slshape
For machines with condition codes, the implementation of [[bc]] will
almost certainly involve the invention of new RTL operators that set
and query the condition codes.
Such invention is not absolutely required, but it enables two major
simplifications:
First, the postexpander and recognizer are much easier to write by
hand.
Second, many fewer RTL nodes are allocated at compile time.

The typical game is to invent two classes of operators:
\begin{itemize}
\item
One class of operators \emph{sets} the condition codes.
On a clean, simple, regular machine, there might be only one way to
set condition codes, say by a compare instruction.
One might invent an RTL operator called [[vax_compare]], for example.
On a messy machine like the Pentium, there might be a half dozen
different ways to set condition codes. 
Each needs its own RTL operator.
\item
The other class of operators \emph{queries} the condition codes.
One might define operators such as [[vax_lt]] or [[vax_ovflw]].
\end{itemize}
Once the operators are invented, the expansion of [[bc]] uses one
instruction from each class.
For example, [[bc x lt y ifso ifnot]] might become
\begin{verbatim}
  P.Test (cc := x `vax_lt` y, (vax_lt cc, ifso, ifnot))
\end{verbatim}
\end{quote}
@ 
The postexpander must be able to call direct and indirect.
A~call instruction may include multiple effects, but the postexpander
is responsible only for the effect on the program counter.
The other effects, which originate from an undisclosed location in the
compiler, are simply passed in and composed in parallel with the
assignment to the~PC.
<<generic expansion operations for register machines>>=
val callr : tgt:temp              -> others:Rtl.Private.effect list -> branch
val call  : tgt:Rtl.Private.const -> others:Rtl.Private.effect list -> branch
@ There's no need for a [[return]], as on most machine a [[return]] is
just a branch instruction anyway.  On a machine like the Pentium, in
which a return changes both program counter and stack pointer, the
instruction will have to be protected by using [[don't_touch_me]].
@
The [[cut to]] is as created by the target-dependent code, except
right-hand sides have been expanded to temporaries.
We need a special function for [[cut to]] because this is the one
case, explained above, in which we produce a single RTL that normally
stands for a two-instruction sequence.
We do this because that sequence \emph{must not} be broken up.
<<generic expansion operations for register machines>>=
val cut_to : Rtl.Private.effect list -> branch
@
The postexpander may insist on having some instructions untouched.
This is possible only for an instruction with multiple effects and a
single guard.
It is useful for protecting target-specific, multi-effect instructions such as
returns. 
<<generic expansion operations for register machines>>=
val don't_touch_me : Rtl.Private.effect list -> bool
@
\subsubsection{Postexpander operations for stack machines}

Most postexpanders will not need this section and can simply placate
the gods by writing
\begin{verbatim}
  include Postexpander.Nostack(Address)
\end{verbatim}
to get implementations of the functions below.
But if you do have to deal with a machine without real registers (like
the x86 floating-point unit), read on.
@
For simplicity, we assume the target machine has at most one stack.
If we need more generality, we can add it later.
@
To begin, we have to know which operators use the stack.
If an operator uses the stack, we need to know whether to push its
left operand first or its right operand first, and we need to know how
much stack room it needs to execute successfully.
<<types for postexpanders>>=
type operator_class = Register | Stack of push * int
and  push = LeftFirst | RightFirst
@ 
For a particular machine, we need to know the class of each operator,
the depth of the stack, and the width of a value that can be pushed on
the stack.
<<generic expansion operations for stack machines>>=
val opclass : operator -> operator_class
val stack_depth : int
val stack_width : int
@ 
We also need to identify an operator that takes a value from the stack
and converts it for use in a temporary.  This sort of operator is
needed on machines in which the width of stack is different from the
width of a temporary (like the Pentium).
<<generic expansion operations for stack machines>>=
val converts_stack_to_temp : operator -> bool
@
We can push a value from memory or pop the stack into memory.
<<generic expansion operations for stack machines>>=
val push      : addr:Address.t -> assertion -> block
val store_pop : addr:Address.t -> assertion -> block
@ 
We also have versions of these operations that convert between data
formats while popping or pushing.
We have to give the width of the value in memory.
<<generic expansion operations for stack machines>>=
val push_cvt      : operator -> width -> addr:Address.t -> assertion -> block
val store_pop_cvt : operator -> width -> addr:Address.t -> assertion -> block
@ 
We can also imagine a whole bunch of stack operations:
[[stack_copy]], [[dup]], [[exch]], [[pop]], and more.
 Luckily we don't need any of them for code expansion.
@
We may have to push a constant.
This, too, may happen with conversion.
<<generic expansion operations for stack machines>>=
val pushk     :                      Rtl.Private.const -> block
val pushk_cvt : operator -> width -> Rtl.Private.const -> block
@
We may operate on the stack.
<<generic expansion operations for stack machines>>=
val stack_op : operator -> block
@
We may branch conditionally based on the result of a stack operation.
<<generic expansion operations for stack machines>>=
val bc_stack : operator -> ifso:cbranch -> ifnot:cbranch -> cbranch
@ 
To support a calling convention that passes arguments or results on
the stack, we have to support push and pop instructions.
But a calling-convention automaton knows nothing of push and pop---in
particular, an automaton expects to be able to fetch a value using
only an RTL expression, so it has no way to create the side effect on
the stack pointer.
We resolve this problem by introducing a \emph{proxy} for the location
on the top of the stack.
This proxy may be used before code expansion with the expectation that
the code expander will rewrite it away:
\begin{itemize}
\item
If the proxy appears in an rvalue context, the expander replaces it
with whatever is on top of the stack (which is popped off).
\item
If the proxy appears on the left of a store, the expander pushes the
right-hand side.
\item 
If the proxy is killed, the expander complains bitterly.
\end{itemize}
Because not every postexpander supports stack operations, we provide
[[is_stack_top_proxy]] so that it can always return [[false]].
<<generic expansion operations for stack machines>>=
val stack_top_proxy    : Rtl.loc
val is_stack_top_proxy : Rtl.Private.loc -> bool
@ 
\subsubsection{A placeholder for register-only machines}
A postexpander for a register-only machine can simply include a
[[Nostack]] module.
<<postexpander.mli>>=
module Nostack (Address : sig type t val reg : temp -> t end) : sig
 <<generic expansion operations for stack machines>>
end
@ 
\subsubsection{Relationship of postexpander and recognizer}

It is often said that the recognizer must accept anything emitted by
the postexpander.
The truth is more subtle:
If an RTL is emitted by the postexpander, that RTL must be accepted by
the recognizer \emph{after} register allocation and simplification.
\begin{itemize}
\item
The postexpander must collude with the register allocator such that
after an acceptable substitution of hardware registers for
temporaries, the recognizer will accept the resulting RTL.
IT SHOULD BE DOCUMENTED SOMEWHERE HOW TO COMMUNICATE TO THE REGISTER
ALLOCATOR WHAT CONSTITUTES AN ACCEPTABLE SUBSTITUTION.  WHERE IS THAT?
\item
The simplifier evaluates many expressions at compile time.
For example, the expression $\mathtt{sx}_{16-32}(\mathtt{0xffff})$
will be simplified to  $\mathtt{0xffffffff}$.
Even if the postexpander emits the former, the recognizer must be
prepared to accept the latter.
In fact, if what the machine instruction does is sign-extend a 16-bit
constant to 32~bits, the recognizer must accept \emph{exactly} those
32-bit constants that can be obtained by sign-extending 16-bit
constants.
(The postexpander, by contrast, can choose either representation.)
\item
The typical recognizer should be prepared to accept additional RTLs that are
not emitted by the postexpander but may be computed by peephole
optimization.
But unlike the previous two requirements, recognizing additional
instructions is optional.
This is because unlike the register allocator and simplifier, the
peephole optimizer is \emph{guarded} by a call to the recognizer.
\end{itemize}
@
\clearpage

\subsection{Implementation outline}

\subsubsection {Postexpander support}

\paragraph{Allocation}
The generic expander can temporarily install and uninstall allocators.
<<exported utility functions for use by the generic expander>>=
val remember_allocators : Talloc.Multiple.t -> Automaton.t -> unit
val forget_allocators   : unit -> unit
@ The following are checked run-time errors:
\begin{itemize}
\item
 To call [[remember_allocators]] twice
consecutively without an intervening call to [[forget_allocators]]
\end{itemize}
The following are \emph{unchecked} run-time errors:
\begin{itemize} 
\item
To call any function in [[Postexpander.S]] before any call to
[[remember_allocators]].
\item
To call any function in [[Postexpander.S]] if [[forget_allocators]]
has been called more recently than
[[remember_allocators]].
\end{itemize}
@
<<postexpander.ml>>=
module Alloc = struct
  let badslot : width -> Automaton.loc =
    fun _ -> Impossible.impossible "slot allocator misconfigured"
  let badtemp : char -> width -> temp =
    fun _ _ -> Impossible.impossible "temporary allocator misconfigured"
  let valid = Reinit.ref false
  let theslot = Reinit.ref badslot
  let thetemp = Reinit.ref badtemp
  let slot w = !theslot w
  let temp c w = !thetemp c w
end
let remember_allocators t s =
  if !Alloc.valid then
    Impossible.impossible "too many allocators";
  Alloc.valid := true;
  Alloc.thetemp := (fun c w -> Talloc.Multiple.reg c t w);
  Alloc.theslot := (fun w -> Automaton.allocate s w "")
let forget_allocators () = 
  if not !Alloc.valid then
    Impossible.impossible "too few allocators";
  Alloc.valid := false;
  Alloc.theslot := Alloc.badslot;
  Alloc.thetemp := Alloc.badtemp
@
\paragraph{Expansion}
The generic expander can expand, recursively, for the postexpander.
<<exported utility functions for use by the generic expander>>=
val remember_expanders : 
  (block -> block) -> (branch -> branch) -> (cbranch -> cbranch) -> unit
val forget_expanders : unit -> unit
@ The following are checked run-time errors:
\begin{itemize}
\item
 To call [[remember_expanders]] twice
consecutively without an intervening call to [[forget_expanders]]
\end{itemize}
The following are \emph{unchecked} run-time errors:
\begin{itemize} 
\item
To call any function in [[Postexpander.S]] before any call to
[[remember_expanders]].
\item
To call any function in [[Postexpander.S]] if [[forget_expanders]]
has been called more recently than
[[remember_expanders]].
\end{itemize}
@
<<postexpander.ml>>=
module Expand = struct
  let bad : block -> block =
    fun _ -> Impossible.impossible "block expander misconfigured"
  let badb : branch -> branch =
    fun _ -> Impossible.impossible "branch expander misconfigured"
  let badcb : cbranch -> cbranch =
    fun _ -> Impossible.impossible "conditional branch expander misconfigured"
  let valid   = Reinit.ref false
  let theblock   = Reinit.ref bad
  let thebranch  = Reinit.ref badb
  let thecbranch = Reinit.ref badcb
  let block   b = !theblock   b
  let branch  b = !thebranch  b
  let cbranch b = !thecbranch b
end
let remember_expanders b br cb =
  if !Expand.valid then
    Impossible.impossible "too many expanders";
  Expand.valid := true;
  Expand.theblock   := b;
  Expand.thebranch  := br;
  Expand.thecbranch := cb
let forget_expanders () = 
  if not !Expand.valid then
    Impossible.impossible "too few expanders";
  Expand.valid := false;
  Expand.theblock   := Expand.bad;
  Expand.thebranch  := Expand.badb;
  Expand.thecbranch := Expand.badcb
@ 
<<postexpander.ml>>=
let (<:>) b b' = match b, b' with
| Nop, b' -> b'
| b, Nop  -> b
| _, _    -> Seq (b, b')
@ 
<<postexpander.ml>>=
let shared =
  let n = Reinit.ref 0 in
  fun c -> match c with
  | Shared _ -> c
  | _ -> n := !n + 1; Shared (!n, c)
<<postexpander.ml>>=
let cond e = Test (Nop, (e, Exit true, Exit false))
<<postexpander.ml>>=
type 'a nodeset = (uid * 'a) list
let empty = []
let lookup = List.assoc
let insert i x l = (i, x) :: l
@ 
\subsubsection{Placeholders for machines without stacks}
<<postexpander.ml>>=
module Nostack (Address : sig type t val reg : temp -> t end) = struct
  let opclass _ = Register
  let stack_depth = 0
  let stack_width = 0
  let converts_stack_to_temp _ = false
  let push ~addr _              = Impossible.impossible "stack op on register machine"
  let store_pop ~addr _         = Impossible.impossible "stack op on register machine"
  let push_cvt _ _ ~addr _      = Impossible.impossible "stack op on register machine"
  let store_pop_cvt _ _ ~addr _ = Impossible.impossible "stack op on register machine"
  let pushk _                   = Impossible.impossible "stack op on register machine"
  let pushk_cvt _ _ _           = Impossible.impossible "stack op on register machine"
  let stack_op _                = Impossible.impossible "stack op on register machine"
  let bc_stack _ ~ifso ~ifnot   = Impossible.impossible "stack op on register machine"
  let stack_top_proxy = Rtl.reg (('\000', Rtl.Identity, Cell.of_size 0), 0, Rtl.C 0)
  let is_stack_top_proxy _ = false
end
@
\subsubsection{More stuff}
The [[Proc.t]] gives the expander a supply of temporaries.
<<expander.mli>>=
module type S = sig
  val cfg: 'a -> Ast2ir.proc -> bool
end 
module IntFloatAddr (Post : Postexpander.S) : S
@ 
Here are some abbreviations and utilities.
<<expander.ml>>=
module type S = sig
  val cfg: 'a -> Ast2ir.proc -> bool
end 

module A  = Automaton
module BO = Bits.Ops
module PX = Postexpander
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target

module Up = Rtl.Up
module Dn = Rtl.Dn

let upassn = Rtl.Up.assertion
let impossf fmt = Printf.kprintf Impossible.impossible fmt
@ 
\subsection{Utilities and debugging code}
<<expander.ml>>=
let fetch l = RP.Fetch (Dn.loc l, RU.Width.loc l)
let width e = RU.Width.exp (Up.exp e)
@ 
Sometimes, we may require that a node have an instruction.
<<expander.ml>>=
module G = Cfgx.M
let inst n =
  match G.to_instr n with
  | Some i -> i
  | None   -> impossf "Expanded node must have instruction"
@ 
We provide three kinds of composition: blocks with blocks, blocks
with branches, and blocks with conditional branches.
<<block-manipulation utilities>>=
let (<:>) = PX.(<:>) in
let (<::>) is (is', branch) = (is <:> is', branch) in
let rec (<:::>) is cbranch = match cbranch with
| PX.Exit b -> PX.Exit b
| PX.Test (b, c) -> PX.Test (is <:> b, c)
| PX.Shared (u, c) -> PX.Shared (u, is <:::> c) in
@ 
<<block-manipulation utilities>>=
let block_concat l = List.fold_right (<:>) l PX.Nop in
@
\subsubsection{Printing code for debugging}
Some debugging code is most helpful.
The expander writes debugging information as it goes;
to activate it, try \texttt{QCDEBUG=expander~qc--}.
<<expander.ml>>=
module D = struct (* debugging *)
  let () = Debug.register "expander" "code expander"
  let eprintf = Printf.eprintf 
  let sprintf = Printf.sprintf 
  let strings =
    if Debug.on "expander" then
      (fun ss -> eprintf "%s" (String.concat "" ss))
    else
      (fun ss -> ()) 
  let int n = string_of_int n
  let rtl r = Rtlutil.ToString.rtl r
  let temp ((s, _, ms), n, c) =
    sprintf "$%s[%d] : %d loc" (Char.escaped s) n (Cell.to_width ms c)
  let exp = Rtlutil.ToString.exp 
  let pr_rtls rs = List.iter (fun r -> strings ["  "; rtl r; "\n"]) (List.rev rs)
  <<more printing functions for the internal [[D]] module>>
  (* renaming *)
  let cbranch  = if Debug.on "expander" then cbranch       else fun _ -> "<cbranch>"
  let pr_block = if Debug.on "expander" then pr_block "  " else fun _ -> ()
  let exp e = Rtlutil.ToString.exp (Up.exp e)
end
@ 
Printing conditional branches:
<<more printing functions for the internal [[D]] module>>=
let rec cbi c = match c with
| e, PX.Exit true,  PX.Exit false -> exp e
| e, PX.Exit false, PX.Exit true  -> sprintf "!(%s)" (exp e)
| e, PX.Exit true,  p -> sprintf "(%s || %s)" (exp e) (cbranch p)
| e, p, PX.Exit false -> sprintf "(%s && %s)" (exp e) (cbranch p)
| e, p, q -> sprintf "(%s ? %s : %s)" (exp e) (cbranch p) (cbranch q)
and cbranch c = match c with
| PX.Exit p           -> if p then "true" else "false"
| PX.Shared (_, c)    -> sprintf "[%s]" (cbranch c)
| PX.Test (PX.Nop, c) -> cbi c
| PX.Test (b, c)      -> sprintf "{%s; %s}" (compact_block b) (cbi c)
and compact_block b =
  let rec pr = function
    | PX.Rtl r        -> sprintf "%s" (rtl r)
    | PX.Seq (b, b')  -> sprintf "%s; %s" (pr b) (pr b')
    | PX.If (c, t, f) -> sprintf "if (%s) { %s; } else { %s; }"
                           (cbranch c) (pr t) (pr f)
    | PX.While (c, b) -> sprintf "while (%s) { %s; }" (cbranch c) (pr b)
    | PX.Nop          -> "skip" in
  pr b
@ 
Printing blocks:
<<more printing functions for the internal [[D]] module>>=
let rec pr_block ind b =
  let exp = Rtlutil.ToString.exp in
  let rec pr = function
    | PX.Rtl r          -> eprintf "%s%s;\n" ind (rtl r)
    | PX.Seq (b, b')    -> pr b; pr b'
    | PX.If (PX.Exit p, t, f) -> pr (if p then t else f)
          (* true to semantics, but maybe not informative enough *)
    | PX.If (PX.Shared (_, c), t, f) -> pr (PX.If(c, t, f))
    | PX.If (PX.Test (PX.Nop, c), t, f) -> 
        let ind' = ind ^ "  " in
        eprintf "%sif (%s) {\n" ind (cbi c);
        pr_block ind' t;
        eprintf "%s} else {\n" ind;
        pr_block ind' f;
        eprintf "%s}\n" ind
    | PX.If (PX.Test (b, cbi), t, f) ->
        assert (Pervasives.(<>) b PX.Nop);
        pr (PX.Seq (b, PX.If (PX.Test(PX.Nop, cbi), t, f)))
    | PX.While (c, b) ->  (* not implemented really *)
        let ind' = ind ^ "  " in
        eprintf "%swhile (%s) {\n" ind (cbranch c);
        pr_block ind' b;
        eprintf "%s}\n" ind
    | PX.Nop -> eprintf "%s<nop>\n" ind in
  pr b
@ 
This little hack
enables statement-count profiling to work even when the expander loops infinitely.
It was useful in debugging the expander.
<<expander.ml>>=
let _ = Sys.set_signal Sys.sigterm (Sys.Signal_handle (fun _ -> exit 0))
@ 
% ----------------------------------------------------------------
\subsection{A generic expander}
% ----------------------------------------------------------------

This expander is intended for machines with integer, floating, and
address register spaces.
It will also work with integer/float machines, since we can make
address registers a synonym for integer registers.
<<expander.ml>>=
module IntFloatAddr (Post : Postexpander.S) = struct
  let pc_lhs = Dn.loc Post.pc_lhs
  let pc_rhs = Dn.loc Post.pc_rhs
  <<internal utilities for the generic expander>>
  <<generic expander>>
  <<generic flow-graph expander>>
end
@ 
Within the expander, we need to be able to turn a temporary into a
location. 
For this we need the postexpander.
It's questionable whether the byte order of a register should be fixed
to that of memory, but so be it.
When we refactor the compiler to support register locations directly,
this function should go away.
<<generic expander>>=
let temploc (space, n, w) = R.reg (space, n, w)
@ 
\subsection{Contexts in which to evaluate expressions}

The world is complicated by the existence of two kinds of machines:
stack machines and register machines.
For a stack machine, much of code expansion involves computing
subexpressions onto the stack.
For a register machine, much of code expansion involves computing
subexpressions into temporaries, which the register allocator will
later turn into registers.

For simplicity, we assume that a stack machine has exactly one stack.
But registser machines have lots of kinds of registers.
To choose the right kind for an expression, we need to know the
\emph{context}.
The context tells us what sort of temporary is appropriate
(typically integer, float, or address).
Sadly, there are two representations of contexts.
\begin{itemize}
\item
A \emph{dynamic} context provides two items: an infinite
supply of temporaries, and a predicate that says whether an existing
temporary can be used in the context.
The supply of temporaries must be shared with the rest of the
compiler, including the variable placer and
register allocator.
Because the supply of temporaries is new for each procedure, we can't
provide one at compile-compile time.
This is why the context is \emph{dynamic}.
\item
A \emph{static} context provides, instead of a supply of temporaries,
the name of the space from which the temporaries should be drawn.
(The static context also includes the checking predicate.)
We can therefore create a static context at compile-compile time, and
in fact we require the postexpander to supply three of them (see
chunk~\subpageref{expander.Postexpander.context}). 
\end{itemize}
We use the allocator in the [[Proc.t]] to convert from a static
context to a dynamic context; see function [[contextmap]] in
chunk~\subpageref{expander.contextmap}. 
@
Here we define the [[alloc]] and [[check]] functions, which use a
dynamic context.
(Actually [[check]] can use either kind.)
<<generic expander>>=
let alloc (allocate, check) w   = allocate w
let ok    (allocate, check) reg = check reg
@ 
Function [[temp_in_context]] takes an existing temporary and a
context, and returns a (possibly new) temporary that is OK for the
context (along with instructions that make it so). 
The temporary is \emph{preceded} by [[instructions]].
<<definition of [[temp_in_context]]>>=
let temp_in_context t context instructions =
  if ok context t then
    t, instructions
  else
    let t' = alloc context (Register.width t) in
    t', instructions <:> Post.move t' t in
@ 
Within the expander, we eagerly build some dynamic contexts:
[[icontext]], [[acontext]], and [[fcontext]].
We also keep function [[contextmap]] for those times when we get a
context that's not known at compile-compile time.
\nextchunklabel{expander.contextmap}%
<<generic expander>>=
let expand ({Proc.cfg = cfg} as proc) =
  <<stack-slot allocation>>
  <<block-manipulation utilities>>
  <<functions for dealing with trivial guards>>
  let contextmap (allocator, checker) = (allocator proc.Proc.temps, checker) in
  let icontext = contextmap Post.icontext in
  let acontext = contextmap Post.acontext in
  let fcontext = contextmap Post.fcontext in
  <<rounding-mode checking>>
  <<context guessing>>
  let alloc_direct (allocator, _) = allocator proc.Proc.temps in
  <<definition of [[temp_in_context]]>> 
  <<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>
  (block, branch', expand_cbranch)
let number = 999
@ 
To find the context for the operands of a comparison, I use the
dreadful hack that every floating-point 
comparison begins with [[f]] and no other comparison does.
This code probably should be replaced with a call to
[[Post.arg_contexts]].
<<context guessing>>=
let cmp_context (oprname, ws) =
  if oprname.[0] =<= 'f' then fcontext else icontext in
@
In other situations, we may have to guess a context based on a
right-hand side. 
<<context guessing>>=
let guess_context = function
  | RP.Const (RP.Bits b) -> contextmap (Post.constant_context (Bits.width b))
  | RP.Const k -> icontext
  | RP.Fetch(RP.Reg ((('f'|'u'), _, _), _, _),_) -> fcontext
  | RP.Fetch _ -> icontext
  | RP.App (op, args) -> contextmap (Post.result_context op) in
@ 
We may also have to guess whether to develop a right-hand side into a
temporary or on the stack.
<<context guessing>>=
let looks_like_stack_rhs = function
  | RP.App (op, _) ->
      begin
        match Post.opclass op with
        | PX.Stack (_, _) -> true
        | PX.Register -> false
      end
  | RP.Fetch (l, _) -> Post.is_stack_top_proxy l
  | _ -> false in
@ 
\subsection{Expanding an expression into a temporary}
The core of the expander is a function [[to_temp]], which takes an
expression and returns a pair containing a list of instructions and a
temporary such that executing those instructions develops the
expression into that temporary.

Unprimed versions of functions issue debugging screeds; primed
versions do the real work.
Here we define the primed and use the unprimed; the two are connected
with debugging code below.

Most cases identify what postexpander function should be used and
create suitable temporaries.%
\footnote{We have a small problem with register targeting; the problem
effects the size of the expanded code and therefore the compile-time
efficiency.
We wish to avoid generating superfluous move
instructions.
There are two possible contexts: if a right-hand side is already a temporary, we avoid
allocating a second temporary.
But if a left-hand side is already a temporary, we fail to ``target''
the right-hand side into that temporary.
It is not obvious to NR how to write an expander that achieves both.}
<<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>=
let rec to_temp' room context e =
  match e with
  <<cases for converting a compile-time constant to a temporary>>
  <<cases for converting a bare [[Fetch]] to a temporary>>
  <<cases for sign extending or zero extending a temporary>>
  <<cases for sign-extending and zero-extending loads>>
  <<cases for extending a narrow register (such as rounding mode)>>
  <<cases for narrow weird value operators>>
  <<cases for converting a Boolean to a value>>
  | RP.App ((_, [stackw; tempw]) as cvt, _) as e
    when Post.converts_stack_to_temp cvt ->
      let slot = exchange_slot tempw in
      let t, is = to_temp room context (fetch_slot slot tempw) in
      t, assign_slot room slot e tempw <:> is 
  | RP.App (("f2f_implicit_round", ws), [x]) ->
      to_temp room context (RP.App (("f2f", ws), [x; RP.Fetch(rounding_mode, 2)]))
  | RP.App (op, args) -> (<<action for expanding [[op(args)]] into a temporary>>)
<<other generic expander functions>> in
@ 
Details depend on whether the operator is a stack operator or a
register operator.
<<action for expanding [[op(args)]] into a temporary>>=
match Post.opclass op with
| PX.Stack(dir, depth) ->
    let w = Post.stack_width in
    let slot = exchange_slot w in
    let t, is = to_temp room context (fetch_slot slot w) in
    t, assign_slot room slot e w <:> is
| PX.Register ->
    let (temps, is) =
      try
        List.split (List.map2 (fun c e -> to_temp room (contextmap c) e)
                      (Post.arg_contexts op) args)
      with Invalid_argument (_) ->
        impossf "bad arity for operator %s (args %d vs context %d)"
          (fst op) (List.length args) (List.length (Post.arg_contexts op)) in
    let w = width e in
    let t = alloc_direct (Post.result_context op) w in
    let compute = match temps with
    | [x; y] -> Post.binop t op x y  (* see note on binary operators below *)
    | [x]    -> Post.unop  t op x
    | _      -> Post.rtlop t op temps in
    temp_in_context t context (block_concat (List.rev is) <:> compute)
@ The note on binary operators is that eventually the generic expander
might be extended so it can deal with a two-address target machine.
The generic expander might (somehow) divine whether the operation is 
in $L \mathrel{:=} L \oplus R$ form or in $R \mathrel{:=} L \oplus R$ form,
and it could call appropriate supporting functions in the target.
On the other hand, we could just rely on peephole optimization\ldots
@
<<cases for converting a compile-time constant to a temporary>>=
| RP.Const k ->
    let w = width e in
    let t = alloc context w in
    t, Post.li t k
| RP.App (_, _) when is_compile_time_constant e ->
    let w = width e in
    let t = alloc context w in
    t, Post.lix t (Up.exp e)
@
<<cases for converting a bare [[Fetch]] to a temporary>>=
| RP.Fetch (l, w) when Post.is_stack_top_proxy l ->
    let slot = exchange_slot w in
    let t, is = to_temp room context (fetch_slot slot w) in
    t, assign_slot room slot e w <:> is
| RP.Fetch (RP.Mem (('m', agg, ms), c, addr, assn), w) ->
    let t = alloc context w in
    let a, is = address room addr in
    assert (agg =*= Post.byte_order);
    assert (w = Cell.to_width ms c);
    t, is <:> Post.load t a (upassn assn)
| RP.Fetch (RP.Reg r, w) ->
    assert (w = Register.width r);
    temp_in_context r context PX.Nop
| RP.Fetch _ ->
    impossf "memory-like access to non-memory space"
@
Sign-extending and zero-extending loads are done into integer registers only.
This fact is documented in the postexpander interface.
<<cases for sign-extending and zero-extending loads>>=
| RP.App (("sx", [n;w]), [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n')]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    let t = alloc icontext w in
    let a, is = address room addr in
    assert (agg =*= Post.byte_order);
    temp_in_context t context (is <:> Post.sxload t a n (upassn assn))
| RP.App (("zx", [n;w]), [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n')]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    let t = alloc icontext w in
    let a, is = address room addr in
    assert (agg =*= Post.byte_order);
    temp_in_context t context (is <:> Post.zxload t a n (upassn assn))
@
<<cases for sign extending or zero extending a temporary>>=
| RP.App (("sx", [n; w]), [RP.App(("lobits", [w'; n']), [x])]) when w = w' ->
    if n <> n' then Impossible.impossible "ill-typed %sx(%lobits(...))";
    to_temp' room context (Dn.exp (Rewrite.sxlo n w (Up.exp x)))
| RP.App (("zx", [n; w]), [RP.App(("lobits", [w'; n']), [x])]) when w = w' ->
    if n <> n' then Impossible.impossible "ill-typed %zx(%lobits(...))";
    to_temp' room context (Dn.exp (Rewrite.zxlo n w (Up.exp x)))
@ 
To get a result of normal width, 
we can see a weird value operator in two contexts: a weird result is
extended or a normal result is used
<<cases for narrow weird value operators>>=
| RP.App ((("sx"|"zx") as xop, [n; w]),
          [RP.App((("carry"|"borrow"), [w']) as wrdop, args) as e]) ->
    if n <> 1 then Impossible.impossible "ill-typed %sx/%zx(...)";
    let signed = xop =$= "sx" in
    let x, y, z, is = compile_weird_args room wrdop args in
    let t = alloc_direct (Post.result_context wrdop) w in
    let fill = if signed then PX.HighS else PX.HighZ in
    t, is <:> Post.wrdrop ~dst:(fill,t) wrdop x y z 
<<cases for narrow weird value operators>>=
| RP.App ((("addc"|"subb"), [w]) as wrdop, args) ->
    let x, y, z, is = compile_weird_args room wrdop args in
    let t = alloc_direct (Post.result_context wrdop) w in
    t, is <:> Post.wrdop ~dst:t wrdop x y z 
<<other generic expander functions>>=
and compile_weird_args room op args = match args, Post.arg_contexts op with
| [x; y; z], [xc; yc; zc] ->
    let x, xis = to_temp room (contextmap xc) x in
    let y, yis = to_temp room (contextmap yc) y in
    let z, zis = to_warg room (contextmap zc) z in
    x, y, z, xis <:> yis <:> zis
| _ -> impossf "wrong number of args or contexts to %%%s" (fst op)
@ 
To compute a weird argument, we have either a literal or a temporary.
We might have to fetch a weird argument from a hardware register, but
that's not implemented (yet).
<<other generic expander functions>>=
and to_warg room context e = match e with
| RP.App (("lobits", [w; n]), [e]) ->
    let t, is = to_temp room context e in
    (PX.WTemp t), is
| RP.App ((("carry"|"borrow"), [w]) as wrdop, args) ->
    let x, y, z, is = compile_weird_args room wrdop args in
    let t = alloc_direct (Post.result_context wrdop) w in
    let t, is = 
      temp_in_context t context (is <:> Post.wrdrop (PX.HighAny, t) wrdop x y z) in
    (PX.WTemp t), is
| RP.Const (RP.Bits b) ->
    PX.WBits b, PX.Nop
| RP.Fetch _ -> Impossible.unimp "narrow argument straight from location"
| e -> impossf "trying to put %s into a weird temporary" (RU.ToString.exp (Up.exp e))
@ 
<<cases for extending a narrow register (such as rounding mode)>>=
@ 
Eventually, [[with_rounding_mode rm f]] should
\begin{enumerate}
\item
Save the current hardware rounding mode if necessary
\item
Set the hardware rounding mode to [[rm]] (if necessary)
\item 
Execute the code represented by applying [[f]] to the hardware
rounding mode
\item
Restore  the hardware rounding mode if necessary.
\end{enumerate}
\emph{And} it should be a utility function, because some hardware
might have rounding-mode information in the instruction word itself.
So instead, operators that take rounding modes have to become weird
value operators.
@ 
For the bit operator, we generate two branches of control flow, create an rtl for a
conditional branch, and pass everything over to [[expand_cbranch]].
<<cases for converting a Boolean to a value>>=
| RP.App ((("sx"|"zx") as op, [n; w]), [RP.App (("bit", []), [e])]) ->
    assert (n = 1);
    let t       = alloc context w in
    let nonzero = if op =$= "sx" then -1 else 1 in
    let tbranch = Post.li t (RP.Bits (Bits.S.of_int nonzero w)) in
    let fbranch = Post.li t (RP.Bits (Bits.zero w)) in
    let cond    = expand_cbranch (PX.cond (Up.exp e)) in
    t, PX.If (cond, tbranch, fbranch)
@
We might one day support multiple addressing modes, but for now, just registers. 
<<other generic expander functions>>=
and address room exp =
  let t, is = to_temp room acontext exp
  in  Post.Address.reg t, is
@
A compile-time constant is a sum or difference of compile-time constants.
<<other generic expander functions>>=
and is_compile_time_constant = function
  | RP.Const (RP.Bits _ | RP.Late (_, _)) -> true
  | RP.App   ((("add"|"sub"), [w]), es)   -> List.for_all is_compile_time_constant es
  | _ -> false
@ 

\subsection{Expanding using stack instructions}
<<other generic expander functions>>=
and to_stack' room e =
  if room < 1 then
    impossf "machine stack overflow in code generation";
  if Rtlutil.Width.exp' e <> Post.stack_width then
     (Printf.eprintf "failing expression: %s\n" (Rtlutil.ToString.exp
                                                  (Rtl.Up.exp e));
         Unsupported.stack_width ~have:(Rtlutil.Width.exp' e)
         ~want:Post.stack_width);
  Debug.eprintf "expander" "to_stack %s\n" (RU.ToString.exp (Up.exp e));
  match e with
  | RP.Const k -> Post.pushk k
  <<cases for getting a [[Fetch]] on the stack>>
  | RP.App (("f2f_implicit_round", ws), [x]) ->
      to_stack room (RP.App (("f2f", ws), [x; RP.Fetch(rounding_mode, 2)]))
  <<cases for converting pushes>>
  | RP.App (("i2f", [iw; fw] as i2f), [e; rm]) ->
      let slot = exchange_slot iw in
      assign_slot room slot e iw <:>
      to_stack room (RP.App (i2f, [fetch_slot slot iw; rm]))
  | RP.App (("f2f", [w; _] as f2f), [e; rm]) ->
      let slot = exchange_slot w in
      assign_slot room slot e w <:>
      to_stack room (RP.App (f2f, [fetch_slot slot w; rm]))
  | RP.App (op, args) -> (<<action for expanding [[op(args)]] onto the stack>>)
@ 
<<cases for getting a [[Fetch]] on the stack>>=
| RP.Fetch (l, _) when Post.is_stack_top_proxy l ->
    PX.Nop
| RP.Fetch (RP.Mem (('m', agg, ms), c, addr, assn), w) ->
    let a, is = address room addr in
    assert (agg =*= Post.byte_order);
    assert (w = Cell.to_width ms c);
    is <:> Post.push a (upassn assn)
| RP.Fetch (RP.Reg (space, i, c), w) ->
    let slot = exchange_slot w in
    assign_slot room slot e w <:> to_stack room (fetch_slot slot w)
| RP.Fetch _ ->
    impossf "memory-like access to non-memory space"
@ 
<<action for expanding [[op(args)]] onto the stack>>=
Debug.eprintf "expander" "to_stack generic case for %s\n" (D.exp e);
match Post.opclass op with
| PX.Stack(dir, depth) ->
    let args = List.filter is_not_rounding_mode args in (* cheat!!! *)
        (* ROUNDING *)
    let args = match dir with PX.LeftFirst -> args | PX.RightFirst -> List.rev args in
    let push_args room =
      let (is, _) = List.fold_left (fun (is,r) e -> (is <:> to_stack r e, r-1))
                    (PX.Nop,room) args in
      is in
    let compute room = push_args room <:> Post.stack_op op in
    (* ROUNDING *)
    if room >= depth then
      compute room
    else
      save_stack room <:> compute Post.stack_depth <:> restore_stack 1 room
| PX.Register ->
    let r, is = to_temp room (guess_context e) e in
    is <:> to_stack room (RP.Fetch (RP.Reg r, Register.width r))
@ 
<<rounding-mode checking>>=
let rounding_mode = Dn.loc proc.Proc.target.Target.rounding_mode in
let is_not_rounding_mode arg = match arg with
| RP.Fetch (l, 2) -> not (RU.Eq.loc l rounding_mode)
| _ -> true in
<<junk>>=
let insist_rounding_mode arg =
  if is_not_rounding_mode arg then
    Unsupported.soft_rounding_mode()
<<other generic expander functions>>=
and save_stack room =
  let number_to_push = Post.stack_depth - room in
  Impossible.unimp "saving an overflowing machine stack"
and restore_stack number_to_keep number_to_restore =
  Impossible.unimp "restoring an overflowing machine stack"
@ 
<<cases for converting pushes>>=
| RP.App ((("sx"|"zx"), [n; w]) as op,
          [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n')]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    assert (agg =*= Post.byte_order);
    let a, is = address room addr in
    is <:> Post.push_cvt op n a (upassn assn)
| RP.App ((("f2f"|"f2i"|"i2f"), [n; w]) as op,
          [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n'); rm]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    assert (agg =*= Post.byte_order);
    let a, is = address room addr in
    is <:> Post.push_cvt op n a (upassn assn)
    (*ROUNDING*)
@ 
\subsection{Expanding RTLs}

This part of the generic expander is currently simpler than it really
needs to be.
The main simplification is it doesn't deal with multiple effects.
In particular, it can't expand a call or a cut to node.
This flaw should be corrected soon.

In the longer term,
it would be good to do something more general with multiple assignments and with
guards. {For example, if a guard uses a non-comparison, Boolean
operator, it would be a fine thing to compile it to control flow.}
@
The expander is divided into three layers:
\begin{itemize}
\item
Function [[rtl]] expands a general RTL.
This function will need future work as noted above.
\item
Function [[guarded]] expands a single guarded effect.
Except for conditional branch, it currently handles only trivial
guards.
Because a nontrivial guard may appear only on a conditional branch,
this expander can't handle predicated instructions.
\item
Function [[assign]] expands an assignment with no guard.
\end{itemize}
@
Because there's no support for multiple assignment yet, the [[rtl']]
function is trivial.
Note that if the source code asks for a bare kill, even conditional,
we're within our rights to implement it as a nop.
Conditional branches should never be called by the [[rtl']] or
[[branch']] functions; we handle conditional branches in
the [[???]] function.
<<other generic expander functions>>=
and rtl' hr =
  let RP.Rtl gs = Dn.rtl hr in
  if trivially Post.don't_touch_me gs then
    PX.Rtl hr
  else
    match gs with
    | [(g, RP.Store (left, right, w))] -> guarded g left right w
    | [(g, RP.Kill _)] -> PX.Nop
    | [] -> PX.Nop (* a nop is a nop is a nop *)
    | ((_::_::_) as effs) -> (<<handle RTL with multiple effects [[effs]] (as RTL)>>)
and rtl_to_branch' hr =
  let RP.Rtl gs = Dn.rtl hr in
  if trivially Post.don't_touch_me gs then
    PX.Nop, hr
  else
    match gs with
    | [(RP.Const (RP.Bool true), RP.Store (left, right, w))] ->
        if RU.Eq.loc left pc_lhs then  (* unconditional branch *)
          match right with
          | RP.Const c -> Post.b c
          | _ ->          let r, is = to_temp Post.stack_depth acontext right in
                          is <::> Post.br r
        else
          impossf "branch does not assign to program counter"

    | [_] -> impossf "single branch effect is not unconditional store"
    | [] -> impossf "nop as branch"
    | ((_::_::_) as effs)-> (<<handle RTL with multiple effects [[effs]] (as branch)>>)
@ 
The type system tells us that anything in a guard must be a Boolean
operator or a comparison operator.\footnote
{Finally we get a payoff from NR's obsession with the distinction
between [[bool]] and \mbox{[[#1 bits]]}.}
<<other generic expander functions>>=
and guarded g left right w =
  match g with
  | RP.Const (RP.Bool b) -> if b then assign left right w else PX.Nop
  | RP.Const _ -> impossf "non-bool constant as guard"
  | RP.Fetch _ -> impossf "fetch as guard"
  | RP.App (cmp, [_; _]) ->
      Printf.eprintf "guarded: %s\n" (Rtlutil.ToString.exp (Up.exp g));
      Impossible.unimp "guard on other than conditional branch"
  | RP.App (cmp, _) ->
      Impossible.unimp "non-binary comparison in guard"
@ 
@ POSSIBLY  REFERENCES TO [[pc_lhs]] SHOULD BE REPLACED BY USING
[[Target.goto.project]] AND FRIENDS.  IN GENERAL, WE NEED TO SEE
ABOUT MERGING SIMILAR INFORMATION IN THE [[Target]] AND
[[Postexpander.S]] INTERFACES.
@
To compile a Boolean, we require that
a guarded effect with a nontrivial guard always be expanded into
a sequence that ends in a conditional branch.
To compile a comparison, we rely on the postexpander.
SOMEHOW WE HAVE TO FIGURE OUT WHAT TO DO WITH [[right]]!
<<other generic expander functions>>=
and expand_cbinst g ktrue kfalse =
  let room = Post.stack_depth in
  let rec expand g ktrue kfalse =
    match g with
    | RP.Const (RP.Bool b) -> if b then ktrue else kfalse
    | RP.Const _ -> impossf "non-bool constant as conditional guard"
    | RP.Fetch _ -> impossf "fetch as conditional guard"
    | RP.App (("not", []), [g]) -> expand g kfalse ktrue
    | RP.App (("conjoin", []), [x;y]) ->
        let kfalse = PX.shared kfalse in expand x (expand y ktrue kfalse) kfalse 
    | RP.App (("disjoin", []), [x;y]) ->
        let ktrue  = PX.shared ktrue  in expand x ktrue (expand y ktrue kfalse)
    | RP.App (cmp, ([x; y] as args)) ->
        begin
          match Post.opclass cmp with
          | PX.Register ->
              let context = cmp_context cmp in
              let xt, xis = to_temp room context x in
              let yt, yis = to_temp room context y in
              xis <:> yis <:::> Post.bc xt cmp yt ktrue kfalse
          | PX.Stack(dir, depth) ->
              let args = List.filter is_not_rounding_mode args in (* cheat!!! *)
                  (* ROUNDING *)
              let args =
                match dir with PX.LeftFirst -> args | PX.RightFirst -> List.rev args in
              let push_args room =
                let is, _ =
                  List.fold_left (fun (is,r) e -> (is <:> to_stack r e, r-1))
                  (PX.Nop,room) args in
                is in
              let compute room ktrue kfalse =
                push_args room <:::> Post.bc_stack cmp ~ifso:ktrue ~ifnot:kfalse in
              if room >= depth then
                compute room ktrue kfalse
              else
                (* PLAUSIBLE BUT COMPLETELY UNTESTED. *)
                let t = restore_stack 0 room <:::> ktrue  in
                let f = restore_stack 0 room <:::> kfalse in
                save_stack room <:::> compute Post.stack_depth t f
        end
    | RP.App (cmp, _) ->
       Printf.eprintf "rtl exp: %s\n" (Rtlutil.ToString.exp (Up.exp g));
        Impossible.unimp "non-binary comparison in conditional guard" in
  expand g ktrue kfalse
<<other generic expander functions>>=
and expand_cbranch' c = match c with
| PX.Exit _ -> c
| PX.Shared (u, c) -> PX.Shared(u, expand_cbranch' c)
| PX.Test (b, (g, ktrue, kfalse)) ->
    let b = block b in
    let rec extend c = match c with
    | PX.Exit p -> PX.Exit p
    | PX.Test (b', c) -> PX.Test (b <:> b', c)
    | PX.Shared (u, c) -> PX.Shared(u, extend c) in
    extend (expand_cbinst (Dn.exp g) ktrue kfalse)
@
An assignment is either a goto, a store, or a computation where we put
something in a temporary.
<<other generic expander functions>>=
and assign left right w = assign_room Post.stack_depth left right w
and assign_room room left right w = 
  match right with
  | RP.App (("f2f_implicit_round", ws), [x]) ->
      assign left (RP.App (("f2f", ws), [x; RP.Fetch(rounding_mode, 2)])) w
  | _ ->
      if RU.Eq.loc left pc_lhs then  (* unconditional branch *)
        impossf "assignment to pc is not a branch"
      else if Post.is_stack_top_proxy left then
        to_stack room right
      else
        match left with
        | RP.Mem (('m',agg,memsize) as mspace, c, addr, assn) ->  (* a store *)
            let w = Cell.to_width memsize c in
            assert (agg =*= Post.byte_order || agg =*= Rtl.Identity);
            <<definition of [[split_assignment]]>>
            let a, is' = address room addr in
            (match right with
            | <<\emph{pattern [[->]] action} for low-bit store>>
            | <<\emph{pattern [[->]] action} for splittable assignment>>
            | <<\emph{pattern [[->]] action} for doubling weird value operator>>
            | _ ->
                if looks_like_stack_rhs right then
                  (match right with
                  | <<\emph{pattern [[->]] action} for push-convert, then store-pop>>
                  | <<\emph{pattern [[->]] action} for converting store-pop>>
                  | _ -> 
                      let is = to_stack room right in
                      is <:> is' <:> Post.store_pop a (upassn assn))
                else
                  match right with
                  | RP.Fetch (RP.Mem(('m', _, _), ct, addr', assn'), w) ->
                      let a', is = address room addr' in
                      is <:> is' <:>
                      Post.block_copy a (upassn assn) a' (upassn assn') w
                  | _ ->
                      let r, is = to_temp room (guess_context right) right in
                      is <:> is' <:> Post.store a r (upassn assn))
        | RP.Mem (_, _, _, _) ->
            Impossible.unimp "memory space other than 'm'"
        | RP.Reg dst -> (* computation *)
            (match right with
            | RP.Fetch (RP.Reg src, _) -> Post.move ~dst ~src
            | _ -> let r, is = to_temp room (guess_context right) right in
                   is <:> Post.move ~dst ~src:r
            )
            (* ROUNDING --- narrow register *)
        | RP.Slice (_,_,_) -> Impossible.unimp "slice"
        | RP.Var (_,_,_) | RP.Global(_,_,_) ->
            impossf "variable passed to code expander"
<<\emph{pattern [[->]] action} for low-bit store>>=
RP.App (("lobits", [w; n]), [rhs]) ->
  let r, is = to_temp room icontext rhs in
  is <:> is' <:> Post.lostore a r n (upassn assn)
| RP.Const (RP.Bits b) when w < Post.itempwidth ->
  let rhs = RP.Const (RP.Bits (Bits.Ops.zx Post.itempwidth b)) in
  let r, is = to_temp room icontext rhs in
  is <:> is' <:> Post.lostore a r w (upassn assn)
<<\emph{pattern [[->]] action} for converting store-pop>>=
RP.App ((("sx" | "zx"), [wsrc; wdst]) as op, [rhs]) ->
  (* what goes wrong if wsrc is not the width of the stack? *)
  let is = to_stack room rhs in
  is <:> is' <:> Post.store_pop_cvt op wdst a (upassn assn)
| RP.App ((("f2f" | "f2i" | "i2f"), [wsrc; wdst]) as op, [rhs; roundingmode]) ->
  (* what goes wrong if wsrc is not the width of the stack? *)
  let is = to_stack room rhs in
  is <:> is' <:> Post.store_pop_cvt op wdst a (upassn assn)
<<\emph{pattern [[->]] action} for push-convert, then store-pop>>=
RP.App ((("f2f"|"f2i"|"i2f"), [n; w]) as op,
        [RP.Fetch (RP.Mem ((_,agg,ms), c, srcaddr, srcassn), n'); roundingmode]) ->
  assert (n = n' && n' = Cell.to_width ms c);
  assert (agg =*= Post.byte_order);
  let srca, is = address room srcaddr in
  is <:> Post.push_cvt op n srca (upassn srcassn) <:> Post.store_pop a (upassn assn)
@ 
A~splittable right-hand side looks like this: 
\begin{quote}
[[%or[64](%zx[32,64]($r0), %shl[64](%zx[32,64]($r2), 32))]]
\end{quote}
I FEAR I MAY BE BOTCHING THE ASSERTION IN THE STORE, ESPECIALLY WHERE
ALIGNMENT IS CONCERNED.
<<\emph{pattern [[->]] action} for splittable assignment>>=
( RP.App (("or", [ww]), [RP.App (("zx", [nn;ww']), [lsw]);
                          RP.App (("shl", [ww'']),
                                  [RP.App (("zx", [dd;ww''']), [msw]);
                                   RP.Const (RP.Bits nnb)])])
| RP.App (("or", [ww]), [RP.App (("shl", [ww'']),
                                  [RP.App (("zx", [dd;ww''']), [msw]);
                                   RP.Const (RP.Bits nnb)]);
                          RP.App (("zx", [nn;ww']), [lsw])])
) when w > Post.itempwidth && Pervasives.(<>) agg Rtl.Identity && ww = ww' && ww = ww''
    && ww = ww''' && dd = ww - nn && BO.eq nnb (Bits.U.of_int nn ww) ->
      split_assignment ~lsw ~lw:nn ~msw ~mw:dd
| RP.Const (RP.Bits b) when w > Post.itempwidth ->
  let lw = Post.itempwidth in
  let mw = w - lw in
  let lsw = RP.Const (RP.Bits (BO.lobits lw b)) in
  let msw = RP.Const (RP.Bits (BO.lobits mw (BO.shrl b (Bits.U.of_int lw w)))) in
  split_assignment ~lsw ~lw ~msw ~mw
<<\emph{pattern [[->]] action} for doubling weird value operator>>=
RP.App ((("mulx"|"mulux"), [nw]) as opr, [x; y]) when w = 2 * nw ->
  let xcon, ycon = match Post.arg_contexts opr with
  | [x; y] -> contextmap x, contextmap y
  | _ -> impossf "arity of extended multiply (arg contexts)" in
  let rcon = contextmap (Post.result_context opr) in
  let tx, i1 = to_temp room xcon x in
  let ty, i2 = to_temp room ycon y in
  let thi, tlo = alloc rcon nw, alloc rcon nw in
  let i3 = Post.dblop ~dsthi:thi ~dstlo:tlo opr tx ty in
  let v tmp = RP.Fetch (RP.Reg tmp, nw) in
  i1 <:> i2 <:> i3 <:> split_assignment ~lsw:(v tlo) ~lw:nw ~msw:(v thi) ~mw:nw
| RP.App ((("mulx"|"mulux"), _), _) as e ->
    impossf "unsupported extended multiply %s at width %d"
      (RU.ToUnreadableString.exp (Up.exp e)) w
@ 
We split an assignment into a least significant word [[lsw]] of
width~[[lw]] and a most significant word [[msw]] of width~[[mw]].
<<definition of [[split_assignment]]>>=
let split_assignment ~lsw ~lw ~msw ~mw =
  if Debug.on "expander" then
    Printf.eprintf "Splitting msw %s; lsw = %s\n" (D.exp msw) (D.exp lsw);
  let lc, mc = Cell.to_count memsize lw, Cell.to_count memsize mw in
  assert (Cell.divides memsize lw && w = lw + mw);
  let addr = Up.exp addr in
  let assn = Up.assertion assn in
  let lsw, msw = Up.exp lsw, Up.exp msw in
  let offset (R.C n) = RU.addk proc.Proc.target.T.pointersize addr n in
  match agg with
  | Rtl.LittleEndian ->
      rtl (R.par [R.store (R.mem assn mspace lc addr) lsw lw;
                  R.store (R.mem assn mspace mc (offset lc)) msw mw])
  | Rtl.BigEndian ->                           
      rtl (R.par [R.store (R.mem assn mspace mc addr) msw mw;
                  R.store (R.mem assn mspace lc (offset mc)) lsw lw])
  | Rtl.Identity ->
      impossf "bad aggregation in split assignment" in
@ 
<<other generic expander functions>>=
and fetch_slot slot w = Dn.exp (A.fetch slot w)
and assign_slot room slot right w =
  match Dn.rtl (A.store slot (Up.exp right) w) with
  | RP.Rtl [(RP.Const (RP.Bool true), RP.Store (left, right, w))] ->
      assign_room room left right w
  | _ -> impossf "stack slot is not a simple store"
@ 
Something with multiple effects is either a call, a [[cut to]], or a
shuffle.
In all three cases, the guard had better be trivial.
<<internal utilities for the generic expander>>=
let has_pc_on_left = function
  | RP.Store (pc, _, _) -> RU.Eq.loc pc pc_lhs
  | RP.Kill _ -> false 
let has_pc_on_right = function
  | RP.Store (_, e, _) -> RU.Exists.Loc.exp (RU.Eq.loc pc_rhs) e
  | RP.Kill _ -> false 
<<handle RTL with multiple effects [[effs]] (as branch)>>=
<<support for call and [[cut to]]>>
let effs = strip_trivial_guards effs in
if Post.don't_touch_me effs then
  PX.Nop, R.par (List.map Up.effect effs)
else
  if List.exists has_pc_on_left effs then
    if List.exists has_pc_on_right effs then
      make_call effs
    else
      make_cut_to effs
  else
    impossf "call or cut to without reference to PC"
<<handle RTL with multiple effects [[effs]] (as RTL)>>=
<<support for shuffle>>
let effs = strip_trivial_guards effs in
if Post.don't_touch_me effs then
  PX.Rtl (R.par (List.map Up.effect effs))
else
  let _ = if List.exists has_pc_on_left effs then
            impossf "straight-line code has PC on left" in
  make_shuffle effs
@ 
When we know guards should be trivial, we just strip them off.
When we don't know, we use the [[trivial]] function, which if guards
are trivial applies a predicate and if not returns [[false]].
\nwaddbox{trivially : (RP.effect list -> bool) -> RP.guarded list -> bool}
\deeperbox{16pt}
<<functions for dealing with trivial guards>>=
let strip_trivial_guards l =
  List.fold_right
    (fun (g, e) l ->
      match g with RP.Const (RP.Bool b) -> if b then e :: l else l
      | _ -> Impossible.unimp "multiple effects with a nontrivial guard") l [] in
let trivially p l =
  let rec t es' = function
    | [] -> p (List.rev es')
    | (g, e) :: ges ->
        match g with RP.Const (RP.Bool b) -> t (if b then e :: es' else es') ges
        | _ -> false in
  t [] l in
@ 
<<internal utilities for the generic expander>>=
let (<<) f g x = f (g x) 
<<support for call and [[cut to]]>>=
let make_call effs = 
  let others = List.filter (not << has_pc_on_left) effs in
  match List.filter has_pc_on_left effs with
  | [RP.Store(pc, RP.Const c, _)] -> Post.call c others
  | [RP.Store(pc, e, _)] ->
      let t, is = to_temp Post.stack_depth acontext e in
      is <::> Post.callr t others
  | _ -> impossf "multiple pc := e in call" in
@ 
<<support for call and [[cut to]]>>=
let make_cut_to effs =
  let expand e (preds, effs) = match e with
    | RP.Store (l, r, w) ->
        let t, is = to_temp Post.stack_depth (guess_context r) r in
        (preds <:> is, RP.Store(l, RP.Fetch(RP.Reg t, w), w) :: effs)
    | RP.Kill l -> (preds, RP.Kill l :: effs) in
  let preds, effs = List.fold_right expand effs (PX.Nop, []) in
  preds <::> Post.cut_to effs in
@ 
Shuffle would be cooler if we carefully arranged to make things
push-like, but never mind.
As it is, we look for an effect that can go first (because its
left-hand side doesn't alias with any other right-hand-side), and if
we don't find one, we introduce a new temporary.
<<support for shuffle>>=
let make_shuffle effs =
  let strip_store = function
    | RP.Store (l, r, w) -> (l, r, w)
    | RP.Kill _ -> impossf "kill in shuffle" in
  let rec shuffle =
    let assign = noisy_assign in
    function
    | [(l, r, w)] -> assign l r w
    | [] -> PX.Nop
    | ((l, (r:RP.exp), w) :: rest) as effs ->
        <<definition of [[try_first_effect]]>>
        try_first_effect effs
          (fun (l, r, w) rest -> assign l r w <:> shuffle rest)
          (fun () ->
            let t = alloc (guess_context r) w in
            (assign (RP.Reg t) r w <:>
             shuffle rest <:>
             assign l (RP.Fetch (RP.Reg t, w)) w))
  in shuffle (List.map strip_store effs) in
<<definition of [[try_first_effect]]>>=
let try_first_effect effects succ fail =
  let rec maybe bad = function
    | [] -> fail()
    | (l, r, w) :: rest ->
        let alias (_, r, _) = RU.MayAlias.exp' l r in
        if not (List.exists alias bad || List.exists alias rest) then
          succ (l, r, w) (List.rev_append bad rest)
        else
          maybe ((l, r, w) :: bad) rest in
  maybe [] effects in
@ 
\subsection{Flow-graph fragments}
<<other generic expander functions>>=
and block b = match b with
| PX.Rtl r        -> rtl r
| PX.Seq (b, b')  -> block b <:> block b'
| PX.If (c, t, f) -> PX.If (expand_cbranch c, block t, block f)
| PX.While (e, b) -> Impossible.unimp "expand loop"
| PX.Nop          -> PX.Nop
and branch' (b, r) = let b', r = rtl_to_branch r in (block b <:> b', r)
@ 

\subsection{Debugging the expander}
These wrapper functions show what the expander [[rtl]] and register
targeter [[to_temp]] are doing.
<<other generic expander functions>>=
and rtl r =
  let _ = D.strings ["Expanding "; D.rtl r; "\n"] in
  let is = rtl' r in
  let _ = D.strings ["Expanded "; D.rtl r; " into\n"]; D.pr_block is in
  is
and rtl_to_branch r =
  let _ = D.strings ["Expanding "; D.rtl r; "\n"] in
  let is, b = rtl_to_branch' r in
  let _ = D.strings ["Expanded "; D.rtl r; " into\n"]; D.pr_block (is <:> PX.Rtl b) in
  is, b
and expand_cbranch cb =
  let _ = D.strings ["Expanding conditional branch "; D.cbranch cb; "\n"] in
  let is = expand_cbranch' cb in
  let _ =
    D.strings ["Expanded conditional branch "; " into "; D.cbranch is; "\n"] in
  is
and noisy_assign l r w =
  let is = assign l r w in
  let r = R.store (Up.loc l) (Up.exp r) w in
  let _ = D.strings ["Shuffling "; D.rtl r; " into\n"]; D.pr_block is in
  is
and to_temp room context e =
  let _ = D.strings ["Targeting "; D.exp e; "...\n"] in
  let t, is = to_temp' room context e in
  let _ = D.strings ["Targeted "; D.exp e; " => "; D.temp t; " by \n"] in
  let _ = D.pr_block is in
  t, is
and to_stack room e =
  let _ = D.strings ["Pushing "; D.exp e; "...\n"] in
  let is = to_stack' room e in
  let _ = D.strings ["Pushed "; D.exp e; " by \n"] in
  let _ = D.pr_block is in
  is
@ 
\subsection{Stack-slot allocation}
To move from a temporary to the stack, we may need to allocate a stack slot.
<<stack-slot allocation>>=
let exchange_slot =
  let slots = ref [] in
  function w ->
    try List.assoc w (!slots)
    with Not_found ->
      let slot = A.allocate proc.Proc.priv w "" in
      slots := (w, slot) :: !slots;
      slot in
@   
\subsection{Old code no longer relevant}
This is old stuff left over, which I might want to resurrect some day
when I try to expand general guards.
<<ZZZ definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>=
let rec old_general_guard g left right w =
  (* this case is bogus *)
  let r, is  = to_temp Post.stack_depth (guess_context right) right in
  let l, is' = old_loc left in
  is <:> is' <:> PX.Rtl (R.guard (Up.exp g) (R.store l (R.fetch (temploc r) w) w))
and old_loc l =
  match l with
  | RP.Mem (('m',_,_) as mspace, w, addr, assn) ->
      let addr, is = to_temp Post.stack_depth (acontext) addr in
      Up.loc (RP.Mem (mspace, w, fetch (temploc addr), assn)), is
  | _ -> Up.loc l, PX.Nop in
@
\subsection{The flow-graph expander}

To expand the flow graph, we expand each node.
Expanding a node means converting its RTL to a block, a conditional
branch, or a branch; expanding the result; then
converting back to flow-graph nodes using  [[<<block-conversion functions>>]].

Before and after expansion we must tie and untie the knot that
establishes the mutual recursion between the generic expander and the
machine-specific postexpander.
<<generic flow-graph expander>>=
let cfg _ ({Proc.cfg = cfg} as proc) =
  let modified = ref false in
  <<block-conversion functions>>
  let expand_block, expand_branch, expand_cbranch = expand proc in
  let expand_node n =
    match G.to_instr n with
    | None -> ()
    | Some i ->
        let pred = G.pred n in
        let pred_set_succ n =
          if Pervasives.(<>) (G.kind pred) G.Illegal then G.set_succ pred n in
        let ill  = G.illegal cfg in
        match G.kind n with
        | G.Assertion | G.StackAdjust | G.Join | G.Exit -> ()
        | G.Instruction ->
            pred_set_succ ill;
            pred_set_succ (block_replace (expand_block (PX.Rtl i)) n)
        | G.Cbranch ->
          let bi   = (Up.exp (branch_condition i), PX.Exit true, PX.Exit false) in
          let b    = expand_cbranch (PX.Test (PX.Nop, bi)) in
          ( pred_set_succ ill
          ; G.delete    cfg n
          ; pred_set_succ (cbranch2cfg b (G.tsucc n) (G.fsucc n))
          )
        | _ ->
            pred_set_succ ill;
            let b, i = expand_branch (PX.Nop, i) in
            G.update_instr (fun _ -> i) n;
            pred_set_succ (block_before b n) in

  Postexpander.remember_allocators proc.Proc.temps proc.Proc.priv;
  Postexpander.remember_expanders expand_block expand_branch expand_cbranch;
  G.iter_nodes expand_node proc.Proc.cfg;
  Postexpander.forget_allocators();
  Postexpander.forget_expanders();
  !modified
<<internal utilities for the generic expander>>=
let branch_condition rtl = match Dn.rtl rtl with
| RP.Rtl [(g, RP.Store (left, right, w))] ->
    if not (RU.Eq.loc left pc_lhs) then
      impossf "conditional branch assigns to non-PC";
    g
| _ -> impossf "ill-formed conditional branch"
@
Free reference [[modified]] is set only if a new node is added to the graph.
IT MAY BE NECESSARY TO REASSOCIATE TO AVOID REPLACING INSTRUCTION $i$
WITH $i; \mathtt{Nop}$. 
<<block-conversion functions>>=
let rec branch2cfg (block, branch) bnode =
  G.update_instr (fun _ -> branch) bnode;
  block_before block bnode 
and block_before block succ =
  let rec before b = match b with
  | PX.Seq (PX.Nop, b) -> before b
  | PX.Seq (b, PX.Nop) -> before b
  | PX.Rtl i -> modified := true; G.instruction cfg i ~succ
  | PX.Seq (b, b') -> block_before b (before b')
  | PX.If (c, t, f) ->
      let t = block_before t succ in
      let f = block_before f succ in
      cbranch2cfg c ~t ~f
  | PX.While _ -> Impossible.unimp "PX.While"
  | PX.Nop -> succ in
  before block 
and block_replace block n =
  let rec repl b = match b with
  | PX.Seq (PX.Nop, b) -> repl b
  | PX.Seq (b, PX.Nop) -> repl b
  | PX.Rtl i -> G.update_instr (fun _ -> i) n; n
  | PX.Seq (b, b') -> block_before b (repl b')
  | PX.If _ | PX.While _ -> block_before b (block_replace PX.Nop n)
  | PX.Nop -> G.update_instr (fun _ -> R.par []) n; n in
  repl block 
@ 
N.B. the sharing works only for a DAG---the graph must be acyclic.
(Guaranteed by the rep.)
<<block-conversion functions>>=
and cbranch2cfg c ~t ~f =
  let nodemap = ref PX.empty in
  let rec cbi (e, tk, fk)  =
    let tn = cbranch tk in
    let fn = cbranch fk in
    G.cbranch cfg e ~ifso:tn ~ifnot:fn
  and cbranch c = match c with
  | PX.Exit p        -> (if p then t else f)
  | PX.Test   (b, i) -> let c = cbi i in block_before b c
  | PX.Shared (u, c) -> shared u c
  and shared u c =
    try PX.lookup u (!nodemap) with
    | Not_found ->
        let n = cbranch c in
        nodemap := PX.insert u n (!nodemap);
        n in
  modified := true;
  cbranch c in

(* got to keep this around somehow *)
  let rewrite_bc bc ktrue kfalse =
    let new_cb = G.cbranch cfg (R.bool true) ktrue kfalse in
    ( G.update_instr (fun _ -> inst bc) new_cb
    ; G.set_tsucc new_cb ktrue
    ; G.set_fsucc new_cb kfalse
    ; if Pervasives.(<>) (G.kind (G.pred bc)) G.Illegal then
        G.set_succ (G.pred bc) new_cb
    ; new_cb
    ) in

@ 

\subsection{Compilation of Boolean expressions into control flow.}

THIS CODE SHOULD BE MOVED TO THE GENERIC CODE EXPANDER.

An if-statement is governed by a boolean expression that has no side
effects. A simple translation is to use this expression as a guard for a
conditional branch to implement the if-statement. The guard finally
becomes a guard in the {\rtl} that implements the conditional branch.
The problem is, that the guarding expression can be quite complex and
must be simplified before a machine instruction can be found that
implements it. We translate a boolean expression $e$ into a sequence of
nodes. If $e$ evaluates to true, the control flow reaches the end of the
sequence, otherwise it branches to a provided label. 


\begingroup % keeps definitions local
\def\C#1{{\cal C}[\![#1]\!]}
\let\i\textit

The translation is summarized by the following function $\C{\cdot}~f$
that takes a boolean expression $e$ and a continuation $f$ to branch if
the expression evaluates to false. The result is a sequence of nodes,
that branches to $f$ if $e$ is false, and falls through otherwise.

\begin{center}
\begin{eqnarray*}
    \C{\i{true}}~f              & \to & \i{nop}\\
    \C{\i{false}}~f             & \to & \i{goto}~f\\
    \C{x \vee y}~f              & \to & \C x~l; l: \C y~f\\
    \C{x \wedge y}~f            & \to & \C x~f; \C y~f\\
    \C{\lnot x}~f               & \to & \C x~l; \i{goto}~f; l:\\
    \C{\oplus(e_1, \dots, e_n)} & \to & 
        \i{if}(\lnot \oplus(e_1, \dots, e_n)\{\i{goto}~f\}
\end{eqnarray*}
\end{center}

The last line covers the case of an application with a boolean result
but non-boolean arguments. Currently only the logical operators $\lnot$,
$\vee$, and $\wedge$ \emph{take} boolean arguments.

The implementation first translates the governing expression into an
{\rtl} and then tranlate it into the sequence of nodes.

\begin{quote}\it
    I think the code below shows a design weakness: we have decided to
    have explicit label nodes in the {\cfg}. In order to jump or branch
    to a node one needs the symbol associated with the label. This,
    however, cannot be observed. This means, labels can only be used
    where they are constructed. In the implementation of the {\cfg}
    labels could be made a sub-class of nodes. However, since we shield
    the object-oriented nature of nodes behind standard types, this is
    not easily possible. Nodes must be more abstract or labels must
    become special.  --CL
\end{quote}

\endgroup

<<old Make statements>>=
and guard state succ fail e = 
    let rec guard' succ fail = function

    | RP.Const(RP.Bool(true))         -> succ
    | RP.Const(RP.Bool(false))        -> fail
    | RP.Const(_)                     -> assert false
    | RP.Fetch(_)                     -> assert false
    <<special cases that match floating-point comparisons>>
    | RP.App(("conjoin",_), [x;y])    -> 
        let ll    = Idgen.label state.proc    in
        let ls    = F.symbol env ll     in
        let fail  = G.gm_label state.cfg ll ls fail in
            let tail = guard' succ fail y in
            let head = guard' tail fail x in
                head
    | RP.App(("not",_), [x])          -> guard' fail succ x
    | RP.App(("disjoin",_), [x;y])    ->
        let ll    = Idgen.label state.proc    in
        let ls    = F.symbol env ll     in
        let succ  = G.gm_label state.cfg ll ls succ in
        let y     = guard' succ fail y    in
        let lexp  = Rtl.codesym ls state.target.T.pointersize in
        let lrtl  = state.target.T.goto.T.embed lexp in
        let succ  = G.gm_goto state.cfg lrtl [G.lookup state.cfg ll] in
                guard' succ y x              
    | RP.App(opr, args) as e -> 
        let sl    = Idgen.label state.proc    in
        let ss    = F.symbol env sl     in
        let succ  = G.gm_label state.cfg sl ss succ in
        
        let fl    = Idgen.label state.proc    in
        let fs    = F.symbol env fl     in
        let fail  = G.gm_label state.cfg fl fs fail in
        
        let oexp  = Rtl.codesym fs state.target.T.pointersize in
        let ortl  = state.target.T.goto.T.embed oexp in
        let fail  = G.gm_goto state.cfg ortl [G.lookup state.cfg fl] in
        
        let e     = R.Revert.exp e in
        let link  = Rtl.codesym ss state.target.T.pointersize in
        let rtl   = state.target.T.branch.T.embed (e,link)  in
            G.gm_branch state.cfg rtl succ fail 
    in
        { state with node = guard' succ fail e }
        
@
<<special cases that match floating-point comparisons>>=
(* the evil empire *)
@
