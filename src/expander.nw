% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
\section{Toy code expander}

The goal here is to create a toy code expander so that we can test
register allocation and some other kinds of analyses and
transformations.  To explain what is happening, I use the following
conventions:

\begin{tabular}{@{\quad}ll}
$t$& any temporary or register-like space\\
$m$& any memory-like space\\
$k$& any constant\\
$\oplus$& any RTL operator\\
\end{tabular}

Our goal is to reduce RTLs to the following forms:

{\def\gets{\mathrel{:=}}%
$$\begin{array}{rcl}
m[t_l] & \gets & t\\
t      & \gets & m[t_l]\\
t_1    & \gets & t_2\\
t      & \gets & k\\
t      & \gets & \oplus(t_1, \ldots, t_n)
\end{array}
$$}

This is not quite what a real code expander does, but it should
suffice for experiments.
The context has three parts, all of which require knowledge of the
target machine:
\begin{itemize}
\item
Look at a location and say whether it is memory-like.
It is a checked run-time error to ask if a variable is memory-like
(this is not a property of the target but is the result of decisions
made higher up).
\item
Given a temporary space and a width, return a fresh temporary from
that space, suitably aggregated to the given width.
It is an \emph{unchecked} run-time error to ask for an unsupported
width.
\item
Given an expression, return a temporary space that would be suited to
hold the result of the expression.
\end{itemize}

<<expander.mli>>=
type context 
  = (Rtl.Private.loc -> bool)           (* say if a location is memory-like *)
  * (Rtl.Private.exp -> Rtl.space)      (* find a temp space to hold this exp *)
val context : Target2.t -> context
val expand : Talloc.Multiple.t -> context -> Rtl.rtl -> Rtl.rtl list
  (* returns *last* instruction at *head* of list (reverse execution order) *)
val cfg : 'a -> Proc.t -> bool
@ 
Here are some abbreviations and utilities.
<<expander.ml>>=
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target2

let up   = Rtl.Revert.exp
let down = Rtl.Convert.exp
let uploc= Rtl.Revert.loc
let downloc= Rtl.Convert.loc

let fetch l = RP.Fetch (downloc l, RU.Width.loc l)

let width e = RU.Width.exp (up e)
@ 
To avoid quadratric list append, I use John Hughes's
continuation-passing list operations.
<<expander.ml>>=
let empty = fun l -> l
let unit x = fun l -> x :: l
let (@::) x f = fun l -> x :: f l
let (@@) f1 f2 = fun l -> f1 (f2 l)
let rec concat = function
  | [] -> empty
  | [x] -> x  (* premature optimization is the root of all evil *)
  | [x; y] -> x @@ y  (* premature optimization is the root of all evil *)
  | [x; y; z] -> x @@ y @@ z (* premature optimization is the root of all evil *)
  | h::t -> h @@ concat t
@ 
The core of the expander is a function [[to_temp]], which takes an
expression and returns a pair containing a list of instructions and a
temporary such that executing those instructions develops the
expression into that temporary.
<<expander.ml>>=
type context 
  = (Rtl.Private.loc -> bool)           (* say if a location is memory-like *)
  * (Rtl.Private.exp -> Rtl.space)      (* find a temp space to hold this exp *)

let expand temps (mem_like, space_for) =
  let temp_for = Talloc.Multiple.loc temps in
  let rec to_temp e = match e with
    | RP.Const k ->
        let w = width e in
        let t = temp_for (space_for e) w in
        (t:R.loc), unit (R.store t (up e) w)
    | RP.Fetch (l, w) ->
        if mem_like l then
          let t = temp_for (space_for e) w in
          let l, is = loc l in
          (t:R.loc), (R.store t (R.fetch l w) w @:: is)
        else
          uploc l, empty
    | RP.App (op, args) ->
        let (temps, is) = List.split (List.map to_temp args) in
        let w = width e in
        let t = temp_for (space_for e) w in
        t, (R.store t (up (RP.App (op, List.map fetch temps))) w @:: concat is)
  <<other expander functions>>
  and rtl r = match Rtl.Convert.rtl r with
  | RP.Rtl [(g, RP.Store (left, right, w))] ->
      assign g left right w
  | _ -> unit r (* no expansion takes place *)
  in fun r -> rtl r []
@ 

It would be good to do something with multiple assignments and with
guards, but for now I keep things very simple.

The remaining functions are simple.
<<other expander functions>>=
and assign g left right w =
  let r, is  = to_temp right in
  let l, is' = loc left in
  R.guard (up g) (R.store l (R.fetch r w) w) @:: is @@ is'

and loc l =
  if mem_like l then
    match l with
    | RP.Cell (space, agg, w, addr, prop) ->
        let addr, is = to_temp addr in
        uploc (RP.Cell (space, agg, w, fetch addr, prop)), is
    | _ -> assert false (* any mem-like location must be a cell *)
  else
    uploc l, empty
@

% ------------------------------------------------------------------ 
\subsection{Test Code}
% ------------------------------------------------------------------ 

This is some code I wrote to play with the expander in an interactive
interpreter.

<<rename this to compile it into expander.ml>>=
module Test = struct
    <<Test>>
end    

<<Test>>=
let truth      = RP.Const(RP.Bool true)
let const n    = RP.Const(RP.Bits(Bits.of_int n 32))
let loc n      = RP.Cell('m', R.Identity, 32, const n, 1)
let add x y    = RP.App(("add",[32]),[x; y])
let assign l r = RP.Store(l,r,32)

let mem_like = function
    | RP.Cell('m',_,_,_,_) -> true
    | _                    -> false

let count = ref 0
let tmp_for sp width =
    let () = count := !count + 1 in
    let l  = RP.Cell(sp, R.Identity, width, const !count, 1) in
        Rtl.Revert.loc l

let rtl        = let left  = loc 0 in
                 let right = add (const 2) (add (const 3) (const 4)) in
                    RP.Rtl([truth,assign left right])
@

The [[rtl]] above is translated into the following sequence (in reverse
execution order):

\begin{quote}
\begin{verbatim}
$m[$t[30::bits32]] = $t[29::bits32];
$t[29::bits32]     = %add($t[25::bits32], $t[28::bits32]);
$t[25::bits32]     = 2::bits32;
$t[28::bits32]     = %add($t[26::bits32], $t[27::bits32]);
$t[26::bits32]     = 3::bits32;
$t[27::bits32]     = 4::bits32;
$t[30::bits32]     = 0::bits32;
\end{verbatim}
\end{quote}

@
Contexts.  This is jury-rigged, since in real life the expander knows
all about the machine and doesn't need a context.
<<expander.ml>>=
let context t =
  let rec space_of = function
    | RP.Cell (s, _, _, _, _) -> s
    | RP.Var (_, _, _) -> assert false
    | RP.Slice (_, _, l) -> space_of l in
  let mem_like =
    List.fold_right
      (fun s rest ->
         if s.S.classification = S.Mem then
           fun c -> c = s.S.space || rest c
         else
           rest)
      t.T.spaces (fun _ -> false) in

  let is_temp s = match s.S.classification with
  | S.Temp _    -> true
  |        _    -> false  in
  let first_temp w =
    try (List.find (fun s -> is_temp s && s.S.cellwidth = w) t.T.spaces).S.space
      with Not_found ->
        prerr_string ("No temporary spaces in target " ^ t.T.name ^ "\n");
        flush stderr;
        assert false in
  let float_regexp = Str.regexp ".*[Ff]loat.*" in
  let is_float_space s = Str.string_match float_regexp s.S.doc 0 in
  let is_float_temp s = is_temp s && is_float_space s  in
  let float_temp w = 
    try (List.find is_float_temp t.T.spaces).S.space
      with Not_found -> first_temp w in

  let float_like =
    List.fold_right
      (fun s rest ->
         if s.S.classification <> S.Mem && is_float_space s then
           fun c -> c = s.S.space || rest c
         else
           rest)
      t.T.spaces (fun _ -> false) in

  let float_ops = ["fcmp"; "fadd"; "fsub"; "fdiv"; "fmul"; "fabs"; "fneg"; "fsqrt"] in
  let is_float_op op = List.exists ((=) op) float_ops in

  let is_float_exp = function
    | RP.Const _ -> false
    | RP.Fetch (loc, _) -> float_like (space_of loc)
    | RP.App ((op, _), args) -> is_float_op op  in

  ( (fun loc -> mem_like (space_of loc))
  , (fun e -> if is_float_exp e then 
                float_temp (Rtlutil.Width.exp (Rtl.Revert.exp e))
             else 
                first_temp (Rtlutil.Width.exp (Rtl.Revert.exp e)))
  )              
@ 
<<expander.ml>>=
module G  = Cfg4
module GU = Cfgutil
let cfg _ proc =
  let g = proc.Proc.cfg in
  let t = proc.Proc.target in
  let _ = G.gm_enumerate g in
  let nodes = GU.fold_bwd g (fun x y -> x::y) [] in
  let expand = expand proc.Proc.temps (context t) in
  let modified = ref false in
  let exp n =
    match expand (G.instr n) with
    | last :: preds ->
        ignore (List.fold_left (fun n i -> G.gm_insert_assign_before i n) n preds);
        G.upd_instr n (fun _ -> last);
        (match preds with [] -> () | _ :: _ -> modified := true)
    | [] -> assert false in
  List.iter exp nodes;
  !modified
