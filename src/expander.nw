% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
\section{Toy code expander}

The goal here is to create a toy code expander so that we can test
register allocation and some other kinds of analyses and
transformations.  To explain what is happening, I use the following
conventions:

\begin{tabular}{@{\quad}ll}
$t$& any temporary or register-like space\\
$m$& any memory-like space\\
$k$& any constant\\
$\oplus$& any RTL operator\\
\end{tabular}

Our goal is to reduce RTLs to the following forms:

{\def\gets{\mathrel{:=}}%
$$\begin{array}{rcl@{\mskip10mu}l}
m[t_l] & \gets & t     &\mbox{store}\\
t      & \gets & m[t_l]&\mbox{load} \\
t_1    & \gets & t_2   &\mbox{move} \\
t      & \gets & k     &\mbox{constant}\\
t      & \gets & \oplus(t_1, \ldots, t_n) & \mbox{ALU}\\
\multicolumn4{@{}l@{}}{\mbox{\parbox{\linewidth}{\noindent
  And it should be extended to include the following variations:}}}\\
m[t_l] & \gets & \mathtt{lobits}_n(t)     &\mbox{store byte/halfword}\\
t      & \gets & \mathtt{sx} m[t_l]       &\mbox{load signed b/h} \\
t      & \gets & \mathtt{zx} m[t_l]       &\mbox{load unsigned b/h} \\
\end{array}
$$}
@
I'm contemplating how we might create a hand-written expander that can
easily be specialized to establish ``most of'' the machine invariant
for many different targets, without relying so heavily on peephole
optimization \emph{post facto}.
For example, it's legitimate to think of $\mathtt{\$m}[\cdot]$ as an
``address context.''
Any machine should be able to deal with $t$~in an address context, but
many machines will also be able to deal with $t+t$ and $t+k$ (though
on some machines $k$~may not be too large).
Some machines can even deal with $t+4\times t$!
One possibility, then, would be to make an ``address context''
function dynamic through Lua.
Care would have to be taken to avoid paying for an expensive identity
function (embedding/projection) at every application of such a function.
@
Here is a tentative signature for a postpass for an integer/float
machine.
<<postexpander.mli>>=
<<postexpander>>
<<postexpander.ml>>=
<<postexpander>>
<<postexpander>>=
module type S = sig
  val byte_order : Rtl.aggregation (* used on all access to memory *)
  val wordsize   : int             (* used as width of register number! *)

  type temp = Register.t
  type rtl = Rtl.rtl
  type width = Rtl.width
  type assertion = Rtl.assertion
  type operator = Rtl.Private.opr

  <<generic expansion operations>>
end
@ 
We provide basic load and store.
<<generic expansion operations>>=
module Address : sig
  type t
  val reg : temp -> t
end

val load  : dst:temp  -> addr:Address.t -> assertion -> rtl list
val store : addr:Address.t -> src:temp -> assertion -> rtl list
@
We also provide sign-extending and zero extending loads
as well as low-bit--extracting stores, all of which are used only
with integer registers.
<<generic expansion operations>>=
val sxload  : dst:temp  -> addr:Address.t -> width -> assertion -> rtl list
val zxload  : dst:temp  -> addr:Address.t -> width -> assertion -> rtl list
val lostore : addr:Address.t  -> src:temp -> width -> assertion -> rtl list
@
We need a move operation.
<<generic expansion operations>>=
val move : dst:temp -> src:temp -> rtl list
@ 
Load immediate can take any constant except a Boolean.
<<generic expansion operations>>=
val li : dst:temp -> Rtl.Private.const -> rtl list
@ 
We provide simple shortcuts for binary and unary operators.
I don't know if the shortcuts are worthwhile.
N.B.~no operator passed to any of these functions expects or returns a
Boolean! 
<<generic expansion operations>>=
val binop : dst:temp -> operator -> temp -> temp -> rtl list
val unop  : dst:temp -> operator -> temp         -> rtl list
val rtlop : dst:temp -> operator -> temp list    -> rtl list
@
The arguments to the functions above must satisfy the invariants that the
temporaries are in the spaces the expander expects.
It announces these spaces through argument and result contexts.
<<generic expansion operations>>=
type context = (width -> temp) * (Register.t -> bool)
val icontext : context (* for ints *)
val fcontext : context (* for floats *)
val acontext : context (* for addresses *)
val arg_contexts   : operator -> context list
val result_context : operator -> context
@ 
This is not quite what a real code expander does, but it should
suffice for experiments.
The context has three parts, all of which require knowledge of the
target machine:
\begin{itemize}
\item
Look at a location and say whether it is memory-like.
It is a checked run-time error to ask if a variable is memory-like
(this is not a property of the target but is the result of decisions
made higher up).
\item
Given a temporary space and a width, return a fresh temporary from
that space, suitably aggregated to the given width.
It is an \emph{unchecked} run-time error to ask for an unsupported
width.
\item
Given an expression, return a temporary space that would be suited to
hold the result of the expression.
\end{itemize}

<<expander.mli>>=
type context 
  = (Rtl.Private.loc -> bool)           (* say if a location is memory-like *)
  * (Rtl.Private.exp -> Rtl.space)      (* find a temp space to hold this exp *)
val context : Target2.t -> context
val expand : Talloc.Multiple.t -> context -> Rtl.rtl -> Rtl.rtl list
  (* returns *last* instruction at *head* of list (reverse execution order) *)
val cfg : 'a -> Proc.t -> bool
module IntFloatAddr (Post : Postexpander.S) : sig
  val expand : Rtl.rtl -> Rtl.rtl list
   (* THERE IS A BUG IN THIS CODE.  IT DOES NOT SHARE THE TEMP SUPPLY CORRECTLY *)
  val cfg    : 'a -> Proc.t -> bool
end 
@ 
Here are some abbreviations and utilities.
<<expander.ml>>=
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target2

let up   = Rtl.Revert.exp
let down = Rtl.Convert.exp
let uploc= Rtl.Revert.loc
let downloc= Rtl.Convert.loc

let upassn = Rtl.Revert.assertion

let fetch l = RP.Fetch (downloc l, RU.Width.loc l)

let width e = RU.Width.exp (up e)
@ 
To avoid quadratric list append, I use John Hughes's
continuation-passing list operations.
<<expander.ml>>=
let empty = fun l -> l
let unit x = fun l -> x :: l
let (@::) x f = fun l -> x :: f l
let (@@) f1 f2 = fun l -> f1 (f2 l)
let to_hughes l = fun l' -> l @ l'
let rec concat = function
  | [] -> empty
  | [x] -> x  (* premature optimization is the root of all evil *)
  | [x; y] -> x @@ y  (* premature optimization is the root of all evil *)
  | [x; y; z] -> x @@ y @@ z (* premature optimization is the root of all evil *)
  | h::t -> h @@ concat t
@ 
The core of the expander is a function [[to_temp]], which takes an
expression and returns a pair containing a list of instructions and a
temporary such that executing those instructions develops the
expression into that temporary.
<<expander.ml>>=
type context 
  = (Rtl.Private.loc -> bool)           (* say if a location is memory-like *)
  * (Rtl.Private.exp -> Rtl.space)      (* find a temp space to hold this exp *)

let expand temps (mem_like, space_for) =
  let temp_for = Talloc.Multiple.loc temps in
  let rec to_temp e = match e with
    | RP.Const k ->
        let w = width e in
        let t = temp_for (space_for e) w in
        (t:R.loc), unit (R.store t (up e) w)
    | RP.Fetch (l, w) ->
        if mem_like l then
          let t = temp_for (space_for e) w in
          let l, is = loc l in
          (t:R.loc), (R.store t (R.fetch l w) w @:: is)
        else
          uploc l, empty
    | RP.App (op, args) ->
        let (temps, is) = List.split (List.map to_temp args) in
        let w = width e in
        let t = temp_for (space_for e) w in
        t, (R.store t (up (RP.App (op, List.map fetch temps))) w @:: concat is)
  <<other expander functions>>
  and rtl r = match Rtl.Convert.rtl r with
  | RP.Rtl [(g, RP.Store (left, right, w))] ->
      assign g left right w
  | _ -> unit r (* no expansion takes place *)
  in fun r -> rtl r []
@ 

It would be good to do something with multiple assignments and with
guards, but for now I keep things very simple.

The remaining functions are simple.
<<other expander functions>>=
and assign g left right w =
  let r, is  = to_temp right in
  let l, is' = loc left in
  R.guard (up g) (R.store l (R.fetch r w) w) @:: is @@ is'

and loc l =
  if mem_like l then
    match l with
    | RP.Cell (space, agg, w, addr, prop) ->
        let addr, is = to_temp addr in
        uploc (RP.Cell (space, agg, w, fetch addr, prop)), is
    | _ -> assert false (* any mem-like location must be a cell *)
  else
    uploc l, empty
@ 
% ----------------------------------------------------------------
\subsection{A generic expander}
% ----------------------------------------------------------------

THE KEY ISSUE HERE IS WHAT TO DO ABOUT BOOLEAN OPERATORS AND GUARDS.

<<expander.ml>>=
module IntFloatAddr (Post : Postexpander.S) = struct
  <<generic expander>>
  <<generic flow-graph expander>>
end
@ 
The core of the expander is a function [[to_temp]], which takes an
expression and returns a pair containing a list of instructions and a
temporary such that executing those instructions develops the
expression into that temporary.
To get the right temporary, we work within a context, which makes it
possible to allocate a fresh temporary and to check if an existing
temporary is OK.
Function [[temp_in_context]] inserts a move if needed.
<<generic expander>>=
let alloc (allocate, check) w = allocate w
let ok    (allocate, check) reg = check reg

let temp_in_context ((space, n, w) as t) context instructions =
  if ok context t then
    t, instructions
  else
    let t' = alloc context w in
    t', to_hughes (Post.move t' t) @@ instructions
<<context guessing>>
@ 
It's questionable whether the byte order of a register should be fixed
to that of memory, but so be it.
<<generic expander>>=
let temploc (space, n, w) =
  Rtl.cell Rtl.none space Post.byte_order w
           (Rtl.bits (Bits.U.of_int n Post.wordsize) Post.wordsize)
@ 
<<generic expander>>=
let expand =
  let rec to_temp context e = match e with
    | RP.Const k ->
        let w = width e in
        let t = alloc context w in
        t, to_hughes (Post.li t k)
    | RP.Fetch (RP.Cell ('m', agg, w, addr, assn), w') ->
        let t = alloc context w in
        let a, is = address addr in
        assert (agg = Post.byte_order);
        assert (w = w');
        t, to_hughes (Post.load t a (upassn assn)) @@ is
    | RP.Fetch (RP.Cell (space, agg, w, RP.Const (RP.Bits b), assn), w') ->
        assert (w = w');
        temp_in_context (space, Bits.U.to_int b, w) context empty
    | RP.Fetch _ ->
        Impossible.impossible "memory-like access to non-memory space"
    <<cases for sign-extending and zero-extending loads>>
    | RP.App (op, args) ->
        let (temps, is) =
          List.split (List.map2 (fun c e -> to_temp c e) (Post.arg_contexts op) args)
        in
        let w = width e in
        let t = alloc (Post.result_context op) w in
        let compute = match temps with
        | [x; y] -> Post.binop t op x y  (* see note on binary operators below *)
        | [x]    -> Post.unop  t op x
        | _      -> Post.rtlop t op temps
        in
        temp_in_context t context (to_hughes compute @@ concat is)
  <<other generic expander functions>>
  and rtl r = match Rtl.Convert.rtl r with
  | RP.Rtl [(g, RP.Store (left, right, w))] ->
      guarded g left right w
  | _ -> unit r (* no expansion takes place *)
  in fun r -> rtl r []
@ The note on binary operators is that eventually the generic expander
should be extended so it can deal with a two-address target machine.
The generic expander should (somehow) divine whether the operation is 
in $L \mathrel{:=} L \oplus R$ form or in $R \mathrel{:=} L \oplus R$ form,
and it should call appropriate supporting functions in the target.
@
Sign-extending and zero-extending loads are done into integer registers only.
This fact is documented in the [[POST]] interface.
<<cases for sign-extending and zero-extending loads>>=
| RP.App (("sx", [n; w]), [RP.Fetch (RP.Cell ('m', agg, n', addr, assn), n'')]) ->
    assert (n == n' && n' == n'');
    let t = alloc Post.icontext w in
    let a, is = address addr in
    assert (agg = Post.byte_order);
    temp_in_context t context (to_hughes (Post.sxload t a n (upassn assn)) @@ is)
| RP.App (("zx", [n; w]), [RP.Fetch (RP.Cell ('m', agg, n', addr, assn), n'')]) ->
    assert (n == n' && n' == n'');
    let t = alloc Post.icontext w in
    let a, is = address addr in
    assert (agg = Post.byte_order);
    temp_in_context t context (to_hughes (Post.zxload t a n (upassn assn)) @@ is)
@
We might one day support multiple addressing modes, but for now, just registers. 
<<other generic expander functions>>=
and address exp =
  let t, is = to_temp Post.acontext exp
  in  Post.Address.reg t, is
@
It would be good to do something with multiple assignments and with
guards, but for now I keep things very simple.

(Need to be able to compile a guard to control flow.)
The remaining functions are simple.
<<other generic expander functions>>=
and guarded g left right w =
  match g with
  | RP.Const (RP.Bool true) -> assign left right w
  | _ ->
      (* this case is bogus *)
      let r, is  = to_temp (guess_context right) right in
      let l, is' = loc left in
      R.guard (up g) (R.store l (R.fetch (temploc r) w) w) @:: is @@ is'

and assign left right w =
  match left with
  | RP.Cell ('m', agg, w, addr, assn) ->
      assert (agg = Post.byte_order);
      let a, is' = address addr in
      (match right with
      | <<\emph{pattern [[->]] action} for low-bit store>>
      | _ ->
          let r, is = to_temp (guess_context right) right in
          to_hughes (Post.store a r (upassn assn)) @@ is' @@ is)
  | RP.Cell (space, agg, w, RP.Const (RP.Bits b), assn) ->
      let r, is = to_temp (guess_context right) right in
      to_hughes (Post.move ~dst:(space, (Bits.U.to_int b), w) ~src:r) @@ is
  | _ ->
      Impossible.impossible "memory-like access to non-memory space"
<<\emph{pattern [[->]] action} for low-bit store>>=
RP.App (("lobits", [w; n]), [rhs]) ->
  let r, is = to_temp Post.icontext rhs in
  to_hughes (Post.lostore a r n (upassn assn)) @@ is' @@ is
@   
<<other generic expander functions>>=
and loc l =
  match l with
  | RP.Cell ('m', agg, w, addr, assn) ->
      let addr, is = to_temp (Post.acontext) addr in
      uploc (RP.Cell ('m', agg, w, fetch (temploc addr), assn)), is
  | _ -> uploc l, empty

@

We guess a context based on right-hand side.
<<context guessing>>=
let guess_context = function
  | RP.Const k -> Post.icontext
  | RP.Fetch (RP.Cell (space, agg, w, RP.Const (RP.Bits b), assn), w') when
      (space = 'f' || space = 'u') -> Post.fcontext
  | RP.Fetch _ -> Post.icontext
  | RP.App (op, args) -> Post.result_context op
@ 
We can see a problem here.  The [[Proc.t]] contains a supply of
temporaries, and there's a different supply hidden inside the generic
expander (in the [[Post]] functor argument).
It's not clear how to link things together correctly.
<<generic flow-graph expander>>=
module G  = Cfg4
module GU = Cfgutil
let cfg _ proc =
  let g = proc.Proc.cfg in
  let t = proc.Proc.target in
  let _ = G.gm_enumerate g in
  let nodes = GU.fold_bwd g (fun x y -> x::y) [] in
  let modified = ref false in
  let exp n =
    match expand (G.instr n) with
    | last :: preds ->
        ignore (List.fold_left (fun n i -> G.gm_insert_assign_before i n) n preds);
        G.upd_instr n (fun _ -> last);
        (match preds with [] -> () | _ :: _ -> modified := true)
    | [] -> assert false in
  List.iter exp nodes;
  !modified
@

% ------------------------------------------------------------------ 
\subsection{Test Code}
% ------------------------------------------------------------------ 

This is some code I wrote to play with the expander in an interactive
interpreter.

<<rename this to compile it into expander.ml>>=
module Test = struct
    <<Test>>
end    

<<Test>>=
let truth      = RP.Const(RP.Bool true)
let const n    = RP.Const(RP.Bits(Bits.of_int n 32))
let loc n      = RP.Cell('m', R.Identity, 32, const n, 1)
let add x y    = RP.App(("add",[32]),[x; y])
let assign l r = RP.Store(l,r,32)

let mem_like = function
    | RP.Cell('m',_,_,_,_) -> true
    | _                    -> false

let count = ref 0
let tmp_for sp width =
    let () = count := !count + 1 in
    let l  = RP.Cell(sp, R.Identity, width, const !count, 1) in
        Rtl.Revert.loc l

let rtl        = let left  = loc 0 in
                 let right = add (const 2) (add (const 3) (const 4)) in
                    RP.Rtl([truth,assign left right])
@

The [[rtl]] above is translated into the following sequence (in reverse
execution order):

\begin{quote}
\begin{verbatim}
$m[$t[30::bits32]] = $t[29::bits32];
$t[29::bits32]     = %add($t[25::bits32], $t[28::bits32]);
$t[25::bits32]     = 2::bits32;
$t[28::bits32]     = %add($t[26::bits32], $t[27::bits32]);
$t[26::bits32]     = 3::bits32;
$t[27::bits32]     = 4::bits32;
$t[30::bits32]     = 0::bits32;
\end{verbatim}
\end{quote}


@
Contexts.  This is jury-rigged, since in real life the expander knows
all about the machine and doesn't need a context.
<<expander.ml>>=
let context t =
  let rec space_of = function
    | RP.Cell (s, _, _, _, _) -> s
    | RP.Var (_, _, _) -> assert false
    | RP.Slice (_, _, l) -> space_of l in
  let mem_like =
    List.fold_right
      (fun s rest ->
         if s.S.classification = S.Mem then
           fun c -> c = s.S.space || rest c
         else
           rest)
      t.T.spaces (fun _ -> false) in

  let is_temp s = match s.S.classification with
  | S.Temp _    -> true
  |        _    -> false  in
  let first_temp w =
    try (List.find (fun s -> is_temp s && s.S.cellwidth = w) t.T.spaces).S.space
      with Not_found ->
        prerr_string ("No temporary spaces in target " ^ t.T.name ^ "\n");
        flush stderr;
        assert false in
  let float_regexp = Str.regexp ".*[Ff]loat.*" in
  let is_float_space s = Str.string_match float_regexp s.S.doc 0 in
  let is_float_temp s = is_temp s && is_float_space s  in
  let float_temp w = 
    try (List.find is_float_temp t.T.spaces).S.space
      with Not_found -> first_temp w in

  let float_like =
    List.fold_right
      (fun s rest ->
         if s.S.classification <> S.Mem && is_float_space s then
           fun c -> c = s.S.space || rest c
         else
           rest)
      t.T.spaces (fun _ -> false) in

  let float_ops = ["fcmp"; "fadd"; "fsub"; "fdiv"; "fmul"; "fabs"; "fneg"; "fsqrt"] in
  let is_float_op op = List.exists ((=) op) float_ops in

  let is_float_exp = function
    | RP.Const _ -> false
    | RP.Fetch (loc, _) -> float_like (space_of loc)
    | RP.App ((op, _), args) -> is_float_op op  in

  ( (fun loc -> mem_like (space_of loc))
  , (fun e -> if is_float_exp e then 
                float_temp (Rtlutil.Width.exp (Rtl.Revert.exp e))
             else 
                first_temp (Rtlutil.Width.exp (Rtl.Revert.exp e)))
  )              
@ 
<<expander.ml>>=
module G  = Cfg4
module GU = Cfgutil
let cfg _ proc =
  let g = proc.Proc.cfg in
  let t = proc.Proc.target in
  let _ = G.gm_enumerate g in
  let nodes = GU.fold_bwd g (fun x y -> x::y) [] in
  let expand = expand proc.Proc.temps (context t) in
  let modified = ref false in
  let exp n =
    match expand (G.instr n) with
    | last :: preds ->
        ignore (List.fold_left (fun n i -> G.gm_insert_assign_before i n) n preds);
        G.upd_instr n (fun _ -> last);
        (match preds with [] -> () | _ :: _ -> modified := true)
    | [] -> assert false in
  List.iter exp nodes;
  !modified
@ 
% ------------------------------------------------------------------ 
\subsection{Exporting the Expander to Lua}
% ------------------------------------------------------------------ 

Code expansion is part of {\qcc}'s backend that is controlled by a Lua
interpreter. To make the expander accessible for Lua code, it is
exported as a Lua primitive [[Expander.toy]].
<<expander.mli>>=
module Lua (ProcT: Lua.Lib.TYPEVIEW with type 'a t = Proc.t): 
    Lua.Lib.TYPEFUL with type 'a combined = 'a ProcT.combined
<<expander.ml>>=
module Intel = IntFloatAddr(X86.Expander)

module Lua (ProcT: Lua.Lib.TYPEVIEW with type 'a t = Proc.t): 
    Lua.Lib.TYPEFUL with type 'a combined = 'a ProcT.combined =
struct
    type 'a combined = 'a ProcT.combined
    module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
    struct
      module V = C.V
      let ( **-> ) = V.( **-> )
      let proc     = ProcT.makemap V.userdata V.projection
      let init g = C.register_module "Expander" 
          [ "toyf" , V.pure (V.value **-> proc **-> V.result V.bool) cfg
          ; "x86f" , V.pure (V.value **-> proc **-> V.result V.bool) Intel.cfg
          ] g;
          Lua.Lib.StringList.of_list [ <<lua initialization>> ]
          
    end (*M*)    
end (*Lua*)            
@ 
<<lua initialization>>=
"Expander.toy = { fn = Expander.toyf, uses = { 'proper widths', 'no vars' }, \
                  name = 'Expander.toy', creates = { 'simple RHS' }, \
                  doc = 'A toy code expander' }";
"Expander.x86 = { fn = Expander.x86f, uses = { 'proper widths', 'no vars' }, \
                  name = 'Expander.x86', creates = { 'x86 invariant' }, \
                  doc = 'A prototype code expander for the x86' }";
""
@ 
