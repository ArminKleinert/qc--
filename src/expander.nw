% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

%%Grades: A Subsystem Later

\section{A generic, parameterized code expander}

\label{expander.sec}

A back end is obligated to expand code to RTLs.
To make retargeting easier, we provide here a generic code expander
that reduces the machine-dependent obligation.
If the machine can move data, operate on temporary registers, and
provide a few simple control-flow operations, this module does the
rest.
In other words, this module expands an RTL into a sequence of much
simpler RTLs.
The target-dependent code is relegated to a \emph{postexpander}.

To explain what is happening, I use the following
conventions:\\
\begin{tabular}{@{\quad}cl}
$t$& any temporary or register-like space\\
$m$& any memory-like space\\
$k$& any compile-time constant\\
$L$& any label or link-time constant\\
$\oplus$& any RTL value operator\\
$?$& any RTL comparison operator\\
\end{tabular}

For a register machine, we reduce RTLs to the following forms:
{\def\gets{\mathrel{:=}}%
$$\begin{array}{r@{}c@{}l@{\mskip10mu}ll}
m[t_l] & {}\gets{} & t     &\mbox{\texttt{store}}\\
t      & \gets & m[t_l]&\mbox{\texttt{load}} \\
t_1    & \gets & t_2   &\mbox{\texttt{move}} \\
t      & \gets & k     &\mbox{\texttt{li} (load immediate constant)}\\
t      & \gets & \oplus(t_1, \ldots, t_n) & 
  \mbox{ALU operations (\texttt{binop}, \texttt{rtlop}, etc)}\\
m[t_l] & \gets & \mathtt{lobits}_n(t)     &\mbox{\texttt{lostore} (store byte/halfword)}\\
t      & \gets & \mathtt{sx}(m[t_l])       &\mbox{\texttt{sxload} (load signed b/h)} \\
t      & \gets & \mathtt{zx}(m[t_l])       &\mbox{\texttt{zxload} (load unsigned b/h)} \\
\mathit{PC}& \gets & L &\mbox{\texttt{b} (branch)}\\
\mathit{PC}& \gets & t &\mbox{\texttt{br} (branch register)}\\
t \mathbin? t \rightarrow \mathit{PC}& \gets & L &\mbox{\texttt{bc} (branch conditional)}\\
\mathit{PC}& \gets & \rlap{t}\phantom{L/t} \mid t_l \gets t_r&\mbox{\texttt{cut\_to}}\\
\mathit{PC}& \gets & L/t \mid \cdots \mathit{PC} \cdots&\mbox{\texttt{call}/\texttt{callr}}\\
\end{array}
$$}
The treatment of [[call]] and [[cut to]] needs some explanation.
Both instructions change the program counter while also assigning to a
register.
In the case of [[call]], the program counter appears on the right-hand
side of some additional effect.
The generic expander assumes that this RTL originated in a call to
[[t.Target.call]], and that its only obligation is to expand the
expression denoting the callee.
The other effects are assumed not to need expansion, and they aren't
touched.
It's up to the [[t.Target.call]] to know what it's doing, although the
postexpander can validate the RTL if it wants.
In any case, we maintain the call as an atomic RTL. 

In the case of \mbox{[[cut to]]}, the program counter isn't mentioned
in an rvalue context, but some register (probably the stack
pointer) is modified along with the branch.
Here we don't need to know the details; all the expander needs to do is
preserve the atomicity of the assignment, but it can (and does) expand
out the right-hand sides.
In the case of cut to, the atomicity is not real; 
the illusion of atomicity is the result of
a conspiracy among the [[Target.t]], the expander, and the recognizer.
@
Some machines, notably the Pentium floating-point unit, are not
register machines but stack machines.
The classification above is not useful because there are few
operations that can work with an arbitrary temporary~$t$.
@
Driving the design is the following classification of operators:
\begin{itemize}
\item
A \emph{standard value operator} takes some bit vectors of reasonable
width and returns a result of that width.
\item
A \emph{weird value operator} takes some bit vectors of reasonable
width and returns a result of some other width.
The obvious weird operators are multiply (which doubles with width of
its operands) and multiprecision operators such as carry and borrow.
A~full classification awaits careful study of the list of operators.
\item
A \emph{size-changing operator} widens or narrows a bit vector.
I~believe there are only three such operators: [[sx]], [[zx]], and
[[lobits]].
\item
A \emph{comparison operator} takes one or more bit vectors and returns
a Boolean.
This category includes not only the usual integer and floating
comparisons but some machine-dependent condition-code testers and the
unnecessary [[bool]] operator.
\item
A \emph{Boolean operator} takes one or more Booleans and returns a
Boolean.
The only Boolean operators are [[conj]], [[disj]], and [[not]], and
I'm inclined to think they should be compiled to control flow.
\item
The elusive [[bit]] operator is the only operator to take a Boolean
and return a bit vector.
It is compiled to control flow below.
N.B.~Machines such as MIPS support [[bit]] by instructions such as SLT
(set less than), so it probably should not be compiled away by the
front end (sadly).
\end{itemize}
This classification speaks to the properties of the operators
themselves.
As such, it
 is orthogonal to the distinction between a
register machine and a stack machine, which speaks to how operators
are implemented on particular hardware.
@
\begin{quote}\em
Aside:
I'm contemplating how we might create a hand-written expander that can
easily be specialized to establish ``most of'' the machine invariant
for many different targets, without relying so heavily on peephole
optimization \emph{post facto}.
For example, it's legitimate to think of $\mathtt{\$m}[\cdot]$ as an
``address context.''
Any machine should be able to deal with $t$~in an address context, but
many machines will also be able to deal with $t_1+t_2$ and $t+k$ (though
on some machines $k$~may not be too large).
Some machines can even deal with $t_1+4\times t_2$!
One possibility, then, would be to make an ``address context''
function dynamic through Lua.
Care would have to be taken to avoid paying for an expensive identity
function (embedding/projection) at every application of such a function.
\end{quote}
@
\subsection{The target-dependent postexpander}

\label{expander.sec:Postexpander.S}

Here is a signature for a postexpander for an integer/float/address
machine.
These are the operations every target must implement.
<<postexpander.mli>>=
<<types for postexpanders>>
<<signature of a postexpander>>
<<postexpander.ml>>=
<<types for postexpanders>>
<<signature of a postexpander>>
<<types for postexpanders>>=
type temp      = Register.t
type rtl       = Rtl.rtl
type width     = Rtl.width
type assertion = Rtl.assertion
type operator  = Rtl.Private.opr
@ 
Most postexpander functions return a \emph{block}, which is a
single-entry, single-exit region of the control-flow graph.
Such a region can include conditional and looping control flow.
But expansion of a condition cannot itself be conditional; it must be
straight-line code.

We use a dirty trick to make the same constructors do for both.
If control flow is permitted, type parameter~[['a]] is [[exp]];
otherwise it is [[void]].
<<types for postexpanders>>=
type 'a t = Rtl   of rtl
          | Seq   of 'a t * 'a t
          | Cond  of 'a * 'a t * 'a t
          | While of 'a * 'a t
type void  = Void of void
type block = Rtl.exp t
type rtls  = void t
@ Meanings and invariants:
\begin{itemize}
\item [[Rtl]] is an RTL that can be represented by a single
instruction, with the following exceptions:
\begin{itemize}
\item
If the target machine has delayed control-transfer instructions
(branch/call/etc), we may use an RTL to represent an atomic
two-instruction package consisting of the control transfer and the
instruction in the delay slot.
We do this because at present, we have no other way to constrain
layout.
\item
For implementing [[cut to]], we use a single RTL representing two
instructions: one that adjusts the stack pointer and one that
branches.
We need to package these atomically because once the stack pointer has
been adjusted, the internal assumptions of the compiler are no longer
valid.
For example, it is not safe to spill a register after the stack
pointer has been adjusted.
We therefore treat the two instructions as an atomic unit by packaging
them as one RTL.
\item
An RTL may be representible as a single instruction only under the
optimistic assumption that a late compile-time constant is ``small.''
If the assumption is violated, it must be possible for the recognizer
to emit a sequence of instructions that together implement the RTL.
Either this sequence can be generated without using an additional
register, or else the recognizer will have to reserve to itself a
register for this purpose.
\end{itemize}
\item
A [[Seq]] node represents a sequence of instructions and executes
first the left half, then the right.
\item
A [[Cond]] node holds a condition, represented as an expression, such
that if the condition holds, 
it executes the first block; otherwise, it executes the second.
The condition must be expandable using the [[expand_cond]] function
in the postexpander interface below.
The condition need not satisfy any other invariants.
\item
The [[While]] node corresponds to a C-style [[while]] statement:
as long as the condition is satisfied, it executes the body.
As in [[Cond]],
the condition must be expandle using the [[expand_cond]] function
in the postexpander interface below.
The condition need not satisfy any other invariants.
\end{itemize}
<<signature of a postexpander>>=
module type S = sig
  val byte_order : Rtl.aggregation (* used on all access to memory *)
  val wordsize   : int             (* used as width of register number! *)

  module Address : sig
    type t
    val reg : temp -> t
  end

  <<operations that enable the postexpander to allocate>>
  <<generic expansion operations for register machines>>
  <<generic expansion operations for stack machines>>
end
@ 
A postexpander may need to allocate a temporary or a slot in the stack
frame, or it may need to emit initialized data (e.g., for a
floating-point load). It keeps these allocators in mutable state (once
per procedure). At present, only allocation of a temporary or a stack
slot is supported.
<<operations that enable the postexpander to allocate>>=
val remember_allocator : Talloc.Multiple.t -> unit
val remember_slot_allocator : Automaton.t -> unit
@ 
\subsubsection{Postexpander operations for register machines}
We provide basic load and store.
<<generic expansion operations for register machines>>=
val load  : dst:temp  -> addr:Address.t -> assertion -> rtl list
val store : addr:Address.t -> src:temp -> assertion -> rtl list
@
We also provide sign-extending and zero extending loads
as well as low-bit--extracting stores, all of which are used only
with integer registers.
This is the only place the back end is required to support
size-changing operators; other uses, such as compositions of widens
and narrows, should be compiled to suitable code (shifts or identity)
somewhere upstream.
<<generic expansion operations for register machines>>=
val sxload  : dst:temp  -> addr:Address.t -> width -> assertion -> rtl list
val zxload  : dst:temp  -> addr:Address.t -> width -> assertion -> rtl list
val lostore : addr:Address.t  -> src:temp -> width -> assertion -> rtl list
@
We need a move operation.
<<generic expansion operations for register machines>>=
val move : dst:temp -> src:temp -> rtl list
@ 
Load immediate can take any constant except a Boolean.
<<generic expansion operations for register machines>>=
val li  : dst:temp -> Rtl.Private.const -> rtl list
@ 
An extended load-immediate can take sums and differences of
compile-time constants (including late compile-time constants). 
<<generic expansion operations for register machines>>=
val lix : dst:temp -> Rtl.exp           -> rtl list
@ 
We provide simple shortcuts for binary and unary operators.
I don't know if the shortcuts are worthwhile.
N.B.~no operator passed to any of these functions expects or returns a
Boolean! 
Ordinary value operators are expected to be supported by these
operations, but only at their natural widths.
Perhaps the weird value operators should be supported also.
<<generic expansion operations for register machines>>=
val binop : dst:temp -> operator -> temp -> temp -> rtl list
val unop  : dst:temp -> operator -> temp         -> rtl list
val rtlop : dst:temp -> operator -> temp list    -> rtl list
@
The arguments to the functions above must satisfy the invariants that the
temporaries are in the spaces the expander expects.
It announces these spaces through argument and result contexts.
The context names a temporary space from which to draw temporaries and
it also says when a temporary satisfies that context.
\nextchunklabel{expander.Postexpander.context}%

THE REAL STORY HAS GOT TO BECOME MORE COMPLICATED.
HERE ARE THE CONTEXTS WE FIND ON THE X86:
\begin{itemize}
\item
A TEMPORARY THAT CAN BE ALLOCATED BY THE REGISTER ALLOCATOR
\item
A LOCATION ON THE FLOATING-POINT STACK
\item
A LOCATION IN MEMORY WITH KNOWN SIZE AND ALIGNMENT
\item 
A FIXED HARDWARE REGISTER SUCH AS ROUNDING MODES
\end{itemize}
THE EXPANDER SHOULD BE UPDATED TO PROVIDE THIS FULL INFORMATION AS THE
ARGUMENT AND RESULT CONTEXT FOR EVERY OPERATOR.
THEN IT CAN BE THE JOB OF THE EXPANDER TO DO SUCH THINGS AS ALLOCATE
MEMORY SLOTS, ETC.
<<generic expansion operations for register machines>>=
type context = (Talloc.Multiple.t -> int -> Register.t) * (Register.t -> bool)
val icontext : context (* for ints *)
val fcontext : context (* for floats *)
val acontext : context (* for addresses *)
val constant_context : width    -> context
val arg_contexts     : operator -> context list
val result_context   : operator -> context
@ 
We have to know when a right-hand side is too big to try to cram into
a single temporary.
<<generic expansion operations for register machines>>=
val itempwidth : int  (* maximum width for one integer temporary *)
@
Every machine should be able to do a block copy.
<<generic expansion operations for register machines>>=
val block_copy :
  dst:Address.t -> assertion -> src:Address.t -> assertion -> width -> rtl list
@ 
\paragraph{Control flow}
To recognize control flow, the expander must be able to identify the
program counter.
We could provide an abstract test of type [[Rtl.loc -> bool]],
but until we need the extra generality, we avoid it.
On the other hand, we \emph{do} need a different representation of the
program counter on the left and the right of an assignment, in order
to handle the SPARC \emph{PC}/\emph{nPC} duo.
<<generic expansion operations for register machines>>=
val pc_lhs : Rtl.loc                    (* program counter as assigned by branch *)
val pc_rhs : Rtl.loc                    (* program counter as captured by call *)
@ 
To create control flow, the postexpander must provide an RTL that
includes an assignment to [[pc_lhs]].
This RTL must be the last in the execution sequence (and therefore the
head of the list that is returned).
We can branch to a temporary drawn from [[acontext]] or to a constant. 
<<generic expansion operations for register machines>>=
val br : tgt:temp -> rtl list               (* branch register *)
val b  : tgt:Rtl.Private.const -> rtl list  (* branch *)
@ 
For a conditional branch,  the target must be a static label, but the
postexpander provides any Boolean condition 
applied to temporaries.
Furthermore, it must be the case that the final, actual branch
instruction can have its sense reversed with [[bnegate]], and the
result is still representable by a single instruction on the target
machine.
<<generic expansion operations for register machines>>=
val bc      : temp -> operator -> temp -> tgt:Rtl.Private.const -> rtl list
val bnegate : rtl -> rtl  (* swap the condition in a conditional branch *)
@ The last (head) instruction from [[bc]] is the \emph{only}
instruction that may legitimately be passed to [[bnegate]].
@ 
The postexpander must be able to call direct and indirect.
A~call instruction may include multiple effects, but the postexpander
is responsible only for the effect on the program counter.
The other effects, which originate from an undisclosed location in the
compiler, are simply passed in and composed in parallel with the
assignment to the~PC.
<<generic expansion operations for register machines>>=
val callr : tgt:temp              -> others:Rtl.Private.effect list -> rtl list
val call  : tgt:Rtl.Private.const -> others:Rtl.Private.effect list -> rtl list
@
The [[cut to]] is as created by the target-dependent code, except
right-hand sides have been expanded to temporaries.
<<generic expansion operations for register machines>>=
val cut_to : Rtl.Private.effect list -> rtl list
@
The postexpander may insist on having some instructions untouched.
This is possible only for an instruction with multiple effects and a
single guard.
<<generic expansion operations for register machines>>=
val don't_touch_me : Rtl.Private.effect list -> bool
@
\subsubsection{Postexpander operations for stack machines}

For simplicity, we assume the target machine has at most one stack.
If we need more generality, we can add it later.
@
To begin, we have to know which operators use the stack.
If an operator uses the stack, we need to know whether to push its
left operand first or its right operand first, and we need to know how
much stack room it needs to execute successfully.
room they need.
<<types for postexpanders>>=
type operator_class = Register | Stack of push * int
and  push = LeftFirst | RightFirst
@ 
For a particular machine, we need to know the class of each operator,
the depth of the stack, and the width of a value that can be pushed on
the stack.
<<generic expansion operations for stack machines>>=
val opclass : operator -> operator_class
val stack_depth : int
val stack_width : int
@ 
We also need to identify an operator that takes a value from the stack
and converts it for use in a temporary.  This sort of operator is
needed on machines in which the width of stack is different from the
width of a temporary (like the Pentium).
<<generic expansion operations for stack machines>>=
val converts_stack_to_temp : operator -> bool
@
We can push a value from memory or pop the stack into memory.
<<generic expansion operations for stack machines>>=
val push      : addr:Address.t -> assertion -> rtl list
val store_pop : addr:Address.t -> assertion -> rtl list
@ 
We also have versions of these operations that convert between data
formats while popping or pushing.
We have to give the width of the value in memory.
<<generic expansion operations for stack machines>>=
val push_cvt      : operator -> width -> addr:Address.t -> assertion -> rtl list
val store_pop_cvt : operator -> width -> addr:Address.t -> assertion -> rtl list
@ 
We can also imagine a whole bunch of stack operations:
[[stack_copy]], [[dup]], [[exch]], [[pop]], and more.
 Luckily we don't need any of them for code expansion.
@
We may have to push a constant.
This, too, may happen with conversion.
<<generic expansion operations for stack machines>>=
val pushk     :                      Rtl.Private.const -> rtl list
val pushk_cvt : operator -> width -> Rtl.Private.const -> rtl list
@
We may operate on the stack.
<<generic expansion operations for stack machines>>=
val stack_op : operator -> rtl list
@
We may branch conditionally based on the result of a stack operation.
<<generic expansion operations for stack machines>>=
val bc_stack : operator -> tgt:Rtl.Private.const -> rtl list
@ 
To support a calling convention that passes arguments or results on
the stack, we have to support push and pop instructions.
But a calling-convention automaton knows nothing of push and pop---in
particular, an automaton expects to be able to fetch a value using
only an RTL expression, so it has no way to create the side effect on
the stack pointer.
We resolve this problem by introducing a \emph{proxy} for the location
on the top of the stack.
This proxy may be used before code expansion with the expectation that
the code expander will rewrite it away:
\begin{itemize}
\item
If the proxy appears in an rvalue context, the expander replaces it
with whatever is on top of the stack (which is popped off).
\item
If the proxy appears on the left of a store, the expander pushes the
right-hand side.
\item 
If the proxy is killed, the expander complains bitterly.
\end{itemize}
Because not every postexpander supports stack operations, we provide
[[is_stack_top_proxy]] so that it can always return [[false]].
<<generic expansion operations for stack machines>>=
val stack_top_proxy    : Rtl.loc
val is_stack_top_proxy : Rtl.Private.loc -> bool
@ 
\subsubsection{A placeholder for register-only machines}
A postexpander for a register-only machine can simply include a
[[Nostack]] module.
<<postexpander.mli>>=
module Nostack (Address : sig type t val reg : temp -> t end) : sig
 <<generic expansion operations for stack machines>>
end
<<postexpander.ml>>=
module Nostack (Address : sig type t val reg : temp -> t end) = struct
  let opclass _ = Register
  let stack_depth = 0
  let stack_width = 0
  let converts_stack_to_temp _ = false
  let push ~addr _              = Impossible.impossible "stack op on register machine"
  let store_pop ~addr _         = Impossible.impossible "stack op on register machine"
  let push_cvt _ _ ~addr _      = Impossible.impossible "stack op on register machine"
  let store_pop_cvt _ _ ~addr _ = Impossible.impossible "stack op on register machine"
  let pushk _                   = Impossible.impossible "stack op on register machine"
  let pushk_cvt _ _ _           = Impossible.impossible "stack op on register machine"
  let stack_op _                = Impossible.impossible "stack op on register machine"
  let bc_stack _ ~tgt           = Impossible.impossible "stack op on register machine"
  let stack_top_proxy = Rtl.reg (('\000', Rtl.Identity, Cell.of_size 0), 0, Rtl.C 0)
  let is_stack_top_proxy _ = false
end
@ 

\subsection{Implementation outline}

The [[Proc.t]] gives the expander a supply of temporaries.
<<expander.mli>>=
module type S = sig
  val cfg: 'a -> Ast2ir.proc -> bool
end 
module IntFloatAddr (Post : Postexpander.S) : S
@ 
Here are some abbreviations and utilities.
<<expander.ml>>=
module type S = sig
  val cfg: 'a -> Ast2ir.proc -> bool
end 

module A  = Automaton
module BO = Bits.Ops
module PX = Postexpander
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target

module Up   = Rtl.Up
module Down = Rtl.Dn

let upassn = Rtl.Up.assertion
@ 
\subsection{Utilities and debugging code}
<<expander.ml>>=
let fetch l = RP.Fetch (Down.loc l, RU.Width.loc l)
let width e = RU.Width.exp (Up.exp e)
@ 
Sometimes, we may require that a node have an instruction.
<<expander.ml>>=
module G = Cfgx.M
let inst n =
  match G.to_instr n with
  | Some i -> i
  | None   -> Impossible.impossible "Expanded node must have instruction"
@
SOMEWHERE WE NEED A HIGH-LEVEL EXPLANATION OF WHAT THE FLOW-GRAPH HAS
TO DO WITH EXPANSION. ---NR

The code expander returns a (possibly empty) segment of a cfg with an
entry node and an exit node. 
We represent such a segment with a pair $(entry\_node, exit\_node)$.
The empty segment is represented by a pair containing two copies of
the illegal node---and \emph{only} the empty segment may contain an
illegal node.
<<flow-graph manipulation utilities>>=
let emptyseg = let ill = G.illegal cfg in (ill,ill) in
@
<<expander.ml>>=
let is_empty (xi,xf) = G.kind xi =*= G.Illegal && G.kind xf =*= G.Illegal
@ To concatenate segments, we must recognize (and ignore) the empty segment.
<<flow-graph manipulation utilities>>=
let (@@) ((xi,xf) as x) ((yi,yf) as y) =
  if      is_empty x then y
  else if is_empty y then x
  else begin G.set_succ xf ~succ:yi; (xi, yf) end in
@
We provide several constructors for segments:
\begin{itemize}
\item [[nunit]] creates a segment that contains one instruction.
\item [[to_segment]]  creates a segment from a list of instructions in
reverse-execution order
\item [[seg_concat]] concatenates a list of segments.
\end{itemize}
<<flow-graph manipulation utilities>>=
let nunit      i = let n = G.instruction cfg i ~succ:(G.illegal cfg) in (n,n) in
let to_segment l = List.fold_left (fun seg i -> nunit i @@ seg) emptyseg l in
let seg_concat l = List.fold_right (@@) l emptyseg in
@
We also need to be able to take a single-entry, single-exit segment of control flow and
insert it in place of an existing non-join node.
In the function [[replace_node]], [[xi]] is the single-entry and [[xf]] is the single
exit in a control-flow segment.
<<expander.ml>>=
let replace_node n ((xi,xf) as x) =
  if is_empty x then
       (G.update_instr (fun _ -> R.par []) n; false)
  else if G.eq xi xf then
       (G.update_instr (fun _ -> inst xf) n; false)
  else
       let last_new = G.pred xf in
         begin
           G.splice_before ~entry:xi ~exit:last_new n;
           G.update_instr (fun _ -> inst xf) n;
           true
         end
@
For debugging purposes, it's sometimes easier to look at a segment as a flat list;
obviously, the list loses the structure of the segment.
<<expander.ml>>=
let seg_to_list (xi,xf)  =
  let rec to_list' n =
    if G.kind n =*= G.Illegal then []
    else let rst = if G.eq n xf then [] else
                   List.concat (List.map to_list' (G.succs n))
         in  match G.to_instr n with
             | Some i -> i :: rst
             | None   -> rst
  in to_list' xi
@
Some debugging code is most helpful.
The expander writes debugging information as it goes;
to activate it, try \texttt{VERBOSITY=5~qc--}.
<<expander.ml>>=
module D = struct (* debugging *)
    let strings =
      if Debug.on "expander" then
        (fun ss -> Printf.eprintf "%s" (String.concat "" ss))
      else
        (fun ss -> ()) 
    let int n = string_of_int n
    let exp e = Rtlutil.ToString.exp (Up.exp e) 
    let rtl r = Rtlutil.ToString.rtl r 
    let pr_is   is = List.iter (fun r -> strings ["  "; rtl r; "\n"]) (seg_to_list is)
    let pr_rtls rs = List.iter (fun r -> strings ["  "; rtl r; "\n"]) (List.rev rs)
    let temp ((s, _, ms), n, c) =
      "$" ^ Char.escaped s ^ "[" ^ int n ^ "] : " ^ int (Cell.to_width ms c) ^ " loc" 
end
@ 
This little hack
enables statement-count profiling to work even when the expander loops infinitely.
It was useful in debugging the expander.
<<expander.ml>>=
let _ = Sys.set_signal Sys.sigterm (Sys.Signal_handle (fun _ -> exit 0))
@ 
% ----------------------------------------------------------------
\subsection{A generic expander}
% ----------------------------------------------------------------

This expander is intended for machines with integer, floating, and
address register spaces.
It will also work with integer/float machines, since we can make
address registers a synonym for integer registers.
<<expander.ml>>=
module IntFloatAddr (Post : Postexpander.S) = struct
  let pc_lhs = Down.loc Post.pc_lhs
  let pc_rhs = Down.loc Post.pc_rhs
  <<generic expander>>
  <<generic flow-graph expander>>
end
@ 
Within the expander, we need to be able to turn a temporary into a
location. 
For this we need the postexpander.
It's questionable whether the byte order of a register should be fixed
to that of memory, but so be it.
When we refactor the compiler to support register locations directly,
this function should go away.
<<generic expander>>=
let temploc (space, n, w) = R.reg (space, n, w)
@ 
\subsection{Contexts in which to evaluate expressions}

The world is complicated by the existence of two kinds of machines:
stack machines and register machines.
For a stack machine, much of code expansion involves computing
subexpressions onto the stack.
For a register machine, much of code expansion involves computing
subexpressions into temporaries, which the register allocator will
later turn into registers.

For simplicity, we assume that a stack machine has exactly one stack.
But registser machines have lots of kinds of registers.
To choose the right kind for an expression, we need to know the
\emph{context}.
The context tells us what sort of temporary is appropriate
(typically integer, float, or address).
Sadly, there are two representations of contexts.
\begin{itemize}
\item
A \emph{dynamic} context provides two items: an infinite
supply of temporaries, and a predicate that says whether an existing
temporary can be used in the context.
The supply of temporaries must be shared with the rest of the
compiler, including the variable placer and
register allocator.
Because the supply of temporaries is new for each procedure, we can't
provide one at compile-compile time.
This is why the context is \emph{dynamic}.
\item
A \emph{static} context provides, instead of a supply of temporaries,
the name of the space from which the temporaries should be drawn.
(The static context also includes the checking predicate.)
We can therefore create a static context at compile-compile time, and
in fact we require the postexpander to supply three of them (see
chunk~\subpageref{expander.Postexpander.context}). 
\end{itemize}
We use the allocator in the [[Proc.t]] to convert from a static
context to a dynamic context; see function [[contextmap]] in
chunk~\subpageref{expander.contextmap}. 
@
Here we define the [[alloc]] and [[check]] functions, which use a
dynamic context.
(Actually [[check]] can use either kind.)
<<generic expander>>=
let alloc (allocate, check) w   = allocate w
let ok    (allocate, check) reg = check reg
@ 
Function [[temp_in_context]] takes an existing temporary and a
context, and returns a (possibly new) temporary that is OK for the
context (along with instructions that make it so). 
<<flow-graph functions>>=
let temp_in_context ((space, n, _) as t) context instructions =
  if ok context t then
    t, instructions
  else
    let t' = alloc context (Register.width t) in
    t', instructions @@ to_segment (Post.move t' t) in
@ 
Within the expander, we eagerly build some dynamic contexts:
[[icontext]], [[acontext]], and [[fcontext]].
We also keep function [[contextmap]] for those times when we get a
context that's not known at compile-compile time.
\nextchunklabel{expander.contextmap}%
<<generic expander>>=
let expand ({Proc.cfg = cfg} as proc) =
  <<stack-slot allocation>>
  <<flow-graph manipulation utilities>>
  <<functions for dealing with trivial guards>>
  let contextmap (allocator, checker) = (allocator proc.Proc.temps, checker) in
  let icontext = contextmap Post.icontext in
  let acontext = contextmap Post.acontext in
  let fcontext = contextmap Post.fcontext in
  <<rounding-mode checking>>
  <<context guessing>>
  let alloc_direct (allocator, _) = allocator proc.Proc.temps in
  <<flow-graph functions>>
  <<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>
  (Post.remember_allocator proc.Proc.temps;
   Post.remember_slot_allocator proc.Proc.priv;
  (expand_cbranch,rtl))
@ 
To find the context for the operands of a comparison, I use the
dreadful hack that every floating-point 
comparison begins with [[f]] and no other comparison does.
This code probably should be replaced with a call to
[[Post.arg_contexts]].
<<context guessing>>=
let cmp_context (oprname, ws) =
  if oprname.[0] =<= 'f' then fcontext else icontext in
@
In other situations, we may have to guess a context based on a
right-hand side. 
<<context guessing>>=
let guess_context = function
  | RP.Const (RP.Bits b) -> contextmap (Post.constant_context (Bits.width b))
  | RP.Const k -> icontext
  | RP.Fetch(RP.Reg ((('f'|'u'), _, _), _, _),_) -> fcontext
  | RP.Fetch _ -> icontext
  | RP.App (op, args) -> contextmap (Post.result_context op) in
@ 
We may also have to guess whether to develop a right-hand side into a
temporary or on the stack.
<<context guessing>>=
let looks_like_stack_rhs = function
  | RP.App (op, _) ->
      begin
        match Post.opclass op with
        | PX.Stack (_, _) -> true
        | PX.Register -> false
      end
  | RP.Fetch (l, _) -> Post.is_stack_top_proxy l
  | _ -> false in
@ 
\subsection{Expanding an expression into a temporary}
The core of the expander is a function [[to_temp]], which takes an
expression and returns a pair containing a list of instructions and a
temporary such that executing those instructions develops the
expression into that temporary.

Unprimed versions of functions issue debugging screeds; primed
versions do the real work.
Here we define the primed and use the unprimed; the two are connected
with debugging code below.

Most cases identify what postexpander function should be used and
create suitable temporaries.%
\footnote{We have a small problem with register targeting; the problem
effects the size of the expanded code and therefore the compile-time
efficiency.
We wish to avoid generating superfluous move
instructions.
There are two possible contexts: if a right-hand side is already a temporary, we avoid
allocating a second temporary.
But if a left-hand side is already a temporary, we fail to ``target''
the right-hand side into that temporary.
It is not obvious to NR how to write an expander that achieves both.}
<<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>=
let rec to_temp' room context e =
  match e with
  | RP.Const k ->
      let w = width e in
      let t = alloc context w in
      t, to_segment (Post.li t k)
  | RP.App (_, _) when is_compile_time_constant e ->
      let w = width e in
      let t = alloc context w in
      t, to_segment (Post.lix t (Up.exp e))
  | RP.Fetch (l, w) when Post.is_stack_top_proxy l ->
      let slot = exchange_slot w in
      let t, is = to_temp room context (fetch_slot slot w) in
      t, assign_slot room slot e w @@ is
  | RP.Fetch (RP.Mem (('m', agg, ms), c, addr, assn), w) ->
      let t = alloc context w in
      let a, is = address room addr in
      assert (agg =*= Post.byte_order);
      assert (w = Cell.to_width ms c);
      t, is @@ to_segment (Post.load t a (upassn assn))
  | RP.Fetch (RP.Reg r, w) ->
      assert (w = Register.width r);
      temp_in_context r context emptyseg
  | RP.Fetch _ ->
      Impossible.impossible "memory-like access to non-memory space"
  <<cases for sign extending or zero extending a temporary>>
  <<cases for sign-extending and zero-extending loads>>
  <<cases for sign-extending and zero-extending divides>>
  <<cases for converting a Boolean to a value>>
  | RP.App ((_, [stackw; tempw]) as cvt, _) as e
    when Post.converts_stack_to_temp cvt ->
      let slot = exchange_slot tempw in
      let t, is = to_temp room context (fetch_slot slot tempw) in
      t, assign_slot room slot e tempw @@ is 
  | RP.App (("f2f_implicit_round", ws), [x]) ->
      to_temp room context (RP.App (("f2f", ws), [x; RP.Fetch(rounding_mode, 2)]))
  | RP.App (op, args) ->
      begin
        match Post.opclass op with
        | PX.Stack(dir, depth) ->
            let w = Post.stack_width in
            let slot = exchange_slot w in
            let t, is = to_temp room context (fetch_slot slot w) in
            t, assign_slot room slot e w @@ is
        | PX.Register ->
            let (temps, is) =
              try
                List.split (List.map2 (fun c e -> to_temp room (contextmap c) e)
                              (Post.arg_contexts op) args)
              with Invalid_argument (_) ->
                Impossible.impossible 
                  (Printf.sprintf "bad arity for operator %s (args %d vs context %d)"
                    (fst op) (List.length args) (List.length (Post.arg_contexts op)))
            in
            let w = width e in
            let t = alloc_direct (Post.result_context op) w in
            let compute = match temps with
            | [x; y] -> Post.binop t op x y  (* see note on binary operators below *)
            | [x]    -> Post.unop  t op x
            | _      -> Post.rtlop t op temps
            in
            temp_in_context t context (seg_concat (List.rev is) @@
                                       to_segment compute)
      end
<<other generic expander functions>> in
@ The note on binary operators is that eventually the generic expander
might be extended so it can deal with a two-address target machine.
The generic expander might (somehow) divine whether the operation is 
in $L \mathrel{:=} L \oplus R$ form or in $R \mathrel{:=} L \oplus R$ form,
and it could call appropriate supporting functions in the target.
On the other hand, we could just rely on peephole optimization\ldots
@
Sign-extending and zero-extending loads are done into integer registers only.
This fact is documented in the postexpander interface.
<<cases for sign-extending and zero-extending loads>>=
| RP.App (("sx", [n;w]), [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n')]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    let t = alloc icontext w in
    let a, is = address room addr in
    assert (agg =*= Post.byte_order);
    temp_in_context t context (is @@ to_segment (Post.sxload t a n (upassn assn)))
| RP.App (("zx", [n;w]), [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n')]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    let t = alloc icontext w in
    let a, is = address room addr in
    assert (agg =*= Post.byte_order);
    temp_in_context t context (is @@ to_segment (Post.zxload t a n (upassn assn)))
@
<<cases for sign extending or zero extending a temporary>>=
| RP.App (("sx", [n; w]), [RP.App(("lobits", [w'; n']), [x])]) when w = w' ->
    if n <> n' then Impossible.impossible "ill-typed %sx(%lobits(...))";
    let sh_amt = RP.Const (RP.Bits (Bits.U.of_int (w-n) w)) in
    to_temp' room context
      (RP.App (("shra", [w]), [RP.App(("shl", [w]), [x; sh_amt]); sh_amt]))
| RP.App (("zx", [n; w]), [RP.App(("lobits", [w'; n']), [x])]) when w = w' ->
    if n <> n' then Impossible.impossible "ill-typed %sx(%lobits(...))";
    let sh_amt = RP.Const (RP.Bits (Bits.U.of_int (w-n) w)) in
    to_temp' room context
      (RP.App (("shrl", [w]), [RP.App(("shl", [w]), [x; sh_amt]); sh_amt]))
@ 
Division is going to be a real problem; I can just tell.
Here's a hack which is untested and probably useless.
<<cases for sign-extending and zero-extending divides>>=
| RP.App ((("divu"|"modu") as divmod, [w; n]), [RP.App (("zx", [n'; w']), [x]); y])
  when w = w' && n = n' ->
    let t = alloc icontext n in
    let tx, isx = to_temp room icontext x in
    let ty, isy = to_temp room icontext y in
    let divmod = Post.binop t ((divmod ^ "_trunc"), [n]) tx ty in
    temp_in_context t context (isx @@ isy @@ to_segment (divmod))
@ 
For the bit operator, we generate two branches of control flow, create an rtl for a
conditional branch, and pass everything over to [[expand_cbranch]].
<<cases for converting a Boolean to a value>>=
| RP.App (("sx", [n; w]), [RP.App (("bit", []), [e])]) ->
    assert (n = 1);
    let t       = alloc context w in
    let pc_lhs_up = Rtl.Up.loc pc_lhs in

    let tlabel  = Idgen.label "if_true" in
    let tsym    = Rtl.codesym (proc.Proc.mk_symbol tlabel) (RU.Width.loc pc_lhs_up) in
    let tjoin   = G.node_labeled cfg tlabel in
    let (ti,tf) = to_segment (Post.li t (RP.Bits (Bits.S.of_int 1 w))) in
    let ()      = G.set_succ tjoin ~succ:ti in

    let flabel  = Idgen.label "if_false" in
    let fjoin   = G.node_labeled cfg flabel in
    let (fi,ff) = to_segment (Post.li t (RP.Bits (Bits.S.of_int 0 w))) in
    let ()      = G.set_succ fjoin ~succ:fi in

    let elabel = Idgen.label "end_if" in
    let ejoin  = G.node_labeled cfg elabel in
    let ()     = G.set_succ ff ~succ:(G.branch cfg ~target:ejoin) in
    let ()     = G.set_succ tf ~succ:(G.branch cfg ~target:ejoin) in

    let rtl = R.guard (Up.exp e) (RU.store pc_lhs_up tsym) in
    let bi  = expand_cbranch rtl tjoin fjoin in
    t, (bi,ejoin)
@
We might one day support multiple addressing modes, but for now, just registers. 
<<other generic expander functions>>=
and address room exp =
  let t, is = to_temp room acontext exp
  in  Post.Address.reg t, is
@
A compile-time constant is a sum or difference of compile-time constants.
<<other generic expander functions>>=
and is_compile_time_constant = function
  | RP.Const (RP.Bits _ | RP.Late (_, _)) -> true
  | RP.App   ((("add"|"sub"), [w]), es)   -> List.for_all is_compile_time_constant es
  | _ -> false
@ 

\subsection{Expanding using stack instructions}
<<other generic expander functions>>=
and to_stack' room e =
  if room < 1 then
    Impossible.impossible "machine stack overflow in code generation";
  if Rtlutil.Width.exp' e <> Post.stack_width then
     (Printf.eprintf "failing expression: %s\n" (Rtlutil.ToString.exp
                                                  (Rtl.Up.exp e));
         Unsupported.stack_width ~have:(Rtlutil.Width.exp' e)
         ~want:Post.stack_width);
  match e with
  | RP.Const k ->
      to_segment (Post.pushk k)
  | RP.Fetch (l, _) when Post.is_stack_top_proxy l ->
      emptyseg
  | RP.Fetch (RP.Mem (('m', agg, ms), c, addr, assn), w) ->
      let a, is = address room addr in
      assert (agg =*= Post.byte_order);
      assert (w = Cell.to_width ms c);
      is @@ to_segment (Post.push a (upassn assn))
  | RP.Fetch (RP.Reg (space, i, c), w) ->
      let slot = exchange_slot w in
      assign_slot room slot e w @@ to_stack room (fetch_slot slot w)
  | RP.Fetch _ ->
      Impossible.impossible "memory-like access to non-memory space"
  | RP.App (("f2f_implicit_round", ws), [x]) ->
      to_stack room (RP.App (("f2f", ws), [x; RP.Fetch(rounding_mode, 2)]))
  <<cases for converting pushes>>
  | RP.App (("i2f", [iw; fw] as i2f), [e; rm]) ->
      let slot = exchange_slot iw in
      assign_slot room slot e iw @@
      to_stack room (RP.App (i2f, [fetch_slot slot iw; rm]))
  | RP.App (("f2f", [w; _] as f2f), [e; rm]) ->
      let slot = exchange_slot w in
      assign_slot room slot e w @@
      to_stack room (RP.App (f2f, [fetch_slot slot w; rm]))
  | RP.App (op, args) ->
      begin
        match Post.opclass op with
        | PX.Stack(dir, depth) ->
            let args = List.filter is_not_rounding_mode args in (* cheat!!! *)
            let args =
              match dir with PX.LeftFirst -> args | PX.RightFirst -> List.rev args in
            let push_args room =
              let (is, _) =
                List.fold_left (fun (is,r) e -> (is @@ to_stack r e, r-1))
                (emptyseg,room) args in
              is in
            let compute room = push_args room @@ (to_segment (Post.stack_op op )) in
            if room >= depth then
              compute room
            else
              save_stack room @@ compute Post.stack_depth @@ restore_stack 1 room
        | PX.Register ->
            let r, is = to_temp room (guess_context e) e in
            is @@ to_stack room (RP.Fetch (RP.Reg r, Register.width r))
      end
@ 
<<rounding-mode checking>>=
let rounding_mode = Down.loc proc.Proc.target.Target.rounding_mode in
let is_not_rounding_mode arg = match arg with
| RP.Fetch (l, 2) -> not (RU.Eq.loc l rounding_mode)
| _ -> true in
<<junk>>=
let insist_rounding_mode arg =
  if is_not_rounding_mode arg then
    Unsupported.soft_rounding_mode()
<<other generic expander functions>>=
and save_stack room =
  let number_to_push = Post.stack_depth - room in
  Impossible.unimp "saving an overflowing machine stack"
and restore_stack number_to_keep number_to_restore =
  Impossible.unimp "restoring an overflowing machine stack"
@ 
<<cases for converting pushes>>=
| RP.App ((("sx"|"zx"), [n; w]) as op,
          [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n')]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    assert (agg =*= Post.byte_order);
    let a, is = address room addr in
    is @@ to_segment (Post.push_cvt op n a (upassn assn))
| RP.App ((("f2f"|"f2i"|"i2f"), [n; w]) as op,
          [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n'); roundingmode]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    assert (agg =*= Post.byte_order);
    let a, is = address room addr in
    is @@ to_segment (Post.push_cvt op n a (upassn assn))
@ 
\subsection{Expanding RTLs}

This part of the generic expander is currently simpler than it really
needs to be.
The main simplification is it doesn't deal with multiple effects.
In particular, it can't expand a call or a cut to node.
This flaw should be corrected soon.

In the longer term,
it would be good to do something more general with multiple assignments and with
guards. {For example, if a guard uses a non-comparison, Boolean
operator, it would be a fine thing to compile it to control flow.}
@
The expander is divided into three layers:
\begin{itemize}
\item
Function [[rtl]] expands a general RTL.
This function will need future work as noted above.
\item
Function [[guarded]] expands a single guarded effect.
Except for conditional branch, it currently handles only trivial
guards.
Because a nontrivial guard may appear only on a conditional branch,
this expander can't handle predicated instructions.
\item
Function [[assign]] expands an assignment with no guard.
\end{itemize}
@
Because there's no support for multiple assignment yet, the [[rtl']]
function is trivial.
Note that if the source code asks for a bare kill, even conditional,
we're within our rights to implement it as a nop.
<<other generic expander functions>>=
and rtl' hr =
  let RP.Rtl gs = Down.rtl hr in
  if trivially Post.don't_touch_me gs then
    nunit hr
  else
    match gs with
    | [(g, RP.Store (left, right, w))] -> guarded g left right w
    | [(g, RP.Kill _)] -> nunit (R.par [])
    | [] -> nunit hr (* a nop is a nop is a nop *)
    | ((_::_::_) as effs) -> (<<handle RTL with multiple effects [[effs]]>>)
@ 
The type system tells us that anything in a guard must be a Boolean
operator or a comparison operator.\footnote
{Finally we get a payoff from NR's obsession with the distinction
between [[bool]] and \mbox{[[#1 bits]]}.}
Conditional branches should never be called by this function; we handle branches in
the [[branch]] function.
<<other generic expander functions>>=
and guarded g left right w =
  match g with
  | RP.Const (RP.Bool b) -> if b then assign left right w else emptyseg
  | RP.Const _ -> Impossible.impossible "non-bool constant as guard"
  | RP.Fetch _ -> Impossible.impossible "fetch as guard"
  | RP.App (cmp, [_; _]) ->
      Printf.eprintf "guarded: %s\n" (Rtlutil.ToString.exp (Up.exp g));
      Impossible.unimp "guard on other than conditional branch"
  | RP.App (cmp, _) ->
      Impossible.unimp "non-binary comparison in guard"
@ POSSIBLY  REFERENCES TO [[pc_lhs]] SHOULD BE REPLACED BY USING
[[Target.goto.project]] AND FRIENDS.  IN GENERAL, WE NEED TO SEE
ABOUT MERGING SIMILAR INFORMATION IN THE [[Target]] AND
[[Postexpander.S]] INTERFACES.
@
To compile a Boolean, we require that
a guarded effect with a nontrivial guard always be expanded into
a sequence that ends in a conditional branch.
To compile a comparison, we rely on the postexpander.
<<other generic expander functions>>=
and expand_cbranch_rtl g left right w ktrue kfalse =
  assert (G.kind ktrue  =*= G.Join);
  assert (G.kind kfalse =*= G.Join);
  let room = Post.stack_depth in
  let rewrite_bc bc ktrue kfalse =
    let new_cb = G.cbranch cfg (R.bool true) ktrue kfalse in
    ( G.update_instr (fun _ -> inst bc) new_cb
    ; G.set_tsucc new_cb ktrue
    ; G.set_fsucc new_cb kfalse
    ; if Pervasives.(<>) (G.kind (G.pred bc)) G.Illegal then
        G.set_succ (G.pred bc) new_cb
    ; new_cb
    ) in
  match g with
  | RP.Const (RP.Bool b) -> if b then ktrue else kfalse
  | RP.Const _ -> Impossible.impossible "non-bool constant as conditional guard"
  | RP.Fetch _ -> Impossible.impossible "fetch as conditional guard"
  | RP.App (("not", []), [g]) ->
    expand_cbranch_rtl g left right w kfalse ktrue
  | RP.App (("conjoin", []), [x;y]) ->
    let true_case = expand_cbranch_rtl y left right w ktrue kfalse in
    let ktrue'    = G.node_labeled cfg (Idgen.label "conj_true") in
    G.set_succ ktrue' true_case;
    expand_cbranch_rtl x left right w ktrue' kfalse 
  | RP.App (("disjoin", []), [x;y]) ->
    let false_case = expand_cbranch_rtl y left right w ktrue kfalse in
    let kfalse'    = G.node_labeled cfg (Idgen.label "conj_false") in
    G.set_succ kfalse' false_case;
    expand_cbranch_rtl x left right w ktrue kfalse'
  | RP.App (cmp, ([x; y] as args)) when RU.Eq.loc left pc_lhs ->
      begin
        match Post.opclass cmp with
        | PX.Register ->
            let context = cmp_context cmp in
            let xt, xis = to_temp room context x in
            let yt, yis = to_temp room context y in
            (match right with
            | RP.Const c ->
              let (si, sf) = xis @@ yis @@ to_segment (Post.bc xt cmp yt c) in
              let new_cb = rewrite_bc sf ktrue kfalse in
              if G.eq si sf then new_cb else si
            | _ -> Impossible.unimp "conditional branch to computed location")
        | PX.Stack(dir, depth) ->
            let args = List.filter is_not_rounding_mode args in (* cheat!!! *)
            let args =
              match dir with PX.LeftFirst -> args | PX.RightFirst -> List.rev args in
            let push_args room =
              let (is, _) =
                List.fold_left (fun (is,r) e -> (is @@ to_stack r e, r-1))
                (emptyseg,room) args in
              is in
            let compute room tsym ktrue kfalse =
              match tsym with
              | RP.Const c ->
                let (si, sf) = push_args room @@ to_segment (Post.bc_stack cmp c) in
                let new_cb   = rewrite_bc sf ktrue kfalse in
                if G.eq si sf then new_cb else si
              | _ -> Impossible.unimp "conditional branch to computed location" in
            if room >= depth then
              compute room right ktrue kfalse
            else
              (* PLAUSIBLE BUT COMPLETELY UNTESTED. *)
              let tlabel = Idgen.label "fstack_true" in
              let tsym   = Down.exp (Rtl.codesym (proc.Proc.mk_symbol tlabel)
                                                 (RU.Width.loc (Up.loc pc_lhs))) in
              let tjoin   = G.node_labeled cfg tlabel in
              let (rti, rtf) = restore_stack 0 room in (* true  case *)
              let ()         = G.set_succ tjoin ~succ:rti in
              let jmp_tcase  = G.branch cfg ktrue in
              let ()         = G.set_succ rtf ~succ:jmp_tcase in

              let flabel  = Idgen.label "fstack_false" in
              let fjoin   = G.node_labeled cfg flabel in
              let (rfi, rff) = restore_stack 0 room in (* false case *)
              let ()         = G.set_succ fjoin ~succ:rfi in
              let jmp_fcase  = G.branch cfg kfalse in
              let ()         = G.set_succ rff ~succ:jmp_fcase in
              
              let (ssi, ssf) = save_stack room in
              ( G.set_succ ssf (compute Post.stack_depth tsym tjoin fjoin)
              ; ssi
              )
      end
  | RP.App (cmp, [_; _]) ->
      Impossible.unimp "guard on other than conditional branch"
  | RP.App (cmp, _) ->
     Printf.eprintf "rtl exp: %s\n" (Rtlutil.ToString.exp (Up.exp g));
      Impossible.unimp "non-binary comparison in conditional guard"
and expand_cbranch' rtl ktrue kfalse =
  match Down.rtl rtl with
  | RP.Rtl [(g, RP.Store (left, right, w))] ->
    expand_cbranch_rtl g left right w ktrue kfalse
  | _ -> Impossible.impossible "unguarded conditional branch"
@
An assignment is either a goto, a store, or a computation where we put
something in a temporary.
<<other generic expander functions>>=
and assign left right w = assign_room Post.stack_depth left right w
and assign_room room left right w = 
  match right with
  | RP.App (("f2f_implicit_round", ws), [x]) ->
      assign left (RP.App (("f2f", ws), [x; RP.Fetch(rounding_mode, 2)])) w
  | _ ->
      if RU.Eq.loc left pc_lhs then  (* unconditional branch *)
        match right with
        | RP.Const c -> to_segment (Post.b c)
        | _ ->
            let r, is = to_temp room acontext right in
            is @@ to_segment (Post.br r)
      else if Post.is_stack_top_proxy left then
        to_stack room right
      else
        match left with
        | RP.Mem (('m',agg,memsize) as mspace, c, addr, assn) ->  (* a store *)
            let w = Cell.to_width memsize c in
            assert (agg =*= Post.byte_order || agg =*= Rtl.Identity);
            <<definition of [[split_assignment]]>>
            let a, is' = address room addr in
            (match right with
            | <<\emph{pattern [[->]] action} for low-bit store>>
            | <<\emph{pattern [[->]] action} for splittable assignment>>
            | _ ->
                if looks_like_stack_rhs right then
                  (match right with
                  | <<\emph{pattern [[->]] action} for converting store-pop>>
                  | _ -> 
                      let is = to_stack room right in
                      is @@ is' @@ to_segment (Post.store_pop a (upassn assn)))
                else
                  match right with
                  | RP.Fetch (RP.Mem(('m', _, _), ct, addr', assn'), w) ->
                      let a', is = address room addr' in
                      is @@ is' @@
                      to_segment (Post.block_copy a (upassn assn) a' (upassn assn') w)
                  | _ ->
                      let r, is = to_temp room (guess_context right) right in
                      is @@ is' @@ to_segment (Post.store a r (upassn assn)))
        | RP.Mem (_, _, _, _) ->
            Impossible.unimp "memory space other than 'm'"
        | RP.Reg dst -> (* computation *)
            (match right with
            | RP.Fetch (RP.Reg src, _) -> to_segment (Post.move ~dst ~src)
            | _ -> let r, is = to_temp room (guess_context right) right in
                   is @@ to_segment (Post.move ~dst ~src:r)
            )
        | RP.Slice (_,_,_) -> Impossible.unimp "slice"
        | RP.Var (_,_,_) | RP.Global(_,_,_) ->
            Impossible.impossible "variable passed to code expander"
<<\emph{pattern [[->]] action} for low-bit store>>=
RP.App (("lobits", [w; n]), [rhs]) ->
  let r, is = to_temp room icontext rhs in
  is @@ is' @@ to_segment (Post.lostore a r n (upassn assn))
| RP.Const (RP.Bits b) when w < Post.itempwidth ->
  let rhs = RP.Const (RP.Bits (Bits.Ops.zx Post.itempwidth b)) in
  let r, is = to_temp room icontext rhs in
  is @@ is' @@ to_segment (Post.lostore a r w (upassn assn))
<<\emph{pattern [[->]] action} for converting store-pop>>=
RP.App ((("sx" | "zx"), [wsrc; wdst]) as op, [rhs]) ->
  (* what goes wrong if wsrc is not the width of the stack? *)
  let is = to_stack room rhs in
  is @@ is' @@ to_segment (Post.store_pop_cvt op wdst a (upassn assn))
| RP.App ((("f2f" | "f2i" | "i2f"), [wsrc; wdst]) as op, [rhs; roundingmode]) ->
  (* what goes wrong if wsrc is not the width of the stack? *)
  let is = to_stack room rhs in
  is @@ is' @@ to_segment (Post.store_pop_cvt op wdst a (upassn assn))
@ 
A~splittable right-hand side looks like this: 
\begin{quote}
[[%or[64](%zx[32,64]($r0), %shl[64](%zx[32,64]($r2), 32))]]
\end{quote}
I FEAR I MAY BE BOTCHING THE ASSERTION IN THE STORE, ESPECIALLY WHERE
ALIGNMENT IS CONCERNED.
<<\emph{pattern [[->]] action} for splittable assignment>>=
( RP.App (("or", [ww]), [RP.App (("zx", [nn;ww']), [lsw]);
                          RP.App (("shl", [ww'']),
                                  [RP.App (("zx", [dd;ww''']), [msw]);
                                   RP.Const (RP.Bits nnb)])])
| RP.App (("or", [ww]), [RP.App (("shl", [ww'']),
                                  [RP.App (("zx", [dd;ww''']), [msw]);
                                   RP.Const (RP.Bits nnb)]);
                          RP.App (("zx", [nn;ww']), [lsw])])
) when w > Post.itempwidth && Pervasives.(<>) agg Rtl.Identity && ww = ww' && ww = ww''
    && ww = ww''' && dd = ww - nn && BO.eq nnb (Bits.U.of_int nn ww) ->
      split_assignment ~lsw ~lw:nn ~msw ~mw:dd
| RP.Const (RP.Bits b) when w > Post.itempwidth ->
  let lw = Post.itempwidth in
  let mw = w - lw in
  let lsw = RP.Const (RP.Bits (BO.lobits lw b)) in
  let msw = RP.Const (RP.Bits (BO.lobits mw (BO.shrl b (Bits.U.of_int lw w)))) in
  split_assignment ~lsw ~lw ~msw ~mw
@ 
We split an assignment into a least significant word [[lsw]] of
width~[[lw]] and a most significant word [[msw]] of width~[[mw]].
<<definition of [[split_assignment]]>>=
let split_assignment ~lsw ~lw ~msw ~mw =
  let lc, mc = Cell.to_count memsize lw, Cell.to_count memsize mw in
  assert (Cell.divides memsize lw && w = lw + mw);
  let addr = Up.exp addr in
  let assn = Up.assertion assn in
  let lsw, msw = Up.exp lsw, Up.exp msw in
  let offset (R.C n) = RU.addk proc.Proc.target.T.pointersize addr n in
  match agg with
  | Rtl.LittleEndian ->
      rtl (R.par [R.store (R.mem assn mspace lc addr) lsw lw;
                  R.store (R.mem assn mspace mc (offset lc)) msw mw])
  | Rtl.BigEndian ->                           
      rtl (R.par [R.store (R.mem assn mspace mc addr) msw mw;
                  R.store (R.mem assn mspace lc (offset mc)) lsw lw])
  | Rtl.Identity ->
      Impossible.impossible "bad aggregation in split assignment" in
@ 
<<other generic expander functions>>=
and fetch_slot slot w = Down.exp (A.fetch slot w)
and assign_slot room slot right w =
  match Down.rtl (A.store slot (Up.exp right) w) with
  | RP.Rtl [(RP.Const (RP.Bool true), RP.Store (left, right, w))] ->
      assign_room room left right w
  | _ -> Impossible.impossible "stack slot is not a simple store"
@ 
Something with multiple effects is either a call, a [[cut to]], or a
shuffle.
In all three cases, the guard had better be trivial.
<<handle RTL with multiple effects [[effs]]>>=
let has_pc_on_left = function
  | RP.Store (pc, _, _) -> RU.Eq.loc pc pc_lhs
  | RP.Kill _ -> false in
let has_pc_on_right = function
  | RP.Store (_, e, _) -> RU.Exists.Loc.exp (RU.Eq.loc pc_rhs) e
  | RP.Kill _ -> false in
<<support for call, [[cut to]], and shuffle>>
let effs = strip_trivial_guards effs in
if Post.don't_touch_me effs then
  nunit (R.par (List.map Up.effect effs))
else
  if List.exists has_pc_on_left effs then
    if List.exists has_pc_on_right effs then
      make_call effs
    else
      make_cut_to effs
  else
    make_shuffle effs
@ 
When we know guards should be trivial, we just strip them off.
When we don't know, we use the [[trivial]] function, which if guards
are trivial applies a predicate and if not returns [[false]].
\nwaddbox{trivially : (RP.effect list -> bool) -> RP.guarded list -> bool}
<<functions for dealing with trivial guards>>=
let strip_trivial_guards l =
  List.fold_right
    (fun (g, e) l ->
      match g with RP.Const (RP.Bool b) -> if b then e :: l else l
      | _ -> Impossible.unimp "multiple effects with a nontrivial guard") l [] in
let trivially p l =
  let rec t es' = function
    | [] -> p (List.rev es')
    | (g, e) :: ges ->
        match g with RP.Const (RP.Bool b) -> t (if b then e :: es' else es') ges
        | _ -> false in
  t [] l in
@ 
<<support for call, [[cut to]], and shuffle>>=
let (<<) f g x = f (g x) in
let make_call effs = 
  let others = List.filter (not << has_pc_on_left) effs in
  match List.filter has_pc_on_left effs with
  | [RP.Store(pc, RP.Const c, _)] -> to_segment (Post.call c others)
  | [RP.Store(pc, e, _)] ->
      let t, is = to_temp Post.stack_depth acontext e in
      let is_type = (is : R.rtl G.node * R.rtl G.node) in
      is @@ to_segment (Post.callr t others)
  | _ -> Impossible.impossible "multiple pc := e in call" in
@ 
<<support for call, [[cut to]], and shuffle>>=
let make_cut_to effs =
  let expand e (preds, effs) = match e with
    | RP.Store (l, r, w) ->
        let t, is = to_temp Post.stack_depth (guess_context r) r in
        (preds @@ is, RP.Store(l, RP.Fetch(RP.Reg t, w), w) :: effs)
    | RP.Kill l -> (preds, RP.Kill l :: effs) in
  let preds, effs = List.fold_right expand effs (emptyseg, []) in
  preds @@ to_segment (Post.cut_to effs) in
@ 
Shuffle would be cooler if we carefully arranged to make things
push-like, but never mind.
As it is, we look for an effect that can go first (because its
left-hand side doesn't alias with any other right-hand-side), and if
we don't find one, we introduce a new temporary.
<<support for call, [[cut to]], and shuffle>>=
let make_shuffle effs =
  let strip_store = function
    | RP.Store (l, r, w) -> (l, r, w)
    | RP.Kill _ -> Impossible.impossible "kill in shuffle" in
  let rec shuffle =
    let assign = noisy_assign in
    function
    | [(l, r, w)] -> assign l r w
    | [] -> emptyseg
    | ((l, (r:RP.exp), w) :: rest) as effs ->
        <<definition of [[try_first_effect]]>>
        try_first_effect effs
          (fun (l, r, w) rest -> assign l r w @@ shuffle rest)
          (fun () ->
            let t = alloc (guess_context r) w in
            (assign (RP.Reg t) r w @@
             shuffle rest @@
             assign l (RP.Fetch (RP.Reg t, w)) w))
  in shuffle (List.map strip_store effs) in
<<definition of [[try_first_effect]]>>=
let try_first_effect effects succ fail =
  let rec maybe bad = function
    | [] -> fail()
    | (l, r, w) :: rest ->
        let alias (_, r, _) = RU.MayAlias.exp' l r in
        if not (List.exists alias bad || List.exists alias rest) then
          succ (l, r, w) (List.rev_append bad rest)
        else
          maybe ((l, r, w) :: bad) rest in
  maybe [] effects in
@ 
\subsection{Debugging the expander}
These wrapper functions show what the expander [[rtl]] and register
targeter [[to_temp]] are doing.
<<other generic expander functions>>=
and rtl r =
  let _ = D.strings ["Expanding "; D.rtl r; "\n"] in
  let is = rtl' r in
  let _ = D.strings ["Expanded "; D.rtl r; " into\n"]; D.pr_is is in
  is
and expand_cbranch r ktrue kfalse =
  let _ = D.strings ["Expanding conditional branch "; D.rtl r; "\n"] in
  let is = expand_cbranch' r ktrue kfalse in
  let _ =
    D.strings ["Expanded conditional branch "; D.rtl r; " into a mystery node\n"] in
  is
and noisy_assign l r w =
  let is = assign l r w in
  let r = R.store (Up.loc l) (Up.exp r) w in
  let _ = D.strings ["Shuffling "; D.rtl r; " into\n"]; D.pr_is is in
  is
and to_temp room context e =
  let _ = D.strings ["Targeting "; D.exp e; "...\n"] in
  let t, is = to_temp' room context e in
  let _ = D.strings ["Targeted "; D.exp e; " => "; D.temp t; " by \n"] in
  let _ = D.pr_is is in
  t, is
and to_stack room e =
  let _ = D.strings ["Pushing "; D.exp e; "...\n"] in
  let is = to_stack' room e in
  let _ = D.strings ["Pushed "; D.exp e; " by \n"] in
  let _ = D.pr_is is in
  is
@ 
\subsection{Stack-slot allocation}
To move from a temporary to the stack, we may need to allocate a stack slot.
<<stack-slot allocation>>=
let exchange_slot =
  let slots = ref [] in
  function w ->
    try List.assoc w (!slots)
    with Not_found ->
      let slot = A.allocate proc.Proc.priv w "" in
      slots := (w, slot) :: !slots;
      slot in
@   
\subsection{Old code no longer relevant}
This is old stuff left over, which I might want to resurrect some day
when I try to expand general guards.
<<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>=
let rec old_general_guard g left right w =
  (* this case is bogus *)
  let r, is  = to_temp Post.stack_depth (guess_context right) right in
  let l, is' = old_loc left in
  is @@ is' @@ nunit (R.guard (Up.exp g) (R.store l (R.fetch (temploc r) w) w))
and old_loc l =
  match l with
  | RP.Mem (('m',_,_) as mspace, w, addr, assn) ->
      let addr, is = to_temp Post.stack_depth (acontext) addr in
      Up.loc (RP.Mem (mspace, w, fetch (temploc addr), assn)), is
  | _ -> Up.loc l, emptyseg in
@
\subsection{The flow-graph expander}
<<generic flow-graph expander>>=
let cfg _ ({Proc.cfg = cfg} as proc) =
  if proc.Proc.target.Target.memsize <> 8 then
    Impossible.unimp "may-alias detection for memsize <> 8";
  let modified = ref false in
  let expand_cbranch, expand_rtl = expand proc in
  let expand_node n =
    match G.to_instr n with
    | None -> ()
    | Some i ->
        match G.kind n with G.Assertion | G.StackAdjust | G.Join | G.Exit -> ()
        | G.Cbranch ->
          let pred = G.pred    n   in
          let ill  = G.illegal cfg in
          let pred_set_succ n =
            if Pervasives.(<>) (G.kind pred) G.Illegal then G.set_succ pred n in
          ( pred_set_succ ill
          ; G.delete    cfg n
          ; pred_set_succ (expand_cbranch i (G.tsucc n) (G.fsucc n))
          ; modified := true
          )
        | _ -> modified := replace_node n (expand_rtl i) in

  G.iter_nodes expand_node proc.Proc.cfg;
  !modified
@

\subsection{Compilation of Boolean expressions into control flow.}

THIS CODE SHOULD BE MOVED TO THE GENERIC CODE EXPANDER.

An if-statement is governed by a boolean expression that has no side
effects. A simple translation is to use this expression as a guard for a
conditional branch to implement the if-statement. The guard finally
becomes a guard in the {\rtl} that implements the conditional branch.
The problem is, that the guarding expression can be quite complex and
must be simplified before a machine instruction can be found that
implements it. We translate a boolean expression $e$ into a sequence of
nodes. If $e$ evaluates to true, the control flow reaches the end of the
sequence, otherwise it branches to a provided label. 


\begingroup % keeps definitions local
\def\C#1{{\cal C}[\![#1]\!]}
\let\i\textit

The translation is summarized by the following function $\C{\cdot}~f$
that takes a boolean expression $e$ and a continuation $f$ to branch if
the expression evaluates to false. The result is a sequence of nodes,
that branches to $f$ if $e$ is false, and falls through otherwise.

\begin{center}
\begin{eqnarray*}
    \C{\i{true}}~f              & \to & \i{nop}\\
    \C{\i{false}}~f             & \to & \i{goto}~f\\
    \C{x \vee y}~f              & \to & \C x~l; l: \C y~f\\
    \C{x \wedge y}~f            & \to & \C x~f; \C y~f\\
    \C{\lnot x}~f               & \to & \C x~l; \i{goto}~f; l:\\
    \C{\oplus(e_1, \dots, e_n)} & \to & 
        \i{if}(\lnot \oplus(e_1, \dots, e_n)\{\i{goto}~f\}
\end{eqnarray*}
\end{center}

The last line covers the case of an application with a boolean result
but non-boolean arguments. Currently only the logical operators $\lnot$,
$\vee$, and $\wedge$ \emph{take} boolean arguments.

The implementation first translates the governing expression into an
{\rtl} and then tranlate it into the sequence of nodes.

\begin{quote}\it
    I think the code below shows a design weakness: we have decided to
    have explicit label nodes in the {\cfg}. In order to jump or branch
    to a node one needs the symbol associated with the label. This,
    however, cannot be observed. This means, labels can only be used
    where they are constructed. In the implementation of the {\cfg}
    labels could be made a sub-class of nodes. However, since we shield
    the object-oriented nature of nodes behind standard types, this is
    not easily possible. Nodes must be more abstract or labels must
    become special.  --CL
\end{quote}

\endgroup

<<old Make statements>>=
and guard state succ fail e = 
    let rec guard' succ fail = function

    | RP.Const(RP.Bool(true))         -> succ
    | RP.Const(RP.Bool(false))        -> fail
    | RP.Const(_)                     -> assert false
    | RP.Fetch(_)                     -> assert false
    <<special cases that match floating-point comparisons>>
    | RP.App(("conjoin",_), [x;y])    -> 
        let ll    = Idgen.label state.proc    in
        let ls    = F.symbol env ll     in
        let fail  = G.gm_label state.cfg ll ls fail in
            let tail = guard' succ fail y in
            let head = guard' tail fail x in
                head
    | RP.App(("not",_), [x])          -> guard' fail succ x
    | RP.App(("disjoin",_), [x;y])    ->
        let ll    = Idgen.label state.proc    in
        let ls    = F.symbol env ll     in
        let succ  = G.gm_label state.cfg ll ls succ in
        let y     = guard' succ fail y    in
        let lexp  = Rtl.codesym ls state.target.T.pointersize in
        let lrtl  = state.target.T.goto.T.embed lexp in
        let succ  = G.gm_goto state.cfg lrtl [G.lookup state.cfg ll] in
                guard' succ y x              
    | RP.App(opr, args) as e -> 
        let sl    = Idgen.label state.proc    in
        let ss    = F.symbol env sl     in
        let succ  = G.gm_label state.cfg sl ss succ in
        
        let fl    = Idgen.label state.proc    in
        let fs    = F.symbol env fl     in
        let fail  = G.gm_label state.cfg fl fs fail in
        
        let oexp  = Rtl.codesym fs state.target.T.pointersize in
        let ortl  = state.target.T.goto.T.embed oexp in
        let fail  = G.gm_goto state.cfg ortl [G.lookup state.cfg fl] in
        
        let e     = R.Revert.exp e in
        let link  = Rtl.codesym ss state.target.T.pointersize in
        let rtl   = state.target.T.branch.T.embed (e,link)  in
            G.gm_branch state.cfg rtl succ fail 
    in
        { state with node = guard' succ fail e }
        
@
<<special cases that match floating-point comparisons>>=
(* the evil empire *)
@
