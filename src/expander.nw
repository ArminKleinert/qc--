% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

%%Grades: C Subsystem Soon

\section{A generic, parameterized code expander}

A back end is obligated to expand code to RTLs.
To make retargeting easier, we provide here a generic code expander
that reduces the machine-dependent obligation.
If the machine can move date, operate on temporary registers, and
provide a few simple control-flow operations, this module does the
rest.
In other words, this module expands an RTL into a sequence of much
simpler RTLs.
The target-dependent code is relegated to a \emph{postexpander}.

To explain what is happening, I use the following
conventions:\\
\begin{tabular}{@{\quad}ll}
$t$& any temporary or register-like space\\
$m$& any memory-like space\\
$k$& any constant\\
$\oplus$& any RTL operator\\
\end{tabular}

We reduce RTLs to the following forms:
(THIS TABLE SHOULD BE CHECKED FOR CONSISTENCY WITH THE OTHER STUFF)
{\def\gets{\mathrel{:=}}%
$$\begin{array}{rcl@{\mskip10mu}l}
m[t_l] & \gets & t     &\mbox{store}\\
t      & \gets & m[t_l]&\mbox{load} \\
t_1    & \gets & t_2   &\mbox{move} \\
t      & \gets & k     &\mbox{constant}\\
t      & \gets & \oplus(t_1, \ldots, t_n) & \mbox{ALU}\\
m[t_l] & \gets & \mathtt{lobits}_n(t)     &\mbox{store byte/halfword}\\
t      & \gets & \mathtt{sx}(m[t_l])       &\mbox{load signed b/h} \\
t      & \gets & \mathtt{zx}(m[t_l])       &\mbox{load unsigned b/h} \\
t \mathbin? t \rightarrow \mathit{PC}& \gets & L &\mbox{conditional branch}\\
\end{array}
$$}
@
Driving the design is the following classification of operators:
\begin{itemize}
\item
A \emph{standard value operator} takes some bit vectors of reasonable
width and returns a result of that width.
\item
A \emph{weird value operator} takes some bit vectors of reasonable
width and returns a result of some other width.
The obvious weird operators are multiply (which doubles with width of
its operands) and multiprecision operators such as carry and borrow.
\item
A \emph{size-changing operator} widens or narrows a bit vector.
I~believe there are only three such operators: [[sx]], [[zx]], and
[[lobits]].
\item
A \emph{comparison operator} takes one or more bit vectors and returns
a Boolean.
This category includes not only the usual integer and floating
comparisons but some machine-dependent condition-code testers and the
elusive [[bool]] operator.
\item
A \emph{Boolean operator} takes one or more Booleans and returns a
Boolean.
The only Boolean operators are [[conj]], [[disj]], and [[not]], and
I'm inclined to think they should be compiled to control flow.
\item
The elusive [[bit]] operator is the only operator to take a Boolean
and return a bit vector.
It's not supported here, but it could possibly be compiled to control
flow.
N.B.~Machines such as MIPS support [[bit]] by instructions such as SLT
(set less than), so it probably should not be compiled away by the
front end (sadly).
\end{itemize}
@
\begin{quote}\em
Aside:
I'm contemplating how we might create a hand-written expander that can
easily be specialized to establish ``most of'' the machine invariant
for many different targets, without relying so heavily on peephole
optimization \emph{post facto}.
For example, it's legitimate to think of $\mathtt{\$m}[\cdot]$ as an
``address context.''
Any machine should be able to deal with $t$~in an address context, but
many machines will also be able to deal with $t+t$ and $t+k$ (though
on some machines $k$~may not be too large).
Some machines can even deal with $t+4\times t$!
One possibility, then, would be to make an ``address context''
function dynamic through Lua.
Care would have to be taken to avoid paying for an expensive identity
function (embedding/projection) at every application of such a function.
\end{quote}
@
\subsection{The target-dependent postexpander}
Here is a tentative signature for a postpass for an integer/float
machine.
These are the operations every target must implement.
<<postexpander.mli>>=
<<postexpander>>
<<postexpander.ml>>=
<<postexpander>>
<<postexpander>>=
module type S = sig
  val byte_order : Rtl.aggregation (* used on all access to memory *)
  val wordsize   : int             (* used as width of register number! *)

  type temp = Register.t
  type rtl = Rtl.rtl
  type width = Rtl.width
  type assertion = Rtl.assertion
  type operator = Rtl.Private.opr

  <<generic expansion operations>>
end
@ 
We provide basic load and store.
<<generic expansion operations>>=
module Address : sig
  type t
  val reg : temp -> t
end

val load  : dst:temp  -> addr:Address.t -> assertion -> rtl list
val store : addr:Address.t -> src:temp -> assertion -> rtl list
@
We also provide sign-extending and zero extending loads
as well as low-bit--extracting stores, all of which are used only
with integer registers.
This is the only place the back end is required to support
size-changing operators; other uses, such as compositions of widens
and narrows, should be compiled to suitable code (shifts or identity)
somewhere upstream.
<<generic expansion operations>>=
val sxload  : dst:temp  -> addr:Address.t -> width -> assertion -> rtl list
val zxload  : dst:temp  -> addr:Address.t -> width -> assertion -> rtl list
val lostore : addr:Address.t  -> src:temp -> width -> assertion -> rtl list
@
We need a move operation.
<<generic expansion operations>>=
val move : dst:temp -> src:temp -> rtl list
@ 
Load immediate can take any constant except a Boolean.
<<generic expansion operations>>=
val li : dst:temp -> Rtl.Private.const -> rtl list
@ 
We provide simple shortcuts for binary and unary operators.
I don't know if the shortcuts are worthwhile.
N.B.~no operator passed to any of these functions expects or returns a
Boolean! 
Ordinary value operators are expected to be supported by these
operations, but only at their natural widths.
Perhaps the weird value operators should be supported also.
<<generic expansion operations>>=
val binop : dst:temp -> operator -> temp -> temp -> rtl list
val unop  : dst:temp -> operator -> temp         -> rtl list
val rtlop : dst:temp -> operator -> temp list    -> rtl list
@
The arguments to the functions above must satisfy the invariants that the
temporaries are in the spaces the expander expects.
It announces these spaces through argument and result contexts.
The context names a temporary space from which to draw temporaries and
it also says when a temporary satisfies that context.
<<generic expansion operations>>=
type context = Rtl.space * (Register.t -> bool)
val icontext : context (* for ints *)
val fcontext : context (* for floats *)
val acontext : context (* for addresses *)
val arg_contexts   : operator -> context list
val result_context : operator -> context
@ 
To recognize control flow, the expander must be able to identify the
program counter.
We could provide an abstract test of type [[Rtl.loc -> bool]],
but until we need the extra generality, we avoid it.
On the other hand, we \emph{do} need a different representation of the
program counter on the left and the right of an assignment, in order
to handle the SPARC \emph{PC}/\emph{nPC} duo.
<<generic expansion operations>>=
val pc_lhs : Rtl.loc                    (* program counter as assigned by branch *)
val pc_rhs : Rtl.loc                    (* program counter as captured by call *)
@ 
To create control flow, the postexpander must provide an RTL that
includes an assignment to [[pc_lhs]].
This RTL must be the last in the execution sequence (and therefore the
head of the list that is returned.
We can branch to a temporary drawn from [[acontext]] or to a constant. 
<<generic expansion operations>>=
val br : tgt:temp -> rtl list               (* branch register *)
val b  : tgt:Rtl.Private.const -> rtl list  (* branch *)
@ 
For a conditional branch,  the target must be a static label, but the
postexpander provides any Boolean condition 
applied to temporaries.
Furthermore, it must be the case that the final, actual branch
instruction can have its sense reversed with [[bnegate]], and the
result is still representable by a single instruction on the target
machine.
<<generic expansion operations>>=
val bc      : temp -> operator -> temp -> tgt:Rtl.Private.const -> rtl list
val bnegate : rtl -> rtl  (* swap the condition in a conditional branch *)
@ The last (head) instruction from [[bc]] is the \emph{only}
instruction that may legitimately be passed to [[bnegate]].
@

\subsection{Onward to an implementation}

The [[Proc.t]] gives the expander a supply of temporaries.
<<expander.mli>>=
module type S = sig
  val expand : Proc.t -> Rtl.rtl -> Rtl.rtl list
  val cfg    : 'a -> Proc.t -> bool
end 
module IntFloatAddr (Post : Postexpander.S) : S
@ 
Here are some abbreviations and utilities.
<<expander.ml>>=
module type S = sig
  val expand : Proc.t -> Rtl.rtl -> Rtl.rtl list
  val cfg    : 'a -> Proc.t -> bool
end 

module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target2

module Up = Rtl.Revert
module Down = Rtl.Convert

let upassn = Rtl.Revert.assertion

let fetch l = RP.Fetch (Down.loc l, RU.Width.loc l)
let width e = RU.Width.exp (Up.exp e)
@ 
To avoid quadratric list append, I use John Hughes's
continuation-passing list representation.
<<expander.ml>>=
let empty = fun l -> l
let unit x = fun l -> x :: l
let (@::) x f = fun l -> x :: f l
let (@@) f1 f2 = fun l -> f1 (f2 l)
let to_hughes l = fun l' -> l @ l'
let rec concat = function
  | [] -> empty
  | [x] -> x  (* premature optimization is the root of all evil *)
  | [x; y] -> x @@ y  (* premature optimization is the root of all evil *)
  | [x; y; z] -> x @@ y @@ z (* premature optimization is the root of all evil *)
  | h::t -> h @@ concat t
@ 
% ----------------------------------------------------------------
\subsection{A generic expander}
% ----------------------------------------------------------------

<<expander.ml>>=
module IntFloatAddr (Post : Postexpander.S) = struct
  <<generic expander>>
  <<generic flow-graph expander>>
end
@ 
The core of the expander is a function [[to_temp]], which takes an
expression and returns a pair containing a list of instructions and a
temporary such that executing those instructions develops the
expression into that temporary.
To get the right temporary, we work within a context, which makes it
possible to allocate a fresh temporary and to check if an existing
temporary is OK.
Function [[temp_in_context]] inserts a move if needed.
<<generic expander>>=
let alloc (allocate, check) w = allocate w
let ok    (allocate, check) reg = check reg

let temp_in_context ((space, n, w) as t) context instructions =
  if ok context t then
    t, instructions
  else
    let t' = alloc context w in
    t', to_hughes (Post.move t' t) @@ instructions
@ 
It's questionable whether the byte order of a register should be fixed
to that of memory, but so be it.
<<generic expander>>=
let temploc (space, n, w) =
  Rtl.cell Rtl.none space Post.byte_order w
           (Rtl.bits (Bits.U.of_int n Post.wordsize) Post.wordsize)
@ 
Some debugging code is most helpful.
To activite, try \texttt{VERBOSITY=5~qc--}.
<<generic expander>>=
module D = struct (* debugging *)
    let strings = Verbose.say 5 
    let int = string_of_int 
    let exp e = Rtlutil.ToReadableString.exp (Up.exp e) 
    let rtl r = Rtlutil.ToReadableString.rtl r 
    let pr_is is = List.iter (fun r -> strings ["  "; rtl r; "\n"]) (List.rev (is []))
    let pr_rtls rs = List.iter (fun r -> strings ["  "; rtl r; "\n"]) (List.rev rs)
    let temp (s, n, w) =
      "$" ^ Char.escaped s ^ "[" ^ int n ^ "] : " ^ int w ^ " loc" 
end
@ 
Within the expander, we try to build an allocator eagerly, which means
we use a different form of context than in the postexpander.
(The postexpander can't provide an ``allocating context'' directly,
because the supply of temporaries is in the [[Proc.t]] and is not
available until we actually have a procedure in which to expand.)
<<generic expander>>=
let expand proc =
  let contextmap (space, checker) =
    (Talloc.Multiple.reg proc.Proc.temps space, checker) in
  let icontext = contextmap Post.icontext in
  let acontext = contextmap Post.acontext in
  let fcontext = contextmap Post.fcontext in
  <<context guessing>>
  let alloc_direct (space, _) = Talloc.Multiple.reg proc.Proc.temps space in
  <<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>
  in fun r -> rtl r []
@ 
Unprimed versions of functions issue debugging screeds; primed
versions do the real work.
<<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>=
let rec to_temp context e =
  let _ = D.strings ["Targeting "; D.exp e; "...\n"] in
  let t, is = to_temp' context e in
  let _ = D.strings ["Targeted "; D.exp e; " => "; D.temp t; " by \n"] in
  let _ = D.pr_is is in
  t, is
and to_temp' context e = match e with
  | RP.Const k ->
      let w = width e in
      let t = alloc context w in
      t, to_hughes (Post.li t k)
  | RP.Fetch (RP.Cell ('m', agg, w, addr, assn), w') ->
      let t = alloc context w in
      let a, is = address addr in
      assert (agg = Post.byte_order);
      assert (w = w');
      t, to_hughes (Post.load t a (upassn assn)) @@ is
  | RP.Fetch (RP.Cell (space, agg, w, RP.Const (RP.Bits b), assn), w') ->
      assert (w = w');
      temp_in_context (space, Bits.U.to_int b, w) context empty
  | RP.Fetch _ ->
      Impossible.impossible "memory-like access to non-memory space"
  <<cases for sign-extending and zero-extending loads>>
  <<cases for sign-extending and zero-extending divides>>
  | RP.App (op, args) ->
      let (temps, is) =
        List.split (List.map2 (fun c e -> to_temp (contextmap c) e)
                      (Post.arg_contexts op) args)
      in
      let w = width e in
      let t = alloc_direct (Post.result_context op) w in
      let compute = match temps with
      | [x; y] -> Post.binop t op x y  (* see note on binary operators below *)
      | [x]    -> Post.unop  t op x
      | _      -> Post.rtlop t op temps
      in
      temp_in_context t context (to_hughes compute @@ concat is)
<<other generic expander functions>>
and rtl r =
  let is = rtl' r in
  let _ = D.strings ["Expanded "; D.rtl r; " into\n"]; D.pr_is is in
  is
and rtl' r = match Down.rtl r with
| RP.Rtl [(g, RP.Store (left, right, w))] ->
    guarded g left right w
| _ -> unit r (* no expansion takes place *)
@ The note on binary operators is that eventually the generic expander
might be extended so it can deal with a two-address target machine.
The generic expander might (somehow) divine whether the operation is 
in $L \mathrel{:=} L \oplus R$ form or in $R \mathrel{:=} L \oplus R$ form,
and it should call appropriate supporting functions in the target.
On the other hand, we could just rely on peephole optimization\ldots
@
Sign-extending and zero-extending loads are done into integer registers only.
This fact is documented in the postexpander interface.
<<cases for sign-extending and zero-extending loads>>=
| RP.App (("sx", [n; w]), [RP.Fetch (RP.Cell ('m', agg, n', addr, assn), n'')]) ->
    assert (n == n' && n' == n'');
    let t = alloc icontext w in
    let a, is = address addr in
    assert (agg = Post.byte_order);
    temp_in_context t context (to_hughes (Post.sxload t a n (upassn assn)) @@ is)
| RP.App (("zx", [n; w]), [RP.Fetch (RP.Cell ('m', agg, n', addr, assn), n'')]) ->
    assert (n == n' && n' == n'');
    let t = alloc icontext w in
    let a, is = address addr in
    assert (agg = Post.byte_order);
    temp_in_context t context (to_hughes (Post.zxload t a n (upassn assn)) @@ is)
@ 
Division is going to be a real problem; I can just tell.
Here's a hack which is untested and probably useless.
<<cases for sign-extending and zero-extending divides>>=
| RP.App ((("divu"|"modu") as divmod, [w; n]), [RP.App (("zx", [n'; w']), [x]); y])
  when w = w' && n = n' ->
    let t = alloc icontext n in
    let tx, isx = to_temp icontext x in
    let ty, isy = to_temp icontext y in
    let divmod = Post.binop t ((divmod ^ "_trunc"), [n]) tx ty in
    temp_in_context t context (to_hughes (divmod) @@ isy @@ isx)
@
We might one day support multiple addressing modes, but for now, just registers. 
<<other generic expander functions>>=
and address exp =
  let t, is = to_temp acontext exp
  in  Post.Address.reg t, is
@
It would be good to do something with multiple assignments and with
guards,\footnote{For example, if a guard uses a non-comparison, Boolean
operator, it would be a fine thing to compile it to control flow.}
but for now I keep things very simple.

The type system tells us that anything in a guard must be a Boolean
operator or a comparison operator.\footnote
{Finally we get a payoff from NR's obsession with the distinction
between [[bool]] and [[#1 bits]].}
To compile a Boolean, we require that
a guarded effect with a nontrivial guard always be expanded into
a sequence that ends in a conditional branch.
To compile a comparison, we rely on the postexpander.

This expander can't handle predicated instructions; a nontrival guard
may appear on a conditional branch only.
<<other generic expander functions>>=
and guarded g left right w =
  match g with
  | RP.Const (RP.Bool b) -> if b then assign left right w else empty
  | RP.Const _ -> Impossible.impossible "non-Bool constant as guard"
  | RP.Fetch _ -> Impossible.impossible "fetch as guard"
  | RP.App (("not", []), [g]) ->
      let is = guarded g left right w in
      (match is [] with
      | h :: t -> to_hughes (Post.bnegate h :: t)
      | [] -> Impossible.impossible "empty list of instructions for cond. branch")
  | RP.App ((("conj" | "disj"), []), [g]) ->
      Impossible.unimp "conjunction or disjunction in generic code expander"
  | RP.App (cmp, [x; y]) ->
      if left = Down.loc Post.pc_lhs then
        let context = cmp_context cmp in
        let xt, xis = to_temp context x in
        let yt, yis = to_temp context y in
        match right with
        | RP.Const c -> to_hughes (Post.bc xt cmp yt c) @@ yis @@ xis
        | _ -> Impossible.unimp "conditional branch to computed location"
      else
        Impossible.unimp "guard on other than conditional branch";
  | RP.App (cmp, _) ->
      Impossible.unimp "non-binary comparison in guard"
@ 
POSSIBLY  REFERENCES TO [[Post.pc_lhs]] SHOULD BE REPLACED BY USING
[[Target2.goto.project]] AND FRIENDS.  IN GENERAL, WE NEED TO SEE
ABOUT MERGING SIMILAR INFORMATION IN THE [[Target]] AND
[[Postexpander.S]] INTERFACES.
@
An assignment is either a goto, a store, or a computation where we put
somethign in a temporary.
<<other generic expander functions>>=
and assign left right w =
  if left = Down.loc Post.pc_lhs then
    match right with
    | RP.Const c -> to_hughes (Post.b c)
    | _ ->
        let r, is = to_temp acontext right in
        to_hughes (Post.br r) @@ is
  else
    match left with
    | RP.Cell ('m', agg, w, addr, assn) ->
        assert (agg = Post.byte_order || agg = Rtl.Identity);
        let a, is' = address addr in
        (match right with
        | <<\emph{pattern [[->]] action} for low-bit store>>
        | _ ->
            let r, is = to_temp (guess_context right) right in
            to_hughes (Post.store a r (upassn assn)) @@ is' @@ is)
    | RP.Cell (space, agg, w, RP.Const (RP.Bits b), assn) ->
        let r, is = to_temp (guess_context right) right in
        to_hughes (Post.move ~dst:(space, (Bits.U.to_int b), w) ~src:r) @@ is
    | _ ->
        Impossible.impossible "memory-like access to non-memory space"
<<\emph{pattern [[->]] action} for low-bit store>>=
RP.App (("lobits", [w; n]), [rhs]) ->
  let r, is = to_temp icontext rhs in
  to_hughes (Post.lostore a r n (upassn assn)) @@ is' @@ is
@ 
This function is based on the dreadful hack that every floating-point
comparison begins with [[f]] and no other comparison does.
<<context guessing>>=
let cmp_context (oprname, ws) =
  if oprname.[0] = 'f' then fcontext else icontext in
@   
This is old stuff left over.
<<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>=
in let rec old_general_guard g left right w =
  (* this case is bogus *)
  let r, is  = to_temp (guess_context right) right in
  let l, is' = old_loc left in
  R.guard (Up.exp g) (R.store l (R.fetch (temploc r) w) w) @:: is @@ is'
and old_loc l =
  match l with
  | RP.Cell ('m', agg, w, addr, assn) ->
      let addr, is = to_temp (acontext) addr in
      Up.loc (RP.Cell ('m', agg, w, fetch (temploc addr), assn)), is
  | _ -> Up.loc l, empty
@

We guess a context based on right-hand side.
<<context guessing>>=
let guess_context = function
  | RP.Const k -> icontext
  | RP.Fetch (RP.Cell (space, agg, w, RP.Const (RP.Bits b), assn), w') when
      (space = 'f' || space = 'u') -> fcontext
  | RP.Fetch _ -> icontext
  | RP.App (op, args) -> contextmap (Post.result_context op) in
@ 
Here we expand every RTL in a flow graph.
<<generic flow-graph expander>>=
module G  = Cfg4
module GU = Cfgutil
let cfg _ proc =
  let g = proc.Proc.cfg in
  let t = proc.Proc.target in
  let _ = G.gm_enumerate g in
  let nodes = GU.fold_bwd g (fun x y -> x::y) [] in
  let modified = ref false in
  let exp n =
      match expand proc (G.instr n) with
      | last :: preds ->
          ignore (List.fold_left (fun n i -> G.gm_insert_assign_before i n) n preds);
          G.upd_instr n (fun _ -> last);
          (match preds with [] -> () | _ :: _ -> modified := true)
      | [] ->
          G.upd_instr n (fun _ -> R.par [])
            (*don't set modified := true --- hope for the best*)
  in
  List.iter exp nodes;
  !modified
@

@ 
Enables profiling to work even on infinite loop...
<<expander.ml>>=
let _ = Sys.set_signal Sys.sigterm (Sys.Signal_handle (fun _ -> exit 0))
@ 
This won't work because we can't load to a general address.
We really need the code expander.
<<bad postexpander.ml>>=
module R  = Rtl
module RP = Rtl.Private
module Down = Rtl.Convert
module Up   = Rtl.Revert
module MakeSpills (X : S) = struct
  let spill t l = match Down.loc l with
  | RP.Cell ('m', agg, w, addr, prop) ->
      X.store addr t prop
  | RP.Cell (sp, _, w, RP.Const (RP.Bits n), _) ->
      X.move (sp, Bits.U.to_int n, w) t
  | _ ->
      Impossible.impossible "asked to spill to non-mem non-reg"

  let reload t l = match Down.loc l with
  | RP.Cell ('m', agg, w, addr, prop) ->
      X.load t addr t prop
  | RP.Cell (sp, _, w, RP.Const (RP.Bits n), _) ->
      X.move t (sp, Bits.U.to_int n, w)
  | _ ->
      Impossible.impossible "asked to reload from non-mem non-reg"
end

