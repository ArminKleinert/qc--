% -*- mode: Noweb; noweb-code-mode: caml-mode -*- %
% vim: ts=8 sw=4 et:

% ------------------------------------------------------------------ 
\section{RTL to Lua}
% ------------------------------------------------------------------ 

This file provides functions that convert an RTL to Lua code readable by 
the {\PAL} interpreter.

% ------------------------------------------------------------------ 
\subsection{RTL Lua Representation}
% ------------------------------------------------------------------ 

To run {\PAL} code through the interpreter, we must first convert it into
the Lua-based format the interpreter expects.
This module provides a translation from an RTL to a string representing its
Lua-style counterpart.

<<rtltolua.mli>>=
val rtl: out_channel -> Rtl.rtl -> unit
val exp: out_channel -> Rtl.exp -> unit
@ 

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtltolua.ml>>=
<<ToLua>>
@ 

% ------------------------------------------------------------------ 
\subsubsection{Conversion to Lua}
% ------------------------------------------------------------------ 

<<ToLua>>=
module R     = Rtl.Private
let fprintf  = Printf.fprintf
@ 

<<ToLua>>=
let quoted        q = "\"" ^ q ^ "\""

let parenthesized p = "("  ^ p ^ ")"
let luafunc       f args = "CMM." ^ f ^ parenthesized args ^ "\n"

let push   kind c = luafunc ("push_" ^ kind) (quoted c)
let nopush kind c = c

let argstack op s =
  match op with
  |	"fetch" -> "pop" ^ s
  |	"store" -> "push" ^ s
  |	_       -> assert false

let valstack   op s = op ^ s
let commentout _  _ = "comment"

let tybits b = 
  match b with
  |	Types.Bool    -> "bool"
  |	Types.Bits(i) -> "bits" ^ string_of_int i

let const f c =
	match c with
    | R.Bool(true)    -> f "literal" "1"
    | R.Bool(false)   -> f "literal" "0"
    | R.Bits b        -> f "literal" (string_of_int (Bits.U.to_int b))

    | R.Link(sym, w)  -> f "symbol" sym#text
    | R.Late(name, w) -> f "symbol" name
@ 

<<ToLua>>=
(* but what about the operator's return type? *)
let opr op w = 
  let opty, result = Rtlop.Types.mono (Rtl.opr op w) in
  luafunc "apply_operator"  ((quoted op) ^ "," ^
							 (quoted 
								((String.concat "," (List.map tybits opty)) ^ 
								 ":" ^ (tybits result))))

let byteorder = function
  |	Rtl.BigEndian    -> quoted "BIG"
  |	Rtl.LittleEndian -> quoted "LITTLE"
  |	Rtl.Identity     -> quoted "NotImplemented"

(* what is identity? *)

let alignment = string_of_int

let rec expr' f e =
	match e with
    | R.Const c           -> const f c
    | R.Fetch(loc, _)     -> 
		let (prefix, func_f, func_suffix, args) = location' loc in
		prefix ^ luafunc (func_f "fetch" func_suffix) args
    | R.App((op, ww), ee) -> (String.concat "\n" (List.map (expr' push) ee)) ^ 
		                     opr op ww
@ 

<<ToLua>>=
and location' = function
    | R.Cell (sp, agg, width, e, ass) ->
		(match sp with
        | 'A' -> (expr' push e,
                  argstack,
                  "_arg",
                  "")
        | 'm' -> (expr' push e,
                  valstack,
				  "",
				  string_of_int width ^ "," ^ byteorder agg ^ "," ^ 
				     alignment ass)
        | r   -> ("",
                  commentout,
				  "_register",
				  "'" ^ String.make 1 r ^ "'," ^ expr' nopush e))
    | R.Var   (name, index, width)     -> ("", valstack, "_local", 
										   string_of_int index)
    | R.Slice (w, i, loc)              -> 
        let (p, ff, s, a) = location' loc in ("-- slice\n" ^ p, ff, s, a)

(* the last case of Cell is not being properly handled *)
(* NOTE: R.Slice is not yet being properly handled     *)

let (<<) f g   = fun x -> f (g x)

let expr fd rtl = output_string fd ((expr' push) (Rtl.Convert.exp rtl))
let location  = location' << Rtl.Convert.loc
@ 

<<ToLua>>=
let effect eff func_prefix =
    match eff with
    | R.Kill loc            -> ""
    | R.Store (loc, exp, w) -> 
		let (prefix, func_f, func_suffix, args) = location' loc in
		prefix ^ expr' push exp ^ 
		(luafunc (func_prefix ^ func_f "store" func_suffix) args)

let guard = function
  | R.Const (R.Bool true) -> ""
  | g                     -> "g"

let print_guarded fd (g, eff) = fprintf fd "%s" (effect eff (guard g))
@

We recognize special {\rtl}s that encode control-flow transfers and
other special instructions. The encoding of these instructions is shared
with module \module{interp}. 

I know realize that this does not allow me to recover all informations I
need. Therefore I will comment out this code for now.

<<ToLua>>=
let rec rtl' fd (R.Rtl gg) = match gg with

    | [] -> 
        fprintf fd "-- skip\n"
    
   (* 
    | [(_,R.Store(R.Cell('c',_,_,R.Const(R.Bits(i)),_),e,_))] 
        when Bits.U.to_int i = 0 -> assert false (* goto e *)
         
    | [_;(_,R.Store(R.Cell('c',_,_,R.Const(R.Bits(i)),_),e,_))] 
        when Bits.U.to_int i = 0 -> assert false (* call e *)
    
    | [(c,R.Store(R.Cell('c',_,_,R.Const(R.Bits(i)),_),e,_))] 
        when Bits.U.to_int i = 0 -> assert false (* if c, goto e *)
    
    | [(_,R.Store( R.Cell('c',_,_,R.Const(R.Bits(i0)),_)
                 , R.Fetch(R.Cell('c',_,_,R.Const(R.Bits(i3)),_),_) 
                 ,_))]    
        when Bits.U.to_int i0 = 0 && Bits.U.to_int i3 = 3 ->
        assert false (* return *)    
    *)
    
    | [(_,R.Store(R.Cell('A',_,_,_,_), e,_));_] ->
        ( output_string fd ((expr' push) e)
        ; Printf.fprintf fd "CMM.push_arg()\n"
        )

    | [(_,R.Store(R.Var(_,i,_),R.Fetch (R.Cell('A',_,_,_,_),_),_))] ->
        ( Printf.fprintf fd "CMM.pop_arg()\n"
        ; Printf.fprintf fd "CMM.store_local(%d) -- CL\n" i
        )
    
    | _      -> List.iter (print_guarded fd) gg   (* standard RTL *)


let rtl fd = (rtl' fd) << Rtl.Convert.rtl

let exp = expr
@ 

