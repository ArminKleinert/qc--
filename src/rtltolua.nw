% -*- mode: Noweb; noweb-code-mode: caml-mode -*- %
% vim: ts=8 sw=4 et:

% ------------------------------------------------------------------ 
\section{RTL to Lua}
% ------------------------------------------------------------------ 

This file provides functions that convert an RTL to Lua code readable by 
the {\PAL} interpreter.

% ------------------------------------------------------------------ 
\subsection{RTL Lua Representation}
% ------------------------------------------------------------------ 

To run {\PAL} code through the interpreter, we must first convert it into
the Lua-based format the interpreter expects.
This module provides a translation from an RTL to a string representing its
Lua-style counterpart.

<<rtltolua.mli>>=
val rtl: out_channel -> Rtl.rtl -> unit
val exp: out_channel -> Rtl.exp -> unit
@ 

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtltolua.ml>>=
<<ToLua>>
@ 

% ------------------------------------------------------------------ 
\subsubsection{Conversion to Lua}
% ------------------------------------------------------------------ 

<<ToLua>>=
module R     = Rtl.Private
let fprintf  = Printf.fprintf
@ 

<<ToLua>>=
let quoted        q = "\"" ^ q ^ "\""

let parenthesized p = "("  ^ p ^ ")"
let luafunc       f args = "CMM." ^ f ^ parenthesized args ^ "\n"

let push   kind c = luafunc ("push_" ^ kind) c
let nopush kind c = c

let valstack   op s = op ^ s
let argspace        = valstack
let globalspace     = valstack
let commentout _  _ = "comment"

let tybits b = 
  match b with
  | Types.Bool    -> "bool"
  | Types.Bits(i) -> "bits" ^ string_of_int i

let hexbits v      = quoted (Printf.sprintf "0x%Lx" (Bits.U.to_int64 v))

let const f c =
    match c with
    | R.Bool(true)    -> f "literal" (quoted "0x1" ^ ",1")
    | R.Bool(false)   -> f "literal" (quoted "0x0" ^ ",1")
    | R.Bits b        -> f "literal" (hexbits b ^ "," ^ 
                                      string_of_int (Bits.width b))

    | R.Link(sym,  _) -> f "symbol" (quoted sym#mangled_text)
    | R.Late(name, _) -> f "symbol" (quoted name)
@ 

<<ToLua>>=
let opr op w = 
  let opty, result = Rtlop.Types.mono (Rtl.opr op w) in
  luafunc "apply_operator"  ((quoted op) ^ "," ^
                             (quoted 
                                ((String.concat "," (List.map tybits opty)) ^ 
                                 ":" ^ (tybits result))))

let byteorder = function
  | Rtl.BigEndian    -> quoted "NATIVE"
  | Rtl.LittleEndian -> quoted "NATIVE"
  | Rtl.Identity     -> Impossible.impossible "rtltolua cannot handle Identity"

(* what is identity? *)

let alignment _ = "0"
 (* string_of_int *)

let rec expr' f e =
    match e with
    | R.Const c           -> const f c

    | R.Fetch(R.Mem (_,_,_,R.App(_,(R.Fetch(R.Reg('c',1,_),_))::ee),_), _) -> 
        let examine appexp =
          match appexp with
          | (R.Const (R.Bool _)) -> ""
          | (R.Const (R.Bits _)) -> ""        
          | (R.Const c)          -> const f c
          | (_)                  -> ""
        in
            (String.concat "\n" (List.map examine ee))

    | R.Fetch(loc, _)     -> 
        let (prefix, func_f, func_suffix, args) = location' loc in
        prefix ^ luafunc (func_f "fetch" func_suffix) args
    | R.App((op, ww), ee) -> (String.concat "\n" (List.map (expr' push) ee)) ^ 
                             opr op ww
@ 

<<ToLua>>=
and location' = function
    | R.Mem (sp, agg, width, e, ass) -> 
        ( expr' push e
        , valstack
        , ""
        , string_of_int width ^ "," ^ byteorder agg ^ "," ^ alignment ass
        )

    | R.Reg   ('A', i, width)        -> 
        ( ""
        , argspace
        , "_arg"
        , string_of_int i
        )

    | R.Reg   ('G', i, width)        ->
        ( ""
        , globalspace
        , "_global"
        , string_of_int i
        )

    | R.Reg   ('d', 0, 2)            ->
        ( ""
        , valstack
        , "_rounding"
        , ""
        )

    | R.Reg   (sp, i, width)         -> 
        ( ""
        , commentout
        , "_register"
        , "'" ^ String.make 1 sp ^ "'," ^ string_of_int i)
                                        
    | R.Var   (name, index, width)   -> 
        ( ""
        , valstack
        , "_local"
        , string_of_int index
        )
                 
    | R.Slice (w, i, loc)              -> 
        let (p, ff, s, a) = location' loc in ("-- slice\n" ^ p, ff, s, a)

(* NOTE: should R.Slice just fail an assertion? *)

let (<<) f g   = fun x -> f (g x)

let expr fd rtl = output_string fd ((expr' push) (Rtl.Dn.exp rtl))
let location  = location' << Rtl.Dn.loc
@ 

<<ToLua>>=
let guard = function
  | R.Const (R.Bool true) -> (""          , "" )
  | g                     -> (expr' push g, "g")

let print_rtl fd gg =
   let get_store = function
                 | (_ , R.Kill _)              -> 
                     Impossible.impossible "rtltolua : Rtl.Kill"
                 | (gd, R.Store (loc, exp, w)) ->
                     (guard gd, location' loc, exp, w)                     in
   let gg_locs   = List.map get_store gg                                   in
   let gg_stores = List.rev_map
                     (fun ((gd_prefix, gd_f_prefix), 
                           (prefix, func_f, func_suffix, args), exp, w
                          ) -> 
                       ( output_string fd (gd_prefix ^ prefix ^ expr' push exp)
                       ; luafunc (gd_f_prefix ^ func_f "store" func_suffix)
                                 args
                       )
                     )
                     gg_locs                                               in
    List.iter (output_string fd) gg_stores
@

<<ToLua>>=
let rec rtl' fd (R.Rtl gg) = match gg with
    | [] -> fprintf fd "-- skip\n"    
    | _  -> print_rtl fd gg

(* exported functions *)

let rtl fd = (rtl' fd) << Rtl.Dn.rtl
let exp    = expr
@ 

