% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% ------------------------------------------------------------------ 
\section{Stack Layout in Lua}
% ------------------------------------------------------------------ 

This module implements Lua primitives that allow to define the frame
layout for a procedure in Lua. [[Blocks]] provides a list of named
blocks that must be assembled by the layout function into one block.
[[Freeze]] takes this block and realizes the layout by performing final
substitutions in the procedure's code. For the names available, just see
the list in the implementation of [[blocks]] below.

The functions exported here are bound to Lua functions in module
\module{lualink}.

<<stack.mli>>=
val blocks: (Block.t -> 'a) -> ('a list -> 'a) -> Ast2ir.proc -> (string * 'a) list
val freeze: Ast2ir.proc -> Block.t -> unit
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<stack.ml>>=
module Target = Target
module RP     = Rtl.Private
@
[[blocks]] builds a list table of (named) blocks taken from the actual
procedure.  This table will be passed to the Lua function that actually
assembles the blocks into one that becomes the stack frame. 

Some blocks are special: the blocks named [[sp]] and [[vfp]] are
empty, but they are useful because their addresses are the
``standard'' stack
pointer and the virtual frame pointer respectively. It can be
therefore used by the frame-assembling Lua function to define where the
stack pointer points into the frame. 
<<stack.ml>>=
let blocks' frozen_block block list p =
    let cc  = p.Proc.cc                        in
    let vfp = p.Proc.target.Target.vfp         in
        [ "sp"                 , block p.Proc.sp
        ; "vfp"                , block (Block.at vfp 0 (Block.alignment p.Proc.sp))
        ; "oldblocks_callee"   , list (List.map block p.Proc.oldblocks_callee)
        ; "oldblocks_caller"   , list (List.map block p.Proc.oldblocks_caller)
        ; "stackdata"          , block p.Proc.stackd            
        ; "continuations"      , block p.Proc.conts
        ; "spills"             , block (frozen_block p.Proc.priv)
        ; "youngblocks_callee" , list (List.map block p.Proc.youngblocks_callee)
        ; "youngblocks_caller" , list (List.map block p.Proc.youngblocks_caller)
        ]

let blocks x = blocks' (fun a -> (Automaton.freeze a).Automaton.overflow) x

let freeze' apply_to_cfg p (stack:Block.t) = 
    let pointer  = p.Proc.target.Target.pointersize in            
    let eqns     = p.Proc.eqns @ (Block.constraints stack) in
    let solution = 
        try Rtleqn.solve pointer eqns 
        with Rtleqn.Can'tSolve -> <<complain of unsolved [[eqns]] for [[p]]>> in
    let null = function [] -> true | _ :: _ -> false in
    let ()   = assert (null solution.Rtleqn.dependent)   in
    let ()   = assert (not (null solution.Rtleqn.known)) in
    let map  = Strutil.assoc2map solution.Rtleqn.known     in
    if Verbose.verbosity >= 4 then
      Verbose.say 4 ("Solutions:\n" ::
                       (List.map (fun (s, e) -> Printf.sprintf "  %20s = %s\n" s
                                                (Rtlutil.ToReadableString.exp e))
                          solution.Rtleqn.known));
    (* The guard protects the subst function. If the guard is true
     * the subst function is applied to an expression *)
    let guard    = function
        | RP.Const(RP.Late(_)) -> true
        | _                    -> false in
    
    (* This is the guareded substitution - we replace certain RP.Late
       values *)
    let rec subst (e:RP.exp) = match e with              
        | RP.Const(RP.Late(x,_)) -> 
            ( try Rtl.Dn.exp (Strutil.Map.find x map) with 
            | Not_found -> 
                if false then e else Impossible.impossible ("cannot find: "^x)
            )  
        | x -> x in
    apply_to_cfg (Rtlutil.Subst2.exp ~guard ~map:subst) p.Proc.cfg


let freeze =
  let module G = Cfgx.M in
  freeze' (fun f g -> G.iter_nodes (G.update_instr (fun i -> Simplify.rtl (f i))) g)
  (* unsafe simplifier is not needed until vfp is replaced *)
@
<<complain of unsolved [[eqns]] for [[p]]>>=
let eqns = List.map Rtleqn.to_string eqns in
Impossible.impossible 
  ("for procedure " ^ p.Proc.symbol#original_text ^ "; can't solve these eqns:\n" ^
   String.concat "\n" eqns)
