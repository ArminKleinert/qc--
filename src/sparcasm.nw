% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4 

% ------------------------------------------------------------------ 
\section{SPARC Assembler}
% ------------------------------------------------------------------ 

This is an assembler that emits SPARC assembly language. 
It implements the
[[Asm3.assembler]] interface for assemblers in the {\qcc} compiler.
It should be functorized to deal with differences between SunOS and
Solaris, but to hell with SunOS.
@

The assembler constructor receices the output channel for the assembler. 
<<sparcasm.mli>>=
val make : (* solaris *) bool -> out_channel -> Asm3.assembler
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation provides no surprises. It builds up an {\AST} and
emits it to [[stdout]] when the [[emit]] method is called.

<<sparcasm.ml>>=
module T        = Target2
module A        = Ast
module G        = Cfg4
module GU       = Cfgutil

<<utilities>>
<<definitions>>
let make solaris fd = new asm solaris fd
@
<<utilities>>=
let fprintf = Printf.fprintf

@


% ------------------------------------------------------------------ 
\subsubsection{Classes for symbols}
% ------------------------------------------------------------------ 

<<definitions>>=
class symbol (n:string) : Symbol.t = 
object(this)
    method text    = n
end
@

% ------------------------------------------------------------------ 
\subsubsection{The assembler class}
% ------------------------------------------------------------------ 

The assembler maintains mutable state for:

\begin{itemize}
\item the actual section the assembler is in,
\item exported symbols,
\item imported symbols,
\item completed sections in reverse order,
\item declarations in the current section in reverse order.
\end{itemize}

Most methods append a declaration to the current section---[[append]]
provides a private method for this.

The [[init]] argument for the constructor provides a chance to open a
file or similar. We don't use it at the momement.

<<definitions>>=
type init = unit
type i    = Proc.t

class asm (solaris:bool) (fd:out_channel): Asm3.assembler = 
object (this)
    val         _fd       = fd
    <<private assembly state>>
    method private print l = List.iter (output_string _fd) l

    <<assembly methods>>
end
@ 
static AsmSymtab asmtab;
static int solaris;            /* true iff on solaris; false for sunos */
extern Assembler sparc_asm_solaris_asm;

@ 
Importing emits nothing; identifiers that are otherwise undefined are
automatically imported.
Maintaining the symbol table suffices.
<<assembly methods>>=
method import s = new symbol s
<<SPARC assembly interface procedures>>=
static AsmSymbol asm_import (name) char *name; { 
  return asm_sym_insert(asmtab, name, ASM_IMPORTED);
}
@
Exporting requires announcing as global.
<<assembly methods>>=
method export s = Printf.fprintf _fd ".global %s\n" s; new symbol s
<<SPARC assembly interface procedures>>=
static AsmSymbol asm_export (name) char *name; {
  print(".global %s\n", name);
  return asm_sym_insert(asmtab, name, ASM_EXPORTED);
}
@ 
Locals also require no announcement.
<<assembly methods>>=
method local s = new symbol s
<<SPARC assembly interface procedures>>=
static AsmSymbol asm_local (name) char *name; { 
  return asm_sym_insert(asmtab, name, ASM_LOCAL);
}
@ 
Common blocks differ from SPARC to solaris.
We don't actually support a non-[[NULL]] [[section]] argument.
\emph{Common seems to be missing from the Q\PAL\ version.}
<<SPARC assembly interface procedures>>=
static AsmSymbol asm_common(name, size, align, section) 
  char *name; int size; int align; char *section;
{ 
  AsmSymbol s;
  assert(section == NULL);
  if (solaris)
    print(".common %s,%d,%d\n", name, size, align);
  else
    print(".common %s,%d\n", name, size);
  s = asm_sym_insert(asmtab, name, ASM_COMMON);
  s->u.common.size  = size;
  s->u.common.align = align;
  return s;
}
@ 
Unknown symbols are imported by default.
<<SPARC assembly interface procedures>>=
static AsmSymbol asm_lookup (name) char *name; {
  return asm_sym_lookup(asmtab, name, ASM_IMPORTED);
}
@ 
[[offset]] is a bit tricky, because the symbol's [[addr]] field should
be given relative to the base symbol~[[p]].
We go ahead and let the default
[[asm_sym_insert]] create a label and a relocatable address, then we
eliminate the label and change the relocatable address.
<<SPARC assembly interface procedures>>=
static AsmSymbol asm_offset (qname, p, n)
  char *qname; AsmSymbol p; int n;
{
  AsmSymbol q = asm_sym_insert(asmtab, qname, p->scope);
  q->label = NULL;
  q->addr->label = p->addr->label;
  q->addr->offset = p->addr->offset + n;
  return q;
}
@ 
The symbol bound to a label should be made local if it isn't already.
The name of this method should probably change to [[define_label]].
<<assembly methods>>=
method label (s: Symbol.t) = fprintf _fd "%s:\n" s#text
<<SPARC assembly interface procedures>>=
static void asm_define_label (name) char *name; {
  AsmSymbol lab = asm_sym_lookup(asmtab, name, ASM_LOCAL);
  assert(lab->scope == ASM_LOCAL || lab->scope == ASM_EXPORTED);
  print("%s:\n", name);
}
@ 
The only thing the SPARC has for announcing procedures is [[.proc]],
and that's kind of broken, so we do nothing.
It's not clear we need this function in the interface.
<<SPARC assembly interface procedures>>=
static void asm_function (name) char *name; { }
@ 
I have to keep track of the current section so I can implement
[[current_section]]. 
<<assembly methods>>=
method section name =
  _section <- name;
  fprintf _fd "%s \"%s\"\n" (if solaris then ".section" else ".seg") name
method current = _section
<<private assembly state>>=
val mutable _section = "bogus section"
<<SPARC assembly interface procedures>>=
static char *cursection;
static void asm_section (name) char *name; {
  cursection = name;
  print("%s \"%s\"\n", solaris ? ".section" : ".seg", name);
}
static char *asm_current_section () { return cursection; }
@ 
There is no [[.org]].
<<assembly methods>>=
method org n = Impossible.unimp "no .org in SPARC assembler"
<<SPARC assembly interface procedures>>=
static void asm_org (n) unsigned n; {
  fatal("AIR->asm.org", ".org unimplemented by SPARC assembler", 0);
}
@ 
I can't find from the documentation whether [[.skip]] really skips or
lays down zeroes.  If unspecified bytes are zero, the distinction is not
useful, because in the absence of [[.org]] the SPARC location counter
increases monotonically and therefore can never step in the same river
twice.
<<assembly methods>>=
method align  n = fprintf _fd ".align %d\n" n
method addloc n = fprintf _fd ".skip %d\n"  n
<<SPARC assembly interface procedures>>=
static void asm_align (n) unsigned n; {
  print(".align %d\n", n);
}
static void asm_addlc (n) unsigned n; {
  print(".skip %d\n", n);
}
<<assembly methods>>=
method zeroes (n:int) = for i = 1 to n do fprintf _fd ".byte 0\n" done
<<SPARC assembly interface procedures>>=
static void asm_emit_zeroes (n) unsigned n; {
  unsigned i;
  for (i = 0; i < n; i++) print(".byte 0\n");
}
@ 
I use a dreadful hack to increase the likelihood of duplicating {\tt
lcc}'s 
assembly-language output for [[.word]] and [[.half]].
The SPARC has no 8-byte emission unit, so I fake one, assuming big-endian order.
<<assembly methods>>=
method value (v:Bits.bits) = 
  let altfmt v =
    let i64 = Bits.to_int64 v in
    if Uint64.lt i64 (Uint64.of_int 256) then
      string_of_int (Int64.to_int i64)
    else
      "0x" ^ Bits.to_string (Some Bits.Hex) v in
  match Bits.width v with
  |  8 -> fprintf _fd ".byte %s\n" (Bits.to_string (Some Bits.Dec) v)
  | 16 -> fprintf _fd ".half %s\n" (altfmt v)
  | 32 -> fprintf _fd ".word %s\n" (altfmt v)
  | 64 ->
      let i = Bits.to_int64 v in
      output_string _fd (Int64.format ".word 0x%x\n" (Int64.shift_right_logical i 32));
      output_string _fd (Int64.format ".word 0x%x\n" (Int64.logand i mask32))
  | w -> Impossible.unimp ("emission width " ^ string_of_int w ^ " in SPARC assembler")
<<utilities>>=
let mask32 = Int64.pred (Int64.shift_left Int64.one 32)
@                          
<<SPARC assembly interface procedures>>=
static void asm_emit (value, width) long value; int width; {
  char *unit;
  switch (width) {
    case 1 : print(".byte %d\n", value); break;
    case 2 : print((unsigned) value < 256 ? ".half %d\n" : ".half 0x%x\n", value);
	     break;
    case 4 : print((unsigned) value < 256 ? ".word %d\n" : ".word 0x%x\n", value);
	     break;
    case 8 : print(".word 0x%x\n.word 0x%x\n",
                   value & 0xffffffff, (value >> 32) & 0xffffffff); 
	     break;
    default : fatal("AIR->asm.emit", "bad emission width %d", width);
  }
}
@ 
<<assembly methods>>=            
method addr (a:Reladdr.t) = fprintf _fd ".word %s\n" (Reladdr.to_string a)
<<SPARC assembly interface procedures>>=
static void asm_emita (addr) RAddr addr; {
  print(".word "); asmprintreloc(addr); print("\n");
}
@ 
Initialization requires initializing a symbol table, setting the
[[solaris]] flag, and overriding the toolkit's default choice of
printing procedures.
<<SPARC assembly interface procedures>>=
static void asm_progbeg (asm, argc, argv) 
  struct assembler *asm; int argc; char *argv[]; 
{
  asmtab = asm->symtab = asm_symtab();
  solaris = (asm == &sparc_asm_solaris_asm);
  asm_init_printing();
}
<<assembly methods>>=
method emit = ()
<<SPARC assembly interface procedures>>=
static void asm_progend () { }
<<SPARC assembly interface procedures>>=
static void asm_asm (s) char *s; { print("%s", s); }
@
<<assembly methods>>=
method comment s = fprintf _fd "/* %s */\n" s

method const (s: Symbol.t) (b:Bits.bits) =
  Impossible.unimp "no assembly directive of the form symbol=bits"
@ 
This almost certainly doesn't work---we must linearize the flow graph
and know to emit labels.
This code belongs elsewhere; assemblers shouldn't have to know more
than simple instructions. 
This means layering the abstraction with a common subtype for
instruction-based assemblers.
<<assembly methods>>=
method private instruction rtl =
  Sledlib.String.app (output_string _fd) (Asm.to_asm (Rtl.Convert.rtl rtl))

method cfg_instr (cfg:G.rtlcfg) (symbol:Symbol.t) = 
    (* We have to emit a label/whatever for the procedure's 
       entry point. This is what symbol is for. Simply use this#label?  *)
    this#label symbol;
    GU.emit cfg (fun rtl ()  -> this#instruction rtl)
                (fun sym ()  -> this#label sym)
                ()
  
@
We should do better here---it would be good to print an ascii form
of unmatched RTLs.
Eventually unmatched will be an assembly-time error.
<<utilities>>=
module Asm = struct
  let default_string rtl =
    Sledlib.String.of_string 
        ( Printf.sprintf "unimp 0 /* not an instruction: %s */\n"
          (Rtlutil.ToString.rtl (Rtl.Revert.rtl rtl))   
        )  
  module A = Sparcrec.Make (Sparcmkasm.M (Idreloc.M))
  let to_asm rtl =
    try A.defaultOfInstruction rtl
    with Match_failure _ -> default_string rtl
end
@

% ------------------------------------------------------------------ 
\section{Assembler Constructor Function}
% ------------------------------------------------------------------ 

<<M>>=

