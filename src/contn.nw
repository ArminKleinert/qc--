% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ------------------------------------------------------------------ 
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
\section{Continuations}
% ------------------------------------------------------------------ 

A continuation is a pointer-sized {\PAL} \emph{value}. As such, it can
be passed around and stored in registers. However, not all data
necessary to represent a continuation fit into a pointer and therefore
the pointer points to a pair of two values: first, a pointer to the code
belonging to a continuation, and second, a stack pointer value. We call
this pair the continuation \emph{representation}. The representation is
stored in the activation record of a procedure and is initialized when
the procedure becomes active.

To deal with the different aspects of a continuation, this module
provides an abstraction that is carefully balanced with the target and
calling convention.
Each is responsible for different types of information:
\begin{itemize}
\item contn: the continuation's layout in memory 
\item target: sizes
\item cc: which reg is the sp; how to set the pc and sp
\end{itemize}

A continuation is a block of memory with two locations: one for a stack
pointer, and another for a code pointer.
[[with_overflow]] creates a stack block for a continuation; the
[[overflow]] input is a block for overflow parameters and [[base]] is the
base address of the block.
[[rep]] can be used to get the stack block for the continuation.

A continuation value is a pointer to the block. The block resides in
the stack frame of a procedure. It initializes the block by passing the
stack pointer location and the address of the continuation code to
[[init_code]]. The call returns a list of instructions that perform the
initialization of the block.

<<contn.mli>>=
type t

val init_code:     t -> k_sp:Rtl.exp -> k_pc:Rtl.exp -> Rtl.rtl
val rep : t -> Block.t               (* entire cont in memory *)
val with_overflow: Target2.t -> base:Rtl.exp -> overflow:Block.t -> t
@

The [[cutto]] function takes a pointer to the continuation ([[contn]])
on the stack and returns an Rtl to make the cut.
The function argument to [[cutto]] takes newpc * newsp and returns the Rtl
for a cut.
The [[get_contn]] function takes pointers to a pc * sp pair
from a continuation and returns a pointer to the continuation.

<<contn.mli>>=
val cutto : Target2.t -> (Rtl.exp * Rtl.exp -> Rtl.rtl)
                      -> contn:Rtl.exp -> Rtl.rtl
val get_contn : Rtl.exp * Rtl.exp -> Rtl.exp
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<contn.ml>>=
module T = Target2

type t =
    { block:      Block.t     (* memory block for pair *)
    ; sp:         Rtl.loc     (* location inside block for sp *)
    ; pc:         Rtl.loc     (* location in block for code ptr *)
    ; overflow:   Rtl.exp     (* base in block of overflow area *)
    }

let init_code t ~k_sp ~k_pc =
    Rtl.par [ Rtl.store t.pc k_pc (Rtlutil.Width.loc t.pc)
            ; Rtl.store t.sp k_sp (Rtlutil.Width.loc t.sp)
            ]

let rep t = t.block

let with_overflow t ~base ~overflow =
    let add       = Rtl.opr "add" [t.T.pointersize] in
    let offset n  =
        Rtl.app add [base; Rtl.bits (Bits.S.of_int n t.T.pointersize) t.T.pointersize] in
    let cell addr = Rtl.cell Rtl.none 'm' t.T.byteorder t.T.pointersize  addr in
    let size = t.T.pointersize / t.T.memsize in
        { block = Block.cathl overflow (Block.mk ~base ~size:(2 * size)
                                               ~alignment:t.T.alignment)
        ; sp    = cell (offset size)
        ; pc    = cell (offset 0)
        ; overflow = Block.base overflow
        }

let cutto t to_rtl ~contn =
    to_rtl (contn, (Rtl.app (Rtl.opr "add" [t.T.pointersize])
                [ contn
                ; Rtl.bits (Bits.S.of_int (t.T.pointersize/t.T.memsize)
                                          t.T.pointersize) t.T.pointersize
                ]))

let get_contn (newpc, newsp) = newpc
@
