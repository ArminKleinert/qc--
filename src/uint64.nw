% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

% ------------------------------------------------------------------ 
\section{UInt64 -- unsigned operations on \texttt{int64}}
% ------------------------------------------------------------------ 

This module provides unsigned operations on {\ocaml} [[int64]] values
and some conversions. The operations just add a new interpretation to
values of type [[int64]].


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Values of [[int64]] can be converted into [[float]] values by
re-interpreting the bit-patters of the [[int64]] value. This is a much
different operation than provided by the [[Int64]] module which
converts between [[float]] and [[int64]] by maintaining the numerical
value. This conversion maintains the bit patters and thus relates two
very different numerical values.

<<uint64.mli>>=
external to_float:   int64 -> float                  = "pack_float64"
external of_float:   float -> int64                  = "unpack_float64"
@

The following arithmetical operations consider their arguments and
return values as unsigned integers. Otherwise they implement the
behavior of the corresponding functions in the [[Int64]] module.

<<>>=
external addu:       int64 -> int64 -> int64         = "int64_addu"
external subu:       int64 -> int64 -> int64         = "int64_subu"
external mulu:       int64 -> int64 -> int64         = "int64_mulu"
external divu:       int64 -> int64 -> int64         = "int64_divu"
external odu:        int64 -> int64 -> int64         = "int64_modu"
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation is done in C like the implementation of [[Int64]]. 
It simply provides some additional operations in the same style as the
[[Int64]] implementation. 

<<uint64.c>>=
#include <caml/fail.h>
#include <caml/mlvalues.h>
#include <caml/alloc.h>
#include <caml/config.h>

<<>>=
value unpack_float64(value f)
{
    union { double d; int64 i; } buffer;
    buffer.d = Double_val(f);
    return copy_int64(buffer.i);
}

<<>>=
value pack_float64(value i)
{
    union { double d; int64 i; } buffer;
    buffer.i = Int64_val(i);
    return copy_double(buffer.d);
}


value int64_addu(value v1, value v2)  /* ML */
{ return copy_int64((uint64)Int64_val(v1) + (uint64)Int64_val(v2)); }
<<>>=

value int64_subu(value v1, value v2)  /* ML */
{ return copy_int64((uint64)Int64_val(v1) - (uint64)Int64_val(v2)); }

<<>>=
value int64_mulu(value v1, value v2)  /* ML */
{ return copy_int64((uint64)Int64_val(v1) * (uint64)Int64_val(v2)); }

<<>>=
value int64_divu(value v1, value v2)  /* ML */
{
    int64 divisor = Int64_val(v2);
    if (divisor == 0) raise_zero_divide();
    return copy_int64((uint64)Int64_val(v1) / (uint64)divisor);
}

<<>>=
value int64_modu(value v1, value v2)  /* ML */
{
    int64 divisor = Int64_val(v2);
    if (divisor == 0) raise_zero_divide();
    return copy_int64((uint64)Int64_val(v1) % (uint64)divisor);
}
@

