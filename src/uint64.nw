% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

% ------------------------------------------------------------------ 
\section{UInt64 -- unsigned operations on \texttt{int64}}
% ------------------------------------------------------------------ 

This module provides unsigned operations on {\ocaml} [[int64]] values
and some conversions. The operations just add a new interpretation to
values of type [[int64]].


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Values of [[int64]] can be converted into [[float]] values by
re-interpreting the bit-patters of the [[int64]] value. This is a much
different operation than provided by the [[Int64]] module which
converts between [[float]] and [[int64]] by maintaining the numerical
value. This conversion maintains the bit patters and thus relates two
very different numerical values.

<<uint64.mli>>=
external of_float:   float -> int64                  = "uint64_int64"
external to_float:   int64 -> float                  = "uint64_float"
@

The following arithmetical operations consider their arguments and
return values as unsigned integers. Otherwise they implement the
behavior of the corresponding functions in the [[Int64]] module.

<<>>=
external compare     int64 -> int64 -> int           = "unit64_compare"
external addu:       int64 -> int64 -> int64         = "uint64_add"
external subu:       int64 -> int64 -> int64         = "uint64_sub"
external mulu:       int64 -> int64 -> int64         = "uint64_mul"
external divu:       int64 -> int64 -> int64         = "uint64_div"
external modu:       int64 -> int64 -> int64         = "uint64_mod"
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation is done in C like the implementation of [[Int64]]. 
It simply provides some additional operations in the same style as the
[[Int64]] implementation. 

<<uint64.c>>=
#include <caml/fail.h>
#include <caml/mlvalues.h>
#include <caml/alloc.h>
#include <caml/config.h>

<<>>=
value uint64_compare(value v1, value v2)
{
  uint64 i1 = Int64_val(v1);
  uint64 i2 = Int64_val(v2);
  return i1 == i2 ? Val_int(0) : i1 < i2 ? Val_int(-1) : Val_int(1);
}

<<>>=
value uint64_int64(value f)
{
    union { double d; int64 i; } buffer;
    buffer.d = Double_val(f);
    return copy_int64(buffer.i);
}

<<>>=
value uint64_float(value i)
{
    union { double d; int64 i; } buffer;
    buffer.i = Int64_val(i);
    return copy_double(buffer.d);
}


value uint64_add(value v1, value v2)  /* ML */
{ return copy_int64((uint64)Int64_val(v1) + (uint64)Int64_val(v2)); }
<<>>=

value uint64_sub(value v1, value v2)  /* ML */
{ return copy_int64((uint64)Int64_val(v1) - (uint64)Int64_val(v2)); }

<<>>=
value uint64_mul(value v1, value v2)  /* ML */
{ return copy_int64((uint64)Int64_val(v1) * (uint64)Int64_val(v2)); }

<<>>=
value uint64_div(value v1, value v2)  /* ML */
{
    int64 divisor = Int64_val(v2);
    if (divisor == 0) raise_zero_divide();
    return copy_int64((uint64)Int64_val(v1) / (uint64)divisor);
}

<<>>=
value uint64_mod(value v1, value v2)  /* ML */
{
    int64 divisor = Int64_val(v2);
    if (divisor == 0) raise_zero_divide();
    return copy_int64((uint64)Int64_val(v1) % (uint64)divisor);
}
@

