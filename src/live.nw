% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Liveness Analysis}
% ------------------------------------------------------------------ 

Liveness analysis determines what locations are live on entry to and
exit from every node in a flow graph.
Precisely speaking, a location~$x$ is live on an edge~$e$ iff that
edge flows to a use of~$x$ without crossing a definition or kill of
$x$. 
Liveness information should be attached to each
edge, but since our edges are simple pointers, 
we instead provide  for live-in and live-out information at each node;
the liveness of an edge is the live-in set of that edge's head.
The live-out set is the union of the live sets on all the edges
flowing out of a node.


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Function [[set_live]] computes liveness information and caches the
results in node extensions.
The functions [[live_in]] and [[live_out]] use the cached information.
One day we hope to get extremely clever about minimizing the amount of
cached information while still making [[live_in]] and [[live_out]]
cost constant time, but that day is not yet.
<<live.mli>>=
type live_info
val mk : unit -> live_info

module type Arg = sig
  module G : Cfg.S
  val jx : G.X.jx -> live_info 
  val nx : G.X.nx -> live_info   
  val fx : G.X.fx -> live_info   
end

module Make (A : Arg): sig
  val set_live : Rtl.rtl A.G.cfg -> unit
  (* following may be run only after [[set_live]] and without mutation *)
  val live_out : Rtl.rtl A.G.node -> A.G.regs
  val live_in  : Rtl.rtl A.G.node -> A.G.regs 
end
@

% ------------------------------------------------------------------ 
\section{Implementation of liveness}
% ------------------------------------------------------------------ 

<<live.ml>>=
module RS = Register.Set
module R  = Rtl

type live_info = { mutable cached_live_out : RS.t }
let mk () = { cached_live_out = RS.empty }

module type Arg = sig
  module G : Cfg.S
  val jx : G.X.jx -> live_info 
  val nx : G.X.nx -> live_info   
  val fx : G.X.fx -> live_info   
end

module Make (A : Arg) = struct 
  module G = A.G
  let irwk = Rtlutil.ReadWriteKill.sets
  <<struct Make>>
end
@

The [[live]] function computes the set of registers live \emph{after}
[[node]].  It does so by looking at the liveout sets of its successors
and the registers defined, killed, and used by the successors [[node]]. 
The idea is, that variables live before successor nodes must be must be
live after this node as well.  The details depend on the kind of [[node]]. 

\begin{itemize}
\item A variables live after the node are also live before it,
\item minus the variables that are defined by the rtl,
\item minus the variables that are killed by the rtl,
\item plus the variables that are used by the rtl.
\end{itemize}
$$\mathit{live} = 
    ( \mathit{after} 
      \setminus \mathit{defined} \setminus \mathit{killed}
    ) \cup \mathit{used}
$$
@
Set operations.
<<struct Make>>=
let ( ++  ) = RS.union
let ( --  ) = RS.diff 
let ( --* ) live killed =
  if RS.exists (fun x -> RS.mem x killed) live then
    Impossible.impossible "live variable is in killed set"
  else
    live 
@ 
<<struct Make>>=
let info node =
  if      G.is_join node then A.jx (G.jx node)
  else if G.is_fork node then A.fx (G.fx node)
  else                        A.nx (G.nx node)

@ 
<<struct Make>>=
let rec new_live_out node =
  G.union_over_outedges
    node
    (fun n' -> live_in n')
    (fun {G.node = n'; G.defs = d; G.kills = k} -> live_in n' -- d --* k)
and live_out node = (info node).cached_live_out
and live_in  node =
  let live = live_out node in  
  let live = match G.to_instr node with
  | None -> live
  | Some i ->
      let uses, defs, kills = irwk i in
      live -- defs --* kills ++ uses in
  G.add_inedge_uses node live
@
@
To compute liveness, we empty all cached live sets and iterate until
we reach a fixed point.
The iteration order is completely unspecified, and it would probably
be much more efficient to use a well-chosen order. 
<<struct Make>>=
let set_live g =
  G.iter_nodes (fun n -> (info n).cached_live_out <- RS.empty) g;
  let changed     = ref false                           in
  <<definition of [[update_cache]]>> in
  let rec loop n = (* would be sensible to choose a *good* order here *)
    ( changed := false
    ; G.iter_nodes update_cache g
    ; if !changed then
        if n < 1000 then loop (n+1) 
        else Impossible.impossible "more than 1000 iterations for liveness to converge"
    ) in
  loop 0
@
To update the cache we call [[new_live_out]] and note whether anything
has changed.
<<definition of [[update_cache]]>>=
let update_cache node =
  let l  = new_live_out node in
  let info = info node in
  if RS.equal l info.cached_live_out then
    ()   (* changed := false *)
  else
    ( changed := true
    ; assert (RS.subset info.cached_live_out l)
    ; info.cached_live_out <- l
    ) 
@ 

