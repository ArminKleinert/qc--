% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Liveness Analysis}
% ------------------------------------------------------------------ 

Liveness analysis determines for every node in a flow graph (see
module \module{cfg3}) the set of locations that will be used in that
node or any of its successors.  More formally a location $x$ is live
before a node $n$, if and only if $x$ is \emph{used} by $n$ or there
exists a path to a node that uses $x$ without crossing a definition or
kill of $x$.  A set of live variables is called the \emph{live set}. 
Since nodes use, define, and kill variables, liveness is actually only
defined \emph{between} adjacent notes.  Therefore, the set of live
variables associated with each node in a control flow graph denotes
the variables that are live \emph{before} the node at hand.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[liveness]] function annotates the nodes in a control-flow graph
[[cfg]] with the set of live registers \emph{before} that node.

<<CFG>>=
module type CFG = sig
    include Cfg3.S
    val get_live: node -> locs          (* access to live sets *)
    val set_live: node -> locs -> unit
end with
    type locs = Register.Set.t          
@

\begin{quote}\it
    Should [[Cfg3.S]] provide an equality predicate for [[Cfg3.loc]]
    values? Here we are basically breaking the abstraction of
    locations. --CL
\end{quote}


<<live.mli>>=
<<CFG>>
module Make(G: CFG): sig
    val liveness: G.t -> unit
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 



<<live.ml>>=
<<CFG>>
module Make (G: CFG) = struct 
    module R = Register.Set
    <<struct Make>>
end
@

The [[live]] function computes the set of registers live \emph{before}
[[node]].  It does so by looking at the live sets of its successors
and the registers defined, killed, and used by the current [[node]]. 
The idea is, that variables live at successor nodes must be either
defined by this node, or must be live before this node as well.  The
details depend on the kind of [[node]]. 

\begin{itemize}
\item A variables live after the node are also live before it,
\item minus the variables that are defined by the rtl,
\item minus the variables that are killed by the rtl,
\item plus the variables that are used by the rtl.
\end{itemize}

% \begin{quote}\it
%     What is the difference of \emph{def} and \emph{kill} from the
%     liveness analysis point of view. It seems that both define a
%     location but in the case of a kill the value is unknown. However,
%     the value does not matter for liveness analysis which would make
%     them equivalent. --CL
% \end{quote}

$$\mathit{live} = 
    ( \mathit{after} 
      \setminus \mathit{defined} \setminus \mathit{killed}
    ) \cup \mathit{used}
$$

<<struct Make>>=
let rec live (node:G.node) =
    let defs         = G.defs    node                      in
    let uses         = G.uses    node                      in
    let kills        = G.kills   node                      in
    let live         = Register.Set.diff (after node) defs in
    let live         = Register.Set.diff live kills        in 
    let live         = Register.Set.union live uses        in 
        Register.Set.union (G.get_live node) live
@

The [[after]] function computes the union of the live sets of a node's
successors.

<<struct Make>>=
and after node = 
    List.fold_left (fun set x -> R.union (G.get_live x) set) R.empty
                   (G.succ node)
@

Computing the live sets of a control-flow graph (\cfg) is a fix-point
problem:  you have to do it as long as doing so changes the result. 
After computing a new live set for a node we compare it to the set
currently stored in the node.  If both differ the mutable [[changed]]
flag is set. 

<<struct Make>>=
let process changed node =
    let l  = live node in
    let _  = assert (Register.Set.subset (G.get_live node) l) in 
        if Register.Set.equal l (G.get_live node) then
           ()   (* changed := false *)
        else
           ( changed := true
           ; G.set_live node l
           (* Printf.printf "id=%d\n" (G.number node) *)
           ) 
@

The [[process]] function, which updates the live set of a node, is
repeatedly applied to all nodes in [[cfg]].  This is done until
[[process]] does not change any live set which means the fix point is
reached.  We use [[G.scan_bwd]] to implement an iteration function
that iterates mostly backwards (reverse control-flow direction) over
the {\cfg}.

<<struct Make>>=
let liveness cfg =
    let () = G.gm_enumerate cfg in
    let fold cfg f z =
        let first = G.number (G.first cfg)     in
        let limit = G.number (G.last  cfg) + 1 in
            G.scan_bwd cfg first limit f z     in
    let changed     = ref false                           in
    let iter cfg f  = fold cfg (fun node () -> f node) () in
    let rec loop n = 
        ( changed := false
        ; iter cfg (process changed) 
        ; if !changed && n < 1000 then 
            loop (n+1) 
          else if n >= 1000 then
                assert false    (* does not terminate? *)
          else
                ()              (* ok *)        
        )
    in loop 0
@


