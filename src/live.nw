% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

%%Grades: A Peripheral Later

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Liveness Analysis}
% ------------------------------------------------------------------ 

Liveness analysis determines what locations are live on entry to and
exit from every node in a flow graph.
Liveness is actually an edge property: a location~$x$ is live on an
edge~$e$ iff that 
edge flows to a use of~$x$ without crossing a definition or kill
of~$x$.  
Since our edges are simple pointers, 
we put liveness information at the nodes, in the form of
\emph{live-in} and \emph{live-out sets}.
The liveness of an edge is the live-in set of that edge's head.
The live-out set is the union of the live sets on all the edges
flowing out of a node.
@

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Function [[set_live]] computes liveness information and caches the
results in node extensions.
The functions [[live_in]] and [[live_out]] use the cached information.
One day we hope to get clever about minimizing the amount of
cached information while still making [[live_in]] and [[live_out]]
cost constant time, but that day is not yet.
<<live.mli>>=
type info
val mk : unit -> info

module type Arg = sig
  module G : Cfg.S
  val jx : G.X.jx -> info 
  val nx : G.X.nx -> info   
  val fx : G.X.fx -> info   
end

module type S = sig
  module G : Cfg.S
  val set_live : Rtl.rtl G.cfg -> unit
  (* following may be run only after [[set_live]] and without mutation *)
  val live_out : Rtl.rtl G.node -> G.regs
  val live_in  : Rtl.rtl G.node -> G.regs 
end
module Make (A : Arg): S with module G = A.G
@

% ------------------------------------------------------------------ 
\section{Implementation of liveness}
% ------------------------------------------------------------------ 

Following a suggestion of John Dias, we cache live-out information at
each node. 
<<live.ml>>=
module RS = Register.Set
module R  = Rtl

type info = { mutable cached_live_out : RS.t }
let mk () = { cached_live_out = RS.empty }
@ 
Here are the structures promised in the interface.
<<live.ml>>=
module type Arg = sig
  module G : Cfg.S
  val jx : G.X.jx -> info 
  val nx : G.X.nx -> info   
  val fx : G.X.fx -> info   
end

module type S = sig
  module G : Cfg.S
  val set_live : Rtl.rtl G.cfg -> unit
  (* following may be run only after [[set_live]] and without mutation *)
  val live_out : Rtl.rtl G.node -> G.regs
  val live_in  : Rtl.rtl G.node -> G.regs 
end

module Make (A : Arg) = struct 
  module G = A.G
  let irwk = Rtlutil.ReadWriteKill.sets
  <<liveness functions>>
  (*<code using [[Dataflow]]>*)
end
@ 
Here's how we get to the cached information for a node.
<<liveness functions>>=
let info node =
  if      G.is_join node then A.jx (G.jx node)
  else if G.is_fork node then A.fx (G.fx node)
  else                        A.nx (G.nx node)

@
We use these
set operations.
The [[--*]] operation expresses our expectation that a killed register should
never be live. 
<<liveness functions>>=
let ( ++  ) = RS.union
let ( --  ) = RS.diff 
let ( --* ) live killed =
  if RS.exists (fun x -> RS.mem x killed) live then
    (*<complain of live variables in killed set>; live--killed *)
    Impossible.impossible "live variable is in killed set"
  else
    live 
<<complain of live variables in killed set>>=
let regstring (s, i, _) = Printf.sprintf "%c%d" s i in
let bad = RS.elements (RS.filter (fun x -> RS.mem x killed) live) in
let msg = "Live vars in killed set: " ^ String.concat ", " (List.map regstring bad) in
prerr_string msg;
prerr_string "\n"
@ 
The [[live_out]] function uses the cache.
The [[new_live_out]] function computes the live-out set afresh; it is
used to fill the cache.
It works by taking the union over outedges of the live-in sets of its
successors, also accounting for any defs or kills that may be on the
outedges. 
Finally, the [[live_in]] function starts with the cached live-out set and
accounts for any registers used, defined, and killed by the
instruction in the node.
$$\mathit{live}_{\mathit{in}} = 
    (\mathit{live}_{\mathit{out}}
      \setminus \mathit{defined} \setminus \mathit{killed}
    ) \cup \mathit{used}.
$$
<<liveness functions>>=
let rec live_out node = (info node).cached_live_out
and new_live_out node =
  G.union_over_outedges
    node
    (fun n' -> live_in n')
    (fun {G.node = n'; G.defs = d; G.kills = k} -> live_in n' -- d --* k)
and live_in  node =
  let live = live_out node in  
  let live = match G.to_instr node with
  | None -> live
  | Some i ->
      let uses, defs, kills = irwk i in
      live -- defs --* kills ++ uses in
  G.add_inedge_uses node live
@ N.B. we could operate more efficiently if, instead of using [[irwk]]
to build sets, we simply folded over the proper functions directly.
@
To fill the caches with correct liveness information, we empty all
cached live sets and iterate until we reach a fixed point.
The iteration order is unspecified, and it would probably
be much more efficient to use a well-chosen order. 
<<liveness functions>>=
let set_live g =
  G.iter_nodes (fun n -> (info n).cached_live_out <- RS.empty) g;
  let nodes   = List.rev (G.postorder_dfs (fun x y -> x :: y) [] g) in
  let changed = ref false                           in
  <<definition of [[update_cache]]>> in
  let rec loop n =
    ( changed := false
    ; List.iter update_cache nodes
    ; if !changed then
        if n < 1000 then loop (n+1) 
        else Impossible.impossible "liveness didn't converge in 1000 iterations"
      else
        Verbose.say 2 ["set_live converged in "; string_of_int n; " iterations\n"]
    ) in
  loop 1
@
To update the cache we call [[new_live_out]] and note whether anything
has changed.
<<definition of [[update_cache]]>>=
let update_cache node =
  let l    = new_live_out node in
  let info = info node in
  if RS.equal l info.cached_live_out then
    ()
  else
    ( changed := true
    ; assert (RS.subset info.cached_live_out l)
    ; info.cached_live_out <- l
    ) 
@ 
\section{Alternative implementation using the generic dataflow support}

\textbf{This code will not work and is not compiled. 
There are several problems, not
least of which is that the backward code in dataflow incorrectly
assumes that a fork point does not contain an instruction.
}

Liveness is a backward dataflow problem.
The ``info'' is the live-out set.
At a fork, we take the union.
<<code using [[Dataflow]]>>=
let split_info node = (info node).cached_live_out
let merge node live =
  let info = info node in
  if RS.subset live info.cached_live_out then
    false
  else
    ( info.cached_live_out <- info.cached_live_out ++ live
    ; true
    ) 
let init_info = RS.empty
let (with_predecessor's_outedge : Rtl.rtl G.node -> RS.t ->
        (RS.t -> defs:RS.t -> kills:RS.t -> RS.t) -> RS.t) = fun _ -> assert false
let propagate node live =
  (info node).cached_live_out <- live;
  let live = match G.to_instr node with
  | None -> live
  | Some i ->
      let uses, defs, kills = irwk i in
      live -- defs --* kills ++ uses in
  let live = G.add_inedge_uses node live in
  if G.is_join node then
    live
  else
    with_predecessor's_outedge (G.pred node) live
      (fun live ~defs ~kills -> live -- defs --* kills)

module D = Dataflow.Make(G)
let set_live' =
  let once = D.bwd_iteration { D.split_info = split_info; D.merge_split_info = merge
                              ; D.init_info = init_info; D.propagate = propagate } in
  fun g ->
    let rec go n =
      if n < 1000 then
        if once g then
          go (n+1)
        else
          Verbose.say 2 ["set_live' converged in "; string_of_int n; " iterations\n"]
      else
        Impossible.impossible "liveness didn't converge in 1000 iterations";
    in go 0
