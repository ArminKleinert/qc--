% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Liveness Analysis}
% ------------------------------------------------------------------ 

Liveness analysis determines for every node in a flow graph (see
module \module{cfg3}) the set of variables that will be used in any of
its succeeding nodes.  This set of variables is called the \emph{live
set}.  Since nodes use and define variables, liveness is actually only
defined \emph{between} adjacent notes.  Therefore, the set of live
variables associated with each node in a control flow graph denotes
the variables that are live \emph{before} the node at hand.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[liveness]] function annotates the nodes in a control-flow graph
[[cfg]] with the set of live registers \emph{before} that node.

<<live.mli>>=
module Make(G: Cfg3.S with type locs = Register.Set.t
           ) : sig
    val liveness: G.t -> unit
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 


<<live.ml>>=
module Make (G: Cfg3.S with type locs = Register.Set.t) = struct
    module R = Register.Set
    <<struct Make>>
end
@

The set of live variables of a node are basically the union of live
variables from its successors.  The [[union]] function unites a list
of sets.

<<struct Make>>=
let (union: Register.Set.t list -> Register.Set.t) = 
        List.fold_left R.union R.empty            
@

Nodes in the control-flow graph {\cfg} carry mutable properties which
include a set of register live before that node.  The following
functions allow to read and write this set.

<<struct Make>>=
let get_live (node:G.node)                      = assert false
let set_live (node:G.node) (set:Register.Set.t) = assert false
@

The [[live]] function computes the set of registers live \emph{before}
[[node]].  It does so by looking at the live sets of its successors
and the registers defined, killed, and used by the current [[node]]. 
The idea is, that variables live at successor nodes must be either
defined by this node, or must be live before this node as well.  The
details depend on the kind of [[node]]. 

\begin{itemize}
\item A variables live after the node are also live before it,
\item minus the variables that are written by the rtl,
\item plus the variables that are read by the rtl.
\end{itemize}

\begin{quote}\it
    What is the difference of \emph{def} and \emph{kill} from the
    liveness analysis point of view. It seems that both define a
    location but in the case of a kill the value is unknown. However,
    the value does not matter for liveness analysis which would make
    them equivalent. --CL
\end{quote}

$$\mathit{live} = 
    ( \mathit{after} 
      \setminus \mathit{defined} \setminus \mathit{killed}
    ) \cup \mathit{used}
$$

The [[after]] function computes the union of the live sets of a node's
successors.

<<struct Make>>=
let rec after node = union (List.map live (G.succ node)) 
@

Nodes report the locations they use, define, and kill.

<<struct Make>>=
and live: G.node -> Register.Set.t = fun node -> 
    let defs         = G.defines node                      in
    let uses         = G.uses    node                      in
    let kills        = G.kills   node                      in
    let live         = Register.Set.diff (after node) defs in
    let live         = Register.Set.diff live kills        in (*XXX*)
        Register.Set.union live uses
@

Computing the live sets of a control-flow graph (\cfg) is a fix-point
problem:  you have to do it as long as doing so changes the result. 
After computing a new live set for a node we compare it to the set
currently stored in the node.  If both differ the mutable
[[changed]] flag is set.  

<<struct Make>>=
let process changed node =
    let l = live node in
        if l <>  get_live node then
            ( changed := true; set_live node l )
        else
            ()
@

The [[process]] function, which updates the live set of a node, is
repeatedly applied to all nodes in [[cfg]].  This is done until
[[process]] does not change any live set which means the fix point is
reached.  We use [[G.fold]] to implement an iteration function
[[iter]] over the nodes of a {\cfg}. 

<<struct Make>>=
let liveness cfg =
    let changed = ref false                                in
    let iter cfg f = G.fold cfg (fun node () -> f node) () in
    let rec loop () = 
        ( changed := false
        ; iter cfg (process changed) 
        ; if !changed then loop () else ()
        )
    in loop ()
@


