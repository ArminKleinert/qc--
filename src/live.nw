% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Liveness Analysis}
% ------------------------------------------------------------------ 

Liveness analysis determines for every node in a flow graph (see
module \module{cfg3}) the set of variables that will be used in any of
its succeeding nodes.  This set of variables is called the \emph{live
set}.  Since nodes use and define variables, liveness is actually only
defined \emph{between} adjacent notes.  Therefore, the set of live
variables associated with each node in a control flow graph denotes
the variables that are live \emph{before} the node at hand.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[liveness]] function annotates the nodes in a control-flow graph
[[cfg]] with the set of live registers \emph{before} that node.

<<live.mli>>=
val liveness: Cfg3.cfg -> unit
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 


<<live.ml>>=
module R = Register.Set
module G = Cfg3
<<struct Make>>
@

The set of live variables of a node are basically the union of live
variables from its successors.  The [[union]] function unites a list
of sets.

<<struct Make>>=
let (union: Register.Set.t list -> Register.Set.t) = 
        List.fold_left R.union R.empty            
@

The [[live]] function computes the set of variable live \emph{before}
[[node]].  It does so by looking at the live sets of its successors. 
The idea is, that variables live at successor nodes must be either
defined by this node, or must be live before this node as well.  The
details depend on the kind of [[node]].  

Most nodes include an [[rtl]]; we calculate the read/write sets from
the [[rtl]] using [[rw]].  In the [[standard]] case, the live set can
be deduced from the [[rtl]] alone whitout looking a the kind of its
node:

\begin{itemize}
\item A variables live after the node are also live before it,
\item minus the variables that are written by the rtl,
\item plus the variables that are read by the rtl.
\end{itemize}

$$\mathit{live} = 
    ( \mathit{after} 
      \setminus \mathit{written}
    ) \cup \mathit{read}
$$

The [[after]] function computes the union of the live sets of a node's
successors.

<<struct Make>>=
let rec after node = union (List.map live (G.succ node)) 
@

Not all liveness information can be deduced from nodes' {\rtl}s.  Some
nodes have additional liveness informations attached, like the
[[jump]], [[cutto]] and [[return]] node.  They are taken into account
by the [[live]] function.  In this particular case nodes advertise
which registers are used such that they are kept live.

<<struct Make>>=
and live: G.node -> Register.Set.t = fun node -> 
    let use          = Register.Set.empty (* dummy *)           in
    let (read,write) = Rtlutil.read_write_sets (G.rtl node)     in
    let live         = Register.Set.diff (after node) write     in
        Register.Set.union live read
@

Computing the live sets of a control-flow graph (\cfg) is a fix-point
problem:  you have to do it as long as doing so changes the result. 
After computing a new live set for a node we compare it to the set
currently stored in the node.  If both differ the mutable
[[changed]] flag is set.  

<<struct Make>>=
let process changed node =
    let l = live node in
        if l <> G.live node then
            ( changed := true; G.set_live node l )
        else
            ()
@

The [[process]] function, which updates the live set of a node, is
repeatedly applied to all nodes in [[cfg]].  This is done until
[[process]] does not change any live set which means the fix point is
reached.  We use [[G.fold]] to implement an iteration function
[[iter]] over the nodes of a {\cfg}. 

<<struct Make>>=
let liveness cfg =
    let changed = ref false                                in
    let iter cfg f = G.fold cfg (fun node () -> f node) () in
    let rec loop () = 
        ( changed := false
        ; iter cfg (process changed) 
        ; if !changed then loop () else ()
        )
    in loop ()
@


