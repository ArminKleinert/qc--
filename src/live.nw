% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Liveness Analysis}
% ------------------------------------------------------------------ 

Liveness analysis determines for every node in a flow graph (see
module \module{cfg3}) the set of locations that will be used in that
node's successors.  More formally a location $x$ is live after a node
$n$, if and only if there exists a path to a node that uses $x$
without crossing a definition or kill of $x$. A set of live variables
is called the \emph{liveout set}. Since nodes use, define, and kill
variables, liveness is actually only defined \emph{between} adjacent
notes.  Therefore, the set of liveout variables associated with each
node in a control flow graph denotes the variables that are live
\emph{after} the node at hand.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[liveness]] function annotates the nodes in a control-flow graph
[[cfg]] with the set of live registers \emph{after} that node.

<<live.mli>>=
module Make(G: Cfg4.S): sig
    val liveness: G.cfg -> unit
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 



<<live.ml>>=
module Make (G: Cfg4.S) = struct 
    module R = Register.Set
    module P = Cfgprop (* node properties *)
    <<struct Make>>
end
@

The [[live]] function computes the set of registers live \emph{after}
[[node]].  It does so by looking at the liveout sets of its successors
and the registers defined, killed, and used by the successors [[node]]. 
The idea is, that variables live before successor nodes must be must be
live after this node as well.  The details depend on the kind of [[node]]. 

\begin{itemize}
\item A variables live after the node are also live before it,
\item minus the variables that are defined by the rtl,
\item minus the variables that are killed by the rtl,
\item plus the variables that are used by the rtl.
\end{itemize}

% \begin{quote}\it
%     What is the difference of \emph{def} and \emph{kill} from the
%     liveness analysis point of view. It seems that both define a
%     location but in the case of a kill the value is unknown. However,
%     the value does not matter for liveness analysis which would make
%     them equivalent. --CL
% \end{quote}

$$\mathit{live} = 
    ( \mathit{after} 
      \setminus \mathit{defined} \setminus \mathit{killed}
    ) \cup \mathit{used}
$$

<<struct Make>>=
let rec live node =
    let ( ++ ) = Register.Set.union in
    let ( -- ) = Register.Set.diff in
    let live_in n =
        let defs         = G.defs    node                      in
        let uses         = G.uses    node                      in
        let kills        = G.kills   node                      in
             (((G.property n).P.liveout -- (G.defs n)) -- (G.kills n))
                        ++ G.uses n
    in
        List.fold_left (fun set x -> R.union (live_in x) set) R.empty
                       (G.succ node)
@

The [[after]] function computes the union of the live-in sets of a node's
successors. This union forms the live-out set for the current node.

Computing the live sets of a control-flow graph (\cfg) is a fix-point
problem:  you have to do it as long as it changes the result.  After
computing a new live set for a node we compare it to the set currently
stored in the node.  If both differ the mutable [[changed]] flag is set. 

<<struct Make>>=
let process changed node =
    let l  = live node in
    let _  = assert (Register.Set.subset (G.property node).P.liveout l) in 
        if Register.Set.equal l (G.property node).P.liveout then
           ()   (* changed := false *)
        else
           ( changed := true
           ; (G.property node).P.liveout <- l
           (* Printf.printf "id=%d\n" (G.number node) *)
           ) 
@

First, we make sure we clear the [[liveout]] sets for all the nodes -
this ensures that any obsolete liveness information is discarded before
we begin.  The [[process]] function, which updates the live set of a
node, is repeatedly applied to all nodes in [[cfg]].  This is done until
[[process]] does not change any live set which means the fix point is
reached.  We use [[G.scan_bwd]] to implement an iteration function that
iterates mostly backwards (reverse control-flow direction) over the
{\cfg}.

<<struct Make>>=
let liveness cfg =
    let () = G.gm_enumerate cfg in
    let fold cfg f z =
        let first = G.number (G.first cfg)     in
        let limit = G.number (G.last  cfg) + 1 in
            G.scan_bwd cfg ~first ~limit f z     in
    let empty = Register.Set.empty             in
    let _ = fold cfg (fun n () -> (G.property n).P.liveout <- empty) () in
    let changed     = ref false                           in
    let iter cfg f  = fold cfg (fun node () -> f node) () in
    let rec loop n = 
        ( changed := false
        ; iter cfg (process changed) 
        ; if !changed && n < 1000 then 
            loop (n+1) 
          else if n >= 1000 then
                assert false    (* does not terminate? *)
          else
                ()              (* ok *)        
        )
    in loop 0
@
