% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% ------------------------------------------------------------------ 
\section{Lua Assembler}
% ------------------------------------------------------------------ 

This is an assembler that emits Lua code in the format expected by the
{\qcc} interpreter.  It implements the [[Asm.assembler]] interface for
assemblers in the {\qcc} compiler.

<<interpasm.mli>>=
type tgt   = ((Rtl.exp -> Automaton.t), Call.t) Target.t
type proc' = (Automaton.t, Rtl.rtl Cfgx.M.cfg, Call.t, tgt) Proc.t

val asm':   byteorder:Rtl.aggregation -> memsize:int -> ptrsize:int
            -> out_channel -> proc'  Asm.assembler
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The details of procedure representation and how to emit a procedure are
captured by a functor argument of signature [[PROC]]. I could not get it
to work with polymorphism allone.

<<interpasm.ml>>=
module T        = Target
module Asm      = Asm
module GU       = Cfgutil
module RL       = Interpemitrtl
module RP       = Rtl.Private

type tgt   = ((Rtl.exp -> Automaton.t), Call.t) Target.t
type proc' = (Automaton.t, Rtl.rtl Cfgx.M.cfg, Call.t, tgt) Proc.t

module type PROC = sig
    type proc
    val emit: proc -> out_channel -> unit
end

module Make (P: PROC) = struct
    type proc = P.proc
    <<auxilliaries>>
    <<name mangler spec>>
    <<class asm>>

    let asm = new asm 
end

module New = struct
    type proc = proc'

    (* we ask for more stackdata space than we strictly need; leftover space
       we use for storing continuation information *)
    let emit (proc:proc) fd =
        let fprintf = Printf.fprintf in
        ( fprintf fd "CMM.procedure ('%s',%d,%d) -- stackdata = sdata+conts\n"
                      (proc.Proc.symbol#mangled_text)
                      proc.Proc.vars
                      (Block.size proc.Proc.stackd+Block.size proc.Proc.conts)
        ; Interpemit.proc proc fd
        ; fprintf fd "CMM.end_procedure()\n"
        )
end


module NewAsm = Make(New)
let asm' = NewAsm.asm

@

% ------------------------------------------------------------------ 
\subsubsection{Auxiliaries}
% ------------------------------------------------------------------ 

<<auxilliaries>>=
let quoted        s = "\"" ^ s ^ "\""
let parenthesized s = "("  ^ s ^ ")"
let braced        s = "{"  ^ s ^ "}"

let luafunc f args  = "CMM." ^ f ^ parenthesized args ^ "\n"

(* sz : int , d : string list *)
let initdata sz d  = luafunc "data" (string_of_int sz ^ "," ^
                                     (braced (String.concat "," 
                                                 (List.map quoted d))))
 
let hexbits v      = Printf.sprintf "0x%Lx" (Bits.U.to_int64 v)

exception Unsupported of string
let unsupported msg = raise (Unsupported msg)
type reloc = Bits.bits Reloc.Simple.relocatable 
@

% ------------------------------------------------------------------ 
\subsubsection{Name Mangling}
% ------------------------------------------------------------------ 

Since we emit Lua code we have to make sure that symbols respect
naming conventions. The \module{mangle} module provides name
mangling support. To highlight the destinction between names and symbols
we prefix every symbol with [[sym]].

<<name mangler spec>>=
let spec =
    let reserved = [] (* add any reserved words here *)
    in
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '.' 
        | '_' 
        | '$' 
        | '@'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
  (*    | _           -> '@'  *)
        | x           -> x
        in    
            { (* Mangle.preprocess = (fun x -> "sym:"^x) *)
              Mangle.preprocess = (fun x -> x)
            ; Mangle.replace    = replace
            ; Mangle.reserved   = reserved
            ; Mangle.avoid      = (fun x -> x ^ "$")
            }
@

% ------------------------------------------------------------------ 
\subsubsection{The assembler class}
% ------------------------------------------------------------------ 

The assembler maintains mutable state for:

\begin{itemize}
\item the actual section the assembler is in,
\item exported symbols,
\item imported symbols,
\item completed sections in reverse order,
\item declarations in the current section in reverse order.
\end{itemize}

Most methods append a declaration to the current section---[[append]]
provides a private method for this.


<<class asm>>=
class asm  ~(byteorder:Rtl.aggregation)
           ~(memsize:int)
           ~(ptrsize:int)
           (fd:out_channel): [proc] Asm.assembler =
object (this)
    val         _fd       = fd

    val mutable _section  = "this can't happen"
    val mutable _exported = Strutil.Set.empty
    val mutable _imported = Strutil.Set.empty

    val         _mangle   = Mangle.mk spec
    val         _fprintf  = output_string fd

    method private append s =
        _fprintf s

    (* -- declare symbols -- *)
    method import s =
        ( _imported <- Strutil.Set.add (_mangle s) _imported
        ; Symbol.with_mangler _mangle s
        )
        
    method export s =
        ( _exported <- Strutil.Set.add (_mangle s) _exported
        ; Symbol.with_mangler _mangle s
        )
        
    (* FIX what is local supposed to do ? *)
    method local  s = 
        Symbol.with_mangler _mangle s


    (* -- sections -- *)
    method section s =
        ( this#append (luafunc "end_section" "")
        ; this#append (luafunc "section"     (quoted s))
        ; _section <- s
        )

    method current = 
        _section
            
    (* define symbols *)        
    method label (s: Symbol.t) = 
        this#append (luafunc "define_label" (quoted s#mangled_text))
    
    (* FIX can we ignore constants here? *)
    method const (s: Symbol.t) (b:Bits.bits) = 
        ()

    (* set location counter *)
    method org n =
        unsupported "no location counter in this implementation"

    method align n =
        if n <> 1 then this#append (luafunc "align" (string_of_int n))

    method addloc n = 
        if n <> 0 then this#append (luafunc "skip"  (string_of_int n))

    (* instructions *)
    method cfg_instr (proc: proc) = P.emit proc _fd

    (* -- emit data -- *)

    (* zeroes emits n zeroes as initialized data *)
    method zeroes (n:int) =
        let rec  z   = function
            | 0 -> []
            | n -> 0 :: z (n-1) in
        if n > 0 then
            this#append (initdata (memsize) 
                                  (List.map string_of_int (z n)))
        else
            ()
    
    method value (v:Bits.bits) = 
        let sz = Bits.width v in
        let i  = hexbits v    in
            this#append (initdata sz [i])
        
    method addr (a: reloc) = 
        match Reloc.Simple.normalize a with
        | None,   bits -> 
            this#append (initdata (Bits.width bits) [(hexbits bits)])
        | Some s, bits ->
            this#append (luafunc "emit_raddr" 
                                 ((quoted s#mangled_text) ^ "," ^ 
                                  (quoted (hexbits bits))))

    (* should we consider throwing the comments in as Lua comments? *)
    method comment s = ()

    method private imports =
        match Strutil.Set.elements _imported with
        | []    -> ""
        | names -> luafunc "imports" 
                           (braced (String.concat "," 
                                        (List.map quoted
                                            (Strutil.Set.elements _imported))))

    method private exports =
        match Strutil.Set.elements _exported with
        | []    -> ""
        | names -> luafunc "exports" 
                           (braced (String.concat "," 
                                        (List.map quoted
                                            (Strutil.Set.elements _exported))))
    
    (* this is wrong!!! *)
    method private globals =
          luafunc "globals" "36"


    (* -- Advertise pointer sizes and such for this assembler -- *)

    method private personality =
          luafunc "memsize"   (string_of_int memsize)
        ^ luafunc "byteorder" ( match byteorder with
                                | Rtl.BigEndian    -> quoted "NATIVE"
                                | Rtl.LittleEndian -> quoted "NATIVE"
                                | _                -> assert false
                              )
        ^ luafunc "ptrsize"   (string_of_int ptrsize)
    
    method emit = 
        let toplevel = this#imports ^ this#exports ^ this#personality
                     ^ this#globals                                   in
        ( _fprintf (luafunc "end_section" "")
        ; _fprintf toplevel
        )

end    
@
