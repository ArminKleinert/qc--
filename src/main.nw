% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml

% ------------------------------------------------------------------ 
\section{Main}\label{sect:main}
% ------------------------------------------------------------------ 

This module contains the [[main]] function that is executed when the
\C~compiler starts.  Its main purposes are command line processing,
catching of exceptions, and providing the exit code.

The [[Main]] module opens the modules it most frequently uses:

<<main.ml>>=
open Pc                     (* infix parser combinators for cmd line *)
module E = Error
@

The module [[Arg]] for command line processing from the standard
library enforces an imperative programming style and can not be used
to parse highly structured command lines.  We use parser combinators
from module [[Pc]] for command line processing that capture the
structure of the command line in an abstract syntax tree which then is
processed. 

The data type [[cmd]] describes the abstract syntax of the command
line; it is defined in module [[Cmdline]].  Currently the structure is
very simple:  the command line can ask the program for different
actions:

\begin{enumerate}
\item Display a usage information: [[-help]].
\item Display a version information: [[-version]].
\item Scan a file and show the token stream: [[-lex file.c--]].
\item Parse a file and serialize it in \asdl~format: [[-asdl file.c--]].
\item Parse a file and pretty print it for a given line width: 
      [[-pp -w 72 file.c--]]
\item Check the static semantics of a file: [[-check file.c--]].
\item Generate the intermediate representation of a file: [[-ir file.c--]]
\end{enumerate}

<<cmdline.mli>>=
type cmd =        | Help                                               
                  | Version                                  
                  | Lex      of string
                  | Asdl     of string
                  | PP       of string * int
                  | Check    of string
                  | IR       of string
@

The concrete syntax of the command line is specified through the
parser combinators that recognizes them. The [[Pc]] module defines
several infix operators which makes the notation of parser combinators
rather suggestive: [[***]], [[**>]], and [[**<]] recognize a sequence
of tokens; [[**>]] returns only the string of the right hand side as a
semantic value. Semantic values are processed by functions defined on
the right hand side of [[-->]]. The string recognized by [[any]] after
a flag [[-pp] is passed to a function that injects the string into a
[[Pp]] constructor that asks to parse and pretty print a file.
  
<<main.ml>>=
let default_width = 72 

let cmd_help      = literal "-help"         --> fun _ -> Cmdline.Help
let cmd_version   = literal "-version"      --> fun _ -> Cmdline.Version
let cmd_lex       = literal "-lex" **> any  --> fun s -> Cmdline.Lex(s) 
let cmd_asdl      = literal "-asdl" **> any --> fun s -> Cmdline.Asdl(s) 
let cmd_check     = literal "-check" **>any --> fun s -> Cmdline.Check(s) 
let cmd_ir        = literal "-ir" **> any   --> fun s -> Cmdline.IR(s)
let cmd_default   = any                     --> fun s -> Cmdline.Check(s)

let cmd_width     = literal "-w" **> any    
                    --> fun s -> (try  int_of_string s 
                                  with Failure(_) -> default_width)
                    
let cmd_pp        = (literal "-pp" **> cmd_width *** any 
                    --> fun (width,file) -> Cmdline.PP(file,width)) 
                ||| literal "-pp" **> any 
                    --> fun (file)       -> Cmdline.PP(file,default_width)
@                    

Each parser recognizes a complete command line.  As an abbreviation
a single file name without flags is interpreted as an argument to the
[[-pp]] flag. 

The structure of the whole command line is recognized by the
[[cmdline]] parser: it simply recognizes the first successfully parsed
command line. The end of the command line that is recognized by
[[eof]] must terminate a successfully parsed token sequence in order
for [[cmdline]] to be successful.

<<main.ml>>=
let cmdline       = (  cmd_version 
                   ||| cmd_help 
                   ||| cmd_lex
                   ||| cmd_asdl 
                   ||| cmd_pp
                   ||| cmd_check
                   ||| cmd_ir
                   ||| cmd_default 
                    ) **< Pc.eof
@

The command line flags [[-version]] and [[-help]] trigger short
messages going to stdout.  The [[usage]] function is also called from
[[main]] when the command line syntax is wrong. 

<<main.ml>>= 
let version () =
    ( This.name     stdout 
    ; output_string stdout " "
    ; This.version  stdout 
    ; output_string stdout " (c) 2000 President and Fellows of Harvard University" 
    ; output_string stdout " http://www.cminusminus.org/"
    )
@

<<>>=
let usage this =
  let msg = 
  [   "\t -help                      (this to stdout)"
  ;   "\t -version                   (version to stdout)"
  ;   "\t -lex file.c--              (scan file)"
  ;   "\t -asdl file.c--             (parse file)"
  ;   "\t -pp [-w width] file.c--    (parse and pretty print file for width)"
  ;   "\t -check file.c--            (check static semantics of file)"
  ;   "\t -ir file.c--               (create abstract c-- )"
  ;   "\t file.c--                   (same as -check file)"
  ] in
    Printf.printf "%s command line syntax\n" this ;
    List.iter print_endline msg
@
        
For testing the parser we let the [[asdl]] function write the
abstract syntax to stdout.

<<>>=
let asdl file =
    let fd          = try open_in file 
                      with Sys_error(msg) -> E.error msg     in
    let finally ()  = close_in fd                            in
    let lexbuf      = Lexing.from_channel fd                 in
    let map         = Srcmap.empty                           in
    let scanner     = Scan.scan map                          in
    let _           = Srcmap.sync map 0 (file,1,1)           in
    let asdl ()     = let ast = Parse.program scanner lexbuf in
                         (E.Ok (AstUtil.sexp_wr_program ast stdout))
        in try asdl () with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.Error
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.Error
              )
            | e ->
              ( finally()
              ; raise e
              )
@
 
The [[main]] function gets the command line arguments and tries to
parse them using the [[cmdline]] parser.  It returns the abstract
syntax as defined in Module [[Cmdline]] which is used to decide which
function to call.  In case of no error all functions return here and
the program end with exit code zero.  However, in case of an error the
[[Error]] exception is raised and caught here.  This leads to a non
zero exit code. 

<<main.ml>>=
let main () =
    let argv        = Array.to_list Sys.argv in
    let this        = Filename.basename (List.hd argv) in
    let args        = List.tl argv in
    let (cmd,_)     = try cmdline args with Pc.Error msg -> 
                         Printf.eprintf "%s command line syntax: %s\n"
                            this msg;
                         usage this;
                         exit 1
    in
    let dispatch    = function
        | Cmdline.Help          -> usage this ; E.Ok ()
        | Cmdline.Version	-> version () ; E.Ok ()
        | Cmdline.Lex(file)     -> Scan.lex file 
        | Cmdline.Asdl(file)    -> asdl file 
        | Cmdline.PP(file,width)-> Astpp.pp file width
        | Cmdline.Check(file)   -> Check.check file
        | Cmdline.IR(file)      -> Ast2ir.ast2ir file
    in
        match E.catch E.errorPrt dispatch cmd with
            | E.Error -> exit 1
            | E.Ok _  -> exit 0
@                

In \ocaml~no [[main]] function like in C exists but simply all values
in a module are evaluated.  However, we simulate this by evaluating
[[main ()]]. 

<<>>=
let _ = try main () with e -> 
        ( Printf.eprintf "%s\n" (Printexc.to_string e)
        ; Printf.eprintf "Please report this problem to bugs@cminusminus.org\n"
        ; exit 2
        )
@
 
% ------------------------------------------------------------------  
\section{Manual Page}
% ------------------------------------------------------------------  
          
Writing manual pages for the Troff formatter is a tedious job.  I have
found the highly readable \textit{plain old document} (\textsc{pod})
format used by the Perl community very helpful.  Every Perl
installation comes with a \texttt{pod2man} tool which creates a man
page from \textsc{pod} file.  Today we can assume that Perl is
installed nearly everywhere such that the use of this tool does not
spoil portability of our code.

The format of \textsc{pod} files is documented in the \texttt{perlpod}
manual page.  Besides the \texttt{pod2man} filter there exist other
filters to convert a \textsc{pod} file to \textsc{html} and \LaTeX,
which makes it a very versatile format.

<<qc--.pod>>=
=head1 NAME

qc-- - the quick c-- compiler

=head1 SYNOPSIS

B<qc-- -version>

B<qc-- -help>

B<qc-- -lex> I<file.c-->

B<qc-- -asdl> I<file.c-->

B<qc-- -pp> [ B<-w> I<width> ] I<file.c-->

B<qc-- -check> I<file.c-->

B<qc-- -ir> I<file.c-->

=head1 DESCRIPTION

B<qc--> compiles C-- code. The compiler is still under development and
currently does not yet produce executable code.  However, it checks
the syntax and static semantics of a C-- program.  The grammar
currently accepted by B<qc--> is described in section L<"GRAMMAR">. 

=head1 OPTIONS

=over

=item B<-version>

Report the version of B<qc--> to stdout. The version is essentialy the
date the compiler was built.

=item B<-help>

Print a short usage message to stdout.

=item B<-asdl> I<file>

Parse I<file> and print the abstract syntax in ASDL format to stdout. 
The ASDL format is a cross-platform cross-compiler format to exchange
an abstract syntax.  The B<-asdl> option thus exports the abstract
syntax of a C-- program to a file which possibly can be read by
another compiler that supports ASDL as its input format.

=item B<-pp> [ B<-w> I<width> ]I<file>

Parse I<file> and write a pretty printed concrete syntax to stdout. 
The default width for output is 72 characters; it can be changed with the
B<-w> flag. 

=item B<-lex> I<file>

Scan (lex) I<file> and write a representation of the tokens in I<file> 
to stdout.

=item B<-check> I<file>

Check the static semantics of I<file>. Error messages are written to
stdout. In case of errors in the static semantics of I<file> the
compiler exits with an exit code different from 0.

=item B<-ir> I<file>

Check the static semantics of I<file> and compile it (internally) to
abstract C--. This is a development flag and produces no interesting
output. 

=back

=head1 EXIT CODE

The B<qc--> compiler returns with exit code 0 of successful
operation.  In case of errors in a source file B<qc--> returns with
exit code 1.  Any internal compiler error leads to exit code 2.

=head1 SEE ALSO

http://www.cminusminus.org/, 
http://www.cs.princeton.edu/zephyr/ASDL/

=head1 AUTHOR

Christian Lindig <lindig@eecs.harvard.edu>, 
Norman Ramsey <nr@eecs.harvard.edu>

@

<<qc--grammar.pod>>=
=head1 NAME

qc--grammar - the c-- grammar recognized by qc--(1).

=head1 DESCRIPTION

During the development of the compiler it happens easily that the
documentation of the C-- language and the language recognized by the
compiler differ.  To give at least a hint about the language
recognized by the implementation its grammar is presented here.  The
grammar is created automatically from the implementation such that
errors are less likely.  However, the grammar comes without any
further explanation.  It is only meant as a least resort when the
implementation reports an otherwise unexplainable parse error.

##grammar##


=head1 SEE ALSO

http://www.cminusminus.org/, 
http://www.cs.princeton.edu/zephyr/ASDL/

=head1 AUTHOR

Christian Lindig <lindig@eecs.harvard.edu>, 
Norman Ramsey <nr@eecs.harvard.edu>
@
          
      
% ------------------------------------------------------------------  
\section{This}
% ------------------------------------------------------------------  

To include some version information into the main binary we provide
the [[This]] module.  Its source code [[this.ml]] is created during
the build process from [[this.in]].  Currently only the version
information stays here but it is a useful place for other informations
that change frequently.  Note, that this code should \emph{note} be
used to control the behavior of the program.  We therefore write all
these informations to a stream to emphasize this.

<<this.in>>=
(* do not edit - this file is created from this.in through make(1) *)

let system	    = "@this@"

@ The functions [[name]] and [[version]] decompose the [[system]]
string to get the name and version of the system. 

<<this.in>>=
let name channel = 
    let s = try let minus = String.index system '-' in
                String.sub system 0 minus
            with Not_found -> "not configured"
    in
         output_string channel s

<<>>=
let version channel = 
    let s = try let minus = String.rindex system '-' in
                String.sub system (minus+1) (String.length system - minus - 1)
            with Not_found -> "not configured"
    in
        output_string channel s
@

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

<<this.mli>>=
val name    : out_channel -> unit
val version : out_channel -> unit 
@

