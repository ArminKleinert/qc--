
\input{macros.tex}


% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Control-Flow Graph}
% ------------------------------------------------------------------ 

For code generation, the compiler translates the dynamic part of a
{\PAL} procedure into a control flow-graph (\cfg).  Each node is
contains a target-specific register-transfer list {\rtl} that later is
translated to machine instructions. 
 
Once a procedure is translated into an initial {\cfg} it is analyzed
and according to the results rewritten gradually in a semantics
preserving way.  Analysis includes liveness analysis, modifications
include establishing the machine invariant that every {\rtl} is
representable by a machine instruction, and modifications resulting
from register allocation and spilling.

% ------------------------------------------------------------------ 
\subsection{Low-Level Types and Operations}
% ------------------------------------------------------------------ 

The {\cfg} abstraction is characterized by the following invariants:

\begin{itemize}
\item A {\cfg} contains nodes, connected by directed edges that model
      control-flow: $x \to y$ means, $y$ is a successor of $x$;  $y \gets
      x$ means, $x$ is a predecessor of $y$. 
\item A {\cfg} has an \emph{entry} and an \emph{exit} node.  A node
      may be unreachable from either the entry or exit node, or from
      both.
\item The nodes of a {\cfg} can be numbered $1, \dots,
      |\mathit{cfg}|$.  A numbering for the nodes of a {\cfg} is
      either \emph{present} or \emph{absent}.  If and only if a
      numbering is present, then every node of a {\cfg} has unique
      number.
\item A node belongs to exactly one {\cfg}.
\item A node has a \emph{kind} that defines its behavior and contains
      a matching {\rtl} defining its semantics.  
\item The number of outgoing edges (to successors) is constrained by a
      node's kind. A node can have any number of successors, including
      zero. 
\item A node and its neighbors, i.e.~its successors and predecessors
      are consistent: if and only if $x \to y$, then $y \gets x$.
\item A node contains a set of registers live \emph{before} it with
      respect to the linear order.
\end{itemize}

The interface below shows that graphs and nodes have an imperative
nature. A control-flow graph is generally built bottom-up: all node
creation functions take succeeding nodes as arguments. Functions can
mutate a node, a graph, both, or none. To indicate the different
behaviors, the following name scheme is used:

\begin{itemize}
\item Functions mutating a node or the mapping of labels to nodes are
      prefixed by [[set_]].
\item Function mutating a control-flow graph are prefixed by [[gm_]]
      (graph mutator).
\item Observation functions have no special prefix.
\end{itemize}

<<types and ops>>=
type cfg
type node
<<type conts>>
<<type formal>>
<<type actual>>

(* cfg creation *)
val mk:         unit -> cfg

(* label mutator/oberservation *)
val set_label:  cfg -> string -> node -> unit
val lookup:     cfg -> string -> node                 (* Not_found *)

(* cfg observation *)
val entry:      cfg -> node
val exit:       cfg -> node
val enumerated: cfg -> bool                  (* true, iff nodes are numbered *)
val fold:       cfg -> (node -> 'a -> 'a) -> 'a -> 'a (* must not use gm_xxx *)
val scan_fwd:   cfg -> (node -> 'a -> 'a) -> 'a -> 'a (* must not use gm_xxx *)
val scan_bwd:   cfg -> (node -> 'a -> 'a) -> 'a -> 'a (* must not use gm_xxx *)
val forward:    cfg -> node -> node option
val backward:   cfg -> node -> node option

(* add node to cfg *)
val gm_assign:  cfg -> Rtl.rtl -> succ:node -> node
val gm_return:  cfg -> Rtl.rtl -> int * int -> node
val gm_goto:    cfg -> Rtl.rtl -> node list -> node
val gm_jump:    cfg -> Rtl.rtl -> node list -> node
val gm_cutto:   cfg -> Rtl.rtl -> conts     -> node
val gm_call:    cfg -> Rtl.rtl -> conts -> succ:node -> node
val gm_branch:  cfg -> Rtl.rtl -> ifso:node -> ifnot:node -> node
val gm_dummy:   cfg -> node

(* add linear sequence of assign nodes to cfg *) 
val gm_copyi:   cfg -> formal list -> Automaton2.t -> succ:node -> node * Automaton2.t
val gm_copyo:   cfg -> actual list -> Automaton2.t -> succ:node -> node * Automaton2.t

(* cfg mutators *)
val gm_delete:                  node -> unit
val gm_redirect_all:            node -> from:node -> dest:node -> unit
val gm_insert_assign_before:    node -> Rtl.rtl -> unit (* assign node only *)
val gm_insert_assign_after:     node -> Rtl.rtl -> unit (* assign node only *)
val gm_enumerate:               cfg -> unit             

(* node observation *)
val cfg:        node -> cfg
val rtl:        node -> Rtl.rtl
val succ:       node -> node list       (* no duplicates *)
val pred:       node -> node list       (* no duplicates *)
val live:       node -> Register.Set.t
val number:     node -> int             (* precond: cfg is enumerated *)

(* node mutators *)
val set_live:   node -> Register.Set.t -> unit (* set live set *)
val set_rtl:    node -> Rtl.rtl -> unit
@

% ------------------------------------------------------------------ 
\subsubsection{Graph creation}
% ------------------------------------------------------------------ 

\begin{description}
\item[mk] 
    Creates an empty {\cfg} that just contains an entry node connected
    to an exit node. Numbering of nodes is absent and no labels are defined.
\end{description}

% ------------------------------------------------------------------ 
\subsection{Graph observation}
% ------------------------------------------------------------------ 

\begin{description}
\item[entry]
    The {\cfg}'s unique entry node.
\item[exit]     
    The {\cfg}'s unique exit node.
\item[enumerated]
    True, if the nodes of the {\cfg} are currently numbered. A
    numbering is destroyed by any node mutation function, like adding
    a node.

\item[fold]     
    Traverses the nodes of the {\cfg} in a ``natural'' order.  It is
    an unchecked run-time error if the function passed to [[fold]]
    calls a graph mutator.

\item[scan\_fwd]
    Like [[fold]], except that nodes are visited in their numbered
    order.  It is a checked run-time error if no order is present.  It
    is an unchecked run-time if [[scan_fwd]] calls a graph mutator. 
    
\item[scan\_bwd]
    Like [[scan_fwd]] except that nodes are visited in the reverse order.

\item[forward]
    The next node in numbered order or [[None]] if the [[node]]
    argument is the last node.  It is a checked run-time error if
    numbering is absent.
    
\item[backward]
    The previous node in numbered order or [[None]] if [[node]] is the
    first node. It is a checked run-time error is numbering is absent.
\end{description}

% ------------------------------------------------------------------     
\subsubsection{Labels}
% ------------------------------------------------------------------ 

\begin{description}
\item[set\_label]    
    Assign a label to a node.  It is a checked run-time error if the
    node does not belong to the {\cfg}.  It is also a checked run-time
    error to assign a label twice.

\item[lookup]   
    Lookup a node by name.  If a node has a label of that name, the
    node is returned, otherwise [[Not_found]] is raised.
\end{description}

% ------------------------------------------------------------------ 
\subsubsection{Node Creation}
% ------------------------------------------------------------------ 

The kind of a node is encoded into the function that creates it. 
Depending on its kind, a node takes a number of arguments:  the graph
it belongs to, an {\rtl} and its successors.  The [[cutto]] and
[[call]] nodes take a continuation bundle that includes several nodes,
denoting continuations that can be reached from that node.

<<type conts>>=
type conts =    { cuts    : node list
                ; unwinds : node list
                ; returns : node list
                ; aborts  : bool
                }
@

The creation of a node also adds it to the {\cfg}; because of this,
all node creation functions are marked as graph mutators.  Graph
mutators must not be called by certain functions that traverse a
{\cfg}.  All graph mutators cause a node numbering to become
\emph{absent}.


A [[dummy]] node is its own successor.  It is used as a placeholder
for labeled nodes that are not yet defined.  Use [[redirect]] to
update its successor. 

Parameter passing is implemented by sequences of [[assign]] nodes that
transfer parameters from location determined by calling conventions to
registers, and vice versa.  These sequences of assignments are created
by functions \emph{copy-in} and \emph{copy-out} that take their
successor as argument return the topmost node of the sequence they
create.  Calling conventions are implemented by automata that are
passed to the functions and returned in an advanced state.  The
[[copyi]] function implements receiving parameters, the [[copyo]]
function passing actual parameters. 

<<type formal>>=
type formal =   { name:      string 
                ; width:     Rtl.width       (* bits *)
                ; hint:      string option   (* C-- hint *)
                ; index:     int             (* run-time API index*)
                } 

<<type actual>>=
type actual     = Rtl.exp 
                * Rtl.width 
                * string option               (* hint *)
@

% ------------------------------------------------------------------ 
\subsubsection{Graph Mutation}
% ------------------------------------------------------------------ 

All graph mutations destroy node \emph{numbering} and must not be used
while traversing a graph.

\begin{description}
\item[delete] 
    Deletes a node from a [[cfg]].  It is a checked run-time
    error, if:  the node has any successor, is an exit, or is an entry
    node.

\item[redirect\_all] 
    An outgoing edge (to a successor) can be redirected to
    another node.  The current successor and the new successor must be
    provided.  It is a checked run-time error if:  nodes belong to
    different {\cfg}s, or the [[from]] node is not an actual
    predecessor.

    Note, that if several outgoing edges of a node point to the same
    successor, they \emph{all} get updated to the new node.  Hence,
    [[redirect]] is not fully general.

\item[insert\_assign\_before] 
    Inserts an [[assign]] node $a$ before a node $n$,
    using the supplied {\rtl}.  It is a checked run-time error if the
    node $n$ was not created by the [[assign]] function.  The
    successors of $n$ become successors of $a$ and $a$ becomes the
    only successor of $n$.
                 
\item[insert\_assign\_after] 
    Like [[ins_before]], except that the assign node is
    placed after the node.  Since the node must be an [[assign]] node,
    it has only one outgoing edge and therefore this operation is well
    defined.  

\item[enumerate]
    Establishes a numbering for all nodes of a {\cfg}; until a
    graph mutator is called, [[numbered]] returns [[true]].
\end{description}

% ------------------------------------------------------------------ 
\subsubsection{Node Oberservation}
% ------------------------------------------------------------------ 

The observation functions for nodes return the obvious values.  Every
node contains a (mutable) set of registers; this set is empty in a new
node. 

\begin{description}
\item[live] 
    Registers live \emph{before} this node.

\item[number] 
    Reports the number of a node. It is a checked run-time
    error to invoke this function if node numbering is absent,
    i.e.~[[numbered]] is [[false]].
\end{description}

% ------------------------------------------------------------------ 
\subsubsection{Node Mutators}
% ------------------------------------------------------------------ 

Node mutators are considered generally ``safe'' because they don't
interact with other functions. 

\begin{description}
\item[set\_live] 
    Updates the live-set of a node.
    
\item[set\_rtl]
    Set the {\rtl} of a node to a new value.
\end{description}


% ------------------------------------------------------------------ 
\subsection{Putting the Interface together}
% ------------------------------------------------------------------ 

Here are some dummy signatures to make the interface self-contained. 
This can be used to play with implementation in the {\ocaml}
interpreter. 

<<dummy sigs>>=
module Rtl : sig 
    type rtl 
    type exp 
    type width
    val null: rtl
end

module Register : sig
    module Set : sig
        type t
    end
end

module Automaton2 : sig
    type t
end
@

<<cfg3.mli>>=
(** dummy sigs **)
module type S = sig
    <<types and ops>>
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<cfg3.ml>>=
(* postponed *)
@

