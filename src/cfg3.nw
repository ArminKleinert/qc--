
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Control-Flow Graph}
% ------------------------------------------------------------------ 

For code generation, the compiler translates the dynamic part of a
{\PAL} procedure into a control flow-graph (\cfg).  Each node contains
a target-specific register-transfer list {\rtl} that later is
translated into machine instructions. 
 
Once a procedure is translated into an initial {\cfg} it is analyzed
and according to the results rewritten gradually in a semantics
preserving way.  Analysis includes liveness analysis, modifications
include establishing the machine invariant that every {\rtl} is
representable by a machine instruction, and modifications resulting
from register allocation and spilling.

Nodes of a {\cfg} can take part in two relations simultaneously: 
\begin{enumerate}
\item Control-flow relation. These are represented by the edges
      between nodes and model possible flow of control ar run-time. 
\item Order relation. For the node of a {\cfg} a linear-order can be
      established. This order is used for code-layout and during
      analysis phases. 
\end{enumerate}

% ------------------------------------------------------------------ 
\subsection{Abstractions}
% ------------------------------------------------------------------ 

The {\cfg} abstraction is characterized by the following invariants:

\begin{itemize}
\item A node belongs to exactly one {\cfg}.

\item A {\cfg} contains nodes, connected by directed edges that model
      control-flow: $x \to y$ means, $y$ is a successor of $x$.

\item A node has a fixed \emph{kind} that constraints some of its
      properties, like the number of control-flow successors. In
      particular, a node's kind is one of the following:

      \begin{tabular}{ll}
      \it kind & \it represented {\PAL} entity \\ 
      \hline
      entry     & unique node in every {\cfg} \\
      exit      & unique node in every {\cfg} \\
      assign    & assignment, like [[bits32[x] = y]]\\
      goto      & [[goto]] \\
      jump      & [[jump]] \\
      cutto     & [[cutto]] \\
      call      & procedure call, [[f(x,y)]]\\
      branch    & [[if]]-statement\\
      dummy     & none, used for undefined labels internally\\
      \end{tabular}
      
\item A {\cfg} has unique \emph{entry} and \emph{exit} nodes.  A node
      may be unreachable from either the entry or the exit node, or
      from both.
        
      \begin{quote}\it
      Since reachability of all nodes is desirable at least from the
      entry or the exit node we might introduce \emph{impossible}
      edges to guarantee this. 
      \end{quote}
      
\item The nodes of a {\cfg} can be numbered $1, \dots,
      |\mathit{cfg}|$.  A numbering for the nodes of a {\cfg} is
      either \emph{present} or \emph{absent}.  If and only if a
      numbering is present, then every node of a {\cfg} has unique
      number.  The order is used by the code generation phase to
      define the code layout in memory.
      
\item The number of outgoing edges (to successors) is constrained by a
      node's kind. A node can have any number of successors, including
      zero, for example:
      \begin{enumerate}
      \item An assignment-node has one (control-flow) successor.
      \item A (conditional) branch-node has two successors.
      \item A call-node has one default successor and possibly many 
            exceptional successors.
      \end{enumerate}

\item A node \emph{defines}, \emph{uses}, and \emph{kills} locations.
\item A node has mutable properties.
\end{itemize}

The interface below shows that graphs and nodes have an imperative
nature.  A control-flow graph is generally built bottom-up:  all
node-creation functions take succeeding nodes as arguments.  Functions
can mutate a node, a graph, both, or none.  To indicate the different
behaviors, the following name scheme is used:

\begin{itemize}
\item Functions mutating a node or the mapping of labels to nodes are
      prefixed by [[set_]].
\item Function mutating a control-flow graph are prefixed by [[gm_]]
      (graph mutator).
\item Observation functions have no special prefix.
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Signature}
% ------------------------------------------------------------------ 

<<types and ops>>=
type cfg        
type t = cfg                    (* Cfg.t looks JustBetter *)
type node
type locs = Register.Set.t      (* locations for liveness analysis *)

(* abstract type for data inside nodes *)
type property

<<type conts>>
 
(* cfg creation *)
val mk:         unit -> cfg

(* label mutator/observation *)
val set_label:  cfg -> string -> node -> unit
val lookup:     cfg -> string -> node  (* never fails -- see description *)

(* cfg observation, fold order unspecified *)
val entry:      cfg -> node 
val exit:       cfg -> node 
val fold_fwd:   cfg -> (node -> 'a -> 'a) -> 'a -> 'a (* must not use gm_xxx *)
val fold_bwd:   cfg -> (node -> 'a -> 'a) -> 'a -> 'a (* must not use gm_xxx *)

(* switch to open intervall semantics? first:int -> limit:int *)
(* cfg traversal in linear order, requires (enumerated cfg)  *)
val first:      cfg -> node (* wrt numbering *)
val last:       cfg -> node (* wrt numbering *)
val scan_fwd:   cfg -> first:int -> last:int -> (node -> 'a -> 'a) -> 'a -> 'a 
val scan_bwd:   cfg -> first:int -> last:int -> (node -> 'a -> 'a) -> 'a -> 'a
val next:       node -> node option
val prev:       node -> node option

(* add node to cfg, ensures: not (enumerated cfg) *)
val gm_assign:  cfg -> Rtl.rtl -> succ:node -> node
val gm_return:  cfg -> Rtl.rtl -> int * int -> node
val gm_goto:    cfg -> Rtl.rtl -> node list -> node
val gm_jump:    cfg -> Rtl.rtl -> node list -> node
val gm_cutto:   cfg -> Rtl.rtl -> conts     -> node
val gm_call:    cfg -> Rtl.rtl -> conts -> succ:node -> node
val gm_branch:  cfg -> Rtl.rtl -> ifso:node -> ifnot:node -> node
(*  used only internally - no reason to export
 *  val gm_dummy:   cfg -> node
 *)
(* dataflow-design is bogus *)
val gm_dataflow: cfg -> defs:locs -> uses:locs -> kills:locs -> succ:node -> node

(* cfg mutators, ensures: not (enumerated cfg) *)
val gm_redirect_all:            src:node -> olddst:node -> newdst:node -> unit
val gm_insert_assign_before:    Rtl.rtl -> node -> unit (* any node   *)
val gm_insert_assign_after:     Rtl.rtl -> node -> unit (* see descr! *)
val gm_insert_assign_between:   Rtl.rtl -> src:node -> dst:node -> unit
val gm_insert_dataflow_between: defs:locs -> uses:locs -> kills:locs ->
                                src:node -> dst:node -> unit
val gm_enumerate:               cfg -> unit (* post: enumerated cfg *)

(* node observation *)
val cfg:        node -> cfg
val rtl:        node -> Rtl.rtl
val succ:       node -> node list 
val pred:       node -> node list
val property:   node -> property
val number:     node -> int             (* pre: enumerated cfg *)
val defs:       node -> locs            (* locs defined by node *)
val uses:       node -> locs            (* locs used by node    *)
val kills:      node -> locs            (* locs killed by node  *)

(* node mutators *)
val set_rtl:        node -> (Rtl.rtl -> Rtl.rtl) -> unit
val set_property:   node -> property -> unit 
@

% ------------------------------------------------------------------ 
\subsection{Description}
% ------------------------------------------------------------------ 

% ------------------------------------------------------------------ 
\subsubsection{Graph creation}
% ------------------------------------------------------------------ 

\begin{quote}\it
The typesetting of signatures below is ugly because I'm lacking an
idea and a \LaTeX~macros to do it better.  Duplicating signatures
manually is in addition prone to inconsistencies.  --CL 
\end{quote}

\begin{itemize}
\item [[mk:  unit -> cfg]]:  
Creates an empty {\cfg} that just contains an entry node connected to
an exit node.  Numbering of nodes is absent and no labels are defined.
\end{itemize}

% ------------------------------------------------------------------     
\subsubsection{Labels}
% ------------------------------------------------------------------ 

\begin{itemize}
\item [[set_label:  cfg -> string -> node -> unit]]: 
Assigns label to a node.  It is a checked run-time error if the node
does not belong to the {\cfg}.  It is also a checked run-time error to
assign a label twice.

\item [[lookup:  cfg -> string -> node]]: 
Looks up a node by a label.  If a node was assigned that label before
it is returned.  Otherwise a [[dummy]] node is created, labeled, and
returned.
\end{itemize}

% ------------------------------------------------------------------ 
\subsubsection{Graph observation}
% ------------------------------------------------------------------ 

\begin{itemize}
\item [[entry: cfg -> node]]:
The {\cfg}'s unique entry node.

\item [[exit: cfg -> node]]:
The {\cfg}'s unique exit node.
\end{itemize}

% ------------------------------------------------------------------ 
\subsubsection{Graph Traversal}
% ------------------------------------------------------------------ 

\begin{itemize}

\item 
\begin{verbatim}
fold_fwd: cfg -> (node -> 'a -> 'a) -> 'a -> 'a
fold_bwd: cfg -> (node -> 'a -> 'a) -> 'a -> 'a
\end{verbatim}

Traverses the graph in \emph{unspecified} order and passes each
[[node]] and an intermediate result [['a]] to the function [[f]] that
is supplied as the second argument.  It is an \emph{unchecked}
run-time error if [[f]] calls a graph mutator.  The forward-folding
function [[fold_fwd]] traverses the graph such that the majority of
edges are followd in control-flow direction, the backward-folding
function [[fold_bwd]] such that most edges are followed in reverse
control-flow direction.
\end{itemize}

All traversal functions below rely on and respect a numbering that
must be established by [[gm_enumerate]] before these functions can be
used.  Using any of the traversal functions without an established
order is a checked run-time error.  Any use of a graph mutator
function invalidates an existing numbering.

\begin{itemize}
\item [[first: cfg -> node]]:
The first node with respect to numbering.

\item [[last: cfg -> node]]:
The last node with respect to numbering.

\item [[scan_fwd: cfg -> first:int -> last:int -> (node -> 'a -> 'a) -> 'a -> 'a]]: 
Applies a function [[f]] to the range of nodes from [[first]] to
[[last]] and passes an intermediate result.  The nodes are visited in
increasing order with respect to the numbering.  It is an
\emph{unchecked} run-time error if [[f]] calls a graph mutator; in
order for [[f]] being applied to nodes [[first]]] $\leq$ [[last]] must
hold, otherwise the intermediate result [['a]] is returned.

\item [[scan_bwd: cfg -> first:int -> last:int -> (node -> 'a -> 'a) -> 'a -> 'a]]:
Dual function to [[scan_fwd]] in the sense that nodes are visited in
decreasing order, starting with the node numbered [[last]].  Note,
that [[first]] $\leq$ [[last]] still must hold.

\item [[next: node -> node option]]:
The node following the argument [[node]] with respect to an
established node numbering or [[None]] if there is no such node.

\item [[prev: node -> node option]]:
Dual to [[next]]:  the node prior to the argument with respect to a
node numbering, or [[None]] if no such node exists.
\end{itemize}

% ------------------------------------------------------------------ 
\subsubsection{Node Creation}
% ------------------------------------------------------------------ 

Nodes are created by functions that encode their kinds and depending
on them take different arguments:  the graph a node belongs to, an
{\rtl} and its successors.  The [[cutto]] and [[call]] nodes take a
continuation bundle that includes several nodes, denoting
continuations that can be reached from that node.

<<type conts>>=
type conts =    { cuts    : node list
                ; unwinds : node list
                ; returns : node list
                ; aborts  : bool
                }
@

The creation of a node also adds it to the {\cfg}; because of this,
all node creating functions are marked as graph mutators.  Graph
mutators must not be called by traversal functions.  Using a mutator
causes a node numbering to become \emph{absent}.

\begin{verbatim}
gm_assign:  cfg -> Rtl.rtl -> succ:node -> node
gm_return:  cfg -> Rtl.rtl -> int * int -> node
gm_goto:    cfg -> Rtl.rtl -> node list -> node
gm_jump:    cfg -> Rtl.rtl -> node list -> node
gm_cutto:   cfg -> Rtl.rtl -> conts     -> node
gm_call:    cfg -> Rtl.rtl -> conts -> succ:node -> node
gm_branch:  cfg -> Rtl.rtl -> ifso:node -> ifnot:node -> node
gm_dummy:   cfg -> node
gm_dataflow: cfg -> def:locs -> use:locs -> kill:locs -> succ:node -> node
\end{verbatim}

A [[dummy]] node has one successor which is initially set to itself. 
Use [[gm_redirect_all]] to redirect its outgoing edge to a different
node.  Dummy nodes are used as place holders for labeled nodes that
are not yet defined.  

A [[gm_dataflow]] node has one successor and takes lists for the
locations it uses, defines, and kills explicitly.  It does not
generate code but its sole purpose is to provided data-flow
information.

% Parameter passing is implemented by sequences of [[assign]] nodes that
% transfer parameters from location determined by calling conventions to
% registers, and vice versa.  These sequences of assignments are created
% by functions \emph{copy-in} and \emph{copy-out} that take their
% successor as argument return the topmost node of the sequence they
% create.  Calling conventions are implemented by automata that are
% passed to the functions and returned in an advanced state.  The
% [[copyi]] function implements receiving parameters, the [[copyo]]
% function passing actual parameters. 
% 
% Formal parameters are implicitly declared local registers when used
% for procedures.  A continuation's formal parameter must be an already
% declared local \emph{or global} register.  Since local registers are
% basically represented as names, but global registers as abstract
% locations of type [[Automaton2.loc]], the [[formal]] type must
% accommodate both.
% 
% ((type formal))=
% type repr       = Local  of  string           (* name            *)
%                 | Global of  Alloc.Reg.loc    (* abstr. location *)     
%                 
% type formal =   { width:    Rtl.width
%                 ; hint:     string option
%                 ; repr:     repr              (* representation *)
%                 }
%                  
% ((type actual))=
% type actual     = Rtl.exp 
%                 * Rtl.width 
%                 * string option               (* hint *)
% @

% ------------------------------------------------------------------ 
\subsubsection{Graph Mutation}
% ------------------------------------------------------------------ 

All graph mutations destroy node \emph{numbering} and must not be used
while traversing a graph.

\begin{itemize}
\item [[gm_redirect_all: node -> olddst:node -> newdst:node -> unit]]:
An outgoing edge (to a successor) can be redirected to another node. 
The current successor [[olddst]] and the new successor [[newdst]] must
be provided.  It is a checked run-time error if:  nodes belong to
different {\cfg}s, or [[olddst]] is not an actual successor.

Note, that if several outgoing edges of a node point to the same
successor, they \emph{all} get updated to the new node.  Hence,
[[gm_redirect_all]] is not fully general.

\item [[gm_insert_assign_before:    Rtl.rtl -> node -> unit]]:
Inserts an [[assign]] node $a$ before a node $n$, using the
supplied {\rtl}.  It is a checked run-time error if the node $n$
was not created by the [[gm_assign]] function.  The successors of
$n$ become successors of $a$ and $a$ becomes the only successor of
$n$.
                 
\item [[gm_insert_assign_after: Rtl.rtl -> node -> unit]]:
Like [[insert_assign_before]], except that the assign node is placed
after the node which must be an [[assign]] node.  This guarantees that
it has only one outgoing edge and therefore this operation is well
defined. 

\item [[gm_insert_assign_between: Rtl.rtl -> src:node -> dst:node -> unit]]:
Inserts an assign node on every edge leading from [[src]] to [[dst]]. 
The predecessor/successor relationship of all nodes is updated to
reflect the insertion of the assign node on all affected edges. 
It is a checked run-time error, if no edge between [[src]] and [[dst]] exists.

\item
\begin{verbatim}
gm_insert_dataflow_between: defs:locs -> uses:locs -> kills:locs ->
                            src:node -> dst:node -> unit
\end{verbatim}
Inserts a node between [[src]] and [[dst]] that announces locations
being defined, used, and killed.  This node is used to provide
data-flow analysis about inter-procedural data-flow that can not be
deduced from the other nodes.  It is a checked run-time error, if no
edge between [[src]] and [[dst]] exists.

\item [[gm_enumerate: cfg -> unit]]:
Establishes a numbering for all nodes of a {\cfg}; until a graph
mutator is called the numbering is \emph{present}.

\end{itemize}

% ------------------------------------------------------------------ 
\subsubsection{Node Observation}
% ------------------------------------------------------------------ 

\begin{itemize}
\item [[cfg: node -> cfg]]: The {\cfg} the [[node]] belongs to.

\item [[rtl: node -> Rtl.rtl]]: The {\rtl} that is part of [[node]].

\item [[succ: node -> node list]]: The list of control-flow successors
of [[node]].

\item [[pred: node -> node list]]: The list of control-flow
predecessors of [[node]].

\item [[val property: node -> property]]:
The property associated with this node.

\item [[number:  node -> int]]:  Reports the number of a node.  It is
a checked run-time error to invoke this function if node numbering is
absent.

\item 
\begin{verbatim}
defs:       node -> Rtl.loc list    
uses:       node -> Rtl.loc list    
kills:      node -> Rtl.loc list    
\end{verbatim}

Each function returns locations that are defined, uses, or killed by
[[node]].  
\end{itemize}

\begin{quote}\it
    The register allocation phase takes a more abstract view 
    for numbering nodes by using a [[Point.t]] type. A [[Point.t]]
    must provide one value [[Point.zero]] which is never assigned to a
    node. The current design of using integers to number nodes and let
    numbering start at 1 is compatible with that view. Maybe the
    connection should be made more explicit. -CL
\end{quote}
% ------------------------------------------------------------------ 
\subsubsection{Node Mutators}
% ------------------------------------------------------------------ 

Node mutators update state that is local to a node/ They are safe to
be used during graph-traversal because they don't interact with other
functions. 

\begin{itemize}
\item [[set_rtl: node -> (Rtl.rtl -> Rtl.rtl) -> unit]]:
Set the {\rtl} of a node to a new value using a mapping function.

\item [[set_property:  node -> property -> unit]]:
Set the properties associated with the [[node]] at hand.
\end{itemize}


% ------------------------------------------------------------------ 
\subsection{Putting the Interface together}
% ------------------------------------------------------------------ 

<<cfg3.mli>>=
module type S = sig
    <<types and ops>>
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The interface hides the details of [[node]] and [[cfg]] but it is
clear that nodes come in different kinds, all sharing the same type
[[node]].  In the classical functional programming style this would
enforce a representation that supports all kinds at once and
observation functions that distinguish between the kinds.  Existential
types as provided by the object-oriented sub-language of {\ocaml}
provide a better solution:  a single type like [[node]] can have
mutiple implementations, each for every kind.  Because the
object-oriented style also integrates with the imperative nature of
the interface we chose to use it to implement the control-flow graph.
To avoid name-clashes for useful names like [[cfg]] and [[node]], the
implementation lives in its own sub-module [[X]]. The implementation
of the exported functions refers simply to [[X]].

<<cfg3.ml>>=
module type S = sig
    <<types and ops>>
end

module X = struct
    <<module X>>
end

type cfg  = X.cfg       (* class type cfg  *)
type t    = cfg         (* alias           *)
type node = X.node      (* class type node *)
<<type conts>>          (* continuation bundle *)
@

% ------------------------------------------------------------------ 
\subsection{Object-Oriented Implementation}
% ------------------------------------------------------------------ 

The {\cfg} implementation is build around two central class types,
[[cfg]] and [[node]], that provide the functionality of {\cfg}s and
their nodes respectively.  The [[cfg]] class has one implementation,
the [[node]] class one for every kind of node.  However, they all
implement the same class type. 

A [[node]] has a fixed number of outgoing edges to successors that are
initialized when the node is created. Edges can be updated using
[[upd_succ]] but the number of edges is fixed.

The implementation of labels requires a third class type [[proxy]]
which is a sub-class type of [[node]]. A [[proxy]] node holds a label
for a node that is not yet defined. Its distinct feature is, that an
edge to a successor can be added later after the proxy was created.
This allows to point the proxy to the node that really should hold the
label, once this node is defined.

<<module X>>=
class type cfg = object
    method entry:       node            (* entry node of this *)
    method exit:        node            (* exit node of this *)
    method lookup:      string -> node  (* find labeled node *)
    method set_label:   string -> node -> unit  (* assign label to node *)
    
    method add:         node -> unit    (* add node to this *)
    method enumerate:   unit -> unit    (* enumerate all node in this *)
    method get_id:      unit -> int     (* unique *)
end
@

\begin{itemize}
\item [[entry]] is the entry-node of this {\cfg}. The entry node
      has the [[exit]] node as its successor initially.

\item [[exit]] is the exit-node of this {\cfg} and is initially the successor
      of the [[entry]] node.

\item [[lookup]] returns a labeled node. If no such node exists [[lookup]]
      creates a [[proxy]] node under that label and returns it. The
      fact that the returned node is a [[proxy]] is hidden and can't
      be exploited.

\item [[set_label]] attaches a label to an existing [[node]] in this {\cfg}.
      If the label was previously looked up and therefore a [[proxy]]
      node exists under that label, the provided [[node]] becomes the
      proxy's successor.  It is an checked run-time error if [[node]]
      does not belong to this {\cfg}. 
      
\item [[add]] adds a node to this {\cfg}. 

\item [[enumerate]] assigns numbers $1,2,\dots$ to the nodes in this
      {\cfg}.

\item [[get_id]] returns a unique number (in this {\cfg}) at every
      invocation.  Used by nodes for their unique ID.
\end{itemize}


<<module X>>=
and node = object
    method cfg:         cfg             (* cfg this belongs to *)
    method rtl:         Rtl.rtl         (* rtl of this *)
    method id:          int             (* int of this *)
    method number:      int             (* number of this; req:cfg enumerated *)
    method succ:        node list       (* cf successors of this *)
    method pred:        node list       (* cf predecessors of this *)

    method link_pred:   node -> unit    (* add    in-edge from to pred node *)
    method unlink_pred: node -> unit    (* remove in-edge from to pred node *) 
    method upd_pred:    (node -> node) -> unit (* redirect preds of this *)
    method upd_succ:    (node -> node) -> unit (* redirect succs of this *)
end
@

\begin{itemize]
\item [[cfg]] is the {\cfg} this node belongs to.
\item [[rtl]] is the {\rtl} belonging to this node.
\item [[id]] is the identification of this node. It is unique within
      its [[cfg]].
\item [[number]] the number of this node. It is a checked run-time
      error to invoke this method if the [[cfg]] is not enumerated.
\item [[succ]] are succeeding control-flow nodes.
\item [[pred]] are preceding control-flow nodes.
\item [[link_pred]] informs this node that another node has become a
      predecessor of this node. 
\item [[unlink_pred]] informs this node that a given node is no longer
      a predecessor of this node. It is a checked run-time error if
      the node at hand is not a predecessor of this node.
\item [[upd_pred]] updates links to predecessors from [[this]] using 
      a map-function.
\item [[upp_succ]] updates links to successors using a map-function.
      Note that a map-function can collapse different links to a
      single node but can't reverse the effect.
\end{itemize}      

<<module X>>=
class type proxy = object
    inherit node
    method set_succ: node -> unit       (* set succ for this *)
end
@

% ------------------------------------------------------------------ 
\subsection{Auxiliaries}
% ------------------------------------------------------------------ 

<<module X>>=
module NodeSet = Set.Make(struct type t=node   let compare=compare end)
<<type conts>>

let compare x y = compare x#id y#id
@

The function [[nodup]] removes adjacent duplicates (according to the
comparison function [[cmp]]) from a list.  

<<module X>>=
let rec nodup cmp = function
    | x::(y::_ as tail) -> if cmp x y = 0 
                           then nodup cmp tail
                           else x :: nodup cmp tail
    | x                 -> x
@

The [[uniq]] function returns a duplicate-free list of nodes from a
list of nodes.  We use this function to compute duplicate-free list of
successors and predecessors below.
    
<<module X>>=
let uniq nodes = nodup compare (List.sort compare nodes)   
@

% ------------------------------------------------------------------ 
\subsection{Classes}
% ------------------------------------------------------------------ 

<<module X>>=
class graph: cfg =
object (this)
    val         _labels         = (Hashtbl.create 47: (string,node) Hashtbl.t)
    val         _dummies        = (Hashtbl.create 47: (string,proxy) Hashtbl.t)
    val mutable _nodes          = NodeSet.empty
    val mutable _id             = 0
    val mutable _enumerated     = false
    val mutable _enumeration    = (None: node array option)
    val mutable _entry          = (None: node option)
    val mutable _exit           = (None: node option)

    initializer
        let bot = new exit  (this:>cfg)     in
        let top = new entry (this:>cfg) bot in
            ( _entry <- Some top
            ; _exit  <- Some bot 
            )

    method entry =
        match _entry with
        | None      -> assert false
        | Some node -> node
    
    method exit =
        match _exit with
        | None      -> assert false
        | Some node -> node

    method lookup label =
        try Hashtbl.find _labels label
        with Not_found ->
            try (Hashtbl.find _dummies label :> node)
            with Not_found ->
            let (d:proxy) = new dummy (this :> cfg) in
                ( Hashtbl.add _dummies label d 
                ; this#add (d :> node)
                ; (d :> node)
                )
                
    method set_label label node =
        assert (NodeSet.mem node _nodes);       (* node#cfg = (this:>cfg) *)
        try 
            let d = Hashtbl.find _dummies label in
                d#set_succ node
        with Not_found ->
            Hashtbl.add _labels label node
            
    method add node =
        ( _enumerated <- false
        ; _nodes <- NodeSet.add node _nodes
        )

    method enumerate () =
        ( _enumerated <- true 
        )

    method get_id () =
        ( _id <- _id + 1
        ; _id
        )
end

and virtual vnode cfg rtl =
object(this)
    val mutable _pred = NodeSet.empty
    val mutable _rtl  = (rtl: Rtl.rtl)
    val         _cfg  = cfg
    val mutable _id   = (cfg#get_id ())
    val mutable _num  = -1 
    
    initializer
        _cfg#add (this :> node)

    method cfg      = _cfg
    method rtl      = _rtl
    method pred     = NodeSet.elements _pred
    method succ     = ([]: node list)   (* make virtual? *)
    method id       = _id
    method number   = _num
    
    method upd_succ map =               (* make virtual? *)
        ()
    
    method link_pred node =
        _pred <- NodeSet.add node _pred
        
    method unlink_pred node =
        assert (NodeSet.mem node _pred);
        _pred <- NodeSet.remove node _pred
    
    method upd_pred map =
        let nodes = this#pred in
        let nodes = List.map map nodes in
        let nodes = List.fold_right NodeSet.add nodes NodeSet.empty in
            _pred <- nodes    
end 

and virtual vcut cfg rtl (conts: conts) =
object (this)
    inherit vnode cfg rtl

    val mutable _cuts    = conts.cuts
    val mutable _unwinds = conts.unwinds
    val mutable _returns = conts.returns
    val _aborts          = conts.aborts

    initializer
        let succ = List.concat [_cuts;_unwinds;_returns] in
            List.iter (fun n -> n#link_pred (this:>node)) succ

    method virtual succ     : node list
    method virtual upd_succ : (node -> node) -> unit
end 

and dummy cfg: proxy =
object(this)
    inherit vnode cfg Rtl.null

    val mutable _succ = (None: node option) 

    method set_succ node =
        _succ <- Some node
    
    method succ =
        match _succ with
            | None   -> []
            | Some n -> [n]
    
    method upd_succ map =
        match _succ with
            | None   -> ()
            | Some n -> _succ <- Some (map n)
end

and entry cfg exit: node =
object(this)
    inherit vnode cfg Rtl.null

    val mutable _succ = (exit:node)
    
    method succ = [_succ]
    method upd_succ map = 
        _succ <- map _succ
end

and exit cfg: node =
object(this)
    inherit vnode cfg Rtl.null
end
@

class assign cfg rtl succ : node =
object (this)
    inherit vnode cfg rtl

    val mutable _succ = succ

    initializer =
        succ # link_pred (this :> node)

    method succ = [_succ]

    method upd_succ map = 
        _succ <- map _succ
end

class return cfg rtl (x,y) : node  
object (this)  
    inherit vnode cfg rtl

    val _x = (x:int)
    val _y = (y:int)
end

class goto cfg rtl targets : node =
object (this)
    inherit vnode cfg rtl

    val mutable _targets = targets

    initializer
        List.iter (fun n -> n#link_pred (this :> node) _targets

    method succ = uniq _targets      
    
    method upd_succ map =
        _targets <- List.map map _targets 
end

class jump cfg rtl conts : node =
object (this)
    inherit vnode

end


@

