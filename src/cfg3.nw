
\input{macros.tex}


% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Control-Flow Graph}
% ------------------------------------------------------------------ 

For code generation, the compiler translates the dynamic part of a
{\PAL} procedure into a control flow-graph (\cfg).  Each node is
contains a target-specific register-transfer list {\rtl} that later is
translated to machine instructions.  The lifetime of a control-flow
graph has two distinct phases:

\begin{enumerate}
\item Highl level: creation.
\item Low-level: analysis and semantics preserving modification.
\end{enumerate}

Once a procedure is translated into an initial {\cfg} it is analyzed
and according to the results rewritten gradually in a semantics
preserving way.  Analysis includes liveness analysis, modifications
include establishing the machine invariant that every {\rtl} is
representable by a machine instruction, and modifications resulting
from register allocation and spilling.

The creation interface for the {\cfg} can take a different level of
abstraction than the analysis and modification interface:  some
details are only relevant at the analysis level.  For example, a call
is represented by a number of assignments for parameter passing and a
call node.  However, during creation we can maintain the illusion that
all these aspects are captured by one node.  The analysis phase, on
the other hand, has to look at all the nodes separately. 
Consequently, the control flow-graph interface is layered:  a
high-level interface for creating {\cfg}s, and a low-level interface
for analysis and modification.


% ------------------------------------------------------------------ 
\subsection{Low-Level Types and Operations}
% ------------------------------------------------------------------ 

At the lowest level, the {\cfg} abstraction is characterized by the
following invariants:

\begin{itemize}
\item A {\cfg} contains nodes, connected by directed edges that model
      control-flow: $x \to y$ means, $y$ is a successor of $x$;  $y \gets
      x$ means, $x$ is a predecessor of $y$. 
\item A {\cfg} has an \emph{entry} and an \emph{exit} node.  A node
      may be unreachable from either the entry or exit node, or from
      both.
\item A linear order over all node of a {\cfg} exists.
\item A node belongs to exactly one {\cfg}.
\item A node has a \emph{kind} that defines its behavior and contains
      a matching {\rtl} defining its semantics.  
\item The number of outgoing edges (to successors) is constrained by a
      node's kind. A node can have any number of successors, including
      zero. 
\item A node and its neighbors, i.e.~its successors and predecessors
      are consistent: if and only if $x \to y$, then $y \gets x$.
\item A node contains a set of registers live \emph{before} it with
      respect to the linear order.
\end{itemize}

The interface below shows that graphs and nodes have an imperative
nature. A control-flow graph is generally built bottom-up: all node
creation functions take succeeding nodes as arguments.

<<types and ops>>=
type cfg
type node
<<type conts>>
<<type formal>>
<<type actual>>

(* cfg creation *)
val mk:         unit -> cfg

(* cfg observation *)
val entry:      cfg -> node
val exit:       cfg -> node
val label:      cfg -> string -> node -> unit
val lookup:     cfg -> string -> node                 (* Not_found *)
val fold:       cfg -> (node -> 'a -> 'a) -> 'a -> 'a (* must not alter CFG *)

(* node creation *)
val assign:     cfg -> Rtl.rtl -> succ:node -> node
val return:     cfg -> Rtl.rtl -> int * int -> node
val goto:       cfg -> Rtl.rtl -> node list -> node
val jump:       cfg -> Rtl.rtl -> node list -> node
val cutto:      cfg -> Rtl.rtl -> conts     -> node
val call:       cfg -> Rtl.rtl -> conts -> succ:node -> node
val branch:     cfg -> Rtl.rtl -> ifso:node -> ifnot:node -> node
val dummy:      cfg -> node

(* create linear sequence of assign nodes *) 
val copyi:      cfg -> formal list -> Automaton2.t -> node * Automaton2.t
val copyo:      cfg -> actual list -> Automaton2.t -> node * Automaton2.t

(* node observation *)
val cfg:        node -> cfg
val rtl:        node -> Rtl.rtl
val succ:       node -> node list       (* no duplicates *)
val pred:       node -> node list       (* no duplicates *)
val live:       node -> Register.Set.t

(* node modification *)
val delete:     node -> unit
val redirect:   node -> from:node -> dest:node -> unit
val set_live:   node -> Register.Set.t -> unit
val ins_before: node -> Rtl.rtl -> unit (* only for assign node *)
val ins_after:  node -> Rtl.rtl -> unit (* only for assign node *)

(* postponed 
 * val exapand:    node -> (Rtl.rtl -> Rtl.rtl list) -> unit
 *)
@


\subsubsection{Graph-Operations}

\begin{description}
\item[mk] 
    Creates an empty {\cfg} that just contains an entry node connected
    to an exit node.

\item[entry]
    The {\cfg}'s unique entry node.
\item[exit]     
    The {\cfg}'s unique exit node.

\item[label]    
    Assign a label to a node.  It is a checked run-time error if the
    node does not belong to the {\cfg}.  It is also a checked run-time
    error to assign a label twice.

\item[lookup]   
    Lookup a node by name.  If a node has a label of that name, the
    node is returned, otherwise [[Not_found]] is raised.

\item[fold]     
    Traverses the nodes of the {\cfg} in a linear order that is
    roughly from the exit node to the entry node in reverse
    control-flow order.  It is an unchecked run-time error if the
    function passed to [[fold]] alters the successor/predecessors
    relationship of nodes.  
\end{description}

\subsubsection{Node-Operations}

The kind of a node is encoded into the function that creates it. 
Depending on its kind, a node takes a number of arguments:  the graph
it belongs to, an {\rtl} and its successors.  The [[cutto]] and
[[call]] nodes take a continuation bundle that includes several nodes,
denoting continuations that can be reached from that node.

<<type conts>>=
type conts =    { cuts    : node list
                ; unwinds : node list
                ; returns : node list
                ; aborts  : bool
                }
@


The observation functions for nodes return the obvious values. 
Every node contains a (mutable) set of registers; this set is empty in
a new node. 

A [[dummy]] node is its own successor.  It is used as a placeholder
for labeled nodes that are not yet defined.  Use [[redirect]] to
update its successor. 

\begin{description}
\item[delete] 
    Deletes a node from a [[cfg]].  It is a checked run-time
    error, if:  the node has any successor, is an exit, or is an entry
    node.

\item[redirect] 
    An outgoing edge (to a successor) can be redirected to
    another node.  The current successor and the new successor must be
    provided.  It is a checked run-time error if:  nodes belong to
    different {\cfg}s, or the [[from]] node is not an actual
    predecessor.

    Note, that if several outgoing edges of a node point to the same
    successor, they \emph{all} get updated to the new node.  Hence,
    [[redirect]] is not fully general.

\item[set\_live] 
    Set the register set of a node.

\item[ins\_before] 
    Inserts an [[assign]] node $a$ before a node $n$,
    using the supplied {\rtl}.  It is a checked run-time error if the
    node $n$ was not created by the [[assign]] function.  The
    successors of $n$ become successors of $a$ and $a$ becomes the
    only successor of $n$.
                 
\item[ins\_after] 
    Like [[ins_before]], except that the assign node is
    placed after the node.  Since the node must be an [[assign]] node,
    it has only one outgoing edge and therefore this operation is well
    defined.  
\end{description}

\subsubsection{Implementing Calling Conventions}

Parameter passing is implemented by sequences of [[assign]] nodes that
transfer parameters from location determined by calling conventions to
registers, and vice versa.  These sequences of assignments are created
by functions \emph{copy-in} and \emph{copy-out} that take their
successor as argument return the topmost node of the sequence they
create.  Calling conventions are implemented by automata that are
passed to the functions and returned in an advanced state.  The
[[copyi]] function implements receiving parameters, the [[copyo]]
function passing actual parameters. 

<<type formal>>=
type formal =   { name:      string 
                ; width:     Rtl.width       (* bits *)
                ; hint:      string option   (* C-- hint *)
                ; index:     int             (* run-time API index*)
                } 

<<type actual>>=
type actual     = Rtl.exp 
                * Rtl.width 
                * string option               (* hint *)
@




% ------------------------------------------------------------------ 
\subsection{Putting the Interface together}
% ------------------------------------------------------------------ 

<<dummy sigs>>=
module Rtl : sig 
    type rtl 
    type exp 
    type width
    val null: rtl
end

module Register : sig
    module Set : sig
        type t
    end
end

module Automaton2 : sig
    type t
end
@

<<cfg3.mli>>=
<<dummy sigs>>
<<types and ops>>
@
