% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Control-Flow Graph}
% ------------------------------------------------------------------ 

For code generation, the compiler translates the dynamic part of a
{\PAL} procedure into a control flow-graph (\cfg).  Each node contains
a target-specific register-transfer list {\rtl} that later is
translated into machine instructions. 
 
Once a procedure is translated into an initial {\cfg} it is analyzed
and according to the results rewritten gradually in a semantics
preserving way.  Analysis includes liveness analysis, modifications
include establishing the machine invariant that every {\rtl} is
representable by a machine instruction, and modifications resulting
from register allocation and spilling.

Nodes of a {\cfg} can take part in two relations simultaneously: 
\begin{enumerate}
\item Control-flow relation. These are represented by the edges
      between nodes and model possible flow of control at run-time. 
\item Order relation. For the nodes of a {\cfg} a linear order can be
      established. This order is used for code-layout and during
      analysis phases. 
\end{enumerate}

% ------------------------------------------------------------------ 
\subsection{Abstractions}
% ------------------------------------------------------------------ 

The {\cfg} abstraction is characterized by the following invariants:

\begin{itemize}
\item A node belongs to exactly one {\cfg}.

\item A {\cfg} contains nodes, connected by directed edges that model
      control-flow: $x \to y$ means, $y$ is a successor of $x$.

\item A node has a fixed \emph{kind} that constraints some of its
      properties, like the number of control-flow successors. In
      particular, a node's kind is one of the following:

      \begin{tabular}{ll}
      \it kind & \it represented {\PAL} entity \\ 
      \hline
      entry     & unique node in every {\cfg} \\
      exit      & unique node in every {\cfg} \\
      assign    & assignment, like [[bits32[x] = y]]\\
      goto      & [[goto]] \\
      jump      & [[jump]] \\
      cutto     & [[cutto]] \\
      call      & procedure call, [[f(x,y)]]\\
      branch    & [[if]]-statement\\
      dummy     & none, used for undefined labels internally\\
      \end{tabular}
      
\item A {\cfg} has unique \emph{entry} and \emph{exit} nodes.  A node
      may be unreachable from either the entry or the exit node, or
      from both.
        
      \begin{quote}\it
      Since reachability of all nodes is desirable at least from the
      entry or the exit node we might introduce \emph{impossible}
      edges to guarantee this. 
      \end{quote}
      
\item The nodes of a {\cfg} can be numbered $1, \dots,
      |\mathit{cfg}|$.  A numbering for the nodes of a {\cfg} is
      either \emph{present} or \emph{absent}.  If and only if a
      numbering is present every node of a {\cfg} has a unique
      number.  The order is used by the code generation phase to
      define the code layout in memory and for all graph traversals. 
      
\item The number of outgoing edges (to successors) is constrained by a
      node's kind. A kind can have any number of successors, including
      zero, for example:
      \begin{enumerate}
      \item An assignment-node has one (control-flow) successor.
      \item A (conditional) branch-node has two successors.
      \item A call-node has one default successor and possibly many 
            exceptional successors.
      \end{enumerate}

\item A node can have any number of predecessors. 
      \emph{It is a checked run-time error if a node with more than one
      predecessor is unlabeled}. 

\item A node \emph{defines}, \emph{uses}, and \emph{kills} locations.
\item A node has mutable properties.
\end{itemize}

The interface below shows that graphs and nodes have an imperative
nature.  A control-flow graph is generally built bottom-up:  all
node-creation functions take succeeding nodes as arguments.  Functions
can mutate a node, a graph, both, or none.  To indicate the different
behaviors, the following naming scheme is used:

\begin{itemize}
\item Functions mutating a node or the mapping of labels to nodes are
      prefixed by [[set_]].
\item Function mutating a control-flow graph are prefixed by [[gm_]]
      (graph mutator).
\item Observation functions have no special prefix.
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Emitting {\PAL}}
% ------------------------------------------------------------------ 

For debugging we offer a translation of a {\cfg} to {\PAL} abstract
syntax (\AST). This can be translated back to plain text using the
{\AST} pretty-printer. The [[ast]] function receives a name mangler that
must be used for all names that are included in the {\cfg} and
translated to {\AST}. 

% ------------------------------------------------------------------ 
\subsection{Signature}\label{sec:cfg3:signature}
% ------------------------------------------------------------------ 

<<types and ops>>=
type cfg        
type t = cfg                    (* Cfg.t looks JustBetter *)
type node                       (* control-flow node *)
type locs = Register.Set.t      (* locations for liveness analysis *)
type conts                      (* continuation bundle *)
type property = Cfgprop.t       (* data inside nodes *)

(* cfg creation *)
val mk:         unit -> cfg

(* label mutator/observation *)
val set_label:  cfg -> string -> node -> node
val lookup:     cfg -> string -> node           (* always succeeds! *)

(* cfg observation *)
val entry:      cfg -> node 
val exit:       cfg -> node 

val node_ast: node -> Target2.t -> Ast.body list

(* cfg traversal in linear order, requires (enumerated cfg)  *)
val first:      cfg -> node (* wrt numbering *)
val last:       cfg -> node (* wrt numbering *)
val scan_fwd:   cfg -> first:int -> limit:int -> (node -> 'a -> 'a) -> 'a -> 'a 
val scan_bwd:   cfg -> first:int -> limit:int -> (node -> 'a -> 'a) -> 'a -> 'a
val next:       node -> node option
val prev:       node -> node option
  (* see module Cfgutil for convenience functions: fold_fwd, fold_bwd, first, limit *)

(* add node to cfg, ensures: not (enumerated cfg) *)
val gm_assign:  cfg -> Rtl.rtl -> succ:node -> node
val gm_return:  cfg -> Rtl.rtl -> int * int -> node
val gm_goto:    cfg -> Rtl.rtl -> node list -> node
val gm_jump:    cfg -> Rtl.rtl -> string list -> node
val gm_cutto:   cfg -> Rtl.rtl -> conts     -> node
val gm_call:    cfg -> Rtl.rtl -> conts -> succ:node -> node
val gm_branch:  cfg -> Rtl.rtl -> ifso:node -> ifnot:node -> node

(* delete node from cfg, ensures not (enumerated cfg) *)
val gm_delete_assign:           node -> unit    (* req: node is assign node *)

val print_node : node -> string

(* cfg mutators, ensures: not (enumerated cfg) *)
(* all assignment insertions return the new node *)
val gm_redirect_all:            src:node -> olddst:node -> newdst:node -> unit
val gm_insert_assign_after:     node -> Rtl.rtl -> node (* see descr! *)
val gm_insert_assign_before:    Rtl.rtl -> node -> node (* any node   *)
val gm_insert_assign_between:   Rtl.rtl -> src:node -> dst:node -> node
val gm_insert_dataflow_between: defs:locs -> uses:locs -> kills:locs ->
                                src:node -> dst:node -> unit
val gm_enumerate:               cfg -> unit (* post: enumerated cfg *)



(* node observation *)
val cfg:        node -> cfg
val rtl:        node -> Rtl.rtl
val succ:       node -> node list 
val pred:       node -> node list
val property:   node -> property
val number:     node -> int             (* pre: enumerated cfg *)
val defs:       node -> locs            (* locs defined by node *)
val uses:       node -> locs            (* locs used by node    *)
val kills:      node -> locs            (* locs killed by node  *)

(* node mutators *)
val set_rtl:        node -> (Rtl.rtl -> Rtl.rtl) -> unit

(* continuation bundle constructor *)
val conts: cuts:node list -> unwinds:node list -> 
           returns:node list -> aborts: bool -> conts 

(* observation *)
val ast:    cfg -> name:string                  (* of procedure *)
                -> (mangle:string -> string)    (* C-- name mangler *)
                -> target:Target2.t             (* to translate RTLs *)
                -> Ast.proc
@

% ------------------------------------------------------------------ 
\subsection{Description}
% ------------------------------------------------------------------ 

% ------------------------------------------------------------------ 
\subsubsection{Graph creation}
% ------------------------------------------------------------------ 

\begin{quote}\it
The typesetting of signatures below is ugly because I'm lacking an
idea and a \LaTeX~macros to do it better.  Duplicating signatures
manually is in addition prone to inconsistencies.  --CL 
\end{quote}

\begin{itemize}
\item [[mk:  unit -> cfg]]:  
Creates an empty {\cfg} that just contains an entry node connected to
an exit node.  Numbering of nodes is absent and no labels are defined.
\end{itemize}

% ------------------------------------------------------------------     
\subsubsection{Labels}
% ------------------------------------------------------------------ 

\begin{itemize}
\item [[set_label:  cfg -> string -> node -> node]]: 
Assigns a label to a node.  It is a checked run-time error if the node
does not belong to the {\cfg}.  The labeled node is returned. Note: the
returned node may or may not be the same as the one supplied as an
argument. The reason is, that [[lookup]] creates an internal labeled
node if the one that is asked for does not yet exist. In that case
[[set_label]] makes the provided node a successor of the internal node
and returns the internal node in order to get the control-flow right.

\item [[lookup:  cfg -> string -> node]]: 
Looks up a node by a label.  If a node was assigned that label before
it is returned.  Otherwise a [[dummy]] node is created, labeled, and
returned.
\end{itemize}

% ------------------------------------------------------------------ 
\subsubsection{Graph observation}
% ------------------------------------------------------------------ 

\begin{itemize}
\item [[entry: cfg -> node]]:
The {\cfg}'s unique entry node.

\item [[exit: cfg -> node]]:
The {\cfg}'s unique exit node.
\end{itemize}

% ------------------------------------------------------------------ 
\subsubsection{Graph Traversal}
% ------------------------------------------------------------------ 

All traversal functions below rely on and respect a numbering that
must be established by [[gm_enumerate]] before these functions can be
used.  Using any of the traversal functions without an established
order is a checked run-time error.  Any use of a graph mutator
function invalidates an existing numbering. Exception: it is safe to
mutate the {\cfg} using [[scan]] and [[fold]] because these functions
take a snapshot of the order and then ignore any changes to the graph
structure.

\begin{itemize}
\item [[first: cfg -> node]]:
The first node with respect to numbering.

\item [[last: cfg -> node]]:
The last node with respect to numbering.

\item 
[[scan_fwd: cfg -> first:int -> limit:int -> (node -> 'a -> 'a) -> 'a -> 'a]]: 

Applies a function [[f]] to the range of nodes from [[first]] to
[[limit]] (excluded) and passes an intermediate result.  The nodes are
visited in increasing order with respect to the numbering.  It is
\emph{safe} for [[f]] to call a graph mutator; in order for [[f]] being
applied to nodes, [[first]] $<$ [[limit]] must hold, otherwise the
intermediate result [['a]] is returned.

\item 
[[scan_bwd: cfg -> first:int -> limit:int -> (node -> 'a -> 'a) -> 'a -> 'a]]:
Dual function to [[scan_fwd]] in the sense that nodes are visited in
decreasing order, starting with the node before [[limit]].  Note, that
[[first]] $<$ [[limit]] still must hold. 

\item [[next: node -> node option]]:
The node following the argument [[node]] with respect to an
established node numbering or [[None]] if there is no such node.

\item [[prev: node -> node option]]:
Dual to [[next]]:  the node prior to the argument with respect to a
node numbering, or [[None]] if no such node exists.
\end{itemize}

Note: our original design had two more functions [[fold_fwd]] and
[[fold_bwd]] which would traverse a {\cfg} in unspecified order and did
not rely on an established ordering. These could be re-introduced in
case establishing a linear oder becomes a costly operation.

% ------------------------------------------------------------------ 
\subsubsection{Node Creation}
% ------------------------------------------------------------------ 

Nodes are created by functions that encode their kinds and depending
on them take different arguments:  the graph a node belongs to, an
{\rtl} and its successors.  The [[cutto]] and [[call]] nodes take a
continuation bundle that includes several nodes, denoting
continuations that can be reached from that node.

The creation of a node also adds it to the {\cfg}; because of this,
all node creating functions are marked as graph mutators.  Graph
mutators must not be called by traversal functions.  Using a mutator
causes a node numbering to become \emph{absent}.

\begin{verbatim}
gm_assign:  cfg -> Rtl.rtl -> succ:node -> node
gm_return:  cfg -> Rtl.rtl -> int * int -> node
gm_goto:    cfg -> Rtl.rtl -> node list -> node
gm_jump:    cfg -> Rtl.rtl -> string list -> node 
gm_cutto:   cfg -> Rtl.rtl -> conts     -> node
gm_call:    cfg -> Rtl.rtl -> conts -> succ:node -> node
gm_branch:  cfg -> Rtl.rtl -> ifso:node -> ifnot:node -> node
\end{verbatim}

% ------------------------------------------------------------------ 
\subsubsection{Graph Mutation}
% ------------------------------------------------------------------ 

All graph mutations destroy an existing node \emph{numbering} and must
not be used while traversing a graph.

\begin{itemize}
\item [[gm_redirect_all: node -> olddst:node -> newdst:node -> unit]]:
An outgoing edge (to a successor) can be redirected to another node. 
The current successor [[olddst]] and the new successor [[newdst]] must
be provided.  It is a checked run-time error if:  nodes belong to
different {\cfg}s, or [[olddst]] is not an actual successor.

Note, if several outgoing edges of a node point to the same
successor, they \emph{all} get updated to the new node.  Hence,
[[gm_redirect_all]] is not fully general.

\item [[gm_insert_assign_after:    node -> Rtl.rtl -> node]]:
Inserts [[assign]] node $a$ after a node $n$, using the supplied
{\rtl}. 
Returns~$a$.
The signature is tuned for use with [[List.fold_left]].


It is a checked run-time error if the node $n$ was not created
by the [[gm_assign]] function, or is the [[entry]] node. This guarantees
that it has only one outgoing edge and therefore this operation is well
defined.  The (single) successor of $n$ becomes the successor of $a$ and
$a$ becomes the only successor of $n$. 

\item [[gm_insert_assign_before: Rtl.rtl -> node -> node]]:
Inserts assign node~$a$ before [[node]] such that
\emph{all} incoming edges of [[node]]  are redirected to point to~$a$.
Therefore $a$~becomes the only predecessor of~[[node]].
Returns~$a$.
The signature is tuned for use with [[List.fold_right]].

\item 
[[gm_insert_assign_between: Rtl.rtl -> src:node -> dst:node -> node]]:
Inserts assign node~$a$ before [[dst]], and every edge from  [[src]]
to [[dst]] is redirected to point to~$a$.
The predecessor/successor relationship of all nodes is updated to
reflect the insertion of the assign nodes on all affected edges.  It
is a checked run-time error if no edge between [[src]] and [[dst]]
exists.
Returns~$a$.

\item
\begin{verbatim}
gm_insert_dataflow_between: defs:locs -> uses:locs -> kills:locs ->
                            src:node -> dst:node -> unit
\end{verbatim}

Inserts a node between [[src]] and [[dst]] that announces locations
being defined, used, and killed.  This node informs
data-flow analysis about inter-procedural data-flow that can not be
deduced from the other nodes.  It is a checked run-time error, if no
edge between [[src]] and [[dst]] exists.

\item [[gm_enumerate: cfg -> unit]]:
Establishes a numbering for all nodes of a {\cfg}; until a graph
mutator is called the numbering is \emph{present}.

\end{itemize}

% ------------------------------------------------------------------ 
\subsubsection{Deleting Nodes}
% ------------------------------------------------------------------ 

In general, nodes can not be deleted from a {\cfg}. The exceptions are
[[assign]]-nodes.

\begin{itemize}
\item [[gm_delete_assign: node -> unit]]

Deletes the [[assign]] node from its {\cfg}. It is a checked run-time
error if [[node]] is not an assign-node. The predecessor of [[node]]
becomes the predecessor of [[node]]'s successor and vice versa.

\end{itemize}

% ------------------------------------------------------------------ 
\subsubsection{Node Observation}
% ------------------------------------------------------------------ 

\begin{itemize}
\item [[cfg: node -> cfg]]: The {\cfg} the [[node]] belongs to.

\item [[rtl: node -> Rtl.rtl]]: The {\rtl} that is part of [[node]].

\item [[succ: node -> node list]]: The list of control-flow successors
      of [[node]].

\item [[pred: node -> node list]]: The list of control-flow
      predecessors of [[node]].

\item [[val property: node -> property]]:
      The property associated with this node.
      Because the [[property]] type is intended to be mutable, there
      is no need for a corresponding mutator.
 

\Item [[number:  node -> int]]:  Reports the number of a node.  It is
      a checked run-time error to invoke this function if node numbering is
      absent.

\item 
\begin{verbatim}
defs:       node -> Rtl.loc list    
uses:       node -> Rtl.loc list    
kills:      node -> Rtl.loc list    
\end{verbatim}

Each function returns locations that are defined, uses, or killed by
[[node]].  
\end{itemize}

\begin{quote}\it
    The register allocation phase takes a more abstract view 
    for numbering nodes by using a [[Point.t]] type. A [[Point.t]]
    must provide one value [[Point.zero]] which is never assigned to a
    node. The current design of using integers to number nodes and let
    numbering start at 1 is compatible with that view. Maybe the
    connection should be made more explicit. -CL
\end{quote}
% ------------------------------------------------------------------ 
\subsubsection{Node Mutators}
% ------------------------------------------------------------------ 

Node mutators update state that is local to a node/ They are safe to
be used during graph-traversal because they don't interact with other
functions. 

\begin{itemize}
\item [[set_rtl: node -> (Rtl.rtl -> Rtl.rtl) -> unit]]:
Set the {\rtl} of a node to a new value using a mapping function.

% \item [[set_property:  node -> property -> unit]]:
% Set the properties associated with the [[node]] at hand.
\end{itemize}

% ------------------------------------------------------------------ 
\subsubsection{Various Functions}
% ------------------------------------------------------------------ 


\begin{itemize}
\item
\begin{verbatim}
val conts: cuts:node list -> unwinds:node list -> 
           returns:node list -> aborts: bool -> conts 
\end{verbatim}

Construct a continuation bundle from the arguments.

\item [[ast]] returns an {\PAL} abstract syntax tree (\AST) representing
      the {\cfg}. This is intended as a debugging tool to make the
      {\cfg} visible using a pretty-printer for the {\AST} (c.f.~module
      \module{ast}). The function receives a \emph{mangler} for names.
      This mangler must respect the {\PAL} rules for names. See module
      \module{mangle} for details.

\end{itemize}

@

% ------------------------------------------------------------------ 
\subsection{Putting the Interface together}
% ------------------------------------------------------------------ 

The interface announces in the module type [[S]] is directly implemented
by the module. 

<<cfg3.mli>>=
module type S = sig
    <<types and ops>>
end
<<types and ops>>
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The interface hides the details of [[node]] and [[cfg]] but it is
clear that nodes come in different kinds, all sharing the same type
[[node]].  In the classical functional programming style this would
enforce a representation that supports all kinds at once and
observation functions that distinguish between the kinds.  Existential
types as provided by the object-oriented sub-language of {\ocaml}
provide a better solution:  a single type like [[node]] can have
multiple implementations, each for every kind.  Because the
object-oriented style also integrates with the imperative nature of
the interface we chose to use it to implement the control-flow graph.
To avoid name-clashes for useful names like [[cfg]] and [[node]], the
oo-implementation lives in its own sub-module [[X]].



<<cfg3.ml>>=
module type S = sig
    <<types and ops>>
end

module Property = Cfgprop

type locs       = Register.Set.t    (* defs/uses/kills *)
type property   = Property.t

module X = struct                   (* the OO implementation *)
    module A   = Ast
    module R2A = Rtl2ast
    module T   = Target2
    <<module X>>                    
end

<<implementation>>                  (* implements interface *)
@


% ------------------------------------------------------------------ 
\subsection{Implementing the Interface}
% ------------------------------------------------------------------ 

The implementation of the {\cfg} is layered: the top-layer that
implements the interface is presented here. It relies heavily on the
object-oriented implementation of nodes in module [[x]] that
represents the lower layer.

<<implementation>>=
type cfg        = X.cfg             (* class type cfg  *)
type node       = X.node            (* class type node *)
type t          = X.cfg             (* alias           *)
type conts      = X.conts
@

The implementation of most functions refer to methods of the involved
objects and therefore are short.

<<implementation>>=
let conts ~cuts ~unwinds ~returns ~aborts =
    { X.cuts    = cuts
    ; X.unwinds = unwinds
    ; X.returns = returns
    ; X.aborts  = aborts
    }

let mk () = new X.graph

<<implementation>>=
let set_label cfg (label:string) (node:node) =
    cfg#set_label label node

let lookup cfg (label:string) =
    cfg#lookup label

<<implementation>>=
let entry cfg =
    cfg#entry

let exit cfg =
    cfg#exit


let node_ast node target =
    node#ast (fun s -> s) target


let first cfg = 
    assert (cfg#enumerated);
    assert ((Array.length (cfg#enumeration)) >= 2);
    let enum = cfg#enumeration in
        enum.(0)

let last  cfg = 
    assert (cfg#enumerated);
    assert ((Array.length (cfg#enumeration)) >= 2);
    let enum = cfg#enumeration    in
    let len  = Array.length enum in
        enum.(len-1)
@

The indices [[first]] and [[limit]] are one-based, the array of nodes is
zero-based. The [[loop]] index [[n]] is also one-based and therefore
[[f]] is passed node [[n-1]] from the array.

<<implementation>>=
let scan_fwd (cfg:cfg) ~(first:int) ~(limit:int) f zero = 
    assert (cfg#enumerated);
    assert (first >= 1);
    assert (limit <= ((Array.length (cfg#enumeration)) + 1));
    let enum = cfg#enumeration in
    let rec loop n result =     (* n is one-based *)
        if n = limit then 
            result
        else
            loop (n+1) (f enum.(n-1) result)
    in
        loop first zero


<<implementation>>=
let scan_bwd (cfg:cfg) ~(first:int) ~(limit:int) f zero = 
    assert (cfg#enumerated);
    assert (first >= 1);
    assert (limit <= ((Array.length (cfg#enumeration)) + 1));
    let enum = cfg#enumeration in
    let rec loop n result =     (* n is one-based *)
        if n < first then 
            result
        else
            loop (n-1) (f enum.(n-1) result)
    in
        loop (limit-1) zero
@


The node numbered [[n]] is at the array position [[n-1]]. Consequently
is the next node at [[n]] and the previous one at position [[n-2]]. 

<<implementation>>=
let next (node:node) = 
    assert (node#cfg#enumerated);
    let n    = node#number     in   (* 1 ... |G|   *)
    let cfg  = node#cfg        in
    let enum = cfg#enumeration in   (* 0 ..  |G|-1 *)
        if n < (Array.length enum) then
            Some enum.(n)
        else
            None
    
let prev (node:node) = 
    assert (node#cfg#enumerated);
    let n    = node#number     in   (* 1 ... |G|   *)
    let cfg  = node#cfg        in
    let enum = cfg#enumeration in   (* 0 ..  |G|-1 *)
        if 1 < n then
            Some enum.(n-2)
        else
            None
@

Each node is an object and the function that creates it is simply its
constructor.

<<implementation>>=
let gm_assign = new X.assign
let gm_return = new X.return
let gm_goto   = new X.goto
let gm_jump   = new X.jump
let gm_cutto  = new X.cutto
let gm_call   = new X.call
let gm_branch = new X.branch
@

<<implementation>>=
let gm_redirect_all ~src ~olddst ~newdst =
    src#upd_succ (fun n -> if n = olddst then newdst else n)

let gm_insert_assign_before (rtl:Rtl.rtl) (node:node) =
    node#insert_assign_before rtl

let gm_insert_assign_after (node:node) (rtl:Rtl.rtl) =
    node#insert_assign_after rtl

let gm_insert_assign_between (rtl:Rtl.rtl) (src:node) (dst:node) =
    dst#insert_assign_on_edges_from rtl src

let gm_insert_dataflow_between ~defs ~uses ~kills ~src ~dst =
    let cfg  = src#cfg          in
    let exit = cfg#exit         in
    (*** debugging 
    let _    =
        ( Printf.printf "src: %d %s\n" src#id src#comment
        ; Printf.printf "dst: %d %s\n" dst#id dst#comment
        ) in
     ***)    
    let node = new X.dataflow cfg exit defs uses kills in
        ( src#upd_succ (fun n -> if n = dst then node else n)
        ; node#upd_succ (fun n -> dst)
        )

let gm_enumerate (cfg:cfg) = 
    if cfg#enumerated then      (* risky if out #enumerated lies *)
        ()
    else    
        cfg#enumerate

let gm_delete_assign (node:node) =
    let cfg = node#cfg in
        cfg#delete node

let print_node (node:node) =
    (node#comment ^ "\n")
@    

Many node observations simply invoke a node's method. 
    
<<implementation>>=
let cfg         (node:node) = node#cfg
let rtl         (node:node) = node#rtl
let succ        (node:node) = node#succ
let pred        (node:node) = node#pred
let property    (node:node) = node#property
let number      (node:node) = node#number
let defs        (node:node) = node#defs
let uses        (node:node) = node#uses
let kills       (node:node) = node#kills
@

<<implementation>>=
let set_rtl     (node:node) (map:Rtl.rtl -> Rtl.rtl) =
    node#set_rtl (map node#rtl)

(* 
 * let set_property (node:node) (p:property) = node#set_property p
 *)
@

The [[ast]] method returns an [[Ast.proc]] value. All names in the
resulting {\AST} must be mangled using [[mangle]]. 

<<implementation>>=
let ast (cfg:cfg) (name:string) (mangle:string->string) (target:Target2.t) = 
    cfg#test;   (* check integrity *)    
    ( None
    , mangle name
    , []
    , cfg#ast mangle target
    )
@ 
% ------------------------------------------------------------------ 
\subsection{Object-Oriented Implementation}
% ------------------------------------------------------------------ 

The {\cfg} implementation is build around two central class types,
[[cfg]] and [[node]], that provide the functionality of {\cfg}s and
their nodes respectively.  The [[cfg]] class has one implementation,
the [[node]] class one for every kind of node.  However, they all
implement the same class type. 

A [[node]] has a fixed number of outgoing edges to successors that are
initialized when the node is created. Edges can be updated using
[[upd_succ]] but the number of edges is fixed.


<<module X>>=
class type cfg = object
    method entry:       node            (* entry node of this *)
    method exit:        node            (* exit node of this *)
    method lookup:      string -> node  (* find labeled node *)
    method set_label:   string -> node -> node  (* assign label to node *)
    
    method add:         node -> unit    (* add node to this; 
                                           est: enumerated = false *)
    method delete:      node -> unit    (* remove node *)
    method enumerate:   unit            (* enumerate all node in this *)
    method enumerated:  bool            (* true, iff nodes are enumerated *)
    method enumeration: node array      (* req: enumerated *)
    method get_id:      unit -> int     (* unique *)
    method test:        unit            (* test integrity of this *)
    method ast:         (mangle:string->string) 
                        -> Target2.t
                        -> Ast.body list 
end
@

\begin{itemize}
\item [[entry]] is the entry-node of this {\cfg}. The entry node
      has the [[exit]] node as its successor initially.

\item [[exit]] is the exit-node of this {\cfg} and is initially the successor
      of the [[entry]] node.

\item [[lookup]] returns a labeled node. If no such node exists [[lookup]]
      creates a [[proxy]] node under that label and returns it. The
      fact that the returned node is a [[proxy]] is hidden and can't
      be exploited.

\item [[set_label]] attaches a label to an existing [[node]] in this {\cfg}.
      If the label was previously looked up and therefore a [[proxy]]
      node exists under that label, the provided [[node]] becomes the
      proxy's successor.  It is an checked run-time error if [[node]]
      does not belong to this {\cfg}. 
      
\item [[add]] adds a node to this {\cfg}. This invalidates a potential 
      linerar order (i.e. enumeration) and causes [[enumerated]] to be
      [[false]].

\item [[delete]] removes a node from this {\cfg}. This invalidates a
      potential linear order (i.e. enumeration) and causes
      [[enumerated]] to be [[false]]. Calls the [[delete]] method of the
      node which is responsible for unlinking itself from other nodes in
      the {\cfg}.

\item [[enumerate]] assigns numbers $1,2,\dots$ to the nodes in this
      {\cfg}. As a consequence, [[enumerated]] becomes true.
      
\item [[enumerated]] is [[true]], if nodes are enumerated. The
      enumeration of nodes is invalidated when nodes are inserted into
      [[this]]. 

\item [[enumeration]] is the array of nodes in the linear order
      established by [[enumerate]]. It is a checked run-time error to invoke
      this method if the [[enumerated]] predicate is false.       

\item [[get_id]] returns a unique number (in this {\cfg}) at every
      invocation.  Used by nodes for their unique ID.

\item [[test]] checks the internal consistency of [[this]] and fails 
      with a run-time error if problems exist.

\item [[ast]] returns a {\PAL} representation of [[this]]. More
      precisely, it returns the abstract syntax of a procedure's body
      that represents [[this]] {\cfg}. The [[ast]] method receives a
      \emph{mangler} function that is used to transform labels and
      symbolic constants within  [[this]] to {\PAL} syntax. See module
      \module{mangle} for details.

\end{itemize}


<<module X>>=
and node = object
    method cfg:         cfg             (* cfg this belongs to *)
    method rtl:         Rtl.rtl         (* rtl of this *)
    method id:          int             (* int of this *)
    method number:      int             (* number of this; req:cfg enumerated *)
    method succ:        node list       (* cf successors of this *)
    method pred:        node list       (* cf predecessors of this *)
    method property:    property        (* property of this *)

    method add_label:   string -> unit  (* add alabel to this node *)
    method link_pred:   node -> unit    (* add    in-edge from to pred node *)
    method unlink_pred: node -> unit    (* remove in-edge from to pred node *) 
    method unlink:      unit            (* unlink this from all other nodes *)
    method upd_succ:    (node -> node) -> unit (* redirect succs of this *)
    method set_rtl:     Rtl.rtl -> unit (* set rtl to new value *)
    (* 
     * method set_property: property -> unit (* set property *)
     *)
    method set_number:  int -> unit     (* defines number *)

    method defs:        locs            (* defined by this *)
    method uses:        locs            (* used by this    *)
    method kills:       locs            (* killed by this  *)
    
    method insert_assign_before:  Rtl.rtl -> node (* returns new node *)
    method insert_assign_after :  Rtl.rtl -> node (* returns new node *)  
    method insert_assign_on_edges_from: Rtl.rtl -> before:node -> node (* new node *)

    method comment:     string          (* included into ast *)
    method ast:         mangle:(string->string) 
                        -> Target2.t
                        -> Ast.body list
    method linorder:    node option * node list (* immediate/delayed succs *)

    (* for debugging only *)
    method test:        unit            (* test integrity of this *)
end
@

\begin{itemize}
\item [[cfg]] is the {\cfg} this node belongs to.
\item [[rtl]] is the {\rtl} belonging to this node.
\item [[id]] is the identification of this node. It is unique within
      its [[cfg]].
\item [[number]] the number of this node. It is a checked run-time
      error to invoke this method if the [[cfg]] is not enumerated.
\item [[succ]] are succeeding control-flow nodes. 

\item [[unlink]] unlink this node from all adjacent nodes. Should not be
      called directly but only from [[cfg]] to make sure it is removed
      from the [[cfg]]'s data structures.

\item [[pred]] are preceding control-flow nodes.
\item [[link_pred]] informs this node that another node has become a
      predecessor of this node. 
\item [[unlink_pred]] informs this node that a given node is no longer
      a predecessor of this node. It is a checked run-time error if
      the node at hand is not a predecessor of this node.
\item [[upp_succ]] updates links to successors using a map-function.
      Note that a map-function can collapse different links to a
      single node but can't reverse the effect.
\item [[defs]], [[uses]], [[kills]] reports locations defined, used, or
       killed by a node.

\item [[insert_assign_before]] creates a new [[assign]] node from an
      [[Rtl.rtl]] before [[this]] node and returns it. The predecessors
      of [[this]] become the predecessor of the [[assign]] node.

\item [[insert_assign_after]] creates a new [[assign]] node from an
      [[Rtl.rtl]] after a node and returns it. It is a checked run-time
      error if [[this]] is not an [[assign]] or [[entry]] node. The
      successor of [[this]] becomes the successor of the new node, which
      in turn becomes the new successor of [[this]].

\item [[insert_assign_on_edges_from rtl before]] creates a new
      [[assign]] node from an [[rtl]] and places it between [[this]]
      node and the node [[before]]. The new node is returned. All edges
      leading from the [[before]] node to [[this]] node lead through the
      new node afer the method is completed. It is a checked run-time
      error if no edge between [[before]] and [[this]] exists.

\item [[linorder]] provides constraints for the linear order of node. See
      section \ref{sect:cfg3:linorder} for details.

\item [[comment]] provides a note about [[this]] node that is
      included into the {\AST} representation by method [[ast]]. Note:
      this must be a method and not a value field because we rely on
      dynamic dispatch.

\item [[ast]] returns a representation of the node as abstract {\PAL}
      syntax. The method receives a \emph{mangler} function that is used 
      to transform labels into {\PAL} syntax. See \module{mangle} for
      details. 
\end{itemize}      

The implementation of labels requires a third type [[proxy]]
which is a sub-class type of [[node]]. A [[proxy]] node holds a label
for a node that is not yet defined. Its distinct feature is, that an
edge to a successor can be added later after the proxy was created.
This allows to point the proxy to the node that really should hold the
label, once this node is defined.

<<module X>>=
class type proxy = object
    inherit node 
    method set_succ: node -> unit       (* set succ for this *)
end
@

% ------------------------------------------------------------------ 
\subsection{Linear Ordering}\label{sect:cfg3:linorder}
% ------------------------------------------------------------------ 

The {\cfg} abstraction includes the \emph{enumeration} of a {\cfg}: a
linear order is defined that respects the control-flow. Such a
linear order is used for liveness and data-flow analysis and also
defines the code layout after nodes are translated to machine
instructions. Since linear-scan register allocation
(c.f.~\module{linscan}) is sensitive to code layout it is desirable to
provide some control over it, instead of using a generic depth-first
traversal to define a linear order. Using depth-first the two branches
of an [[if]] statement that are close on the {\PAL} source level often
would be very far apart in the linear order. This is undesirable because
is possibly introduces very long live-ranges for intervals that are used
in both branches. A good linear order therefore should keep nodes
together whose source-level instruction are also close.

Each node announces its control-flow successors (with method [[succ]])
and predecessors (with method [[pred]]). However, these two are not
enough to implement a linear order. The list of successors does not tell
which one should follow the node at hand and a linear order algorithm is
not free to pick just any of them: a [[call]] node, for example should
be followed by the node the calls returns to. But this node can not be
identified easily from the list of successors. Therefore another node
method [[linorder]] tells constraints for an algorithm that constructs a linear
order:

\begin{quote}
\begin{verbatim}
val linorder: node option * node list
\end{verbatim}
\end{quote}

The first element describes the \emph{immediate successor} node that
must follow [[this]] node because of direct control-flow. The second
element describes a list of \emph{delayed} labeled nodes that [[this]]
node might branch to. 

The [[enumerate]] method of a [[graph]] instance defines a linear order
for all nodes that are part of the {\cfg}. It starts at the [[_entry]]
node and follows the linear order suggested by each node. Nodes that are
branch targets are kept in a first-in-first-out list. An element is
processed from this list whenever a node indicates that it has no direct
successor.

Each node is assigned a number that reflects its position in the linear
order. The first node has number 1 and is stored in index position 0 of
the array. The rationale is that 0 is reserved for empty intervals in
the \module{lifetime} implementation. 

<<enumerate method>>=
let rec loop (i:int) (acc: node list) visited todo = match todo with
    | []                               -> acc
    | n::nn when NodeSet.mem n visited -> loop i acc visited nn
    | n::nn -> 
        let visited = NodeSet.add n visited in
        let acc     = n::acc in     (* reverse order *)
        let i       = i+1 in
        let ()      = n#set_number i in
            ( match n#linorder with
            | Some x, [] -> loop i acc visited (x::nn) 
            | Some x, tt -> loop i acc visited (x::nn@tt) (*XXX O(n^2) *)
            | None  , [] -> loop i acc visited nn
            | None  , tt -> loop i acc visited (nn@tt)    (*XXX O(n^2) *) 
            ) in
let entry = match _entry with None -> assert false | Some n -> n  in          
let nodes = loop 0 [] NodeSet.empty [entry] in
let nodes = List.rev nodes in
     _enumeration <- Some (Array.of_list nodes)
@

\begin{quote}\it
    Currently artifical data-flow edges are advertised by nodes'
    [[linorder]] method. They could be dropped without harm to get a
    slighly nicer output. This, however, would make the [[exit]] node
    unreachable from the [[entry]] node and thus it would not get
    unumerated.
\end{quote}

% ------------------------------------------------------------------ 
\subsection{Auxiliaries}
% ------------------------------------------------------------------ 

<<module X>>=
module NodeSet = Set.Make(struct type t=node   let compare=compare end)
type conts =    { cuts    : node list
                ; unwinds : node list
                ; returns : node list
                ; aborts  : bool
                }

let compare x y = compare x#id y#id
@

The function [[nodup]] removes adjacent duplicates (according to the
comparison function [[cmp]]) from a list.  

<<module X>>=
let rec nodup cmp = function
    | x::(y::_ as tail) -> if cmp x y = 0 
                           then nodup cmp tail
                           else x :: nodup cmp tail
    | x                 -> x
@

The [[uniq]] function returns a duplicate-free list of nodes from a
list of nodes.  We use this function to compute duplicate-free list of
successors and predecessors below.
    
<<module X>>=
let uniq nodes = nodup compare (List.sort compare nodes)   
@

Edges in a {\cfg} can not be simply added or removed but only
redirected. This ensures that no edge gets lost. Redirection of edges is
specified by a client supplied function that maps the end of an edge to
a new node: [[node -> node]]. Whenever an edge is re-mapped it must be
unlinked from the old destination and linked with the new destination.
We create a such a function from the client supplied [[map]]:

<<module X>>=
let upd (this:node) (map:node->node) = fun n -> 
    let n' = map n in
        if n' <> n then         (* edge gets redirected *)
            ( n  #unlink_pred this
            ; n' #link_pred   this
            ; n'
            )
        else
            n
@

When generating an {\AST} for each node we repeatedly have to embed
statements in the [[A.BodyStmt]] constructor. Using a constructor
function makes it a little bit easier.

<<module X>>=
let stmt x = A.StmtBody x
let decl x = A.DeclBody x
let data x = A.DataBody x
@


% ------------------------------------------------------------------ 
\subsection{Classes}
% ------------------------------------------------------------------ 

The [[graph]] class maintains two maps for labeled nodes: [[_labels]]
and [[_dummies]]. The former holds labeled nodes, the latter (labeled)
[[proxy]] nodes. These are created by the [[lookup]] method when the
requested label is not yet defined. A lookup therefore searches first
the [[_labels]] map, next the [[_dummies]] map, and if it can not find
the label creates enters a new proxy node into the [[_dummies]] map. The
[[set_label]] method first has to check whether a proxy was defined for
the node that is to be labeled. If this is the case the node becomes the
dummy's successor, otherwise the node is just entered into the
[[_labels]] map.

<<module X>>=
class graph: cfg =
object (this)
    val         _labels         = (Hashtbl.create 47: (string,node) Hashtbl.t)
    val         _dummies        = (Hashtbl.create 47: (string,proxy) Hashtbl.t)
    val mutable _nodes          = NodeSet.empty
    val mutable _id             = 0
    val mutable _enumeration    = (None: node array option)
    val mutable _entry          = (None: node option)
    val mutable _exit           = (None: node option)

    initializer
        let bot = new exit  (this:>cfg)     in
        let top = new entry (this:>cfg) bot in
            ( _entry <- Some top
            ; _exit  <- Some bot 
            ; _nodes <- NodeSet.add top _nodes
            ; _nodes <- NodeSet.add bot _nodes
            )

    method entry =
        match _entry with
        | None      -> assert false
        | Some node -> node
    
    method exit =
        match _exit with
        | None      -> assert false
        | Some node -> node

    method lookup label =
        try Hashtbl.find _labels label
        with Not_found ->
            try (Hashtbl.find _dummies label :> node)
            with Not_found ->
            let (d:proxy) = new dummy (this :> cfg) label in
                ( Hashtbl.add _dummies label d 
                ; this#add (d :> node)
                ; (d :> node)
                )
                
    method set_label label node =
        assert (NodeSet.mem node _nodes);       (* node#cfg = (this:>cfg) *)
        try 
            let d = Hashtbl.find _dummies label in
                ( d#set_succ node
                ; (d :> node)
                )
        with Not_found ->
            ( Hashtbl.add _labels label node
            ; node#add_label label  
            ; node
            )

    method add node =
        ( _enumeration <- None
        ; _nodes <- NodeSet.add node _nodes
        )

    method enumerate =
        <<enumerate method>>

    method enumerated = 
        _enumeration <> None 

    method enumeration =
        match _enumeration with
        | None       -> assert false
        | Some nodes -> nodes

    method get_id () =
        ( _id <- _id + 1
        ; _id
        )

    method delete node =
        ( _nodes <- NodeSet.remove node _nodes
        ; _enumeration <- None
        ; node#unlink
        )
    
    (* test integrity of CFG *)
    method test =
        ( assert (_entry <> None)
        ; assert (_exit  <> None)
        ; NodeSet.iter (fun n -> n#test) _nodes
        )


    (* create AST of this *)
    method ast (mangle:string -> string) (target:Target2.t) =
        let this = (this :> cfg) in
        if not this#enumerated then this#enumerate else ();
        let enum          = 
            match _enumeration with 
            | Some x -> x 
            | _      -> assert false                  in
        let f node result = node#ast mangle target :: result in
            List.concat (Array.fold_right f enum [])
            
end
@

To insert a new [[assign]] node before [[this]] we first create an
assign node that has the [[exit]] node as its successor. Then we
redirect all incoming edges to the new assign node and finally its
outgoing edge towards [[this]] node.

Adding an assignment node after [[this]] only works if [[this]] is
itself an assignment node with a single successor. Therefore the method
provided here fails but is overridden in the [[assign]] class.

<<module X>>=
and virtual vnode cfg rtl =
object(this)
    val mutable _pred   = NodeSet.empty
    val mutable _rtl    = (rtl: Rtl.rtl)
    val         _cfg    = cfg
    val mutable _id     = (cfg#get_id ())
    val mutable _num    = -1 
    val mutable _prop   = (Property.empty ())       (* default properties *)
    val mutable _labels = ([]: string list)
    
    initializer
        _cfg#add (this :> node)

    method cfg      = _cfg
    method rtl      = _rtl
    method pred     = NodeSet.elements _pred
    method succ     = ([]: node list)   (* make virtual? *)
    method id       = _id
    
    method number   = 
        assert (_cfg#enumerated); 
        _num
    
    method add_label (x:string) = 
        _labels <- x::_labels
        
    method upd_succ map =               (* make virtual? *)
        ()

    method unlink =
        assert false    (* not defined in the general case! *)
    
    (* every node with more than one predecessor should be 
       labeled - do we want to check for this? *)

    method link_pred node =
        _pred <- NodeSet.add node _pred
        
    method unlink_pred node =
        assert (NodeSet.mem node _pred);
        _pred <- NodeSet.remove node _pred

    method set_rtl (rtl:Rtl.rtl) =
        _rtl <- rtl

    method defs = 
        let read,write = Rtlutil.ReadWrite.sets _rtl in
            write

    method uses = 
        let read,write = Rtlutil.ReadWrite.sets _rtl in
            read

    method kills =
        Register.Set.empty

    (* 
     * method set_property (p:property) = 
     *   _prop <- p 
     *)

    method set_number i =
        _num <- i

    method property =
        _prop

    method insert_assign_before (rtl:Rtl.rtl) =
        let this        = (this :> node) in
        let assign      = new assign _cfg rtl (_cfg#exit) in 
        let redirect n  = if n = this then assign else n in
            ( NodeSet.iter  (fun n -> n#upd_succ redirect) _pred
            ; assign#upd_succ (fun n -> this)
            ; assign (* the new node *)
            )

    method insert_assign_after (rtl:Rtl.rtl) = 
        invalid_arg "Cfg3: add_assign_after method for non-assignment node"

    method insert_assign_on_edges_from (rtl:Rtl.rtl) (before:node) =
        let ()          = assert (NodeSet.mem before _pred) in
        let this        = (this :> node) in
        let assign      = new assign _cfg rtl this in
        let redirect n  = if n = this then assign else n in
            ( before#upd_succ redirect
            ; assign
            )
    
    (* comment about node kind *)
    method comment = ""
        (**) ^ 
        let this = (this :> node) in
        let live = (this#property).Property.liveout in 
            Printf.sprintf "node: %d num: %d live: %s" 
                           _id _num
                           (Register.print_set live)
    ^ " RTL: " ^ Rtldebug.rtl_to_string _rtl
        (**)    
^ "\n" ^ List.fold_right (fun n prev -> prev ^
                             "with pred: " ^ string_of_int n#id ^ "\n")
                         (this#pred) ""
^ List.fold_right (fun n succ -> succ ^
                             "with succ: " ^ string_of_int n#id ^ "\n")
                         (this#succ) ""

    method ast (mangle:string->string) (target:Target2.t) = 
        let this    = (this :> node) in
        let label l = stmt (A.LabelStmt (mangle l)) in
        let labels  = List.map label _labels in
        (**) let comment = stmt (A.CommentStmt (this#comment)) in 
       Verbose.say 5 [ this#comment; "\n"];
         (**)  
          (* comment :: *) labels

    method virtual linorder: node option * node list

    (* this node must be in the predecessor list of each successor
     * if this node has more than two predecessors it must be labeled
     *    this is not enforced by this module but a dynamic property we
     *    like the client to maintain 
     *)

    method test =
        let this = (this :> node) in
        let succ = this#succ in
        let pred = this#pred in
            ( assert (* check link structure *)
                (List.fold_left (fun r n -> r && (List.mem this n#pred)) 
                                true 
                                succ)
            ; assert ((List.length pred <= 1) || (_labels <> [])) 
            
            (** this code was used to debug some problem 
            ; if not ((List.length pred <= 1) || (_labels <> [])) then
                ( Printf.printf "node %d\n" _id
                ; List.iter (fun n -> Printf.printf "pred %d (%s)" 
                                n#id n#comment) pred
                ; Printf.printf "\n"
                ; List.iter (fun n -> Printf.printf "succ %d (%s)" 
                                n#id n#comment) succ
                ; Printf.printf "\n"
                )
            **)    
            )
    
end (* of vnode class *)

(* ------------------------------------------------------------------ *) 

<<module X>>=
and virtual vcut cfg rtl (conts: conts) =
object (this)
    inherit vnode cfg rtl as super

    val mutable _cuts    = conts.cuts
    val mutable _unwinds = conts.unwinds
    val mutable _returns = conts.returns
    val _aborts          = conts.aborts

    initializer
        let succ = List.concat [_cuts;_unwinds;_returns] in
            List.iter (fun n -> n#link_pred (this:>node)) succ

    method virtual succ     : node list
    method virtual upd_succ : (node -> node) -> unit
end 

(* ------------------------------------------------------------------ *) 

<<module X>>=
and dummy cfg label: proxy =
object(this)
    inherit vnode cfg Rtl.null as super

    val mutable _succ   = (None: node option) 

    initializer
        (this :> node) # add_label label

    method set_succ node =
        ( _succ <- Some node
        ; node#link_pred (this :> node)
        )
    
    method succ =
        match _succ with
            | None   -> assert false (* must not happen *)
            | Some n -> [n]
    
    method upd_succ map =
        let map = upd (this :> node) map in
        match _succ with
            | None   -> ()
            | Some n -> _succ <- Some (map n)

    method linorder = 
        ( match _succ with
          | None -> assert false (* must not happen *)
          | x    -> x
        , []
        )

    method comment = super#comment ^ " proxy"    
end

(* ------------------------------------------------------------------ *) 

<<module X>>=
and entry cfg exit: node =
object(this)
    inherit vnode cfg Rtl.null as super

    val mutable _succ = (exit:node)

    initializer 
        _succ # link_pred (this :> node)

    method linorder = (Some _succ, [])

    method insert_assign_after (rtl:Rtl.rtl) =
        let this   = (this :> node) in
        let assign = new assign _cfg rtl (_succ) in
            ( _succ#unlink_pred this
            ; _succ <- assign
            ; _succ#link_pred this
            ; assign
            )
    
    method comment = super#comment ^ " entry"    
    method succ = [_succ]
    method upd_succ map = 
        let map = upd (this :> node) map in
        _succ <- map _succ
end

(* ------------------------------------------------------------------ *) 

<<module X>>=
and exit cfg: node =
object(this)
    inherit vnode cfg Rtl.null as super

    method comment = 
        super#comment ^ " exit - should be unreachable from entry!"    
    
    method linorder = (None, [])
end
@

(* ------------------------------------------------------------------ *) 
The [[assign]] object provides an [[add_assign_after]] method that
allows to insert a new [[assign]] node before the successor. 

<<module X>>=
and assign cfg rtl succ : node =
object (this)
    inherit vnode cfg rtl as super

    val mutable _succ = succ

    initializer 
        succ # link_pred (this :> node)

    method succ = [_succ]

    method upd_succ map = 
        let map = upd (this :> node) map in
        _succ <- map _succ

    method insert_assign_after (rtl:Rtl.rtl) =
        let this   = (this :> node) in
        let assign = new assign _cfg rtl (_succ) in
            ( _succ#unlink_pred this
            ; _succ <- assign
            ; _succ#link_pred this
            ; assign
            )
@

To unlink an assign-node, we do:

\begin{itemize}
\item Find the single predecessor,
\item redirect all outgoibg edges of the predecessor to our (single)
      successor,
\item unlink this node from our successor,
\item make our predecessor a direct predecessor of our successor. 
\end{itemize}

This should leave this node unliked, except that this node still has a
link to its successor, but is not linked from any other node.

<<module X>>=    
    method unlink =
        let this = (this :> node) in
        let pred = NodeSet.min_elt _pred                in
        let ()   = assert (pred = NodeSet.max_elt _pred) in
            ( pred#upd_succ (fun n -> if n = this then _succ else n)
            ; _succ#unlink_pred this
            ; _succ#link_pred pred
            )
        

    method ast mangle target =
        let labels = super#ast mangle target in
        let s      = R2A.rtl mangle _rtl in
            labels@[stmt s]

    method comment = super#comment ^ " assign"    
    method linorder = (Some _succ,[])
end

(* ------------------------------------------------------------------ *) 

<<module X>>=
class return cfg rtl (x,y) : node  =
object (this)  
    inherit vnode cfg rtl as super

    val         _x    = (x:int)
    val         _y    = (y:int)
    val mutable _exit = cfg#exit

    initializer 
        _exit # link_pred (this :> node)
    
    method succ = [_exit]
    
    method upd_succ map =
        let map = upd (this :> node) map in
        _exit <- map _exit

    method comment = super#comment ^ " return"    

    method ast mangle target =
        let labels = super#ast mangle target    in
        let s      = A.ReturnStmt(None,None,[]) in
            labels@[stmt s]
        
    method linorder = (None, [_exit])

end

(* ------------------------------------------------------------------ *) 

<<module X>>=
class goto cfg rtl targets : node =
object (this)
    inherit vnode cfg rtl as super

    val mutable _targets = targets

    initializer
        List.iter (fun n -> n#link_pred (this :> node)) _targets

    method succ = uniq _targets      
    
    method upd_succ map =
        let map = upd (this :> node) map in
        _targets <- List.map map _targets 

    method comment = super#comment ^ "goto"    
    
    method ast mangle target =
        let labels = super#ast mangle target      in
        let exp    = target.T.goto.T.project _rtl in
        let exp    = R2A.expr mangle exp          in
        let s      = A.GotoStmt (exp, [])         in
            labels@[stmt s]

    method linorder = (None, _targets)
end

(* ------------------------------------------------------------------ *) 
(* here is something wrong: a jump target is never a node
   inside the actual procedure *)

<<module X>>=
class jump cfg rtl (targets:string list) : node =
object (this)
    inherit vnode cfg rtl as super

    val mutable _targets = targets      
    val mutable _exit    = cfg#exit     (* artifical edge to exit *)
    
    initializer
        _exit#link_pred (this :> node)

    method succ = [_exit]   
    
    method linorder = (None, [_exit])
    
    method ast mangle target =
        let labels = super#ast mangle target      in
        let exp    = target.T.jump.T.project _rtl in
        let exp    = R2A.expr mangle exp          in
        let s      = A.JumpStmt (None,exp, [],[]) in
            labels@[stmt s]
    
    method comment = super#comment ^ " jump"    
    method upd_succ map =
        let map = upd (this :> node) map in
            _exit    <- map _exit
end

(* ------------------------------------------------------------------ *) 

<<module X>>=
class call cfg rtl conts ~succ : node =
object (this)
    inherit vcut cfg rtl conts as super

    val mutable _succ = (succ: node)

    initializer 
        succ # link_pred (this :> node)

    method succ =
        uniq (List.concat [ [_succ]; _cuts; _unwinds; _returns])

    method upd_succ map = 
        let map = upd (this :> node) map in
        ( _cuts     <- List.map map _cuts
        ; _unwinds  <- List.map map _unwinds
        ; _returns  <- List.map map _returns
        ; _succ     <- map _succ
        ) 
    
    method comment = super#comment ^ " call"    

    method ast mangle target =
        let labels = super#ast mangle target      in
        let exp    = target.T.call.T.project _rtl in
        let exp    = R2A.expr mangle exp          in
        let s      = A.CallStmt ([], None, exp, [], [], []) in
            labels@[stmt s]

    method linorder = 
        ( Some _succ
        , uniq(List.concat[_cuts;_unwinds;_returns])
        )
end

(* ------------------------------------------------------------------ *) 

<<module X>>=
class cutto cfg rtl conts : node =
object (this)
    inherit vcut cfg rtl conts as super

    val mutable _exit = (cfg#exit: node)       (* artifical edge to exit *)

    initializer
        _exit # link_pred (this :> node)

    method succ =
        uniq (List.concat [ [_exit]; _cuts; _unwinds; _returns])

    method upd_succ map = 
        let map = upd (this :> node) map in
        ( _cuts     <- List.map map _cuts
        ; _unwinds  <- List.map map _unwinds
        ; _returns  <- List.map map _returns
        ; _exit     <- map _exit
        ) 
    
    method comment = super#comment ^ " cutto"    

    method ast mangle target =
        let labels = super#ast mangle target      in
        let exp    = target.T.cutto.T.project _rtl in
        let exp    = R2A.expr mangle exp          in
        let s      = A.CutStmt (exp, [], [])      in
            labels@[stmt s]
    
    method linorder = 
        ( None
        , uniq(List.concat[_cuts;_unwinds;_returns;[_exit]])
        )
end

(* ------------------------------------------------------------------ *) 

<<module X>>=
class branch cfg rtl (ifso:node) (ifnot:node) : node =
object (this)
    inherit vnode cfg rtl  as super

    val mutable _ifso  = ifso
    val mutable _ifnot = ifnot

    initializer
        ( _ifso  # link_pred (this :> node)
        ; _ifnot # link_pred (this :> node)
        )

    method succ =
        uniq [_ifso;_ifnot]

    method upd_succ map =
        let map = upd (this :> node) map in
        ( _ifso  <- map _ifso
        ; _ifnot <- map _ifnot
        )

    method ast mangle target =
        let labels       = super#ast mangle target           in
        let guard,label = target.T.branch.T.project _rtl     in
        let guard        = R2A.expr mangle guard             in
        let label        = R2A.expr mangle label             in
        let goto         = A.GotoStmt (label,[])             in
        let s            = A.IfStmt (guard, [stmt goto], []) in
            labels@[stmt s]

    
    method linorder = 
        ( Some _ifnot
        , [_ifso]
        )
    method comment = super#comment ^ " branch"    
end


(* ------------------------------------------------------------------ *)

<<module X>>=
class dataflow cfg (succ:node) (defs:locs) (uses:locs) (kills:locs) : node =
object (this)
    inherit vnode cfg (Rtl.null) as super

    val mutable _succ = succ
    val _defs  = defs
    val _uses  = uses
    val _kills = kills

    initializer
        _succ # link_pred (this:>node)

    method succ =
        [_succ]

    method upd_succ map =
        let map = upd (this :> node) map in
        _succ <- map _succ

    method defs   = _defs
    method uses   = _uses
    method kills  = _kills

    method comment = 
          super#comment 
        ^ (Printf.sprintf "defs: %s uses: %s kills: %s"
                          (Register.print_set _defs)
                          (Register.print_set _uses)
                          (Register.print_set _kills)
          ) 

    method ast mangle target =
        let labels       = super#ast mangle target           in
        let s            = A.CommentStmt("dataflow node")    in
            labels@[stmt s]


    method linorder =
        ( Some _succ
        , []
        )
end
@

% vim:tw=72:ts=4:et:
