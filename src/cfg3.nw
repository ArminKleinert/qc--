
\input{macros.tex}


% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Control-Flow Graph}
% ------------------------------------------------------------------ 

For code generation, the compiler translates the dynamic part of a
{\PAL} procedure into a control flow-graph (\cfg).  Each node is
contains a target-specific register-transfer list {\rtl} that later is
translated to machine instructions. 
 
Once a procedure is translated into an initial {\cfg} it is analyzed
and according to the results rewritten gradually in a semantics
preserving way.  Analysis includes liveness analysis, modifications
include establishing the machine invariant that every {\rtl} is
representable by a machine instruction, and modifications resulting
from register allocation and spilling.

% ------------------------------------------------------------------ 
\subsection{Low-Level Types and Operations}
% ------------------------------------------------------------------ 

The {\cfg} abstraction is characterized by the following invariants:

\begin{itemize}
\item A {\cfg} contains nodes, connected by directed edges that model
      control-flow: $x \to y$ means, $y$ is a successor of $x$;  $y \gets
      x$ means, $x$ is a predecessor of $y$. 
\item A {\cfg} has an \emph{entry} and an \emph{exit} node.  A node
      may be unreachable from either the entry or exit node, or from
      both.
\item The nodes of a {\cfg} can be numbered $1, \dots,
      |\mathit{cfg}|$.  A numbering for the nodes of a {\cfg} is
      either \emph{present} or \emph{absent}.  If and only if a
      numbering is present, then every node of a {\cfg} has unique
      number. 
\item The number of outgoing edges (to successors) is constrained by a
      node's kind. A node can have any number of successors, including
      zero. 
\end{itemize}

The nodes of a {\cfg} are characterized by the following asbtract
invariants; 
      
\begin{itemize}
\item A node belongs to exactly one {\cfg}.
\item A node has a \emph{kind} that defines its behavior and contains
      a matching {\rtl} defining its semantics.  
\item A node contains a set of registers live \emph{before} it with
      respect to the control flow.  i.e.~live on one edge enetring the
      node.
      
%% \item A node and its neighbors, i.e.~its successors and predecessors
%%    are consistent: if and only if $x \to y$, then $y \gets x$.
\end{itemize}

\begin{quote}\it
    Regsiters read and written by a node are deduced from its {\rtl}. 
    However, sometimes we must pretend that a node manipulates
    registers that are not present in its {\rtl}: inter-procedural 
    control and data flow affects registers beyond what is expressed
    in a {\rtl}. In particular, registers can be \emph{defined},
    \emph{used}, or \emph{killed} in entry, exit, cutto, jump, and
    call nodes. We will have to add observers for these sets. --CL
\end{quote}

\begin{quote}\it
    This interface does not provide a concept for \emph{node
    properties} as we had in earlier designs. I'd like to postpone
    this design decision until we have a better understanding of what
    we really need. --CL
\end{quote}

The interface below shows that graphs and nodes have an imperative
nature.  A control-flow graph is generally built bottom-up:  all
node-creation functions take succeeding nodes as arguments.  Functions
can mutate a node, a graph, both, or none.  To indicate the different
behaviors, the following name scheme is used:

\begin{itemize}
\item Functions mutating a node or the mapping of labels to nodes are
      prefixed by [[set_]].
\item Function mutating a control-flow graph are prefixed by [[gm_]]
      (graph mutator).
\item Observation functions have no special prefix.
\end{itemize}

\begin{quote}\it
    NR proposes to hide a node's live-set behinf an abstract type
    [[node_state]] that is provided by a functor argument. --CL
\end{quote}

<<types and ops>>=
type cfg        
type t = cfg    (* Cfg.t looks JustBetter *)
type node
<<type conts>>
<<type formal>>
<<type actual>>

(* cfg creation *)
val mk:         unit -> cfg

(* label mutator/oberservation *)
val set_label:  cfg -> string -> node -> unit
val lookup:     cfg -> string -> node                 

(* cfg observation *)
val entry:      cfg -> node 
val exit:       cfg -> node 

(* cfg traversal, except fold requires (enumerated cfg)  *)
val fold:       cfg -> (node -> 'a -> 'a) -> 'a -> 'a (* must not use gm_xxx *)
val first:      cfg -> node (* wrt numbering *)
val last:       cfg -> node (* wrt numbering *)
val scan_fwd:   cfg -> first:int -> last:int -> (node -> 'a -> 'a) -> 'a -> 'a 
val scan_bwd:   cfg -> first:int -> last:int -> (node -> 'a -> 'a) -> 'a -> 'a
val next:       node -> node option
val prev:       node -> node option

(* add node to cfg, ensures: not (enumerated cfg) *)
val gm_assign:  cfg -> Rtl.rtl -> succ:node -> node
val gm_return:  cfg -> Rtl.rtl -> int * int -> node
val gm_goto:    cfg -> Rtl.rtl -> node list -> node
val gm_jump:    cfg -> Rtl.rtl -> node list -> node
val gm_cutto:   cfg -> Rtl.rtl -> conts     -> node
val gm_call:    cfg -> Rtl.rtl -> conts -> succ:node -> node
val gm_branch:  cfg -> Rtl.rtl -> ifso:node -> ifnot:node -> node
val gm_dummy:   cfg -> node

(* add linear sequence of assign nodes to cfg, ensures: not (enumerated cfg *)
val gm_copyi:   cfg -> formal list -> Automaton2.t -> succ:node -> node * Automaton2.t
val gm_copyo:   cfg -> actual list -> Automaton2.t -> succ:node -> node * Automaton2.t

(* cfg mutators, ensures: not (enumerated cfg) *)
val gm_delete:                  node -> unit
val gm_redirect_all:            node -> src:node -> dst:node -> unit
val gm_insert_assign_before:    node -> Rtl.rtl -> unit (* any node *)
val gm_insert_assign_after:     node -> Rtl.rtl -> unit (* assign node only *)
val gm_insert_assign_between:   Rtl.rtl -> src:node -> dst:node -> unit
val gm_enumerate:               cfg -> unit (* post: enumerated cfg *)

(* node observation *)
val cfg:        node -> cfg
val rtl:        node -> Rtl.rtl
val succ:       node -> node list       (* no duplicates *)
val pred:       node -> node list       (* no duplicates *)
val live:       node -> Register.Set.t
val number:     node -> int             (* pre: enumerated cfg *)

(* node mutators *)
val set_live:   node -> Register.Set.t -> unit (* set live set *)
val set_rtl:    node -> (Rtl.rtl -> Rtl.rtl) -> unit
@

% ------------------------------------------------------------------ 
\subsubsection{Graph creation}
% ------------------------------------------------------------------ 

\begin{description}
\item[mk] 
    Creates an empty {\cfg} that just contains an entry node connected
    to an exit node. Numbering of nodes is absent and no labels are defined.
\end{description}

% ------------------------------------------------------------------ 
\subsection{Graph observation}
% ------------------------------------------------------------------ 

\begin{description}
\item[entry]
    The {\cfg}'s unique entry node.
\item[exit]     
    The {\cfg}'s unique exit node.

\item[fold]     
    Traverses the nodes of the {\cfg} in a ``natural'' order.  It is
    an unchecked run-time error if the function passed to [[fold]]
    calls a graph mutator.

\item[scan\_fwd]
    Scans the nodes in the [[first]] \dots [[last]] interval in enumeration
    order and passes nodes to the supplied function. Each of the following
    is a checked run-time error:  absent numbering, [[first]] greater
    than [[last]]. It is an unchecked run-time error when the supplied
    function uses any graph mutator.

\item[scan\_bwd]
    Like [[scan_fwd]], except that the interval in reverse order,
    from [[last]] to [[first]].

\item[prev/next]
    Returns the previous/next node with respect to node numbering, or
    [[None]] if there is no such.  It is a checked run-time error to
    use this function when numbering is \emph{absent}.
    
\end{description}

% ------------------------------------------------------------------     
\subsubsection{Labels}
% ------------------------------------------------------------------ 

\begin{description}
\item[set\_label]    
    Assign a label to a node.  It is a checked run-time error if the
    node does not belong to the {\cfg}.  It is also a checked run-time
    error to assign a label twice.

\item[lookup]   
    Lookup a node by name.  If a node has a label of that name, the
    node is returned, otherwise [[Not_found]] is raised.
\end{description}

% ------------------------------------------------------------------ 
\subsubsection{Node Creation}
% ------------------------------------------------------------------ 

The kind of a node is encoded into the function that creates it. 
Depending on its kind, a node takes a number of arguments:  the graph
it belongs to, an {\rtl} and its successors.  The [[cutto]] and
[[call]] nodes take a continuation bundle that includes several nodes,
denoting continuations that can be reached from that node.

<<type conts>>=
type conts =    { cuts    : node list
                ; unwinds : node list
                ; returns : node list
                ; aborts  : bool
                }
@

The creation of a node also adds it to the {\cfg}; because of this,
all node creation functions are marked as graph mutators.  Graph
mutators must not be called by certain functions that traverse a
{\cfg}.  All graph mutators cause a node numbering to become
\emph{absent}.


A [[dummy]] node is its own successor.  It is used as a placeholder
for labeled nodes that are not yet defined.  Use [[redirect]] to
update its successor. 

Parameter passing is implemented by sequences of [[assign]] nodes that
transfer parameters from location determined by calling conventions to
registers, and vice versa.  These sequences of assignments are created
by functions \emph{copy-in} and \emph{copy-out} that take their
successor as argument return the topmost node of the sequence they
create.  Calling conventions are implemented by automata that are
passed to the functions and returned in an advanced state.  The
[[copyi]] function implements receiving parameters, the [[copyo]]
function passing actual parameters. 

<<type formal>>=
type formal =   { name:      string 
                ; width:     Rtl.width       (* bits *)
                ; hint:      string option   (* C-- hint *)
                ; index:     int             (* run-time API index*)
                } 

<<type actual>>=
type actual     = Rtl.exp 
                * Rtl.width 
                * string option               (* hint *)
@

% ------------------------------------------------------------------ 
\subsubsection{Graph Mutation}
% ------------------------------------------------------------------ 

All graph mutations destroy node \emph{numbering} and must not be used
while traversing a graph.

\begin{description}
\item[delete] 
    Deletes a node from a [[cfg]].  It is a checked run-time
    error, if:  the node has any successor, is an exit, or is an entry
    node.

\item[redirect\_all] 
    An outgoing edge (to a successor) can be redirected to
    another node.  The current successor and the new successor must be
    provided.  It is a checked run-time error if:  nodes belong to
    different {\cfg}s, or the [[from]] node is not an actual
    predecessor.

    Note, that if several outgoing edges of a node point to the same
    successor, they \emph{all} get updated to the new node.  Hence,
    [[redirect]] is not fully general.

\item[insert\_assign\_before] 
    Inserts an [[assign]] node $a$ before a node $n$,
    using the supplied {\rtl}.  It is a checked run-time error if the
    node $n$ was not created by the [[assign]] function.  The
    successors of $n$ become successors of $a$ and $a$ becomes the
    only successor of $n$.
                 
\item[insert\_assign\_after] 
    Like [[insert_assign_before]], except that the assign node is
    placed after the node.  Since the node must be an [[assign]] node,
    it has only one outgoing edge and therefore this operation is well
    defined.  

\item[insert\_assign\_between]
    Inserts an assign node on every edge leading from [[src]] to
    [[dst]]. The predecessor/successor relationship of all nodes is
    updated to reflect the insertion of the assign node on all
    affected edges. Nothing happens, if no edge between [[src]] and
    [[dst]] exists.

\item[enumerate]
    Establishes a numbering for all nodes of a {\cfg}; until a
    graph mutator is called the numbering is \emph{present}.
\end{description}

% ------------------------------------------------------------------ 
\subsubsection{Node Observation}
% ------------------------------------------------------------------ 

The observation functions for nodes return the obvious values.  Every
node contains a (mutable) set of registers; this set is empty in a new
node. 

\begin{description}
\item[live] 
    Registers live \emph{before} this node.

\item[number] 
    Reports the number of a node. It is a checked run-time
    error to invoke this function if node numbering is absent,
    i.e.~if [[numbered]] is [[false]].
\end{description}

\begin{quote}\it
    The register allocation phase takes a bit more abstract view 
    for numbering nodes by using a [[Point.t]] type. A [[Point.t]]
    must provide one value [[Point.zero]] which is never assigned to a
    node. The current design of using integers to number nodes and let
    numbering start at 1 is compatible with that view. Maybe the
    connection should be made more explicit. -CL
\end{quote}
% ------------------------------------------------------------------ 
\subsubsection{Node Mutators}
% ------------------------------------------------------------------ 

Node mutators are considered generally ``safe'' because they don't
interact with other functions. 

\begin{description}
\item[set\_live] 
    Updates the live-set of a node.
    
\item[set\_rtl]
    Set the {\rtl} of a node to a new value using a maping function.
\end{description}


% ------------------------------------------------------------------ 
\subsection{Putting the Interface together}
% ------------------------------------------------------------------ 

Here are some dummy signatures to make the interface self-contained. 
This can be used to play with implementation in the {\ocaml}
interpreter. 

<<dummy sigs>>=
module Rtl : sig 
    type rtl 
    type exp 
    type width
    val null: rtl
end

module Register : sig
    module Set : sig
        type t
    end
end

module Automaton2 : sig
    type t
end
@

Currently we have some code that expects a signature [[S]] and some
that doesn't. This should be cleaned up.

<<cfg3.mli>>=
(** dummy sigs **)
module type S = sig
    <<types and ops>>
end
<<types and ops>>
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<cfg3.ml>>=
(* postponed *)
@

