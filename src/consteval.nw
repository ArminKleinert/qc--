% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

\input{macros.tex}

% ------------------------------------------------------------------ 
\section{Evaluating constant expressions}
% ------------------------------------------------------------------ 

This code will one day be replaced by a small interpreter for constant
expressions.

<<consteval.mli>>=
exception Not_constant of Rtl.exp

type relexpr
  (* a relocatable expression, suitable for using as a link-time
     constant in an assembler---needs to be connected with Asm2.S *)
  = Rtl.exp (* a temporary expedient *)

val compile : Rtl.exp -> Bits.bits   (* a compile-time constant *)
val link    : Rtl.exp -> relexpr
@
<<consteval.ml>>=
exception Not_constant of Rtl.exp
type relexpr = Rtl.exp (* a flagrant cheat *)

let compile e = match Rtl.Convert.exp e with
  | Rtl.Private.Const(Rtl.Private.Bits (bits,w)) -> (bits, w)
  | _ -> raise (Not_constant e)
    (* should really try to use Const.lookup to evaluate ``link-time''
      constants, but we don't yet *)

let link e = e (* damn lie *)
