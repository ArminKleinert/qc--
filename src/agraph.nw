% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{An abstract view of a flow graph}

<<agraph.mli>>=
module type S = sig
type graph
type node
@ 
Nodes have to have properties---notably, span bindings.
We don't want to have to pass properties to every node-creation
function.
So instead, we add a new type: [[unode]], for ``unmarked node.''
We then use [[bind]] to add properties.
<<agraph.mli>>=
type unode (* a node without any properties *)
type properties
val bind : properties -> unode -> node
@ Types [[unode]] and [[node]] might have exactly the same
representation, but by using [[node]] as arguments and returning
[[unode]] as results, we ensure that in any well-typed program, some
properties are bound to each node.
@
At the moment, the only interesting properties are span bindings.
<<agraph.mli>>=
module Prop : sig (* property stuff *)
  val empty : properties
  type link_time_constant = Rtl.expr
  val add_span : Bits.bits -> link_time_constant -> properties -> properties
end
@ 

<<agraph.mli>>=
type label = string (* a label in the C-- source language *)

module Make : sig
  <<constructor functions>>
end
@ 
We make new graphs with [[Make.graph]].
<<constructor functions>>=
val graph : unit -> graph (* build a new flow graph *)
@ 
Every node belongs to exactly one graph.
The graph might have to be an explicit argument to the function that
builds the node, or if the constructor function takes another node,
the graph is implicit, since if two nodes are related they belong to
the same graph.
@
We start translating back to front, with the exit node.
As we build the flow graph, we always have edges that provide the
control flow out of the node and through the graph, all the way to an
unconditional [[goto]] or to the exit node.
<<constructor functions>>=
val exit : graph -> unode (* the unique exit node of this graph *)
@ 
When we specify a [[goto]], we also need to say what graph it belongs
to.
Also, the front end must say what the possible targets are.
It is a checked run-time error to pass an empty list of target labels
to [[Make.goto]].
<<constructor functions>>=
val goto : graph -> Rtl.expr -> label list -> unode
@ 
To build ordinary nodes, we pass one or two successor nodes.
<<constructor functions>>=
val branch  : Rtl.expr -> node -> node -> unode
val assign  : Rtl.rtl  -> node -> unode
val copy_in  : Fgraph.formal list -> Fgraph.context -> Fgraph.convention -> node -> unode
val copy_out : Fgraph.actual list -> Fgraph.context -> Fgraph.convention -> node -> unode
@ 
To return from a {\PAL} procedure, you have to say which return
continuation you want and what the total is.
<<constructor functions>>=
type continuation = int
type count = int
val return : graph -> continuation -> count -> unode
@ 
Let's just do tail calls.
<<constructor functions>>=
type cont = { normal  : node
            ; cuts    : label list
            ; unwinds : label list
            ; returns : label list
            ; aborts  : bool
            } 
val call : Rtl.expr -> cont -> unode
val jump : graph -> Rtl.expr -> label list -> unode
@ 
Ugh.
<<agraph.mli>>=
end
@ 
