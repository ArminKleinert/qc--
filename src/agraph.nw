% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}


% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution AST AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{An abstract view of a flow graph}
% ------------------------------------------------------------------ 

A procedure is represented by a flow-graph that is built through an
abstract interface defined by this module.  The idea is to have
different implementations of a flow graph during development for
testing and code generation.  For example, a flow graph could be
implemented as a {\PAL} {\AST} (which ce be pretty-printed), or as a
graph for the graph layout-language {\small DOT} for visualization. 
For the compile process a flow-graph implementation will use the
low-level details defined in the \module{ir} module.

We also intent to stack flow graph implementations on top of each
other: 

<<stack>>=
module type G = Agraph.S
module Level0: G                                (* lowest level *)
module Level1 = Level1Make(Level0): G
module Level2 = Level2Make(Level1): G
...
@

Implementations of an abstract flow graph interface use lower-level
implementations to define a higher-level implementations. This scheme
requires, that the implementations are functors that take a flow-graph
implementation and implement one.


% ------------------------------------------------------------------ 
\subsection{Interface Overview}
% ------------------------------------------------------------------ 

The interface of an abstract is captured in a signature [[S]] which is
used to describe the result of a functor that implements it. To avoid
problems with type definitions when stacking implementations, [[S]]
does not define the representation of types. Types shared by all
implementation are defined outside of [[S]].
declarations 
to 

<<agraph.mli>>=
<<shared types>>
<<signature S>>
@

<<signature S>>=
module type S = sig
    type graph
    type node           (* node with properties *)
    type unode          (* node w/o  properties *)
    type cont           (* continuation bundle  *)

    <<module Props>>
    val bind : Props.properties -> unode -> node
    
    <<module Make>>
end
@

A flow-graph [[graph]] consists of [[node]]s with properties defined
by sub-module [[Props]].  Properties are bound to nodes by [[bind]].
The [[Make]] module captures all functions to create graphs and nodes. 

Nodes with and without properties have different types [[node]] and
[[unode]].  They might have exactly the same representation, but by
using [[node]] as arguments and returning [[unode]] as results, we
ensure that in any well-typed program, some properties are bound to
each node. 

% ------------------------------------------------------------------ 
\subsection{Types}
% ------------------------------------------------------------------ 

The details of a flow graph contain some more data types below the
level of [[graph]], [[node]], and [[unode]]. 

Certain concepts from the {\PAL} are just represented as strings:

\begin{itemize}
\item Labels, like procedure names.
\item Variables.
\item Hints.
\item Calling Conventions.
\end{itemize}

<<shared types>>=
type label      = string (* C-- label    *)
type variable   = string (* C-- variable *)
type hint       = string option
@

Parameters are passed into a procdure, into a continuation, or out of
a procedure. The three different places are covered by a [[context]].

<<shared types>>=
type context     = ProcParameters
                 | ProcResults
                 | ContParameters
@

Alternate return continuations are represented by a type [[cuts]],
that list the different continuations by name. If a call can cut to a
non-local continuation, [[aborts]] is true.

<<shared types>>=
type cuts      = { cuts    : string list
                 ; unwinds : string list
                 ; returns : string list
                 ; aborts  : bool
                 }
@

A formal parameter is a variable, an actual parameter an expression. Both
can have optional hints, and have a [[width]], i.e.~a type. 

<<shared types>>=
type formal      = { name:      string 
                   ; width:     Rtl.width       (* bits *)
                   ; hint:      string option   (* C-- hint *)
                   ; index:     int             (* run-time API *)
                   } 
type actual      = Rtl.expr * Rtl.width * hint 
@

% ------------------------------------------------------------------ 
\subsection{Properties}
% ------------------------------------------------------------------ 

Nodes have to have properties---notably, span bindings.  We don't want
to have to pass properties to every node-creation function.  So
instead, we add a new type:  [[unode]], for ``unmarked node.'' We then
use [[bind]] to add properties.

\begin{itemize}
\item Span bindings allow to mark regions of source code with a
      compile-time constant key, and a link-time constant value.
\item Comments attached to nodes by [[add_comment]] help to debug
      generated code. A comment must not contain a newline character. 
\end{itemize}

<<module Props>>=
module Props : sig 
    type properties

    val empty       : properties
    val add_span    : Bits.bits -> Rtl.const -> properties -> properties
    val add_comment : string -> properties -> properties 
end    
@

% ------------------------------------------------------------------ 
\subsection{Conctruction functions}
% ------------------------------------------------------------------ 

A flow-graph uses {\rtl}s to represent expressions and assignments. 
It takes these from the low-level representation of the {\ir} in
module \module{ir}. 

<<module Make>>=
module Make : sig
  <<constructor functions>>
end
@ 

We make new graphs, representing a single procedure, with
[[Make.graph]]. A graph is initialized with some abstract value of
type [[ginit]].

<<constructor functions>>=
val  graph : unit -> graph (* build a new flow graph *)
@ 

Every node belongs to exactly one graph.  The graph might have to be
an explicit argument to the function that builds the node, or if the
constructor function takes another node, the graph is implicit, since
if two nodes are related they belong to the same graph.

<<>>=
val graph_of : node -> graph
@

We start translating back to front, with the [[exit]] node.  As we
build the flow graph, we always have edges that provide the control
flow out of the node and through the graph, all the way to an
unconditional [[goto]] or to the exit node. The top node of a flow
graph, that is of a procedure, is an [[entry]] node. The

<<constructor functions>>=
val exit  : graph -> unode (* the unique exit node of this graph *)
val entry : node -> unode  (* the unique entry node of this graph *)
@ 

When we specify a [[goto]], we also need to say what graph it belongs
to.  Also, the front end must say what the possible targets are.  It
is a checked run-time error to pass an empty list of target labels to
[[Make.goto]].

<<constructor functions>>=
val goto : graph -> Rtl.expr -> label list -> unode
@ 

To build ordinary nodes, we pass one or two successor nodes.  The
following functions just hide the fact that nodes in the flow graph
(defined in module \module{ir}) sometimes are just references to
nodes.  Otherwise each of the following functions does the obvious: 
in creates a [[Branch]], [[Assign]], or [[Copy*]] node and returns it.

The [[copy_in]] and [[copy_out]] functions need the calling convention
they should implement for parameter passing. 

<<constructor functions>>=
val branch  : Rtl.expr -> node -> node -> unode
val assign  : Rtl.rtl  -> node -> unode
val copy_in  : formal list -> context -> Target.conv -> node -> unode
val copy_out : actual list -> context -> Target.conv -> node -> unode
@ 

To return from a {\PAL} procedure, you have to say which return
continuation you want and what the total is; the first [[int]]
parameter describes the continuation, the second the total number of
return continuations available for return.

<<constructor functions>>=
val return : graph -> int -> int -> unode
@ 

When a call returns, it can do a normal or abnormal return.  All the
points a call can returned to are represented by an abstract
continuation bundle [[cont]].  A continuation bundle is created by
[[make_cont]] from the normal return point (in the flow graph) and all
alternate return points.

<<constructor functions>>=
val make_cont: node -> cuts -> cont
@

A call receives a [[cont]] that includes the continuation for normal
and abnormal returns.  The {\AST} includes a list of targets for a
call which is ignored in the flow graph and thus not passed to
[[call]].  A [[jump]], on the other hand, does receive a list of
targets.

<<constructor functions>>=
val call : Rtl.expr -> cont -> unode  (* no target labels *)
val jump : graph -> Rtl.expr -> label list -> unode
@ 

A [[goto]] label in the source code introduces a label in the flow
graph. The node to be labeled is passed to [[label]]. 

<<constructor functions>>=
val label : label -> node -> unode
@

% ------------------------------------------------------------------ 
\subsection{Empty Implementation}
% ------------------------------------------------------------------ 

We feel that the abstract flow-graph interface is too unstable to
provide an implementation. So this is not The Real Thing.

<<agraph.ml>>=
<<shared types>>
<<signature S>>
@
