% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% agraph == abstract graph

\input{macros.tex}

% ------------------------------------------------------------------ 
\section{An abstract view of a flow graph}
% ------------------------------------------------------------------ 

The details of a flow graph as defined in module \module{ir} are
hidden during its construction.  This module provides an abstract
graph interface that is mainly used by the \module{ast2ir} module.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface is captured in a signature [[S]] which is used to
describe the result of a functor that implements it.

<<agraph.mli>>=
module type S = sig
    <<signature S>>
end

<<signature S>>=
type graph
@ 

Nodes have to have properties---notably, span bindings.  We don't want
to have to pass properties to every node-creation function.  So
instead, we add a new type:  [[unode]], for ``unmarked node.'' We then
use [[bind]] to add properties.

<<>>=
module Props : sig (* property stuff *)
    <<signature Props>>
end
@ 

<<>>=
type node
type unode (* a node without any properties *)
val bind : Props.properties -> unode -> node
@ 

Types [[unode]] and [[node]] might have exactly the same
representation, but by using [[node]] as arguments and returning
[[unode]] as results, we ensure that in any well-typed program, some
properties are bound to each node.  At the moment, the only
interesting properties are span bindings.

<<>>=
type label = string (* a label in the C-- source language *)
@

% ------------------------------------------------------------------ 
\subsubsection{Properties}
% ------------------------------------------------------------------ 

<<signature Props>>=
type properties

val empty : properties
val add_span : Bits.bits -> Rtl.const -> properties -> properties
@

% ------------------------------------------------------------------ 
\subsubsection{Conctruction functions}
% ------------------------------------------------------------------ 

<<signature S>>=
module Make : sig
  <<constructor functions>>
end
@ 

We make new graphs with [[Make.graph]].
<<constructor functions>>=
val graph : unit -> graph (* build a new flow graph *)
@ 

Every node belongs to exactly one graph.  The graph might have to be
an explicit argument to the function that builds the node, or if the
constructor function takes another node, the graph is implicit, since
if two nodes are related they belong to the same graph.

We start translating back to front, with the exit node.  As we build
the flow graph, we always have edges that provide the control flow out
of the node and through the graph, all the way to an unconditional
[[goto]] or to the exit node.

<<constructor functions>>=
val exit : graph -> unode (* the unique exit node of this graph *)
@ 

When we specify a [[goto]], we also need to say what graph it belongs
to.  Also, the front end must say what the possible targets are.  It
is a checked run-time error to pass an empty list of target labels to
[[Make.goto]].

<<constructor functions>>=
val goto : graph -> Rtl.expr -> label list -> unode
@ 

To build ordinary nodes, we pass one or two successor nodes.
<<constructor functions>>=
val branch  : Rtl.expr -> node -> node -> unode
val assign  : Rtl.rtl  -> node -> unode
val copy_in  : Fgraph.formal list -> Fgraph.context -> Fgraph.convention -> node -> unode
val copy_out : Fgraph.actual list -> Fgraph.context -> Fgraph.convention -> node -> unode
@ 
To return from a {\PAL} procedure, you have to say which return
continuation you want and what the total is.

<<constructor functions>>=
type continuation = int
type count = int
val return : graph -> continuation -> count -> unode
@ 
Let's just do tail calls.
<<constructor functions>>=
type cont = { normal  : node
            ; cuts    : label list
            ; unwinds : label list
            ; returns : label list
            ; aborts  : bool
            } 
val call : Rtl.expr -> cont -> unode
val jump : graph -> Rtl.expr -> label list -> unode
@ 

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The abstract graph provides a view on the the flow graph defined in
module{ir}.  While the graph representation there is applicative we
take updatable view on a graph here.

<<agraph.ml>>=
module G = Fgraph.M
module F = Fgraph
module type S = sig
    <<signature S>>
end
@

A [[graph]] is an updatable data structure. 

<<>>=
type graph = Fgraph.graph ref
@

There are two kinds of nodes:  [[node]s with properties, and unmarked
[[unode]]s without.  The representation of [[node]] and [[unode]] is
the same; the distinction in the type system still allows to express
some useful properties. 

<<>>=
module Props = struct
    <<module Props>>
end

type node  = { graph: graph
             ; props: Props.properties
             ; node : Fgraph.node
             } 
type unode = node 
@

% ------------------------------------------------------------------ 
\subsubsection{Constructor functions}
% ------------------------------------------------------------------ 

The constructor functions for a graph are grouped together in a
sub-module [[Make]]:

<<>>=
module Make = struct
    <<module Make>>
end
@

A initially empty graph is created by [[graph]]. 

<<module Make>>=
type cont = { normal  : node
            ; cuts    : string list
            ; unwinds : string list
            ; returns : string list
            ; aborts  : bool
            } 
@
<<>>=
let graph () = ref G.empty
@

<<>>=
let exit graph = 
    { graph = graph
    ; props = Props.empty
    ; node  = F.Exit
    }
@

<<>>=
let goto graph expr labels =
    { graph = graph
    ; props = Props.empty
    ; node  = F.Goto(expr, List.map (fun n -> F.Name n) labels)
    }
@

<<>>=
let unode () =
    { graph  = graph ()
    ; props  = Props.empty
    ; node   = F.Exit
    }

let branch   expr n1 n2                 = unode ()
let assign   rtl node                   = unode ()
let copy_in  formals context cc node    = unode ()
let copy_out actuals context cc node    = unode ()
let return   graph cont count           = unode ()
let call     rtl cont                   = unode ()
let jump     graph expr labels          = unode ()
@
    
     

% ------------------------------------------------------------------ 
\subsubsection{Properties}
% ------------------------------------------------------------------ 

A node may have propertiesr; properties are independent of each other
and may be absent.

\begin{itemize}
\item The [[span]] property consists of the span's key (or token) 
      and its value, which is a link-time constant.
\end{itemize}

<<module Props>>=
type properties = { span: (Bits.bits * Rtl.const) option }
@
              
The [[empty]] property simply provides no [[span]] information.

<<>>=  
let empty     = { span = None }
@

To add a span, the span information is updated. Should we signal when
there is already a span information?

<<>>=
let add_span key value p = { p with span = Some(key,value) } 
@


