% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% agraph == abstract graph

\input{macros.tex}


% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% ------------------------------------------------------------------ 
\section{An abstract view of a flow graph}
% ------------------------------------------------------------------ 

The details of a flow graph as defined in module \module{ir} are
hidden during its construction.  This module provides an abstract
graph interface that is mainly used by the \module{ast2ir} module.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface is captured in a signature [[S]] which is used to
describe the result of a functor that implements it.

<<agraph.mli>>=
module type S = sig
    <<signature S>>
end

<<signature S>>=
type graph
@ 

Nodes have to have properties---notably, span bindings.  We don't want
to have to pass properties to every node-creation function.  So
instead, we add a new type:  [[unode]], for ``unmarked node.'' We then
use [[bind]] to add properties.

<<>>=
module Props : sig 
    <<signature Props>>
end
@ 

<<>>=
type node  (* node with properties *)
type unode (* node w/o  properties *)
val bind : Props.properties -> unode -> node
@ 

Types [[unode]] and [[node]] might have exactly the same
representation, but by using [[node]] as arguments and returning
[[unode]] as results, we ensure that in any well-typed program, some
properties are bound to each node.  At the moment, the only
interesting properties are span bindings.

<<>>=
type label = string (* a label in the C-- source language *)
@

% ------------------------------------------------------------------ 
\subsubsection{Properties}
% ------------------------------------------------------------------ 

<<signature Props>>=
type properties

val empty : properties
val add_span : Bits.bits -> Rtl.const -> properties -> properties
@

% ------------------------------------------------------------------ 
\subsubsection{Conctruction functions}
% ------------------------------------------------------------------ 

<<signature S>>=
module Make : sig
  <<constructor functions>>
end
@ 

We make new graphs with [[Make.graph]].
<<constructor functions>>=
val graph : unit -> graph (* build a new flow graph *)
@ 

Every node belongs to exactly one graph.  The graph might have to be
an explicit argument to the function that builds the node, or if the
constructor function takes another node, the graph is implicit, since
if two nodes are related they belong to the same graph.

We start translating back to front, with the exit node.  As we build
the flow graph, we always have edges that provide the control flow out
of the node and through the graph, all the way to an unconditional
[[goto]] or to the exit node.

<<constructor functions>>=
val exit : graph -> unode (* the unique exit node of this graph *)
@ 

When we specify a [[goto]], we also need to say what graph it belongs
to.  Also, the front end must say what the possible targets are.  It
is a checked run-time error to pass an empty list of target labels to
[[Make.goto]].

<<constructor functions>>=
val goto : graph -> Rtl.expr -> label list -> unode
@ 

To build ordinary nodes, we pass one or two successor nodes.  The
following functions just hide the fact that nodes in the flow graph
(defined in module \module{ir}) sometimes are just references to
nodes.  Otherwise each of the following functions does the obvious: 
in creates a [[Branch]], [[Assign]], or [[Copy*]] node and returns it.

<<constructor functions>>=
val branch  : Rtl.expr -> node -> node -> unode
val assign  : Rtl.rtl  -> node -> unode
val copy_in  : Fgraph.formal list -> Fgraph.context -> Fgraph.convention -> node -> unode
val copy_out : Fgraph.actual list -> Fgraph.context -> Fgraph.convention -> node -> unode
@ 

To return from a {\PAL} procedure, you have to say which return
continuation you want and what the total is.

<<constructor functions>>=
type continuation = int
type count        = int
val return : graph -> continuation -> count -> unode
@ 


An abstract continuation bundle contains a node for the normal
continuation and the names for all other. The type declaration is put
into a {\noweb} chunk so it can be re-used in the implementation.

<<constructor functions>>=
<<cont type>>=
type cont = { normal  : node
            ; cuts    : string list
            ; unwinds : string list
            ; returns : string list
            ; aborts  : bool
            }
@

<<constructor functions>>=
<<cont type>>
val empty_cont : node -> cont


<<constructor functions>>=
val call : Rtl.expr -> cont -> unode
val jump : graph -> Rtl.expr -> label list -> unode
@ 

A [[goto]] label in the source code introduces a label in the flow
graph. The node to be labeled is passed to [[label]]. 

<<constructor functions>>=
val label : label -> node -> unode
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The abstract graph provides a view on the the flow graph defined in
module{ir}.  While the graph representation there is applicative we
take updatable view on a graph here.

<<agraph.ml>>=
module G = Hashtbl
module F = Fgraph
module type S = sig
    <<signature S>>
end
@

A [[graph]] is an updatable data structure. 

<<>>=
type graph = Fgraph.graph (* = Hashtbl.t *)
@

There are two kinds of nodes:  [[node]s with properties, and unmarked
[[unode]]s without.  The representation of [[node]] and [[unode]] is
the same; the distinction in the type system still allows to express
some useful properties. 

<<>>=
module Props = struct
    <<module Props>>
end

type node  = { graph: graph
             ; props: Props.properties
             ; node : Fgraph.node
             } 
type unode = node 
@

% ------------------------------------------------------------------ 
\subsubsection{Constructor functions}
% ------------------------------------------------------------------ 

The constructor functions for a graph are grouped together in a
sub-module [[Make]]:

<<>>=
module Make = struct
    <<module Make>>
end
@

Labels come in two flavors: those found in the source code, like
goto-labels and procedure names, and those created by the compiler.
For labels found in the source code we like to use [[Fgraph.Name]]
values, and [[Fgraph.Number]] for the other. The function
[[new_label]] returns a fresh label on every invocation. Thanks to the
imperative features of {\ocaml}, an implementation is trivial.

<<module Make>>=
let label_counter = ref 0
let new_label ()  = (incr label_counter; F.Number !label_counter)
@

A list of targets at the abstract syntax level is a list of names. 
These names become [[F.Name]] values at the [[Fgraph]] lavel.  The
[[targets]] function just does this for a list of names.  

<<>>=
let targets = List.map (fun n -> F.Name n)
@

A continuation bundle (or record) includes the normal return point as
a node and all others as labels.  The [[cont]] function translates an
abstract [[cont]] value to a [[Fgraph.cont]] value.

<<>>=
<<cont type>>
let empty_cont node =
    { normal  = node
    ; cuts    = []
    ; unwinds = []
    ; returns = []
    ; aborts  = false (* ??? *)
    } 

let cont c =
    ( c.normal.node
    , targets c.cuts
    , targets c.unwinds
    , targets c.returns
    , c.aborts
    )
@

A initially empty graph is created by [[graph]].  The hash table
implementation likes a suggest initial size but grows as needed. 

<<>>=
let graph () = 
    let initial_size = 1000 
    in
        G.create initial_size
@

<<>>=
let exit graph = 
    { graph = graph
    ; props = Props.empty
    ; node  = F.Exit
    }
@

<<>>=
let goto graph expr labels =
    { graph = graph
    ; props = Props.empty
    ; node  = F.Goto(expr, targets labels)
    }
@

The [[unode]] function creates a dummy node which we use for cheating
in case our implementation is not ready yet.

<<>>=
let unode () =
    { graph  = graph ()
    ; props  = Props.empty
    ; node   = F.Exit
    }
@

At the level of [[Fgraph]] the two nodes of a branch are labels of
nodes rather than nodes.  So we have to create a label for each node,
add each under its label to the graph and return the node containing
the labels to them.

<<>>=    
let branch expr n1 n2 = 
    let graph  = n1.graph                  in
    let l1,l2  = new_label (), new_label() in
        ( G.add graph l1 n1.node
        ; G.add graph l2 n2.node
        ; { graph = graph
          ; props = Props.empty
          ; node  = F.Branch(expr,l1,l2)
          }
        )
@
    
The abstract view of [[Agraph]] and the concrete view of [[Fgraph]]
are more or less the same for a number of nodes. The implementation of
the creation functions is thus simple for the following nodes:

\begin{itemize}
\item [[assign]]
\item [[jump]]
\item [[call]]
\end{itemize}
    
<<>>=
let assign rtl node =                   
    { graph = node.graph
    ; props = Props.empty
    ; node  = node.node
    }

<<>>=
let jump graph expr labels =
    { graph = graph
    ; props = Props.empty
    ; node  = F.Jump(expr,targets labels)
    }    

<<>>=
let call expr ctn =
    { graph = ctn.normal.graph
    ; props = Props.empty
    ; node  = F.Call(expr,cont ctn)
    }

<<>>=
let copy_in formals context cc node =
    { graph = node.graph
    ; props = Props.empty
    ; node  = F.CopyIn
              ( formals
              , context
              , cc
              , node.node
              )
    }

<<>>=    
let copy_out actuals context cc node =
    { graph = node.graph
    ; props = Props.empty
    ; node  = F.CopyOut
              ( actuals
              , context
              , cc
              , node.node
              )
    }
@

A labeled node must be recorded in the graph. Aside from that, the
same node is returned with its properties striped off.

<<>>=
let label l node =
    let graph = node.graph              in
    let l     = F.Name l                in
    let _     = G.add graph l node.node in (* side effect *)
        { node with props = Props.empty }
    
<<>>=
let return   graph cont count           = unode ()
@
    
     

% ------------------------------------------------------------------ 
\subsubsection{Properties}
% ------------------------------------------------------------------ 

A node may have propertiesr; properties are independent of each other
and may be absent.

\begin{itemize}
\item The [[span]] property consists of the span's key (or token) 
      and its value, which is a link-time constant.
\end{itemize}

<<module Props>>=
type properties = { span: (Bits.bits * Rtl.const) option }
@
              
The [[empty]] property simply provides no [[span]] information.

<<>>=  
let empty     = { span = None }
@

To add a span, the span information is updated. Should we signal when
there is already a span information?

<<>>=
let add_span key value p = { p with span = Some(key,value) } 
@


