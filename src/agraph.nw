% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}


% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution AST AST
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{An abstract view of a flow graph}
% ------------------------------------------------------------------ 

A procedure is represented by a flow-graph that is built through an
abstract interface defined by this module.  The idea is to have
different implementations of a flow graph during development for
testing and code generation.  For example, a flow graph could be
implemented as a {\PAL} {\AST} (which ce be pretty-printed), or as a
graph for the graph layout-language {\small DOT} for visualization. 
For the compile process a flow-graph implementation will use the
low-level details defined in the \module{ir} module.

% ------------------------------------------------------------------ 
\subsection{Interface Overview}
% ------------------------------------------------------------------ 

The interface is captured in a signature [[S]] which is used to
describe the result of a functor that implements it.

<<agraph.mli>>=
<<signature S>>
@

<<signature S>>=
module type S = sig
    type graph
    type node           (* node with properties               *)
    type unode          (* node w/o  properties               *)

    <<types>>
    
    <<module Props>>
    val bind : Props.properties -> unode -> node
    
    <<module Make>>
end
@

A flow-graph [[graph]] consists of [[node]]s with properties defined
by sub-module [[Props]].  Properties are bound to nodes by [[bind]].
The [[Make]] module captures all functions to create graphs and nodes. 

Nodes with and without properties have different types [[node]] and
[[unode]].  They might have exactly the same representation, but by
using [[node]] as arguments and returning [[unode]] as results, we
ensure that in any well-typed program, some properties are bound to
each node. 

% ------------------------------------------------------------------ 
\subsection{Types}
% ------------------------------------------------------------------ 

The details of a flow graph contain some more data types below the
level of [[graph]], [[node]], and [[unode]]. 

Certain concepts from the {\PAL} are just represented as strings:

\begin{itemize}
\item Labels, like procedure names.
\item Variables.
\item Hints.
\item Calling Conventions.
\end{itemize}

<<types>>=
type label      = string (* C-- label    *)
type variable   = string (* C-- variable *)
type hint       = string option
type convention = string
@

Parameters are passed into a procdure, into a continuation, or out of
a procedure. The three different places are covered by a [[context]].

<<>>=
type context     = ProcParameters
                 | ProcResults
                 | ContParameters
@

A formal parameter is a variable, an actual parameter an expression. Both
can have optional hints, and have a [[width]], i.e.~a type. 

<<>>=
type formal      = variable * Rtl.width * hint  (* use a record? *)
type actual      = Rtl.expr * Rtl.width * hint 
@

% ------------------------------------------------------------------ 
\subsection{Properties}
% ------------------------------------------------------------------ 

Nodes have to have properties---notably, span bindings.  We don't want
to have to pass properties to every node-creation function.  So
instead, we add a new type:  [[unode]], for ``unmarked node.'' We then
use [[bind]] to add properties.

<<module Props>>=
module Props : sig 
    type properties

    val empty : properties
    val add_span : Bits.bits -> Rtl.const -> properties -> properties
end    
@

% ------------------------------------------------------------------ 
\subsection{Conctruction functions}
% ------------------------------------------------------------------ 

A flow-graph uses {\rtl}s to represent expressions and assignments. 
It takes these from the low-level representation of the {\ir} in
module \module{ir}. 

<<module Make>>=
module Make : sig
  <<constructor functions>>
end
@ 

We make new graphs, representing a single procedure, with
[[Make.graph]].

<<constructor functions>>=
val graph : unit -> graph (* build a new flow graph *)
@ 

Every node belongs to exactly one graph.  The graph might have to be
an explicit argument to the function that builds the node, or if the
constructor function takes another node, the graph is implicit, since
if two nodes are related they belong to the same graph.

We start translating back to front, with the [[exit]] node.  As we
build the flow graph, we always have edges that provide the control
flow out of the node and through the graph, all the way to an
unconditional [[goto]] or to the exit node. The top node of a flow
graph, that is of a procedure, is an [[entry]] node. The

<<constructor functions>>=
val exit  : graph -> unode (* the unique exit node of this graph *)
val entry : node -> unode  (* the unique entry node of this graph *)
@ 

When we specify a [[goto]], we also need to say what graph it belongs
to.  Also, the front end must say what the possible targets are.  It
is a checked run-time error to pass an empty list of target labels to
[[Make.goto]].

<<constructor functions>>=
val goto : graph -> Rtl.expr -> label list -> unode
@ 

To build ordinary nodes, we pass one or two successor nodes.  The
following functions just hide the fact that nodes in the flow graph
(defined in module \module{ir}) sometimes are just references to
nodes.  Otherwise each of the following functions does the obvious: 
in creates a [[Branch]], [[Assign]], or [[Copy*]] node and returns it.

<<constructor functions>>=
val branch  : Rtl.expr -> node -> node -> unode
val assign  : Rtl.rtl  -> node -> unode
val copy_in  : formal list -> context -> convention -> node -> unode
val copy_out : actual list -> context -> convention -> node -> unode
@ 

To return from a {\PAL} procedure, you have to say which return
continuation you want and what the total is.

<<constructor functions>>=
type continuation = int
type count        = int
val return : graph -> continuation -> count -> unode
@ 

An abstract continuation bundle contains a node for the normal
continuation and the names for all other. The type declaration is put
into a {\noweb} chunk so it can be re-used in the implementation.

<<cont type>>=
type cont = { normal  : node
            ; cuts    : string list
            ; unwinds : string list
            ; returns : string list
            ; aborts  : bool
            }
@

<<constructor functions>>=
<<cont type>>
val empty_cont : node -> cont
@

A call receives a [[cont]] that includes the continuation for normal
and abnormal returns.  The {\AST} includes a list of targets for a
call which is ignored in the flow graph and thus not passed to
[[call]].  A [[jump]], on the other hand, does receive a list of
targets.

<<constructor functions>>=
val call : Rtl.expr -> cont -> unode  (* no target labels *)
val jump : graph -> Rtl.expr -> label list -> unode
@ 

A [[goto]] label in the source code introduces a label in the flow
graph. The node to be labeled is passed to [[label]]. 

<<constructor functions>>=
val label : label -> node -> unode
@

% ------------------------------------------------------------------ 
\subsection{Empty Implementation}
% ------------------------------------------------------------------ 

We feel that the abstract flow-graph interface is too unstable to
provide an implementation. So this is not The Real Thing.

<<agraph.ml>>=
<<signature S>>
@

% ------------------------------------------------------------------ 
\subsection{Unused Implementation}
% ------------------------------------------------------------------ 

Here is an unused implementation that once worked.  Don't take it too
seriously.

A [[graph]] is an updatable data structure. 

<<unused>>=
type graph = Fgraph.graph (* = Hashtbl.t *)
@

There are two kinds of nodes:  [[node]s with properties, and unmarked
[[unode]]s without.  The representation of [[node]] and [[unode]] is
the same; the distinction in the type system still allows to express
some useful properties. 

<<>>=
module Props = struct
    <<module Props implementation>>
end

type node  = { graph: graph
             ; props: Props.properties
             ; node : Fgraph.node
             } 
type unode = node 
@

% ------------------------------------------------------------------ 
\subsubsection{Constructor functions}
% ------------------------------------------------------------------ 

The constructor functions for a graph are grouped together in a
sub-module [[Make]]:

<<>>=
module Make = struct
    <<module Make implementation>>
end
@

Labels come in two flavors: those found in the source code, like
goto-labels and procedure names, and those created by the compiler.
For labels found in the source code we like to use [[Fgraph.Name]]
values, and [[Fgraph.Number]] for the other. The function
[[new_label]] returns a fresh label on every invocation. Thanks to the
imperative features of {\ocaml}, an implementation is trivial.

<<module Make implementation>>=
let label_counter = ref 0
let new_label ()  = (incr label_counter; F.Number !label_counter)
@

A list of targets at the abstract syntax level is a list of names. 
These names become [[F.Name]] values at the [[Fgraph]] lavel.  The
[[targets]] function just does this for a list of names.  

<<>>=
let targets = List.map (fun n -> F.Name n)
@

A continuation bundle (or record) includes the normal return point as
a node and all others as labels.  The [[cont]] function translates an
abstract [[cont]] value to a [[Fgraph.cont]] value.

<<>>=
<<cont type>>
let empty_cont node =
    { normal  = node
    ; cuts    = []
    ; unwinds = []
    ; returns = []
    ; aborts  = false (* ??? *)
    } 

let cont c =
    ( c.normal.node
    , targets c.cuts
    , targets c.unwinds
    , targets c.returns
    , c.aborts
    )
@

An initially empty graph is created by [[graph]].  The hash table
implementation likes a suggested initial size but grows as needed. 

<<>>=
let graph () = 
    let initial_size = 1000 
    in
        G.create initial_size
@

<<>>=
let exit graph = 
    { graph = graph
    ; props = Props.empty
    ; node  = F.Exit
    }
@

<<>>=
let goto graph expr labels =
    { graph = graph
    ; props = Props.empty
    ; node  = F.Goto(expr, targets labels)
    }
@

The [[unode]] function creates a dummy node which we use for cheating
in case our implementation is not ready yet.

<<>>=
let unode () =
    { graph  = graph ()
    ; props  = Props.empty
    ; node   = F.Exit
    }
@

At the level of [[Fgraph]] the two nodes of a branch are labels of
nodes rather than nodes.  So we have to create a label for each node,
add each under its label to the graph and return the node containing
the labels to them.

<<>>=    
let branch expr n1 n2 = 
    let graph  = n1.graph                  in
    let l1,l2  = new_label (), new_label() in
        ( G.add graph l1 n1.node
        ; G.add graph l2 n2.node
        ; { graph = graph
          ; props = Props.empty
          ; node  = F.Branch(expr,l1,l2)
          }
        )
@
    
The abstract view of [[Agraph]] and the concrete view of [[Fgraph]]
are more or less the same for a number of nodes. The implementation of
the creation functions is thus simple for the following nodes:

\begin{itemize}
\item [[assign]]
\item [[jump]]
\item [[call]]
\end{itemize}
    
<<>>=
let assign rtl node =                   
    { graph = node.graph
    ; props = Props.empty
    ; node  = node.node
    }

<<>>=
let jump graph expr labels =
    { graph = graph
    ; props = Props.empty
    ; node  = F.Jump(expr,targets labels)
    }    

<<>>=
let call expr ctn =
    { graph = ctn.normal.graph
    ; props = Props.empty
    ; node  = F.Call(expr,cont ctn)
    }

<<>>=
let copy_in formals context cc node =
    { graph = node.graph
    ; props = Props.empty
    ; node  = F.CopyIn
              ( formals
              , context
              , cc
              , node.node
              )
    }

<<>>=    
let copy_out actuals context cc node =
    { graph = node.graph
    ; props = Props.empty
    ; node  = F.CopyOut
              ( actuals
              , context
              , cc
              , node.node
              )
    }
@

A labeled node must be recorded in the graph. Aside from that, the
same node is returned with its properties striped off.

<<>>=
let label l node =
    let graph = node.graph              in
    let l     = F.Name l                in
    let _     = G.add graph l node.node in (* side effect *)
        { node with props = Props.empty }
@


How is a [[return]] statement represented? How is the return
continuation communicated?
    
<<>>=
let return   graph cont count           = unode ()
@
    
     

% ------------------------------------------------------------------ 
\subsubsection{Properties}
% ------------------------------------------------------------------ 

A node may have properties; properties are independent of each other
and may be absent.

\begin{itemize}
\item The [[span]] property consists of the span's key (or token) 
      and its value, which is a link-time constant.
\end{itemize}

<<module Props implementation>>=
type properties = { span: (Bits.bits * Rtl.const) option }
@
              
The [[empty]] property simply provides no [[span]] information.

<<>>=  
let empty     = { span = None }
@

To add a span, the span information is updated. Should we signal when
there is already a span information?

<<>>=
let add_span key value p = { p with span = Some(key,value) } 
@


