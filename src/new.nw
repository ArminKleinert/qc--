% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Automata for Resource Allocation}
% ------------------------------------------------------------------ 

An automaton encapsulates the ability to assign locations.
Every automaton has a private collection of locations (e.g.,
registers) that it may use at will, plus an ``overflow area.''
The overflow area is located in memory, and it must be contiguous.

Automata are imperative; the type [[Automaton.t]] encapsulates mutable
state.  This state is primarily the private internal state of the
automaton, but there is one part of state that is public.  When an
automaton is ``frozen,'' it is no longer possible to get new locations
from it, but in exchange, one can get the size and alignment
requirement (and also the address) of its overflow area.

Although an \emph{automaton} is imperative, the \emph{specification}
of the automaton is not.  To create an automaton, one needs a
specification, plus the address to be used to point to the overflow
area.  \emph{Addresses always point to the lowest addressed byte, as
in the value returned from [[malloc]].} This address may contain
unbound compile-time constants (see \module{const}).

<<new.mli>>=
<<type abbreviations>>

(* module Automaton *)

type spec  (* specification of an automaton (immutable) *)

type t   (* an automaton (mutable) *)
type loc (* a location provided by an automaton *)

val mk : spec -> Rtl.expr -> t
  (* supply an address of the overflow area, and get back an
     automaton in its initial state *)

  (* get a location and change the automaton's internal state *)
val ty    : t -> Types.ty * string option -> loc    
val block : t -> width    * align         -> loc    


type area = { address : Rtl.expr    (* address of memory block *)
            ; align   : align       (* at run time, must have address mod align = 0 *)
            ; size    : int
            } 

  (* stop getting locations and found out about the overflow area *)
val freeze : t -> area
@ 
Here's what we do with locations:
<<new.mli>>=
val fetch : loc -> width -> Rtl.expr
val store : loc -> Rtl.expr -> width -> Rtl.rtl
@ 
It's possible that several overflow areas, with disjoint lifetimes,
can be overlapped in a single location in memory.

<<new.mli>>=
type placement = EqualHighEnds | EqualLowEnds
val overlap : placement -> area list -> area
  (* Overlap several areas into a larger area, forcing constraints on
     compile-time constants.  May make calls to Const.make_equal, but
     otherwise has no side effects.  It is a checked run-time error to
     overlap areas at the high end unless the size of every area is a
     multiple of its alignment.  N.B. may raise Const.Cannot_solve. *)

@ 

Maybe this chunk should be inlined?
<<type abbreviations>>=
type align = int
type width = int
type size  = int
@ 

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<new.ml>>=
type align      = int
type width      = int
type size       = int

type spec       = BottomUp of Target.t

type area =     { address:      Rtl.expr
                ; align:        align
                ; size:         size
                }

type loc =      { store:    (Rtl.expr -> Rtl.rtl)
                ; fetch:    Rtl.expr
                }
                
class type automaton = object
    val mutable frozen: bool
    method ty:          Types.ty -> string option -> loc
    method block:       size     -> align         -> loc
    method freeze:      area
end   
    
type t = automaton

class bottomup (base: Rtl.expr) (target: Target.t) =
    let wrd = target#wordsize                                           in
    let ptr = target#pointersize                                        in
    let agg = target#byteorder                                          in
    let mem = target#memsize                                            in

    let addptr    x y = Rtl.app ("add",[ptr]) [x;y]                       in
    let constptr  k   = Rtl.const (Rtl.bits (Bits.of_int k ptr) ptr)      in
    let offset    k w = Rtl.cloc 'm' agg w (addptr base (constptr k))     in
    let eff2rtl   eff = Rtl.rtl [(Rtl.const Rtl.truth,eff)]               in
    let write     k w = fun e -> eff2rtl (Rtl.store (offset k w) e w)     in
    let read      k w = Rtl.fetch (offset k w) w                          in
      
     
    object (self)
        val mutable frozen    = false
        val mutable align     = 1
        val mutable k         = 0

        method block width align =
            let _    = assert (not frozen)                                 in
            let _    = assert (width mod mem = 0)                          in
            let _    = if k mod align <> 0 then k <- ((k/align)+1) * align in
            let size = width / mem                                         in
            let loc  = { store = write k width
                       ; fetch = read k width
                       }                                                   in
            let _    = k <- k + size                                  in
                loc

        method ty t (hint: string option) = 
            let width = match t with
                | Types.Bits(n) -> n
                | _ -> assert false
            in
                self#block width 1 

        method freeze =
            let _ = frozen <- true in
            { address = base
            ; size    = k
            ; align   = align
            }
            
    end
    
    

class topdown (base: Rtl.expr) (target: Target.t) = object end

let mk spec base =
    match spec with
    | BottomUp(target) -> new bottomup base target 

let ty     t (size,hint)   = t#ty    size hint
let block  t (width,align) = t#block width align
let freeze t               = t#freeze

let fetch loc width      = loc.fetch 
let store loc expr width = loc.store expr 

type placement = EqualHighEnds | EqualLowEnds

let overlap placement areas = assert false
            

@
