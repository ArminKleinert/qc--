%
%
%

\input{macros.tex}

% l2h substitution rtl RTL
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h substitution ir IR
% l2h substitution AST AST
 
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Roadmap to the source code}
% ------------------------------------------------------------------ 

This section tries to provide an overview of the QC-- compiler. The
order of presentation is roughly the same the compiler uses when it
compiles a source code file. Each of the following sections describes
one source file in {\noweb} format. A single {\noweb} file generally
contains multiple {\ocaml} or other source files and may describe thus
several modules.

\ifhtml\tableofcontents\fi

% ------------------------------------------------------------------ 
\subsection{Let there be \module{main}}
% ------------------------------------------------------------------ 

The top-level module of the {\qcc} compiler is [[Main]] and the
[[Main.main]] function is executed when the compiler starts to work. 
Its  purpose is to process the command line arguments and to use
functions from other modules to perform the requested action. 

\begin{itemize}
\item The command line is parsed into an abstract syntax defined in
      [[cmdline.mli]] which is part of [[main.nw]]. The parser for the
      command line is build in [[main.ml]] from parser combinators
      defined in [[Pc]] (source file [[pc.nw]] in [[cllib/]].

\item The command line syntax is documented in a manual page
      [[qc--.pod]] in Perl's \textit{plain old document} format.  The
      [[mkfile]] contains rules to translate this format to Troff such
      that the final file for the manual page is [[qc--.1]]. The
      command line syntax is also reported when the [[qc--]] binary is
      called with the [[-h]] flag.

\item To include some version informations into the compiler a
      dynamically generated module called [[This]] is included into
      the compiler.  The file [[this.in]] is a template for this
      module.  At compile time it is turned into [[this.ml]] by
      filling in some information with the help of the build process
      that is controlled by the [[mkfile]].
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Driver \module{driver}}
% ------------------------------------------------------------------ 

The driver module mediates between the \module{main} module that
parses the command line and the modules that implement the different
phases of the compiles.  It deals with opening files and printing
error messages.

% ------------------------------------------------------------------ 
\subsection{Scanner and Parser \module{parser}}
% ------------------------------------------------------------------ 

The scanner and parser for {\PAL} are classically generated by Lex and
Yacc tools for {\ocaml}.  A successful parse returns the abstract
syntax of the parsed file.  Except for syntactical issues the scanner
and parser of {\qcc} can be mostly ignored since the abstract syntax
contains all relevant informations.

\begin{itemize}
\item The scanner is defined by the [[scan.mll]] source file.  It
      obtains the type for the tokens returned to the scanner from the
      parser's interface [[parse.mli]] which is automatically
      generated from [[parse.mly]].  The scanner contains several
      scanner like [[token]], [[character]], [[string]], [[comment1]]
      which are used for different contexts of a source file.

\item The generated scanner and parser maintain only a byte counter to
      identify source code positions. In order to emit meaningful
      error messages in later phases of the compiler these byte
      offsets must be attributed with file names and line numbers. The
      scanner maintains in function [[Scan.nl]] a so-called source
      code map of type [[Srcmap.map]] where it records every change of
      newline.
      
\item The parser is generated from the [[parse.mly]] specification. 
      It builds the abstract syntax of the parsed source file
      bottom-up and returns it.  The parse tree contains so-called
      [[At]]-nodes which contain byte-offsets from the start of the
      source file to identify positions.  A [[Srcmap.map]] is required
      to translate them into meaningful file name, line, column
      triples.

\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Source Code Positions \module{srcmap}}
% ------------------------------------------------------------------ 

The scanner and parser generated by {\ocaml} tools provided no easy
way to maintain complex source code position informations. They only
automatically maintain a byte-offset from the beginning of the parses
stream. In order to provide meaningful position informations to the
user a source code position map is used to record additional
informations. 

\begin{itemize}
\item The [[Srcmap]] module provides a [[Srcmap.map]] type to
      synchronize a simple position [[Srcmap.pos]] with a complex
      location [[Srcmap.location]] using [[Srcmap.sync]].

\item The sub-module [[Srcmap.String]] provides functions to format
      source code locations into strings.

\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Abstract Syntax \module{ast}}
% ------------------------------------------------------------------ 

The abstract syntax for a parsed {\PAL} program is defined by
[[ast.asdl]].  {\asdl} is used to specify the syntax because it
provides opportunities to interchange this internal representation
with other implementations. 

\begin{itemize}
\item The {\asdl} specification of the abstract syntax is compiled
      into [[ast.mli]] that contains the actual {\ocaml} data type
      declaration. Additionally a module [[astUtil.ml]] is generated
      that contains code to serialize and de-serialize an abstract
      syntax from a file.

\item For debugging the abstract syntax can be pretty-printed. The
      [[Astpp]] module contains a pretty printer that is implemented
      by pretty-printing combinators from the [[Pp]] module in
      [[cllib/pp.nw]] file.
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Error Propagation \module{error}}
% ------------------------------------------------------------------ 

We want the compiler not stop after the first error in encounters in a
source file but to find as many errors as possible in a single run. 
In order to not get overwhelmed by error messages caused by previous
errors values an algebra of good and bad data must be established:  a
datum from a some data which includes bad data is usually bad.  The
\module{error} module provides the polymorphic [[Error.error]] type to
encapsulate data that is either good or bad, and functions to deal
with it.  This module is heavily used by the \module{elab} module that
checks the static semantics of a {\PAL} program.

% ------------------------------------------------------------------ 
\subsection{{\PAL} Types \module{types}}
% ------------------------------------------------------------------ 

A {\PAL} compiler must check and remember the types of objects in a
{\PAL} program.  Values in a {\PAL} have monomorphic types, predefined
primitive operations polymorphic types.  Type aliases, introduced by
the [[typedef]] construct, are not expressed in the type language but
handled solely resolved at the symbol-table level (in modules
\module{elab} and \module{fenv}).  The \module{types} module provides
data types for types and type-schemes and functions to facilitate
type-matching.  It also contains abbreviations for commonly used
types. 

% ------------------------------------------------------------------ 
\subsection{{\PAL} Values \module{value}, \module{bits}, \module{uint64}}
% ------------------------------------------------------------------ 

Initialized data, [[const]] declared values, and literal values 
be represented in the {\qcc} compiler. {\PAL} considers a value just
as a bit vector to which functions can be applied. These functions
interpret such a bit pattern as a character, signed or unsigned
integer, or a floating point number.

\begin{itemize}
\item Module \module{value} provides a type [[value]] to represent
      values (type [[bitsXX]]) or conditions (type [[bool]]).
      Additionally functions over values to implement [[const]]
      evaluation are provided.

\item A {\PAL} value is a bit-vector of a certain length. The
      \module{bits} module provides a representation for values of
      type [[bits]]. Values are created from {\ocaml} [[int]] values,
      string, or character representations. The \module{bits} module
      provides conversion functions to create [[bits]] values. The
      internal representation of a [[bits]] value is an {\ocaml}
      [[int64]] value.

\item A [[bits]] value can be interpreted \textit{by operations} in
      many different ways: as signed or unsigned integer, as floating
      point value, or as character. All different interpretations
      interpret the same bit patter. This is in contrast to
      conversions between, for example, [[float]] and [[int]] values
      that try to maintain the numeric value but change the bit
      pattern. 
      
      The \module{uint64} module provides unsigned arithmetic
      operations on [[int64]] values (the representation of [[bits]])
      and pattern-preserving conversion between [[int64]] and
      [[float]] values. Some operations are implemented in C by the
      module [[uint64p.c]].

\end{itemize}


% ------------------------------------------------------------------ 
\subsection{Fat Environment \module{fenv}}
% ------------------------------------------------------------------ 

The denotation (meaning) of identifiers in a {\PAL} program is
recorded in so-called fat environment of type [[Fenv.env]]. The fat
environment in particular contains informations about:

\begin{itemize}
\item Denotation of values (registers, labels, continuations,
      constants, imports), including their types. The denotation of a
      constant includes its value.

\item Meaning of name declared by [[typedef]].

\item Informations about the target architecture, including byte order
      and the size of words and pointers.
\end{itemize}

A fat environment comes in two flavors:  dirty and clean.  In a dirty
environment some informations can be marked as erroneous or absent.  A
dirty environment is built up by the \module{elab} module.  After the
static semantics of a program have been checked a dirty environment is
transformed into a clean environment.  In a clean environment
informations are never absent or marked as erroneous.

% ------------------------------------------------------------------ 
\subsection{Check of the static semantics \module{elab}}
% ------------------------------------------------------------------ 

After a {\PAL} program has been successfully parsed its static
semantics are checked.  This means, the program is checked against the
constraints laid out in the {\PAL} reference manual. Due to the
nature of {\PAL} this must be done is a multi-step approach:

\begin{enumerate}
\item A first pass collects type declarations, sorts them
      topologically (c.f.~module \module{topsort}), and enters them
      into the fat environment.

\item A second pass collects constant declarations, sorts them
      topologically, evaluates them and enter them into the fat
      environment. 

\item A third pass anters all other values (like procedures and
      registers) into the fat environment.

\item The fourth and last pass uses the fat environment to check the
      static semantics.  Found errors are propagated using the
      \module{error} module such that as many as possible errors are
      detected without reporting errors resulting from previous
      errors. 

\end{enumerate}

% ------------------------------------------------------------------ 
\subsection{Auxiliary modules \module{aux}, \module{env}, \module{topsort}}
% ------------------------------------------------------------------ 

Some module just provide services for others without laying directly
on the compilation path:

\begin{itemize}
\item \module{aux} provides general purpose functionality that is not
      already provided by the {\ocaml} standard libraries.
\item \module{env} provides applicative maps.
\item \module{topsort} provides an topological sorting function.
      Type and constant declarations depend on each other and must be
      topologically sorted before they can be processed. 
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Register Transfer Lists \module{rtl}}
% ------------------------------------------------------------------ 

The first real compilation step translates the abstract syntax of a
{\PAL} program into the so-called intermediate representation.  This
representation is specified in {\asdl} in order to facilitate exchange
of it with programs external to the compiler.  The intermediate
representation for procedures ({\ir}) is essentially a control-flow
graph whose nodes contain register transfer lists ({\rtl}s). 

% ------------------------------------------------------------------ 
\subsection{Flow graph \module{fgraph}}
% ------------------------------------------------------------------ 

This intermediate representation for procedures is currently unused. 

% ------------------------------------------------------------------ 
\subsection{Abstract flow graph \module{agraph}}
% ------------------------------------------------------------------ 

The {\ir} is not built directly but through an abstract interface.
Using the interface to build the {\ir} is just one way of using it.
The same interface can probably be used to create very different
representations of a {\PAL} program as well.

% ------------------------------------------------------------------ 
\subsection{Creation of an {\ir} \module{ast2ir}}
% ------------------------------------------------------------------ 

The translation from the abstract syntax ({\AST}) to the intermediate
representation ({\ir}) is done by the \module{ast2ir} module. It
traverses the {\AST} and call functions from the abstract flow graph
interface module \module{agraph}. The translation process also uses
the informations recorded in a clean fat environment (\module{fenv}).

% ------------------------------------------------------------------ 
\subsection{Assembly Interface \module{asm}}
% ------------------------------------------------------------------ 

This module provides an abstract interface to assemblers. It is
parameterized over the instruction set for specific platforms. Assembly
code is generated by the \module{ast2ir} module.

% ------------------------------------------------------------------ 
\subsection{Calling Conventions \module{callconv}}
% ------------------------------------------------------------------ 

Calling conventions describe how parameters are passed to and returned
from procedures.  A finite state automaton can be used to find a
series of locations for a number of parameters to be passed:  when the
sequence of data types belonging to the parameters are used as input
for the automaton, each state-transition allocates a location to pass
one parameter.  This module provides a way to build automata at
run-time and to run them in order to get a sequence of locations.

