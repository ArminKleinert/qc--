%
%
%

% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>
% l2h macro inmodule 2 <a href="#$1.html">#2</a>

\input 

% ------------------------------------------------------------------ 
\section{Roadmap to the source code}
% ------------------------------------------------------------------ 

This section tries to provide an overview of the QC-- compiler. The
order of presentation is roughly the same the compiler uses when it
compiles a source code file. Each of the following sections describes
one source file in {\noweb} format. A single {\noweb} file generally
contains multiple {\ocaml} or other source files and may describe thus
several modules.

\ifhtml\tableofcontents\fi

% ------------------------------------------------------------------ 
\subsection{Let there be \module{main}}
% ------------------------------------------------------------------ 

The top-level module of the {\qcc} compiler is [[Main]] and the
[[Main.main]] function is executed when the compiler starts to work. 
Its  purpose is to process the command line arguments and to use
functions from other modules to perform the requested action. 

\begin{itemize}
\item The command line is parsed into an abstract syntax defined in
      [[cmdline.mli]] which is part of [[main.nw]]. The parser for the
      command line is build in [[main.ml]] from parser combinators
      defined in [[Pc]] (source file [[pc.nw]] in [[cllib/]].

\item The command line syntax is documented in a manual page
      [[qc--.pod]] in Perl's \textit{plain old document} format.  The
      [[mkfile]] contains rules to translate this format to Troff such
      that the final file for the manual page is [[qc--.1]]. The
      command line syntax is also reported when the [[qc--]] binary is
      called with the [[-h]] flag.

\item To include some version informations into the compiler a
      dynamically generated module called [[This]] is included into
      the compiler.  The file [[this.in]] is a template for this
      module.  At compile time it is turned into [[this.ml]] by
      filling in some information with the help of the build process
      that is controlled by the [[mkfile]].
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Scanner and Parser \module{parser}}
% ------------------------------------------------------------------ 

The scanner and parser for {\PAL} are classically generated by Lex and
Yacc tools for {\ocaml}.  A successful parse returns the abstract
syntax of the parsed file.  Except for syntactical issues the scanner
and parser of {\qcc} can be mostly ignored since the abstract syntax
contains all relevant informations.

\begin{itemize}
\item The scanner is defined by the [[scan.mll]] source file.  It
      obtains the type for the tokens returned to the scanner from the
      parser's interface [[parse.mli]] which is automatically
      generated from [[parse.mly]].  The scanner contains several
      scanner like [[token]], [[character]], [[string]], [[comment1]]
      which are used for different contexts of a source file.

\item The generated scanner and parser maintain only a byte counter to
      identify source code positions. In order to emit meaningful
      error messages in later phases of the compiler these byte
      offsets must be attributed with file names and line numbers. The
      scanner maintains in function [[Scan.nl]] a so-called source
      code map of type [[Srcmap.map]] where it records every change of
      newline.
      
\item The parser is generated from the [[parse.mly]] specification. 
      It builds the abstract syntax of the parsed source file
      bottom-up and returns it.  The parse tree contains so-called
      [[At]]-nodes which contain byte-offsets from the start of the
      source file to identify positions.  A [[Srcmap.map]] is required
      to translate them into meaningful file name, line, column
      triples.

\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Source Code Positions \module{srcmap}}
% ------------------------------------------------------------------ 

The scanner and parser generated by {\ocaml} tools provided no easy
way to maintain complex source code position informations. They only
automatically maintain a byte-offset from the beginning of the parses
stream. In order to provide meaningful position informations to the
user a source code position map is used to record additional
informations. 

\begin{itemize}
\item The [[Srcmap]] module provides a [[Srcmap.map]] type to
      synchronize a simple position [[Srcmap.pos]] with a complex
      location [[Srcmap.location]] using [[Srcmap.sync]].

\item The sub-module [[Srcmap.String]] provides functions to format
      source code locations into strings.

\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Abstract Syntax \module{ast}}
% ------------------------------------------------------------------ 

The abstract syntax for a parsed {\PAL} program is defined by
[[ast.asdl]].  {\asdl} is used to specify the syntax because it
provides opportunities to interchange this internal representation
with other implementations. 

\begin{itemize}
\item The {\asdl} specification of the abstract syntax is compiled
      into [[ast.mli]] that contains the actual {\ocaml} data type
      declaration. Additionally a module [[astUtil.ml]] is generated
      that contains code to serialize and de-serialize an abstract
      syntax from a file.

\item For debugging the abstract syntax can be pretty-printed. The
      [[Astpp]] module contains a pretty printer that is implemented
      by pretty-printing combinators from the [[Pp]] module in
      [[cllib/pp.nw]] file.
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Error Propagation \module{error}}
% ------------------------------------------------------------------ 

We want the compiler not stop after the first error in encounters in a
source file but to find as many errors as possible in a single run. 
In order to not get overwhelmed by error messages caused by previous
errors values an algebra of good and bad data must be established:  a
datum from a some data which includes bad data is usually bad.  The
\module{error} module provides the polymorphic [[Error.error]] type to
encapsulate data that is either good or bad, and functions to deal
with it.  This module is heavily used by the \module{elab} module that
checks the static semantics of a {\PAL} program.

% ------------------------------------------------------------------ 
\subsection{{\PAL} Types \module{types}}
% ------------------------------------------------------------------ 

A {\PAL} compiler must check and remember the types of objects in a
{\PAL} program.  Values in a {\PAL} have monomorphic types, predefined
primitive operations polymorphic types.  Type aliases, introduced by
the [[typedef]] construct, are not expressed in the type language but
handled solely resolved at the symbol-table level (in modules
\module{elab} and \module{fenv}).  The \module{types} module provides
data types for types and type-schemes and functions to facilitate
type-matching.  It also contains abbreviations for commonly used
types. 

% ------------------------------------------------------------------ 
\subsection{{\PAL} Values \module{value}, \module{bits}, \module{uint64}}
% ------------------------------------------------------------------ 

Initialized data, [[const]] declared values, and literal values 
be represented in the {\qcc} compiler. {\PAL} considers a value just
as a bit vector to which functions can be applied. These functions
interpret such a bit pattern as a character, signed or unsigned
integer, or a floating point number.

\begin{itemize}
\item Module \module{value} provides a type [[value]] to represent
      values (type [[bitsXX]]) or conditions (type [[bool]]).
      Additionally functions over values to implement [[const]]
      evaluation are provided.

\item A {\PAL} value is a bit-vector of a certain length. The
      \module{bits} module provides a representation for values of
      type [[bits]]. Values are created from {\ocaml} [[int]] values,
      string, or character representations. The \module{bits} module
      provides conversion functions to create [[bits]] values. The
      internal representation of a [[bits]] value is an {\ocaml}
      [[int64]] value.

\item A [[bits]] value can be interpreted \textit{by operations} in
      many different ways: as signed or unsigned integer, as floating
      point value, or as character. All different interpretations
      interpret the same bit patter. This is in contrast to
      conversions between, for example, [[float]] and [[int]] values
      that try to maintain the numeric value but change the bit
      pattern. 
      
      The \module{uint64} module provides unsigned arithmetic
      operations on [[int64]] values (the representation of [[bits]])
      and pattern-preserving conversion between [[int64]] and
      [[float]] values. Some operations are implemented in C by the
      module [[uint64p.c]].

\end{itemize}



