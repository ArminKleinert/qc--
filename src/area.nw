
<<area.mli>>=
type size       = int
type align      = int
type width      = int
type name       = string (* link time constant *)
type direction  = Up | Down

module Loc: sig
    type t
        
    val fetch: t -> width -> Rtl.Private.expr
    val store: Rtl.Private.expr -> width -> t -> Rtl.Private.effect
end

module Dfa: sig
    type t
    val sparc_cmm:  t   (* sample dfa *)
    
    (* allocate memory *)
    val ty:         t -> name -> size * string option -> Loc.t * t
    val block:      t -> name -> size * align         -> Loc.t * t
    
    val align:      align (* requirement for base *)
    val size:       size  (* currently allocated *)
end

module Area: sig 
    type t
    
    val create: name -> Dfa.t -> direction -> t
    val reset: t -> Dfa.t -> t

    val ty:    t -> size * string option -> Loc.t * t
    val block: t -> size * align         -> Loc.t * t

    val size:  size   (* of area *)
    val align: align  (* of base *)
end

module CC: sig
    type t

    val sparc:      t   (* sample cc *)
    val name:       t -> string (* name of this cc *)
    
    val sp:         t -> Rtl.Private.location
    val sp_align:   t -> align
    val sp_grows:   t -> direction

    val call:       t -> Dfa.t
    val cont:       t -> Dfa.t
    val ret:        t -> Dfa.t
end

module Target: sig
    type t

    val name:           t -> string (* name of target *)
    val byteorder:      t -> Rtl.aggregation
    val wordsize:       t -> size
    val pointersize:    t -> 
end
@