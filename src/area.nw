
\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Memory Blocks}
% ------------------------------------------------------------------ 

{\PAL} allows to allocate continuous memory blocks inside a
procedure's activation (called \texttt{stack data}).  The allocation
is not specified as one big chunk but piecewise, where for each piece
its size and alignment requirement are known.  This module provides an
abstraction for the allocation of these piecewise allocated blocks of
memory. 

During the allocation process the continuous memory block is
represented by an abstract type [[builder]].  A still can be enlarged
by allocating more memory, or by strengthening alignment requirements. 
When allocation is completed, the [[builder]] is \emph{frozen} and
responds with a type [[t]] that represents the memory block's size,
base-address, and the base-address alignment.

<<shared types>>=
type t = 
    { address : Rtl.exp (* address of memory block *) (*XXX Rtl.loc? *)
    ; align   : int     (* at run time, must have address mod align = 0 *)
    ; size    : int
    }

<<area.mli>>=
<<shared types>>
type builder

val mk          : address:Rtl.exp -> builder
val align       : builder -> int -> builder
val alloc       : builder -> int -> builder
val location    : builder -> Rtl.exp         (* Rtl.loc ?? *)
val freeze      : builder -> t
@

\begin{itemize}
\item An initial (empty) block is created by prividing a
      $\mathit{base}$ address to [[mk]].  The alignment of the new
      block is 1\footnote{the unit for alignment is the target
      specific \emph{memsize}, usually one byte}.  
      
\item At any given time
      the [[location]] function returns $\mathit{base} +
      \mathit{size}$, where \textit{size} is the size that could be
      observed if the [[builder]] were frozen at that moment.

\item A call to [[allocate]] increases the size of the
      memory block [[builder]] by the supplied number of \emph{memsize} objects. 

\item A call to [[allign n t]] also increases the size of the block
      such that after the call $\mathit{base}+\mathit{size}$ is
      $t$-aligned.

\item After allocation is complete a block can be frozen to obtain its
      definitve size and alignment.  It is a checked run-time error to
      allocate or align a frozen [[builder]], or to ask for its
      current [[location]].
\end{itemize}


It's possible that several areas, with disjoint lifetimes, can be
overlapped in a single location in memory.  The result is a new area
[[t]] with more constraints in general.  The [[placement]] value
determines whether the overlapping areas share a common low or high
end. 

<<shared types>>=
type placement = EqualHighEnds | EqualLowEnds

<<area.mli>>=
val overlap : placement -> t list -> t  
  (* Overlap several areas into a larger area, forcing constraints on
     compile-time constants.  May make calls to Const.make_equal, but
     otherwise has no side effects.  It is a checked run-time error to
     overlap areas at the high end unless the size of every area is a
     multiple of its alignment.  N.B. may raise Const.Cannot_solve. *)
@

Areas of concurrent lifetimes can be concatenated using [[concat]],
resulting in a new area.  The addresses assigned to the argument areas
will increase from the head to the tail of the list.  It is a checked
run-time error to supply an empty list as an argument. 

<<area.mli>>=
val concat : t list -> t        
    (* req: argument <> [];
       calls Const.make_equal, may raise Const.Cannot_solve *)
@

% ------------------------------------------------------------------ 
\section{Implementation}
% ------------------------------------------------------------------ 

The implementation maintains basically a [[base]] address and a
positive [[offset]] from the base to model a block of allocated
memory.  The base address is a link-time expression whose alignment
requirement is the maximum of all alignment requests received for the
offset.  Alignments are checked to be a power of two.

<<area.ml>>=
module RP = Rtl.Private

<<shared types>>
type builder =  
    { width:            int     (* pointer size in bits *)
    ; base:             RP.exp  (* lowest address, link-time expr *)
    ; basealign:        int     (* alignment of base, in memsize units *) 
    ; offset:           int     (* non-negative, in memsize units *)
    }

let rec is2power = function
    | 1 -> true
    | x -> x > 0 && (x mod 2) = 0 && is2power (x/2)
                
let mk base =
    { width     = Rtlutil.width base 
    ; base      = Rtl.Convert.exp base 
    ; basealign = 1
    ; offset    = 0
    }
@

The [[align]] function aligns the [[offset]].  However, this only
works when the base address is also aligned properly and thus the
alignment requirement for the base address is strengthened, too.  

<<area.ml>>=
let align b n =
    let _ = assert (is2power n)   in
    if b.offset mod n > 0 then
        { b with 
            offset     = n * ((b.offset mod n) + 1)
        ;   basealign  = max n b.basealign
        }
    else
       { b with basealign = max n b.basealign }

let alloc b n =
    let _ = assert (n >= 0)       in
        { b with offset = b.offset + n }

let location b =
    let offset = RP.Const(RP.Bits (Bits.of_int b.offset b.width))    in
    let sum    = RP.App (("add",[b.width]), [b.base;offset])         in
        Rtl.Revert.exp sum
@

\begin{quote}\it
    Overlaying areas at their high end only works if the size of each area 
    is a multiple of its base alignment. The following code in
    [[freeze]] enforces this. Should this be up to the user by
    providing an [[adjust]] function? --CL
\end{quote}

<<area.ml>>=
let freeze b = 
    let b = align b b.basealign in
        { address = Rtl.Revert.exp b.base 
        ; align   = b.basealign
        ; size    = b.offset
        }

let maxarea x y =
    let _ = () (* make_equal x.address y.address *) in
        { address = x.address
        ; align   = max x.align y.align
        ; size    = max x.size  y.size
        }
@

The implementation of [[overlap]] is easy when all overlapped areas
share the same base address and they are aligned at their lower ends: 
the resulting area also is based on that address an the size and
alignment requirements are the respective maximums from the overlaid
areas. Everything else requires to accumulate equations that relate
the base addresses of the participating areas. 

\begin{quote}\it
    We currently have the [[Const]] module for this. However, it
    maintains a global set of equations despite the fact that
    equations are procedure-local. Therefore I'd like to discuss the
    interface of [[Const]] first before providing an implementation here.
    --CL
\end{quote}

<<area.ml>>=
let overlap placement areas =  match (placement,areas) with
    | _           , []      -> invalid_arg "Area.overlap"
    | EqualLowEnds, (a::aa) -> List.fold_left maxarea a aa 
    | _                     -> Impossible.unimp "Area.overlap"
@

The implementation of [[concat]] creates a functional [[builder]]
value [[b]] and then allocates space in it according to the size and
alignment of the areas.  The calls to [[make_equal]] are still missing
because of the design questions raised above.

<<area.ml>>=
let concat = function
    | []             -> invalid_arg "Area.concat"
    | t::_ as areas  -> 
        let b       = mk t.address in   (* get base address *)
        let cat b t =  
            let b = align b t.align in  (*XXX call make_equal here *)
            let b = alloc b t.size  in
                b
        in
            freeze (List.fold_left cat b areas)
@

