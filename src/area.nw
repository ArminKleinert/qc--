
\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Memory Blocks}
% ------------------------------------------------------------------ 

{\PAL} allows to allocate continuous memory blocks inside a
procedure's activation (called \texttt{stack data}).  The allocation
is not specified as one big chunk but piecewise, where for each piece
size and alignment requirement are known.  This module provides an
abstraction for the allocation of these piecewise allocated blocks of
memory. Memory blocks can be concatenated and overlayed to form larger
blocks. This is used in the compiler to assemble a procedure's
activation record that consists of several blocks.

During the allocation process the continuous memory block is
represented by an abstract type [[builder]].  A still can be enlarged
by allocating more memory, or by strengthening alignment requirements. 
When allocation is completed, the [[builder]] is \emph{frozen} and
responds with a type [[t]] that represents the memory block's size,
base-address, and the base-address alignment.

<<shared types>>=
type t = 
    { address : Rtl.exp (* address of memory block *) (*XXX Rtl.loc? *)
    ; align   : int     (* at run time, must have address mod align = 0 *)
    ; size    : int
    }

<<area.mli>>=
<<shared types>>
type builder

val mk          : address:Rtl.exp -> builder
val align       : builder -> int -> builder
val alloc       : builder -> int -> builder
val location    : builder -> Rtl.exp         (* Rtl.loc ?? *)
val freeze      : builder -> t
@

\begin{quote}\it
    For generality I would like to add an [[adjust n]] function that
    makes the size of the area a multiple of [[n]]. The is a constraint
    that some stack layouts require.
\end{quote}

\begin{itemize}
\item An initial (empty) block is created by prividing a
      $\mathit{base}$ address to [[mk]].  The alignment of the new
      block is 1\footnote{the unit for alignment is the target
      specific \emph{memsize}, usually one byte}.  
      
\item At any given time
      the [[location]] function returns $\mathit{base} +
      \mathit{size}$, where \textit{size} is the size that could be
      observed if the [[builder]] were frozen at that moment.

\item A call to [[allocate]] increases the size of the
      memory block [[builder]] by the supplied number of \emph{memsize} objects. 

\item A call to [[allign n t]] also increases the size of the block
      such that after the call $\mathit{base}+\mathit{size}$ is
      $t$-aligned.

\item After allocation is complete a block can be frozen to obtain its
      definitve size and alignment.  It is a checked run-time error to
      allocate or align a frozen [[builder]], or to ask for its
      current [[location]].
\end{itemize}


It's possible that several areas, with disjoint lifetimes, can be
overlapped in a single location in memory.  The result is a new area
[[t]] with more constraints in general.  The [[placement]] value
determines whether the overlapping areas share a common low or high
end. 

Of course, overlapping requires some flexibility on the side of the
involved areas: if all areas have fixed base addresses there is no way
to align them. Flexibility comes from \emph{symbolic compile time
constants} (c.f. module \module{const}). These are variables whose
values are known at compile time, which however, can be used before
these excat values are known. A symbolic compile-time value is
represented by an [[Rtl.link]] value and must be registered with
[[Const.register]]. Typically, the base address of an area that is later
aligned with other areas is a symbolic compile time constant. 

When areas are overlapped or concatenated, constraints are put on their
(symbolic) base addresses. These constraints are collected in a
[[Const.t]] value that is later passed to [[Const.solve]] to determine
the exact values of all involved symbolic compile time constants.
Therefore both [[overlap]] and [[conact]] take and return [[Const.t]]
values.

<<shared types>>=
type placement = EqualHighEnds | EqualLowEnds

<<area.mli>>=
val overlap : placement -> t list -> Const.t -> t * Const.t
@

Areas of concurrent lifetimes can be concatenated using [[concat]],
resulting in a new area.  The addresses assigned to the argument areas
will increase from the head to the tail of the list.  It is a checked
run-time error to supply an empty list as an argument. 

<<area.mli>>=
val concat : t list -> Const.t -> t * Const.t       (* req: argument <> [] *)
@

% ------------------------------------------------------------------ 
\section{Implementation}
% ------------------------------------------------------------------ 

The implementation maintains basically a [[base]] address and a
positive [[offset]] from the base to model a block of allocated
memory.  The base address is a link-time expression whose alignment
requirement is the maximum of all alignment requests received for the
offset.  Alignments are checked to be a power of two.

<<area.ml>>=
module RP = Rtl.Private

<<shared types>>
type builder =  
    { width:            int     (* pointer size in bits *)
    ; base:             RP.exp  (* lowest address, link-time expr *)
    ; basealign:        int     (* alignment of base, in memsize units *) 
    ; offset:           int     (* non-negative, in memsize units *)
    }

let rec is2power = function
    | 1 -> true
    | x -> x > 0 && (x mod 2) = 0 && is2power (x/2)
                
let mk base =
    { width     = Rtlutil.Width.exp base 
    ; base      = Rtl.Convert.exp base 
    ; basealign = 1
    ; offset    = 0
    }
@

The [[align]] function aligns the [[offset]].  However, this only
works when the base address is also aligned properly and thus the
alignment requirement for the base address is strengthened, too.  

<<area.ml>>=
let align b n =
    let _ = assert (is2power n)   in
    if b.offset mod n > 0 then
        { b with 
            offset     = n * ((b.offset mod n) + 1)
        ;   basealign  = max n b.basealign
        }
    else
       { b with basealign = max n b.basealign }

let alloc b n =
    let _ = assert (n >= 0)       in
        { b with offset = b.offset + n }

let location b =
    let offset = RP.Const(RP.Bits (Bits.of_int b.offset b.width))    in
    let sum    = RP.App (("add",[b.width]), [b.base;offset])         in
        Rtl.Revert.exp sum

let freeze b = 
    let b = align b b.basealign in
        { address = Rtl.Revert.exp b.base 
        ; align   = b.basealign
        ; size    = b.offset
        }
@


\begin{quote}\it
    Overlaying areas at their high end only works if the size of each area 
    is a multiple of its base alignment. The following code in
    [[freeze]] enforces this. Should this be up to the user by
    providing an [[adjust]] function? Currently the [[freeze]] function
    does this automatically.--CL
\end{quote}


When areas are overlapped or concatenated their base addresses must be
adjusted. This only works when they contain symbolic compile-time
constants which can be adjusted accordingly. The details are left to the
\module{const} module that provides a [[make_equal]] function to align
{\rtl} expressions. Calling it adds constraints to the embedded symbolic
constants.

[[Concat]] creates a new [[builder]] value and places all areas $a_1,
a_2, \dots$ in there, one next to the other. The base address of $a_i$
are adjusted accordingly: 

<<area.ml>>=
let concat (areas:t list) (const:Const.t) = 
    let cat (b,const) t =  
        let const = Const.make_equal (location b) t.address const in
        let b     = align b t.align in  
        let b     = alloc b t.size  in
                (b,const)
    in match areas with            
        | []             -> invalid_arg "Area.concat"
        | t::_ as areas  -> 
                let b       = mk t.address in   (* new builder *)
                let b,const = List.fold_left cat (b,const) areas in
                    freeze b, const
@

Overlapping areas requires to align either their top or bottom ends. The
[[bottom]] function aligns two areas at their low ends by equating their
base addresses and strengthening the alignment requirements. The
resulting area's size is the maximum of the two sizes. Converselt, the
[[top]] function aligns two areas at their top. 

<<area.ml>>=
let bottom (x,const) y =
    let const = Const.make_equal x.address y.address const in
    let area  = { address = x.address
                ; align   = max x.align y.align
                ; size    = max x.size  y.size
                } 
    in
        area, const

<<area.ml>>=
let top (x,const) y = (* x.address + x.size = y.address + y.size *) 
    let const = Const.make_equal' x.address x.size y.address y.size const in
    let area  = { address = x.address
                ; align   = max x.align y.align
                ; size    = max x.size  y.size
                }
    in
        area, const

let overlap placement areas const =
    match (placement,areas) with
    | _            ,[]      -> invalid_arg "Area.overlap"
    | EqualLowEnds ,(a::aa) -> List.fold_left bottom (a,const) aa 
    | EqualHighEnds,(a::aa) -> List.fold_left top    (a,const) aa
        
@


