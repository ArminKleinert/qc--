
\input{macros.tex}

% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Abstract Flow-Graph Implementation}
% ------------------------------------------------------------------ 

This implementation of the abstract flow graph interface clusters
assignments into basic blocks: a graph is a list of basic blocks and
the elements of a basic block are {\rtl}s that represent the
assignments. Of course, this flow graph representation lacks a lot of
information a real flow graph would represent. This implementation is
intended for early experiments with code generation.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Since this module implements [[Agraph.S]], it must obey to its
interface.  We don't repeat an explanation of the interface here;
please refer to \module{agraph}.  Additionally, some extras are
provided. Most useful is the function [[ast]], which translates a
[[graph]] into {\PAL} abstract syntax.

<<agraph2ast.mli>>=
<<agraph interface>>
<<extras>>
@

<<agraph interface>>=
type graph
type node
type unode
type cont
module Props : sig
    type properties
    val empty : properties
    val add_span : Bits.bits -> Rtl.const -> properties -> properties
    val add_comment : string -> properties -> properties
end
val bind : Props.properties -> unode -> node
module Make : sig
    type ginit = string
    val graph : ginit -> graph
    val graph_of : node -> graph
    val exit : graph -> unode
    val entry : node -> unode
    val goto : graph -> Rtl.expr -> Agraph.label list -> unode
    val branch : Rtl.expr -> node -> node -> unode
    val assign : Rtl.rtl -> node -> unode
    val copy_in : Agraph.formal list -> Agraph.context -> Target.conv -> node -> unode
    val copy_out : Agraph.actual list -> Agraph.context -> Target.conv -> node -> unode
    val return : graph -> int -> int -> unode
    val make_cont : node -> Agraph.cuts -> cont
    val call : Rtl.expr -> cont -> unode
    val jump : graph -> Rtl.expr -> Agraph.label list -> unode
    val label : Agraph.label -> node -> unode
end
@

<<extras>>=
type block = string * Rtl.rtl list
val blocks: graph -> block list
val stmts : graph -> Mangle.mangler -> Ast.stmt list
val name  : graph -> string
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The large scale structure of the implementation is dictated by the
abstract interface to the flow graph: certain type declarations, and
the modules [[Props]] and [[Make]] are mandatory.

<<agraph2ast.ml>>=
module A        = Ast
module Props = struct
    <<module Props>>
end
<<types>>
module Make = struct
    <<module Make>>
end
@

A basic [[block]] is a list of {\rtl}s that starts with a label.  A
[[graph]] is a list of basic blocks.  Each [[node]] contains a
reference to the graph it belongs to.

<<types>>=
type block =   string * Rtl.rtl list    (* label and RTLs *)
type graph =   { name:              string
               ; mutable bbs:      block list
               }

type node  =   { graph:             graph 
               ; rtls:              Rtl.rtl list
               }
@
           
Although we ignore properties of nodes, we distinguish between a
[[node]] and a [[unode]].  The latter is a function, that receives
some properties and returns a [[node]].

<<>>=
type unode       = Props.properties -> node
@

Continuations are also left out, but the interface demands that we
provide a representation for them.

<<>>=
type cont =     node
@

% ------------------------------------------------------------------ 
\subsubsection{Properties}
% ------------------------------------------------------------------ 

This implementation ignores properties. However, the interface demands
that we define some types dealing with them.

<<module Props>>=
type properties = unit
@

<<>>=
let empty               = ()
let add_span x y props  = ()
let add_comment s props = ()
@

The binding of properties to nodes is built into the construction
functions. The [[bind]] function required by the interface is a simple
application.

<<agraph2ast.ml>>=
let bind props unode = unode props
@
    
% ------------------------------------------------------------------ 
\subsubsection{Graph Construction}
% ------------------------------------------------------------------ 

The flow graph of a program is built from back to front. The following
rules determine, which nodes start and end a basic block:

\begin{itemize}
\item An [[entry]] or [[label]] node starts a basic block. The two
      successors of a [[branch]] start basic blocks.

\item The following nodes end a basic block: [[jump]], [[return]],
      [[exit]], and [[goto]]. A [[call]] ends a basic block because it
      may not return to the next node.
\end{itemize}

Since a flow graph is built from back to front, a node ending a basic
block introduces an empty block that is filled on the way to the
front. Such a node is constructed by the [[terminal]] function.
      
At the start of a basic block the block can be added to the graph
which maintains a reversed list of basic blocks.  The [[bblock]]
function does this by side-effect.

<<module Make>>=
type ginit = string
let graph name = { name  = name
                 ; bbs  = [] 
                 }

let terminal g = { graph = g 
                 ; rtls  = []
                 }

let graph_of {graph=g} = g

let bblock node name = 
    let g = graph_of node in
     g.bbs <- (name,node.rtls) :: g.bbs
@

Some nodes neither start or end a basic block, nor do they contribute
an {\rtl}.  These nodes are skipped by simply returning their
successor.

<<>>=
let skip n     = fun p -> n
@

Here are all the terminating node, that end a basic block:

<<>>=
let exit  g p               = terminal g
let goto g expr labels p    = terminal g
let return g x y p          = terminal g
let jump g expr labels p    = terminal g
@

Copy-out and copy-out nodes are skipped.

<<>>=
let copy_in formals context cc node p   = skip node p
let copy_out actuals context cc node p  = skip node p
@

A continuation [[cont]] contains the normal return continuation as a
[[node]]. Since a [[call]] might not return, it starts and ends a
basic block. 

<<>>=
let make_cont node cuts                 = node
let call expr cont p =
    let g = graph_of cont in
        ( bblock cont (Idgen.id' g.name)
        ; terminal (graph_of cont)
        ) 
@

An [[assign]] node contributes an {\rtl} to the basic block
represented by its successor:

<<>>=
let assign rtl n p = { n with rtls = rtl :: n.rtls }
@

All other nodes start the current basic block(s). However, they also
end the one above them.

<<>>=
let entry n p =
    let g = graph_of n in 
        ( bblock n g.name
        ; terminal g
        )

<<>>=
let branch e t f p =
    let g = graph_of t in
        ( bblock f (Idgen.id' g.name)
        ; bblock t (Idgen.id' g.name)
        ; terminal g
        )
       
<<>>=
let label n node p =
    ( bblock node n
    ; terminal (graph_of node)
    )
@
    
% ------------------------------------------------------------------ 
\subsubsection{Extras}
% ------------------------------------------------------------------ 

A block's name is returned by [[name]]:

<<agraph2ast.ml>>=
let name {name=n} = n 
@

The list of basic blocks is returned by [[blocks]]:

<<agraph2ast.ml>>=
let blocks {bbs = bb} = bb
@

The [[stmts]] function translates the basic blocks of a graph into a
list of statements. Each block starts with a label which is passed
through the mangler. The label of the first block is droped, because
it belongs to the [[entry]] node which we expect to belong to a
procedure.

<<>>=
let stmts graph mangle = 
    let bb             = blocks graph in
    let block (n,rtls) = 
        A.LabelStmt(mangle n) :: List.map (Rtl2ast.translate mangle) rtls
    in
        List.tl (List.flatten (List.map block bb))
@




