
\input{macros.tex}

% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Abstract Flow-Graph Implementation}
% ------------------------------------------------------------------ 

This implementation of the abstract flow graph interface clusters
assignments into basic blocks: a graph is a list of basic blocks and
the elements of a basic block are {\rtl}s that represent the
assignments. Of course, this flow graph representation lacks a lot of
information a real flow graph would represent. This implementation is
intended for early experiments with code generation.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Since this module implements [[Agraph.S]], it must obey to its
interface.  We don't repeat an explanation of the interface here;
please refer to \module{agraph}.  Additionally, some extras are
provided. Most useful is the function [[ast]], which translates a
[[graph]] into {\PAL} abstract syntax.

<<agraph2ast.mli>>=
<<agraph interface>>
<<extras>>
@

<<agraph interface>>=
type graph
type node
type unode
type cont
module Props : sig
    type properties
    val empty : properties
    val add_span : Bits.bits -> Rtl.const -> properties -> properties
    val add_comment : string -> properties -> properties
end
val bind : Props.properties -> unode -> node
module Make : sig
    val graph : unit -> graph
    val graph_of : node -> graph
    val exit : graph -> unode
    val entry : node -> unode
    val goto : graph -> Rtl.expr -> Agraph.label list -> unode
    val branch : Rtl.expr -> node -> node -> unode
    val assign : Rtl.rtl -> node -> unode
    val copy_in : Agraph.formal list -> Agraph.context -> Target.conv -> node -> unode
    val copy_out : Agraph.actual list -> Agraph.context -> Target.conv -> node -> unode
    val return : graph -> int -> int -> unode
    val make_cont : node -> Agraph.cuts -> cont
    val call : Rtl.expr -> cont -> unode
    val jump : graph -> Rtl.expr -> Agraph.label list -> unode
    val label : Agraph.label -> node -> unode
end
@

<<extras>>=
val blocks: graph -> (Rtl.rtl list) list
val ast   : graph -> Ast.stmt list
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The large scale structure of the implementation is dictated by the
abstract interface to the flow graph: certain type declarations, and
the modules [[Props]] and [[Make]] are mandatory.

<<agraph2ast.ml>>=
module A        = Ast
module Props = struct
    <<module Props>>
end
<<types>>
module Make = struct
    <<module Make>>
end
@

A basic [[block]] is a list of {\rtl}s.  A [[graph]] is a list of
basic blocks in \emph{reverse order}.  Each [[node]] contains a
reference to the graph it belongs to.

<<types>>=
type block =   Rtl.rtl list
type graph =   { mutable bbs':      block list
               }

type node  =   { graph:             graph ref
               ; rtls:              block
               }
@
           
Although we ignore properties of nodes, we distinguish between a
[[node]] and a [[unode]].  The latter is a function, that receives
some properties and returns a [[node]].

<<>>=
type unode       = Props.properties -> node
@

Continuations are also left out, but the interface demands that we
provide a representation for them.

<<>>=
type cont =     unit
@

% ------------------------------------------------------------------ 
\subsubsection{Properties}
% ------------------------------------------------------------------ 

This implementation ignores properties. However, the interface demands
that we define some types dealing with them.

<<module Props>>=
type properties = unit
@

<<>>=
let empty               = ()
let add_span x y props  = ()
let add_comment s props = ()
@

The binding of properties to nodes is built into the construction
functions. The [[bind]] function required by the interface is a simple
application.

<<agraph2ast.ml>>=
let bind props unode = unode props
@
    
% ------------------------------------------------------------------ 
\subsubsection{Graph Construction}
% ------------------------------------------------------------------ 

The flow graph of a program is built from back to front. The following
rules determine, which nodes start and end a basic block:

\begin{itemize}
\item An [[entry]] or [[label]] node starts a basic block. The two
      successors of a [[branch]] start basic blocks.

\item The following nodes end a basic block: [[jump]], [[return]],
      [[exit]], and [[goto]].
\end{itemize}

Since a flow graph is built from back to front, a node ending a basic
block introduces an empty block that is filled on the way to the
front. Such a node is constructed by the [[terminal]] function.
      
At the start of a basic block the block can be added to the graph
which maintains a reversed list of basic blocks.  The [[bblock]]
function does this by side-effect.

<<module Make>>=
let graph ()   = { bbs'  = [] 
                 }

let terminal g = { graph = ref g 
                 ; rtls  = []
                 }

let graph_of {graph=g} = !g 

let bblock n = 
    let g = graph_of n in
     g.bbs' <- n.rtls :: g.bbs'
@

Some nodes neither start or end a basic block, nor do they contribute
an {\rtl}.  These nodes are skipped by simply returning their
successor.

<<>>=
let skip n     = n
@

Here are all the terminating node, that end a basic block:

<<>>=
let exit  g p               = terminal g
let goto g expr labels p    = terminal g
let return g x y p          = terminal g
let jump g expr labels p    = terminal g
@

Copy-out and copy-out nodes are skipped, together with call nodes:

<<>>=
let make_cont node cuts                 = node
let copy_in formals context cc node p   = skip node
let copy_out actuals context cc node p  = skip node
let call expr node p                    = skip node
@

An [[assign]] node contributes an {\rtl} to the basic block
represented by its successor:

<<>>=
let assign rtl n p = { n with rtls = rtl :: n.rtls }
@

All other nodes start the current basic block(s). However, they also
end the one above them.

<<>>=
let entry n p = 
    ( bblock n
    ; terminal (graph_of n)
    )

<<>>=
let branch e t f p =
    ( bblock t
    ; bblock f
    ; terminal (graph_of t)
    )
       
<<>>=
let label n node p =
    ( bblock node
    ; terminal (graph_of node)
    )
@
    
% ------------------------------------------------------------------ 
\subsubsection{Extras}
% ------------------------------------------------------------------ 


