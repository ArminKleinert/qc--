
% ------------------------------------------------------------------ 
\section{Continuations}
% ------------------------------------------------------------------ 


A continuation is a {\PAL} run-time value of the native pointer size
that represents a pair of an activation record and program counter. The
activation record is represented by the current stack pointer $\sp$ and
the program-counter is the link-time label $l$ of the continuation's
code.  Hence, a continuation is basically represented by a $(\sp,l)$
pair.  Because these pairs are no simple {\PAL} values, a continuation
is a pointer to such a pair. During the translation of a procedure a
reference to a continuation is represented as a \emph{symbolic
compile-time value} ([[Rtl.link]] $l$) that is later substituted by the
pointer to the $(\sp,l)$ pair (c.f.~\module{const}).

The code for a continuation is part of a procedure. When the procedure
becomes active at run-time, assignments at the entry of the procedure
fill a slot in its activation record with the actual ($\sp,l$) pair.
References to a continuation in the body of the procedure are
represented as pointers to the ($\sp,l$) pair on the stack.

This module provides an abstraction from the $(\sp,l)$ representation of
continuations.

<<cont.mli>>=
type t                                      (* a continuation *)

val allocate:   Automaton2.t                (* stack space *)
                -> sp:Rtl.loc               (* location of stack pointer *)
                -> label:Symbol.t           (* label of continuation *)
                -> reference:string         (* reference to cont *)
                -> t
                
val register:   t -> Const.t -> Const.t (* register t for substitution *)
val init:       t -> Rtl.rtl list       (* RTLs to fill slots *)

(* observation functions - currently not used/implemented
 * val sp:         t -> Rtl.loc            (* sp on stack *)
 * val pc:         t -> Rtl.loc            (* pc on stack *)
 *)
@

The translation of a procedure must allocate slots for continuations in
the procedure's activation record. Function [[allocate]] does this, and
returns an abstract value [[t]] to access this slot. The allocation
function receives the following parameters:

\begin{itemize}
\item [[Automaton.t]]: provides stack space to allocate a slot in. See
      also \module{proc} and \module{automaton} how automata are used to
      allocate resources. This value is updated by a side-effect.

\item [[sp]]: the location of the stack pointer.

\item [[label:string]]:     the name of the continuation.
\item [[reference:string]]: in an expression a continuation is 
      referred to by [[reference]] (which is distinct from [[label]]).
      The reference can be found in a continuations denotation in the
      fat environment.
\end{itemize}

During the first translation of a procedure addresses on the stack are
not yet known. Therefore a continuation value is represented by
[[Rtl.link reference]] value,  that is later replaced by a pointer into
the procedure's activation record. To make this substitution happen the
continuation must be \emph{registered} with the enclosing procedure's
equation set [[Const.t]]. Each procedure maintains a [[Const.t]] value
for constraints related to values in its activation record.

The [[init]] function returns {\rtl}s that fill the stack slot for [[t]]
with the values for the current activation. We use the {\rtl}s to
generate assignments at the entry of a procedure.

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<cont.ml>>=
module A = Automaton2

type t =
    { cont_sp:          Rtl.loc         (* location of sp in pair *)
    ; cont_pc:          Rtl.loc         (* location of pc in pair *)
    ; label:            Symbol.t  (* name of continuation *)
    ; reference:        string          (* Rtl.late reference to cont *)
    ; sp:               Rtl.loc         (* sp register *)
    }
@

\begin{itemize}
\item [[cont_sp]]: the location of the $\sp$ part of the 
      $(\sp,l)$ pair on the stack.

\item [[cont_pc]]: the location of the $l$ part, 
      which is the link-time constant of the continuation's code.
      
\item [[label]]: the code-symbol of the continuation.      

\item [[reference]]: the references in the body of the enclosing procedure
      to [[label]] are represented as [[Rtl.late t.reference]].

\item [[sp]]: the location of the stack pointer (register).
\end{itemize}

<<cont.ml>>=
let allocate (a:A.t) ~(sp:Rtl.loc) ~(label:Symbol.t) ~(reference:string) =
    let width = Rtlutil.Width.loc sp in         (* pointer width *)
        { label     = label
        ; reference = reference
        ; sp        = sp
        ; cont_sp   = A.to_loc (A.allocate a width None)
        ; cont_pc   = A.to_loc (A.allocate a width None)
        }

let reference t = Rtl.late t.reference (Rtlutil.Width.loc t.sp)
@

In the body of a procedure we want to replace every symbolic
[[reference]] to a continuation with a pointer to it's code pointer
([[cont_pc]]) on the stack. We therefore have to equalize them in the
equation system.

\begin{quote}\it
    The substitution mechanism works on [[Rtl.exp]] values which assumes
    that all locations belong to the same memory space. We must assume
    here that the [[cont_sp]] and [[cont_pc]] value are in the ``right''
    memory spaces. This seems like a small impedance mismatch to me.
    --CL.
\end{quote}

<<cont.ml>>=
let register t const =
    match Rtl.Convert.loc t.cont_pc with
    | Rtl.Private.Cell(_,_,_,e,_) -> 
        Const.make_equal (Rtl.Revert.exp e) (reference t) const
    | _ -> assert false    
@

Function [[init]] generates two assignments: the first transfers the
actual value of the stack pointer to a location on the stack, the second
transfers the pointer to the continuation's code to a location on the
stack.

<<cont.ml>>=
let init t =
    let width = Rtlutil.Width.loc t.sp   in
        [ Rtl.store t.cont_sp (Rtl.fetch t.sp    width) width
        ; Rtl.store t.cont_pc (Rtl.link  t.label width) width
        ]
@

