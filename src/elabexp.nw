% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Elaborating Expressions}
% ------------------------------------------------------------------ 

The {\qcc} compiler type checks expressions and converts them to RTL
expressions. 
None of these functions ever raises an exception.
<<elabexp.mli>>=
type nm_or_mem = Ast.name_or_mem
val elab_ty : 'a Fenv.Dirty.env' -> Ast.ty   -> Types.ty                    Error.error
val elab_exp: 'a Fenv.Dirty.env' -> Ast.expr -> (Rtl.exp * Types.ty)        Error.error
val elab_loc: 'a Fenv.Dirty.env' -> nm_or_mem-> (Automaton.loc * Rtl.width) Error.error

@ The [[elab_*]] functions work with incomplete information,
indicated by [[Error.Error]] values.  The policy is as follows:
\begin{itemize}
\item In case of a success, [[check]] returns the type of the
      expression at hand as a [[Error.Ok]] value.
\item If the type check must use an erroneous information from the
      environment, it propagates this error and returns [[E.Error]].
\item If the type check detects a new error, for example a type
      inconsistency, it issues an error message and returns
      [[E.Error]].
      The exception [[Error.ErrorExn]] may be used internally, but it
      should never be raised by a top-level function.
\end{itemize}
@
% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<elabexp.ml>>=
module A = Ast
module AT = Automaton
module E = Error
module F = Fenv.Dirty
type nm_or_mem = Ast.name_or_mem

let impossf fmt = Printf.kprintf Impossible.impossible fmt

let (@<<) f g = fun x -> f (g x) (* function composition *)
    
let is2power x = x > 0 && x land (x - 1) = 0
@
% ------------------------------------------------------------------
\subsection{The translation of types, names, and expressions}
% ------------------------------------------------------------------ 

<<elabexp.ml>>=
module M = Metrics
<<utilities>>
<<definition of [[lvalue_name_in_env]]>>
let exprfuns env =
  let metrics = F.metrics env in
  let lvalue_name = lvalue_name_in_env env in
  <<definition of [[rvalue_name]]>> in
  let catch r f x = E.catch (E.errorRegionPrt (F.srcmap env, r)) f x in
  <<mutually recursive nest of [[typed_expr]] and [[lvalue]]>> in
  catch Srcmap.null typed_expr, catch Srcmap.null lvalue
let elab_exp env = fst (exprfuns env)
let elab_loc env = snd (exprfuns env)
@

There are four interesting syntactic categories here:
\begin{itemize}
\item
A \emph{type} is interesting only for its width.
We have two forms: one from [[Types]] and one from [[Ast]].We provide functions [[tywidth]] and [[astwidth]].
\item
A \emph{name} may occur in an lvalue context or an rvalue context; we
provide [[lvalue_name_in_env]] and [[rvalue_name]].
Many names are meaningful only in an rvalue context.
\item
A \emph{name-or-mem} may occur in an lvalue context or an rvalue context; we
provide [[lvalue]] and [[rvalue_name_or_mem]].
\item
An \emph{expression} may occur only in an rvalue context; we provide
[[typed_expr]].
\end{itemize}
Of the functions above, only [[lvalue_name_in_env]] and [[astwidth]]
are parameterized 
by an environment.
The rest appear in a context (under [[exprfuns]]) in which the
environment is bound to [[env]].
@
\subsubsection {Translation of type and conversion from type to width}

\nwaddbox{tywidth  : 'a Types.t -> 'a}
\nwaddbox{astwidth : F.env -> A.ty -> int}
\deeperbox{2pt}
<<utilities>>=
let tywidth a_bad_thing = function
  | Types.Bits n -> n
  | Types.Bool   -> E.error (Printf.sprintf "A boolean may not be %s" a_bad_thing)

let emap f x = E.ematch x f

let elab_ty env =
  let catch r = E.catch (E.errorRegionPrt (F.srcmap env, r)) in
  let rec elab = function
    | A.TyAt (x,r)    -> catch r elab x
    | A.BitsTy size   -> E.Ok (Types.Bits size)
    | A.TypeSynonym n -> snd (F.findt n env) in
  catch Srcmap.null elab

let astwidth msg env = emap (tywidth msg) << elab_ty env
@
\subsubsection{The meanings of names}

Only the name of a {\PAL} register variable is meaningful in an lvalue
context.
The environment is explicit.
\nwaddbox{lvalue_name_in_inv : F.env -> name -> AT.loc * Rtl.width}
\deeperbox{16pt}
<<definition of [[lvalue_name_in_env]]>>=
let lvalue_name_in_env env x = 
  E.ematch (snd (F.findv x env))
  (fun (denot,t) ->
    let w = tywidth "assigned to" t  in
    match denot with
    | F.Variable({F.loc=Some l}) -> l, w
    | F.Variable({F.index=i;F.loc=None}) ->
        if F.is_localv x env then
          AT.of_loc (Rtl.var x i w), w
        else 
          impossf "global variable %s without location" x
    | _ -> 
        let what = match denot with
        | F.Constant _ -> "constant"
        | F.Label    _ -> "label"
        | F.Import   _ -> "imported symbol"
        | F.Continuation _ -> "continuation"
        | F.Variable _ -> "register" in
        impossf "asked for lvalue of %s %s" what x)
@ 
Any name can be meaningful in an rvalue context.
The environment is implicit.
\nwaddbox{val rvalue_name : name -> Rtl.exp * Types.t}
<<definition of [[rvalue_name]]>>=
let rvalue_name x =
  E.seq (snd (F.findv x env))
  (fun (denot, t) ->
    let w = tywidth "named variable" t in
    let rval = match denot with
    | F.Constant(bits)            -> E.Ok (Rtl.bits bits w)
    | F.Label(F.Proc s)           -> E.Ok (Rtl.link s w)
    | F.Label(F.Code s)           -> E.Ok (Rtl.link s w)
    | F.Label(F.Data s)           -> E.Ok (Rtl.link s w)
    | F.Import(_,s)               -> E.Ok (Rtl.link s w)
    | F.Continuation c            -> (c.F.escapes <- true; E.Ok (Block.base c.F.base))
    | F.Label(F.Stack addr) -> E.Ok addr  (* a fetch would be wrong *)
    | F.Variable _                -> emap atfetch (lvalue_name x) in
    E.Raise.left (rval, t))
@ 
Help for fetching and storing automata locations.
<<utilities>>=
let atfetch (loc, w)     = loc.AT.fetch w
let atstore (loc, w) exp = loc.AT.store exp w
@ 
\subsubsection{General lvalues}

Again, the environment is implicit.
\nwaddbox{lvalue : Ast.lvalue -> AT.loc * Rtl.width}
\deeperbox{14pt}
<<mutually recursive nest of [[typed_expr]] and [[lvalue]]>>=
let rec lvalue lhs = match lhs with
  | A.NameOrMemAt(lhs,_) -> lvalue lhs
  | A.Name(hint,x)       -> lvalue_name x 
  | A.Mem(t,addr,aligned,aliasing) ->
      let w    = astwidth "value in memory" env t in
      let addr = typed_expr addr in
      E.ematchTriple  (w, addr, assertion aligned)
        (fun (w, (addre, addrt), assn) ->
          if tywidth "address" addrt = metrics.M.pointersize then
            AT.of_loc (Rtl.mem assn 'm' metrics.M.byteorder w addre), w
          else
            E.error "address's type is not the machine's pointer size")
and expr e = emap fst (typed_expr e) 
and rvalue_name_or_mem nm = match nm with
  | A.NameOrMemAt(v, _) -> rvalue_name_or_mem v
  | A.Name(hint, x)     -> rvalue_name x
  | A.Mem(_, _, _, _)   ->
      E.ematch (lvalue nm) (fun (loc, w) -> loc.AT.fetch w, Types.Bits w)
@
<<utilities>>=
let assertion = function
  | None -> Rtl.none
  | Some n when is2power n -> Rtl.aligned n 
  | Some n -> E.error (Printf.sprintf "Alignment %d is not a power of 2" n) 
let assertion x = E.catch E.errorPrt (fun x -> E.Ok (assertion x)) x
@ 
% ------------------------------------------------------------------ 
\subsubsection{The meaning of expressions}
% ------------------------------------------------------------------ 

Although in many cases we need only the RTL associated with an
expression, it is simple and efficient to produce both the type and
the RTL at one time. 
\nwaddbox{typed_expr : Ast.exp -> Rtl.exp * Types.t}
<<mutually recursive nest of [[typed_expr]] and [[lvalue]]>>=
and typed_expr exp = 
  let apply op args =
    E.ematch (E.Raise.list (List.map typed_expr args))
    (fun args ->
      let arges, argtys = List.split args in
      let resty,  opr   = Rtlop.Translate.operator op argtys    in
      Rtl.app opr arges, resty) in
  let literal cvt v width = Rtl.bits (cvt v width) width, Types.Bits width in
  let literal cvt v = emap (literal cvt v) in
  let const default_width = function
    | Some ty -> astwidth "literal constant" env ty
    | None    -> E.Ok default_width in
  match exp with
  | A.ExprAt(x,r)     -> catch r typed_expr x
  | A.Int(str,t)      -> literal Bits.U.of_string str (const metrics.M.wordsize t) 
  | A.Float(str,t)    -> literal Bits.U.of_string str (const metrics.M.wordsize t) 
  | A.Char(int,t)     -> literal Bits.U.of_int    int (const 8                  t) 
      (* perhaps suprisingly, [[Bits.U.of_string]] copes with all 
         literal formats. Update: I have changed the type of A.Char, it
         now contains an integer. -- CL *)
  | A.Fetch(v)        -> rvalue_name_or_mem v
  | A.BinOp (l,op,r)  -> apply op [l;r]
  | A.UnOp  (op,e)    -> apply op [e]
  | A.PrimOp(op,args) -> apply op (List.map snd args)
<<utilities>>=

