% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% ------------------------------------------------------------------ 
\section{Abstract \PAL}
% ------------------------------------------------------------------ 

After a {\PAL} program has been parsed and its static semantics have
been checked it is transformed into a more abstract representation. 
It is based on a data-flow graph which embeds register transfer lists
in its nodes.  Register transfer lists (\rtl{}s) provide a machine and
target independent way to capture the meaning of statements and
machine-level operations.  The representation of {\rtl}s and the flow
graph is defined in {\asdl} to allow for the interchange of these
intermediate formats with other tools.

% ------------------------------------------------------------------ 
\subsection{Register Transfer Lists (\rtl)}
% ------------------------------------------------------------------ 

Register transfer lists capture the meaning of storing values into
memory or register locations.  They are used as part of the abstract
representation of {\PAL}.  The meaning of a register transfer list is
well defined and especially independent from any properties of a
target architecture because no hidden assumptions exist.  This
implementation uses {\asdl} to define the syntax of {\rtl}s.

A [[space]] describes some kind of memory, like a set of registers or
main memory.  The number of [[spaces]] is a property of a target
architecture and thus can not be fixed here with a sum type.  The
[[char]] type provides a big enough cardinality and is nice to print
and remember.
 
[[register]] represents a named {\PAL} register and [[width]] a number
of bits which corresponds to the {\PAL} [[bits]]$k$ types.
  
<<module rtl>>=
space       = (int)    -- mapped to char using views
register    = (string)
width       = (int)
@

We want to represent assertions for specific properties but have not
yet found a representation. Since {\asdl} provides no abstract type we
abuse [[int]].

<<>>=
assertion   = (int)    -- stands for an abstract type
@

An operator for values at run-time is represented by its name and a
list of [[width]]s.  Each [[width]] corresponds to a $\forall$-bound
variable in the type scheme of the operator's type.  From the type
scheme and the [[width list]] a monomorphic type of the operator can
be deduced.

<<>>=
op          = (string, width*)
@

Expressions provide values to be stored in [[locations]] as well as
addresses local to a [[space]].  An expression can access constant
values and values fetched from memory.  A fetch from memory makes the
[[width]] number of fetched bits explicit.  A label denotes a {\PAL}
data- or goto-label and its type. 

<<>>=
bits        = (int,width)       -- view for Bits.bits
boolean     = (int)             -- view for bool

const       = Bool      (boolean)
            | Bits      (bits)
            | Link      (string, width)         -- link time constant

expr        = Const     (const)               
            | Fetch     (location,width) 
            | App       (op, expr list)
            | Label     (string, width)
@

A location describes a memory location or register on the target
architecture or a {\PAL} register. The code generation will remove all
{\PAL} registers and provide memory locations for them. A memory
[[cell]] lives in an address [[space]] at the address denoted by
[[expr]]. In order to fetch [[width]] bits at once several memory
units from the chosen [[space]] must be aggregated. For example, a 32
bit fetch must aggregate 4 8-bit values when the memory space is made
by 8-bit bytes. The aggregation is described by a value of the type
[[aggregation]]. 

<<>>=
location    = Cell      (space, aggregation, width, expr, assertion)
            | Var       (register, width)
<<>>=
aggregation = BigEndian
            | LittleEndian
            | Identity
@

An [[effect]] is describes an assignment of a [[width]] bits value obtained
from an expression [[expr]], or a [[Kill]]. A killed location contains an
undefined value.

<<>>=
effect      = Store     (location, expr, width)
            | Kill      (location)
@

A guarded effect is pair of an expression and an effect. The effect takes
place, if and only if the expression evaluates to [[true]].      

<<>>=
guarded     = (expr,effect)
@

And finally, a \emph{register transfer list} is a list of guarded
effects. When a {\rtl} is evaluated, first all guarding expressions
are evaluated and then all effects of the guards that evaluated to
true become effective simultaneously.

<<>>=
rtl         = Rtl       (guarded*)
@


% ------------------------------------------------------------------ 
\subsection{Data Flow Graph}
% ------------------------------------------------------------------ 

The abstract syntax of a {\PAL} program is translated into a flow
graph.  The graph consists of labeled entry nodes which point to other
nodes, which may or may not be labeled.  Internally, we wish to
represent a graph as a map from labels to nodes.  Because ASDL cannot
support this representation, we use a list of pairs.

We might consider using an ASDL view to define the internal
representation, but there is a circularity problem:  the definition of
the internal representation would have to precede the ASDL definition
of [[graph]], because [[graph]] would depend on it.  But it would have
to follow the ASDL definition of [[label]], because [[label]] must be
the key in the map.  Because ASDL insists on generating a single lump
of code containing the definitions of both [[graph]] and [[label]],
this problem can't be solved easily.

We take the easy way out and use the evil ``epilogue'' to define
[[Ir.graph]], the rightful internal representation of flow graphs.

<<module fgraph>>=
xgraph      = (entry*)          -- external use only; use graph inside compiler.
entry       = (label,node)

<<view ocaml>>=
module fgraph <= interface_epilogue
%%
type graph = (label,node) Hashtbl.t
val  intern_graph : xgraph -> graph
val  extern_graph : graph  -> xgraph
%%
@ 

A [[label]] is either a name or a number.  Numbers will be typically
used for automatically generated labels where names in the source file
can be used for labels, too.  A list of labels is used for lists of
goto-targets and continuations; these are uniformly called
[[targets]].

<<module fgraph>>=
label       = Name      (string)
            | Number    (int)

targets     = (label*)
@

A node represents {\PAL} on an abstract level. For every statement a
corresponding node exists. Procedures are represented by [[CopyIn]]
and [[CopyOut]] nodes which model parameter passing into and out of
procedures. 

<<>>=
node        = Branch    (rtl.expr, label, label)
            | Exit      
            | Assign    (rtl.rtl, node)
            | Goto      (rtl.expr, targets)
            | Jump      (rtl.expr, targets)
            | Entry     (cont*, node)
            | Call      (rtl.expr, cont)
            | CopyIn    (formal*,context,convention,node)
            | CopyOut   (actual*,context,convention,node)
@

A [[context]] describes where parameters are passed: into a procedure, out
of a procedure, or into a continuation.

<<>>=
context     = ProcParameters
            | ProcResults
            | ContParameters
@

A formal parameter is a variable, an actual parameter an expression. Both
can be hinted and have a [[width]], i.e.~a type.

<<>>=
formal      = (variable, rtl.width, hint?)
actual      = (rtl.expr, rtl.width, hint?)
@

<<>>=
boolean     = (int)  -- view
cont        = ( node    normal
              , label*  cuts
              , label*  unwinds
              , label*  returns
              , boolean aborts
              )
@

<<>>=
variable    = (string)
hint        = (string)
convention  = (string)
@


% ------------------------------------------------------------------ 
\subsection{Views}
% ------------------------------------------------------------------ 

{\asdl} does not provide every type we need. Views allow to express
new types in term of supported types. So we define some mappings
between data types here.

<<view ocaml>>=
rtl.space <= {
    natural_type:   char
    wrapper:        Char.chr    (* int -> char *)
    unwrapper:      Char.code   (* char -> int *)
}

rtl.bits <= {
    natural_type:   Bits.bits
    wrapper:        to_bits 
    unwrapper:      of_bits
}

rtl.boolean <= {
    natural_type:   bool
    wrapper:        to_bool
    unwrapper:      of_bool 
}    

fgraph.boolean <= {
    natural_type:   bool
    wrapper:        to_bool
    unwrapper:      of_bool 
}    
@

<<>>=
module rtl <= implementation_prologue
%%
let of_bits b     = (Bits.to_int b, Bits.width b)
let to_bits (n,w) = Bits.of_int n w

let to_bool i     = i <> 0
let of_bool       = function true -> 1 | false -> 0
%%
@

% ------------------------------------------------------------------ 
\subsection{Internal graph representation}
% ------------------------------------------------------------------ 

The flow graph is internally represented as a mapping from labels to
nodes.  This representation is never used directly when a flow graph
is built but only through an interface like [[Agraph]] (module
\module{agraph)) that provides an abstract view.  We have chosen to
use an imperative approach, i.e.~the graph is manipulated with side
effects. 

The {\ocaml} standard module [[Hashtbl]] provides what we need except
that there is no [[fold]] function to easily read out an entire map.
Until we have a more complete implementation we cheat a little bit and
do not provide an export for the view. This does not matter for the
moment since we can't use it anyway: a bug in the {\asdl} compiler
creates buggy code for the marshalling functions such that we do not
use it.

<<>>=
module fgraph <= implementation_epilogue
%%
type graph = (label, node) Hashtbl.t

let intern_graph entries =
    let map = Hashtbl.create 1000 in (* inital size - grows as needed *)
    let enter (label,node) = Hashtbl.add map label node in
        ( List.iter enter entries
        ; map
        )

let extern_graph map = [] (* this is a lie *)
%%
@


% ------------------------------------------------------------------ 
\subsection{The \asdl-definition}
% ------------------------------------------------------------------ 

<<ir.asdl>>=
module rtl {
    <<module rtl>>
}

module fgraph (imports rtl) {
    <<module fgraph>>
}

view OCaml {
<<view ocaml>>
}
@
