% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% $Id$
% ---------------------------------------------------------------------------

Backend for PPC

% ---------------------------------------------------------------------------
\section{Module Structure}
% ---------------------------------------------------------------------------
<<ppc.mli>>=
module Spaces : sig
  val m : Space.t
  val r : Space.t
  val t : Space.t
  val c : Space.t
  val f : Space.t
  val u : Space.t
end
module Post : Postexpander.S
module X    : Expander.S
val target : Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@ 
<<ppc.ml>>=
module R    = Rtl
module RP   = Rtl.Private
module Up   = Rtl.Up
module Down = Rtl.Dn
module PX   = Postexpander
module T    = Target
<<spaces>>
module Post = struct
  <<ppc postexpander>>
end
module X = Expander.IntFloatAddr (Post)
<<calling conventions>>
<<target spec>>
<<variable placer>>
@
% ---------------------------------------------------------------------------
\section{Spaces}
% ---------------------------------------------------------------------------
The PPC has 32 integer registers and 32 floating point registers.
<<spaces>>=
module Spaces = struct
  module S = Space
  module SS = Space.Standard32
  let bo = Rtl.BigEndian
  let id = Rtl.Identity
  let m = SS.m    bo [8;16;32]
  let r = SS.r 32 id [32]
  let t = SS.t    id [32]
  let c = SS.c 7  id [32]

  let flt = { S.space = 'u'
            ; S.doc = "floating point registers"
            ; S.cellwidth = 64
            ; S.indexwidth = 5
            ; S.indexlimit = Some 32
            ; S.aggregation = id
            ; S.widths = [64]
            ; S.classification = S.Reg
            }
 let f = S.checked flt
 let u = S.checked { flt with
                     S.indexwidth = 31
                   ; S.indexlimit = None
                   ; S.classification =
                      S.Temp { S.stands_for = 'f'
                             ; S.index_ok = (fun _ -> true)
                             ; S.set_doc = "floating point temporaries"
                             }
                   }
end
@ 
The power PC has 7 different control registers.
<<spaces>>=
let reg n  = R.reg ('r',n,32)
let freg n = R.reg ('f',n,32)
let creg n = R.reg ('c',n,32)
let nia    = creg 0  (* new (next) instr address         *)
let cia    = creg 1  (* current instr address (pc)       *)
let cr     = creg 2  (* condition register               *)
let fpscr  = creg 3  (* flt point condition register     *)
let xer    = creg 4  (* XER register                     *)
let lr     = creg 5  (* link register                    *)
let ctr    = creg 6  (* counter register                 *)
@ 
Setting bits in the control registers is handled by this utility
function. The [[flag_map]] function shold convert the flag parameter
to a bit number.
<<spaces>>=
let set_flag reg flag_map v flag =
  R.store (R.slice 1 (flag_map flag) reg)
          (R.bits (Bits.U.of_int v 1) 1) 1
@ 
The condition register is divided into eight identical fields, and the
first eight bits have special names. The third bit is a copy of the
[[SO]] flag from the [[XER]] register. The bits 4-7 are copies of
flags from the [[FRSCR]] register.
<<spaces>>=
let crf    n = R.slice 4 (n*4) cr  (* CR field       *)
let crfval n = R.fetch (crf n) 4   (* CR field value *)

type cr_flag = LT | GT | EQ | SO | FX | FEX | VX | OX
let cr_flag_to_bit = function
    LT  -> 0 | GT  -> 1 | EQ  -> 2 | SO  -> 3
  | FX  -> 4 | FEX -> 5 | VX  -> 6 | OX  -> 7
let set_cr_flag = set_flag cr cr_flag_to_bit 1
let clr_cr_flag = set_flag cr cr_flag_to_bit 0
@ 
Almost all of the bits in the floating point status register have special
names. I omit their complete definitions for now.
<<spaces>>=
(*
type fpscr_flag =
    FX | FEX | VX | OX | UX | ZX | XX
  | VXSNAN | VXISI | VXIDI | VXZDZ | VXIMZ | VXVC
  | FR | FI | VXSOFT | VXSQRT | VXCVI
  | VE | OE | UE | ZE | XE | NI | RN
*)
@ 
Three bits in the [[XER]] register have special names. The [[XER_SO]]
bit is copied to the [[CR]] register whenever it is set.
<<spaces>>=
type xer_flag = XER_SO | OV | CA
let xer_flag_to_bit = function XER_SO -> 0 | OV -> 1 | CA -> 2
let set_xer' = set_flag xer xer_flag_to_bit
let set_xer_flag fl = function
    XER_SO -> R.par [ set_cr_flag SO ; set_xer' 1 fl ]
  | _      -> set_xer' 1 fl
let clr_xer_flag fl = function
    XER_SO -> R.par [ clr_cr_flag SO ; set_xer' 0 fl ]
  | _  -> set_xer' 0 fl
@ 
% ---------------------------------------------------------------------------
\section{Post Expander}
% ---------------------------------------------------------------------------
<<ppc postexpander>>=
let byte_order = R.BigEndian
let wordsize = 32
let pc_lhs = nia
let pc_rhs = cia

module Address = struct
  type t = Rtl.exp
  let reg (space, n, w) = R.fetch (R.reg (space, n, w)) w
end

let talloc = ref None
let get_talloc () = match !talloc with
  | Some s -> s
  | None   -> Impossible.impossible "Temp allocator not registered with postexpander"
let remember_allocator ta = talloc := Some ta
let talloc space = Talloc.Multiple.reg space (get_talloc ())

type context = (Talloc.Multiple.t -> int -> Register.t) * (Register.t -> bool)
let icontext = Talloc.Multiple.reg 't', fun (c, _, _) -> c = 'r' || c = 't'
let fcontext = icontext
let acontext = icontext
let rcontext = (fun x y -> Impossible.unimp "Unsupported soft rounding mode")
               ,fun r -> r = ('d', 0, 2)
let bcontext = (fun x y -> Impossible.impossible "allocate from bcontext")
               ,fun _ -> false

module SM = Strutil.Map
let operators = Context.standard icontext fcontext rcontext acontext bcontext
let resmap    = List.fold_left (fun m (n, a, r)-> SM.add n r m) SM.empty operators
let argmap    = List.fold_left (fun m (n, a, r)-> SM.add n a m) SM.empty operators
let arg_contexts   (n, _) = try SM.find n argmap 
                            with Not_found -> Impossible.impossible 
                                    ("cannot find arg context for "^n)
let result_context (n, _) = try SM.find n resmap
                            with Not_found -> Impossible.impossible
                                    ("cannot find result context for "^n)

let ui s = Printf.eprintf "*** unimp %s" s; []

let tloc               t = Rtl.reg t
let tval  ((_,_,w) as t) = R.fetch (tloc t) w
let twidth (_,_,w)       = w
let tstore       tmp exp = R.store (tloc tmp) exp (twidth tmp)

let mem    assn w addr = R.mem assn 'm' byte_order w addr
let memval assn w addr = R.fetch (mem assn w addr) w

let load ~dst ~addr assn =
  let w = twidth dst in
  assert (w = wordsize);
  [R.par [ R.store (tloc dst) (memval assn w addr) w
         ; tstore dst addr
         ] ]

let store ~addr ~src assn =
  let w = twidth src in
  assert (w = wordsize);
  [R.par [ R.store (mem assn w addr) (tval src) w
         ; tstore src addr
         ] ]

let xload op ~dst ~addr w assn =
  let ext = R.app (R.opr op [w; twidth dst]) [memval assn w addr]
  in [tstore dst ext]

let sxload = xload "sx"
let zxload = xload "zx"

let lostore ~addr ~src w assn =
  let ext = R.app (R.opr "lobits" [twidth src; w]) [tval src]
  in [R.store (mem assn w addr) ext w]

let move ~dst ~src = [tstore dst (tval src)]

let li ~dst const = [tstore dst (Up.const const)]
let lix ~dst exp  = [tstore dst exp]

let rtlop ~dst op tmpl = [tstore dst (R.app (Up.opr op) (List.map tval tmpl))]

let binop ~dst op tmp1 tmp2 = rtlop dst op [tmp1;tmp2]
let unop  ~dst op tmp       = rtlop dst op [tmp]

let block_copy ~dst assn1 ~src assn2 width = ui "block_copy"

let br ~tgt = [R.store pc_lhs (tval tgt) wordsize]
let b ~tgt  = [R.store pc_lhs (Up.const tgt) wordsize]
let bc tmp1 op tmp2 ~tgt =
  [ R.guard (R.app (Up.opr op) [R.bool true]) (List.hd (b tgt))
  ; R.store (R.reg tmp1)
      (R.app (Up.opr op) [ (R.fetch (R.reg tmp1) wordsize)
                         ; (R.fetch (R.reg tmp2) wordsize)
                         ] )
      wordsize
  ]


let bnegate rtl = rtl
let call  ~tgt ~others = [R.par (List.hd (b  tgt) :: List.map Up.effect others)]
let callr ~tgt ~others = [R.par (List.hd (br tgt) :: List.map Up.effect others)]

let cut_to effects = [R.par (List.map Up.effect effects)]

let don't_touch_me effects =
  let exp = (fun e -> Rtlutil.ToReadableString.exp (Up.exp e))
  and loc = (fun l -> Rtlutil.ToReadableString.loc (Up.loc l)) in
  let pr = function
      RP.Store (l,e,w) ->
        Printf.eprintf "dtm store: %s = %s (%d bits)\n" (loc l) (exp e) w
    | RP.Kill l ->
        Printf.eprintf "stm kill: %s\n" (loc l)
  in
  Printf.eprintf("dont touch me effects\n");
  List.iter pr effects; false

let opclass op = PX.Register

let stack_depth = 8
let stack_width = 80
let stack_top_proxy_reg = ('\000', 0, 80)
let stack_top_proxy = R.reg stack_top_proxy_reg

let converts_stack_to_temp op = false
let push ~addr assn = ui "push"
let store_pop ~addr assn = ui "store_pop"
let push_cvt op width ~addr assn = ui "push_cvt"
let store_pop_cvt op width ~addr assn = ui "store_pop_cvt"
let pushk const = ui "pushk_const"
let pushk_cvt op width const = ui "pushk_cvt"
let stack_op op = ui "stack_op"
let bc_stack op ~tgt = ui "bc_stack"
let is_stack_top_proxy loc = false
@ 
% ---------------------------------------------------------------------------
\section{Calling Conventions}
% ---------------------------------------------------------------------------
<<calling conventions>>=
module C  = Call
module RS = Register.Set
@ 
Integer registers r0, and r2-r12 are volatile, r1 is the stack
pointer, and r13-r31 are non-volatile. For floating point,
registers f1-f13 are volatile, and f14-131 are not.
<<calling conventions>>=
let regset s w l = RS.of_list (List.map (fun r-> (s,r,w)) l)
let sp_reg = ('r', 1, 32)
let vregs  = regset 'r' 32 [0;2;3;4;5;6;7;8;9;10;11;12]
let nvregs = regset 'r' 32 [13;14;15;16;17;18;19;20;21;
                            22;23;24;25;26;27;28;29;30;31]
let fvregs  = regset 'f' 64 [0;1;2;3;4;5;6;7;8;9;10;11;12;13]
let fnvregs = regset 'f' 64 [14;15;16;17;18;19;20;21;22;
                             23;24;25;26;27;28;29;30;31]
let cvregs = regset 'c' 32 [5(*lr*); 6(*ctr*); 4(*xer*); 2(*cr*)]

(* let volregs  = RS.union (RS.union vregs fvregs) cvregs *)
(* let nvolregs = RS.union nvregs fnvregs *)
let volregs  = RS.union vregs cvregs
let nvolregs = nvregs
@ 
A function to build a [[Call.t]].
<<calling conventions>>=
let cconv name spec =
  let ws    = Post.wordsize
  and callt = Dummy.dummy32b'.T.cc_spec_to_auto name spec in
  { callt with
    C.replace_vfp      = Cfgx.Vfp.replace_with ~sp:(reg 1)
  ; C.pre_nvregs = nvolregs
  ; C.volregs    = volregs
  ; C.return           = (fun k n ~ra -> R.store nia (R.fetch lr ws) ws)
  ; C.ra_on_entry      = (fun b       -> R.fetch lr ws)
(*  ; C.where_to_save_ra = (fun e t     -> Post.mem R.none ws sp_8) *)
  ; C.ra_on_exit       = (fun l e t   -> lr)
  }
@ 
The calling convention specs are written in Lua; they have no ML
counterpart.
<<PPC calling convention automata in Lua>>=
A                = Automaton
PPC              = PPC              or {}
PPC.cc           = PPC.cc           or {}
PPC.cc["C"     ] = PPC.cc["C"     ] or {}
PPC.cc["C--"   ] = PPC.cc["C--"   ] or {}
PPC.cc["notail"] = PPC.cc["notail"] or {}

function PPC.r(i) return({ space = "r", index = i, width = 32 }) end
function PPC.f(i) return({ space = "f", index = i, width = 64 }) end

PPC.overflow = A.overflow { memsize       = 8
                          , byteorder     = "big"
                          , growth        = "down"
                          , max_alignment = 4
                          }

PPC.cc["C"].call =
  { A.widen(32, "multiple")
  , A.widths { 32, 64 }
  , A.bitcounter("bits")
  , A.argcounter("arg")
  , A.choice { "float",  A.regs_by_args("args", PPC.f(1) .. PPC.r(13))
             , A.is_any, A.regs_by_bits("bits", PPC.r(3) .. PPC.r(10))
             }
  , PPC.overflow
  }

PPC.cc["C"].results =
  A.choice
    { "float" , { A.widen(64), A.useregs { PPC.f(1) }}
    , A.is_any, { A.widen(32), A.useregs { PPC.r(3), PPC.r(4) }}
    }

PPC.cc["C"].cutto = { A.widen(32), PPC.overflow }

PPC.cc["C--"].call    = PPC.cc["C"].call
PPC.cc["C--"].results = { PPC.cc["C"].results, PPC.overflow }
PPC.cc["C--"].cutto   = PPC.cc["C"].cutto

PPC.cc["notail"] = PPC.cc["C--"]

A.register_cc(Backend.ppc.target,"C"     ,PPC.cc["C"     ])
A.register_cc(Backend.ppc.target,"C'"    ,PPC.cc["C"     ])
A.register_cc(Backend.ppc.target,"C--"   ,PPC.cc["C--"   ])
A.register_cc(Backend.ppc.target,"notail",PPC.cc["notail"])
@ 
% ---------------------------------------------------------------------------
\section{Target Specification}
% ---------------------------------------------------------------------------
<<target spec>>=
module F = Mflow.MakeStandard (
  struct
    let pc_lhs = Post.pc_lhs
    let pc_rhs = Post.pc_rhs
    let ra_reg = creg 5
    let ra_offset = 4                 (* size of call instruction *)
  end)
@ 
We must provide an automaton for allocating globals, and functions for
spilling and reloading registers.
<<target spec>>=
module A = Automaton
let ( *> ) = A.( *> )
let globals base = 
  let width w = if w <= 8 then 8 else if w <= 16 then 16 else Aux.round_up_to 32 w in
  let align = function 8 -> 1 | 16 -> 2 | _ -> 4 in
  A.at ~start:base (A.widen width *> A.align_to align *>
  A.overflow ~memsize:8 ~byteorder:Post.byte_order ~growth:Memalloc.Up ~max_alignment:4)

let spill lookup (_,_,w as reg) loc =
  [ Automaton.store loc (Rtl.fetch (Rtl.reg reg) w) w ]
    
let reload lookup (_,_,w as reg) loc =
  [ Rtl.store (Rtl.reg reg) (Automaton.fetch loc w) w ]
@ 
The actual [[Target.t]] for the PPC backend.
<<target spec>>=
let target =
  { T.name = "ppc"

  (* basic metrics and spaces are OK *)
  ; T.byteorder   = Post.byte_order  
  ; T.wordsize    = Post.wordsize
  ; T.pointersize = Post.wordsize
  ; T.vfp         = Space.Standard32.vfp
  ; T.alignment = 1
  ; T.memsize = 8
  ; T.spaces = [ Spaces.m; Spaces.r; Spaces.t; Spaces.c; Spaces.f; Spaces.u ]
  ; T.distinct_addr_sp = false

  (* Does the Pentium really implement IEEE 754?  I think so *)
  ; T.float = "ieee754"

  (* spill and reload are believed OK *)
  ; T.spill  = spill
  ; T.reload = reload

  (* control flow is solid, except [[cutto]] is a lie *)
  ; T.bnegate = F.bnegate (R.reg ('?', 99, 32))
  ; T.goto    = F.goto
  ; T.jump    = F.jump
  ; T.call    = F.call
  ; T.branch  = F.branch

  ; T.cc_specs         = []      (* added by lua code *)
  ; T.cc_spec_to_auto  = cconv

  (* global or hardware registers *)
  ; T.globals  = globals
  ; T.rounding_mode = R.reg ('?', 99, 32)
  ; T.named_locs   = Strutil.assoc2map 
                     ["IEEE 754 rounding mode", R.reg ('?', 99, 32)
                     ;"IEEE 754 rounding results", R.reg ('?', 99, 32)
                     ]
  
  (* bogosity *)
  ; T.data_section = "data" (* NOT REALLY A PROPERTY OF THE TARGET MACHINE... *)
  ; T.charset = "latin1" (* THIS IS NONSENSE!! NOT A PROPERTY OF THE MACHINE?? *)
  } 
@ 
% ---------------------------------------------------------------------------
\section{Variable Placer}
% ---------------------------------------------------------------------------
<<variable placer>>=
let unimp               = Impossible.unimp
let impossible          = Impossible.impossible

let vfp = Vfp.mk 23

let from_temps proc space = (* stage to allocate a temporary location *)
  let allocator = Talloc.Multiple.loc proc.Proc.temps space in
  let alloc ~width:w ~alignment:a ~hint:h = A.of_loc (allocator w) in
  A.wrap (fun methods -> {A.allocate = alloc; A.freeze = methods.A.freeze})

let placevars proc = 
  let is_float    hint w = w <= 32 && hint = "float" in
  let warn methods =
    let alloc ~width:w ~alignment:a ~hint:h =
      if w > 32 then
        unimp (Printf.sprintf "%d-bit values not supported"  w);
      methods.A.allocate w a h
    in
    {A.allocate = alloc; A.freeze = methods.A.freeze} in
  Block.srelative vfp "variables placed in memory" A.at
  (
    A.wrap warn *>
    A.choice
      [ is_float,               A.widen (Aux.round_up_to ~multiple_of: 32); 
        (fun h w -> w <= 32),   A.widen (fun _ -> 32) *> from_temps proc 't';
        A.is_any,               A.widen (Aux.round_up_to ~multiple_of: 8);
      ] *>
    A.as_stage proc.Proc.priv
  )
@ 
