% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% $Id$
% ---------------------------------------------------------------------------

Backend for PPC

% ---------------------------------------------------------------------------
\section{Module Structure}
% ---------------------------------------------------------------------------
<<ppc.mli>>=
module Spaces : sig
  val m : Space.t
  val r : Space.t
  val t : Space.t
  val c : Space.t
  val f : Space.t
  val u : Space.t
end
module Post : Postexpander.S
module X    : Expander.S
val target : Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@ 
<<ppc.ml>>=
module R    = Rtl
module RP   = Rtl.Private
module Up   = Rtl.Up
module Down = Rtl.Dn
module RU   = Rtlutil
module PX   = Postexpander
module T    = Target
module A    = Automaton
<<spaces>>
module Post = struct
  <<ppc postexpander>>
end
module X = Expander.IntFloatAddr (Post)
module F = Mflow.MakeStandard (
  struct
    let pc_lhs = Post.pc_lhs
    let pc_rhs = Post.pc_rhs
    let ra_reg = creg 5
    let ra_offset = 4
  end)
<<calling conventions>>
<<target spec>>
<<variable placer>>
@
% ---------------------------------------------------------------------------
\section{Spaces}
% ---------------------------------------------------------------------------
The PPC has 32 integer registers and 32 floating point registers.
<<spaces>>=
module Spaces = struct
  module S = Space
  module SS = Space.Standard32
  let bo = Rtl.BigEndian
  let id = Rtl.Identity
  let m = SS.m    bo [8;16;32]
  let r = SS.r 32 id [32]
  let t = SS.t    id [32]
  let c = SS.c 7  id [32]

  let flt = { S.space = 'u'
            ; S.doc = "floating point registers"
            ; S.cellwidth = 64
            ; S.indexwidth = 5
            ; S.indexlimit = Some 32
            ; S.aggregation = id
            ; S.widths = [64]
            ; S.classification = S.Reg
            }
 let f = S.checked flt
 let u = S.checked { flt with
                     S.indexwidth = 31
                   ; S.indexlimit = None
                   ; S.classification =
                      S.Temp { S.stands_for = 'f'
                             ; S.index_ok = (fun _ -> true)
                             ; S.set_doc = "floating point temporaries"
                             }
                   }
end
@ 
The power PC has 7 different control registers.
<<spaces>>=
let reg n  = R.reg ('r',n,32)
let freg n = R.reg ('f',n,32)
let creg n = R.reg ('c',n,32)
let nia    = creg 0  (* new (next) instr address         *)
let cia    = creg 1  (* current instr address (pc)       *)
let cr     = creg 2  (* condition register               *)
let fpscr  = creg 3  (* flt point condition register     *)
let xer    = creg 4  (* XER register                     *)
let lr     = creg 5  (* link register                    *)
let ctr    = creg 6  (* counter register                 *)
@ 
Setting bits in the control registers is handled by this utility
function. The [[flag_map]] function shold convert the flag parameter
to a bit number.
<<spaces>>=
let set_flag reg flag_map v flag =
  R.store (R.slice 1 (flag_map flag) reg)
          (R.bits (Bits.U.of_int v 1) 1) 1
@ 
The condition register is divided into eight identical fields, and the
first eight bits have special names. The third bit is a copy of the
[[SO]] flag from the [[XER]] register. The bits 4-7 are copies of
flags from the [[FRSCR]] register.
<<spaces>>=
let crf    n = R.slice 4 (n*4) cr  (* CR field       *)
let crfval n = R.fetch (crf n) 4   (* CR field value *)

type cr_flag = LT | GT | EQ | SO | FX | FEX | VX | OX
let cr_flag_to_bit = function
    LT  -> 0 | GT  -> 1 | EQ  -> 2 | SO  -> 3
  | FX  -> 4 | FEX -> 5 | VX  -> 6 | OX  -> 7
let set_cr_flag = set_flag cr cr_flag_to_bit 1
let clr_cr_flag = set_flag cr cr_flag_to_bit 0
@ 
Almost all of the bits in the floating point status register have special
names. I omit their complete definitions for now.
<<spaces>>=
(*
type fpscr_flag =
    FX | FEX | VX | OX | UX | ZX | XX
  | VXSNAN | VXISI | VXIDI | VXZDZ | VXIMZ | VXVC
  | FR | FI | VXSOFT | VXSQRT | VXCVI
  | VE | OE | UE | ZE | XE | NI | RN
*)
@ 
Three bits in the [[XER]] register have special names. The [[XER_SO]]
bit is copied to the [[CR]] register whenever it is set.
<<spaces>>=
type xer_flag = XER_SO | OV | CA
let xer_flag_to_bit = function XER_SO -> 0 | OV -> 1 | CA -> 2
let set_xer' = set_flag xer xer_flag_to_bit
let set_xer_flag fl = function
    XER_SO -> R.par [ set_cr_flag SO ; set_xer' 1 fl ]
  | _      -> set_xer' 1 fl
let clr_xer_flag fl = function
    XER_SO -> R.par [ clr_cr_flag SO ; set_xer' 0 fl ]
  | _  -> set_xer' 0 fl
@ 
% ---------------------------------------------------------------------------
\section{Post Expander}
% ---------------------------------------------------------------------------
<<ppc postexpander>>=
let byte_order = R.BigEndian
let wordsize = 32
let pc_lhs = nia
let pc_rhs = cia
module Address = struct
  type t = Rtl.exp
  let reg (space, n, w) = R.fetch (R.reg (space, n, w)) w
end
@ 
This temporary allocator is copied directly from the x86 backend.
<<ppc postexpander>>=
let talloc = ref None
let get_talloc () = match !talloc with
  | Some s -> s
  | None   -> Impossible.impossible "Temp allocator not registered with postexpander"
let remember_allocator ta = talloc := Some ta
let talloc space = Talloc.Multiple.reg space (get_talloc ())
@ 
Contexts.
<<ppc postexpander>>=
type context = (Talloc.Multiple.t -> int -> Register.t) * (Register.t -> bool)
let icontext = Talloc.Multiple.reg 't', fun (c, _, _) -> c = 'r' || c = 't'
let fcontext = icontext
let acontext = icontext
let rcontext = (fun x y -> Impossible.unimp "Unsupported soft rounding mode")
               ,fun r -> r = ('d', 0, 2)
let bcontext = (fun x y -> Impossible.impossible "allocate from bcontext")
               ,fun _ -> false

module SM = Strutil.Map
let operators = Context.standard icontext fcontext rcontext acontext bcontext
let resmap    = List.fold_left (fun m (n, a, r)-> SM.add n r m) SM.empty operators
let argmap    = List.fold_left (fun m (n, a, r)-> SM.add n a m) SM.empty operators
let arg_contexts   (n, _) = try SM.find n argmap 
                            with Not_found -> Impossible.impossible 
                                    ("cannot find arg context for "^n)
let result_context (n, _) = try SM.find n resmap
                            with Not_found -> Impossible.impossible
                                    ("cannot find result context for "^n)
@ 
A few utility functions for building common RTL's.
<<ppc postexpander>>=
let ui s = Printf.eprintf "*** unimp %s" s; []

let tloc t               = Rtl.reg t
let tval  ((_,_,w) as t) = R.fetch (tloc t) w
let twidth (_,_,w)       = w
let tstore tmp exp       = R.store (tloc tmp) exp (twidth tmp)

let mem    assn w addr = R.mem assn 'm' byte_order w addr
let memval assn w addr = R.fetch (mem assn w addr) w
@ 
The load and store instructions on the ppc cannot use register 0 as a
parameter. Right now this is avoided by not telling the register
allocator about register 0, so we don't have to worry about that here.
<<ppc postexpander>>=
let load ~dst ~addr assn =
  let w = twidth dst in
  assert (w = wordsize);
  [R.store (tloc dst) (memval assn w addr) w]

let store ~addr ~src assn =
  let w = twidth src in
  assert (w = wordsize);
  [R.store (mem assn w addr) (tval src) w]
@ 
The [[xload]] and [[xstore]] functions apply an operator to an
expression before loading or storing them in the final location. The
remaining postexpander load and store operations are defined in terms
of these two functions.
<<ppc postexpander>>=
let xload op ~dst ~addr w assn =
  let ext = R.app (R.opr op [w; twidth dst]) [memval assn w addr] in
  [tstore dst ext]

let xstore op ~addr ~src w assn =
  let ext = R.app (R.opr op [twidth src; w]) [tval src] in
  [R.store (mem assn w addr) ext w]

let sxload  = xload "sx"
let zxload  = xload "zx"
let lostore = xstore "lobits"
@ 
Immediate values and registers are copied into registers with
[[tstore]].
<<ppc postexpander>>=
let move ~dst ~src = [tstore dst (tval src)]
let lix  ~dst  exp = [tstore dst exp]
@ 
Load immediate is a bit tricky because the PPC only allows 16-bit
constants to be loaded directly.
<<ppc postexpander>>=
let li ~dst const =
  let con w i = R.bits (Bits.S.of_int i w) w in
  let split b = let i = Bits.S.to_int b in
                ( con 32 (i lsr 16)       (* high bits *)
                , con 16 (i land 0xffff)  (* low  bits *)
                )
  in
  match const with
    RP.Bits b -> let (h,l) = split b in
                 let l = R.app (R.opr "zx" [16;32]) [l] in
                 [ tstore dst (R.app (R.opr "or"  [32;32]) [tval dst;l])
                 ; tstore dst (R.app (R.opr "shl" [32;32]) [h;con 32 16])
                 ]
  | _         -> [ tstore dst (Up.const const) ]
@ 
Operators...
<<ppc postexpander>>=
let rtlop ~dst op tmpl = [tstore dst (R.app (Up.opr op) (List.map tval tmpl))]

let binop ~dst op tmp1 tmp2 = rtlop dst op [tmp1;tmp2]
let unop  ~dst op tmp       = rtlop dst op [tmp]
@ 
Block Copy...
<<ppc postexpander>>=
let block_copy ~dst assn1 ~src assn2 width = ui "block_copy"
@ 
Branch and call rtls.
<<ppc postexpander>>=
let br ~tgt = [R.store pc_lhs (tval tgt) wordsize]
let b ~tgt  = [R.store pc_lhs (Up.const tgt) wordsize]
@ 
Conditional branches are encoded as a comparison against the
appropriate bit in the CR register. With this scheme, the opposite
condition can be derived by changing the guard operator.
I am using a bits value of 0 because using 1 gives the wrong number.
<<ppc postexpander>>=
let bc x (opr, ws as op) y ~tgt =
    assert (ws = [wordsize]);
    [ R.guard (R.app (Up.opr op) [tval x; tval y]) 
              (R.store pc_lhs (Up.const tgt) wordsize)  (* effect *)
    ]

let negate = function
  | "ne"            -> "eq"
  | "eq"            -> "ne"
  | "ge"            -> "lt"
  | "gt"            -> "le"
  | "le"            -> "gt"
  | "lt"            -> "ge"
  | "geu"           -> "ltu"
  | "gtu"           -> "leu"
  | "leu"           -> "gtu"
  | "ltu"           -> "geu"
  | "feq"           -> Impossible.unimp "floating-point comparison"
  | "fne"           -> Impossible.unimp "floating-point comparison"
  | "flt"           -> Impossible.unimp "floating-point comparison"
  | "fle"           -> Impossible.unimp "floating-point comparison"
  | "fgt"           -> Impossible.unimp "floating-point comparison"
  | "fge"           -> Impossible.unimp "floating-point comparison"
  | "fordered"      -> Impossible.unimp "floating-point comparison"
  | "funordered"    -> Impossible.unimp "floating-point comparison"
  | _               -> Impossible.impossible 
                        "bad comparison in expanded MIPS conditional branch"

let bnegate r = match Down.rtl r with
    |           RP.Rtl [RP.App( (op,       [32]),[x;y]), RP.Store (pc,tgt,32)]
      when pc = Down.loc pc_lhs ->
        Up.rtl (RP.Rtl [RP.App( (negate op,[32]),[x;y]), RP.Store (pc,tgt,32)])
    | _ -> Impossible.impossible "ill-formed MIPS conditional branch"
@ 
Call instructions are the same as branches with some additional effects.
<<ppc postexpander>>=
let call  ~tgt ~others = [R.par (List.hd (b  tgt) :: List.map Up.effect others)]
let callr ~tgt ~others = [R.par (List.hd (br tgt) :: List.map Up.effect others)]

let cut_to effects = [R.par (List.map Up.effect effects)]
@ 
We want to prevent the expander from messing with the rtl [[pc := lr]]
which is a return from procedure call.
<<ppc postexpander>>=
let don't_touch_me = function
    [ RP.Store(pc_lhs, RP.Fetch(lr, _), _) ] -> true
  | _ -> false
@ 
Stack operations...
<<ppc postexpander>>=
let opclass op = PX.Register

let stack_depth = 8
let stack_width = 80
let stack_top_proxy_reg = ('\000', 0, 80)
let stack_top_proxy = R.reg stack_top_proxy_reg

let converts_stack_to_temp op = false
let push ~addr assn = ui "push"
let store_pop ~addr assn = ui "store_pop"
let push_cvt op width ~addr assn = ui "push_cvt"
let store_pop_cvt op width ~addr assn = ui "store_pop_cvt"
let pushk const = ui "pushk_const"
let pushk_cvt op width const = ui "pushk_cvt"
let stack_op op = ui "stack_op"
let bc_stack op ~tgt = ui "bc_stack"
let is_stack_top_proxy loc = false
@ 
% ---------------------------------------------------------------------------
\section{Calling Conventions}
% ---------------------------------------------------------------------------
<<calling conventions>>=
module C  = Call
module RS = Register.Set
@ 
Integer registers r0 is not used because of the restrictions on the arguments
of load/store instructions, r1 is the stack pointer,
r2 is reserved for position-independent code,
r3-r12 are volatile, and r13-r31 are non-volatile. For floating point,
registers f1-f13 are volatile, and f14-131 are not.
<<calling conventions>>=
let sp_reg = ('r', 1, 32)
let sp     = R.reg sp_reg
let vfp    = Vfp.mk 32

let regset s w l = RS.of_list (List.map (fun r-> (s,r,w)) l)
let vregs  = regset 'r' 32 [3;4;5;6;7;8;9;10;11;12]
let nvregs = regset 'r' 32 [13;14;15;16;17;18;19;20;21;
                            22;23;24;25;26;27;28;29;30;31]
let fvregs  = regset 'f' 64 [0;1;2;3;4;5;6;7;8;9;10;11;12;13]
let fnvregs = regset 'f' 64 [14;15;16;17;18;19;20;21;22;
                             23;24;25;26;27;28;29;30;31]
let cvregs = regset 'c' 32 [5(*lr*); 6(*ctr*); 4(*xer*); 2(*cr*)]

(* let volregs  = RS.union (RS.union vregs fvregs) cvregs *)
(* let nvolregs = RS.union nvregs fnvregs *)
let volregs  = RS.union vregs cvregs
let nvolregs = nvregs
@ 
A function to build a [[Call.t]]. This function is still cheating a
bit by using the dummy module. I have changed that fields that both
need to be different, and that I understand.
<<transformations>>=
let call_actuals  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out call parms" A.at specs.A.call)
    ~autosp:(fun r  -> Block.base r.A.overflow)
    ~postsp:(fun _ sp -> sp)
and prolog  =
  let autosp = (fun _ -> vfp) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in call parms" A.at specs.A.call)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a)
and call_results  =
  let autosp = (fun r -> Block.base r.A.overflow) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" A.at specs.A.results)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location) (* irrelevant? *)
    ~insp:(fun a _ _ -> autosp a)
and epilog  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" A.at specs.A.results)
    ~autosp:(fun r -> Block.base r.A.overflow)
    ~postsp:(fun _ _ -> vfp)  (* irrelevant *)
and also_cuts_to =
  let autosp = (fun r -> std_sp_location) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in cont parms" A.at specs.A.cutto)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a)
and cut_actuals base  =
   C.outgoing ~growth ~sp ~mkauto:(fun () -> A.at base specs.A.cutto)
     ~autosp:(fun r -> spval)
     ~postsp:(fun _ _ -> spval)
and saved_nvr temps =
  let t = Talloc.Multiple.loc temps 't' in
  fun (_, _, w) -> t w
@ 
<<calling conventions>>=
let cconv name specs =
  let ws              = Post.wordsize
  and growth          = Memalloc.Down
  and spval           = R.fetch sp 32
  and std_sp_location = RU.add 32 vfp (R.late "minus frame size" 32)
  in <<transformations>> in
  { C.name             = name
  ; C.overflow_alloc   = { C.parameter_deallocator = C.Caller
                         ; C.result_allocator      = C.Caller
                         }
  ; C.call_parms       = { C.in' = prolog;       C.out = call_actuals}
  ; C.cut_parms        = { C.in' = also_cuts_to; C.out = cut_actuals}
  ; C.results          = { C.in' = call_results; C.out = epilog}
 
  ; C.stack_growth     = growth
  ; C.stable_sp_loc    = std_sp_location
  ; C.replace_vfp      = Cfgx.Vfp.replace_with ~sp
  ; C.sp_align         = 4
  ; C.pre_nvregs       = nvolregs
  ; C.volregs          = volregs
  ; C.saved_nvr        = saved_nvr
  ; C.cutto            = F.cutto sp
  ; C.return           = (fun k n ~ra -> R.store nia (R.fetch lr ws) ws)
  ; C.ra_on_entry      = (fun b     -> R.fetch lr ws)
(*  ; C.where_to_save_ra = (fun e t     -> Post.mem R.none ws sp_8) *)
  ; C.where_to_save_ra = (fun _ t   -> Talloc.Multiple.loc t 't' ws)
  ; C.ra_on_exit       = (fun l e t -> lr)
  ; C.sp_on_jump       = (fun _ _   -> Rtl.null)
  }
@ 
The calling convention specs are written in Lua; they have no ML
counterpart.
<<PPC calling convention automata in Lua>>=
A                = Automaton
PPC              = PPC              or {}
PPC.cc           = PPC.cc           or {}
PPC.cc["C"     ] = PPC.cc["C"     ] or {}
PPC.cc["C--"   ] = PPC.cc["C--"   ] or {}
PPC.cc["notail"] = PPC.cc["notail"] or {}

function PPC.r(i) return({ space = "r", index = i, width = 32 }) end
function PPC.f(i) return({ space = "f", index = i, width = 64 }) end

PPC.overflow = A.overflow { memsize       = 8
                          , byteorder     = "big"
                          , growth        = "down"
                          , max_alignment = 4
                          }
@ 
For the C convention, the overflow block should contain space
corresponding to all of the parameters allocated into registers. I
want something like regs_by_bits for the overflow block. The Mips
backend uses a postprocess stage to handle something similar (see
mipscall.nw). In absence of a nicer solution, something like this will
have to be employed here.
<<PPC calling convention automata in Lua>>=
PPC.cc["C"].call =
  { A.widen(32, "multiple")
  , A.widths { 32, 64 }
  , A.bitcounter("bits")
  , A.argcounter("arg")
  , A.choice { "float",  A.regs_by_args("args", PPC.f(1) .. PPC.r(13))
             , A.is_any, A.regs_by_bits("bits", PPC.r(3) .. PPC.r(10))
             }
  , PPC.overflow
  }

PPC.cc["C"].results =
  A.choice
    { "float" , { A.widen(64), A.useregs { PPC.f(1) }}
    , A.is_any, { A.widen(32), A.useregs { PPC.r(3), PPC.r(4) }}
    }

PPC.cc["C"].cutto = { A.widen(32), PPC.overflow }
@
The [[C--]] convention is the same as the [[C]] convention except that
we provide an overflow block for results.
<<PPC calling convention automata in Lua>>=
PPC.cc["C--"].call    = PPC.cc["C"].call
PPC.cc["C--"].results = { PPC.cc["C"].results, PPC.overflow }
PPC.cc["C--"].cutto   = PPC.cc["C"].cutto
@ 
Finally, register all of the conventions for the PPC.
<<PPC calling convention automata in Lua>>=
A.register_cc(Backend.ppc.target,"C"     ,PPC.cc["C"  ])
A.register_cc(Backend.ppc.target,"C'"    ,PPC.cc["C"  ])
A.register_cc(Backend.ppc.target,"C--"   ,PPC.cc["C--"])
A.register_cc(Backend.ppc.target,"notail",PPC.cc["C--"])
@ 
% ---------------------------------------------------------------------------
\section{Target Specification}
% ---------------------------------------------------------------------------
<<target spec>>=
@ 
We must provide an automaton for allocating globals, and functions for
spilling and reloading registers.
<<target spec>>=
let ( *> ) = A.( *> )
let globals base = 
  let width w = if w <= 8 then 8 else if w <= 16 then 16 else Aux.round_up_to 32 w in
  let align = function 8 -> 1 | 16 -> 2 | _ -> 4 in
  A.at ~start:base (A.widen width *> A.align_to align *>
  A.overflow ~memsize:8 ~byteorder:Post.byte_order ~growth:Memalloc.Up ~max_alignment:4)

let spill lookup (_,_,w as reg) loc =
  [ Automaton.store loc (Rtl.fetch (Rtl.reg reg) w) w ]
    
let reload lookup (_,_,w as reg) loc =
  [ Rtl.store (Rtl.reg reg) (Automaton.fetch loc w) w ]
@ 
The actual [[Target.t]] for the PPC backend.
<<target spec>>=
let target =
  let spaces = [ Spaces.m; Spaces.r; Spaces.t; Spaces.c; Spaces.f; Spaces.u ] in
  { T.name = "ppc"

  (* basic metrics and spaces are OK *)
  ; T.byteorder   = Post.byte_order  
  ; T.wordsize    = Post.wordsize
  ; T.pointersize = Post.wordsize
  ; T.vfp         = Space.Standard32.vfp
  ; T.alignment = 1
  ; T.memsize = 8
  ; T.spaces = spaces
  ; T.reg_ix_map          = T.mk_reg_ix_map spaces
  ; T.distinct_addr_sp = false

  (* Does the Pentium really implement IEEE 754?  I think so *)
  ; T.float = "ieee754"

  (* spill and reload are believed OK *)
  ; T.spill  = spill
  ; T.reload = reload

  (* control flow is solid, except [[cutto]] is a lie *)
  ; T.bnegate = F.bnegate (R.reg ('?', 99, 32))
  ; T.goto    = F.goto
  ; T.jump    = F.jump
  ; T.call    = F.call
  ; T.branch  = F.branch

  ; T.cc_specs         = []      (* added by lua code *)
  ; T.cc_spec_to_auto  = cconv

  (* global or hardware registers *)
  ; T.globals  = globals
  ; T.rounding_mode = R.reg ('?', 99, 2)
  ; T.named_locs   = Strutil.assoc2map 
                     ["IEEE 754 rounding mode", R.reg ('?', 99, 2)
                     ;"IEEE 754 rounding results", R.reg ('?', 99, 2)
                     ]
  
  (* bogosity *)
  ; T.data_section = "data" (* NOT REALLY A PROPERTY OF THE TARGET MACHINE... *)
  ; T.charset = "latin1" (* THIS IS NONSENSE!! NOT A PROPERTY OF THE MACHINE?? *)
  } 
@ 
% ---------------------------------------------------------------------------
\section{Variable Placer}
% ---------------------------------------------------------------------------
<<variable placer>>=
let unimp               = Impossible.unimp
let impossible          = Impossible.impossible

let from_temps proc space = (* stage to allocate a temporary location *)
  let allocator = Talloc.Multiple.loc proc.Proc.temps space in
  let alloc ~width:w ~alignment:a ~hint:h = A.of_loc (allocator w) in
  A.wrap (fun methods -> {A.allocate = alloc; A.freeze = methods.A.freeze})

let placevars proc = 
  let is_float    hint w = w <= 32 && hint = "float" in
  let warn methods =
    let alloc ~width:w ~alignment:a ~hint:h =
      if w > 32 then
        unimp (Printf.sprintf "%d-bit values not supported"  w);
      methods.A.allocate w a h
    in
    {A.allocate = alloc; A.freeze = methods.A.freeze} in
  Block.srelative vfp "variables placed in memory" A.at
  (
    A.wrap warn *>
    A.choice
      [ (fun _ -> is_float),    A.widen (Aux.round_up_to ~multiple_of: 32); 
        (fun _ h w -> w <= 32), A.widen (fun _ -> 32) *> from_temps proc 't';
        A.is_any,               A.widen (Aux.round_up_to ~multiple_of: 8);
      ] *>
    A.as_stage proc.Proc.priv
  )
@ 
