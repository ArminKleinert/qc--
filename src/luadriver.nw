% vim: ts=8 et sw=4:

% ------------------------------------------------------------------ 
\section{The Lua Code}
% ------------------------------------------------------------------ 

The compiler is almost completely driven by a Lua script [[qc--.lua]]
that the built-in Lua interpreter executes at startup.  The script is
searched along a search path by an {\ocaml} function in module
\module{main.nw}. As a default, the script presented here is compiled
into the {\qcc} binary and executed unless the user has made special
arrangements.

The Lua 2.5 library function [[strfind]] is unimplemented. We therefore
use some special purpose functions from the [[Util]] module, implemented
in \module{luautil.nw}. 

<<qc--.lua>>=
-- 
-- This Lua code is generated from the following file that also includes
-- the documentation. Do not edit this file directly.
--
-- $Id$
--

<<Lua Boot Script>>

-- 
-- Evrything starts from here
--

-- CMD.interact()
-- Inspect.globals()

CMD.cmdline(Sys.argv)
return CMD.run()
@

To keep the Lua name space clean, related functionality is grouped into
tables which are used like modules. By convention, the names or tables
are capitalized.

% ------------------------------------------------------------------ 
\subsection{Introspection}
% ------------------------------------------------------------------ 

To support the debugging of Lua code we provide at the very beginning of
the script functions that allow to inspect the interpreter, This way are
available in the interpreter, even if later parts of the scrip fail to
load.

The module [[Inspect]] provides functions to dump the entire name space of
the interpreter to stdout.

[[Inspect.type]] returns the type of a table entry. It tries to be smart
about userdata.

<<Lua Boot Script>>=
Inspect = Inspect and error('Inspect not empty') or {}

function Inspect.type (val)  -- identify the value
    if type(val) == "userdata" then
        local s = tostring(val)
        if strlen(s) < 20 then
            return "userdata " .. s
        else
            return "userdata"
        end
    else
        return type(val)                                                            end
end
@

[[Inspect.globals]] and [[Inspect.table]] dump the table of all global
variables and a regular table, respectively. Both functions recurse if
they find a table, which they pass to [[Inspect.table]].

<<Lua Boot Script>>=
function Inspect.globals ()
    local key,val = nextvar(nil)
    while key do
        write(format ("%-40s%s\n",key, Inspect.type(val)))
        if type(val) == "table" then Inspect.table (key, val) end
        key,val = nextvar(key)
    end
end    


function Inspect.table (tabname,table)    -- helper for Inspect.vars 
    local key,val = next(table,nil)
    while key do
        local valname = Inspect.valname(tabname, key)
        write(format("%-40s%s\n", valname, Inspect.type(val)))
        if type(val) == "table" then Inspect.table (valname, val) end
        key,val = next(table,key)
    end
end


function Inspect.valname(tabname, key)
    if type(key) == "string" then
        return tabname .. "." .. key
    else
        return tabname .. "[" .. key .. "]"
    end
end
@

This script is stored as a string in [[Inspect["Lua Boot Script"]]]. For
convenience we provide an [[Inspect.script]] function that dumps it to
stdout.

<<Lua Boot Script>>=
function Inspect.script () write(Boot["Lua Boot Script"]) end    
@

The [[Inspect.find]] searches trough all tables for a key [[x]] and
returns the path to first [[x]] it finds as a string, or [[nil]].

<<Lua Boot Script>>=
function Inspect.find(x)
    local i, v, ii, vv
    -- search global tables for x
    i, v = nextvar(nil)
    while i do
        if type(v) == "table" then
            ii, vv = next(v, nil)
            while ii ~= nil do
                if vv == x then
                    return i .. "." .. ii
                else
                    ii, vv = next(v, ii)
                end
            end
        end
        i, v = nextvar(i)
    end
    -- search globals for x
    i, v = nextvar(nil)
    while i ~= nil do
        if v == x then
            return i
        else
            i, v = nextvar(i)
        end
    end
    return nil
end
@

% ------------------------------------------------------------------ 
\subsection{Global Variables}
% ------------------------------------------------------------------ 

<<Lua Boot Script>>=
backend = nil       -- initialized below
@

% ------------------------------------------------------------------ 
\subsection{Compiler Debugging}
% ------------------------------------------------------------------ 

We have some functionality that once was useful but that we do not have
found worth to assign an officical command line flag to. All these find
a new home in our [[Debug]] module.

<<Lua Boot Script>>=
Debug = Debug and error('Debug not empty') or {}

function Debug.prettyprint(file,out)
    local linewidth = 72
    local ast       = Driver.parse(file)
    local doc       = Driver.pretty(ast)
    fd              = out and writeto(out) or Driver.stdout
    Driver.print(doc,linewidth,fd)
    if out then writeto() end
end  
@

% ------------------------------------------------------------------ 
\subsection{Backplane and Backplane Stages}
% ------------------------------------------------------------------ 

The backplane provides primitives to construct stages which implement
back end phases in the compiler. For notational brevity, we introduce an
alias here. See \module{backplane.nw} for details.

<<Lua Boot Script>>=
B      = Backplane 
Stages = Stages    and error('Stages not empty') or {}

function Stages.nullf () return nil end
Stages.null = B.stage { name="empty stage", fn = Stages.nullf }
@

% ------------------------------------------------------------------ 
\subsection{Stage Patching}
% ------------------------------------------------------------------ 

Some primtive functions that are registered need to be stages rather
than functions. we simply patch the binding in the Lua interpreter here.

<<Lua Boot Script>>=

function Stages.make_stage(t, short, long)
  if type(t[short]) == 'function' then
    t[short] = B.stage { name=long, fn = t[short] }
  end
end

Stages.make_stage(Placevar,  'fortran', "fortran variable placer")
Stages.make_stage(Expander,  'dummy',   'dummy expander')
Stages.make_stage(Expander,  'sparc',   'sparc expander')
Stages.make_stage(Typecheck, 'proc',    'type check RTLs')
@


% ------------------------------------------------------------------ 
\subsection{Stack Layout (Experimental)}
% ------------------------------------------------------------------ 

We are planning to define stack layouts for several targets here. So
far, most details are not clear and we only have some experimental code
here.

A stack layout function must respect the backplane protocol: such a
function receives two values, where the second is a [[Proc.t]] value,
and returns boolean value.

<<Lua Boot Script>>=
Stack = Stack or error('Stack primitives missing')

function Stack.layout(dummy,proc)
    local blocks = Stack.blocks(proc)
    local layout = 
                { blocks.incoming               -- <-- high addresses
                , blocks.stackdata
                , blocks.continuations
                , Block.mk(blocks.sp, 24, 16)   -- size/alignment=24/16
                , blocks.spills
                , blocks.outgoing
                , blocks.sp                     -- <-- low addresses 
                }
    local block = Block.cat(999, layout)
    Stack.freeze(proc,block)
    return 1
end    
@


% ------------------------------------------------------------------ 
\subsection{Graph-Coloring Register Allocator}
% ------------------------------------------------------------------ 

The graph-coloring register allocator is part of the compiler backplane.
It is composed of several pieces that are combined here. Some more
informations what a user can do here would be welcome. 

The [[ColorGraph]] has predefined primitives which we expect to have
available here. 

<<Lua Boot Script>>=
ColorGraph = ColorGraph or error('predefined ColorGraph is empty')

ColorGraph.makeGraph = B.seq 
    { Liveness.liveness
    , ColorGraph.build 
    }
    
ColorGraph.orderVars = B.seq 
    { ColorGraph.makeWorklist
    , B.fix(B.unless_do(ColorGraph.simplify,
                            B.unless_do(ColorGraph.coalesce,
                                B.unless_do(ColorGraph.freeze,
                                    ColorGraph.selectSpill))))
    }

ColorGraph.pcg  = B.ignore(ColorGraph.printCG)
ColorGraph.pcfg = B.ignore(ColorGraph.pCFG)

ColorGraph.color = 
  B.share
    ( ColorGraph.cgInfo
    , "cgInfo"
    , B.seq 
                { ColorGraph.clearCGInfo
        , B.fix 
            ( B.seq 
                { B.ignore (B.seq
                    { ColorGraph.makeGraph
                    , ColorGraph.orderVars
                    , ColorGraph.assignColors
                    })
                , 
                   B.when_do
                    ( ColorGraph.haveSpilledTemps
                    , ColorGraph.resetProgram
                    )
                } 
            )    
        , B.seq 
            { ColorGraph.updateProgram
            , ColorGraph.applyColors
            }
        }        
    )
@

% ------------------------------------------------------------------ 
\subsection{Register Allocators}
% ------------------------------------------------------------------ 

All register allocators are made available in the table [[Ralloc]].

\emph{The code that defines Ralloc.linscan should move to [[Lualink]].
-- CL}

<<Lua Boot Script>>=
Ralloc = Ralloc or error('missing primitives in Ralloc')

Ralloc.color = ColorGraph.color
-- Ralloc.linscan is a primitives. 
@
% ------------------------------------------------------------------ 
\subsection{Optimizer}
% ------------------------------------------------------------------ 

For the translation of a procedure all back-end related actions, like
register allocation or variable assignment, are controlled by an
optimizer. The optimizer has a sequence of stages the procedure passes
through.

So far, we just have one standard optimizer that receives the current
backend and an assembler.

<<Lua Boot Script>>=
Opt = Opt and error('Opt not empty') or {}

function Opt.standard(backend, asm)
  local x = B.seq
    { backend.widen      or Stages.null
    , backend.placevars  or Stages.null
    , backend.expand     or Stages.null
    , backend.liveness   or Stages.null
    , backend.ralloc     or Stages.null
    , backend.freeze     or Stages.null
    , B.stage { name="assemble procedure", fn = Driver.proc_assembler(asm) }
    } 
  return x
end
@

% ------------------------------------------------------------------ 
\subsection{Backends}
% ------------------------------------------------------------------ 

A backend value describes everything the compiler needs to know to
produce code for a particular target. Many values in the description of
a backend are primitives, and thus cannot be simply constructed in Lua.

<<Lua Boot Script>>=
Backend = Backend and error('Backend not empty') or {}

Backend.debug = --- debugging back end
  { target    = Targets.dummy
  , widen     = Stages.null
  , placevars = Placevar.fortran
  , expand    = Expander.dummy
  , liveness  = Stages.null
  , ralloc    = Ralloc.color
  , freeze    = Stack.layout
  , asm       = Asm.cmm
  , emit      = Driver.assemble
  }   
Backend.dummy = Backend.debug  -- alias

Backend.check = --- debugging back end
  { target    = Targets.dummy
  , widen     = Stages.null
  , placevars = Placevar.fortran
  , expand    = Expander.dummy
  , liveness  = Stages.null
  , ralloc    = Ralloc.color
  , freeze    = Stack.layout
  , asm       = Asm.cmm
  , emit      = nil
  }   

Backend.x86 =     
  { target    = Targets.x86
  , widen     = Stages.null
  , placevars = Placevar.fortran
  , expand    = Expander.x86
  , liveness  = Stages.null
  , ralloc    = Ralloc.color
  , freeze    = Stack.layout
  , asm       = Asm.x86
  , emit      = Driver.assemble
  }   

Backend.interp =     
  { target    = Targets.interp
  , widen     = Stages.null
  , placevars = Stages.null
  , expand    = Stages.null
  , liveness  = Stages.null
  , ralloc    = Stages.null
  , freeze    = Stack.layout
  , asm       = Asm.interp
  , emit      = Driver.assemble
  }   


-- initialization
backend = Backend.debug

@

% ------------------------------------------------------------------ 
\subsection{Compiler}
% ------------------------------------------------------------------ 

The [[Compile.file]] function takes the file name for a {\PAL} source
file, a backend, and the name of the (assembly) file to produce and
compile the file.
 
\emph{I do not understand how the optimizer is run here. Maybe some
clarifying words by the designer are in order. -- CL} 

Lua 2.5 does not suffer from insanity, it enjoys every minute of it.
Witness the absence of a traditional [[open()]] to obtain a file
descriptor. We here have to use [[writeto]] to open a file, which at the
same time takes or [[stdout]] away.

There is some inconsistency how we deal with files. The [[Driver.parse]]
function takes a file name, while an assembler expects a file
descriptor.

<<Lua Boot Script>>=
Compile = Compile and error('Compile not empty') or {}

function Compile.run_optimizer(self,proc)
    B.run(self.action, proc)
end    

function Compile.file(backend, file, out)
    local fd  = out and writeto(out) or Driver.stdout
    local ast = Driver.parse(file) 
    local asm = backend.asm(fd)
    local env = Driver.check(ast,asm) -- asm is stored in env
    local opt = { apply  = Compile.run_optimizer
                , action = Opt.standard(backend, asm) 
                }
    Driver.compile(opt, ast, backend.target, env)
    if backend.emit then backend.emit(asm) end
    writeto() -- close fd
end    
@

% ------------------------------------------------------------------ 
\subsection{Command Line Handling and Driver}
% ------------------------------------------------------------------ 

Command line parsing is implemented in Lua. The command line is passed
as an table to [[CMD.cmdline]] which records the results in the
[[Options]] table. From there it is read by [[CMD.run]] that decides
what to do and triggers the compilation of all the files on the command
line. What needs to be done for each file is decided by
[[CMD.dispatch]]. 

<<Lua Boot Script>>=
Options = Options and error('Options not empty') or {}

Options.to_obj   = nil      -- -c
Options.to_asm   = nil      -- -S
Options.verbose  = 0        -- -v
Options.output   = nil      -- -o
Options.help     = nil      -- -help
Options.version  = nil      -- -versions
Options.interact = nil      -- -i
-- debug options below
Options.pretty   = nil      -- -pp

Options.argc     = 0        -- number of files
Options.argv     = {}       -- argv[1], .. , argv[argc]

Options.tempdir  = getenv("TMP") or getenv("TEMP") or "/tmp"
@

The command line driver calls an external assembler [[as]] and linker
[[ld]]. They have their own tables.

<<Lua Boot Script>>=
As = As and error ('As not empty') or {}

As.path    = "as"           -- binary 
As.options = ""             -- options passed to binary

Ld = Ld and errir ('Ld not empty') or {}
Ld.path     = "ld"          -- binary
Ld.options  = ""            -- options
@

All logic for the command line is encapsulated in the [[CMD]] module.
\emph{We should define how to deal with errors and in particular whether
this code should return to {\ocaml}}.

<<Lua Boot Script>>=
CMD = CMD and error('CMD not empty') or {}
@

[[CMD.interact]] implements an read--eval loop that gives the user
interactive access to the interpreter. This is most useful for debugging
Lua code.

<<Lua Boot Script>>=
function CMD.interact ()
    local prompt = "\n-- "
    local stmt
    write ("-- This is Lua for QC--\n")
    write ("-- Call Inspect.globals() to dump name space")
    
    write(prompt)
    stmt = read()
    while stmt ~= nil do
        dostring(stmt)
        write(prompt)
        stmt = read()
    end           
end
@

Simple command line options are implemented in the [[CMD]] module
directly. 

<<Lua Boot Script>>=
CMD.manpage = [[
       qc-- processes options from left to right, and then all
       file name arguments from left to right.

       -c  Compile to object code, do not link. Each C-- source
           ("file.c--") and assembly file ("file.s") is compiled
           and assembled to an object file ("file.o"), but not
           linked. This option is incompatible with option -S.

       -S  Compile to assembly code, do not assemble or link.
           Each C-- source ("file.c--") file is compiled to a
           corresponding "file.s" assembly file. No assembling or
           linking. This option is incompatible with option -c

       -o output
           Name the output file output.  If -c or -S is specified
           and there is exactly  one  source  file,  this option
           names  the object or assembly file, respectively.
           Otherwise, this  option  names  the  final executable
           file generated  by  the  loader. If -o is not used,
           the output file defaults to "a.out".

       -Ldir
           Add dir to the library search path. This option can be
           repeated and is passed to the linker.

       -lname
           Add library name to the list of libraries to be
           searched. This option can be repeated is passed to the
           linker.

       -v  Print commands as they are executed. Commands include
           calls to all external programs, like the assembler or
           linker.

       -version
           Print version to stdout and stop with exit code 0.
           This option is incompatible with any other option.

       -help
           Summarize options to stdout and stop with exit code 0.
           This option is incompatible with any other option.

       var=value
           Assign the variable var in qc--'s Lua interpreter the
           new value value. Refer to qc--internals(1) for
           details.
]]


function CMD.usage ()
    write ("qc-- [option|file] ..\n")
    write (CMD.manpage)
end

-- Boot.version writes to a channel such that you cannot use the version
-- to control program behavior. 

function CMD.version ()
    write ("Quick C-- Version ")
    Boot.version(Driver.stdout) 
    write ("\n")
end    

function CMD.error (msg)
    write ("Error: " .. msg .. "\n")
end    
@

The [[CMD.cmdline]] function is the heart of the module. It takes a list
(represented as table) with all command line arguments and parses it.
The results are recorded in the global table [[Options]].

File arguments are accumulated in the variable [[Options.argv]], using
[[Options.argc]] as an index to the last argument. The files in [[argv]]
are compiled and linked in this order. Since linking is sensitive to
order, we have to treat options like [[-L]] and [[-l]] that affect
linking. 

We have to be careful when using tables as lists, as tables do not
guarantee any order when traversed using [[next()]]. Therefore we rely
on indices. All out tables are indexed by consecutive numbers $1 \dots
n$.

<<Lua Boot Script>>=
function CMD.cmdline (args)
    local O = Options
    
    local i = 1
    local v
    while args[i] and type(args[i]) == "string" do
        v = args[i]
        if     v == "-c"            then O.to_obj       = not nil 
        elseif v == "-S"            then O.to_asm       = not nil 
        elseif v == "-i"            then O.interact     = not nil
        elseif strsub(v,1,2)== "-L" then O.argc = O.argc+1; O.argv[O.argc] = v
        elseif strsub(v,1,2)== "-l" then O.argc = O.argc+1; O.argv[O.argc] = v
        elseif v == "-v"            then O.verbose = O.verbose + 1
        elseif v == "-vv"           then O.verbose = O.verbose + 2
        elseif v == "-version"      then O.version      = not nil
        elseif v == "-help"         then O.help         = not nil
        elseif v == "-pp"           then O.pretty       = not nil
        elseif Util.contains(v, "=")then dostring (v) 
        elseif v == "-o" then 
            i,v    = i+1, args[i+1]
            if not v then error("argument for option -o missing") end
            O.output = v 
        elseif v == "-e" then 
            i, v   = i+1, args[i+1]
            if not v then error("argument for option -e missing") end
            dostring(v)
        elseif strsub(v, 1, 1) == "-" then 
            CMD.error("unknown option: "..v)
            CMD.usage()
            exit(2)
        else -- it is a file    
            O.argc         = O.argc + 1
            O.argv[O.argc] = v 
        end
        i = i+1
    end
end
@

[[CMD.run]] starts the real work. It inspects the [[Options]] table to
see what the user has requested and starts doing it. In a loop it passes
all file arguments to [[CMD.dispatch]] which decides what to do based on
the file's suffix and the options.

<<Lua Boot Script>>=
function CMD.run ()
    local O = Options
    
    if      O.help      then CMD.usage ()  ; return 0
    elseif  O.version   then CMD.version() ; return 0
    elseif  O.interact  then CMD.interact(); return 0
    elseif  O.argc == 0 then CMD.usage ()  ; return 0
    
    elseif  O.to_obj  and O.to_asm then 
        CMD.error("Options -c and -S exclude each other")
        return 1
    elseif  O.argc > 1 and O.to_asm and O.output then
        CMD.error("Cannot specify -o and -S with multiple compilations")
        return 1
    elseif  O.argc > 1 and O.to_obj and O.output then
        CMD.error("Cannot specify -o and -c with multiple compilations")
        return 1
    elseif  O.argc > 1 and O.pretty and O.output then
        CMD.error("Cannot specify -o and -pp with multiple compilations")
        return 1
    else
        local i = 1
        local obj
        local objs= {}
        objs.n = 0      -- save in OCaml implementation?

        while i <= O.argc do
            obj = CMD.dispatch(Options.argv[i],O.output)
            -- skip nil entries resulted from *.lua
            if obj then objs.n=objs.n+1; objs[objs.n] = obj end
            i = i+1
        end 
        if not O.to_asm and not O.to_obj and not O.pretty then
            CMD.link(objs, O.output)
        end
    end
    return 0
end    
@

[[CMD.dispatch]] decides what needs to be done with an individual file,
based on its file name suffix and returns the file name of the final
result. This is simple in principle and complicated in practice because
of the [[-o]] flag. Depending on the situation this flag affects the
file name of produced files. I strongly recommend that you test this
code thoroughly if you make changes.

The [[CMD.cmm2asm]] does what it names suggest: it takes the name of a
{\PAL} source file and compiles it to an assembly file. If the second
parameter [[out]] is not [[nil]] it specifies the file name of the
resulting file. Otherwise the [[cmm2asm]] is free to pick a name. This
applies to the other functions $x$[[2]]$y$ analogously.

<<Lua Boot Script>>=
function CMD.dispatch(file,out)
    if Util.checksuffix (file, ".c--") or Util.checksuffix(file, ".cmm") then 
        if      Options.to_asm -- -S option
        then    return CMD.cmm2asm(file, out) 
        elseif  Options.pretty
        then    return CMD.cmm2pp(file, out)
        else    return CMD.cmm2obj(file, Options.to_obj and out)
        end
    elseif Util.checksuffix(file, ".s") then 
        if      Options.to_asm -- -S option
        then    return file    -- what do, if out ~= file?
        else    return CMD.asm2obj(file, Options.to_obj and out)
        end
    elseif Util.checksuffix(file, ".lua") then 
        return dofile(file)
    else -- catches -L* -l* *.o *.a *.so
        return file    
    end
    return nil
end
@

[[Util.chopsuffix]] strips a suffix from a file and and returns it. Unlike
the Unix \textit{basename}(1) it does not strip of the directory part of
the name.

As explained above, a function of name $x$[[2]]$y$ takes a file name of
type $x$, creates a file of type $y$, and returns its name. If the
[[out]] parameter is not nil, the name of the returned file must be the
the value of [[out]].

<<Lua Boot Script>>=
function CMD.cmm2pp(file,out)
    local base = Util.chopsuffix(file)
    local pp   = out or base .. ".pp"
    Debug.prettyprint(file,pp)
    return pp
end

function CMD.cmm2obj(file,out)
    local base = Util.chopsuffix(file)
    local asm  = base .. ".s"
    Compile.file(backend, file, asm) 
    local obj  = CMD.asm2obj(asm,out)
    return obj
end    

function CMD.cmm2asm(file,out)
    local base = Util.chopsuffix(file)
    local asm  = out or base .. ".s"
    Compile.file(backend, file, asm)
    return asm
end    

function CMD.asm2obj(file,out)
    local obj = out or Util.chopsuffix(file) .. ".o"
    local cmd = format ("%s %s -o %s %s"
                       , As.path
                       , As.options
                       , obj
                       , file
                       )
    CMD.exec(cmd)
    return obj
end
@

Depending on the verbosity level, commands are silently executed (0),
shown before executions (1), only shown, but not executed (2).

<<Lua Boot Script>>=
function CMD.exec(cmd)
    if Options.verbose == 1 then write(format("executing: %s\n", cmd)) end
    if Options.verbose == 2 then 
        write(format("simulating: %s\n", cmd)) 
    else
        if not execute(cmd) then error(cmd) end
    end    
end
@

The linker takes a list of object files in a table [[objs]] and an
optional output file.

<<Lua Boot Script>>=
function CMD.link(objs,out)
    local exe = out or "a.out"
    local cmd = format ("%s %s -o %s"
                       , Ld.path
                       , Ld.options
                       , exe
                       )
    local i = 1
    while i <= objs.n do
        if type(objs[i]) == "string" then
            cmd = cmd ..  " " .. objs[i]
        end    
        i = i + 1
    end
    CMD.exec(cmd)
    return exe
end    
@


