% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:

% ------------------------------------------------------------------ 
\section{The Lua Code}
% ------------------------------------------------------------------ 

The compiler is almost completely driven by a Lua script [[qc--.lua]]
that the built-in Lua interpreter executes at startup.  The script is
searched along a search path by an {\ocaml} function in module
\module{main.nw}. As a default, the script presented here is compiled
into the {\qcc} binary and executed unless the user has made special
arrangements.

The Lua 2.5 library function [[strfind]] is unimplemented. We therefore
use some special purpose functions from the [[Util]] module, implemented
in \module{luautil.nw}. 

<<qc--.lua>>=
-- 
-- This Lua code is generated from the following file that also includes
-- the documentation. Do not edit this file directly.
--
-- $Id$
--

<<Lua Boot Script>>

-- 
-- Evrything starts from here
--

backend = Backend.dummy32b

CMD.cmdline(Sys.argv)
return CMD.run()
@

To keep the Lua name space clean, related functionality is grouped into
tables which are used like modules. By convention, the names or tables
are capitalized.

% ------------------------------------------------------------------ 
\subsection{Introspection}
% ------------------------------------------------------------------ 

To support the debugging of Lua code we provide at the very beginning of
the script functions that allow to inspect the interpreter, This way are
available in the interpreter, even if later parts of the scrip fail to
load.

The module [[Inspect]] provides functions to dump the entire name space of
the interpreter to stdout.

[[Inspect.type]] returns the type of a table entry. It tries to be smart
about userdata.
<<Lua Boot Script>>=
Inspect = Inspect and error('Inspect not empty') or {}

function Inspect.type (val)  -- identify the value
    if type(val) == "userdata" then
        local s = tostring(val)
        if strlen(s) < 20 then
            return "userdata " .. s
        else
            return "userdata"
        end
    else
        return type(val)
    end
end
@
[[Inspect.globals]] and [[Inspect.table]] dump the table of all global
variables and a regular table, respectively. Both functions recurse if
they find a table, which they pass to [[Inspect.table]].
<<Lua Boot Script>>=
function Inspect.globals ()
    local key,val = nextvar(nil)
    while key do
        write(format ("%-40s%s\n",key, Inspect.type(val)))
        if type(val) == "table" then Inspect.table (key, val) end
        key,val = nextvar(key)
    end
end    

function Inspect.table (tabname,table)    -- helper for Inspect.vars 
    local key,val = next(table,nil)
    while key do
        local valname = Inspect.valname(tabname, key)
        write(format("%-40s%s\n", valname, Inspect.type(val)))
        if type(val) == "table" then Inspect.table (valname, val) end
        key,val = next(table,key)
    end
end

function Inspect.valname(tabname, key)
    if type(key) == "string" then
        return tabname .. "." .. key
    else
        return tabname .. "[" .. key .. "]"
    end
end
@
This script is stored as a string in [[Inspect["Lua Boot Script"]]]. For
convenience we provide an [[Inspect.script]] function that dumps it to
stdout.
<<Lua Boot Script>>=
function Inspect.script () write(Boot["Lua Boot Script"]) end    
@

The [[Inspect.find]] searches trough all tables for a key [[x]] and
returns the path to first [[x]] it finds as a string, or [[nil]].

<<Lua Boot Script>>=
function Inspect.find(x)
    local i, v, ii, vv
    -- search global tables for x
    i, v = nextvar(nil)
    while i do
        if type(v) == "table" then
            ii, vv = next(v, nil)
            while ii ~= nil do
                if vv == x then
                    return i .. "." .. ii
                else
                    ii, vv = next(v, ii)
                end
            end
        end
        i, v = nextvar(i)
    end
    -- search globals for x
    i, v = nextvar(nil)
    while i ~= nil do
        if v == x then
            return i
        else
            i, v = nextvar(i)
        end
    end
    return nil
end
@

% ------------------------------------------------------------------ 
\subsection{Global Variables}
% ------------------------------------------------------------------ 

<<Lua Boot Script>>=
backend = nil       -- initialized below
@

% ------------------------------------------------------------------ 
\subsection{Compiler Debugging}
% ------------------------------------------------------------------ 

We have some functionality that once was useful but that we do not have
found worth to assign an officical command line flag to. All these find
a new home in our [[Debug]] module.

<<Lua Boot Script>>=
Debug = Debug and error('Debug not empty') or {}

function Debug.prettyprint(file,out)
    local linewidth = 72
    local ast       = Driver.parse(file)
    local doc       = Driver.pretty(ast)
    fd              = (not out or out == "-") and Driver.stdout or open_out(out)
    Driver.print(doc,linewidth,fd)
    if fd ~= Driver.stdout then close_out(fd) end
end  
@

% ------------------------------------------------------------------ 
\subsection{Backplane and Backplane Stages}
% ------------------------------------------------------------------ 

The backplane provides primitives to construct stages which implement
back end phases in the compiler. For notational brevity, we introduce an
alias here. See \module{backplane.nw} for details.
<<Lua Boot Script>>=
B      = Backplane 
Stages = Stages or {}

function Stages.nullf () return nil end
Stages.null = B.stage { name="empty stage", fn = Stages.nullf }

function Stages.assert(prop)
  return NewBackplane.stage { name='assert ' .. prop, creates={prop},
                              fn = Stages.nullf}
end
@

% ------------------------------------------------------------------ 
\subsection{Stage Patching}
% ------------------------------------------------------------------ 

Some primitive functions that are registered need to be stages rather
than functions. We patch the binding in the Lua interpreter here.
<<Lua Boot Script>>=
function Stages.make_stage(t, short, long, B)
  B = B or Backplane
  if type(t[short]) == 'function' then
    if type(long) == 'table' then
      local stage = { fn = t[short] }
      <<add every key-value pair in [[long]] to [[stage]]>>
      t[short] = B.stage(stage)
    else
      t[short] = B.stage { name=long, fn = t[short] }
    end
  end
end

Stages.make_stage(Stages, 'replace_vfp', {name='replace VFP', uses='no late consts' },
                  NewBackplane)

Stages.make_stage(Placevar,  'fortran', "fortran variable placer")
Stages.make_stage(Placevar,  'new_fortran',
                  {name="new fortran variable placer",creates='no vars'}, NewBackplane)
Stages.make_stage(Typecheck, 'proc',    'type check RTLs')
-- non longer compiled in:
-- Stages.make_stage(Expander,  'dummy',   'dummy expander')
-- Stages.make_stage(Expander,  'sparc',   'sparc expander')
<<add every key-value pair in [[long]] to [[stage]]>>=
local k, v = next(long, nil)
while k do
  stage[k] = v
  k, v = next(long, k)
end
@


% ------------------------------------------------------------------ 
\subsection{Stack Layout}
% ------------------------------------------------------------------ 

A stack layout function must respect the backplane protocol: such a
function receives two values, where the second is a [[Proc.t]] value,
and returns boolean value.
<<Lua Boot Script>>=
Stack = Stack or error('Stack primitives missing')

function Stack.layout(dummy,proc)
   -- works only with *old* back end
    local blocks = Stack.blocks(proc)
    local layout = 
                { blocks.oldblocks[1]               -- <-- high addresses
                , blocks.stackdata
                , blocks.continuations
                , Block.relative(blocks.sp, 'six words', 24, 16)   -- size/alignment=24/16
                , blocks.spills
                , blocks.youngblocks[1]
                , blocks.sp                     -- <-- low addresses 
                }
    local block = Block.cat(999, layout)
    Stack.freeze(proc,block)
    return 1
end    
@ 
The new layout supports the virtual frame pointer.
<<Lua Boot Script>>=
Debug = Debug or {}
function Debug.showblocks(blocks, keys)
  local i = 1
  while keys[i] do
    local block = blocks[keys[i]]
    write(format('block %13s is %d bytes at %s\n',
                 keys[i], Block.size(block), Block.base(block)))
    local constraints = Block.constraints(block)
    local j = 1
    while constraints[j] do
      write(format('  where %s\n', constraints[j]))
      j = j + 1
    end
    i = i + 1
  end
end
@ 
This code should probably move to the x86 module.
<<Lua Boot Script>>=
X86 = X86 or {}
X86.layout = { creates='no late consts' }

function X86.layout.fn(dummy,proc) --- dispatch on cc name
  return X86.layout[Stack.ccname(proc)](dummy, proc)
end

function X86.layout["C"](dummy,proc) --- really for a C convention only
    local blocks = Stack.new_blocks(proc)
    blocks.ra = Block.relative(blocks.vfp, "return address", 4, 4)

    blocks.oldblocks   = Block.overlap(32, "low", blocks.oldblocks)
    blocks.youngblocks = Block.overlap(32, "low", blocks.youngblocks)
    local layout = 
                { blocks.oldblocks               -- <-- high addresses
                , blocks.ra
                , blocks.vfp
                , blocks.stackdata
                , blocks.continuations
                , blocks.spills
                , blocks.youngblocks
                , blocks.sp                     -- <-- low addresses 
                }
    if Debug.stack then
      write('======= using stack layout for C/notail =======\n')
      write('****** cc name = ', Stack.ccname(proc), '\n')
      Debug.showblocks (blocks, {'oldblocks', 'ra', 'vfp', 'stackdata',
                                 'continuations', 'spills', 'youngblocks', 'sp'})
    end
    local block = Block.cat(32, layout)
    Stack.new_freeze(proc,block)
    return 1
end    

X86.layout["notail"] = X86.layout["C"]

function X86.layout["C--"](dummy,proc)
    local blocks = Stack.new_blocks(proc)

    if Debug.stack then
      write('======= using stack layout for C-- with tail calls =======\n')
      local i = 1
      local keys = { }
      while blocks.oldblocks[i] do keys[i] = i; i = i + 1 end
      write('old blocks:\n')
      Debug.showblocks(blocks.oldblocks, keys)
      write('\n')
    end

    blocks.ra = Block.relative(blocks.vfp, "return address", 4, 4)
    -- first old block is always the incoming parms
    blocks.oldblocks[1] = Block.cat(32, {blocks.oldblocks[1], blocks.ra, blocks.vfp})
    blocks.oldblocks   = Block.overlap(32, "high", blocks.oldblocks)
    blocks.youngblocks = Block.overlap(32, "high", blocks.youngblocks)
    local layout = 
                { blocks.oldblocks               -- <-- high addresses
                --- , blocks.ra  -- joined to incoming block
                --- , blocks.vfp
                , blocks.stackdata
                , blocks.continuations
                , blocks.spills
                , blocks.sp                     -- <-- low addresses 
                , blocks.youngblocks
                }
    if Debug.stack then
      Debug.showblocks (blocks, {'oldblocks', 'ra', 'vfp', 'stackdata',
                                 'continuations', 'spills', 'sp', 'youngblocks'})
    end
    local block = Block.cat(32, layout)
    Stack.new_freeze(proc,block)
    return 1
end    
@

% ------------------------------------------------------------------ 
\subsection{Graph-Coloring Register Allocator}
% ------------------------------------------------------------------ 

Defined in file \texttt{colorgraph.nw}.
<<Lua Boot Script>>=
<<Lua startup code for [[Colorgraph]] module>>
@

% ------------------------------------------------------------------ 
\subsection{Register Allocators}
% ------------------------------------------------------------------ 

All register allocators are made available in the table [[Ralloc]].

\emph{The code that defines Ralloc.linscan should move to [[Lualink]].
-- CL}

<<Lua Boot Script>>=
Ralloc = Ralloc or error('missing primitives in Ralloc')

Ralloc.color    = ColorGraph.color
Ralloc.new_color = NewColorGraph.color
-- Ralloc.linscan is a primitives. 
@
% ------------------------------------------------------------------ 
\subsection{Optimizer}
% ------------------------------------------------------------------ 

For the translation of a procedure all back-end related actions, like
register allocation or variable assignment, are controlled by an
optimizer. The optimizer has a sequence of stages the procedure passes
through.

So far, we just have one standard optimizer that receives the current
backend and an assembler.

<<Lua Boot Script>>=
Opt = Opt and error('Opt not empty') or {}

function whichB(B)
  if B == Backplane then return "original backplane"
  elseif B == NewBackplane then return "new backplane"
  else return "not a backplane"
  end
end

-- function verbose(s, a, b, c, d, e, f, g, h)
--    return
-- end

function Opt.standard(backend, asm, B)
--verbose('running Opt.standard with third argument ', whichB(B), '\n')
  B = B or Backplane
--verbose('running Opt.standard with ', whichB(B), '\n')
  Stages.null = B.stage {name="empty stage for " .. whichB(B), fn=Stages.nullf}
  local x = B.seq
    { backend.widen      or Stages.null
    , backend.placevars  or Stages.null
    , backend.expand     or Stages.null
    , backend.liveness   or Stages.null
    , backend.ralloc     or Stages.null
    , backend.freeze     or Stages.null
    , backend.rmvfp      or Stages.null
    , B.stage { name="assemble procedure", fn = Driver.proc_assembler(asm) }
    } 
--verbose('built a standard optimizer with ', whichB(B), '\n')
  return x
end
@

% ------------------------------------------------------------------ 
\subsection{Backends}
% ------------------------------------------------------------------ 

A backend value describes everything the compiler needs to know to
produce code for a particular target. Many values in the description of
a backend are primitives, and thus cannot be simply constructed in Lua.

<<Lua Boot Script>>=
Backend = Backend and error('Backend not empty') or {}

function Backend.make(b)
  return
    { target    = b.target    or error('target not specified')
    , widen     = b.widen     or Stages.null
    , placevars = b.placevars or Stages.null
    , expand    = b.expand    or Stages.null
    , liveness  = b.liveness  or Liveness.liveness
    , ralloc    = b.ralloc    or Stages.null
    , freeze    = b.freeze    or Stack.layout
    , asm       = b.asm       or Asm.cmm
    , emit      = b.emit      or Driver.assemble
    }   
end

Backend.dummy32l = Backend.make {target=Targets.dummy32l}
Backend.dummy32b = Backend.make {target=Targets.dummy32b}
Backend.dummy    = Backend.dummy32b -- alias

Backend.interp = Backend.make {target=Targets.interp, asm=Asm.interp}

Backend.x86 =     
  { target    = Targets.x86
  , widen     = { fn = Stages.nullf, name='assert proper widths',
                  creates='proper widths'}
  , placevars = Placevar.fortran
  , expand    = Expander.x86
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.color
  , freeze    = Stack.layout
  , asm       = Asm.x86
  , emit      = Driver.assemble
  }   

Backend.new_x86 =     
  { target    = Targets.new_x86
  , widen     = Stages.assert('proper widths')
  , placevars = Placevar.new_fortran
  , expand    = Expander.new_x86
  , liveness  = Liveness.new_liveness
  , ralloc    = Ralloc.new_color
  , freeze    = X86.layout
  , rmvfp     = Stages.replace_vfp
  , asm       = Asm.new_x86
  , emit      = Driver.assemble
  }   
@

% ------------------------------------------------------------------ 
\subsection{Compiler}
% ------------------------------------------------------------------ 

The [[Compile.file]] function takes the file name for a {\PAL} source
file, a backend, and the name of the (assembly) file to produce and
compile the file.
 
\emph{I do not understand how the optimizer is run here. Maybe some
clarifying words by the designer are in order. -- CL} 

There is some inconsistency how we deal with files. The [[Driver.parse]]
function takes a file name, while an assembler expects a file
descriptor.
<<Lua Boot Script>>=
Compile = Compile and error('Compile not empty') or {}


function Compile.run_optimizer(self,proc)
    local B = self.B or Backplane
--verbose('running Compile.run_optimizer with ', whichB(B), '\n')

    if B == NewBackplane then -- demo for a bug in the backplane
       B.run(B.seq {Stages.assert('fish'),
                    B.stage {fn=Stages.nullf, uses='fish'}}, proc)
    end

    B.run(self.action, proc)
end    

function Compile.file(backend, file, out)
    local fd  = (not out or out == "-") and Driver.stdout or open_out(out)
    local ast = Driver.parse(file) 
    local asm = backend.asm(fd)
    local env = Driver.check(ast,asm) -- asm is stored in env
    local opt = { apply  = Compile.run_optimizer
                , action = Opt.standard(backend, asm) 
                }
    Driver.compile(opt, ast, backend.target, env)
    if backend.emit then backend.emit(asm) end
    if fd ~= Driver.stdout then close_out(fd) end
end    

function Compile.new_file(backend, file, out)
    local fd  = (not out or out == "-") and Driver.stdout or open_out(out)
    local ast = Driver.parse(file) 
--verbose('about to call asm\n')
    local asm = backend.asm(fd)
--verbose('about to call Driver.new_check\n')
    local env = Driver.new_check(ast,asm) -- asm is stored in env
--verbose('about to call Opt.standard\n')
    local opt = { apply  = Compile.run_optimizer
                , action = Opt.standard(backend, asm, NewBackplane) 
                , B = NewBackplane
                }
    Driver.new_compile(opt, ast, backend.target, env)
    if backend.emit then backend.emit(asm) end
    if fd ~= Driver.stdout then close_out(fd) end -- close fd
end    
@

% ------------------------------------------------------------------ 
\subsection{Command Line Handling and Driver}
% ------------------------------------------------------------------ 

Command line parsing is implemented in Lua. The command line is passed
as an table to [[CMD.cmdline]] which records the results in the
[[Options]] table. From there it is read by [[CMD.run]] that decides
what to do and triggers the compilation of all the files on the command
line. What needs to be done for each file is decided by
[[CMD.dispatch]]. 

<<Lua Boot Script>>=
Options = Options and error('Options not empty') or {}

Options.to_obj   = nil      -- -c
Options.to_asm   = nil      -- -S
Options.verbose  = 0        -- -v
Options.output   = nil      -- -o
Options.help     = nil      -- -help
Options.man      = nil      -- -man
Options.version  = nil      -- -versions
Options.interact = nil      -- -i
Options.interp   = nil      -- -interp
-- debug options below
Options.pretty   = nil      -- -pp

Options.argc     = 0        -- number of files
Options.argv     = {}       -- argv[1], .. , argv[argc]

Options.tempdir  = getenv("TMP") or getenv("TEMP") or "/tmp"
@

The command line driver calls an external assembler [[as]], linker
[[ld]] and interpreter for linking interpreter files. They have their
own tables.

<<Lua Boot Script>>=
As = As and error ('As not empty') or {}

As.path    = "as"           -- binary 
As.options = ""             -- options passed to binary

Ld = Ld and error ('Ld not empty') or {}
Ld.path     = "ld"          -- binary
Ld.options  = ""            -- options

Interp = Interp and error('Interp not empty') or {}
Interp.hashbang = "#! /usr/bin/env qc-interp"
@

All logic for the command line is encapsulated in the [[CMD]] module.
\emph{We should define how to deal with errors and in particular whether
this code should return to {\ocaml}}.

<<Lua Boot Script>>=
CMD = CMD and error('CMD not empty') or {}
@

[[CMD.interact]] implements an read--eval loop that gives the user
interactive access to the interpreter. This is most useful for debugging
Lua code.

<<Lua Boot Script>>=
function CMD.interact ()
    local prompt = "\n-- "
    local stmt
    write ("-- This is Lua for QC--\n")
    write ("-- Call Inspect.globals() to dump name space")
    
    write(prompt)
    stmt = read()
    while stmt ~= nil do
        dostring(stmt)
        write(prompt)
        stmt = read()
    end           
end
@
Simple command-line options are implemented in the [[CMD]] module
directly. 
<<Lua Boot Script>>=
CMD.help = [[
qc-- [option | file] ...

qc-- processes options from left to right, and then all file name
arguments from left to right.

-c          Compile to object code, do not link. 
-S          Compile to assembly code, do not assemble or link.
-o output   Name the output file output.  If -o is not used,
            the output file defaults to "a.out".
-Ldir       Add dir to the library search path. 
-lname      Add library name to the list of libraries to be searched. 
-interp     Generate code for qc--interp(1).
-v          Print commands as they are executed. 
-version    Print version to stdout and stop with exit code 0.
-help       Summarize options to stdout and stop with exit code 0.
-man        Write manual page to stdout and stop with exit code 0.
var=value   Assign the variable var in qc--'s Lua interpreter the 
            new value. 

See also: qc--(1), qc--internals(1), http://www.cminusminus.org/.            
]]

-- The manual page is automatically included into the qc-- binary and 
-- available as Boot.manual from within Lua.

CMD.manpage = Boot.manual


-- Boot.version writes to a channel such that you cannot use the version
-- to control program behavior. 

function CMD.version ()
    write ("Quick C-- Version ")
    Boot.version(Driver.stdout) 
    write ("\n")
end    

function CMD.error (msg)
    write ("Error: " .. msg .. "\n")
end    
@

The [[CMD.cmdline]] function is the heart of the module. It takes a list
(represented as table) with all command line arguments and parses it.
The results are recorded in the global table [[Options]].

File arguments are accumulated in the variable [[Options.argv]], using
[[Options.argc]] as an index to the last argument. The files in [[argv]]
are compiled and linked in this order. Since linking is sensitive to
order, we have to treat options like [[-L]] and [[-l]] that affect
linking. 

We have to be careful when using tables as lists, as tables do not
guarantee any order when traversed using [[next()]]. Therefore we rely
on indices. All our tables are indexed by consecutive numbers $1 \dots
n$.
<<Lua Boot Script>>=
function CMD.cmdline (args)
    local O = Options
    
    local i = 1
    O.original_argc = 0
    while args[i] and type(args[i]) == "string" do
	O.original_argc = i
        local v = args[i]
        if     v == "-c"            then O.to_obj       = not nil 
        elseif v == "-S"            then O.to_asm       = not nil 
        elseif v == "-i"            then O.interact     = not nil
        elseif strsub(v,1,2)== "-L" then O.argc = O.argc+1; O.argv[O.argc] = v
        elseif strsub(v,1,2)== "-l" then O.argc = O.argc+1; O.argv[O.argc] = v
        elseif v == "-v"            then O.verbose = O.verbose + 1
        elseif v == "-vv"           then O.verbose = O.verbose + 2
        elseif v == "-version"      then O.version      = not nil
        elseif v == "-help"         then O.help         = not nil
        elseif v == "-man"          then O.man          = not nil
        elseif v == "-pp"           then O.pretty       = not nil
        elseif v == "-interp"       then 
            O.interp = not nil
            backend  = Backend.interp
        elseif strfind(v, "=") then dostring (v) 
        elseif v == "-o" then 
            i,v    = i+1, args[i+1]
            if not v then error("argument for option -o missing") end
            O.output = v 
        elseif v == "-e" then 
            O.exe  = not nil
            i, v   = i+1, args[i+1]
            if not v then error("argument for option -e missing") end
            dostring(v)
        elseif strsub(v, 1, 1) == "-" then 
            CMD.error("unknown option: "..v)
            CMD.usage()
            exit(2)
        else -- it is a file    
            O.argc         = O.argc + 1
            O.argv[O.argc] = v 
        end
        i = i+1
    end
end
@

[[CMD.run]] starts the real work. It inspects the [[Options]] table to
see what the user has requested and starts doing it. In a loop it passes
all file arguments to [[CMD.dispatch]] which decides what to do based on
the file's suffix and the options.

It turned out that compiling for bytecode and native code cannot be
uinfied gracefully. We therefore have distinct dispatch functions for
each case.

<<Lua Boot Script>>=
function CMD.run ()
    local O = Options
    
    if      O.help                     then write(CMD.help)   ; return 0
    elseif  O.man                      then write(CMD.manpage); return 0
    elseif  O.version                  then CMD.version() ; return 0
    elseif  O.interact                 then CMD.interact(); return 0
    elseif  O.original_argc == 0       then CMD.usage ()  ; return 0
    elseif  O.argc == 0                then                 return 0
    
    elseif  O.to_obj  and O.to_asm then 
        CMD.error("Options -c and -S exclude each other")
        return 1
    elseif  O.argc > 1 and O.to_asm and O.output then
        CMD.error("Cannot specify -o and -S with multiple compilations")
        return 1
    elseif  O.argc > 1 and O.to_obj and O.output then
        CMD.error("Cannot specify -o and -c with multiple compilations")
        return 1
    elseif  O.argc > 1 and O.pretty and O.output then
        CMD.error("Cannot specify -o and -pp with multiple compilations")
        return 1
    else
        local i = 1
        local obj
        local objs= {}
        objs.n = 0      -- save in OCaml implementation?

        if not CMD.dispatch then -- wizards can set CMD.dispatch
            if O.interp or backend == Backend.interp then
                CMD.dispatch = CMD.interp_dispatch
            else
                CMD.dispatch = CMD.compile_dispatch
            end    
        end
        while i <= O.argc do
            obj = CMD.dispatch(Options.argv[i],O.output)
            -- skip nil entries resulted from *.lua
            if obj then objs.n=objs.n+1; objs[objs.n] = obj end
            i = i+1
        end 
        if not O.to_asm and not O.to_obj and not O.pretty then
            if O.interp or backend == Backend.interp then
                CMD.qs2exe(objs, O.output)
            else
                CMD.obj2exe(objs, O.output)
            end    
        end
    end
    return 0
end    
@
[[CMD.dispatch]] decides what needs to be done with an individual file,
based on its file name suffix and returns the file name of the final
result. This is simple in principle and complicated in practice because
of the [[-o]] flag. Depending on the situation this flag affects the
file name of produced files. I strongly recommend that you test this
code thoroughly if you make changes.

The [[CMD.cmm2asm]] does what it names suggest: it takes the name of a
{\PAL} source file and compiles it to an assembly file. If the second
parameter [[out]] is not [[nil]] it specifies the file name of the
resulting file. Otherwise the [[cmm2asm]] is free to pick a name. This
applies to the other functions $x$[[2]]$y$ analogously.
<<Lua Boot Script>>=
function CMD.compile_dispatch(file,out)
    if Util.checksuffix (file, ".c--") or Util.checksuffix(file, ".cmm") then 
        if      Options.to_asm -- -S option
        then    return CMD.cmm2asm(file, out) 
        elseif  Options.pretty
        then    return CMD.cmm2pp(file, out)
        else    return CMD.cmm2obj(file, Options.to_obj and out)
        end
    elseif Util.checksuffix(file, ".s") then 
        if      Options.to_asm -- -S option
        then    return file    -- what do, if out ~= file?
        else    return CMD.asm2obj(file, Options.to_obj and out)
        end
    elseif Util.checksuffix(file, ".lua") then 
        return dofile(file)
    else -- catches -L* -l* *.o *.a *.so
        return file    
    end
    return nil
end

function CMD.interp_dispatch(file,out)
    if Util.checksuffix (file, ".c--") or Util.checksuffix(file, ".cmm") then 
        if      Options.pretty
        then    return CMD.cmm2pp(file, out)
        else    return CMD.cmm2qs(file, out)
        end
    elseif Util.checksuffix(file, ".qs") then
        return  file
    elseif Util.checksuffix(file, ".lua") then 
        return  dofile(file)
    else -- catches -L* -l* *.o *.a *.so
        CMD.error("don't know what to do with file "..file)
    end
    return nil
end
@

[[Util.chopsuffix]] strips a suffix from a file and and returns it. Unlike
the Unix \textit{basename}(1) it does not strip of the directory part of
the name.

As explained above, a function of name $x$[[2]]$y$ takes a file name of
type $x$, creates a file of type $y$, and returns its name. If the
[[out]] parameter is not nil, the name of the returned file must be the
the value of [[out]].

<<Lua Boot Script>>=
function CMD.cmm2pp(file,out)
    local base = Util.chopsuffix(file)
    local pp   = out or base .. ".pp"
    Debug.prettyprint(file,pp)
    return pp
end

function CMD.cmm2qs(file,out)
    local base = Util.chopsuffix(file)
    local qs   = out or base .. ".qs"
    Compile.file(backend, file, qs) 
    return qs
end

function CMD.cmm2obj(file,out)
    local base = Util.chopsuffix(file)
    local asm  = base .. ".s"
    Compile.file(backend, file, asm) 
    local obj  = CMD.asm2obj(asm,out)
    return obj
end    

function CMD.cmm2asm(file,out)
    local base = Util.chopsuffix(file)
    local asm  = out or base .. ".s"
    Compile.file(backend, file, asm)
    return asm
end    

function CMD.asm2obj(file,out)
    local obj = out or Util.chopsuffix(file) .. ".o"
    local cmd = format ("%s %s -o %s %s"
                       , As.path
                       , As.options
                       , obj
                       , file
                       )
    CMD.exec(cmd)
    return obj
    
end
@

Depending on the verbosity level, commands are silently executed (0),
shown before executions (1), only shown, but not executed (2).

<<Lua Boot Script>>=
function CMD.exec(cmd)
    if Options.verbose == 1 then write(format("executing: %s\n", cmd)) end
    if Options.verbose == 2 then 
        write(format("simulating: %s\n", cmd)) 
    else
        if not execute(cmd) then error(cmd) end
    end    
end
@

The linker takes a list of object files in a table [[objs]] and an
optional output file. 

<<Lua Boot Script>>=
function CMD.obj2exe(objs,out)
    local exe = out or "a.out"
    local cmd 
    cmd = format ("%s %s -o %s"
                 , Ld.path
                 , Ld.options
                 , exe
                 )
    local i = 1
    while i <= objs.n do
        if type(objs[i]) == "string" then
            cmd = cmd ..  " " .. objs[i]
        end    
        i = i + 1
    end
    CMD.exec(cmd)
    return exe
end    
@

Lua files are linked by concatenating them with one Lua statement
between any two files. The head of the file is a [[#!]] line taken from
[[Interp.hashbang]]; finally, the resulting file is marked as
executable.

<<Lua Boot Script>>=
function CMD.qs2exe(objs, out)    
    local exe = out or "a.out"
    local i = 1
    local s
    
    if writeto(exe) == nil then CMD.error ("cannot open file "..objs[i]) end
    write(Interp.hashbang .. "\n")
    while i <= objs.n do
        if type (objs[i]) == "string" then
            if readfrom(objs[i]) == nil then
                writeto() -- restore stdout
                CMD.error ("cannot open file "..objs[i]) 
            end
            
            s = read() -- copy file, line by line
            while s ~= nil do
                write(s)
                write("\n")
                s = read()
            end
            write("CMM.new_assembly_unit()\n")
            readfrom() -- close file, restore stdin
        end
        i = i+1
    end
    writeto() -- close input, restore stdout
    CMD.exec("chmod +x " .. exe)
    return exe
end    
@

