% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:

% ------------------------------------------------------------------ 
\section{The Lua Code}
% ------------------------------------------------------------------ 

The compiler is almost completely driven by a Lua script [[qc--.lua]]
that the built-in Lua interpreter executes at startup.  The script is
searched along a search path by an {\ocaml} function in module
\module{main.nw}. As a default, the script presented here is compiled
into the {\qcc} binary and executed unless the user has made special
arrangements.

<<qc--.lua>>=
$debug 1
-- 
-- This Lua code is generated from the following file that also includes
-- the documentation. Do not edit this file directly.
--
-- $Id$
--

<<list functions>>
<<Debugging Tools>>
<<Lua compiler configuration>> -- defined in luacompile.nw
<<Lua command-line driver>>

--
-- Global Variables
--

backend = nil   -- initialized by command-line driver

-- 
-- Everything starts from here
--

CMD.parse(Sys.argv)
CMD.whatfuns[CMD.what or "-compile"]()
CMD.remove_derived_files()
@ 
\subsection{Interface}



To keep the Lua name space clean, related functionality is grouped into
tables which are used like modules. By convention, the names of tables
are capitalized.

\begin{tabularx}{\linewidth}{|@{}lX@{}|}
\hline
[[CMD.parse]]& Parse the command line and set values in [[Options]].\\
[[CMD.run]]& Run code requested by command line.\\
[[CMD.what]]&
  String saying what the driver should do on this run (default is
  [[-compile]]).\\
[[CMD.whatfuns]]&
  Table of functions, indexed by string in [[CMD.what]].\\
[[CMD.derived]]&
  List of derived files.\\
[[CMD.qslist]]&
  List of [[.qs]] files to be linked if using the interpreter.\\
\hline
[[Options.stop]]&
  Set of extensions with which translation should stop.\\
[[Options.stop_count]]&
  Size of [[Options.stop]].\\
[[Options.stop_at]]&
  Add an item to [[Options.stop]]\\
[[Options.the_stop]]&
  Function returning the extension, if any, at which to stop translating.\\
[[Options.keep]]&
  Set of extensions that should be kept (as derived files) or nil to
  keep all.
  Any derived file with extension in [[Options.stop]] is also kept.\\
\hline
\end{tabularx}
It would probably be useful to have an [[optfuns]] as the counterpart
of [[whatfuns]], so that other compilers could add new options.
@
The most interesting flow is the ``compile'' flow, which does this as
governed by [[Options.stop]]:
\begin{verbatim}
            <source>
               |
             .c--
           /   |   \
         .s   .qs  .pp
          |
         .o
\end{verbatim}


% ------------------------------------------------------------------ 
\subsection{Command Line Handling and Driver}
% ------------------------------------------------------------------ 

Command-line parsing is implemented in Lua. The command line is passed
as a list to [[CMD.parse]], which records the results in the
[[Options]] table. From there it is read by [[CMD.run]] that decides
what to do and triggers the compilation of all the files on the command
line. 
For the compile and interpret paths, what needs to be done for each
file is decided by [[CMD.dispatch]]. 
<<Lua command-line driver>>=
Options = Options and error('Options not empty') or {}

Options.verbose    = 0        -- -v
Options.output     = nil      -- -o
Options.stop       = { }
Options.stop_count = 0
Options.keep       = { }
Options.argc       = 0        -- number of files
Options.argv       = {}       -- argv[1], .. , argv[argc]

Options.tempdir  = getenv("TMP") or getenv("TEMP") or "/tmp"

function Options.stop_at(ext) -- insert ext into stop set
  if Options.stop[ext] == nil then
    if Options.stop_count == 0 then
      Options.stop[ext] = 1
      Options.stop_count = Options.stop_count + 1
    else
      CMD.error('Cannot stop translating after both ' ..
                Options.the_stop() .. ' and ' .. ext)
    end
  end
end

function Options.the_stop()
  return next(Options.stop, nil)
end
@
The command-line driver calls an external assembler [[as]], linker
[[ld]] and interpreter for linking interpreter files. They have their
own tables.
<<Lua command-line driver>>=
As = As and error ('As not empty') or {}

As.path    = "as"           -- binary 
--As.options = "-a --gstabs"             -- options passed to binary
As.options = ""             -- options passed to binary
function As.cmd(out, in)
  return format('%s%s -o %s %s', As.path, As.options, out, in)
end
@  
<<Lua command-line driver>>=
Ld = Ld and error ('Ld not empty') or {}
Ld.path     = "cc"          -- binary
Ld.options  = ""            -- options
Ld.rtstart  = ""            -- initial run-time system
Ld.objects  = ""            -- object files from this compilation
Ld.libs     = ""            -- libraries and library options
Ld.rtend    = ""            -- trailing run-time system

function Ld.cmd(exe)
  return
    format ("%s%s -o %s%s%s%s%s",
            Ld.path , Ld.options , exe , Ld.rtstart, Ld.objects, Ld.libs, Ld.rtend)
end
@ 
<<Lua command-line driver>>=
Interp = Interp or {}
Interp.hashbang = "#! /usr/bin/env qc--interp"
@
All logic for the command line is encapsulated in the [[CMD]] module.
\emph{We should define how to deal with errors and in particular whether
this code should return to {\ocaml}}.
<<Lua command-line driver>>=
CMD = CMD and error('CMD not empty') or {}
CMD.what = nil -- set by CMD.parse
CMD.whatfuns = { }
CMD.derived = { }
@ 
<<Lua command-line driver>>=
function CMD.remove_derived_files()
  local i = 1
  while CMD.derived[i] do
    local d = CMD.derived[i]
    if Options.stop[Caml.Filename.extension(d)] or not Options.keep or
       Options.keep[Caml.Filename.extension(d)]
    then
       -- do nothing
    else
       CMD.exec('rm ' .. d)
    end
    i = i + 1
  end
end
@
The [[-i]]~option triggers a read--eval loop that gives the user
interactive access to the interpreter. This is most useful for debugging
Lua code.
<<Lua command-line driver>>=
function CMD.whatfuns["-i"] ()
    local prompt = "\n-- "
    local stmt
    write ("-- This is Lua for QC--\n")
    write ("-- Call Inspect.globals() to dump name space")
    
    write(prompt)
    stmt = read()
    while stmt ~= nil do
        dostring(stmt)
        write(prompt)
        stmt = read()
    end           
end
@
Simple command-line options are implemented in the [[CMD]] module
directly. 
<<Lua command-line driver>>=
function CMD.whatfuns["-help"]()
  write(CMD.help)
end
CMD.help = [[
qc-- [option | file] ...

qc-- processes options from left to right, and then all file name
arguments from left to right.

-c          Stop compiling after producing .o files
-S          Stop compiling after producing .s files
-keep .ext  Keep derived files whose names end in .ext
-keep all   Keep all derived files
-o output   Name the output file output.  If -o is not used,
            the output file defaults to "a.out".
-Ldir       Add dir to the library search path. 
-lname      Add library name to the list of libraries to be searched. 
-interp     Generate code for qc--interp(1).
-v          Print commands as they are executed. 
-version    Print version to stdout and stop with exit code 0.
-help       Summarize options to stdout and stop with exit code 0.
-man        Write manual page to stdout and stop with exit code 0.
var=value   Assign the variable var in qc--'s Lua interpreter the 
            new value. 

See also: qc--(1), qc--internals(1), http://www.cminusminus.org/.            
]]
<<Lua command-line driver>>=
-- The manual page is automatically included into the qc-- binary and 
-- available as Boot.manual from within Lua.

CMD.manpage = Boot.manual
function CMD.whatfuns["-man"]()
  write(CMD.manpage)
end
<<Lua command-line driver>>=
-- Boot.version writes to a channel such that you cannot use the version
-- to control program behavior. 

function CMD.whatfuns["-version"] ()
    write ("Quick C-- Version ")
    Boot.version(Driver.stdout) 
    write ("\n")
end    
@ 
Driver code should use [[CMD.error]] to indicate an error during
compilation or on the command line.  
The built-in Lua [[error]] should be reserved for an internal error
that should never happen.
<<Lua command-line driver>>=
function CMD.error (msg)
    write ("Error: " .. msg .. "\n")
    exit(2)
end    
@
The [[CMD.parse]] function is the heart of the module. It takes a list
(represented as table) with all command line arguments and parses it.
The results are recorded in the global table [[Options]].

Files to be compiled are accumulated in the variable [[Options.argv]], using
[[Options.argc]] as an index to the last argument. The files in [[argv]]
are compiled and linked in this order. Since linking is sensitive to
order, we have to treat options like [[-L]] and [[-l]] as files.
<<Lua command-line driver>>=
function CMD.parse (args)
  local O = Options
  
  local i = 1
  while args[i] and type(args[i]) == "string" do
    local v = args[i]
    if CMD.whatfuns[v] then
      if not CMD.what or CMD.what == v then
        CMD.what = v
      else
        CMD.error('options ' .. CMD.what .. ' and ' .. v ..
                  ' are mutually incompatible')
      end
    elseif v == "-c"       then O.stop_at(".o")
    elseif v == "-S"       then O.stop_at(".s") -- also does duty for .qs
    elseif v == "-v"       then O.verbose = O.verbose + 1
    elseif v == "-vv"      then O.verbose = O.verbose + 2
    elseif strfind(v, "=") then local _ = dostring(v) or exit(2)
    elseif v == "-o" then 
        i,v    = i+1, args[i+1] or CMD.error("argument for option -o missing") 
        O.output = v
    elseif v == "-e" then 
        i, v   = i+1, args[i+1] or CMD.error("argument for option -e missing")
        local _ = dostring(v) or exit(2)
    elseif v == "-keep" then 
        i, v   = i+1, args[i+1] or CMD.error("argument for option -keep missing")
        if v and v == 'all' then
          Options.keep = nil
        elseif strfind(v, '^%.') then
          Options.keep[v] = 1
        else
          CMD.error('in -keep x, x must be "all" or an extension, not ' .. v)
        end
    elseif strfind(v, '^-') and not strfind(v, '^-[lL]') then
        CMD.error("unknown option: ".. v, 1)
    else -- it is a file or is -L or -l and must be treated as a file
        O.argc         = O.argc + 1
        O.argv[O.argc] = v 
    end
    i = i+1
  end
  if O.output and O.stop_count > 0 and O.argc > 1 then
    CMD.error('You cannot translate multiple files with -o option and ' ..
              'also stop at ' .. Options.the_stop())    
  end
end
@
[[CMD.run]] starts the real work. It inspects the [[Options]] table to
see what the user has requested and starts doing it. In a loop it passes
all file arguments to [[CMD.dispatch]] which decides what to do based on
the file's suffix and the options.

It turned out that compiling for bytecode and native code cannot be
uinfied gracefully. We therefore have distinct dispatch functions for
each case.
<<Lua command-line driver>>=
function CMD.whatfuns["-interp"]()
  backend = backend or Backend.interp
  CMD.dispatch = CMD.dispatch or CMD.interp_dispatch
  if Options.argc == 0 then return CMD.whatfuns["-help"]() end
  CMD.dispatch_files()
  if Options.stop_count == 0 then CMD.qs2exe(CMD.qslist, Options.output) end
end

function CMD.whatfuns["-compile"]()
  backend = backend or Backend.x86
  CMD.dispatch = CMD.dispatch or CMD.compile_dispatch
  if Options.argc == 0 then return CMD.whatfuns["-help"]() end
  CMD.dispatch_files()
  if Options.stop_count == 0 then
    CMD.exec(Ld.cmd(Options.output or 'a.out'))
  elseif Options.verbose > 0 then
    write('Stopping at ', Options.the_stop() or ('??nothing?? with count ' .. Options.stop_count), '\n')
  end    
end

function CMD.dispatch_files()
  local O = Options
  local i = 1
  while i <= O.argc do
    CMD.dispatch(O.argv[i],O.output)
    i = i+1
  end
end
@ 
<<Lua command-line driver>>=
function CMD.whatfuns["-pp"]()
  local O = Options
  if O.argc > 1 and O.pretty and O.output then
    CMD.error("Cannot specify -o and -pp with multiple compilations")
  end
  CMD.dispatch = CMD.dispatch or CMD.pretty_dispatch
  CMD.dispatch_files()
end
@
[[CMD.dispatch]] decides what needs to be done with an individual file,
based on its file name suffix and returns the file name of the final
result. This is simple in principle and complicated in practice because
of the [[-o]] flag. Depending on the situation this flag affects the
file name of produced files. I strongly recommend that you test this
code thoroughly if you make changes.

The [[CMD.cmm2asm]] does what it names suggest: it takes the name of a
{\PAL} source file and compiles it to an assembly file. If the second
parameter [[out]] is not [[nil]] it specifies the file name of the
resulting file. Otherwise the [[cmm2asm]] is free to pick a name. This
applies to the other functions $x$[[2]]$y$ analogously.
<<Lua command-line driver>>=
CMD.compilertab = { }
function CMD.compilertab[".lua"](file, out) 
  local _ = dofile(file) or exit(2) -- fails on error
end
function CMD.compilertab[".c--"](file, out) 
  if not Options.stop[".c--"] then
    local asm = Caml.Filename.chop_extension(file) .. ".s"
    if Options.stop['.s'] and out then 
      asm = out
    else
      tinsert(CMD.derived, asm)
    end
    if Options.verbose > 0 then write('Compiling ', file, ' to ', asm, '\n') end
    backend.compile(backend, file, asm)
    CMD.compilertab[".s"](asm, out)
  end
end
CMD.compilertab[".cmm"] = CMD.compilertab[".c--"]

function CMD.compilertab[".s"](file, out) 
  if not Options.stop[".s"] then
    local obj = Caml.Filename.chop_extension(file) .. ".o"
    if Options.stop['.o'] and out then 
      obj = out
    else
      tinsert(CMD.derived, obj)
    end
    CMD.exec(As.cmd(obj, file))
    CMD.compilertab[".o"](obj, out)
  end
end
function CMD.compilertab[".o"](file, out) 
  if not Options.stop[".o"] then
    Ld.objects = Ld.objects .. " " .. file
  end
end

CMD.compilertab[".a"]  = CMD.compilertab[".o"]
CMD.compilertab[".so"] = CMD.compilertab[".o"]

function CMD.compile_dispatch(file,out)
    if strfind(file, '^-[lL]') then
       return CMD.compilertab[".o"](file, out) -- passed to linker as if a file
    elseif CMD.compilertab[Caml.Filename.extension(file)] then
       return CMD.compilertab[Caml.Filename.extension(file)](file, out)
    else
       error('qc-- compiler does not recognize extension of file ' .. file)
    end
end
<<Lua command-line driver>>=
CMD.interptab = { }
function CMD.interptab[".c--"](file, out) 
  if not Options.stop[".c--"] then
    local asm = Caml.Filename.chop_extension(file) .. ".qs"
    if Options.stop['.s'] and out then -- N.B. check stop-at .s not .qs
      asm = out
    else
      tinsert(CMD.derived, asm)
    end
    if Options.verbose > 0 then write('Compiling ', file, ' to ', asm, '\n') end
    backend.compile(backend, file, asm)
    CMD.interptab[".qs"](asm, out)
  end
end
CMD.interptab[".cmm"] = CMD.interptab[".c--"]
CMD.interptab[".lua"] = CMD.compilertab[".lua"]

function CMD.interptab[".qs"](file, out)
  tinsert(CMD.qslist, file)
end

function CMD.compilertab[".qs"](file, out)
  CMD.error('file ' .. file .. ' is for the Quick C-- interpreter, not native code')
end

function CMD.interptab[".s"](file, out)
  CMD.error('file ' .. file .. ' is for native code, not the Quick C-- interpreter')
end

function CMD.interp_dispatch(file,out)
  if CMD.interptab[Caml.Filename.extension(file)] then
     return CMD.interptab[Caml.Filename.extension(file)](file, out)
  else
     error('qc-- interpreter does not recognize extension of file ' .. file)
  end
end
@
[[Caml.Filename.chop_extension]] strips an extension from a file and
and returns it. Unlike 
the Unix \textit{basename}(1) it does not strip of the directory part of
the name.
[[Caml.Filename.extension]] is an add-on that computes the extension
(with dot).

As explained above, a function of name $x$[[2]]$y$ takes a file name of
type $x$, creates a file of type $y$, and returns its name. If the
[[out]] parameter is not nil, the name of the returned file must be the
the value of [[out]].
<<Lua command-line driver>>=
-- needs to be tidied up later
function CMD.pretty_dispatch(file,out)
    local base = Caml.Filename.chop_extension(file)
    local pp   = out or base .. ".pp"
    Debug.prettyprint(file,pp)
    return pp
end
@
Depending on the verbosity level, commands are silently executed (0),
shown before executions (1), only shown, but not executed (2).
<<Lua command-line driver>>=
function CMD.exec(cmd)
    if Options.verbose == 1 then write(format("executing: %s\n", cmd)) end
    if Options.verbose == 2 then 
        write(format("simulating: %s\n", cmd)) 
    else
        if not execute(cmd) then exit(1) end
    end    
end
@
Lua files are linked by concatenating them with one Lua statement
between any two files. The head of the file is a [[#!]] line taken from
[[Interp.hashbang]]; finally, the resulting file is marked as
executable.
<<Lua command-line driver>>=
function CMD.qs2exe(objs, out)    
    local exe = out or "a.out"
    if writeto(exe) == nil then CMD.error ("cannot open file " .. exe) end
    write(Interp.hashbang .. "\n")
    local i = 1
    while objs[i] do
        if type (objs[i]) == "string" then
            if readfrom(objs[i]) == nil then
                writeto() -- restore stdout
                CMD.error ("cannot open file "..objs[i]) 
            end
            
            local s = read() -- copy file, line by line
            while s ~= nil do
                write(s)
                write("\n")
                s = read()
            end
            write("CMM.new_assembly_unit()\n")
            readfrom() -- close file, restore stdin
        end
        i = i+1
    end
    writeto() -- close input, restore stdout
    CMD.exec("chmod +x " .. exe)
    return exe
end    
@

% ------------------------------------------------------------------ 
\subsection{Introspection}
% ------------------------------------------------------------------ 

To support the debugging of Lua code we provide at the very beginning of
the script functions that allow to inspect the interpreter. This way
they are available in the interpreter, even if later parts of the scrip
fail to load.

The module [[Inspect]] provides functions to dump the entire name space of
the interpreter to stdout.

[[Inspect.type]] returns the type of a table entry. It tries to be smart
about userdata.
<<Debugging Tools>>=
Inspect = Inspect and error('Inspect not empty') or {}

function Inspect.type (val)  -- identify the value
    if type(val) == "userdata" then
        local s = tostring(val)
        if strlen(s) < 20 then
            return "userdata " .. s
        else
            return "userdata"
        end
    else
        return type(val)
    end
end
@
[[Inspect.globals]] and [[Inspect.table]] dump the table of all global
variables and a regular table, respectively. Both functions recurse if
they find a table, which they pass to [[Inspect.table]].
<<Debugging Tools>>=
function Inspect.globals ()
    local key,val = nextvar(nil)
    while key do
        Inspect.value(key, val)
        key,val = nextvar(key)
    end
end    

function Inspect.value(key, val)
   if not val then val = key; key = nil end
   write(format ("%-40s%s\n",tostring(key or ""), Inspect.type(val)))
   if type(val) == "table" then Inspect.table (key or '?', val) end
end

function Inspect.table (tabname,table)    -- helper for Inspect.vars 
    local key,val = next(table,nil)
    while key do
        local valname = Inspect.valname(tabname, key)
        Inspect.value(valname, val)
        key,val = next(table,key)
    end
end

function Inspect.valname(tabname, key)
    if type(key) == "string" then
        return tabname .. "." .. key
    else
        return tabname .. "[" .. key .. "]"
    end
end
@
This script is stored as a string in [[Inspect["qc--.lua"]]]. For
convenience we provide an [[Inspect.script]] function that dumps it to
stdout.
<<Debugging Tools>>=
function Inspect.script () write(Boot["qc--.lua"]) end    
@

The [[Inspect.find]] searches trough all tables for a key [[x]] and
returns the path to first [[x]] it finds as a string, or [[nil]].

<<Debugging Tools>>=
function Inspect.find(x)
    local i, v, ii, vv
    -- search global tables for x
    i, v = nextvar(nil)
    while i do
        if type(v) == "table" then
            ii, vv = next(v, nil)
            while ii ~= nil do
                if vv == x then
                    return i .. "." .. ii
                else
                    ii, vv = next(v, ii)
                end
            end
        end
        i, v = nextvar(i)
    end
    -- search globals for x
    i, v = nextvar(nil)
    while i ~= nil do
        if v == x then
            return i
        else
            i, v = nextvar(i)
        end
    end
    return nil
end
@
Function [[tinsert]] inserts at the end of a list.
<<list functions>>=
function tinsert(l, x)
  local n = l.n
  if not n then
    local i = 1
    while l[i] do i = i + 1 end
    n = i - 1
  end
  l[n+1] = x
  l.n = n + 1
end
@
