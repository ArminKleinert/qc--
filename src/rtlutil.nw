
% vim: ts=8 sw=4 et

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{RTL Utilities}
% ------------------------------------------------------------------ 

This module provides functions to observe and transform {\rtl}s. 

Locations and non-boolean expressions have a \emph{width} that can be
observed.  It is a checked run-time error to pass a boolean expression
to [[exp]].

<<rtlutil.mli>>=
module Width: sig
    val loc:    Rtl.loc -> int
    val exp:    Rtl.exp -> int
end 
@

A \emph{register} is an {\rtl} location that is addressed by a known
(integer) value (c.f.~module \module{register}). Registers are of
special interest for liveness analysis where it is important to know,
the registers that read or written by an {\rtl}. We provide two methods
to observe an {\rtl}'s registers: [[fold]] scans an [[Rtl.rtl]] value
and reports any register in a read or write position to a function. This
does not require heap allocation and is therefore efficient.  The
slightly less efficient function [[sets]] reports registers in read and
write positions as sets.

\begin{quote}\it
    The [[fold]] function is related to registers and therefore its name
    should imply this. We need another fold over memory locations that
    reports aliasing informations.
\end{quote}

<<rtlutil.mli>>=
module ReadWrite: sig
    type 'a observer = Rtl.space -> index:Base.std_int -> Rtl.width -> 'a -> 'a
    val fold: read: 'a observer -> write: 'a observer -> Rtl.rtl -> 'a -> 'a
    val sets: Rtl.rtl -> (Register.Set.t * Register.Set.t)
end
@    

Register allocation requires to re-write an {\rtl} by substituting
registers inside. The translation of a procedure creates expressions
that contain [[Rtl.link]] values that later must be substituted for
compile-time constants. Substitutions for locations, registers. and
expressions are provided by the [[Subst]] sub-module:

<<rtlutil.mli>>=
module Subst: sig
    val loc:    (Rtl.loc    -> Rtl.loc)    -> Rtl.rtl -> Rtl.rtl
    val reg:    (Register.t -> Register.t) -> Rtl.rtl -> Rtl.rtl
    val exp:    (Rtl.exp    -> Rtl.exp)    -> Rtl.rtl -> Rtl.rtl
end
@

Register allocation may benefit from knowing whether an {\rtl} represents a
move instruction. [[singleAssignment]] returns a source and destination
register pair if the input {\rtl} consists of a single, unconditional
assignment with any number of unconditional kills. If the {\rtl} has a
different form, [[singleAssignment]] returns [[None]].

<<rtlutil.mli>>=
module RTLType: sig
    val singleAssignment:    Rtl.rtl -> (Register.t * Register.t) option
end
@


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlutil.ml>>=
module RP = Rtl.Private

module Width = struct
    <<Width>>
end

module ReadWrite = struct
    <<ReadWrite>>
end

module Subst = struct
    <<Subst>>
end    

module RTLType = struct
    <<RTLType>>
end
@


% ------------------------------------------------------------------ 
\subsubsection{Width of Locations and Expressions}
% ------------------------------------------------------------------ 

<<Width>>=   
let loc l = match (Rtl.Convert.loc l) with
    | RP.Cell(_,_,w,_,_) -> w
    | RP.Var(_,_,w)      -> w
    | RP.Slice(w, _, _)  -> w
@

A named {\rtl} operator has a type and semantics that is independent of
its implementation. We have to look it up for expressions that have an
application on the outermost level.

<<Width>>=
let exp e = match Rtl.Convert.exp e with
    | RP.Const(RP.Bool _)     -> assert false
    | RP.Const(RP.Bits (_,w)) -> w
    | RP.Const(RP.Link (_,w)) -> w
    | RP.Fetch(_,w)           -> w
    | RP.App (op,_)           -> 
        ( match snd (Rtlop.Types.mono (Rtl.Revert.opr op)) with
        | Types.Bits(n) -> n
        | Types.Bool    -> assert false 
        ) 
@

% ------------------------------------------------------------------ 
\subsubsection{Registers read and written by an RTL}
% ------------------------------------------------------------------ 

<<ReadWrite>>=
type 'a observer = Rtl.space -> index:Base.std_int -> Rtl.width -> 'a -> 'a

let fold (read:'a observer) (write:'a observer) = 
  let rec rtl (z:'a) (RP.Rtl gs)  = List.fold_left guarded z gs
      and guarded z (g, eff) = exp (effect z eff) g
      and effect z eff = match eff with
        | RP.Store (lhs, rhs, _) -> loc write (exp z rhs) lhs
        | RP.Kill lhs -> loc write z lhs
      and loc which z l = match l with
        | RP.Cell (space, _, w, RP.Const (RP.Bits (index, w')), _) ->
            (try which space (Bits.to_int (index, w')) w (z:'a)
             with Bits.Overflow -> z)
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and index z l = match l with
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and exp z e = match e with
        | RP.Const _ -> z
        | RP.Fetch (l, w) -> loc read z l
        | RP.App (_, es) -> List.fold_left exp z es
  in  fun r z -> rtl z (Rtl.Convert.rtl r)

let sets (rtl:Rtl.rtl) = 
    let reg space index width = (space,index,width) in
    let add_left  space index width (left,right) = 
        (Register.Set.add (reg space index width) left, right) in
    let add_right  space index width (left,right) = 
        (left, Register.Set.add (reg space index width) right) in
    let empty = (Register.Set.empty, Register.Set.empty) in
        fold add_left add_right rtl empty
@

% ------------------------------------------------------------------ 
\subsection{Substitutions inside RTLs}
% ------------------------------------------------------------------ 

<<Subst>>=
let loc map rtl = 
    let rec exp = function
        | RP.Fetch (l, width)    -> RP.Fetch(loc l, width)
        | RP.App(opr, exprs)     -> RP.App(opr, List.map exp exprs)
        | x                      -> x
    and loc l                    = Rtl.Convert.loc (map (Rtl.Revert.loc l)) 
    and effect = function
        | RP.Store (l,e,width)   -> RP.Store(loc l, exp e, width)
        | RP.Kill  (l)           -> RP.Kill (loc l)
    and guarded (e,eff)          = (exp e, effect eff)
    and subst (RP.Rtl rtl)       = RP.Rtl (List.map guarded rtl)
    in    
        Rtl.Revert.rtl (subst (Rtl.Convert.rtl rtl))
@

A register is a special kind of location. The [[reg]] function uses
[[loc]] to traverse an {\rtl}. The register transformation function
[[f]] is itself transformed into an location transformation function
[[aux]] that is passed to [[loc]].

<<Subst>>=
let reg (f:Register.t -> Register.t) rtl = 
    let rec auxExp sp width exp = match exp with
      | RP.Const (RP.Bits bits) ->      (* what happens here? -CL? *)
            let register            = (sp, Bits.to_int bits, width)  in
            let index_width         = Bits.width bits                in
            let (_,index',_)        = f register (* transform! *)    in
                RP.Const (RP.Bits (Bits.of_std_int index' index_width))
      | RP.Fetch(l, w) ->
                RP.Fetch(Rtl.Convert.loc (aux (Rtl.Revert.loc l)), w)
      | RP.App(opr, exps) ->
                RP.App(opr, List.map (auxExp sp width) exps)
      | x -> x  (* not a register *)
    
    and aux = fun loc -> 
        ( match Rtl.Convert.loc loc with
        | Rtl.Private.Cell ( sp
                           , agg
                           , width
                           , (RP.Const(RP.Bits bits) as exp)
                           , ass
                           ) ->
            ( try
                let register            = (sp, Bits.to_int bits, width)  in
                let index_width         = Bits.width bits                in
                let (sp',index',width') = f register (* transform! *)    in
                let loc' = Rtl.Private.Cell
                    ( sp'
                    , agg
                    , width'
                    , auxExp sp width exp
                    , ass
                    ) 
                in 
                    Rtl.Revert.loc loc'
              with Bits.Overflow -> loc (* not a register *)
            )
        | Rtl.Private.Cell (sp, agg, width, (RP.Fetch _ as exp), ass) ->
                Rtl.Revert.loc (Rtl.Private.Cell ( sp
                                                 , agg 
                                                 , width 
                                                 , auxExp sp width exp 
                                                 , ass))
        | Rtl.Private.Cell (sp, agg, width, (RP.App(opr, exps) as exp), ass) ->
                Rtl.Revert.loc (Rtl.Private.Cell ( sp
                                                 , agg 
                                                 , width 
                                                 , auxExp sp width exp 
                                                 , ass))
        | _                    -> loc   (* not a register *)
        )
    in
        loc aux rtl
@

<<Subst>>=
let exp map rtl =
    let rec exp' e                 = Rtl.Convert.exp (map (Rtl.Revert.exp e)) 
    and loc = function
        | RP.Cell (ap,agg,w,e,ass) -> RP.Cell(ap, agg, w, exp' e, ass)
        | RP.Slice (w,i,l)         -> RP.Slice(w,i,loc l)
        | x                        -> x
    and effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc l, exp' e, width)
        | RP.Kill  (l)             -> RP.Kill (loc l)
    and guarded (e,eff)            = (exp' e, effect eff)
    and subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)
    in    
        Rtl.Revert.rtl (subst (Rtl.Convert.rtl rtl))
@


<<RTLType>>=
let singleAssignment rtl =
    let rec firstAssignment rtls = match rtls with
    | [] -> (None, [])
    | (RP.Const(RP.Bool true), RP.Store(loc1, RP.Fetch(loc2, _), _))::rst ->
        (try (Some (Register.of_loc (Rtl.Revert.loc loc1),
                    Register.of_loc (Rtl.Revert.loc loc2)),
              rst)
        with Invalid_argument _ -> (None, []))
    | _::rst -> firstAssignment rst in
    let getFirstAssignment (RP.Rtl guardeds) = firstAssignment guardeds in

    let isKill rtl = match rtl with
    | (RP.Const(RP.Bool true), RP.Kill _) -> true
    | _ -> false in
    let rec allKills rtls = List.for_all isKill rtls in

    let (assign, rst) = getFirstAssignment (Rtl.Convert.rtl rtl) in
        match assign with
        | Some _ when allKills rst -> assign
        | _ -> None
@
