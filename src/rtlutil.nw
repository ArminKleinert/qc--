
% vim: ts=8 sw=4 et

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{RTL Utilities}
% ------------------------------------------------------------------ 

This module provides functions to observe and transform {\rtl}s. 

% ------------------------------------------------------------------ 
\subsection{Width}
% ------------------------------------------------------------------ 

Locations and non-boolean expressions have a \emph{width} that can be
observed.  It is a checked run-time error to pass a boolean expression
to [[exp]].

<<rtlutil.mli>>=
module Width: sig
    val loc:    Rtl.loc -> int
    val exp:    Rtl.exp -> int
end 
@

% ------------------------------------------------------------------ 
\subsection{Read-Write Sets}
% ------------------------------------------------------------------ 


A \emph{register} is an {\rtl} location that is addressed by a known
(integer) value (c.f.~module \module{register}). Registers are of
special interest for liveness analysis where it is important to know,
the registers that read or written by an {\rtl}. We provide two methods
to observe an {\rtl}'s registers: [[fold]] scans an [[Rtl.rtl]] value
and reports any register in a read or write position to a function. This
does not require heap allocation and is therefore efficient.  The
slightly less efficient function [[sets]] reports registers in read and
write positions as sets.

\begin{quote}\it
    The [[fold]] function is related to registers and therefore its name
    should imply this. We need another fold over memory locations that
    reports aliasing informations.
\end{quote}

<<rtlutil.mli>>=
module ReadWrite: sig
    type 'a observer = Rtl.space -> Base.std_int -> Rtl.width -> 'a -> 'a
    val fold: read: 'a observer -> write: 'a observer -> Rtl.rtl -> 'a -> 'a
    val sets: Rtl.rtl -> (Register.Set.t * Register.Set.t)
end
@    

% ------------------------------------------------------------------ 
\subsection{Substitution}
% ------------------------------------------------------------------ 

Register allocation requires to re-write an {\rtl} by substituting
registers inside. The translation of a procedure creates expressions
that contain [[Rtl.link]] values that later must be substituted for
compile-time constants. Substitutions for locations, registers. and
expressions are provided by the [[Subst]] sub-module:

<<rtlutil.mli>>=
module Subst: sig       (* DEPRECATED *)
    val loc:    (Rtl.loc    -> Rtl.loc)    -> Rtl.rtl -> Rtl.rtl
    val reg:    (Register.t -> Register.t) -> Rtl.rtl -> Rtl.rtl
    val exp:    (Rtl.exp    -> Rtl.exp)    -> Rtl.rtl -> Rtl.rtl
end
@

The substitution module [[Subst2]] is a replacement for [[Subst]] and
is hopefully easier to use. 

<<rtlutil.mli>>=
module Subst2: sig
    val loc:    guard:(Rtl.Private.loc -> bool)               
                -> map:(Rtl.Private.loc -> Rtl.Private.loc) 
                -> Rtl.rtl -> Rtl.rtl
    
    val exp:    guard:(Rtl.Private.exp -> bool)
                -> map:(Rtl.Private.exp -> Rtl.Private.exp) 
                -> Rtl.rtl -> Rtl.rtl
    
    val reg:    lookup:(Rtl.space -> Space.t) 
                -> map:(Register.t -> Register.t)
                -> Rtl.rtl -> Rtl.rtl
end
@

Function [[loc]] substitutes locations in an {\rtl}. We pass each
location that passes the [[guard]] predicate to [[map]] to obtain the
new location. The location returned by [[map]] is taken literally and
not further traversed by [[loc]]. If a location fails to pass the
[[guard]] it is recursively traversed to substitute locations within.


Function [[exp]] works like [[loc]], except that it substitutes
expressions.


Function [[reg]] substitutes registers in an {\rtl}. It takes a
[[lookup]] function for [[Rtl.spaces]] and a [[map]] function that
describes the substitution. 

% ------------------------------------------------------------------ 
\subsection{Classification}
% ------------------------------------------------------------------ 

Register allocation may benefit from knowing whether an {\rtl} represents a
move instruction. [[singleAssignment]] returns a source and destination
register pair if the input {\rtl} consists of a single, unconditional
assignment with any number of unconditional kills. If the {\rtl} has a
different form, [[singleAssignment]] returns [[None]].

<<rtlutil.mli>>=
module RTLType: sig
    val singleAssignment:    Rtl.rtl -> (Register.t * Register.t) option
end
@

% ------------------------------------------------------------------ 
\subsection{RTL AST Representation}
% ------------------------------------------------------------------ 

For debugging we like to make the intermediate code visible by
translating it back to {\PAL} syntax.  Technically this means, that
{\rtl}s are translated to the {\PAL} abstract syntax ({\AST}); for the
{\AST} a pretty printer (in module \module{ast}) translates it back to
{\small ASCII} codes. This module provides a translation from an {\rtl}
to a {\PAL} statement.

<<rtlutil.mli>>=
module ToAST: sig
    type verbosity =    Low | High             (* default is High   *)
    val verbosity:      verbosity -> verbosity (* returns old value *)

    val expr:           Rtl.exp  -> Ast.expr 
    val rtl:            Rtl.rtl  -> Ast.stmt 
end
@


% ------------------------------------------------------------------ 
\subsection{RTL String Representation}
% ------------------------------------------------------------------ 

For debugging, we want to represent {\rtl}s as strings. The string
representation is meant to be human-, but not necessarily
machine-readable. 

<<rtlutil.mli>>=
module ToString: sig
    val rtl: Rtl.rtl -> string
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlutil.ml>>=
module RP = Rtl.Private

module Width = struct
    <<Width>>
end

module ReadWrite = struct
    <<ReadWrite>>
end

module Subst = struct
    <<Subst>>
end    

module Subst2 = struct
    <<Subst2>>
end

module ToAST = struct
    <<ToAST>>
end

module ToString = struct
    <<ToString>>
end
@

Register allocation may benefit from knowing whether an {\rtl} represents a
move instruction. [[singleAssignment]] returns a source and destination
register pair if the input {\rtl} consists of a single, unconditional
assignment with any number of unconditional kills. If the {\rtl} has a
different form, [[singleAssignment]] returns [[None]].

<<rtlutil.ml>>=
module RTLType = struct
    <<RTLType>>
end
@

% ------------------------------------------------------------------ 
\subsubsection{Width of Locations and Expressions}
% ------------------------------------------------------------------ 

<<Width>>=   
let loc l = match (Rtl.Convert.loc l) with
    | RP.Cell(_,_,w,_,_) -> w
    | RP.Var(_,_,w)      -> w
    | RP.Slice(w, _, _)  -> w
@

A named {\rtl} operator has a type and semantics that is independent of
its implementation. We have to look it up for expressions that have an
application on the outermost level.

<<Width>>=
let exp e = match Rtl.Convert.exp e with
    | RP.Const(RP.Bool _)     -> assert false
    | RP.Const(RP.Bits (_,w)) -> w
    | RP.Const(RP.Link (_,w)) -> w
    | RP.Const(RP.Late (_,w)) -> w
    | RP.Fetch(_,w)           -> w
    | RP.App (op,_)           -> 
        ( match snd (Rtlop.Types.mono (Rtl.Revert.opr op)) with
        | Types.Bits(n) -> n
        | Types.Bool    -> assert false 
        ) 
@

% ------------------------------------------------------------------ 
\subsubsection{Registers read and written by an RTL}
% ------------------------------------------------------------------ 

<<ReadWrite>>=
type 'a observer = Rtl.space -> (*index*) Base.std_int -> Rtl.width -> 'a -> 'a

let fold ~(read:'a observer) ~(write:'a observer) = 
  let rec rtl (z:'a) (RP.Rtl gs)  = List.fold_left guarded z gs
      and guarded z (g, eff) = exp (effect z eff) g
      and effect z eff = match eff with
        | RP.Store (lhs, rhs, _) -> loc write (exp z rhs) lhs
        | RP.Kill lhs -> loc write z lhs
      and loc which z l = match l with
        | RP.Cell (space, _, w, RP.Const (RP.Bits (index, w')), _) ->
            (try which space (Bits.to_int (index, w')) w (z:'a)
             with Bits.Overflow -> z)
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and index z l = match l with
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and exp z e = match e with
        | RP.Const _ -> z
        | RP.Fetch (l, w) -> loc read z l
        | RP.App (_, es) -> List.fold_left exp z es
  in  fun r z -> rtl z (Rtl.Convert.rtl r)

let sets (rtl:Rtl.rtl) = 
    let reg space index width = (space,index,width) in
    let add_left  space index width (left,right) = 
        (Register.Set.add (reg space index width) left, right) in
    let add_right  space index width (left,right) = 
        (left, Register.Set.add (reg space index width) right) in
    let empty = (Register.Set.empty, Register.Set.empty) in
        fold ~read:add_left ~write:add_right rtl empty
@

% ------------------------------------------------------------------ 
\subsection{Substitutions inside RTLs}
% ------------------------------------------------------------------ 

<<Subst>>=
let loc map rtl = 
    let rec exp = function
        | RP.Fetch (l, width)    -> RP.Fetch(loc l, width)
        | RP.App(opr, exprs)     -> RP.App(opr, List.map exp exprs)
        | x                      -> x
    and loc l                    = Rtl.Convert.loc (map (Rtl.Revert.loc l)) 
    and effect = function
        | RP.Store (l,e,width)   -> RP.Store(loc l, exp e, width)
        | RP.Kill  (l)           -> RP.Kill (loc l)
    and guarded (e,eff)          = (exp e, effect eff)
    and subst (RP.Rtl rtl)       = RP.Rtl (List.map guarded rtl)
    in    
        Rtl.Revert.rtl (subst (Rtl.Convert.rtl rtl))
@

A register is a special kind of location. The [[reg]] function uses
[[loc]] to traverse an {\rtl}. The register transformation function
[[f]] is itself transformed into an location transformation function
[[aux]] that is passed to [[loc]].

<<Subst>>=
let reg (f:Register.t -> Register.t) rtl = 
    let rec auxExp sp width exp = match exp with
      | RP.Const (RP.Bits bits) ->      (* what happens here? -CL? *)
            let register            = (sp, Bits.to_int bits, width)  in
            let index_width         = Bits.width bits                in
            let (_,index',_)        = f register (* transform! *)    in
                RP.Const (RP.Bits (Bits.of_std_int index' index_width))
      | RP.Fetch(l, w) ->
                RP.Fetch(Rtl.Convert.loc (aux (Rtl.Revert.loc l)), w)
      | RP.App(opr, exps) ->
                RP.App(opr, List.map (auxExp sp width) exps)
      | x -> x  (* not a register *)
    
    and aux = fun loc -> 
        ( match Rtl.Convert.loc loc with
        | Rtl.Private.Cell ( sp
                           , agg
                           , width
                           , (RP.Const(RP.Bits bits) as exp)
                           , ass
                           ) ->
            ( try
                let register            = (sp, Bits.to_int bits, width)  in
                let index_width         = Bits.width bits                in
                let (sp',index',width') = f register (* transform! *)    in
                let loc' = Rtl.Private.Cell
                    ( sp'
                    , agg
                    , width'
                    , auxExp sp width exp
                    , ass
                    ) 
                in 
                    Rtl.Revert.loc loc'
              with Bits.Overflow -> loc (* not a register *)
            )
        | Rtl.Private.Cell (sp, agg, width, (RP.Fetch _ as exp), ass) ->
                Rtl.Revert.loc (Rtl.Private.Cell ( sp
                                                 , agg 
                                                 , width 
                                                 , auxExp sp width exp 
                                                 , ass))
        | Rtl.Private.Cell (sp, agg, width, (RP.App(opr, exps) as exp), ass) ->
                Rtl.Revert.loc (Rtl.Private.Cell ( sp
                                                 , agg 
                                                 , width 
                                                 , auxExp sp width exp 
                                                 , ass))
        | _                    -> loc   (* not a register *)
        )
    in
        loc aux rtl
@

<<Subst>>=
let exp map rtl =
    let rec exp' e                 = Rtl.Convert.exp (map (Rtl.Revert.exp e)) 
    and loc = function
        | RP.Cell (ap,agg,w,e,ass) -> RP.Cell(ap, agg, w, exp' e, ass)
        | RP.Slice (w,i,l)         -> RP.Slice(w,i,loc l)
        | x                        -> x
    and effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc l, exp' e, width)
        | RP.Kill  (l)             -> RP.Kill (loc l)
    and guarded (e,eff)            = (exp' e, effect eff)
    and subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)
    in    
        Rtl.Revert.rtl (subst (Rtl.Convert.rtl rtl))
@


<<RTLType>>=
let singleAssignment rtl =
    let rec firstAssignment rtls = match rtls with
    | [] -> (None, [])
    | (RP.Const(RP.Bool true), RP.Store(loc1, RP.Fetch(loc2, _), _))::rst ->
        (try (Some (Register.of_loc (Rtl.Revert.loc loc1),
                    Register.of_loc (Rtl.Revert.loc loc2)),
              rst)
        with Invalid_argument _ -> (None, []))
    | _::rst -> firstAssignment rst in
    let getFirstAssignment (RP.Rtl guardeds) = firstAssignment guardeds in

    let isKill rtl = match rtl with
    | (RP.Const(RP.Bool true), RP.Kill _) -> true
    | _ -> false in
    let rec allKills rtls = List.for_all isKill rtls in

    let (assign, rst) = getFirstAssignment (Rtl.Convert.rtl rtl) in
        match assign with
        | Some _ when allKills rst -> assign
        | _ -> None
@

% ------------------------------------------------------------------ 
\subsection{Substitutions inside RTLs (Second Try)}
% ------------------------------------------------------------------ 

The [[DownUp]] module allows to apply functions that work on the private
representation of {\rtl}s to their abstract public representation.

<<Subst2>>=
module DownUp = struct
    let rtl f r = Rtl.Revert.rtl (f (Rtl.Convert.rtl r))
    let loc f l = Rtl.Revert.loc (f (Rtl.Convert.loc l))
    let exp f e = Rtl.Revert.exp (f (Rtl.Convert.exp e))
end

let loc' guard map rtl = 
    let rec exp = function
        | RP.Fetch (l, width)      -> RP.Fetch(loc l, width)
        | RP.App(opr, exprs)       -> RP.App(opr, List.map exp exprs)
        | x                        -> x
    and loc l = if guard l then map l else match l with
        | RP.Cell (ap,agg,w,e,ass) -> RP.Cell(ap, agg, w, exp e, ass)
        | RP.Slice (w,i,l)         -> RP.Slice(w,i,loc l)
        | x                        -> x
    and effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc l, exp e, width)
        | RP.Kill  (l)             -> RP.Kill (loc l)
    and guarded (e,eff)            = (exp e, effect eff)
    and subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)
    in    
        subst rtl

let exp' guard map rtl =
    let rec exp e = if guard e then map e else match e with
        | RP.Fetch (l, width)      -> RP.Fetch(loc l, width)
        | RP.App(opr, exprs)       -> RP.App(opr, List.map exp exprs)
        | x                        -> x
    and loc = function
        | RP.Cell (ap,agg,w,e,ass) -> RP.Cell(ap, agg, w, exp e, ass)
        | RP.Slice (w,i,l)         -> RP.Slice(w,i,loc l)
        | x                        -> x
    and effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc l, exp e, width)
        | RP.Kill  (l)             -> RP.Kill (loc l)
    and guarded (e,eff)            = (exp e, effect eff)
    and subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)
    in  
        subst rtl
@

A location is a register if its has a constant index that fits into an
integer.

<<Subst2>>=
let is_register = function
    | RP.Cell (_,_,_,RP.Const(RP.Bits b),_) ->
        ( try  let _ = Bits.to_int b in true with 
        | Bits.Overflow -> false
        )
    | _                 -> false
@

A location can be represented as a register, by taking its space, index,
and width.

<<Subst2>>=
let loc2reg = function
    | RP.Cell (sp,_,w,RP.Const(RP.Bits b),_) -> (sp,Bits.to_int b,w)
    | _                                      -> assert false
@

To transform a register into a location we need informations about the
space the register belongs to. In particular, the width of the index
expression is a space property.

<<Subst2>>=
let reg2loc lookup (sp,index,w) =
    let space      = lookup sp in
    let ()         = () (* assert (w = space.Space.cellwidth) *) in 
    let indexwidth = space.Space.indexwidth in 
        RP.Cell ( sp
                , space.Space.aggregation
                , w
                , RP.Const(RP.Bits(Bits.of_int index indexwidth))
                , 1 (* not provided by Space *)
                )

let reg' lookup map rtl = 
    let map' = fun loc -> reg2loc lookup (map (loc2reg loc)) in
        loc' is_register map' rtl

let exp ~guard  ~map rtl = DownUp.rtl (exp' guard  map) rtl
let loc ~guard  ~map rtl = DownUp.rtl (loc' guard  map) rtl 
let reg ~lookup ~map rtl = DownUp.rtl (reg' lookup map) rtl 
@


% ------------------------------------------------------------------ 
\subsection{RTL Classification}
% ------------------------------------------------------------------ 

<<RTLType>>=
let singleAssignment rtl =
    let rec firstAssignment rtls = match rtls with
    | [] -> (None, [])
    | (RP.Const(RP.Bool true), RP.Store(loc1, RP.Fetch(loc2, _), _))::rst ->
        (try (Some (Register.of_loc (Rtl.Revert.loc loc1),
                    Register.of_loc (Rtl.Revert.loc loc2)),
              rst)
        with Invalid_argument _ -> (None, []))
    | _::rst -> firstAssignment rst in
    let getFirstAssignment (RP.Rtl guardeds) = firstAssignment guardeds in

    let isKill rtl = match rtl with
    | (RP.Const(RP.Bool true), RP.Kill _) -> true
    | _ -> false in
    let rec allKills rtls = List.for_all isKill rtls in

    let (assign, rst) = getFirstAssignment (Rtl.Convert.rtl rtl) in
        match assign with
        | Some _ when allKills rst -> assign
        | _ -> None
@
% ------------------------------------------------------------------ 
\subsection{Conversion to AST}
% ------------------------------------------------------------------ 

<<ToAST>>=
module R = Rtl.Private
module A = Ast
module T = Types
@

<<ToAST>>=
type verbosity = Low | High  (* default is High --- more accurate *)
let the_verbosity = ref High
let verbosity v =
  let v' = !the_verbosity in
  the_verbosity := v;
  v'

<<ToAST>>=
let bits n             = A.BitsTy n

let const = function
    | R.Bool(_)      -> assert false    (* impossible *)
    | R.Bits(b,w)    ->  A.Int((b,w)
                              ,if !the_verbosity = High 
                               then Some (bits w) 
                               else None)
                     
    | R.Link(sym,w)  -> A.Fetch(A.Var(None, (sym#text)))
    | R.Late(name,w) -> A.Fetch(A.Var(None, name)) (*XXX ok? *)
@

<<ToAST>>=
let rec expr' = function
    | R.Const c         -> const c
    | R.Fetch(loc,_)    -> A.Fetch(location' loc)
    | R.App((op,ww),ee) -> let actual e = (None, expr' e) in
                           match ee with
                           | [l; r] when op = "add" || op = "sub" ->
                                  let op = if op = "add" then "+" else "-" in
                                  A.BinOp(expr' l, op, expr' r)
                           | _ -> A.PrimOp(op, List.map actual ee)
@

N.B. This code might possibly look up the location in a machine-dependent map
in case it needs to the name of a hardware register variable.

A translation of {\rtl} locations to {\PAL} is not semantic preserving
because {\PAL} has no notion of spaces. The translation here turns a
space into a (named) type, which is neither wrong nor right.

<<ToAST>>=
and location' = function 
    | R.Cell (sp,agg,width,e,ass) ->
     (* let space   =  Printf.sprintf "$%c" sp           in *)
        let space   =  Printf.sprintf "$%c(%d)" sp width in   
        let aligned = if ass = 1 then None else Some ass in 
        A.Mem(A.AliasTy space,expr' e,aligned)
    | R.Var (name,_,width)       -> A.Var(None,name)
    | R.Slice (w,i,loc)          -> A.Var(Some (string_of_int w), "slice")
                                    (*should convert as special reg name*)

let (@<<) f g  = fun x -> f (g x)
let expr       = expr'     @<< Rtl.Convert.exp
let location   = location' @<< Rtl.Convert.loc

@

A [[kill]] is translated into an assignment of [[%undef()]].

<<ToAST>>=
let rec effect guard = function
    | R.Kill   loc       -> 
        let width = Width.loc  (Rtl.Revert.loc loc)       in
        let undef = R.App(("undef",[width]),[]) in
            effect guard (R.Store(loc, undef, width))
    | R.Store  (loc,e,w) ->
            (location' loc,(guard, expr' e))

let guard = function
  | R.Const (R.Bool true) -> None
  | g -> Some (expr' g)  

let guarded (g, eff) = effect (guard g) eff

let rtl' (R.Rtl gg) = 
  match gg with
  | [] -> A.EmptyStmt
  | _ :: _ ->
    let pairs    = List.map (guarded ) gg in
    let lhs, rhs = List.split pairs             in
        A.AssignStmt(lhs,rhs)
let rtl = rtl' @<< Rtl.Convert.rtl
@



% ------------------------------------------------------------------ 
\subsection{Conversion to String}
% ------------------------------------------------------------------ 

We convert a given {\rtl} into {\PAL} abstract syntax and then
pretty-print it into a string. To avoid newlines in the string we pass
[[max_int]] as the line-width to the pretty-printer. 


<<ToString>>=
let rtl r =
    let stmt = ToAST.rtl r in
    let pp   = Astpp.stmt stmt              in
        Pp.ppToString max_int (* line width *) pp
@
