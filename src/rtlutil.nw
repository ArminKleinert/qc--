% -*- mode: Noweb; noweb-code-mode: caml-mode -*-


% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

\input{macros.tex}

% ----------------------------------------------------------------
\section{Utility functions on RTLs}
% ----------------------------------------------------------------

Code that builds or manipulates {\rtl}s tends to use the same
functionality over and over again. We try to define some useful values
here.

The [[width]] of an expression is only defined for value-expressions,
but not for conditions.  Applying [[width]] to a condition will result
in an assertion failure.  

<<rtlutil.mli>>=
val locwidth  : Rtl.loc -> Rtl.width
val locwidth' : Rtl.Private.loc -> Rtl.width (* always succeeds *)
@

For liveness analysis, we need to know what registers are read and
written.  We provide a suitable catamorphism (folding operator).  This
operator runs \emph{after} creation time, and it announces \emph{only}
locations that seem ``register-like,'' i.e., spaces indexed by
constants.  N.B.~it cannot distinguish fixed registers or references
to fixed locations in memory; it is up to the client to ignore these
as appropriate.  This operator does, however, ignore slices, since we
think they aren't of interest to any liveness analysis.  (This is
going to be wrong if we have to manage condition codes.)

The order registers are announced to [[read]] and [[write]] is
unspecified.  Beware of this when dealing with {\rtl}s that read and
write the same register!

<<rtlutil.mli>>=
type 'a regfun = Rtl.space -> index:Base.std_int -> Rtl.width -> 'a -> 'a
val read_write_lists : read:'a regfun -> write:'a regfun -> Rtl.rtl -> 'a -> 'a
(*
  let read_write_sets read write rtl z =
    let rws = read_write_lists insert_left insert_right in
    let (readlist, writelist) = rws rtl (empty, empty) in
    fold_left read (fold_left write z writelist) readlist
*)
@

Liveness analysis and register allocation deal with [[Rtl.loc]]
locations.  Sets and maps of locations are essential data structures.

<<rtlutil.mli>>=
module LocSet: Set.S with type elt = Rtl.loc
module LocMap: Map.S with type key = Rtl.loc
@

The [[subst map rtl]] function substitutes locations in [[rtl]].  The
[[map]] argument associates locations to be substituted and the
respective substitutes.  Locations not in the domain of [[map]] are
left untouched by the [[subst]].

<<rtlutil.mli>>=
val subst: Rtl.loc LocMap.t -> Rtl.rtl -> Rtl.rtl
@
    
The predicate [[uses locs rtl]] is true, if and only if [[rtl]]
contains any of the locations in the set [[locs]].

<<rtlutil.mli>>=
val uses : LocSet.t -> Rtl.rtl -> bool
@


<<obsolete and deprecated?>>=
val width:      Rtl.exp -> int                 (* width of expression *)
  (* often faults with assertion failure *)
val assign:     Rtl.loc -> Rtl.exp -> Rtl.rtl
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlutil.ml>>=
module RP = Rtl.Private
let locwidth' = function
    | RP.Cell(_,_,w,_,_) -> w
    | RP.Var(_,_,w)      -> w
    | RP.Slice(w, _, _)  -> w
let locwidth l = locwidth' (Rtl.Convert.loc l)

let width e = match Rtl.Convert.exp e with
    | RP.Const(RP.Bool _)     -> assert false
    | RP.Const(RP.Bits (_,w)) -> w
    | RP.Const(RP.Link (_,w)) -> w
    | RP.Fetch(_,w)           -> w
    | RP.App _                -> assert false (* not implemented *)
    
let assign l r = Rtl.store l r (width r)
@

<<rtlutil.ml>>=
type 'a regfun = Rtl.space -> index:Base.std_int -> Rtl.width -> 'a -> 'a
let read_write_lists (read:'a regfun) (write:'a regfun) = 
  let rec rtl (z:'a) (RP.Rtl gs)  = List.fold_left guarded z gs
      and guarded z (g, eff) = exp (effect z eff) g
      and effect z eff = match eff with
        | RP.Store (lhs, rhs, _) -> loc write (exp z rhs) lhs
        | RP.Kill lhs -> loc write z lhs
      and loc which z l = match l with
        | RP.Cell (space, _, w, RP.Const (RP.Bits (index, w')), _) ->
            (try which space (Bits.to_int (index, w')) w (z:'a)
             with Bits.Overflow -> z)
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and index z l = match l with
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and exp z e = match e with
        | RP.Const _ -> z
        | RP.Fetch (l, w) -> loc read z l
        | RP.App (_, es) -> List.fold_left exp z es
  in  fun r z -> rtl z (Rtl.Convert.rtl r)
@

Maps and sets of locations are easily defined using the [[Map]] and
[[Set]] functors.

<<rtlutil.ml>>=
module LocCompare = struct type t = Rtl.loc let compare = compare end
module LocMap     = Map.Make(LocCompare)
module LocSet     = Set.Make(LocCompare)
@

The [[subst map rtl]] function substitutes all locations in [[rtl]] that
have an entry in [[map]].

<<rtlutil.ml>>=
let rec subst_exp map = function
    | RP.Fetch (loc, width) -> RP.Fetch(subst_loc map loc, width)
    | RP.App(opr, exprs)    -> RP.App(opr, List.map (subst_exp map) exprs)
    | x                     -> x
    
and subst_loc map loc  =  
    try Rtl.Convert.loc (LocMap.find (Rtl.Revert.loc loc) map)
    with Not_found -> loc
    
and subst_effect map = function
    | RP.Store (loc,exp,width) -> 
        RP.Store(subst_loc map loc, subst_exp map exp, width)
    | RP.Kill  (loc) -> 
        RP.Kill (subst_loc map loc)
        
and subst_guarded map (exp,eff) =
    (subst_exp map exp, subst_effect map eff)

and subst' map (RP.Rtl rtl) = RP.Rtl (List.map (subst_guarded map) rtl)

let subst map rtl = Rtl.Revert.rtl (subst' map (Rtl.Convert.rtl rtl))
@    
    
The predicate [[uses locs rtl]] is true, if and only if [[rtl]]
contains any of the locations in the set [[locs]].

<<rtlutil.ml>>=
let rec uses_exp locs = function
    | RP.Fetch (loc, _    ) -> uses_loc locs loc
    | RP.App(opr, exprs)    -> List.exists (uses_exp locs) exprs
    | x                     -> false
    
and uses_effect locs = function
    | RP.Store (loc,exp,_ ) -> uses_loc locs loc || uses_exp locs exp
    | RP.Kill  (loc)        -> uses_loc locs loc 
        
and uses_loc locs loc           = LocSet.mem (Rtl.Revert.loc loc) locs
and uses_guarded locs (exp,eff) = uses_exp locs exp || uses_effect locs eff
and uses' locs (RP.Rtl rtl)     = List.exists (uses_guarded locs) rtl
let uses locs rtl               = uses' locs (Rtl.Convert.rtl rtl)
@
