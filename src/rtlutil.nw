% -*- mode: Noweb; noweb-code-mode: caml-mode -*-


% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

\input{macros.tex}

% ----------------------------------------------------------------
\section{Utility functions on RTLs}
% ----------------------------------------------------------------

Code that builds or manipulates {\rtl}s tends to use the same
functionality over and over again. We try to define some useful values
here.

The [[width]] of an expression is only defined for value-expressions,
but not for conditions.  Applying [[width]] to a condition will result
in an assertion failure.  

<<rtlutil.mli>>=
val locwidth  : Rtl.loc -> Rtl.width
val locwidth' : Rtl.Private.loc -> Rtl.width (* always succeeds *)
@

For liveness analysis, we need to know what registers are read and
written.  We provide a suitable catamorphism (folding operator).  This
operator runs \emph{after} creation time, and it announces \emph{only}
locations that seem ``register-like,'' i.e., spaces indexed by
constants.  N.B.~it cannot distinguish fixed registers or references
to fixed locations in memory; it is up to the client to ignore these
as appropriate.  This operator does, however, ignore slices, since we
think they aren't of interest to any liveness analysis.  (This is
going to be wrong if we have to manage condition codes.)

The order registers are announced to [[read]] and [[write]] is
unspecified.  Beware of this when dealing with {\rtl}s that read and
write the same register!

<<rtlutil.mli>>=
type 'a regfun = Rtl.space -> index:Base.std_int -> Rtl.width -> 'a -> 'a
val read_write_lists : read:'a regfun -> write:'a regfun -> Rtl.rtl -> 'a -> 'a
(*
  let read_write_sets read write rtl z =
    let rws = read_write_lists insert_left insert_right in
    let (readlist, writelist) = rws rtl (empty, empty) in
    fold_left read (fold_left write z writelist) readlist
*)
@

The [[read_write_lists]] function has the advantage that it does not
allocate memory while it traverses a {\rtl} to find registers.  Below
is a more convenient, but less efficient function that returns the
registers read and written by an {\rtl} as two sets.

<<rtlutil.mli>>=
val read_write_sets: Rtl.rtl -> Register.Set.t * Register.Set.t
@

Liveness analysis and register allocation deal with [[Rtl.loc]]
locations.  Sets and maps of locations are essential data structures.

<<rtlutil.mli>>=
module LocSet: Set.S with type elt = Rtl.loc
@

The [[loc f rtl]] function substitutes locations in [[rtl]].  Every
location used in [[rtl]] is presented to [[f]] which can substitute it
for a different one.

<<rtlutil.mli>>=
module Subst : sig
    val loc: (Rtl.loc    -> Rtl.loc)    -> Rtl.rtl -> Rtl.rtl
    val reg: (Register.t -> Register.t) -> Rtl.rtl -> Rtl.rtl
end
@
    
The predicate [[uses locs rtl]] is true, if and only if [[rtl]]
contains any of the locations in the set [[locs]].  \emph{This should
also go into a separate sub-module; do we need it at all?}. 

<<rtlutil.mli>>=
val uses : LocSet.t -> Rtl.rtl -> bool
@

The [[width]] of an expression in bits. It is a checked run-time
errror if the expression denotes a boolean value. 

\begin{quote}\it
    This function was \emph{obsolete and deprecated} but is required
    for the implementation of [[Area]] where the width of a pointer
    is deduced from an expression denoting an address. --CL
\end{quote}

<<rtlutil.mli>>=
val width:      Rtl.exp -> int  (* not implemented for applications *)
@

<<obsolete and deprecated?>>=
val assign:     Rtl.loc -> Rtl.exp -> Rtl.rtl
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlutil.ml>>=
module RP = Rtl.Private
let locwidth' = function
    | RP.Cell(_,_,w,_,_) -> w
    | RP.Var(_,_,w)      -> w
    | RP.Slice(w, _, _)  -> w
let locwidth l = locwidth' (Rtl.Convert.loc l)

let width e = match Rtl.Convert.exp e with
    | RP.Const(RP.Bool _)     -> assert false
    | RP.Const(RP.Bits (_,w)) -> w
    | RP.Const(RP.Link (_,w)) -> w
    | RP.Fetch(_,w)           -> w
    | RP.App _                -> assert false (* not implemented *)
    
let assign l r = Rtl.store l r (width r)
@

Maps and sets of locations are easily defined using the [[Map]] and
[[Set]] functors.

<<rtlutil.ml>>=
module LocCompare = struct type t = Rtl.loc let compare = compare end
module LocMap     = Map.Make(LocCompare)
module LocSet     = Set.Make(LocCompare)
@

<<rtlutil.ml>>=
type 'a regfun = Rtl.space -> index:Base.std_int -> Rtl.width -> 'a -> 'a
let read_write_lists (read:'a regfun) (write:'a regfun) = 
  let rec rtl (z:'a) (RP.Rtl gs)  = List.fold_left guarded z gs
      and guarded z (g, eff) = exp (effect z eff) g
      and effect z eff = match eff with
        | RP.Store (lhs, rhs, _) -> loc write (exp z rhs) lhs
        | RP.Kill lhs -> loc write z lhs
      and loc which z l = match l with
        | RP.Cell (space, _, w, RP.Const (RP.Bits (index, w')), _) ->
            (try which space (Bits.to_int (index, w')) w (z:'a)
             with Bits.Overflow -> z)
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and index z l = match l with
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and exp z e = match e with
        | RP.Const _ -> z
        | RP.Fetch (l, w) -> loc read z l
        | RP.App (_, es) -> List.fold_left exp z es
  in  fun r z -> rtl z (Rtl.Convert.rtl r)
@

The registers read and written by an {\rtl} are advertised by
[[RtlUtil.read_write_lists]].  It receives two functions that recieve
the read and written registers repectively.  Since the order in which
locations are passed to these functions is unspecified it is in
ingeneral impossible to use a single set that represents the set live
variables.  We therefore use the function [[rw_sets]] that returns a
pair $(r,w)$ of two sets.

<<rtlutil.ml>>=
let read_write_sets: Rtl.rtl -> (Register.Set.t * Register.Set.t) = fun rtl ->
    let reg space index width = (space,index,width) in
    let add_left  space index width (left,right) = 
        (Register.Set.add (reg space index width) left, right) in
    let add_right  space index width (left,right) = 
        (left, Register.Set.add (reg space index width) right) in
    let empty = (Register.Set.empty, Register.Set.empty) in
        read_write_lists add_left add_right rtl empty
@


The [[subst map rtl]] function substitutes all locations in [[rtl]] by
passing locations to the [[map]] function.

<<rtlutil.ml>>=
module Subst = struct
    <<module Subst struct>>
end
@

<<module Subst struct>>=
let loc map rtl = 
    let rec subst_exp map = function
        | RP.Fetch (loc, width) -> RP.Fetch(subst_loc map loc, width)
        | RP.App(opr, exprs)    -> RP.App(opr, List.map (subst_exp map) exprs)
        | x                     -> x
    and subst_loc map loc  = Rtl.Convert.loc (map (Rtl.Revert.loc loc)) 
    and subst_effect map = function
        | RP.Store (loc,exp,width) -> 
            RP.Store(subst_loc map loc, subst_exp map exp, width)
        | RP.Kill  (loc) -> 
            RP.Kill (subst_loc map loc)
    and subst_guarded map (exp,eff) =
        (subst_exp map exp, subst_effect map eff)
    and subst map (RP.Rtl rtl) = RP.Rtl (List.map (subst_guarded map) rtl)
    in    
        Rtl.Revert.rtl (subst map (Rtl.Convert.rtl rtl))
@    

The [[reg]] function substitutes registers in {\rtl}s and is
implemented in terms of the location substitution [[loc] above:  the
[[aux]] function has type

$$[[(Register.t -> Register.t) -> (Rtl.loc -> Rtl.loc )]]$$ 

and returns the function needed for [[loc]].  A register is the
special case of a [[Rtl.Cell]] location where the expression for the
address is a compile-time constant that fits into an [[integer]].  If
the [[aux]] function can identify such a location, it takes the
register part out of it, passes to the register-transforming function
[[f]] and inserts the resulting register back into a location.  In
short, the context provided by the location for the register is
maintained.

<<module Subst struct>>=
let aux f = fun loc -> 
    ( match Rtl.Convert.loc loc with
    | Rtl.Private.Cell 
        ( sp
        , agg
        , width
        , Rtl.Private.Const(Rtl.Private.Bits bits)
        , ass) ->
        ( try
            let register            = (sp, Bits.to_int bits, width)  in
            let index_width         = Bits.width bits                in
            let (sp',index',width') = f register                     in
            let loc' = Rtl.Private.Cell
                ( sp'
                , agg
                , width'
                , Rtl.Private.Const
                    (Rtl.Private.Bits (Bits.of_std_int index' index_width))
                , ass) 
            in 
                Rtl.Revert.loc loc'
          with Bits.Overflow -> loc
        )
    | otherwise            -> loc
    )

let reg f rtl = loc (aux f) rtl
@
    
The predicate [[uses locs rtl]] is true, if and only if [[rtl]]
contains any of the locations in the set [[locs]].

<<rtlutil.ml>>=
let rec uses_exp locs = function
    | RP.Fetch (loc, _    ) -> uses_loc locs loc
    | RP.App(opr, exprs)    -> List.exists (uses_exp locs) exprs
    | x                     -> false
    
and uses_effect locs = function
    | RP.Store (loc,exp,_ ) -> uses_loc locs loc || uses_exp locs exp
    | RP.Kill  (loc)        -> uses_loc locs loc 
        
and uses_loc locs loc           = LocSet.mem (Rtl.Revert.loc loc) locs
and uses_guarded locs (exp,eff) = uses_exp locs exp || uses_effect locs eff
and uses' locs (RP.Rtl rtl)     = List.exists (uses_guarded locs) rtl
let uses locs rtl               = uses' locs (Rtl.Convert.rtl rtl)
@
