
% vim: ts=8 sw=4 et
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Please add grades for this module below. The line must start with % "%%".
% %%Grades: B Central Soon

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{RTL Utilities}
% ------------------------------------------------------------------ 

This module provides functions to observe and transform {\rtl}s. 

% ------------------------------------------------------------------ 
\subsection{Width}
% ------------------------------------------------------------------ 

Locations and non-boolean expressions have a \emph{width} that can be
observed.  It is a checked run-time error to pass a boolean expression
to [[exp]].

<<rtlutil.mli>>=
module Width: sig
    val loc:    Rtl.loc -> int
    val exp:    Rtl.exp -> int
end 
@

% ------------------------------------------------------------------ 
\subsection{Evaluation Time Classification}
% ------------------------------------------------------------------ 

The form of an {\rtl} expression tells whether it is a compile-time
constant, link-time constant, or run-time expression.

<<rtlutil.mli>>=
module Time: sig
    val compile:    Rtl.exp -> bool (* true, iff compile-time const *)
    val link:       Rtl.exp -> bool (* true, off compile-time or link-time *)
end
@

% ------------------------------------------------------------------ 
\subsection{Read-Write Sets}
% ------------------------------------------------------------------ 


A \emph{register} is an {\rtl} location that is addressed by a known
(integer) value (c.f.~module \module{register}). Registers are of
special interest for liveness analysis where it is important to know,
the registers that read or written by an {\rtl}. We provide two methods
to observe an {\rtl}'s registers: [[fold]] scans an [[Rtl.rtl]] value
and reports any register in a read or write position to a function. This
does not require heap allocation and is therefore efficient.  The
slightly less efficient function [[sets]] reports registers in read and
write positions as sets.

\begin{quote}\it
    The [[fold]] function is related to registers and therefore its name
    should imply this. We need another fold over memory locations that
    reports aliasing informations.
\end{quote}

<<rtlutil.mli>>=
module ReadWrite: sig
    type 'a observer = Rtl.space -> Base.std_int -> Rtl.width -> 'a -> 'a
    val fold: read: 'a observer -> write: 'a observer -> Rtl.rtl -> 'a -> 'a
    val sets: Rtl.rtl -> (Register.Set.t * Register.Set.t)
end
@    

% ------------------------------------------------------------------ 
\subsection{Substitution}
% ------------------------------------------------------------------ 

Register allocation requires to re-write an {\rtl} by substituting
registers inside. The translation of a procedure creates expressions
that contain [[Rtl.link]] values that later must be substituted for
compile-time constants. Substitutions for locations, registers. and
expressions are provided by the [[Subst2]] sub-module:

<<rtlutil.mli>>=
module Subst2: sig
    val loc:    guard:(Rtl.Private.loc -> bool)               
                -> map:(Rtl.Private.loc -> Rtl.Private.loc) 
                -> Rtl.rtl -> Rtl.rtl
    
    val exp:    guard:(Rtl.Private.exp -> bool)
                -> map:(Rtl.Private.exp -> Rtl.Private.exp) 
                -> Rtl.rtl -> Rtl.rtl
    
    val reg:    lookup:(Rtl.space -> Space.t) 
                -> map:(Register.t -> Register.t)
                -> Rtl.rtl -> Rtl.rtl
end
@

Function [[loc]] substitutes locations in an {\rtl}. We pass each
location that passes the [[guard]] predicate to [[map]] to obtain the
new location. The location returned by [[map]] is taken literally and
not further traversed by [[loc]]. If a location fails to pass the
[[guard]] it is recursively traversed to substitute locations within.

Function [[exp]] works like [[loc]], except that it substitutes
expressions.

Function [[reg]] substitutes registers in an {\rtl}. It takes a
[[lookup]] function for [[Rtl.spaces]] and a [[map]] function that
describes the substitution. 

% ------------------------------------------------------------------ 
\subsection{Classification}
% ------------------------------------------------------------------ 

Register allocation may benefit from knowing whether an {\rtl} represents a
move instruction. [[singleAssignment]] returns a source and destination
register pair if the input {\rtl} consists of a single, unconditional
assignment with any number of unconditional kills. If the {\rtl} has a
different form, [[singleAssignment]] returns [[None]].

<<rtlutil.mli>>=
module RTLType: sig
    val singleAssignment:    Rtl.rtl -> (Register.t * Register.t) option
end
@

% ------------------------------------------------------------------ 
\subsection{RTL AST Representation}
% ------------------------------------------------------------------ 

For debugging we like to make the intermediate code visible by
translating it back to {\PAL} syntax.  Technically this means, that
{\rtl}s are translated to the {\PAL} abstract syntax ({\AST}); for the
{\AST} a pretty printer (in module \module{ast}) translates it back to
{\small ASCII} codes. This module provides a translation from an {\rtl}
to a {\PAL} statement.

<<rtlutil.mli>>=
module ToAST: sig
    type verbosity =    Low | High             (* default is High   *)
    val verbosity:      verbosity -> verbosity (* returns old value *)

    val expr:           Rtl.exp  -> Ast.expr 
    val rtl:            Rtl.rtl  -> Ast.stmt 
end
@


% ------------------------------------------------------------------ 
\subsection{RTL String Representation}
% ------------------------------------------------------------------ 

For debugging, we want to represent {\rtl}s as strings. The string
representation is meant to be human-, but not necessarily
machine-readable. 

<<rtlutil.mli>>=
module ToString: sig
    val rtl: Rtl.rtl -> string
    val exp: Rtl.exp -> string
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlutil.ml>>=
module RP = Rtl.Private
module U  = Rtl.Revert
module D  = Rtl.Convert

module Width = struct
    <<Width>>
end

module ReadWrite = struct
    <<ReadWrite>>
end

module Subst2 = struct
    <<Subst2>>
end

module ToAST = struct
    <<ToAST>>
end

module ToString = struct
    <<ToString>>
end

module Time = struct
    <<Time>>
end    
@

Register allocation may benefit from knowing whether an {\rtl} represents a
move instruction. [[singleAssignment]] returns a source and destination
register pair if the input {\rtl} consists of a single, unconditional
assignment with any number of unconditional kills. If the {\rtl} has a
different form, [[singleAssignment]] returns [[None]].

<<rtlutil.ml>>=
module RTLType = struct
    <<RTLType>>
end
@

% ------------------------------------------------------------------ 
\subsubsection{Width of Locations and Expressions}
% ------------------------------------------------------------------ 

<<Width>>=   
let loc l = match (Rtl.Convert.loc l) with
    | RP.Cell(_,_,w,_,_) -> w
    | RP.Var(_,_,w)      -> w
    | RP.Slice(w, _, _)  -> w
@

A named {\rtl} operator has a type and semantics that is independent of
its implementation. We have to look it up for expressions that have an
application on the outermost level.

<<Width>>=
let exp e = match Rtl.Convert.exp e with
    | RP.Const(RP.Bool _)     -> assert false
    | RP.Const(RP.Bits b)     -> Bits.width b
    | RP.Const(RP.Link (_,w)) -> w
    | RP.Const(RP.Late (_,w)) -> w
    | RP.Fetch(_,w)           -> w
    | RP.App (op,_)           -> 
        ( match snd (Rtlop.Types.mono (Rtl.Revert.opr op)) with
        | Types.Bits(n) -> n
        | Types.Bool    -> assert false 
        ) 
@

% ------------------------------------------------------------------ 
\subsubsection{Registers read and written by an RTL}
% ------------------------------------------------------------------ 

<<ReadWrite>>=
type 'a observer = Rtl.space -> (*index*) Base.std_int -> Rtl.width -> 'a -> 'a

let fold ~(read:'a observer) ~(write:'a observer) = 
  let rec rtl (z:'a) (RP.Rtl gs)  = List.fold_left guarded z gs
      and guarded z (g, eff) = exp (effect z eff) g
      and effect z eff = match eff with
        | RP.Store (lhs, rhs, _) -> loc write (exp z rhs) lhs
        | RP.Kill lhs -> loc write z lhs
      and loc which z l = match l with
        | RP.Cell (space, _, w, RP.Const (RP.Bits b), _) ->
            (try which space (Bits.U.to_int b) w (z:'a) with Bits.Overflow -> z)
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and index z l = match l with
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and exp z e = match e with
        | RP.Const _ -> z
        | RP.Fetch (l, w) -> loc read z l
        | RP.App (_, es) -> List.fold_left exp z es
  in  fun r z -> rtl z (Rtl.Convert.rtl r)

let sets (rtl:Rtl.rtl) = 
    let reg space index width = (space,index,width) in
    let add_left  space index width (left,right) = 
        (Register.Set.add (reg space index width) left, right) in
    let add_right  space index width (left,right) = 
        (left, Register.Set.add (reg space index width) right) in
    let empty = (Register.Set.empty, Register.Set.empty) in
        fold ~read:add_left ~write:add_right rtl empty
@

% ------------------------------------------------------------------ 
\subsection{Substitutions inside RTLs (Second Try)}
% ------------------------------------------------------------------ 

The [[DownUp]] module allows to apply functions that work on the private
representation of {\rtl}s to their abstract public representation.

<<Subst2>>=
module DownUp = struct
    let rtl f r = Rtl.Revert.rtl (f (Rtl.Convert.rtl r))
    let loc f l = Rtl.Revert.loc (f (Rtl.Convert.loc l))
    let exp f e = Rtl.Revert.exp (f (Rtl.Convert.exp e))
end

let loc' guard map rtl = 
    let rec exp = function
        | RP.Fetch (l, width)      -> RP.Fetch(loc l, width)
        | RP.App(opr, exprs)       -> RP.App(opr, List.map exp exprs)
        | x                        -> x
    and loc l = if guard l then map l else match l with
        | RP.Cell (ap,agg,w,e,ass) -> RP.Cell(ap, agg, w, exp e, ass)
        | RP.Slice (w,i,l)         -> RP.Slice(w,i,loc l)
        | x                        -> x
    and effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc l, exp e, width)
        | RP.Kill  (l)             -> RP.Kill (loc l)
    and guarded (e,eff)            = (exp e, effect eff)
    and subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)
    in    
        subst rtl

let exp' guard map rtl =
    let rec exp e = if guard e then map e else match e with
        | RP.Fetch (l, width)      -> RP.Fetch(loc l, width)
        | RP.App(opr, exprs)       -> RP.App(opr, List.map exp exprs)
        | x                        -> x
    and loc = function
        | RP.Cell (ap,agg,w,e,ass) -> RP.Cell(ap, agg, w, exp e, ass)
        | RP.Slice (w,i,l)         -> RP.Slice(w,i,loc l)
        | x                        -> x
    and effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc l, exp e, width)
        | RP.Kill  (l)             -> RP.Kill (loc l)
    and guarded (e,eff)            = (exp e, effect eff)
    and subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)
    in  
        subst rtl
@

A location is a register if its has a constant index that fits into an
integer.

<<Subst2>>=
let is_register = function
    | RP.Cell (_,_,_,RP.Const(RP.Bits b),_) ->
        ( try  let _ = Bits.U.to_int b in true with 
        | Bits.Overflow -> false
        )
    | _                 -> false
@

A location can be represented as a register, by taking its space, index,
and width.

<<Subst2>>=
let loc2reg = function
    | RP.Cell (sp,_,w,RP.Const(RP.Bits b),_) -> (sp,Bits.U.to_int b,w)
    | _                                      -> assert false
@

To transform a register into a location we need informations about the
space the register belongs to. In particular, the width of the index
expression is a space property.

<<Subst2>>=
let reg2loc lookup (sp,index,w) =
    let space      = try lookup sp with Not_found ->
        Impossible.impossible (Printf.sprintf "can't find space '%c'" sp) in
    let ()         = () (* assert (w = space.Space.cellwidth) *) in 
    let indexwidth = space.Space.indexwidth in 
        RP.Cell ( sp
                , space.Space.aggregation
                , w
                , RP.Const(RP.Bits(Bits.U.of_int index indexwidth))
                , 1 (* not provided by Space *)
                )

let reg' lookup map rtl = 
    let map' = fun loc -> reg2loc lookup (map (loc2reg loc)) in
        loc' is_register map' rtl

let exp ~guard  ~map rtl = DownUp.rtl (exp' guard  map) rtl
let loc ~guard  ~map rtl = DownUp.rtl (loc' guard  map) rtl 
let reg ~lookup ~map rtl = DownUp.rtl (reg' lookup map) rtl 
@


% ------------------------------------------------------------------ 
\subsection{RTL Classification}
% ------------------------------------------------------------------ 

<<RTLType>>=
let singleAssignment rtl =
    let rec firstAssignment rtls = match rtls with
    | [] -> (None, [])
    | (RP.Const(RP.Bool true), RP.Store(loc1, RP.Fetch(loc2, _), _))::rst ->
        (try (Some (Register.of_loc (Rtl.Revert.loc loc1),
                    Register.of_loc (Rtl.Revert.loc loc2)),
              rst)
        with Invalid_argument _ -> (None, []))
    | _::rst -> firstAssignment rst in
    let getFirstAssignment (RP.Rtl guardeds) = firstAssignment guardeds in

    let isKill rtl = match rtl with
    | (RP.Const(RP.Bool true), RP.Kill _) -> true
    | _ -> false in
    let rec allKills rtls = List.for_all isKill rtls in

    let (assign, rst) = getFirstAssignment (Rtl.Convert.rtl rtl) in
        match assign with
        | Some _ when allKills rst -> assign
        | _ -> None
@
% ------------------------------------------------------------------ 
\subsection{Conversion to AST}
% ------------------------------------------------------------------ 

<<ToAST>>=
module R = Rtl.Private
module A = Ast
module T = Types
@

<<ToAST>>=
type verbosity = Low | High  (* default is High --- more accurate *)
let the_verbosity = ref High
let verbosity v =
  let v' = !the_verbosity in
  the_verbosity := v;
  v'

<<ToAST>>=
let bits n             = A.BitsTy n

let const = function
    | R.Bool(true)   ->  A.PrimOp ("true", [])
    | R.Bool(false)  ->  A.PrimOp ("false", [])
    | R.Bits b       ->  A.Int( string_of_int (Bits.U.to_int b)
                              , if !the_verbosity = High 
                                then Some (bits (Bits.width b)) 
                                else None
                              )
                     
    | R.Link(sym,w)  -> A.Fetch(A.Var(None, (sym#text)))
    | R.Late(name,w) -> A.Fetch(A.Var(None, name)) (*XXX ok? *)
@



<<ToAST>>=
let opr op w =
    Printf.sprintf "%s[%s]" op (String.concat "," (List.map string_of_int w))

let rec expr' = function
    | R.Const c         -> const c
    | R.Fetch(loc,_)    -> A.Fetch(location' loc)
    | R.App((op,ww),ee) -> let actual e = (None, expr' e) in
                           match ee with
                           | [l; r] when op = "add" || op = "sub" ->
                                  let op = if op = "add" then "+" else "-" in
                                  A.BinOp(expr' l, op, expr' r)
                           | _ -> A.PrimOp(opr op ww, List.map actual ee)
@

N.B. This code might possibly look up the location in a machine-dependent map
in case it needs to the name of a hardware register variable.

A translation of {\rtl} locations to {\PAL} is not semantic preserving
because {\PAL} has no notion of spaces. The translation here turns a
space into a (named) type, which is neither wrong nor right.

<<ToAST>>=
and location' = function 
    | R.Cell (sp,agg,width,e,ass) ->
     (* let space   =  Printf.sprintf "$%c" sp           in *)
        let a       =  match agg with
                       | Rtl.Identity     -> 'I'
                       | Rtl.BigEndian    -> 'B'
                       | Rtl.LittleEndian -> 'L' in
        let space   =  Printf.sprintf "$%c(%d%c)" sp width a in   
        let aligned = if ass = 1 then None else Some ass in 
        A.Mem(A.AliasTy space,expr' e,aligned)
    | R.Var (name,_,width)       -> A.Var(None,name)
    | R.Slice (w,i,loc)          -> location' loc (*XXX*)
    

let (@<<) f g  = fun x -> f (g x)
let expr       = expr'     @<< Rtl.Convert.exp
let location   = location' @<< Rtl.Convert.loc

@

A [[kill]] is translated into an assignment of [[%undef()]].

<<ToAST>>=
let rec effect guard = function
    | R.Kill   loc       -> 
        let width = Width.loc  (Rtl.Revert.loc loc)       in
        let undef = R.App(("undef",[width]),[]) in
            effect guard (R.Store(loc, undef, width))
    | R.Store  (loc,e,w) ->
            (location' loc,(guard, expr' e))

let guard = function
  | R.Const (R.Bool true) -> None
  | g -> Some (expr' g)  

let guarded (g, eff) = effect (guard g) eff

let rtl' (R.Rtl gg) = 
  match gg with
  | [] -> A.EmptyStmt
  | _ :: _ ->
    let pairs    = List.map (guarded ) gg in
    let lhs, rhs = List.split pairs             in
        A.AssignStmt(lhs,rhs)
let rtl = rtl' @<< Rtl.Convert.rtl
@

% ------------------------------------------------------------------ 
\subsection{Evaluation Time Classification}
% ------------------------------------------------------------------ 

<<Time>>=
let compile e = match D.exp e with
    | RP.Const(RP.Bits _) -> true
    | RP.Const(RP.Bool _) -> true
    | RP.Const(RP.Late _) -> true
    | _                   -> false

let link e = match D.exp e with     
    | RP.Const(RP.Bits _) -> true
    | RP.Const(RP.Bool _) -> true
    | RP.Const(RP.Late _) -> true
    | RP.Const(RP.Link _) -> true       
    | RP.App(("add",_), [RP.Const(RP.Link _); RP.Const(RP.Bits _)])
        -> true
    | _                   -> false
@

% ------------------------------------------------------------------ 
\subsection{Conversion to String}
% ------------------------------------------------------------------ 

We convert a given {\rtl} into {\PAL} abstract syntax and then
pretty-print it into a string. To avoid newlines in the string we pass
[[max_int]] as the line-width to the pretty-printer. 


<<ToString>>=

module P  = Pp
module R  = Rtl
module RP = Rtl.Private 

let (^^)   = P.(^^)
let (^/)   = P.(^/)

let indent x = P.nest 4 (P.break ^^ x)
let int i    = P.text (string_of_int i)
let str s    = P.text s
let char c   = P.text (Printf.sprintf "'%c'" c)

let tuple docs = 
    let id x = x in
    P.agrp (P.text "(" ^^ P.list (P.text "," ^^ P.break) id docs ^^ P.text ")")
    
let apply c args = P.agrp(str c ^^ indent(tuple args))

let aggregation = function
    | R.BigEndian       -> P.text "BE"
    | R.LittleEndian    -> P.text "LE"
    | R.Identity        -> P.text "ID"

let opr (name, ws) =
    tuple [str name; tuple (List.map int ws)]

let const = function
    | RP.Bool(b)        -> apply "Bool"  [str (if b then "true" else "false")]
    | RP.Bits(b)        -> apply "Bits"  [ int (Bits.U.to_int b)
                                         ; int (Bits.width b)
                                         ]
    | RP.Link(r,w)      -> apply "Link"  [str r#text; int w]
    | RP.Late(s,w)      -> apply "Late"  [str s; int w]


let rec exp = function
    | RP.Const(k)       -> apply "Const" [const k]
    | RP.Fetch(l,w)     -> apply "Fetch" [loc l; int w]
    | RP.App(o,es)      -> apply "App"   [opr o; tuple (List.map exp es)] 
    
and loc = function
    | RP.Cell(sp, agg, w, e, ass) -> 
        apply "Cell" [char sp; aggregation agg; int w; exp e]
    | RP.Var(name, index, w) ->
        apply "Var" [str name; int index; int w]
    | RP.Slice(w, i, l) ->
        apply "Slice" [int w; int i; loc l]
        

let effect = function
    | RP.Store(l,e,w) -> apply "Store" [loc l; exp e; int w]
    | RP.Kill(l)      -> apply "Kill"  [loc l]  

let guarded (g, e) =
    tuple [exp g; effect e]

let rtl' (RP.Rtl x) =
    apply "Rtl" (List.map guarded x)
    
let rtl r =
    let pp = rtl' (R.Convert.rtl r) in
        Pp.ppToString 66 (* line width *) pp

let exp e =
    let pp = exp (R.Convert.exp e) in
        Pp.ppToString 66 (* line width *) pp
@

