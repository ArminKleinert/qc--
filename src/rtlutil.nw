% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% vim: ts=8 sw=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{RTL Utilities}
% ------------------------------------------------------------------ 

This module provides functions to observe and transform {\rtl}s. 

\subsection{Common operations on RTLs}
These functions reassociate constants.
It can be mildly useful to partially apply them to a width.
N.B. [[addk x 0 === x]] always.
<<rtlutil.mli>>=
val add  : Rtl.width -> Rtl.exp -> Rtl.exp -> Rtl.exp
val addk : Rtl.width -> Rtl.exp -> int     -> Rtl.exp
@ 
These functions use the width of the location.
Although we gain some convenience,
we lose some redundancy; use these functions only where the width is
not readily available.
<<rtlutil.mli>>=
val fetch : Rtl.loc -> Rtl.exp
val store : Rtl.loc -> Rtl.exp -> Rtl.rtl
@ 
% ------------------------------------------------------------------ 
\subsection{Width}
% ------------------------------------------------------------------ 

Locations and non-boolean expressions have a \emph{width} that can be
observed.  It is a checked run-time error to pass a boolean expression
to [[exp]].
<<rtlutil.mli>>=
module Width: sig
    val loc:    Rtl.loc -> int
    val exp:    Rtl.exp -> int
    val exp':   Rtl.Private.exp -> int
end 
@

% ------------------------------------------------------------------ 
\subsection{Evaluation Time Classification}
% ------------------------------------------------------------------ 

The form of an {\rtl} expression tells whether it is a compile-time
constant, link-time constant, or run-time expression.

<<rtlutil.mli>>=
module Time: sig
    val compile:    Rtl.exp -> bool (* true, iff compile-time const *)
    val link:       Rtl.exp -> bool (* true, off compile-time or link-time *)
end
@

% ------------------------------------------------------------------ 
\subsection{Read-Write Sets}
% ------------------------------------------------------------------ 


A \emph{register} is an {\rtl} location that is addressed by a known
(integer) value (c.f.~module \module{register}). Registers are of
special interest for liveness analysis where it is important to know,
the registers that read or written by an {\rtl}.
Because slices of registers may also be used in an {\rtl}, we maintain
locations of type [[Register.x]].
We provide two methods
to observe an {\rtl}'s locations: [[fold]] scans an [[Rtl.rtl]] value
and reports any register or slice in a read or write position to a function. This
does not require heap allocation and is therefore efficient.  The
slightly less efficient function [[sets]] reports registers and slices in read and
write positions as sets.

\begin{quote}\it
    The [[fold]] function is related to registers and slices, and therefore its name
    should imply this. We need another fold over memory locations that
    reports aliasing informations.
\end{quote}

<<rtlutil.mli>>=
module ReadWrite: sig
    type 'a observert = Register.t -> 'a -> 'a
    type 'a observerx = Register.x -> 'a -> 'a
    val fold: read: 'a observerx -> write: 'a observerx -> Rtl.rtl -> 'a -> 'a
    val fold_promote: read: 'a observert -> write: 'a observert -> Rtl.rtl -> 'a -> 'a
    val sets: Rtl.rtl -> (Register.SetX.t * Register.SetX.t)
    val sets_promote: Rtl.rtl -> (Register.Set.t * Register.Set.t)
end
@ 
<<rtlutil.mli>>=
module ReadWriteKill: sig
    type 'a observert = Register.t -> 'a -> 'a
    type 'a observerx = Register.x -> 'a -> 'a
    val fold: read: 'a observerx -> write: 'a observerx -> kill: 'a observerx ->
                    Rtl.rtl -> 'a -> 'a
    val fold_promote: read: 'a observert -> write: 'a observert -> kill: 'a observert ->
                      Rtl.rtl -> 'a -> 'a
    val sets: Rtl.rtl -> Register.SetX.t * Register.SetX.t * Register.SetX.t
    val sets_promote: Rtl.rtl -> Register.Set.t * Register.Set.t * Register.Set.t
end
@ 
Sometimes we need to know about all locations, not just registers.
<<rtlutil.mli>>=
module FullReadWriteKill: sig
    type 'a observer = Rtl.Private.loc -> 'a -> 'a
    val fold: read: 'a observer -> write: 'a observer -> kill: 'a observer ->
                    Rtl.rtl -> 'a -> 'a
end
@ 
% ------------------------------------------------------------------ 
\subsection{Search}
% ------------------------------------------------------------------ 

We can search for operators, locations, or constants satisfying a
given predicate.
<<rtlutil.mli>>=
module Exists : sig
  module Opr : sig
    val rtl : (Rtl.opr -> bool) -> Rtl.rtl -> bool
  end
  module Loc : sig
    val exp : (Rtl.Private.loc -> bool) -> Rtl.Private.exp -> bool
    val rtl : (Rtl.Private.loc -> bool) -> Rtl.Private.rtl -> bool
  end
  module Const : sig
    val rtl : (Rtl.Private.const -> bool) -> Rtl.rtl -> bool
  end
end 
@ 
If a location satisfying a predicate exists, we can find it.
<<rtlutil.mli>>=
module Find : sig
  module Loc : sig
    val exp : (Rtl.Private.loc -> bool) -> Rtl.Private.exp -> Rtl.Private.loc option
  end
end 
@    
We fold over locations that appear under [[Fetch]].
<<rtlutil.mli>>=
module Fold : sig
  module LocFetched : sig
    val rtl : (Rtl.Private.loc -> 'a -> 'a) -> Rtl.Private.rtl -> 'a -> 'a
  end
end
@ 

% ------------------------------------------------------------------ 
\subsection{Location search}
% ------------------------------------------------------------------ 
<<rtlutil.mli>>=
@ 
% ------------------------------------------------------------------ 
\subsection{Aliasing}
% ------------------------------------------------------------------ 

If a store to one item could affect the value of another, those two
items \emph{may alias}.

Because of a flaw in the design of our register representation, it is
difficult to know how many cells of its space a [[Register.t]]
occupies.
We ignore the problem and assume every register is just one cell.
This assumption is blatantly wrong, but it should be OK in those few
cases where we currently use may-alias information, i.e., to expand
shuffles. 
<<rtlutil.mli>>=
module MayAlias : sig
  (* MODULE MAY GIVE FALSE NEGATIVES FOR QUERIES INVOLVING REGISTER PAIRS *)
  val regs  : Register.t -> Register.t -> bool   
  val locs  : Rtl.loc -> Rtl.loc -> bool  (* useful to partially apply *)
  val locs' : Rtl.Private.loc -> Rtl.Private.loc -> bool  (* partially apply *)
  val exp   : Rtl.loc -> Rtl.exp -> bool  (* useful to partially apply *)
  val exp'  : Rtl.Private.loc -> Rtl.Private.exp -> bool  (* partially apply *)
end
@

% ------------------------------------------------------------------ 
\subsection{Substitution}
% ------------------------------------------------------------------ 

Register allocation requires to re-write an {\rtl} by substituting
registers inside. The translation of a procedure creates expressions
that contain [[Rtl.link]] values that later must be substituted for
compile-time constants. Substitutions for locations, registers. and
expressions are provided by the [[Subst]] sub-module:
<<rtlutil.mli>>=
module Subst: sig
    val loc:        guard:(Rtl.Private.loc -> bool)               
                    -> map:(Rtl.Private.loc -> Rtl.Private.loc) 
                    -> Rtl.rtl -> Rtl.rtl
    
    val exp:        guard:(Rtl.Private.exp -> bool)
                    -> map:(Rtl.Private.exp -> Rtl.Private.exp) 
                    -> Rtl.rtl -> Rtl.rtl
    
    val exp_of_exp: guard:(Rtl.Private.exp -> bool)
                    -> map:(Rtl.Private.exp -> Rtl.Private.exp) 
                    -> Rtl.exp -> Rtl.exp
    val loc_of_exp: map:(Register.t -> Rtl.loc) -> Rtl.exp -> Rtl.exp
    
    val reg:        map:(Register.t -> Register.t) -> Rtl.rtl -> Rtl.rtl
    
    val reg_def:    map:(Register.t -> Register.t) -> Rtl.rtl -> Rtl.rtl
    
    val reg_use:    map:(Register.t -> Register.t) -> Rtl.rtl -> Rtl.rtl

    module Fetch : sig   (* substitute for Fetch(l, w) *)
      val rtl:      guard:(Rtl.Private.loc -> bool) ->
                    fetch:(Rtl.Private.loc -> Rtl.width -> Rtl.Private.exp) ->
                    Rtl.rtl -> Rtl.rtl
      val exp':     guard:(Rtl.Private.loc -> bool) ->
                    fetch:(Rtl.Private.loc -> Rtl.width -> Rtl.Private.exp) ->
                    Rtl.Private.exp -> Rtl.Private.exp
    end
end
@

Function [[loc]] substitutes locations in an {\rtl}. We pass each
location that passes the [[guard]] predicate to [[map]] to obtain the
new location. The location returned by [[map]] is taken literally and
not further traversed by [[loc]]. If a location fails to pass the
[[guard]] it is recursively traversed to substitute locations within.

Function [[exp]] works like [[loc]], except that it substitutes
expressions.

Function [[reg]] substitutes registers in an {\rtl}. It takes a
[[lookup]] function for [[Rtl.spaces]] and a [[map]] function that
describes the substitution. 

% ------------------------------------------------------------------ 
\subsection{Classification}
% ------------------------------------------------------------------ 

Register allocation may benefit from knowing whether an {\rtl}
represents a move instruction. [[singleAssignment]] returns a destination
and source register pair if the input {\rtl} consists of a single,
unconditional assignment with any number of unconditional kills. If the
{\rtl} has a different form, [[singleAssignment]] returns [[None]].

<<rtlutil.mli>>=
module RTLType: sig
    val singleAssignment:    Rtl.rtl -> (Register.t * Register.t) option
end
@

% ------------------------------------------------------------------ 
\subsection{RTL AST Representation}
% ------------------------------------------------------------------ 

For debugging we like to make the intermediate code visible by
translating it back to {\PAL} syntax.  Technically this means, that
{\rtl}s are translated to the {\PAL} abstract syntax ({\AST}); for the
{\AST} a pretty printer (in module \module{ast}) translates it back to
{\small ASCII} codes. This module provides a translation from an {\rtl}
to a {\PAL} statement.

<<rtlutil.mli>>=
module ToAST: sig
    type verbosity =    Low | High             (* default is High   *)
    val verbosity:      verbosity -> verbosity (* returns old value *)

    val expr:           Rtl.exp  -> Ast.expr 
    val rtl:            Rtl.rtl  -> Ast.stmt 
end
@


% ------------------------------------------------------------------ 
\subsection{RTL String Representation}
% ------------------------------------------------------------------ 

For debugging, we want to represent {\rtl}s as strings. The string
representation is meant to be human-, but not necessarily
machine-readable. 

<<rtlutil.mli>>=
module ToString: sig
    val rtl: Rtl.rtl -> string
    val exp: Rtl.exp -> string
    val agg: Rtl.aggregation -> string
end
module ToReadableString: sig
    val rtl: Rtl.rtl -> string
    val exp: Rtl.exp -> string
    val loc: Rtl.loc -> string
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlutil.ml>>=
module R   = Rtl
module RP  = Rtl.Private
module Up  = Rtl.Up
module Dn  = Rtl.Dn
module Re  = Register
module RS  = Register.Set
module RSX = Register.SetX

module Width = struct
    <<Width>>
end

let fetch l   = R.fetch l   (Width.loc l)
let store l e = R.store l e (Width.loc l)

<<define common ReadWriteKill Higher Order Fns>>

module ReadWrite = struct
    <<ReadWrite>>
end

module ReadWriteKill = struct
    <<ReadWriteKill>>
end

module FullReadWriteKill = struct
    <<FullReadWriteKill>>
end

module Subst = struct
    <<Subst>>
end

module ToAST = struct
    <<ToAST>>
end

module ToString = struct
    <<ToString>>
end

module ToReadableString = struct
    <<ToReadableString>>
end

module Time = struct
    <<Time>>
end    
@

Register allocation may benefit from knowing whether an {\rtl} represents a
move instruction. [[singleAssignment]] returns a destination and source
register pair if the input {\rtl} consists of a single, unconditional
assignment with any number of unconditional kills. If the {\rtl} has a
different form, [[singleAssignment]] returns [[None]].

<<rtlutil.ml>>=
module RTLType = struct
    <<RTLType>>
end
@

% ------------------------------------------------------------------ 
\subsubsection{Width of Locations and Expressions}
% ------------------------------------------------------------------ 

<<Width>>=   
let loc l = match (Rtl.Dn.loc l) with
    | RP.Mem(_,_,w,_,_)     -> w
    | RP.Reg(_,_,w)         -> w
    | RP.Var(_,_,w)         -> w
    | RP.Global(_,_,w)      -> w
    | RP.Slice(w, _, _)     -> w
@

A named {\rtl} operator has a type and semantics that is independent of
its implementation. We have to look it up for expressions that have an
application on the outermost level.

<<Width>>=
let rec const = function
    | RP.Bool _       -> Impossible.impossible "asked width of Boolean"
    | RP.Bits b       -> Bits.width b
    | RP.Link (_,_,w) -> w
    | RP.Diff (c,_)   -> const c
    | RP.Late (_,w)   -> w

let exp' = function
    | RP.Const(c)   -> const c
    | RP.Fetch(_,w) -> w
    | RP.App (op,_) -> 
        ( match snd (Rtlop.Types.mono (Rtl.Up.opr op)) with
        | Types.Bits n -> n
        | Types.Bool   -> Impossible.impossible "asked width of Boolean operator"
        ) 
let exp e = exp' (Rtl.Dn.exp e)
@

% ------------------------------------------------------------------ 
\subsubsection{Registers read and written by an RTL}
% ------------------------------------------------------------------ 

<<define common ReadWriteKill Higher Order Fns>>=
let fold handle_reg handle_slice handle_mem ~read ~write ~kill r z = 
  let rec rtl (z:'a) (RP.Rtl gs)  = List.fold_left guarded z gs
      and guarded z (g, eff) = exp (effect z eff) g
      and effect z eff = match eff with
        | RP.Store (lhs, rhs, _)             -> loc write (exp z rhs) lhs
        | RP.Kill lhs                        -> loc kill z lhs
      and loc which z l = match l with
        | RP.Mem (space, _, w, addr, _) as m -> exp (handle_mem which z m) addr
        | RP.Reg r                           -> handle_reg       which z r
        | RP.Slice (w, i, l)                 -> handle_slice loc which z (w, i, l)
        | RP.Var _                           -> z
        | RP.Global _                        -> z
      and exp z e = match e with
        | RP.Const _                         -> z
        | RP.Fetch (l, w)                    -> loc read z l
        | RP.App (_, es)                     -> List.fold_left exp z es
  in
     rtl z (Rtl.Dn.rtl r)

let fold_regx ~read ~write ~kill r z =
  fold (fun which z r -> which (Re.Reg r) z)
       (fun loc which z (w, i, l) -> match l with
                        | RP.Reg r -> which (Re.Slice (w, i, r)) z
                        | _        -> loc which z l)
       (fun _ z _ -> z)
    ~read ~write ~kill r z

let fold_regt ~read ~write ~kill r z =
  fold (fun which z r -> which r z)
       (fun loc which z (w, i, l) -> loc which z l)
       (fun _ z _ -> z)
       ~read ~write ~kill r z
@

<<ReadWrite>>=
type 'a observert = Register.t -> 'a -> 'a
type 'a observerx = Register.x -> 'a -> 'a

let fold         ~read ~write r z = fold_regx ~read ~write ~kill:write r z
let fold_promote ~read ~write r z = fold_regt ~read ~write ~kill:write r z

let mk_sets fold add empty rtl =
    let add_left  r (left,right) = (add r left, right) in
    let add_right r (left,right) = (left, add r right) in
    let empty = (empty, empty) in
    fold ~read:add_left ~write:add_right rtl empty
let sets         rtl = mk_sets fold         RSX.add RSX.empty rtl
let sets_promote rtl = mk_sets fold_promote RS.add  RS.empty  rtl
@

% ------------------------------------------------------------------ 
\subsubsection{Registers read, written, and killed by an RTL}
% ------------------------------------------------------------------ 

<<ReadWriteKill>>=
type 'a observert = Register.t -> 'a -> 'a
type 'a observerx = Register.x -> 'a -> 'a
let fold         = fold_regx
let fold_promote = fold_regt

let mk_sets fold add empty rtl =
  let read  reg (r, w, k) = (add reg r, w, k) in
  let write reg (r, w, k) = (r, add reg w, k) in
  let kill  reg (r, w, k) = (r, w, add reg k) in
  fold ~read ~write ~kill rtl (empty, empty, empty)

let sets         rtl = mk_sets fold         RSX.add RSX.empty rtl
let sets_promote rtl = mk_sets fold_promote RS.add  RS.empty  rtl
@

% ------------------------------------------------------------------ 
\subsubsection{All locations read, written, and killed by an RTL}
% ------------------------------------------------------------------ 

I'M NOT SURE WHAT'S GOING ON WITH SLICES HERE...

<<FullReadWriteKill>>=
type 'a observer = RP.loc -> 'a -> 'a
let fold ~read ~write ~kill r z =
  fold (fun which z r -> which (RP.Reg r) z)
       (fun loc which z (w, i, l) ->  (* ??? *)
         match l with
         | RP.Reg r -> which (RP.Slice (w, i, l)) z
         | _        -> loc which z l)
       (fun which z m -> which m z)
    ~read ~write ~kill r z
@

% ------------------------------------------------------------------ 
\subsection{Substitutions inside RTLs (Second Try)}
% ------------------------------------------------------------------ 

The [[DownUp]] module allows to apply functions that work on the private
representation of {\rtl}s to their abstract public representation.
<<Subst>>=
module DownUp = struct
    let rtl f r = Rtl.Up.rtl (f (Rtl.Dn.rtl r))
    let loc f l = Rtl.Up.loc (f (Rtl.Dn.loc l))
    let exp f e = Rtl.Up.exp (f (Rtl.Dn.exp e))
end
@
It is sometimes useful to apply a function only to the locations defined or
used in an {\rtl}.
We define a general function [[loc\_gen']] that takes two extra boolean
arguments: [[def]] and [[use]]. These arguments indicate whether the function
should be applied to definitions and/or uses. The [[loc]] sub-function is
resposible for checking the [[act]] boolean variable before applying the
function. The caller of [[loc]] pass this variable according to whether the
location is used as a def or a use.
<<Subst>>=
let loc_gen' guard map rtl ~def ~use = 
    let rec exp = function
        | RP.Fetch (l, width)      -> RP.Fetch(loc use l, width)
        | RP.App(opr, exprs)       -> RP.App(opr, List.map exp exprs)
        | x                        -> x
    and loc act l = if act && guard l then map l else match l with
        | RP.Mem (sp,agg,w,e,ass)  -> RP.Mem(sp, agg, w, exp e, ass)
        | RP.Slice (w,i,l)         -> RP.Slice(w,i,loc act l)
        | x                        -> x
    and effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc def l, exp e, width)
        | RP.Kill  (l)             -> RP.Kill (loc def l)
    and guarded (e,eff)            = (exp e, effect eff)
    and subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)
    in    
        subst rtl
let loc'     guard map rtl = loc_gen' guard map rtl ~def:true  ~use:true
let loc_def' guard map rtl = loc_gen' guard map rtl ~def:true  ~use:false
let loc_use' guard map rtl = loc_gen' guard map rtl ~def:false ~use:true

let subst_exp_loc guard map =
    let rec subst_exp e = if guard e then map e else match e with
        | RP.Fetch (l, width)      -> RP.Fetch(subst_loc l, width)
        | RP.App(opr, exprs)       -> RP.App(opr, List.map subst_exp exprs)
        | x                        -> x
    and subst_loc = function
        | RP.Mem (sp,agg,w,e,ass)  -> RP.Mem(sp, agg, w, subst_exp e, ass)
        | RP.Slice (w,i,l)         -> RP.Slice(w,i,subst_loc l)
        | x                        -> x                                    in
    (subst_exp, subst_loc)
let exp' guard map rtl =
    let (exp, loc) = subst_exp_loc guard map                        in
    let effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc l, exp e, width)
        | RP.Kill  (l)             -> RP.Kill (loc l)               in
    let guarded (e,eff)            = (exp e, effect eff)            in
    let subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)  in
    subst rtl
@


For subtitutiong registers we use the substitution function for
locations and provide it with the appropirate guard and map.

<<Subst>>=
let reg_gen' map rtl loc' =
    let map = function RP.Reg r -> RP.Reg(map r) | _ -> assert false in
    let is_register = function
        | RP.Reg(_) -> true
        | _         -> false
    in
        loc' is_register map rtl
let reg' map rtl     = reg_gen' map rtl loc'
let reg_def' map rtl = reg_gen' map rtl loc_def'
let reg_use' map rtl = reg_gen' map rtl loc_use'

let exp        ~guard  ~map rtl = DownUp.rtl (exp' guard  map) rtl
let exp_of_exp ~guard  ~map exp =
  let (subst_exp,_) = subst_exp_loc guard map in
  DownUp.exp subst_exp exp
let loc_of_exp         ~map exp =
  let rec subst_exp e = match e with
      | RP.Fetch (l, width)      -> RP.Fetch(subst_loc l, width)
      | RP.App(opr, exprs)       -> RP.App(opr, List.map subst_exp exprs)
      | x                        -> x
  and subst_loc = function
      | RP.Mem (sp,agg,w,e,ass)  -> RP.Mem(sp, agg, w, subst_exp e, ass)
      | RP.Slice (w,i,l)         -> RP.Slice(w,i,subst_loc l)
      | RP.Reg (s,i,w as r)      -> Dn.loc (map r)
      | x                        -> x                                    in
  DownUp.exp subst_exp exp
  
let loc        ~guard  ~map rtl = DownUp.rtl (loc' guard  map) rtl 
let reg                ~map rtl = DownUp.rtl (reg'        map) rtl 
let reg_def            ~map rtl = DownUp.rtl (reg_def'    map) rtl 
let reg_use            ~map rtl = DownUp.rtl (reg_use'    map) rtl 
@

<<Subst>>=
module Fetch = struct
  let rec exp ~guard ~fetch = function
    | RP.Fetch (l, width) when guard l -> fetch l width
    | RP.Fetch (l, width) -> RP.Fetch (loc ~guard ~fetch l, width)
    | RP.App(opr, exprs)  -> RP.App(opr, List.map (exp ~guard ~fetch) exprs)
    | RP.Const _ as e     -> e
  and loc ~guard ~fetch l = match l with
  | RP.Mem (sp,agg,w,e,ass)  -> RP.Mem(sp, agg, w, exp ~guard ~fetch e, ass)
  | RP.Slice (w,i,l)         -> RP.Slice(w,i,loc ~guard ~fetch l)
  | RP.Reg _ | RP.Var _ | RP.Global _ -> l 
  let rtl ~guard ~fetch rtl =
    let RP.Rtl effs = Dn.rtl rtl in
    let loc = loc ~guard ~fetch in
    let exp = exp ~guard ~fetch in
    let effect = function
      | RP.Store (l,e,width)     -> RP.Store(loc l, exp e, width)
      | RP.Kill  (l)             -> RP.Kill (loc l) in
    let guarded (e,eff)  = (exp e, effect eff) in
    Up.rtl (RP.Rtl (List.map guarded effs))
  let exp' = exp
end
@

% ------------------------------------------------------------------ 
\subsection{RTL Classification}
% ------------------------------------------------------------------ 

<<old RTLType>>=
let singleAssignment rtl =
    let rec firstAssignment rtls = match rtls with
    | [] -> (None, [])
    | (RP.Const(RP.Bool true), RP.Store(loc1, RP.Fetch(loc2, _), _))::rst ->
        (try (Some (Register.of_loc (Rtl.Up.loc loc1),
                    Register.of_loc (Rtl.Up.loc loc2)),
              rst)
        with Invalid_argument _ -> (None, []))
    | _::rst -> firstAssignment rst in
    let getFirstAssignment (RP.Rtl guardeds) = firstAssignment guardeds in

    let isKill rtl = match rtl with
    | (RP.Const(RP.Bool true), RP.Kill _) -> true
    | _ -> false in
    let rec allKills rtls = List.for_all isKill rtls in

    let (assign, rst) = getFirstAssignment (Rtl.Dn.rtl rtl) in
        match assign with
        | Some _ when allKills rst -> assign
        | _ -> None
@

<<RTLType>>=
let singleAssignment rtl = 
    let truth = RP.Const(RP.Bool true) in
    let is_move = function (* effect is an uncond. move *)
        | (g,RP.Store(RP.Reg(dst), RP.Fetch(RP.Reg(src),_),_)) 
            when g=truth -> Some(dst,src)
        | _              -> None in
    let is_kill = function (* effect is an uncond. kill *) 
        | (g, RP.Kill _) -> g = truth
        | _              -> false
    in 
        match Rtl.Dn.rtl rtl with
        | RP.Rtl([])       -> None
        | RP.Rtl(fst::rst) -> if List.for_all is_kill rst 
                              then is_move fst
                              else None
@

% ------------------------------------------------------------------ 
\subsection{Conversion to AST}
% ------------------------------------------------------------------ 

<<ToAST>>=
module R = Rtl.Private
module A = Ast
module T = Types
@

<<ToAST>>=
type verbosity = Low | High  (* default is High --- more accurate *)
let the_verbosity = ref High
let verbosity v =
  let v' = !the_verbosity in
  the_verbosity := v;
  v'

<<ToAST>>=
let bits n             = A.BitsTy n
let bitstring b =
  try string_of_int (Bits.S.to_int b)
  with Bits.Overflow -> Bits.to_string b

let rec const = function
    | R.Bool(true)   ->  A.PrimOp ("true", [])
    | R.Bool(false)  ->  A.PrimOp ("false", [])
    | R.Bits b       ->  A.Int( bitstring b
                              , if !the_verbosity = High 
                                then Some (bits (Bits.width b)) 
                                else None
                              )
                     
    | R.Link(sym,_,w) -> A.Fetch(A.Name(None, sym#mangled_text))
    | R.Diff(c1,c2)   -> A.PrimOp("-", [(None,const c1); (None,const c2)])
    | R.Late(name,w)  -> A.Fetch(A.Name(None, name)) (*XXX ok? *)
@



<<ToAST>>=
let opr op w =
    Printf.sprintf "%s[%s]" op (String.concat "," (List.map string_of_int w))

let rec expr' = function
    | R.Const c         -> const c
    | R.Fetch(loc,_)    -> A.Fetch(location' loc)
    | R.App((op,ww),ee) -> let actual e = (None, expr' e) in
                           match ee with
                           | [l; r] when op = "add" || op = "sub" ->
                                  let op = if op = "add" then "+" else "-" in
                                  A.BinOp(expr' l, op, expr' r)
                           | _ -> A.PrimOp(opr op ww, List.map actual ee)
@

N.B. This code might possibly look up the location in a machine-dependent map
in case it needs to the name of a hardware register variable.

A translation of {\rtl} locations to {\PAL} is not semantic preserving
because {\PAL} has no notion of spaces. The translation here turns a
space into a (named) type, which is neither wrong nor right.

<<ToAST>>=
and location' = function 
    | R.Mem (sp,agg,width,e,ass) ->
        (match !the_verbosity with
        | High ->
            let a       =  match agg with
                           | Rtl.Identity     -> 'I'
                           | Rtl.BigEndian    -> 'B'
                           | Rtl.LittleEndian -> 'L' in
            let space   =  Printf.sprintf "$%c(%d%c)" sp width a in   
            let aligned = if ass = 1 then None else Some ass in 
            A.Mem(A.TypeSynonym space,expr' e,aligned, [])
        | Low ->
            A.Mem(A.BitsTy width,expr' e, (if ass = 1 then None else Some ass),
                  if sp = 'm' then [] else ["'" ^ Char.escaped sp ^ "'"]))
    | R.Reg(sp,i,w) -> 
        (match !the_verbosity with
        | High ->
            let space   =  Printf.sprintf "$%c(%d)" sp w in   
            let s       = string_of_int i in
            A.Mem(A.TypeSynonym space,A.Int(s,None), None, [])
        | Low -> A.Name(None, Printf.sprintf "$%c%d" sp i))
    | R.Var    (name,_,width)   -> A.Name(None,name)
    | R.Global (name,_,width)    -> A.Name(None,name)
    | R.Slice (w,i,loc)          -> location' loc (*XXX*)
    

let (<<) f g  = fun x -> f (g x)
let expr       = expr'     << Rtl.Dn.exp
let location   = location' << Rtl.Dn.loc

@

A [[kill]] is translated into an assignment of [[%undef()]].

<<ToAST>>=
let rec effect guard = function
    | R.Kill   loc       -> 
        let width = Width.loc  (Rtl.Up.loc loc)       in
        let undef = R.App(("undef",[width]),[]) in
            effect guard (R.Store(loc, undef, width))
    | R.Store  (loc,e,w) ->
            (location' loc,(guard, expr' e))

let guard = function
  | R.Const (R.Bool true) -> None
  | g -> Some (expr' g)  

let guarded (g, eff) = effect (guard g) eff

let rtl' (R.Rtl gg) = 
  match gg with
  | [] -> A.EmptyStmt
  | _ :: _ ->
    let pairs    = List.map (guarded ) gg in
    let lhs, rhs = List.split pairs             in
        A.AssignStmt(lhs,rhs)
let rtl = rtl' << Rtl.Dn.rtl
@
% ------------------------------------------------------------------ 
\subsection{Conversion to Readable String}
% ------------------------------------------------------------------ 

<<ToReadableString>>=
module R = Rtl.Private
module A = Ast
module T = Types
@

<<ToReadableString>>=
let rec const = function
    | R.Bool(true)    ->  "true"
    | R.Bool(false)   ->  "false"
    | R.Bits b        ->  Int64.to_string (Bits.S.to_int64 b)
    | R.Link(sym,_,w) -> sym#mangled_text
    | R.Diff(c1,c2)   -> (const c1) ^ "-" ^ (const c2)
    | R.Late(name,w)  -> "<" ^ name ^ ">"
@

<<ToReadableString>>=
let opr op w = "%" ^ op

let join = String.concat

let rec expr' = function
    | R.Const c         -> const c
    | R.Fetch(loc,_)    -> location' loc
    | R.App((op,ww),ee) -> match ee with
                           | [l; r] when op = "add" || op = "sub" ->
                                  let op = if op = "add" then " + " else " - " in
                                  brexpr' l ^ op ^ brexpr' r
                           | _ -> opr op ww ^ "(" ^ join ", " (List.map expr' ee) ^ ")"
and brexpr' e = match e with (* bracketed expression *)
    | R.App ((op,ww), _) when op = "add" || op = "sub" -> "(" ^ expr' e ^ ")"
    | _ -> expr' e
@

<<ToReadableString>>=
and location' = function 
    | R.Mem (sp,agg,width,e,ass) ->
        let space = if sp = 'm' then "bits" ^ string_of_int width
                    else "$" ^ Char.escaped sp in
        space ^ "[" ^ expr' e ^ "]"
    | R.Reg (sp,i,w) -> Printf.sprintf "$%s[%d]" (Char.escaped sp) i
    | R.Var    (name,_,width)       -> name
    | R.Global (name,_,width)       -> name
    | R.Slice (w,i,loc)          ->
        location' loc ^ "@[" ^ string_of_int i ^ ".." ^ string_of_int (i+w-1) ^ "]"
    
let (<<) f g  = fun x -> f (g x)
let expr       = expr'     << Rtl.Dn.exp
let loc = location' << Rtl.Dn.loc
@

A [[kill]] is translated into an assignment of [[%undef()]].
<<ToReadableString>>=
let rec effect = function
    | R.Kill   loc       -> "kill " ^ location' loc
    | R.Store  (loc,e,w) -> location' loc ^ " := " ^ expr' e

let guard = function
  | R.Const (R.Bool true) -> ""
  | g -> expr' g ^ " --> " 

let guarded (g, eff) = guard g ^ effect eff

let rtl' (R.Rtl gg) = 
  match gg with
  | [] -> "skip"
  | _ :: _ -> join " | " (List.map guarded gg)
let rtl = rtl' << Rtl.Dn.rtl
let exp = expr
@

% ------------------------------------------------------------------ 
\subsection{Evaluation Time Classification}
% ------------------------------------------------------------------ 

<<Time>>=
let compile e = match Dn.exp e with
    | RP.Const(RP.Bits _) -> true
    | RP.Const(RP.Bool _) -> true
    | RP.Const(RP.Late _) -> true
    | _                   -> false

let link e = match Dn.exp e with     
    | RP.Const(RP.Bits _) -> true
    | RP.Const(RP.Bool _) -> true
    | RP.Const(RP.Late _) -> true
    | RP.Const(RP.Link _) -> true       
    | RP.Const(RP.Diff _) -> true
    | RP.App(("add",_), [RP.Const(RP.Link _); RP.Const(RP.Bits _)])
        -> true
    | RP.App(("add",_), [RP.Const(RP.Diff _); RP.Const(RP.Bits _)])
        -> true
    | _                   -> false
@

% ------------------------------------------------------------------ 
\subsection{Conversion to String}
% ------------------------------------------------------------------ 

We convert a given {\rtl} into {\PAL} abstract syntax and then
pretty-print it into a string. To avoid newlines in the string we pass
[[max_int]] as the line-width to the pretty-printer. 


<<ToString>>=

module P  = Pp
module R  = Rtl
module RP = Rtl.Private 

let (^^)   = P.(^^)
let (^/)   = P.(^/)

let indent x = P.nest 4 (P.break ^^ x)
let int i    = P.text (string_of_int i)
let str s    = P.text s
let char c   = P.text (Printf.sprintf "'%c'" c)

let tuple docs = 
    let id x = x in
    P.agrp (P.text "(" ^^ P.list (P.text "," ^^ P.break) id docs ^^ P.text ")")
    
let apply c args = P.agrp(str c ^^ indent(tuple args))

let aggregation' = function
    | R.BigEndian       -> P.text "BE"
    | R.LittleEndian    -> P.text "LE"
    | R.Identity        -> P.text "ID"

let agg= function
    | R.BigEndian       -> "big"
    | R.LittleEndian    -> "little"
    | R.Identity        -> "none"

let opr (name, ws) =
    tuple [str name; tuple (List.map int ws)]

let rec const = function
    | RP.Bool(b)        -> apply "Bool"  [str (if b then "true" else "false")]
    | RP.Bits(b)        -> apply "Bits"  [ str (Int64.to_string (Bits.U.to_int64 b))
                                         ; int (Bits.width b)
                                         ]
    | RP.Link(r,k,w)    -> apply "Link"  [str r#mangled_text; P.text (kind k); int w]
    | RP.Diff(c1,c2)    -> apply "Diff"  [const c1; const c2]
    | RP.Late(s,w)      -> apply "Late"  [str s; int w]
and kind = function RP.Code -> "Code" | RP.Data -> "Data" | RP.Imported -> "Imported"

let rec exp = function
    | RP.Const(k)       -> apply "Const" [const k]
    | RP.Fetch(l,w)     -> apply "Fetch" [loc l; int w]
    | RP.App(o,es)      -> apply "App"   [opr o; tuple (List.map exp es)] 
    
and loc = function
    | RP.Mem(sp, agg, w, e, ass) -> 
        apply "Mem" [char sp; aggregation' agg; int w; exp e]
    | RP.Reg(sp,i,w) ->
        apply "Reg" [char sp; int i; int w]
    | RP.Var(name, index, w) ->
        apply "Var" [str name; int index; int w]
    | RP.Global(name, index, w) ->
        apply "Global" [str name; int index; int w]
    | RP.Slice(w, i, l) ->
        apply "Slice" [int w; int i; loc l]
        

let effect = function
    | RP.Store(l,e,w) -> apply "Store" [loc l; exp e; int w]
    | RP.Kill(l)      -> apply "Kill"  [loc l]  

let guarded (g, e) =
    tuple [exp g; effect e]

let rtl' (RP.Rtl x) =
    apply "Rtl" (List.map guarded x)
    
let rtl r =
    let pp = rtl' (R.Dn.rtl r) in
        Pp.ppToString 66 (* line width *) pp

let exp e =
    let pp = exp (R.Dn.exp e) in
        Pp.ppToString 66 (* line width *) pp
@

\subsection{Aliasing}
First code is not used but is to show how it should be done.
<<rtlutil.ml>>=
module Down = Rtl.Dn
module MayAlias = struct

  let cells (s, i, w) = Impossible.unimp "cell counts for registers"
  let regs_may_not_alias ((s, i, w) as r) ((s', i', w') as r') = 
    s <> s' || i + cells r <= i' || i' + cells r' <= i

  let regs (s, i, w) (s', i', w') = s = s && i = i'
  let with_reg r = function
    | RP.Reg r' -> regs r r'
    | _ -> false

  let with_vari vi = function
    | RP.Var (_, vi', _) -> vi = vi'
    | _ -> false

  let with_globali vi = function
    | RP.Global (_, vi', _) -> vi = vi'
    | _ -> false

  let memsize = 8 (* big risk *)

  type slot = string * int  (* symbol and offset *)

  let stack_slot = function
    | RP.Fetch(RP.Reg('V', 0, _), _) -> Some ("", 0)
    | RP.App (("add", [_]), [RP.Fetch(RP.Reg('V', 0, _), _); offset]) ->
        (match offset with
        | RP.Const (RP.Bits k') -> Some ("", Bits.S.to_int k')
        | RP.Const (RP.Late (s, _)) -> Some (s, 0)
        | RP.App (("add", [_]), [RP.Const l; RP.Const r]) ->
            (match l, r with
            | RP.Late (s, _), RP.Bits k -> Some (s, Bits.S.to_int k)
            | RP.Bits k, RP.Late (s, _) -> Some (s, Bits.S.to_int k)
            | _ -> None)
        | _ -> None)
    | _ -> None

  let rec is_initialized_data = function
    | RP.Const (RP.Link(_, _, _)) -> true
    | RP.Const (RP.Diff(_, _)) -> true
    | RP.App ((("add"|"sub"), [_]), [RP.Const _ as l; RP.Const _ as r]) ->
        is_initialized_data l || is_initialized_data r
    | _ -> false

  let with_mem s w e = function  (* different stack slots don't alias *)
    | RP.Mem (s', a', w', e', _) ->
        s = s' &&
        (match stack_slot e, stack_slot e' with
        | None,   Some _ -> not (is_initialized_data e)
        | Some _, None   -> not (is_initialized_data e')
        | None,   None   -> true
        | Some (sym, n), Some(sym', n') ->
(*
Printf.eprintf "--> comparing stack slots %s+%d and %s+%d\n" sym n sym' n';
*)
                sym = sym' && not (n + w * memsize <= n' || n' + w' + memsize <= n))
    | _ -> false

  let unslice f l =
    let rec un = function
      | RP.Slice (_, _, l) -> un l
      | l -> l
    in f (un l)

  let rec locs' l = match l with
    | RP.Reg r               -> unslice (with_reg  r)
    | RP.Var    (_, i, _)    -> unslice (with_vari i)
    | RP.Global (_, i, _)    -> unslice (with_globali i)
    | RP.Mem (s, a, w, e, _) -> unslice (with_mem s w e)
    | RP.Slice (_, _, l)     -> locs' l
  and locs l =
    let alias = locs' (Down.loc l) in
    fun l' -> alias (Down.loc l')
          
  let has_loc f e =
    let rec has es ess = match es with
      | [] -> (match ess with [] -> false | es :: ess -> has es ess)
      | RP.Const _ :: es -> has es ess
      | RP.Fetch (l, w) :: es ->
          f l || (match l with
                 | RP.Mem (_, _, _, e, _) -> has (e :: es) ess
                 | _ -> has es ess)
      | RP.App (_, es') :: es -> has es (es' :: ess) in
    has [e] []

  let exp' l =
    let may_alias = has_loc (locs' l) in
    fun e ->
      let answer = may_alias e in
      let module S = ToReadableString in
      let debug () = 
        Printf.eprintf "*** Expression %s %s alias with location %s\n"
          (S.exp (Rtl.Up.exp e)) (if answer then " may " else " may not ")
          (S.loc (Rtl.Up.loc l)) in
      answer

  let exp l =
    let alias = exp' (Down.loc l) in
    fun e -> alias (Down.exp e)
end
<<rtlutil.ml>>=
@ 
\section{Reassociating arithemtic}
<<rtlutil.ml>>=
let add' w =
  let addop = R.opr "add" [w] in
  fun x y -> R.app addop [x; y]

let rec is_sum_of_constants = function
  | RP.Const (RP.Bits _ | RP.Late (_, _)) -> true
  | RP.App   ((("add"), [w]), es)   -> List.for_all is_sum_of_constants es
  | _ -> false

let addc w =
  let add' = add' w in
  let addconst x y = match x, y with
    | RP.Bits b, RP.Bits b' -> R.bits (Bits.Ops.add b b') w
    | c, c' -> add' (Up.const c) (Up.const c') in
  fun x y ->
    match Down.exp x with
    | RP.App (("add", [w']), [x1; RP.Const c]) -> add' (Up.exp x1) (addconst c y)
    | RP.App (("add", [w']), [x1; x2]) when is_sum_of_constants x2 ->
        add' (Up.exp x1) (add' (Up.exp x2) (Up.const y))
    | _ -> add' x (Up.const y) 

let addk w =
  let add = addc w in
  fun x k -> if k = 0 then x else add x (RP.Bits (Bits.S.of_int k w))

let add w =
  let add = add' w in
  fun x y -> match (Down.exp y) with
  | RP.Const c -> addc w x c
  | _ -> add x y
@ 
\subsection{Operator search}
<<rtlutil.ml>>=
module Exists = struct
  module Loc = struct
    let exp = MayAlias.has_loc
    let rtl p =
      let exp = exp p in
      let effect = function
        | RP.Store (l, r, w) -> exp r || exp (RP.Fetch (l, w))
        | RP.Kill l          -> exp (RP.Fetch (l, 0)) in (* width cheat is OK *)
      let ge (guard, eff) = exp guard || effect eff in
      fun (RP.Rtl ges) -> List.exists ge ges
  end
  module Opr = struct
    let rtl p =
      let rec rtl (RP.Rtl gs) = List.exists guarded gs
      and guarded (g, eff) = exp g || effect eff
      and effect = function
        | RP.Store (lhs, rhs, _)    -> loc lhs || exp rhs
        | RP.Kill lhs               -> loc lhs
      and loc = function
        | RP.Mem (_, _, _, addr, _) -> exp addr
        | RP.Reg r                  -> false
        | RP.Slice (_, _, l)        -> loc l
        | RP.Var _                  -> false
        | RP.Global _               -> false
      and exp = function
        | RP.Const _                -> false
        | RP.Fetch (l, w)           -> loc l
        | RP.App (opr, es)          -> p (Rtl.Up.opr opr) || List.exists exp es in
      fun r -> rtl (Rtl.Dn.rtl r)
  end
  module Const = struct
    let rtl const_ftn =
      let rec rtl (RP.Rtl gs) = List.exists guarded gs
      and guarded (e, eff) = exp e || effect eff
      and effect eff = match eff with
        | RP.Store(l, e, _) -> loc l || exp e
        | RP.Kill l -> loc l
      and loc l = match l with
        | RP.Mem(_,_,_,e,_) -> exp e
        | RP.Slice(_,_,l')  -> loc l'
        | RP.Reg _ | RP.Var _ | RP.Global _ -> false
      and exp e = match e with
        | RP.Const c     -> const c
        | RP.Fetch(l, _) -> loc l
        | RP.App(_, es)  -> List.exists exp es
      and const c = const_ftn c in
      fun r -> rtl (R.Dn.rtl r)
  end
end 
<<rtlutil.ml>>=
module Find = struct
  module Loc = struct
    let exp f e =
      let rec has es ess = match es with
        | [] -> (match ess with [] -> None | es :: ess -> has es ess)
        | RP.Const _ :: es -> has es ess
        | RP.Fetch (l, w) :: es ->
            if f l then Some l
            else ( match l with
                 | RP.Mem (_, _, _, e, _) -> has (e :: es) ess
                 | _ -> has es ess)
        | RP.App (_, es') :: es -> has es (es' :: ess) in
      has [e] []
  end
end 
@ 
<<rtlutil.ml>>=
module Fold = struct
  module LocFetched = struct
    let rtl f rtl z = 
      let rec exp z e =
        let rec fold z es ess = match es with
        | [] -> (match ess with [] -> z | es :: ess -> fold z es ess)
        | RP.Const _ :: es -> fold z es ess
        | RP.Fetch (l, w) :: es -> let z = f l z in fold (loc z l) es ess
        | RP.App (_, es') :: es -> fold z es (es' :: ess) in
        fold z [e] [] 
      and loc z = function
        | RP.Mem (_, _, _, e, _) -> exp z e
        | _ -> z in
      let effect z = function
        | RP.Kill l -> loc z l
        | RP.Store (l, r, w) -> exp (loc z l) r in
      let guarded z (g, e) = effect (exp z g) e in
      let RP.Rtl effs = rtl in
      List.fold_left guarded z effs
  end
end 
