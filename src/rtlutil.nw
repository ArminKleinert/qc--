% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% vim: ts=8 sw=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{RTL Utilities}
% ------------------------------------------------------------------ 

This module provides functions to observe and transform {\rtl}s. 

% ------------------------------------------------------------------ 
\subsection{Width}
% ------------------------------------------------------------------ 

Locations and non-boolean expressions have a \emph{width} that can be
observed.  It is a checked run-time error to pass a boolean expression
to [[exp]].

<<rtlutil.mli>>=
module Width: sig
    val loc:    Rtl.loc -> int
    val exp:    Rtl.exp -> int
end 
@

% ------------------------------------------------------------------ 
\subsection{Evaluation Time Classification}
% ------------------------------------------------------------------ 

The form of an {\rtl} expression tells whether it is a compile-time
constant, link-time constant, or run-time expression.

<<rtlutil.mli>>=
module Time: sig
    val compile:    Rtl.exp -> bool (* true, iff compile-time const *)
    val link:       Rtl.exp -> bool (* true, off compile-time or link-time *)
end
@

% ------------------------------------------------------------------ 
\subsection{Read-Write Sets}
% ------------------------------------------------------------------ 


A \emph{register} is an {\rtl} location that is addressed by a known
(integer) value (c.f.~module \module{register}). Registers are of
special interest for liveness analysis where it is important to know,
the registers that read or written by an {\rtl}. We provide two methods
to observe an {\rtl}'s registers: [[fold]] scans an [[Rtl.rtl]] value
and reports any register in a read or write position to a function. This
does not require heap allocation and is therefore efficient.  The
slightly less efficient function [[sets]] reports registers in read and
write positions as sets.

\begin{quote}\it
    The [[fold]] function is related to registers and therefore its name
    should imply this. We need another fold over memory locations that
    reports aliasing informations.
\end{quote}

<<rtlutil.mli>>=
module ReadWrite: sig
    type 'a observer = Rtl.space -> Base.std_int -> Rtl.width -> 'a -> 'a
    val fold: read: 'a observer -> write: 'a observer -> Rtl.rtl -> 'a -> 'a
    val sets: Rtl.rtl -> (Register.Set.t * Register.Set.t)
end
@ 
<<rtlutil.mli>>=
module ReadWriteKill: sig
    val sets: Rtl.rtl -> Register.Set.t * Register.Set.t * Register.Set.t
end
@    

% ------------------------------------------------------------------ 
\subsection{Substitution}
% ------------------------------------------------------------------ 

Register allocation requires to re-write an {\rtl} by substituting
registers inside. The translation of a procedure creates expressions
that contain [[Rtl.link]] values that later must be substituted for
compile-time constants. Substitutions for locations, registers. and
expressions are provided by the [[Subst2]] sub-module:

<<rtlutil.mli>>=
module Subst2: sig
    val loc:    guard:(Rtl.Private.loc -> bool)               
                -> map:(Rtl.Private.loc -> Rtl.Private.loc) 
                -> Rtl.rtl -> Rtl.rtl
    
    val exp:    guard:(Rtl.Private.exp -> bool)
                -> map:(Rtl.Private.exp -> Rtl.Private.exp) 
                -> Rtl.rtl -> Rtl.rtl
    
    val reg:    map:(Register.t -> Register.t) -> Rtl.rtl -> Rtl.rtl
end
@

Function [[loc]] substitutes locations in an {\rtl}. We pass each
location that passes the [[guard]] predicate to [[map]] to obtain the
new location. The location returned by [[map]] is taken literally and
not further traversed by [[loc]]. If a location fails to pass the
[[guard]] it is recursively traversed to substitute locations within.

Function [[exp]] works like [[loc]], except that it substitutes
expressions.

Function [[reg]] substitutes registers in an {\rtl}. It takes a
[[lookup]] function for [[Rtl.spaces]] and a [[map]] function that
describes the substitution. 

% ------------------------------------------------------------------ 
\subsection{Classification}
% ------------------------------------------------------------------ 

Register allocation may benefit from knowing whether an {\rtl}
represents a move instruction. [[singleAssignment]] returns a source and
destination register pair if the input {\rtl} consists of a single,
unconditional assignment with any number of unconditional kills. If the
{\rtl} has a different form, [[singleAssignment]] returns [[None]].

<<rtlutil.mli>>=
module RTLType: sig
    val singleAssignment:    Rtl.rtl -> (Register.t * Register.t) option
end
@

% ------------------------------------------------------------------ 
\subsection{RTL AST Representation}
% ------------------------------------------------------------------ 

For debugging we like to make the intermediate code visible by
translating it back to {\PAL} syntax.  Technically this means, that
{\rtl}s are translated to the {\PAL} abstract syntax ({\AST}); for the
{\AST} a pretty printer (in module \module{ast}) translates it back to
{\small ASCII} codes. This module provides a translation from an {\rtl}
to a {\PAL} statement.

<<rtlutil.mli>>=
module ToAST: sig
    type verbosity =    Low | High             (* default is High   *)
    val verbosity:      verbosity -> verbosity (* returns old value *)

    val expr:           Rtl.exp  -> Ast.expr 
    val rtl:            Rtl.rtl  -> Ast.stmt 
end
@


% ------------------------------------------------------------------ 
\subsection{RTL String Representation}
% ------------------------------------------------------------------ 

For debugging, we want to represent {\rtl}s as strings. The string
representation is meant to be human-, but not necessarily
machine-readable. 

<<rtlutil.mli>>=
module ToString: sig
    val rtl: Rtl.rtl -> string
    val exp: Rtl.exp -> string
end
module ToReadableString: sig
    val rtl: Rtl.rtl -> string
    val exp: Rtl.exp -> string
    val loc: Rtl.loc -> string
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlutil.ml>>=
module RP = Rtl.Private
module U  = Rtl.Revert
module D  = Rtl.Convert

module Width = struct
    <<Width>>
end

module ReadWrite = struct
    <<ReadWrite>>
end

module ReadWriteKill = struct
    <<ReadWriteKill>>
end

module Subst2 = struct
    <<Subst2>>
end

module ToAST = struct
    <<ToAST>>
end

module ToString = struct
    <<ToString>>
end

module ToReadableString = struct
    <<ToReadableString>>
end

module Time = struct
    <<Time>>
end    
@

Register allocation may benefit from knowing whether an {\rtl} represents a
move instruction. [[singleAssignment]] returns a source and destination
register pair if the input {\rtl} consists of a single, unconditional
assignment with any number of unconditional kills. If the {\rtl} has a
different form, [[singleAssignment]] returns [[None]].

<<rtlutil.ml>>=
module RTLType = struct
    <<RTLType>>
end
@

% ------------------------------------------------------------------ 
\subsubsection{Width of Locations and Expressions}
% ------------------------------------------------------------------ 

<<Width>>=   
let loc l = match (Rtl.Convert.loc l) with
    | RP.Mem(_,_,w,_,_)     -> w
    | RP.Reg(_,_,w)         -> w
    | RP.Var(_,_,w)         -> w
    | RP.Slice(w, _, _)     -> w
@

A named {\rtl} operator has a type and semantics that is independent of
its implementation. We have to look it up for expressions that have an
application on the outermost level.

<<Width>>=
let exp e = match Rtl.Convert.exp e with
    | RP.Const(RP.Bool _)     -> assert false
    | RP.Const(RP.Bits b)     -> Bits.width b
    | RP.Const(RP.Link (_,w)) -> w
    | RP.Const(RP.Late (_,w)) -> w
    | RP.Fetch(_,w)           -> w
    | RP.App (op,_)           -> 
        ( match snd (Rtlop.Types.mono (Rtl.Revert.opr op)) with
        | Types.Bits(n) -> n
        | Types.Bool    -> assert false 
        ) 
@

% ------------------------------------------------------------------ 
\subsubsection{Registers read and written by an RTL}
% ------------------------------------------------------------------ 

<<ReadWrite>>=
type 'a observer = Rtl.space -> (*index*) Base.std_int -> Rtl.width -> 'a -> 'a

let fold ~(read:'a observer) ~(write:'a observer) r z = 
  let rec rtl (z:'a) (RP.Rtl gs)  = List.fold_left guarded z gs
      and guarded z (g, eff) = exp (effect z eff) g
      and effect z eff = match eff with
        | RP.Store (lhs, rhs, _)         -> loc write (exp z rhs) lhs
        | RP.Kill lhs                    -> loc write z lhs
      and loc which z l = match l with
        | RP.Mem (space, _, w, addr, _)  -> exp z addr
        | RP.Reg (space, i, w)           -> which space i w z
        | RP.Slice (_, _, l)             -> loc which z l
        | RP.Var _                       -> z
      and exp z e = match e with
        | RP.Const _                     -> z
        | RP.Fetch (l, w)                -> loc read z l
        | RP.App (_, es)                 -> List.fold_left exp z es
  in
     rtl z (Rtl.Dn.rtl r)

let sets (rtl:Rtl.rtl) = 
    let reg space index width = (space,index,width) in
    let add_left  space index width (left,right) = 
        (Register.Set.add (reg space index width) left, right) in
    let add_right  space index width (left,right) = 
        (left, Register.Set.add (reg space index width) right) in
    let empty = (Register.Set.empty, Register.Set.empty) in
        fold ~read:add_left ~write:add_right rtl empty
@

% ------------------------------------------------------------------ 
\subsubsection{Registers read, written, and killed by an RTL}
% ------------------------------------------------------------------ 

<<ReadWriteKill>>=
let fold ~read ~write ~kill r z = 
  let rec rtl z (RP.Rtl gs) = List.fold_left guarded z gs
      and guarded z (g, eff) = exp (effect z eff) g
      and effect z eff = match eff with
        | RP.Store (lhs, rhs, _)         -> loc write (exp z rhs) lhs
        | RP.Kill lhs                    -> loc kill  z lhs
      and loc which z l = match l with
        | RP.Mem (space, _, w, addr, _)  -> exp z addr
        | RP.Reg r                       -> which r z
        | RP.Slice (_, _, l)             -> loc which z l
        | RP.Var _                       -> z
      and exp z e = match e with
        | RP.Const _                     -> z
        | RP.Fetch (l, w)                -> loc read z l
        | RP.App (_, es)                 -> List.fold_left exp z es
  in
     rtl z (Rtl.Dn.rtl r)

let sets (rtl:Rtl.rtl) = 
  let module RS = Register.Set in
  let read  reg (r, w, k) = (RS.add reg r, w, k) in
  let write reg (r, w, k) = (r, RS.add reg w, k) in
  let kill  reg (r, w, k) = (r, w, RS.add reg k) in
  fold ~read ~write ~kill rtl (RS.empty, RS.empty, RS.empty)
@

% ------------------------------------------------------------------ 
\subsection{Substitutions inside RTLs (Second Try)}
% ------------------------------------------------------------------ 

The [[DownUp]] module allows to apply functions that work on the private
representation of {\rtl}s to their abstract public representation.

<<Subst2>>=
module DownUp = struct
    let rtl f r = Rtl.Up.rtl (f (Rtl.Dn.rtl r))
    let loc f l = Rtl.Up.loc (f (Rtl.Dn.loc l))
    let exp f e = Rtl.Up.exp (f (Rtl.Dn.exp e))
end

let loc' guard map rtl = 
    let rec exp = function
        | RP.Fetch (l, width)      -> RP.Fetch(loc l, width)
        | RP.App(opr, exprs)       -> RP.App(opr, List.map exp exprs)
        | x                        -> x
    and loc l = if guard l then map l else match l with
        | RP.Mem (sp,agg,w,e,ass)  -> RP.Mem(sp, agg, w, exp e, ass)
        | RP.Slice (w,i,l)         -> RP.Slice(w,i,loc l)
        | x                        -> x
    and effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc l, exp e, width)
        | RP.Kill  (l)             -> RP.Kill (loc l)
    and guarded (e,eff)            = (exp e, effect eff)
    and subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)
    in    
        subst rtl

let exp' guard map rtl =
    let rec exp e = if guard e then map e else match e with
        | RP.Fetch (l, width)      -> RP.Fetch(loc l, width)
        | RP.App(opr, exprs)       -> RP.App(opr, List.map exp exprs)
        | x                        -> x
    and loc = function
        | RP.Mem (sp,agg,w,e,ass)  -> RP.Mem(sp, agg, w, exp e, ass)
        | RP.Slice (w,i,l)         -> RP.Slice(w,i,loc l)
        | x                        -> x
    and effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc l, exp e, width)
        | RP.Kill  (l)             -> RP.Kill (loc l)
    and guarded (e,eff)            = (exp e, effect eff)
    and subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)
    in  
        subst rtl
@


For subtitutiong registers we use the substitution function for
locations and provide it with the appropirate guard and map.

<<Subst2>>=
let reg' map rtl = 
    let map = function RP.Reg r -> RP.Reg(map r) | _ -> assert false in
    let is_register = function
        | RP.Reg(_) -> true
        | _         -> false
    in
        loc' is_register map rtl

let exp ~guard  ~map rtl = DownUp.rtl (exp' guard  map) rtl
let loc ~guard  ~map rtl = DownUp.rtl (loc' guard  map) rtl 
let reg         ~map rtl = DownUp.rtl (reg'        map) rtl 
@


% ------------------------------------------------------------------ 
\subsection{RTL Classification}
% ------------------------------------------------------------------ 

<<old RTLType>>=
let singleAssignment rtl =
    let rec firstAssignment rtls = match rtls with
    | [] -> (None, [])
    | (RP.Const(RP.Bool true), RP.Store(loc1, RP.Fetch(loc2, _), _))::rst ->
        (try (Some (Register.of_loc (Rtl.Revert.loc loc1),
                    Register.of_loc (Rtl.Revert.loc loc2)),
              rst)
        with Invalid_argument _ -> (None, []))
    | _::rst -> firstAssignment rst in
    let getFirstAssignment (RP.Rtl guardeds) = firstAssignment guardeds in

    let isKill rtl = match rtl with
    | (RP.Const(RP.Bool true), RP.Kill _) -> true
    | _ -> false in
    let rec allKills rtls = List.for_all isKill rtls in

    let (assign, rst) = getFirstAssignment (Rtl.Convert.rtl rtl) in
        match assign with
        | Some _ when allKills rst -> assign
        | _ -> None
@

<<RTLType>>=
let singleAssignment rtl = 
    let truth = RP.Const(RP.Bool true) in
    let is_move = function (* effect is an uncond. move *)
        | (g,RP.Store(RP.Reg(dst), RP.Fetch(RP.Reg(src),_),_)) 
            when g=truth -> Some(dst,src)
        | _              -> None in
    let is_kill = function (* effect is an uncond. kill *) 
        | (g, RP.Kill _) -> g = truth
        | _              -> false
    in 
        match Rtl.Dn.rtl rtl with
        | RP.Rtl([])       -> None
        | RP.Rtl(fst::rst) -> if List.for_all is_kill rst 
                              then is_move fst
                              else None
@

% ------------------------------------------------------------------ 
\subsection{Conversion to AST}
% ------------------------------------------------------------------ 

<<ToAST>>=
module R = Rtl.Private
module A = Ast
module T = Types
@

<<ToAST>>=
type verbosity = Low | High  (* default is High --- more accurate *)
let the_verbosity = ref High
let verbosity v =
  let v' = !the_verbosity in
  the_verbosity := v;
  v'

<<ToAST>>=
let bits n             = A.BitsTy n

let const = function
    | R.Bool(true)   ->  A.PrimOp ("true", [])
    | R.Bool(false)  ->  A.PrimOp ("false", [])
    | R.Bits b       ->  A.Int( string_of_int (Bits.U.to_int b)
                              , if !the_verbosity = High 
                                then Some (bits (Bits.width b)) 
                                else None
                              )
                     
    | R.Link(sym,w)  -> A.Fetch(A.Var(None, (sym#text)))
    | R.Late(name,w) -> A.Fetch(A.Var(None, name)) (*XXX ok? *)
@



<<ToAST>>=
let opr op w =
    Printf.sprintf "%s[%s]" op (String.concat "," (List.map string_of_int w))

let rec expr' = function
    | R.Const c         -> const c
    | R.Fetch(loc,_)    -> A.Fetch(location' loc)
    | R.App((op,ww),ee) -> let actual e = (None, expr' e) in
                           match ee with
                           | [l; r] when op = "add" || op = "sub" ->
                                  let op = if op = "add" then "+" else "-" in
                                  A.BinOp(expr' l, op, expr' r)
                           | _ -> A.PrimOp(opr op ww, List.map actual ee)
@

N.B. This code might possibly look up the location in a machine-dependent map
in case it needs to the name of a hardware register variable.

A translation of {\rtl} locations to {\PAL} is not semantic preserving
because {\PAL} has no notion of spaces. The translation here turns a
space into a (named) type, which is neither wrong nor right.

<<ToAST>>=
and location' = function 
    | R.Mem (sp,agg,width,e,ass) ->
        let a       =  match agg with
                       | Rtl.Identity     -> 'I'
                       | Rtl.BigEndian    -> 'B'
                       | Rtl.LittleEndian -> 'L' in
        let space   =  Printf.sprintf "$%c(%d%c)" sp width a in   
        let aligned = if ass = 1 then None else Some ass in 
        A.Mem(A.AliasTy space,expr' e,aligned)
    | R.Reg(sp,i,w) -> 
        let space   =  Printf.sprintf "$%c(%d)" sp w in   
        let s       = string_of_int i in
            A.Mem(A.AliasTy space,A.Int(s,None), None)
    | R.Var (name,_,width)       -> A.Var(None,name)
    | R.Slice (w,i,loc)          -> location' loc (*XXX*)
    

let (<<) f g  = fun x -> f (g x)
let expr       = expr'     << Rtl.Convert.exp
let location   = location' << Rtl.Convert.loc

@

A [[kill]] is translated into an assignment of [[%undef()]].

<<ToAST>>=
let rec effect guard = function
    | R.Kill   loc       -> 
        let width = Width.loc  (Rtl.Revert.loc loc)       in
        let undef = R.App(("undef",[width]),[]) in
            effect guard (R.Store(loc, undef, width))
    | R.Store  (loc,e,w) ->
            (location' loc,(guard, expr' e))

let guard = function
  | R.Const (R.Bool true) -> None
  | g -> Some (expr' g)  

let guarded (g, eff) = effect (guard g) eff

let rtl' (R.Rtl gg) = 
  match gg with
  | [] -> A.EmptyStmt
  | _ :: _ ->
    let pairs    = List.map (guarded ) gg in
    let lhs, rhs = List.split pairs             in
        A.AssignStmt(lhs,rhs)
let rtl = rtl' << Rtl.Convert.rtl
@
% ------------------------------------------------------------------ 
\subsection{Conversion to Readable String}
% ------------------------------------------------------------------ 

<<ToReadableString>>=
module R = Rtl.Private
module A = Ast
module T = Types
@

<<ToReadableString>>=
let const = function
    | R.Bool(true)   ->  "true"
    | R.Bool(false)  ->  "false"
    | R.Bits b       ->  string_of_int (Bits.U.to_int b)
                     
    | R.Link(sym,w)  -> sym#text
    | R.Late(name,w) -> "<" ^ name ^ ">"
@

<<ToReadableString>>=
let opr op w = "%%" ^ op

let join = String.concat

let rec expr' = function
    | R.Const c         -> const c
    | R.Fetch(loc,_)    -> location' loc
    | R.App((op,ww),ee) -> match ee with
                           | [l; r] when op = "add" || op = "sub" ->
                                  let op = if op = "add" then " + " else " - " in
                                  brexpr' l ^ op ^ brexpr' r
                           | _ -> opr op ww ^ "(" ^ join ", " (List.map expr' ee) ^ ")"
and brexpr' e = match e with (* bracketed expression *)
    | R.App ((op,ww), _) when op = "add" || op = "sub" -> "(" ^ expr' e ^ ")"
    | _ -> expr' e
@

<<ToReadableString>>=
and location' = function 
    | R.Mem (sp,agg,width,e,ass) ->
        let space = if sp = 'm' then "bits" ^ string_of_int width
                    else "$" ^ Char.escaped sp in
        space ^ "[" ^ expr' e ^ "]"
    | R.Reg (sp,i,w) -> Printf.sprintf "$%s[%d]" (Char.escaped sp) i
    | R.Var (name,_,width)       -> name
    | R.Slice (w,i,loc)          ->
        location' loc ^ "@[" ^ string_of_int i ^ ".." ^ string_of_int (i+w-1) ^ "]"
    
let (<<) f g  = fun x -> f (g x)
let expr       = expr'     << Rtl.Convert.exp
let loc = location' << Rtl.Convert.loc
@

A [[kill]] is translated into an assignment of [[%undef()]].
<<ToReadableString>>=
let rec effect = function
    | R.Kill   loc       -> "kill " ^ location' loc
    | R.Store  (loc,e,w) -> location' loc ^ " := " ^ expr' e

let guard = function
  | R.Const (R.Bool true) -> ""
  | g -> expr' g ^ " --> " 

let guarded (g, eff) = guard g ^ effect eff

let rtl' (R.Rtl gg) = 
  match gg with
  | [] -> "skip"
  | _ :: _ -> join " | " (List.map guarded gg)
let rtl = rtl' << Rtl.Convert.rtl
let exp = expr
@

% ------------------------------------------------------------------ 
\subsection{Evaluation Time Classification}
% ------------------------------------------------------------------ 

<<Time>>=
let compile e = match D.exp e with
    | RP.Const(RP.Bits _) -> true
    | RP.Const(RP.Bool _) -> true
    | RP.Const(RP.Late _) -> true
    | _                   -> false

let link e = match D.exp e with     
    | RP.Const(RP.Bits _) -> true
    | RP.Const(RP.Bool _) -> true
    | RP.Const(RP.Late _) -> true
    | RP.Const(RP.Link _) -> true       
    | RP.App(("add",_), [RP.Const(RP.Link _); RP.Const(RP.Bits _)])
        -> true
    | _                   -> false
@

% ------------------------------------------------------------------ 
\subsection{Conversion to String}
% ------------------------------------------------------------------ 

We convert a given {\rtl} into {\PAL} abstract syntax and then
pretty-print it into a string. To avoid newlines in the string we pass
[[max_int]] as the line-width to the pretty-printer. 


<<ToString>>=

module P  = Pp
module R  = Rtl
module RP = Rtl.Private 

let (^^)   = P.(^^)
let (^/)   = P.(^/)

let indent x = P.nest 4 (P.break ^^ x)
let int i    = P.text (string_of_int i)
let str s    = P.text s
let char c   = P.text (Printf.sprintf "'%c'" c)

let tuple docs = 
    let id x = x in
    P.agrp (P.text "(" ^^ P.list (P.text "," ^^ P.break) id docs ^^ P.text ")")
    
let apply c args = P.agrp(str c ^^ indent(tuple args))

let aggregation = function
    | R.BigEndian       -> P.text "BE"
    | R.LittleEndian    -> P.text "LE"
    | R.Identity        -> P.text "ID"

let opr (name, ws) =
    tuple [str name; tuple (List.map int ws)]

let const = function
    | RP.Bool(b)        -> apply "Bool"  [str (if b then "true" else "false")]
    | RP.Bits(b)        -> apply "Bits"  [ int (Bits.U.to_int b)
                                         ; int (Bits.width b)
                                         ]
    | RP.Link(r,w)      -> apply "Link"  [str r#text; int w]
    | RP.Late(s,w)      -> apply "Late"  [str s; int w]


let rec exp = function
    | RP.Const(k)       -> apply "Const" [const k]
    | RP.Fetch(l,w)     -> apply "Fetch" [loc l; int w]
    | RP.App(o,es)      -> apply "App"   [opr o; tuple (List.map exp es)] 
    
and loc = function
    | RP.Mem(sp, agg, w, e, ass) -> 
        apply "Mem" [char sp; aggregation agg; int w; exp e]
    | RP.Reg(sp,i,w) ->
        apply "Reg" [char sp; int i; int w]
    | RP.Var(name, index, w) ->
        apply "Var" [str name; int index; int w]
    | RP.Slice(w, i, l) ->
        apply "Slice" [int w; int i; loc l]
        

let effect = function
    | RP.Store(l,e,w) -> apply "Store" [loc l; exp e; int w]
    | RP.Kill(l)      -> apply "Kill"  [loc l]  

let guarded (g, e) =
    tuple [exp g; effect e]

let rtl' (RP.Rtl x) =
    apply "Rtl" (List.map guarded x)
    
let rtl r =
    let pp = rtl' (R.Convert.rtl r) in
        Pp.ppToString 66 (* line width *) pp

let exp e =
    let pp = exp (R.Convert.exp e) in
        Pp.ppToString 66 (* line width *) pp
@

