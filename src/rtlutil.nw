% -*- mode: Noweb; noweb-code-mode: caml-mode -*-


% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

\input{macros.tex}

% ----------------------------------------------------------------
\section{Utility functions on RTLs}
% ----------------------------------------------------------------

Code that builds or manipulates {\rtl}s tends to use the same
functionality over and over again. We try to define some useful values
here.

The [[width]] of an expression is only defined for value-expressions,
but not for conditions.  Applying [[width]] to a condition will result
in an assertion failure.  

<<rtlutil.mli>>=
val locwidth  : Rtl.loc -> Rtl.width
val locwidth' : Rtl.Private.loc -> Rtl.width
  (* always succeeds *)
@ 

For liveness analysis, we need to know what registers are read and
written.  We provide a suitable catamorphism (folding operator).  This
operator runs \emph{after} creation time, and it announces \emph{only}
locations that seem ``register-like,'' i.e., spaces indexed by
constants.  N.B.~it cannot distinguish fixed registers or references
to fixed locations in memory; it is up to the client to ignore these
as appropriate.  This operator does, however, ignore slices, since we
think they aren't of interest to any liveness analysis.  (This is
going to be wrong if we have to manage condition codes.)

The order registers are announced to [[read]] and [[write]] is
unspecified.  Beware of this when dealing with {\rtl}s that read and
write the same register!

<<rtlutil.mli>>=
type 'a regfun = Rtl.space -> index:Base.std_int -> Rtl.width -> 'a -> 'a
val read_write_lists : read:'a regfun -> write:'a regfun -> Rtl.rtl -> 'a -> 'a
(*
  let read_write_sets read write rtl z =
    let rws = read_write_lists insert_left insert_right in
    let (readlist, writelist) = rws rtl (empty, empty) in
    fold_left read (fold_left write z writelist) readlist
*)
@ 
    
<<obsolete and deprecated?>>=
val width:      Rtl.exp -> int                 (* width of expression *)
  (* often faults with assertion failure *)
val assign:     Rtl.loc -> Rtl.exp -> Rtl.rtl
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlutil.ml>>=
module RP = Rtl.Private
let locwidth' = function
    | RP.Cell(_,_,w,_,_) -> w
    | RP.Var(_,_,w)      -> w
    | RP.Slice(w, _, _)  -> w
let locwidth l = locwidth' (Rtl.Convert.loc l)

let width e = match Rtl.Convert.exp e with
    | RP.Const(RP.Bool _)     -> assert false
    | RP.Const(RP.Bits (_,w)) -> w
    | RP.Const(RP.Link (_,w)) -> w
    | RP.Fetch(_,w)           -> w
    | RP.App _                -> assert false (* not implemented *)
    
let assign l r = Rtl.store l r (width r)
@ 

<<rtlutil.ml>>=
type 'a regfun = Rtl.space -> index:Base.std_int -> Rtl.width -> 'a -> 'a
let read_write_lists (read:'a regfun) (write:'a regfun) = 
  let rec rtl (z:'a) (RP.Rtl gs)  = List.fold_left guarded z gs
      and guarded z (g, eff) = exp (effect z eff) g
      and effect z eff = match eff with
        | RP.Store (lhs, rhs, _) -> loc write (exp z rhs) lhs
        | RP.Kill lhs -> loc write z lhs
      and loc which z l = match l with
        | RP.Cell (space, _, w, RP.Const (RP.Bits (index, w')), _) ->
            (try which space (Bits.to_int (index, w')) w (z:'a)
             with Bits.Overflow -> z)
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and index z l = match l with
        | RP.Cell (space, _, w, index, _) -> exp z index
        | RP.Slice (_, _, l) -> index z l
        | RP.Var _ -> z
      and exp z e = match e with
        | RP.Const _ -> z
        | RP.Fetch (l, w) -> loc read z l
        | RP.App (_, es) -> List.fold_left exp z es
  in  fun r z -> rtl z (Rtl.Convert.rtl r)


