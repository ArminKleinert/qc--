% vim: ts=8 sw=4 et: 

% ------------------------------------------------------------------ 
\section{Code-Expander for the Dummy Target}
% ------------------------------------------------------------------ 

The {\rtl}s generated by the \module{Ast3ir} module violate the machine
invariant that every {\rtl} must be representable as a machine
instruction. A code-expander establishes this invariant by simplifying
{\rtl}s. This module provides a toy code expander for the [[Dummy]]
target. Although it would be possible to write a generic code expander
that works for all targets, we keep things simple and write a
specialized one. The expander is specified as a set of {\burg} rules.

The idea of code expansion is to store intermediate results into
registers.  Registers come in different flavors (c.f.~module
\module{Targets}); we use the following notion: 

\begin{center}
\begin{tabular}{@{\quad}ll}
$r$& an integer hardware register, or an integer temporary\\
$f$& a floating-point hardware register or a floating-point temporary\\
$m$& memory space\\
$k$& non-bool constant\\
$\oplus$& {\rtl} integer {\rtl} operator \\
$\otimes$& {\rtl} floating-point {\rtl} operator \\
\end{tabular}
\end{center}

Or goal is, to re-write all {\rtl}s to the following form:

\begingroup
\def\gets{$\mathrel{:=}$}%
\let\mc\multicolumn

\begin{center}
\begin{tabular}{rcl@{\quad}l}
$r$     & \gets & $k$ & all constants are considered integers\\
$r$     & \gets & $r$ \\
$r$     & \gets & $\oplus(r, \ldots, r)$ \\
$r$     & \gets & $m[t]$ \\
$r$     & \gets & $f$ & conversion \\
\\ 
$f$     & \gets & $f$ \\
$f$     & \gets & $\otimes(f, \ldots, f)$ \\
$f$     & \gets & $m[t]$ \\
$f$     & \gets & $r$ & conversion\\
\\ 
$m[t]$  & \gets & $r$ & an address in an integer\\
$m[t]$  & \gets & $f$ \\
\end{tabular}
\end{center}
\endgroup

\begin{quote}\it
    What to do with boolean expressions? What to do with guarded
    effects? The code generator emits target-specific {\rtl}s for
    branches, jumps, and so on. There is a danger that we try to
    expand those, how do we avoid that?
\end{quote}

Locations are divided into memory, and registers. Registers are further
divided into floating-point and integer registers where a register is
either a hardware register or a temporary. Memory is addressed by
integer registers, {\rtl} operators take either integer or floating
point arguments and return integer or floating point results
respectively. 

The main point of code expansion is to eliminate complex expressions by
keeping their values in registers. The code passed to the expander
already includes some registers from calling conventions that we in
general do not want to replace. For this reason we only distinguish
between integer and floating point registers, but mostly do not enforce
that values are kept in temporaries. In particular, operands can be a
mix of temporaries and hardware registers holding either integers or
floating point values.

% ------------------------------------------------------------------ 
\subsection{Code Expansion with {\burg}}
% ------------------------------------------------------------------ 

A {\burg} specification consists of non-deterministic rules to cover a
tree. Code generated from that specification finds with dynamic
programming at run-time the rules that cover a given tree with minimal
cost. For code expansion the tree to be covered is an {\rtl}. For the
details of how {\burg} works, see the manual of {\small MLBURG} and
Fraser and Hanson: \textit{Engineering a Simple, Efficient Code
Generator Generator}, {\small ACM} Letters on Programming Languages and
Systems 1, 3 (Sep 1992), 213-226.

<<dummyexpander.mlb>>=
%head {: <<utilities>> :}    
<<terminal types>>
%tail {: <<tail>> :}
%%
<<rules>>
@

% ------------------------------------------------------------------ 
\subsection{Utilities for {\burg} actions}
% ------------------------------------------------------------------ 

To keep the semantic actions of {\burg} rules as simple as possible, we
provide some basic functions in the head of the specification and
abbreviate commonly used modules.

<<utilities>>=
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target2
module C  = Camlburg
module D  = Rtl.Convert      (* Convert Down to private repr. *)
module U  = Rtl.Revert       (* Convert Up    to abstract repr. *)
module W  = Rtlutil.Width 
module G  = Cfg3             (* for expanding all RTLs in a CFG *)
module GU = Cfgutil
@

Instead of the always useful [[assert false]] we raise a more
descriptive error. These errors are still considered to be fatal.

<<utilities>>=
exception Error of string
let error msg = raise (Error msg)
@

Most semantic actions transform an expression into a sequence of {\rtl}s
that evaluates the expression into a register and return that register.
Thus, two things are returned: the register where the expression's value
can be found, and the sequence of {\rtl}s. To avoid decomposing returned
pairs, these semantic actions are implemented as a state monad: the
state is the list of accumulated {\rtl}s and a source for temporaries. A
monadic action takes the state, and produces a pair of a new result and
a new state:

<<utilities>>=
type state = R.rtl list * Talloc.Multiple.t
type 'a m  = state -> ('a * state)
@

In particular, we save an {\rtl} in the state with [[exec]]. {\rtl}s are
saved in \emph{reverse exceution order}.

<<utilities>>=
let exec  rtl  = fun (rtls,tmp) -> ((), (rtl :: rtls,tmp)) 
@

The power of monads come from higher-order functions to deal with them.
Here are the standard functions, often called \emph{unit} and
\emph{bind}:

<<utilities>>=
let return a  = fun s -> (a, s)
let (>>=) (m: 'a m) (f: 'a -> 'b m) = fun s -> let (a,s) = m s in f a s 
@

We need a source for new temporaries; the functions [[itmp]] and
[[ftmp]] return a new temporary when applied to the desired width of the
new temporary.

<<utilities>>=
let itmp w = fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 't' w, state)
let ftmp w = fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'u' w, state)
@

{\rtl} operators do not distinguish between floating point and integer
values, but we assume the [[Dummy]] machine does. As an oversimplified
experiment, we declare the following operators to be floating point
operators, taking and yielding floating point values.

<<utilities>>=
module StringSet = Set.Make(struct type t = string let compare = compare end)

let float_ops = 
    List.fold_right 
        StringSet.add 
        ["fcmp"; "fadd"; "fsub"; "fdiv"; "fmul"; "fabs"; "fneg"; "fsqrt"]
        StringSet.empty
@

To simplify guarded effects we have to know which operators return
boolean values. All operators that take \emph{and} return boolean values
have been re-written into control-flow structures and do not show up
here. The operators listed here all take non-boolean arguments.

<<utilities>>=
let bool_ops = (* boolean valued primitive with non-boolean args *)
    List.fold_right
        StringSet.add
        ["bool"; "eq"; "ge"; "geu"; "gt"; "gtu"; "le"; "leu"; "lt"; "ltu";
         "ne"]
         StringSet.empty

let is_float_op (op,_) = StringSet.mem op float_ops
let is_bool_op  (op,_) = StringSet.mem op bool_ops
let is_int_op   opr    = not (is_float_op opr || is_bool_op opr) 
@

To create a fetch from a location we have to know the size of the
location. The [[fetch]] function makes this easy.

<<utilities>>=
let fetch t = R.fetch t (W.loc t)
@

% ------------------------------------------------------------------ 
\ssection{Code Expansion Rules}
% ------------------------------------------------------------------ 

A Variable in a rule pattern matches either an Objective Caml value, or
polymorphic {\burg} value. The Objective Caml values are called terminal
values and recognized by their terminal type. The following types are
terminal:

<<terminal types>>=
%term k width opr exps agg ass index bool bits link late x
@

Note, that in a {\burg} pattern a variable $v$ is an abbreviation for
$v:v$, i.e.~variable $v$ of type $v$. A variable [[width]] is thus
of type [[width]] and thus represents a terminal value.

{\rtl}s are mainly composed of expressions, locations and effects. The
code expander keeps the latter two and replaces an expression by a location
that hold the expression's value. 

The following table summarizes the nonterminals in the rules and their
purpose. 

\begin{tabular}{ll}
    Nonterminal & Meaning \\ 
    \hline
    [[ireg]]        & register holding result of integer expression\\
                    & also used as general purpose location\\
    [[freg]]        & register holding result of floating-point expression\\
    [[creg]]        & control register\\
    [[mem]]         & memory location\\
    [[const]]       & constant value\\
    [[addr]]        & memory address\\
    [[fop]],[[rop]] & {\rtl} operator\\
    [[stmt]]        & side effect (like assignment)\\
\end{tabular}

The costs associated with burg rules usually reflect the number of
generated {\rtl}s. In addtion, we want to penalize the conversion
between integer and floating point registers. A missing cost annotation
defaults to zero.

A constant is loaded into a register. This does not work for boolean
constants! Do we have to treat the different constants seperately?

<<rules>>=
const:      Const(k)
            {: return (U.exp (RP.Const(k))) :}

-- r := k   
ireg:       const [1]
            {:  const                                >>= fun k ->
                itmp (W.exp k)                       >>= fun t  ->
                exec (R.store t k (W.exp k))         >>= fun () ->
                return t
            :}

-- r := $m[addr]            
ireg:       Fetch(mem,width) [1]
            {:  mem           >>= fun m ->
                itmp width    >>= fun t -> 
                exec (R.store t (R.fetch m width) width) >>= fun () ->
                return t
            :}    
@
Fetches from registers must not to be rewritten, but the fetch
instruction disappears. It is inserted when the value is used in
a right-hand-side context.

<<rules>>=
ireg:       Fetch(ireg,width) {: ireg :}

-- r := op(r,..,r)
ireg:       App(iop, iregs) [1]
            {:  
                iregs                                     >>= fun rs ->
                let fetches = List.map fetch rs           in 
                let exp     = R.app iop fetches           in
                let width   = W.exp exp                   in
                itmp width                                >>= fun t  ->
                exec (R.store t exp width)                >>= fun () ->
                return t
            :}
@

Floating-point expressions are analogously developed into floating-point
registers that hold the values.

<<rules>>=
-- f := $m[addr]
freg:       Fetch(mem,width) [1]
            {:  mem           >>= fun m ->
                ftmp width    >>= fun u -> 
                exec (R.store u (R.fetch m width) width) >>= fun () ->
                return u
            :}
            


freg:       Fetch(freg,width) {: freg :}    

-- f := op(f, .., f)
freg:       App(fop, fregs) [1]
            {:  
                fregs                                     >>= fun us ->
                let fetches = List.map fetch us           in 
                let exp     = R.app fop fetches           in
                let width   = W.exp exp                   in
                ftmp width                                >>= fun t  ->
                exec (R.store t (R.app fop fetches) width)>>= fun () ->
                return t
            :}
@            

Lists of expressions are decomposed into list of registers holding their
values. Lists are either for integer or floating-point values, but not
both.

<<rules>>=
iregs:      Nil() {: return [] :}
iregs:      Cons(ireg, iregs) 
            {:  ireg >>= fun r -> iregs >>= fun rs -> return (r::rs) :}


fregs:      Nil() {: return [] :}
fregs:      Cons(freg, fregs)
            {: freg  >>= fun u -> fregs >>= fun us -> return (u::us) :}
@

We expect memory locations, temporaries, and hardware registers in the
code to expand.  These locations are classified into memory and
integer/floating-point registers.  Memory is addressed by registers
([[addr]] is a synonym for [[ireg]], we might add [[const]] later) and
registers are addressed by [[const]].

<<rules>>=
addr:       ireg  {: ireg >>= fun r -> return (fetch r) :}


mem:        Cell('m', agg, width, addr, ass)
            {:  
                addr >>= fun a ->
                return (R.cell (U.assertion ass) 'm' agg width a) 
            :}
            
ireg:       Cell('r', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'r' agg width k) 
            :}
ireg:       Cell('t', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 't' agg width k) 
            :}


freg:       Cell('f', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'f' agg width k) 
            :}
freg:       Cell('u', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'u' agg width k) 
            :}

creg:       Cell('c', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'c' agg width k) 
            :}

error:      Cell(x:char, agg, width, addr, ass)
            {:
                error (Printf.sprintf "cell in space '%c'" x)
            :}    
@

Operators are classified to integer or floating-point operators. We use
a cost expression that is evaluated at run-time to classify an operator:
an integer operator is also considered a floating-point operator but is
associated with extreme costs and thus will be never selected.

<<rules>>=
fop:        Op(opr) [{: if is_float_op opr  then 0 else C.inf_cost :}] 
            {: U.opr opr :}

iop:        Op(opr) [{: if is_int_op opr    then 0 else C.inf_cost :}]
            {: U.opr opr :}

bop:        Op(opr) [{: if is_bool_op opr   then 0 else C.inf_cost :}]
            {: U.opr opr :}
@

To make sure we can cover every {\rtl} we can move integer registers
into floating-point temporairies, and floating-point registers into
integer temporaries. We do not like these conversions so we penalize
them with high costs. 

<<rules>>=
-- t := f
ireg:       freg [2]    
            {:  
                freg                                >>= fun u  ->
                let w = W.loc u in 
                itmp w                              >>= fun t  ->
                exec (R.store t (R.fetch u w) w)    >>= fun () ->
                return t
            :} 
-- f := t            
freg:       ireg [2]    
            {:  
                ireg                                >>= fun t ->
                let w = W.loc t in
                ftmp w                              >>= fun u  ->
                exec (R.store u (R.fetch t w) w)    >>= fun () ->
                return u
            :} 
@


{\rtl} effects are covered by the [[stmt]] nonterminal. We allow
only very simple assignments between registers of the same class and
registers and memory. In particular, constants cannot be written to
memory, and no memory-memory transfer is allowed. 

<<rules>>=
-- m[addr] := r
stmt:       Store(mem, ireg, width)
            {: 
                mem  >>= fun m ->
                ireg >>= fun r ->
                return (R.store m (R.fetch r width) width) 
            :}

-- m[addr] := f
stmt:       Store(mem, freg, width)
            {: 
                mem  >>= fun m ->
                freg >>= fun r ->
                return (R.store m (R.fetch r width) width)
            :}
-- r := r        
stmt:       Store(left:ireg, right:ireg, width)
            {:
                left  >>= fun l ->
                right >>= fun r ->
                return (R.store l (R.fetch r width) width)
            :}    
-- f := f
stmt:       Store(left:freg, right:freg, width)
            {:
                left  >>= fun l ->
                right >>= fun r ->
                return (R.store l (R.fetch r width) width)
            :}    

-- c := t (assignment to PC is the only case in the Dummy target)
stmt:       Store(creg, ireg, width)
            {:
                creg  >>= fun c ->
                ireg  >>= fun r ->
                return (R.store c (R.fetch r width) width)
            :}    

@

Currently the frontend generates guarded expression only for
if-statements. The expression is already simplified such that it is
either [[true]], [[false]], or an application with a boolean result that
takes \emph{non-boolean} arguments. 

I don't know how to handle guarded statements. The guard expression is a
boolean expression. For the moment I treat the guard as a literal and do
not expand it.

<<rules>>=
guard:      True()  {: return (R.bool true)  :}
guard:      False() {: return (R.bool false) :}
guard:      App(bop, iregs)
            {:  
                iregs >>= fun rs ->
                return (R.app bop (List.map fetch rs))
            :}    

gstmt:      GStmt(guard,stmt)
            {: 
                guard >>= fun g ->
                stmt  >>= fun s -> 
                return (R.guard g s) 
            :}

gstmts:     Nil() {:  return [] :}
gstmts:     Cons(gstmt,gstmts)
            {: gstmt  >>= fun s  -> gstmts >>= fun ss -> return (s::ss) :}
@

An {\rtl} is a list of guarded statements. 

<<rules>>=
rtl:        Rtl(gstmts) [1]
            {:
                gstmts            >>= fun rtls ->
                exec (R.par rtls) >>= fun ()  ->
                return ()
            :}
@

Here are the cases we cannot handle (yet). 

<<rules>>=
error:      Kill()
            {: error "cannot handle Kill" :}

error:      Var()
            {: error "Var constructor" :}

error:      Slice()
            {: error "Slice constrictor" :}
@

% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

The code generated from {\burg} rules knows nothing about {\rtl}s. In
order to expand an {\rtl}, we have to traverse it and pass the different
parts to the generated functions whose names we know from the {\small
MLBURG} manual. This code follows here. 

<<tail>>=
let rec map f = function
    | []                        -> conNil ()
    | x::xs                     -> conCons (f x) (map f xs)
@    
  
Make sure that the above function [[map]] is \emph{not} in the same
[[letrec]] as the functions below. In that case it becomes monomorphic
and the code below will not type check! This mistake has taken me some
time to spot.

<<tail>>=  
let rec exp = function
    | RP.Const(RP.Bool(true))   -> conTrue()
    | RP.Const(RP.Bool(false))  -> conFalse()
    | RP.Const(k)               -> conConst(k)
    | RP.Fetch(l,w)             -> conFetch (loc l) w
    | RP.App(opr,exps)          -> conApp (conOp opr) (map exp exps)

and loc = function
    | RP.Cell(char, aff, w, e, ass) -> conCell char aff w (exp e) ass 
    | RP.Var(s, i, w)           -> conVar ()
    | RP.Slice(w,i,loc)         -> conSlice ()
    
and stmt = function
    | RP.Store(l,e,w)           -> conStore (loc l) (exp e) w
    | RP.Kill(loc)              -> conKill ()

and guarded (e,eff)             =  conGStmt (exp e) (stmt eff)

and rtl = function
    | RP.Rtl(gs)                -> conRtl (map guarded gs)
@

The [[rtl]] function returns (the best) plan to rewrite a given {\rtl}.
When this plan is executed, it returns a monadic value that includes the
desired expanded {\rtl}s.

<<tail>>=
let expand tmps (r: R.rtl) = 
    let plan = rtl (D.rtl r) in
    try
        match plan.rtl.Camlburg.action () ([],tmps) with
            | (), (rtls,_) -> rtls
    with 
        Camlburg.Uncovered -> 
            ( List.iter prerr_endline
                [ "cannot expand this RTL:"
                ; RU.ToString.rtl r
                ]
            ; assert false
            )
@                        

% ------------------------------------------------------------------ 
\subsection{Expanding an entire {\cfg}}
% ------------------------------------------------------------------ 

{\rtl}s do not live in isolation but belong to a procedure's {\cfg}.
Since procedures are the basic units of compilation we want to expand
all the {\rtl}s of a procedure. This requires to re-write the {\cfg}.

Re-writing the {\cfg} mutates its structure and therefore we have to
obtain first all the nodes whose {\rtl}s we want to expand. We cannot
use the iterator provided by the {\cfg} module because it does not work
under mutation.

[[Cfg]] expands all {\rtl}s of a procedure and returns [[true]], if the 
structure of the procedure's {\cfg} had to be modified.

<<tail>>=
let cfg proc =
    let nodes       = GU.fold_bwd proc.Proc.cfg (fun n ns -> n::ns) []
    and tmps        = proc.Proc.temps   (* source for temporaries *)
    and insert n i  = G.gm_insert_assign_before i n
    and modified    = ref false in
    let expnd node =
        match expand tmps (G.rtl node) with
        | last :: preds ->
            ( ignore (List.fold_left insert node preds)
            ; G.set_rtl node (fun _ -> last)
            ; modified := (preds <> [])
            )
        | [] -> assert false 
    in    
        ( List.iter expnd nodes
        ; !modified
        )
@

% ------------------------------------------------------------------ 
\subsection{Exporting the Expander to Lua}
% ------------------------------------------------------------------ 

Code expansion is part of {\qcc}'s backend that is controlled by a Lua
interpreter. To make the expander accessible for Lua code, it is
exported as a Lua primitive [[Dummyexpand.expand]].

<<tail>>=
module Make (ProcT: Lua.Lib.TYPEVIEW with type 'a t = Proc.t): 
    Lua.Lib.TYPEFUL with type 'a combined = 'a ProcT.combined =
struct
    type 'a combined = 'a ProcT.combined
    module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
    struct
        <<export expander>>
        let init = C.register_module "Dummyexpand" builtins
    end (*M*)    
end (*Make*)            

<<export expander>>=
module V  = C.V

let ( **-> ) = V.( **-> )
let proc     = ProcT.makemap V.userdata V.projection
let pf t     = (V.pfunc t).V.embed    (* pure Lua function *)

let builtins =
    [ "expand" , pf (V.value **-> proc **-> V.result V.bool) (fun _ -> cfg)
    ]
@

