% vim: ts=8 sw=4 et: 

% ------------------------------------------------------------------ 
\section{Code-Expander for the Dummy Target}
% ------------------------------------------------------------------ 

The {\rtl}s generated by the \module{Ast3ir} module violate the machine
invariant that every {\rtl} must be representable as a machine
instruction. A code-expander establishes this invariant by simplifying
{\rtl}s. This module provides a toy code expander for the [[Dummy]]
target. Although it would be possible to write a generic code expander
that works for all targets, we keep things simple and write a
specialized one. The expander is specified as a set of {\burg} rules.

The idea of code expansion is to store intermediate results into
registers.  Registers come in different flavors (c.f.~module
\module{Targets}); we use the following notion: 

\begin{center}
\begin{tabular}{@{\quad}ll}
$r$& an integer hardware register, or an integer temporary\\
$f$& a floating-point hardware register or a floating-point temporary\\
$m$& memory space\\
$k$& non-bool constant\\
$\oplus$& {\rtl} integer {\rtl} operator \\
$\otimes$& {\rtl} floating-point {\rtl} operator \\
\end{tabular}
\end{center}

Or goal is, to re-write all {\rtl}s to the following form:

\begingroup
\def\gets{$\mathrel{:=}$}%
\let\mc\multicolumn

\begin{center}
\begin{tabular}{rcl@{\quad}l}
$r$     & \gets & $k$ & all constants are considered integers\\
$r$     & \gets & $r$ \\
$r$     & \gets & $\oplus(r, \ldots, r)$ \\
$r$     & \gets & $m[t]$ \\
$r$     & \gets & $f$ & conversion \\
\\ 
$f$     & \gets & $f$ \\
$f$     & \gets & $\otimes(f, \ldots, f)$ \\
$f$     & \gets & $m[t]$ \\
$f$     & \gets & $r$ & conversion\\
\\ 
$m[t]$  & \gets & $r$ & an address in an integer\\
$m[t]$  & \gets & $f$ \\
\end{tabular}
\end{center}
\endgroup

\begin{quote}\it
    What to do with boolean expressions? What to do with guarded
    effects? The code generator emits target-specific {\rtl}s for
    branches, jumps, and so on. There is a danger that we try to
    expand those, how do we avoid that?
\end{quote}

Locations are divided into memory, and registers. Registers are further
divided into floating-point and integer registers where a register is
either a hardware register or a temporary. Memory is addressed by
integer registers, {\rtl} operators take either integer or floating
point arguments and return integer or floating point results
respectively. 

The main point of code expansion is to eliminate complex expressions by
keeping their values in registers. The code passed to the expander
already includes some registers from calling conventions that we in
general do not want to replace. For this reason we only distinguish
between integer and floating point registers, but mostly do not enforce
that values are kept in temporaries. In particular, operands can be a
mix of temporaries and hardware registers holding either integers or
floating point values.

% ------------------------------------------------------------------ 
\subsection{Code Expansion with {\burg}}
% ------------------------------------------------------------------ 

A {\burg} specification consists of non-deterministic rules to cover a
tree. Code generated from that specification finds with dynamic
programming at run-time the rules that cover a given tree with minimal
cost. For code expansion the tree to be covered is an {\rtl}. For the
details of how {\burg} works, see the manual of {\small MLBURG} and
Fraser and Hanson: \textit{Engineering a Simple, Efficient Code
Generator Generator}, {\small ACM} Letters on Programming Languages and
Systems 1, 3 (Sep 1992), 213-226.

<<dummyexpander.mlb>>=
%head {: <<utilities>> :}    
<<terminal types>>
%tail {: <<tail>> :}
%%
<<rules>>
@

% ------------------------------------------------------------------ 
\subsection{Utilities for {\burg} actions}
% ------------------------------------------------------------------ 

To keep the semantic actions of {\burg} rules as simple as possible, we
provide some basic functions in the head of the specification and
abbreviate commonly used modules.

<<utilities>>=
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target2
module C  = Camlburg
module D  = Rtl.Convert      (* Convert Down to private repr. *)
module U  = Rtl.Revert       (* Convert Up    to abstract repr. *)
module W  = Rtlutil.Width 
module G  = Cfg4             (* for expanding all RTLs in a CFG *)
module GU = Cfgutil
@

Instead of the always useful [[assert false]] we raise a more
descriptive error. These errors are still considered to be fatal.

<<utilities>>=
exception Error of string
let error msg = raise (Error msg)
@

Most semantic actions transform an expression into a sequence of {\rtl}s
that evaluates the expression into a register and return that register.
Thus, two things are returned: the register where the expression's value
can be found, and the sequence of {\rtl}s. To avoid decomposing returned
pairs, these semantic actions are implemented as a state monad: the
state is the list of accumulated {\rtl}s and a source for temporaries. A
monadic action takes the state, and produces a pair of a new result and
a new state:

<<utilities>>=
type state = R.rtl list * Talloc.Multiple.t
type 'a m  = state -> ('a * state)
@

In particular, we save an {\rtl} in the state with [[exec]]. {\rtl}s are
saved in \emph{reverse exceution order}.

<<utilities>>=
let exec  rtl  = fun (rtls,tmp) -> ((), (rtl :: rtls,tmp)) 
@

The power of monads come from higher-order functions to deal with them.
Here are the standard functions, often called \emph{unit} and
\emph{bind}:

<<utilities>>=
let return a  = fun s -> (a, s)
let (>>=) (m: 'a m) (f: 'a -> 'b m) = fun s -> let (a,s) = m s in f a s 
@

We need a source for new temporaries; the functions [[itmp]] and
[[ftmp]] return a new temporary when applied to the desired width of the
new temporary.

<<utilities>>=
let itmp = function
    | 32 -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 't' 32, state)
    | 8  -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'v'  8, state)
    | w  -> Impossible.impossible 
                (Printf.sprintf "unsupported width for int register: %d" w)
let ftmp = function
    | 32 -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'u' 32, state)
    | w  -> Impossible.impossible 
                (Printf.sprintf "unsupported width for float register: %d" w)
@

{\rtl} operators do not distinguish between floating point and integer
values, but we assume the [[Dummy]] machine does. As an oversimplified
experiment, we declare the following operators to be floating point
operators, taking and yielding floating point values.

<<utilities>>=
module StringSet = Set.Make(struct type t = string let compare = compare end)
@

To simplify guarded effects we have to know which operators return
boolean values. All operators that take \emph{and} return boolean values
have been re-written into control-flow structures and do not show up
here. The operators listed here all take non-boolean arguments.

<<utilities>>=
let bool_ops2 = (* boolean valued primitive with non-boolean args *)
    List.fold_right StringSet.add
        ["eq"; "ge"; "geu"; "gt"; "gtu"; "le"; "leu"; "lt"; "ltu"; "ne"]
         StringSet.empty

let is_bool_op2  op     = StringSet.mem op bool_ops2
let is_bool_op1  op     = op = "bool"
@

To create a fetch from a location we have to know the size of the
location. The [[fetch]] function makes this easy.

<<utilities>>=
let fetch t = R.fetch t (W.loc t)

let app1 tmp s x arg1 =
    arg1 >>= fun a1 ->
    let opr   = R.opr s x in
    let exp   = R.app opr [fetch a1] in
    let width = W.exp exp in
    tmp width >>= fun t ->
    exec (R.store t exp width) >>= fun () ->
    return t

let app2 tmp s x arg1 arg2 =
    arg1 >>= fun a1 -> arg2 >>= fun a2 ->
    let opr   = R.opr s x in
    let exp   = R.app opr [fetch a1; fetch a2] in
    let width = W.exp exp in
    tmp width >>= fun t ->
    exec (R.store t exp width) >>= fun () ->
    return t

let app3 tmp s x arg1 arg2 arg3 =
    arg1 >>= fun a1 -> arg2 >>= fun a2 -> arg3 >>= fun a3 ->
    let opr   = R.opr s x in
    let exp   = R.app opr [fetch a1; fetch a2; fetch a3] in
    let width = W.exp exp in
    tmp width >>= fun t ->
    exec (R.store t exp width) >>= fun () ->
    return t
@

% ------------------------------------------------------------------ 
\ssection{Code Expansion Rules}
% ------------------------------------------------------------------ 

A Variable in a rule pattern matches either an Objective Caml value, or
polymorphic {\burg} value. The Objective Caml values are called terminal
values and recognized by their terminal type. The following types are
terminal:

<<terminal types>>=
%term k width opr exps agg ass index bool bits link late x
@

Note, that in a {\burg} pattern a variable $v$ is an abbreviation for
$v:v$, i.e.~variable $v$ of type $v$. A variable [[width]] is thus
of type [[width]] and thus represents a terminal value.

{\rtl}s are mainly composed of expressions, locations and effects. The
code expander keeps the latter two and replaces an expression by a location
that hold the expression's value. 

The following table summarizes the nonterminals in the rules and their
purpose. 

\begin{tabular}{ll}
    Nonterminal & Meaning \\ 
    \hline
    [[ireg]]        & register holding result of integer expression\\
                    & also used as general purpose location\\
    [[freg]]        & register holding result of floating-point expression\\
    [[creg]]        & control register\\
    [[mem]]         & memory location\\
    [[const]]       & constant value\\
    [[addr]]        & memory address\\
    [[fop]],[[rop]] & {\rtl} operator\\
    [[stmt]]        & side effect (like assignment)\\
\end{tabular}

The costs associated with burg rules usually reflect the number of
generated {\rtl}s. In addtion, we want to penalize the conversion
between integer and floating point registers. A missing cost annotation
defaults to zero.

A constant is loaded into a register. This does not work for boolean
constants! Do we have to treat the different constants seperately?

<<rules>>=
const:      Const(k)
            {: return (U.exp (RP.Const(k))) :}

-- r := k   
ireg:       const [1]
            {:  const                                >>= fun k ->
                itmp (W.exp k)                       >>= fun t  ->
                exec (R.store t k (W.exp k))         >>= fun () ->
                return t
            :}

-- r := $m[addr]            
ireg:       Fetch(mem,width) [1]
            {:  mem           >>= fun m ->
                itmp width    >>= fun t -> 
                exec (R.store t (R.fetch m width) width) >>= fun () ->
                return t
            :}  
            
-- f := $m[addr]
freg:       Fetch(mem,width) [1]
            {:  mem           >>= fun m ->
                ftmp width    >>= fun u -> 
                exec (R.store u (R.fetch m width) width) >>= fun () ->
                return u
            :}
@

Fetches from registers must not to be rewritten, but the fetch
instruction disappears. It is inserted when the value is used in
a right-hand-side context.

<<rules>>=
ireg:       Fetch(ireg,width) {: ireg :}
freg:       Fetch(freg,width) {: freg :}    
dreg:       Fetch(dreg,width) {: dreg :} 
@

Applications.

<<rules>>=
ireg:       App1("com",  x, r1:ireg)          {: app1 itmp "com"  x r1 :}
ireg:       App1("lobits", x, r1:ireg)        {: app1 itmp "lobits" x r1 :}
ireg:       App1("sx",  x, r1:ireg)           {: app1 itmp "sx"  x r1 :}
ireg:       App1("zx",  x, r1:ireg)           {: app1 itmp "zx"  x r1 :}

<<rules>>=
ireg:       App2("add",  x, r1:ireg, r2:ireg) {: app2 itmp "add"  x r1 r2 :}
ireg:       App2("div",  x, r1:ireg, r2:ireg) {: app2 itmp "div"  x r1 r2 :}
ireg:       App2("divu", x, r1:ireg, r2:ireg) {: app2 itmp "divu" x r1 r2 :}
ireg:       App2("mod",  x, r1:ireg, r2:ireg) {: app2 itmp "mod"  x r1 r2 :}
ireg:       App2("modu", x, r1:ireg, r2:ireg) {: app2 itmp "modu" x r1 r2 :}
ireg:       App2("mul",  x, r1:ireg, r2:ireg) {: app2 itmp "mul"  x r1 r2 :}
ireg:       App2("mulu", x, r1:ireg, r2:ireg) {: app2 itmp "mulu" x r1 r2 :}
ireg:       App2("quot", x, r1:ireg, r2:ireg) {: app2 itmp "quot" x r1 r2 :}
ireg:       App2("rem",  x, r1:ireg, r2:ireg) {: app2 itmp "rem"  x r1 r2 :}
ireg:       App2("rotl", x, r1:ireg, r2:ireg) {: app2 itmp "rotl" x r1 r2 :}
ireg:       App2("rotr", x, r1:ireg, r2:ireg) {: app2 itmp "rotr" x r1 r2 :}
ireg:       App2("shl",  x, r1:ireg, r2:ireg) {: app2 itmp "shl"  x r1 r2 :}
ireg:       App2("shra", x, r1:ireg, r2:ireg) {: app2 itmp "shra" x r1 r2 :}
ireg:       App2("shrl", x, r1:ireg, r2:ireg) {: app2 itmp "shrl" x r1 r2 :}
ireg:       App2("sub",  x, r1:ireg, r2:ireg) {: app2 itmp "sub"  x r1 r2 :}

freg:       App1("fneg", x, r1:freg)          {: app1 ftmp "fneg" x r1 :}

freg:       App2("f2i",  x, r1:freg, r2:ireg) {: app2 ftmp "f2i"  x r1 r2 :}
freg:       App2("fadd", x, r1:freg, r2:freg) {: app2 ftmp "fadd" x r1 r2 :}
freg:       App2("fdiv", x, r1:freg, r2:freg) {: app2 ftmp "fdiv" x r1 r2 :}
freg:       App2("fmul", x, r1:freg, r2:freg) {: app2 ftmp "fmul" x r1 r2 :}
freg:       App2("fsub", x, r1:freg, r2:freg) {: app2 ftmp "fsub" x r1 r2 :}

<<rules off>>=
-- When these rules are active, certain RTLs that don't use these
-- operators fail to expand. I dunno why. Bug in OCamlBurg?

freg:       App2("i2f",  x, r1:ireg, r2:dreg) {: app2 ftmp "i2f"  x r1 r2 :}
freg:       App2("f2f",  x, r1:ireg, r2:dreg) {: app2 ftmp "f2f"  x r1 r2 :}

<<rules off>>=
-- catch all rules with high costs
ireg:       App1(s:string, x, r:ireg) [20] 
            {: app1 itmp s x r :}
ireg:       App2(s:string, x, r1:ireg, r2:ireg) [20] 
            {: app2 itmp s x r1 r2 :}
ireg:       App3(s:string, x, r1:ireg, r2:ireg, r3:ireg) [20] 
            {: app3 itmp s x r1 r2 r3 :}

freg:       App1(s:string, x, r:freg) [20] 
            {: app1 ftmp s x r :}
freg:       App2(s:string, x, r1:freg, r2:freg) [20] 
            {: app2 ftmp s x r1 r2 :}
freg:       App3(s:string, x, r1:freg, r2:freg, r3:freg) [20] 
            {: app3 ftmp s x r1 r2 r3 :}


<<rules>>=
--
-- Floating point comparison results are ALWAYS stored in a hardware
-- register. This is a hack.
--

dreg:      App2("fcmp", x, f1:freg, f2:freg) [1]
            {:
                f1 >>= fun f1 -> f2 >>= fun f2 ->
                let o  = R.opr "fcmp" x in
                let exp     = R.app o (List.map fetch [f1;f2]) in
                let const n width = R.bits (Bits.U.of_int n width) width in
                let fpcond n = R.cell R.none 'd' R.Identity  2 (const n 2) in
                let r        = fpcond 1 in
                exec (R.store r exp 2) >>= fun () ->
                return r
            :}    
@


We expect memory locations, temporaries, and hardware registers in the
code to expand.  These locations are classified into memory and
integer/floating-point registers.  Memory is addressed by registers
([[addr]] is a synonym for [[ireg]], we might add [[const]] later) and
registers are addressed by [[const]].

<<rules>>=
addr:       ireg  {: ireg >>= fun r -> return (fetch r) :}


mem:        Cell('m', agg, width, addr, ass)
            {:  
                addr >>= fun a ->
                return (R.cell (U.assertion ass) 'm' agg width a) 
            :}

-- ireg == r/t (32) and g/v (8)
ireg:       Cell('r', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'r' agg width k) 
            :}
ireg:       Cell('t', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 't' agg width k) 
            :}
ireg:       Cell('g', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'g' agg width k) 
            :}
ireg:       Cell('v', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'v' agg width k) 
            :}

-- freg == f/u (32)
freg:       Cell('f', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'f' agg width k) 
            :}
freg:       Cell('u', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'u' agg width k) 
            :}

-- dreg == d (2)
dreg:       Cell('d', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'd' agg width k) 
            :}

--
creg:       Cell('c', agg, width, const, ass)
            {: 
                const >>= fun k ->
                return (R.cell (U.assertion ass) 'c' agg width k) 
            :}

error:      Cell(x:char, agg, width, addr, ass) [10]
            {:
                error (Printf.sprintf "cell in space '%c'" x)
            :}    
@

To make sure we can cover every {\rtl}, we allow to move integer
registers into floating-point temporaries, and floating-point registers
into integer temporaries.  We do not like these conversions so we
penalize them with high costs. 

<<rules>>=
-- t := f
ireg:       freg [10]    
            {:  
                freg                                >>= fun u  ->
                let w = W.loc u in 
                itmp w                              >>= fun t  ->
                exec (R.store t (R.fetch u w) w)    >>= fun () ->
                return t
            :} 

-- f := t            
freg:       ireg [10]    
            {:  
                ireg                                >>= fun t ->
                let w = W.loc t in
                ftmp w                              >>= fun u  ->
                exec (R.store u (R.fetch t w) w)    >>= fun () ->
                return u
            :} 
@

{\rtl} effects are covered by the [[stmt]] nonterminal. We allow
only very simple assignments between registers of the same class and
registers and memory. In particular, constants cannot be written to
memory, and no memory-memory transfer is allowed. 

<<rules>>=
-- m[addr] := r
stmt:       Store(mem, ireg, width)
            {: 
                mem  >>= fun m ->
                ireg >>= fun r ->
                return (R.store m (R.fetch r width) width) 
            :}

-- m[addr] := f
stmt:       Store(mem, freg, width)
            {: 
                mem  >>= fun m ->
                freg >>= fun r ->
                return (R.store m (R.fetch r width) width)
            :}
-- r := r        
stmt:       Store(left:ireg, right:ireg, width)
            {:
                left  >>= fun l ->
                right >>= fun r ->
                return (R.store l (R.fetch r width) width)
            :}    
-- f := f
stmt:       Store(left:freg, right:freg, width)
            {:
                left  >>= fun l ->
                right >>= fun r ->
                return (R.store l (R.fetch r width) width)
            :}    

-- c := t (assignment to PC is the only case in the Dummy target)
stmt:       Store(creg, ireg, width) [1]
            {:
                creg  >>= fun c ->
                ireg  >>= fun r ->
                return (R.store c (R.fetch r width) width)
            :}    
-- c := k
stmt:       Store(creg, const, width)
            {:
                creg  >>= fun c ->
                const >>= fun k ->
                return (R.store c k width)
            :}    

-- d := d
stmt:       Store(left:dreg, right:dreg, width)
            {:
                left  >>= fun l ->
                right >>= fun r ->
                return (R.store l (R.fetch r width) width)
            :}    
@

Currently the frontend generates guarded expression only for
if-statements. The expression is already simplified such that it is
either [[true]], [[false]], or an application with a boolean result that
takes \emph{non-boolean} arguments. 

I don't know how to handle guarded statements. The guard expression is a
boolean expression. For the moment I treat the guard as a literal and do
not expand it.

<<rules>>=
guard:      True()  {: return (R.bool true)  :}
guard:      False() {: return (R.bool false) :}

guard:      App2(o:string, x, r1:ireg, r2:ireg) 
            [{: if is_bool_op2 o then 0 else C.inf_cost  :}]
            {:  
                r1 >>= fun r1 -> r2 >>= fun r2 ->
                let opr = R.opr o x in
                return (R.app opr [fetch r1; fetch r2])
            :}    

-- we need an extra rule for floating point results that always
-- stay in 'd' space.

guard:      App2(o:string, x, r1:dreg, r2:dreg) 
            [{: if is_bool_op2 o then 0 else C.inf_cost  :}]
            {:  
                r1 >>= fun r1 -> r2 >>= fun r2 ->
                let opr = R.opr o x in
                return (R.app opr [fetch r1; fetch r2])
            :}    

guard:      App1(o:string, x, r1:ireg)
            [{: if is_bool_op1 o then 0 else C.inf_cost  :}]
            {:  
                r1 >>= fun r1 -> 
                let opr = R.opr o x in
                return (R.app opr [fetch r1])
            :}    
           
gstmt:      GStmt(guard,stmt)
            {: 
                guard >>= fun g ->
                stmt  >>= fun s -> 
                return (R.guard g s) 
            :}

gstmts:     Nil() {:  return [] :}
gstmts:     Cons(gstmt,gstmts)
            {: gstmt  >>= fun s  -> gstmts >>= fun ss -> return (s::ss) :}
@

An {\rtl} is a list of guarded statements. 

<<rules>>=
rtl:        Rtl(gstmts) [1]
            {:
                gstmts            >>= fun rtls ->
                exec (R.par rtls) >>= fun ()  ->
                return ()
            :}
@

Here are the cases we cannot handle (yet). 

<<rules>>=
error:      Kill()
            {: error "cannot handle Kill" :}

error:      Var()
            {: error "Var constructor" :}

error:      Slice()
            {: error "Slice constrictor" :}
@

% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

The code generated from {\burg} rules knows nothing about {\rtl}s. In
order to expand an {\rtl}, we have to traverse it and pass the different
parts to the generated functions whose names we know from the {\small
MLBURG} manual. This code follows here. 

<<tail>>=
let rec map f = function
    | []                        -> conNil ()
    | x::xs                     -> conCons (f x) (map f xs)
@    
  
Make sure that the above function [[map]] is \emph{not} in the same
[[letrec]] as the functions below. In that case it becomes monomorphic
and the code below will not type check! This mistake has taken me some
time to spot.

<<tail>>=  
let rec exp = function
    | RP.Const(RP.Bool(true))   -> conTrue()
    | RP.Const(RP.Bool(false))  -> conFalse()
    | RP.Const(k)               -> conConst(k)
    | RP.Fetch(l,w)             -> conFetch (loc l) w
    | RP.App((o,x),[e1])        -> conApp1 o x (exp e1)
    | RP.App((o,x),[e1;e2])     -> conApp2 o x (exp e1) (exp e2)
   (*
    | RP.App((o,x),[e1;e2;e3])  -> conApp3 o x (exp e1) (exp e2) (exp e3)
    *)
    | _                         -> error "application with too many args"

and loc = function
    | RP.Cell(char, aff, w, e, ass) -> conCell char aff w (exp e) ass 
    | RP.Var(s, i, w)           -> conVar ()
    | RP.Slice(w,i,loc)         -> conSlice ()
    
and stmt = function
    | RP.Store(l,e,w)           -> conStore (loc l) (exp e) w
    | RP.Kill(loc)              -> conKill ()

and guarded (e,eff)             =  conGStmt (exp e) (stmt eff)

and rtl = function
    | RP.Rtl(gs)                -> conRtl (map guarded gs)
@

The [[rtl]] function returns (the best) plan to rewrite a given {\rtl}.
When this plan is executed, it returns a monadic value that includes the
desired expanded {\rtl}s.

<<tail>>=
let expand tmps (r: R.rtl) = 
    let plan = rtl (D.rtl r) in
    try
        match plan.rtl.Camlburg.action () ([],tmps) with
            | (), (rtls,_) -> rtls
    with 
        Camlburg.Uncovered -> 
            ( List.iter prerr_endline
                [ "cannot expand this RTL:"
                ; RU.ToString.rtl r
                ]
            ; assert false
            )
@                        

% ------------------------------------------------------------------ 
\subsection{Expanding an entire {\cfg}}
% ------------------------------------------------------------------ 

{\rtl}s do not live in isolation but belong to a procedure's {\cfg}.
Since procedures are the basic units of compilation we want to expand
all the {\rtl}s of a procedure. This requires to re-write the {\cfg}.

Re-writing the {\cfg} mutates its structure and therefore we have to
obtain first all the nodes whose {\rtl}s we want to expand. We cannot
use the iterator provided by the {\cfg} module because it does not work
under mutation.

[[Cfg]] expands all {\rtl}s of a procedure and returns [[true]], if the 
structure of the procedure's {\cfg} had to be modified.

<<tail>>=
let cfg proc =
    let nodes       = GU.fold_bwd proc.Proc.cfg (fun n ns -> n::ns) []
    and tmps        = proc.Proc.temps   (* source for temporaries *)
    and insert n i  = G.gm_insert_assign_before i n
    and modified    = ref false in
    let expnd node =
        match expand tmps (G.instr node) with
        | last :: preds ->
            ( ignore (List.fold_left insert node preds)
            ; G.upd_instr node (fun _ -> last)
            ; modified := (preds <> [])
            )
        | [] -> assert false 
    in    
        ( List.iter expnd nodes
        ; !modified
        )
@

% ------------------------------------------------------------------ 
\subsection{Exporting the Expander to Lua}
% ------------------------------------------------------------------ 

Code expansion is part of {\qcc}'s backend that is controlled by a Lua
interpreter. To make the expander accessible for Lua code, it is
exported as a Lua primitive [[Dummyexpand.expand]].

<<tail>>=
module Make (ProcT: Lua.Lib.TYPEVIEW with type 'a t = Proc.t): 
    Lua.Lib.TYPEFUL with type 'a combined = 'a ProcT.combined =
struct
    type 'a combined = 'a ProcT.combined
    module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
    struct
        <<export expander>>
        let init = C.register_module "Dummyexpand" builtins
    end (*M*)    
end (*Make*)            

<<export expander>>=
module V  = C.V

let ( **-> ) = V.( **-> )
let proc     = ProcT.makemap V.userdata V.projection
let pf t     = (V.pfunc t).V.embed    (* pure Lua function *)

let builtins =
    [ "expand" , pf (V.value **-> proc **-> V.result V.bool) (fun _ -> cfg)
    ]
@

