% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

% ------------------------------------------------------------------ 
\section{Values}
% ------------------------------------------------------------------ 

{\PAL} treats values a vector of bits and makes no differences between
signed, unsigned, floating point, or integer values.  Constant
expressions are evaluated at compile-time and produce such values. 
This module provides a representation and operations on them.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

<<value.mli>>=
type value  = Bits of Bits.bits
            | Bool of bool

module Ops  : Map.S with type key = string
val ops     : ((value list -> value) * Types.tyscheme) Ops.t
val lookup  : string -> 'a Ops.t -> 'a
@


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<value.ml>>=
module T = Types
module B = Bits

type value  = Bits of Bits.bits
            | Bool of bool

module Ops  = Map.Make(struct type t=string let compare=compare end)

let lookup key env = 
    try Ops.find key env with | Not_found -> Error.error ("unknown operator")

let enter pairs env = 
    let f env (key,value) = Ops.add key value env in 
        List.fold_left f env pairs

let zero = function
    | [Bits(x);Bits(y)] -> Bits(B.zero (B.width x))
    | _                 -> assert false

let true' = function
    | [Bits(_);Bits(_)] -> Bool(true)
    | _                 -> assert false

let ops = enter
    [  "add"    , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  "+"      , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  "sub"    , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  "-"      , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  "mult"   , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  "shl"    , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  "shra"   , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  "shrl"   , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  "<<"     , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  ">>"     , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  "*"      , (zero  , T.proc [T.bitsv 1; T.bitsv 1] (T.bitsv 1))
    ;  "eq"     , (true' , T.proc [T.bitsv 1; T.bitsv 1] T.bool)
    ;  "=="     , (true' , T.proc [T.bitsv 1; T.bitsv 1] T.bool)
    ;  "<="     , (true' , T.proc [T.bitsv 1; T.bitsv 1] T.bool)
    ;  ">="     , (true' , T.proc [T.bitsv 1; T.bitsv 1] T.bool)
    ;  ">"      , (true' , T.proc [T.bitsv 1; T.bitsv 1] T.bool)
    ;  "<"      , (true' , T.proc [T.bitsv 1; T.bitsv 1] T.bool)
    ;  "!="     , (true' , T.proc [T.bitsv 1; T.bitsv 1] T.bool)
    ] Ops.empty
@

