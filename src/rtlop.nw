% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------ 
\section{Translation of {\PAL} operators to RTL operators}
% ------------------------------------------------------------------ 

This module provides the translation of a {\PAL} operator to an {\rtl}
operator.  {\PAL} and {\rtl} operators are closely related: a {\PAL}
operator is in general an instance of a polymorphic {\rtl} operator.

Three different translations are provided: for the prefix named form
[[%name(...)]], for the infix binary form, and for the symbolic unary
form.
Different translations are needed because the [[-]] symbol translates
into [[%sub]] when binary but [[%neg]] when unary.
Each translation returns the type of the operator's result and
an {\rtl} operator that implements the {\PAL} operator.
<<rtlop.mli>>=
module Translate : sig
    val prefix: string -> Types.ty list -> Types.ty * Rtl.opr (*ErrorExn*)
    val binary: string -> Types.ty list -> Types.ty * Rtl.opr (*ErrorExn*)
    val unary:  string -> Types.ty list -> Types.ty * Rtl.opr (*ErrorExn*)
end
@
% ------------------------------------------------------------------ 
\subsection{Types of RTL operators}
% ------------------------------------------------------------------ 

Note: the [[Types]] module is not intended for the casual user. There
should be no reason why you need to know about the types of a {\rtl}
operator. 

[[Mono]] takes an [[Rtl.opr]] operator and reconstructs its monomorphic
type (using the width list inside the operator). If the operator is
unknown, [[Not_found]] is raised.
<<rtlop.mli>>=
module Types: sig
  val mono: Rtl.opr -> Types.monotype      (* Not_found *)
  val has_floating_result : Rtl.opr -> bool
end
@ 
\subsection{Enumerating operators}

For testing purposes, we enumerate the operators, so we can generate
code for testing, identify operators that are not implemented, and so
on. 
<<rtlop.mli>>=
val opnames : string list  (* names of all source-language operators *)
@

\subsection{Useful functions}

Emit code that might be useful in the compiler.
<<rtlop.mli>>=
module Emit : sig
  val creators : unit -> unit
end
@ 
% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlop.ml>>=
module T = Types        (* save external Types module here *)

module Types = struct
    <<Types>>
end
let opnames = Types.opnames

module Translate = struct
    <<Translate>>
end
@


% ------------------------------------------------------------------ 
\subsection{RTL-Op Types}
% ------------------------------------------------------------------ 

The [[ops]] table associates {\rtl} operators with their types. A
function type is constructed by [[T.proc]] that takes the list of
arguments and the result type. Most functions are polymorphic; a
[[T.bitsv]]~$n$ introduces a (bound) polymorphic [[bits]] type variable
$n$. For example, the type for [[add]] demands that all arguments and
the result have the same width. If the type variable of the result is
not identical to one of the arguments, the operator is polymorphic in
its return size. 
<<Types>>=
module T = Types

let (-->) = T.proc 

let optable = 
  let float = true in
  let int   = false in
  let code2 = false in
  let bool  = false in
  [  "NaN"          , float, [T.var 1] --> T.var 2
  ;  "add"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "addc"         , int,   [T.var 1; T.var 1; T.fixbits 1] --> T.var 1
  ;  "add_overflows", bool,  [T.var 1; T.var 1] --> T.bool
  ;  "and"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "bit"          , int,   [T.bool] --> T.fixbits 1
  ;  "bool"         , bool,  [T.fixbits 1] --> T.bool
  ;  "borrow"       , int,   [T.var 1; T.var 1; T.fixbits 1] --> T.fixbits 1
  ;  "carry"        , int,   [T.var 1; T.var 1; T.fixbits 1] --> T.fixbits 1
  ;  "com"          , int,   [T.var 1] --> T.var 1
  ;  "conjoin"      , bool,  [T.bool; T.bool] --> T.bool
  ;  "disjoin"      , bool,  [T.bool; T.bool] --> T.bool
  ;  "div"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "div_overflows", bool,  [T.var 1; T.var 1] --> T.bool
  ;  "divu"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "eq"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "f2f"          , float, [T.var 1; T.fixbits 2] --> T.var 2
  ;  "f2f_implicit_round", float, [T.var 1] --> T.var 2
  ;  "f2i"          , int,   [T.var 1; T.fixbits 2] --> T.var 2
  ;  "fabs"         , float, [T.var 1] --> T.var 1
  ;  "fadd"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "fcmp"         , code2, [T.var 1; T.var 1] --> T.fixbits 2
  ;  "fdiv"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "feq"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fge"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fgt"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fle"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "float_eq"     , code2, [] --> T.fixbits 2
  ;  "float_gt"     , code2, [] --> T.fixbits 2
  ;  "float_lt"     , code2, [] --> T.fixbits 2
  ;  "flt"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fmul"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "fmulx"        , float, [T.var 1; T.var 1] --> T.double 1
  ;  "fne"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fneg"         , float, [T.var 1] --> T.var 1
  ;  "fordered"     , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fsqrt"        , float, [T.var 1; T.fixbits 2] --> T.var 1
  ;  "fsub"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "funordered"   , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "ge"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "geu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "gt"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "gtu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "i2f"          , float, [T.var 1; T.fixbits 2] --> T.var 2
  ;  "le"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "leu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "lobits"       , int,   [T.var 1] --> T.var 2
  ;  "lt"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "ltu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "minf"         , float, [] --> T.var 1
  ;  "mod"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "modu"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "mul"          , int,   [T.var 1; T.var 1] --> T.var 1 
  ;  "mulux"        , int,   [T.var 1; T.var 1] --> T.double 1 
  ;  "mulx"         , int,   [T.var 1; T.var 1] --> T.double 1 
  ;  "mul_overflows", bool,  [T.var 1; T.var 1] --> T.bool
  ;  "mulu_overflows", bool, [T.var 1; T.var 1] --> T.bool
  ;  "mzero"        , float, [] --> T.var 1
  ;  "ne"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "neg"          , int,   [T.var 1] --> T.var 1
  ;  "not"          , bool,  [T.bool] --> T.bool
  ;  "or"           , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "pinf"         , float, [] --> T.var 1
  ;  "popcnt"       , int,   [T.var 1] --> T.var 1
  ;  "pzero"        , float, [] --> T.var 1
  ;  "quot"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "quot_overflows", bool,  [T.var 1; T.var 1] --> T.bool
  ;  "rem"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "rotl"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "rotr"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "round_down"   , code2, [] --> T.fixbits 2
  ;  "round_nearest", code2, [] --> T.fixbits 2
  ;  "round_up"     , code2, [] --> T.fixbits 2
  ;  "round_zero"   , code2, [] --> T.fixbits 2
  ;  "shl"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "shra"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "shrl"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "sub"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "subb"         , int,   [T.var 1; T.var 1; T.fixbits 1] --> T.var 1
  ;  "sub_overflows", bool,  [T.var 1; T.var 1] --> T.bool
  ;  "sx"           , int,   [T.var 1] --> T.var 2
  ;  "unordered"    , code2, [] --> T.fixbits 2
  ;  "xor"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "zx"           , int,   [T.var 1] --> T.var 2
     (* not C-- operators, but might show up in RTLs *)    
  ;  "bitExtract"   , int,   [T.var 1; T.var 1] --> T.var 2
  ;  "bitInsert"    , int,   [T.var 1; T.var 1; T.var 2] --> T.var 1
  ;  "bitTransfer"  , int,   [T.var 1; T.var 1; T.var 1; T.var 1; T.var 1] --> T.var 1 
                    
  ] 
<<Types>>=
let optypes  = Strutil.assoc2map (List.map (fun (o, _, t) -> (o, t)) optable)
let opfloats = Strutil.assoc2map (List.map (fun (o, f, _) -> (o, f)) optable)
@ 
We once printed operators' signatures
<<Types>>=
let () = 
  if false then
    List.iter (fun (o, _, t) ->
      Printf.printf "%16s : %s\n" o (Types.scheme_string t)) optable
@ 
Some operators are not visible.
An operator is invisible if it is for internal use only or if it has
been expunged from the {\PAL} specification.
<<Types>>=
let opnames =
  let visible = function
    | "bitExtract" | "bitInsert" | "bitTransfer" | "f2f_implicit_round" -> false
    | "fcmp" | "float_lt" | "float_eq" | "float_gt" | "unordered" -> false (*expunged*)
    | _ -> true in
  List.filter visible (List.map (fun (o, _, _) -> o) optable)

<<Types>>=
let findopname name t =
  try Strutil.Map.find name t
  with Not_found ->
    ( Printf.eprintf "unknown RTL operator '%%%s'" name
    ; raise Not_found
    )
let findop op = findopname (fst (Rtl.Dn.opr op))

        
let poly op = findop op optypes
let mono op = let _, ws = Rtl.Dn.opr op in Types.instantiate (findop op optypes) ws

let has_floating_result op = findop op opfloats
@
% ------------------------------------------------------------------ 
\subsection{Translation from {\PAL} operators to {\rtl} operators}
% ------------------------------------------------------------------ 

{\PAL} primitive operators and {\rtl} primitive operators are closely
connected. To typecheck the application of a {\PAL} operator, we use the
type of the corresponding {\RTL} operator.  For example, the {\PAL}
operator [[add]] is translated to the {\rtl} operator [[add]], that has
the exact same signature. 

The exceptions are {\PAL} operators like [[zx32]] that encodes the size
of their return value in the name. {\rtl} operators are more polymorphic
than {\PAL} operators and thus there are no separate operators [[zx1]],
\dots, [[zx32]], \dots, but a single polymorphic operator [[zx]]:
%
$$[[zx]]: \forall~\alpha,\beta.[[bits]]\alpha \to [[bits]]\beta$$
%
An application [[zx32 (1::bits10)]] is translated into the {\rtl}
operator [[(zx,[10,32])]], where [[10]] is bound by $\alpha$, and [[32]]
by $\beta$ in the above type scheme. Hence, the size of the result,
which is inferred from the name, is always the \emph{last}
value in the \emph{width list} of an {\rtl} operator.
@
If an operator name has a numerical component, it denotes the size of
the result. Such a size always becomes the last element in the width
list of an operator. 
<<Translate>>=
let prefix opname argtys =
  try 
    let op, retsize = T.split opname in
    let opty        = Types.findopname op Types.optypes in
    let argwidths   = T.widthlist opname opty argtys in
    ( match retsize with
    | None   -> T.appl opname opty argtys, Rtl.opr op argwidths
    | Some n -> T.bits n,                  Rtl.opr op (argwidths@[n])
    )            
  with
  | Not_found  -> Error.errorf "unknown operator %%%s" opname
@ 
Infix and prefix symbols are stored in tables.
Nothing should go wrong  in lookup because the only symbols that make
it this far should have been blessed by the parser.
<<Translate>>=
let binops = Strutil.assoc2map 
    [  "+"      , "add"
    ;  "-"      , "sub"
    ;  "*"      , "mul"
    ;  "/"      , "divu"
    ;  "%"      , "modu"
    ;  "<<"     , "shl"
    ;  ">>"     , "shrl"
    ;  "=="     , "eq"
    ;  "<="     , "leu"
    ;  ">="     , "geu"
    ;  ">"      , "gtu"
    ;  "<"      , "ltu"
    ;  "!="     , "ne"
    ;  "&"      , "and"
    ;  "^"      , "xor"
    ;  "|"      , "or"
    ;  "!="     , "ne"
    ] 

let unops = Strutil.assoc2map 
    [  "-"      , "neg"
    ;  "~"      , "com"
    ]

let binary op =
  try prefix (Strutil.Map.find op binops) 
  with Not_found -> Impossible.impossible ("unknown binary infix operator "^op)

let unary op =
  try prefix (Strutil.Map.find op unops) 
  with Not_found -> Impossible.impossible ("unknown unary symbolic operator "^op)
@        

<<rtlop.ml>>=
let ws = ["w"; "w'"; "w3"; "w4"; "w5"]
let args = ["x"; "y"; "z"; "u"; "v"]

let width n = try List.nth ws   n with _ -> Impossible.impossible "too many widths"
let arg   n = try List.nth args n with _ -> Impossible.impossible "too many args"


module Emit = struct
  let pf = Printf.printf
  let mangle = function
    | "and" -> "_and"
    | "NaN" -> "_Nan"
    | "mod" -> "_mod"
    | "or" -> "_or"
    | n -> n
          
  let emitop (name, _, (parms, _ as tyscheme)) =
    let nargs   = List.length parms in
    let nwidths = T.largest_key tyscheme in
    begin
      pf "let %s" (mangle name);
      for i = 0 to nwidths - 1 do pf " %s"  (width i) done;
      for i = 0 to nargs   - 1 do pf " %s"  (arg   i) done;
      pf " = Rtl.app (Rtl.opr \"%s\" [" name;
      for i = 0 to nwidths - 1 do pf "%s;"  (width i) done;
      pf "]) [";
      for i = 0 to nargs   - 1 do pf "%s; " (arg   i) done;
      pf "]\n";
    end
  let creators () =
    pf "(* This code generated automatically by Rtlop.Emit.creators *)\n";
    List.iter emitop Types.optable    
end    
