% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------ 
\section{Translation of {\PAL} operators to RTL operators}
% ------------------------------------------------------------------ 

This module provides the translation of a {\PAL} operator to an {\rtl}
operator.  {\PAL} and {\rtl} operators are closely related: a {\PAL}
operator is in general an instance of a polymorphic {\rtl} operator.

The [[operator]] function returns the type of the operator's result, and
an {\rtl} operator that implements the {\PAL} operator.

<<rtlop.mli>>=
module Translate : sig
    val operator: op:string -> Types.ty list -> Types.ty * Rtl.opr (*ErrorExn*)
end
@
% ------------------------------------------------------------------ 
\subsection{Types of RTL operators}
% ------------------------------------------------------------------ 

Note: the [[Types]] module is not intended for the casual user. There
should be no reason why you need to know about the types of a {\rtl}
operator. 

[[Mono]] takes an [[Rtl.opr]] operator and reconstructs its monomorphic
type (using the width list inside the operator). If the operator is
unknown, [[Not_found]] is raised.
<<rtlop.mli>>=
module Types: sig
  val mono: Rtl.opr -> Types.monotype      (* Not_found *)
  val has_floating_result : Rtl.opr -> bool
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlop.ml>>=
module T = Types        (* save external Types module here *)

module Types = struct
    <<Types>>
end

module Translate = struct
    <<Translate>>
end
@


% ------------------------------------------------------------------ 
\subsection{RTL-Op Types}
% ------------------------------------------------------------------ 

The [[ops]] table associates {\rtl} operators with their types. A
function type is constructed by [[T.proc]] that takes the list of
arguments and the result type. Most functions are polymorphic; a
[[T.bitsv]]~$n$ introduces a (bound) polymorphic [[bits]] type variable
$n$. For example, the type for [[add]] demands that all arguments and
the result have the same width. If the type variable of the result is
not identical to one of the arguments, the operator is polymorphic in
its return size. 

The multiplication operator [[mulXX]] is quasi-polymoprhic in its result
size: two $n$ bits values are multioplied into one $2n$ bits result.
This makes it hard to define the meaning of the {\PAL} infix-operator
because its meaning would depend on its arguments. Therefore, [[*]]
denotes a $n$ bits multiplication with a an $n$ bits result. We
introduce a new {\rtl} operator [[mul@]] for this. Since the character
[[@]] cannot be part a {\PAL} identifier, it cannot be used in a program
and is thus hidden.  The operator [[mul@]] can be defined in terms of
existing operators:

$$[[%mul@]](x,y) = [[%lobits]]$n$([[%mul$n$]](x,y))$$

<<Types>>=
module T = Types

let (-->) = T.proc 

let optable = 
  let float = true in
  let int   = false in
  let code2 = false in
  let bool  = false in
  [  "NaN"          , float, [T.var 1] --> T.var 2
  ;  "add"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "and"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "bit"          , int,   [T.bool] --> T.fixbits 1
  ;  "bool"         , bool,  [T.fixbits 1] --> T.bool
  ;  "borrow"       , int,   [T.var 1; T.var 1; T.fixbits 1] --> T.fixbits 1
  ;  "carry"        , int,   [T.var 1; T.var 1; T.fixbits 1] --> T.fixbits 1
  ;  "com"          , int,   [T.var 1] --> T.var 1
  ;  "conjoin"      , bool,  [T.bool; T.bool] --> T.bool
  ;  "disjoin"      , bool,  [T.bool; T.bool] --> T.bool
  ;  "div"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "divu"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "eq"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "f2f"          , float, [T.var 1; T.fixbits 2] --> T.var 2
  ;  "f2f_implicit_round", float, [T.var 1] --> T.var 2
  ;  "f2i"          , int,   [T.var 1; T.fixbits 2] --> T.var 2
  ;  "fabs"         , float, [T.var 1] --> T.var 1
  ;  "fadd"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "fcmp"         , code2, [T.var 1; T.var 1] --> T.fixbits 2
  ;  "fdiv"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "feq"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fge"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fgt"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fle"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "float_eq"     , code2, [] --> T.fixbits 2
  ;  "float_gt"     , code2, [] --> T.fixbits 2
  ;  "float_lt"     , code2, [] --> T.fixbits 2
  ;  "flt"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fmul"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "fmulx"        , float, [T.var 1; T.var 1] --> T.double 1
  ;  "fne"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fneg"         , float, [T.var 1] --> T.var 1
  ;  "fordered"     , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fsqrt"        , float, [T.var 1; T.fixbits 2] --> T.var 1
  ;  "fsub"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "funordered"   , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "ge"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "geu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "gt"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "gtu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "i2f"          , float, [T.var 1; T.fixbits 2] --> T.var 2
  ;  "le"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "leu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "lobits"       , int,   [T.var 1] --> T.var 2
  ;  "lt"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "ltu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "minf"         , float, [] --> T.var 1
  ;  "mod"          , int,   [T.var 1; T.var 2] --> T.var 2
  ;  "modu"         , int,   [T.var 1; T.var 2] --> T.var 2
  ;  "mul"          , int,   [T.var 1; T.var 1] --> T.double 1 
  ;  "mul_trunc"    , int,   [T.var 1; T.var 1] --> T.var 1 
  ;  "mulu"         , int,   [T.var 1; T.var 1] --> T.double 1 
  ;  "mzero"        , float, [] --> T.var 1
  ;  "ne"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "neg"          , int,   [T.var 1] --> T.var 1
  ;  "not"          , bool,  [T.bool] --> T.bool
  ;  "or"           , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "pinf"         , float, [] --> T.var 1
  ;  "popcnt"       , int,   [T.var 1] --> T.fixbits 1
  ;  "pzero"        , float, [] --> T.var 1
  ;  "quot"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "rem"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "rotl"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "rotr"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "round_down"   , code2, [] --> T.fixbits 2
  ;  "round_nearest", code2, [] --> T.fixbits 2
  ;  "round_up"     , code2, [] --> T.fixbits 2
  ;  "round_zero"   , code2, [] --> T.fixbits 2
  ;  "shl"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "shra"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "shrl"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "sub"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "sx"           , int,   [T.var 1] --> T.var 2
  ;  "unordered"    , code2, [] --> T.fixbits 2
  ;  "xor"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "zx"           , int,   [T.var 1] --> T.var 2
     (* not C-- operators, but might show up in RTLs *)    
  ;  "bitExtract"   , int,   [T.var 1; T.var 1] --> T.var 2
  ;  "bitInsert"    , int,   [T.var 1; T.var 1; T.var 2] --> T.var 1
  ;  "bitTransfer"  , int,   [T.var 1; T.var 1; T.var 1; T.var 1; T.var 1] --> T.var 1 
                    
  ] 

let optypes  = Strutil.assoc2map (List.map (fun (o, _, t) -> (o, t)) optable)
let opfloats = Strutil.assoc2map (List.map (fun (o, f, _) -> (o, f)) optable)

let findopname name t =
  try Strutil.Map.find name t
  with Not_found ->
    ( Printf.eprintf "unknown RTL operator '%%%s'" name
    ; raise Not_found
    )
let findop op = findopname (fst (Rtl.Dn.opr op))

        
let poly op = findop op optypes
let mono op = let _, ws = Rtl.Dn.opr op in Types.instantiate (findop op optypes) ws

let has_floating_result op = findop op opfloats
@


% ------------------------------------------------------------------ 
\subsection{Translation from {\PAL} operators to {\rtl} operators}
% ------------------------------------------------------------------ 

{\PAL} primitive operators and {\rtl} primitive operators are closely
connected. To typecheck the application of a {\PAL} operator, we use the
type of the corresponding {\RTL} operator.  For example, the {\PAL}
operator [[add]] is translated to the {\rtl} operator [[add]], that has
the exact same signature. 

The exceptions are {\PAL} operators like [[zx32]] that encodes the size
of their return value in the name. {\rtl} operators are more polymorphic
than {\PAL} operators and thus there are no separate operators [[zx1]],
\dots, [[zx32]], \dots, but a single polymorphic operator [[zx]]:

$$[[zx]]: \forall~\alpha,\beta.[[bits]]\alpha \to [[bits]]\beta$$

An application [[zx32 (1::bits10)]] is translated into the {\rtl}
operator [[(zx,[10,32])]], where [[10]] is bound by $\alpha$, and [[32]]
by $\beta$ in the above type scheme. Hence, the size of the result,
which is inferred from the name, is always the \emph{last}
value in the \emph{width list} of an {\rtl} operator.

<<Translate>>=
let alias = Strutil.assoc2map 
    [  "+"      , "add"
    ;  "-"      , "sub"
    ;  "*"      , "mul_trunc"    (* see discussion of %mul above *)
    ;  "/"      , "div"
    ;  "<<"     , "shl"
    ;  ">>"     , "shrl"
    ;  "=="     , "eq"
    ;  "<="     , "le"
    ;  ">="     , "ge"
    ;  ">"      , "gt"
    ;  "<"      , "lt"
    ;  "!="     , "ne"
    ;  "~"      , "neg"
    ] 

let unalias op = try Strutil.Map.find op alias with Not_found -> op    
@

{\PAL} uses infix symbols as aliases for alphanumeric operator names. If
we find the current operator in the [[alias]] map we replace it with the
official name. If we don't find it, we assume it is an official name
already.

If an operator name has a numerical component, it denotes the size of
the result. Such a size always becomes the last element in the width
list of an operator. 
<<Translate>>=
let operator ~op argtys =
  try 
    let op, retsize = T.split (unalias op) in
    let opty        = Types.findopname op Types.optypes in
    let argwidths   = T.widthlist opty argtys in
    ( match retsize with
    | None   -> T.appl opty argtys, Rtl.opr op argwidths
    | Some n -> T.bits n,           Rtl.opr op (argwidths@[n])
    )            
  with
  | Not_found  -> Error.error ("unknown operator "^op)
  | T.MatchExn -> Error.error "type error in application"
@        

