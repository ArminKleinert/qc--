% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------ 
\section{Translation of {\PAL} operators to RTL operators}
% ------------------------------------------------------------------ 

This module provides the translation of a {\PAL} operator to an {\rtl}
operator.  {\PAL} and {\rtl} operators are closely related: a {\PAL}
operator is in general an instance of a polymorphic {\rtl} operator.

The [[operator]] function returns the type of the operator's result, and
an {\rtl} operator that implements the {\PAL} operator.

<<rtlop.mli>>=
module Translate : sig
    val operator: op:string -> Types.ty list -> Types.ty * Rtl.opr (*ErrorExn*)
end
@

% ------------------------------------------------------------------ 
\subsection{Types of RTL operators}
% ------------------------------------------------------------------ 

Note: the [[Types]] module is not intended for the casual user. There
should be no reason why you need to know about the types of a {\rtl}
operator. 

[[Mono]] takes an [[Rtl.opr]] operator and reconstructs its monomorphic
type (using the width list inside the operator). If the operator is
unknown, [[Not_found]] is raised.

<<rtlop.mli>>=
module Types: sig
    val mono: Rtl.opr -> Types.monotype      (* Not_found *)
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtlop.ml>>=
module T = Types        (* save external Types module here *)

module Types = struct
    <<Types>>
end

module Translate = struct
    <<Translate>>
end
@


% ------------------------------------------------------------------ 
\subsection{RTL-Op Types}
% ------------------------------------------------------------------ 

The [[ops]] table associates {\rtl} operators with their types. A
function type is constructed by [[T.proc]] that takes the list of
arguments and the result type. Most functions are polymorphic; a
[[T.bitsv]]~$n$ introduces a (bound) polymorphic [[bits]] type variable
$n$. For example, the type for [[add]] demands that all arguments and
the result have the same width. If the type variable of the result is
not identical to one of the arguments, the operator is polymorphic in
its return size. 

The multiplication operator [[mulXX]] is quasi-polymoprhic in its result
size: two $n$ bits values are multioplied into one $2n$ bits result.
This makes it hard to define the meaning of the {\PAL} infix-operator
because its meaning would depend on its arguments. Therefore, [[*]]
denotes a $n$ bits multiplication with a an $n$ bits result. We
introduce a new {\rtl} operator [[mul@]] for this. Since the character
[[@]] cannot be part a {\PAL} identifier, it cannot be used in a program
and is thus hidden.  The operator [[mul@]] can be defined in terms of
existing operators:

$$[[%mul@]](x,y) = [[%lobits]]$n$([[%mul$n$]](x,y))$$

<<Types>>=
module T = Types

let (-->) = T.proc 

let ops = Strutil.assoc2map
        [  "NaN"        , [T.var 1] --> T.var 2
        ;  "add"        , [T.var 1; T.var 1] --> T.var 1
        ;  "and"        , [T.var 1; T.var 1] --> T.var 1
        ;  "bit"        , [T.bool] --> (T.fixbits 1)
        ;  "bool"       , [T.fixbits 1] --> T.bool
        ;  "borrow"     , [T.var 1; T.var 1; T.fixbits 1] --> (T.fixbits 1)
        ;  "carry"      , [T.var 1; T.var 1; T.fixbits 1] --> (T.fixbits 1)
        ;  "com"        , [T.var 1] --> T.var 1
        ;  "conjoin"    , [T.bool; T.bool] --> T.bool
        ;  "disjoin"    , [T.bool; T.bool] --> T.bool
        ;  "div"        , [T.var 1; T.var 1] --> T.var 1
        ;  "divu"       , [T.var 1; T.var 1] --> T.var 1
        ;  "eq"         , [T.var 1; T.var 1] --> T.bool
        ;  "f2f"        , [T.var 1; T.fixbits 2] --> T.var 2
        ;  "f2f_bogus"  , [T.var 1] --> T.var 2
        ;  "f2i"        , [T.var 1; T.fixbits 2] --> T.var 2
        ;  "fabs"       , [T.var 1] --> T.var 1
        ;  "fadd"       , [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
        ;  "fcmp"       , [T.var 1; T.var 1] --> (T.fixbits 2)
        ;  "fdiv"       , [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
        ;  "feq"        , [T.var 1; T.var 1] --> T.bool
        ;  "fge"        , [T.var 1; T.var 1] --> T.bool
        ;  "fgt"        , [T.var 1; T.var 1] --> T.bool
        ;  "fle"        , [T.var 1; T.var 1] --> T.bool
        ;  "float_eq"   , [] --> (T.fixbits 2)
        ;  "float_gt"   , [] --> (T.fixbits 2)
        ;  "float_lt"   , [] --> (T.fixbits 2)
        ;  "flt"        , [T.var 1; T.var 1] --> T.bool
        ;  "fmul"       , [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
        ;  "fmulx"      , [T.var 1; T.var 1] --> T.double 1
        ;  "fne"        , [T.var 1; T.var 1] --> T.bool
        ;  "fneg"       , [T.var 1] --> T.var 1
        ;  "fordered"   , [T.var 1; T.var 1] --> T.bool
        ;  "fsqrt"      , [T.var 1; T.fixbits 2] --> T.var 1
        ;  "fsub"       , [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
        ;  "funordered" , [T.var 1; T.var 1] --> T.bool
        ;  "ge"         , [T.var 1; T.var 1] --> T.bool
        ;  "geu"        , [T.var 1; T.var 1] --> T.bool
        ;  "gt"         , [T.var 1; T.var 1] --> T.bool
        ;  "gtu"        , [T.var 1; T.var 1] --> T.bool
        ;  "i2f"        , [T.var 1; T.fixbits 2] --> T.var 2
        ;  "le"         , [T.var 1; T.var 1] --> T.bool
        ;  "leu"        , [T.var 1; T.var 1] --> T.bool
        ;  "lobits"     , [T.var 1] --> T.var 2
        ;  "lt"         , [T.var 1; T.var 1] --> T.bool
        ;  "ltu"        , [T.var 1; T.var 1] --> T.bool
        ;  "minf"       , [] --> T.var 1
        ;  "mod"        , [T.var 1; T.var 2] --> T.var 2
        ;  "modu"       , [T.var 1; T.var 2] --> T.var 2
        ;  "mul"        , [T.var 1; T.var 1] --> T.double 1 
        ;  "mul_trunc"  , [T.var 1; T.var 1] --> T.var 1 
        ;  "mulu"       , [T.var 1; T.var 1] --> T.double 1 
        ;  "mzero"      , [] --> T.var 1
        ;  "ne"         , [T.var 1; T.var 1] --> T.bool
        ;  "neg"        , [T.var 1] --> T.var 1
        ;  "not"        , [T.bool] --> T.bool
        ;  "or"         , [T.var 1; T.var 1] --> T.var 1
        ;  "pinf"       , [] --> T.var 1
        ;  "popcnt"     , [T.var 1] --> (T.fixbits 1)
        ;  "pzero"      , [] --> T.var 1
        ;  "quot"       , [T.var 1; T.var 1] --> T.var 1
        ;  "rem"        , [T.var 1; T.var 1] --> T.var 1
        ;  "rotl"       , [T.var 1; T.var 1] --> T.var 1
        ;  "rotr"       , [T.var 1; T.var 1] --> T.var 1
        ;  "round_down" , [] --> T.fixbits 2
        ;  "round_nearest", [] -->T.fixbits 2
        ;  "round_up"   , [] --> T.fixbits 2
        ;  "round_zero" , [] --> T.fixbits 2
        ;  "shl"        , [T.var 1; T.var 1] --> T.var 1
        ;  "shra"       , [T.var 1; T.var 1] --> T.var 1
        ;  "shrl"       , [T.var 1; T.var 1] --> T.var 1
        ;  "sub"        , [T.var 1; T.var 1] --> T.var 1
        ;  "sx"         , [T.var 1] --> T.var 2
        ;  "unordered"  , [] --> (T.fixbits 2)
        ;  "xor"        , [T.var 1; T.var 1] --> T.var 1
        ;  "zx"         , [T.var 1] --> T.var 2
           (* not C-- operators, but might show up in RTLs *)    
        ;  "bitExtract" , [T.var 1; T.var 1] --> T.var 2
        ;  "bitInsert"  , [T.var 1; T.var 1; T.var 2] --> T.var 1
        ;  "bitTransfer", [T.var 1; T.var 1; T.var 1; T.var 1; T.var 1] 
                          --> T.var 1 
                          
        ] 

let poly op = 
    try
        Strutil.Map.find op ops 
    with Not_found ->
        ( Printf.eprintf "cannot find '%s' operator" op
        ; raise Not_found
        )
        
let mono op =
    let (o,w) = Rtl.Dn.opr op in
    let ptype = poly o             in
        Types.instantiate ptype w
@


% ------------------------------------------------------------------ 
\subsection{Translation from {\PAL} operators to {\rtl} operators}
% ------------------------------------------------------------------ 

{\PAL} primitive operators and {\rtl} primitive operators are closely
connected. To typecheck the application of a {\PAL} operator, we use the
type of the corresponding {\RTL} operator.  For example, the {\PAL}
operator [[add]] is translated to the {\rtl} operator [[add]], that has
the exact same signature. 

The exceptions are {\PAL} operators like [[zx32]] that encodes the size
of their return value in the name. {\rtl} operators are more polymorphic
than {\PAL} operators and thus there are no separate operators [[zx1]],
\dots, [[zx32]], \dots, but a single polymorphic operator [[zx]]:

$$[[zx]]: \forall~\alpha,\beta.[[bits]]\alpha \to [[bits]]\beta$$

An application [[zx32 (1::bits10)]] is translated into the {\rtl}
operator [[(zx,[10,32])]], where [[10]] is bound by $\alpha$, and [[32]]
by $\beta$ in the above type scheme. Hence, the size of the result,
which is inferred from the name, is always the \emph{last}
value in the \emph{width list} of an {\rtl} operator.

<<Translate>>=
let alias = Strutil.assoc2map 
    [  "+"      , "add"
    ;  "-"      , "sub"
    ;  "*"      , "mul_trunc"    (* see discussion of %mul above *)
    ;  "/"      , "div"
    ;  "<<"     , "shl"
    ;  ">>"     , "shrl"
    ;  "=="     , "eq"
    ;  "<="     , "le"
    ;  ">="     , "ge"
    ;  ">"      , "gt"
    ;  "<"      , "lt"
    ;  "!="     , "ne"
    ;  "~"      , "neg"
    ] 

let unalias op = try Strutil.Map.find op alias with Not_found -> op    
@

{\PAL} uses infix symbols as aliases for alphanumeric operator names. If
we find the current operator in the [[alias]] map we replace it with the
official name. If we don't find it, we assume it is an official name
already.

If an operator name has a numerical component, it denotes the size of
the result. Such a size always becomes the last element in the width
list of an operator. 

<<Translate>>=
let operator ~op argtys =
    try 
        let op, retsize = T.split (unalias op)             in
        ( match retsize with
        | None ->   let return      = T.appl (Types.poly op) argtys    in
                    let widthlist   = T.widthlist (Types.poly op) argtys in
                    return, Rtl.opr op widthlist 
        | Some n -> let return    = T.bits n in
                    let widthlist = (T.widthlist (Types.poly op) argtys)@[n] in
                    return, Rtl.opr op widthlist
        )            
    with
    | Not_found  -> Error.error ("unknown operator "^op)
    | T.MatchExn -> Error.error "type error in application"

@        

