%cg. -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
%-------------------------------------------------------------------
\section{DFS Linear Scan Register Allocation}
%-------------------------------------------------------------------
The goal of this register allocator is to allocate registers in linear time,
generating as few load and store instructions as possible.
We make two traversals of the cfg; the first traversal determines the order of
the second traversal, which allocates the registers.

This algorithm is very different from graph coloring.
Graph coloring builds up an abstract model of how temps interfere in a procedure.
Our algorithm builds no such representation; instead, liveness information
provides all the information we need to allocate registers.
The important invariant of the graph traversal is that we visit the predecessors of a
node before we visit the node.
Of course, this invariant does not apply to predecessors along backedges.
Also, from join points, we make sure that the information from the allocation of
one predecessor flows to the allocation of the other predecessor.
This information flow allows us to allocate a variable to the same register, so no
extra move instructions are required at the join point.

This algorithm takes its ideas primarily from two sources: linear scan and SSA.
Linear scan register allocation offers the idea of the reverse postorder depth-first
search.
Our contribution is to realize that this graph traversal, coupled only with liveness
information, allows us to treat the graph as if it has the SSA property of static
single-assignment.
Static single-assignment allows us to treat each definition as a separate temp.
Of course, it is a good idea to ensure that if two definitions of a temp are live
into a join point, they should be allocated to the same location; if not, shuffles must
be inserted to place them in the same location.
This behavior at join points is exactly what we would expect from a phi-node in SSA.

Because we take a local, graph-node-by-graph-node perspective, we never spill a temp
unless there are more live temps than registers.
Of course, the big concerns are whether we spill the right temps and whether we have
too many shuffle instructions at join points.
We use preferencing information as heuristics for each of these problems.
More on these later...

%-------------------------------------------------------------------
\section{DFS Linear Scan Register Allocation}
%-------------------------------------------------------------------
Before digging into the algorithm, we have a few shorthands for module names
and some type declarations.
The utilities are largely uninteresting, so we leave their exposition until
later.
<<dls type declarations and utilities>>=
type reg  = Register.t
type temp = Register.t
module RP = Rtl.Private
module RU = Rtlutil
module G = Cfgx.M
module IntMod = struct type t = int let compare = compare end
module IS = Set.Make (IntMod)
module IM = Map.Make (IntMod)
module NodeMod = struct type t = Rtl.rtl G.node let compare = compare end
module NM = Map.Make (NodeMod)
module RM = Register.Map
module RS = Register.Set

<<register utilities>>
<<varmap module type>>
<<varmap module>>
module VM = OneLocVarMap

<<type declarations>>
<<printers>>
<<utilities>>
@
%-------------------------------------------------------------------
\subsection{Variable Maps}
%-------------------------------------------------------------------
The variable map is the fundamental data structure that maps variables to locations
(registers and slots on the stack).
It is a dynamic, unchecked invariant that only temps (not hardware registers) are in
the domain of a variable map.

We have some simple types for temps and locations, and location sets.
<<varmap module type>>=
type loc  = Reg of Register.t
          | Mem of Automaton.loc
type tgt = ((Rtl.exp -> Automaton.t), Call.t) Target.t
@
%-------------------------------------------------------------------
\subsubsection{Interface}
%-------------------------------------------------------------------
The variable map supports standard map operations, as well as some unique operations
that help with register allocation.

We have simple constructors to create and empty map, add a temp to a map, and remove a
temp from a map.
<<varmap module type>>=
module type VarMap = sig
  type t
  val empty            : t
  val add              : temp  -> loc -> t -> t
  val remove           : temp  -> loc -> t -> t
@
We can also fold over a map, observe the locations where a temp is stored, observe the
temp stored in a register, or print a map.
<<varmap module type>>=
  val fold             : (temp -> loc list -> 'a -> 'a) -> t -> 'a -> 'a
  val var_locs         : t -> temp -> loc list
  val reg_contents     : t -> reg  -> temp option
  val print            : string -> t -> unit
@
The variable map also provides functions to determine which registers are available at
a given node.
The [[reg_classes]] datatype indicates the availability of registers.
The function [[classify_inregs]] determines which registers are available for the temps
used at a node.
The function [[classify_outregs]] determines which registers are available for the temps
defined at a node.
<<varmap module type>>=
  type reg_classes
  val classify_inregs  : tgt -> reg list -> t -> Rtl.rtl G.node -> reg_classes
  val classify_outregs : tgt -> reg list -> t -> Rtl.rtl G.node -> reg_classes
@
The registers may be divided into five categories:
\begin{enumerate}
\item unused: The registers are available for use.
\item used\_free\_evict: The registers are in use but may be evicted without a store
  instruction to spill the contents (because the contents has already been stored).
\item used\_can\_spill: The registers are in use but may be evicted, at the cost of
  a store instruction to spill the contents.
\item unavailable: The registers not only cannot be used to satisfy an allocation, but
  any temp using one of these registers must be evicted.
\item unavailable\_if\_liveout: The registers are unavailable for temps that are
  live\_out.
\end{enumerate}
It is possible that the union of these four sets will not contain all the
registers.
For example, in a variable map that can only keep each variable in one location, if we
have a temp that is placed in a register for a use, then that register cannot be used
for a definition if the variable is live\_out.
But that does not mean we need to evict the variable; we just need to avoid using that
register.
<<varmap module type>>=
  val unused                 : reg_classes -> reg list
  val used_free_evict        : reg_classes -> reg list
  val used_can_spill         : reg_classes -> reg list
  val unavailable            : reg_classes -> reg list
  val unavailable_if_liveout : reg_classes -> reg list
@
We also provide a function that makes two variable maps consistent.
The first map (the inmap) holds the variable that are live\_in to the node, and the
second map (the outmap) holds the variables that are live\_out of the node.
Because the second map may require spills to be inserted before the node, the maps have
to be synchronized.
<<varmap module type>>=
  val sync_maps        : t -> t -> t * t
end
@
%-------------------------------------------------------------------
\subsubsection{Implementations}
%-------------------------------------------------------------------
We currently have only one implementation of a variable map.
This implementation allows each temp to be stored in only one location at a time.
Our representation keeps a map from temps to locations and register locations to temps
(to facilitate the spilling function, [[reg_contents]]).
<<varmap module>>=
module OneLocVarMap : VarMap = struct
  exception Found of temp
  type t = loc RM.t * temp RM.t
@
The constructors and observers are simple.
<<varmap module>>=
  let empty            = (RM.empty, RM.empty)
  let add t l (vm, lm) = (RM.add t l vm, match l with Reg r -> RM.add r t lm | _ -> lm)
  let remove temp loc (vm, lm) =
    match loc with
    | Reg r -> (RM.remove temp vm, RM.remove r lm)
    | Mem _ -> Impossible.impossible "Cannot remove a temp from a memory location"
  let var_locs (vm, _) temp    = [RM.find temp vm]
  let reg_contents (_, lm) reg = try Some (RM.find reg lm) with Not_found -> None
  let fold f (vm, lm) zero     = (RM.fold (fun t ls z -> f t [ls] z) vm zero)
@
Printing is easy.
<<varmap module>>=
  let print msg (vm, _) =
    let string_of_loc = function | Reg r -> printReg r | Mem _ -> "mem_loc" in
    ( Printf.eprintf "%s\nOneLocVarMap:\n" msg
    ; RM.iter (fun t l -> Printf.eprintf "%s -> %s\n" (printReg t) (string_of_loc l)) vm
    ; flush stderr
    )
@
If the outmap spills a temp that is assigned to a reg in the inmap,
then the spill must happen in the inmap.
We assume that any spilled temp is not used in the instruction (which would make the
register assignment illegal for this representation).
Recall that in this representation, a temp can only be in one location -- a register or
a memory slot.
Note: We fold over the outmap, with the inmap as the accumulating parameter.
<<varmap module>>=
  let sync_maps inmap (om_vm,_ as outmap) =
    (RM.fold (fun temp loc (im_vm',_ as inmap') ->
                match loc with
                | Mem _ ->
                  (try if RM.find temp im_vm' <> loc then add temp loc inmap'
                       else inmap'
                   with Not_found -> inmap')
                | Reg _ -> inmap')
             om_vm inmap, outmap)
@
The [[reg_classes]] are represented as a record of lists.
<<varmap module>>=
  type reg_classes = { regs_unused        : reg list
                     ; regs_cheap         : reg list
                     ; regs_hicost        : reg list
                     ; regs_unavail       : reg list
                     ; regs_unavail_if_lo : reg list
                     }
@
Any registers explicitly allocated to hardware registers are unavailable.
Otherwise, the availability of registers depends on whether they have been assigned to
temps (as shown by the variable map).
<<varmap module>>=
  let classify_inregs target allregs (vm, _) node =
    let defs          = defs node                                in
    let uses          = uses node                                in
    let live_in       = Cfgx.Live.live_in  node                  in
    let live_out      = Cfgx.Live.live_out node                  in

    let used_hw_regset       = get_hw_regs target (defs ++ live_in ++ live_out)    in
    let (used_hw_regs, regs) = part (fun r -> RS.mem r used_hw_regset) allregs     in
    let occupied             =
      RM.fold (fun _ l rst -> match l with | Reg r -> RS.add r rst | Mem _ -> rst)
              vm RS.empty                                                          in
    let (regs_hicost, regs_unused) = part (fun r -> RS.mem r occupied) regs        in
    { regs_unused        = regs_unused
    ; regs_cheap         = []
    ; regs_hicost        = regs_hicost
    ; regs_unavail       = RS.elements (get_hw_regs target live_in)
    ; regs_unavail_if_lo = used_hw_regs
    }
@
DOCO PAUSE HERE
<<varmap module>>=
  let classify_outregs target allregs (vm, _) node =
    let defs          = defs node                                in
    let uses          = uses node                                in
    let live_in       = Cfgx.Live.live_in  node                  in
    let live_out      = Cfgx.Live.live_out node                  in

    let used_hw_regs    = get_hw_regs target (defs ++ live_out)       in
    let regs       = diff allregs used_hw_regs                        in
    let used_regs  =
      RM.fold (fun t l rst -> match l with
                 | Reg r -> RS.add r rst
                 | Mem _ -> rst)
              vm RS.empty                                        in
    let live_out_uses = RS.inter uses (RS.diff live_out defs) in
    let regs_for_live_out_uses =
      RS.fold (fun t set -> match RM.find t vm with
                            | Reg r -> RS.add r set
                            | Mem _ -> set)
              (rem_regs target live_out_uses) RS.empty in
    let cant_alloc = used_hw_regs ++ regs_for_live_out_uses in
    let unavail = RS.elements used_hw_regs in
    { regs_unused        = diff regs used_regs
    ; regs_cheap         = []
    ; regs_hicost        = inter regs (RS.diff used_regs cant_alloc)
    ; regs_unavail       = unavail
    ; regs_unavail_if_lo = unavail
    }
@
The observers for register classes.
<<varmap module>>=
  let unused                 rclasses = rclasses.regs_unused
  let used_free_evict        rclasses = rclasses.regs_cheap
  let used_can_spill         rclasses = rclasses.regs_hicost
  let unavailable            rclasses = rclasses.regs_unavail
  let unavailable_if_liveout rclasses = rclasses.regs_unavail_if_lo
end
@

%-------------------------------------------------------------------
\subsection{Preferences}
%-------------------------------------------------------------------

A [[varMap]] maps a temp (temporary register) to a hardware register.
It is a dynamic invariant that the domain of this function contains only
temps and the range includes hardware registers and memory locations.
<<type declarations>>=
type preferences = { varMap : VM.t
                   ; regs   : reg list
                   }
@
The preferences come in two forms: the register order and the variable map.
The register order indicates the order in which we assign registers.
The variable map suggests where a variable should be placed (if there is a choice).
We expect that the [[alloced_preds]] argument to [[update_pref_varmap]] holds all the
predecessors of the current node that have already been handled by the register
allocator (and therefore have useful outmaps).
Currently, the choice of predecessor is arbitrary.
<<updating preferences>>=
let update_pref_varmap state prefs alloced_preds =
  match alloced_preds with
  | []   -> prefs
  | p::_ -> { prefs with varMap = IM.find (G.num p) state.varOutMaps } in

let update_prefs_at_node prefs node =
  let temp_defs,hw_defs = partition_regs target (defs node)                     in
  let get_regs = get_regs prefs.varMap                                          in
  let to_avoid = RS.fold (fun t rst -> List.fold_right RS.add (get_regs t) rst)
                         temp_defs (RS.inter hw_defs alloc_regset)              in
  let vm = match get_copy_regs node with
           | Some (d, s) when is_tmp target s ->
               if is_tmp target d then 
                  try VM.add s (Reg (choose_reg prefs.varMap d)) prefs.varMap
                  with Not_found  -> prefs.varMap
               else VM.add s (Reg d) prefs.varMap
           | _ -> prefs.varMap in
  { regs   = diff prefs.regs to_avoid @ RS.elements to_avoid
  ; varMap = vm
  } in
@

%-------------------------------------------------------------------
\subsection{The Basic Algorithm}
%-------------------------------------------------------------------
The [[state]] is used to pass information as we traverse the flow graph:
\begin{itemize}
\item allocated:  the set of nodes that have been allocated (by node number)
\item spillMap:   a map from a temp to its spill location
\item varInMaps:  a map from a node (by node number) to the varMap representing
                  the location of each temp live\_in to the node
\item varOutMaps: a map from a node (by node number) to the varMap representing
                  the location of each temp live\_out from the node
\end{itemize}
<<type declarations>>=
type state = { allocated  : IS.t
             ; visited    : IS.t
             ; spillMap   : Automaton.loc RM.t
             ; varInMaps  : VM.t IM.t
             ; varOutMaps : VM.t IM.t
             }

let empty_state regs = ( { allocated  = IS.empty
                         ; visited    = IS.empty
                         ; spillMap   = RM.empty
                         ; varInMaps  = IM.empty
                         ; varOutMaps = IM.empty
                         }
                       , { varMap = VM.empty; regs = regs }
                       )
@
[[rpo_dfs]] traverses the cfg by a DFS, calling [[alloc_node]] in a reverse post-order.
This order ensures that [[alloc_node]] is called on each predecessor of a node $n$
before [[alloc_node]] is applied to $n$.

[[dls]] puts the allocator together: [[rpo_dfs]] is called with [[alloc_node]] to
place each temp at a node.
[[alloc_node]] calls [[choose_varMaps]] to decide where each temp belongs.
<<rpo\_dfs determines the order for visiting nodes>>=
<<updating preferences>>
let rpo_dfs (state, prefs) =
  let (_, postorder) = G.postorder_dfs (fun n (i, map) -> (i+1, NM.add n i map))
                                       (0, NM.empty) cfg                              in
  let rec visit (state, prefs) node prev_delays =
    let state = mark_visited state node                                               in
    let prefs = update_prefs_at_node prefs node                                       in
    let preds = G.preds node                                                          in
    let unvis_preds = List.filter (fun p -> not (is_visited state p)) preds           in
    (* Not_found case only for nodes unreachable from entry node... *)
    let node_num = try NM.find node postorder with Not_found -> 0                     in
    let (to_vis, to_delay) =
      (* Not_found case only for nodes unreachable from entry node... *)
      let comparep p = try NM.find p postorder > node_num with Not_found -> false     in
      List.partition comparep unvis_preds                                             in

    let visit_pred (state, delays) node =
      let prefs = update_pref_varmap state prefs
                                     (List.filter (is_allocated state) preds)         in
      visit (state, prefs) node delays                                                in
    let (state, delays) = List.fold_left visit_pred (state, prev_delays) to_vis       in
    (alloc_node state prefs node, (List.map (fun d -> (prefs,d)) to_delay) :: delays) in
  let rec handle_delays (state, ds) = match List.concat ds with
    | []  -> state
    | ds  -> List.fold_left (fun s (p, n) -> handle_delays (visit (s, p) n []))
                            state ds in
  handle_delays (state, [[(prefs, G.exit cfg)]])                                      in
@
<<dls algorithm>>=
let dls () ({Proc.cfg = cfg; Proc.cc = cc; Proc.target = target} as proc) =
  <<definition of shuffle>>
  let fits (s,_,_) r = Target.fits target s r                   in
  let alloc_regset = cc.Call.volregs ++ cc.Call.pre_nvregs      in
  <<choose\_varMaps finds varIn and varOut maps for a node>>
  <<alloc\_node allocates registers at a single node>>
  <<rpo\_dfs determines the order for visiting nodes>>
  let state' = rpo_dfs (empty_state (RS.elements alloc_regset)) in
  cleanup   cfg;
  true
@

To allocate registers at a single node, we follow a simple process:
\begin{enumerate}
\item Find predecessors and successors of [[node]].
\item Choose a varMaps for [[node]].
\item Rewrite the instruction to reflect the placement of temps in the varMaps.
\item Insert a shuffle of moves, loads, and stores to settle differences
      between varMaps in adjacent nodes.
\end{enumerate}
<<alloc\_node allocates registers at a single node>>=
let alloc_node state prefs node =
  let state = mark_allocated state node                                          in
  let preds = List.filter (is_allocated state) (G.preds node)                    in
  let succs = List.filter (is_allocated state) (G.succs node)                    in

  let state, varIn, defMap, varOut = choose_varMaps state prefs node preds succs in
  let state = set_varIn  state node varIn                                        in
  let state = set_varOut state node varOut                                       in

  let () = rewrite_uses target node varIn                                        in
  let () = rewrite_defs target node defMap                                       in
  let state = List.fold_left (fun state p -> shuffle state p node) state preds   in
  let state = List.fold_left (fun state s -> shuffle state node s) state succs   in
  {state with allocated = IS.add (G.num node) state.allocated}                   in
@
We clean up any move instruction where the source register is the same as the
destination register.
We accumulate the list of nodes we intend to delete before deleting them
because we do not want to modify the cfg while traversing it.
<<alloc\_node allocates registers at a single node>>=
let cleanup cfg =
  let visit_node node rst =
    match get_copy_regs node with
    | Some (r1,r2) when r1 = r2 -> node::rst
    | _                         -> rst in
  List.iter (Cfgutil.delete cfg) (G.fold_nodes visit_node [] cfg) in
@

[[choose_varMaps]] is responsible for choosing the varMaps in and
out of each node.
This particular version does not do any preferencing.
We begin by gathering some useful information about registers
at the node.
<<choose\_varMaps finds varIn and varOut maps for a node>>=
let choose_varMaps state prefs node preds succs =
  let defs              = defs node               in
  let uses              = uses node               in
  let live_in           = Cfgx.Live.live_in  node in
  let live_out          = Cfgx.Live.live_out node in
  let temp_uses,hw_uses = partition_regs target uses           in
  let temp_defs,hw_defs = partition_regs target defs           in

  <<define remove\_last\_uses, alloc, initial\_inmap, and alloc\_hw\_regs>>

  let inmap = initial_inmap state preds succs in
  (*<<check pred map invariant>>*)
  <<define spill functions>>
@
If any temps are in an unavailable register, then we need to spill the temp from that
register.
There is an opportunity for optimization here: even if the temp is not used in this
instruction, we could try to allocate it to a register if there are any free registers.
This optimization would insert a move instruction instead of a store.
<<choose\_varMaps finds varIn and varOut maps for a node>>=
  let reg_classes = VM.classify_inregs target prefs.regs inmap node in
  let avail, cheap, hicost, unavail, unavail_lo =
    VM.unused                 reg_classes, VM.used_free_evict reg_classes,
    VM.used_can_spill         reg_classes, VM.unavailable     reg_classes,
    VM.unavailable_if_liveout reg_classes                                  in
  let state,inmap = List.fold_left (spill_reg true_fun) (state, inmap) unavail in
  let state,inmap =
    List.fold_left (spill_reg (fun t -> RS.mem t live_out)) (state, inmap) unavail_lo in
@
Check each of the temps that remain to be allocated.
If a temp is already in a register, then we remove that register from the [[hicost]]
and [[cheap]] sets (alternatively, we could check whether the var is also in memory to
figure out which set to remove from).
After this part, this inmap is done.
<<choose\_varMaps finds varIn and varOut maps for a node>>=
  let remove_preallocs map to_alloc cheap hicost =
    let to_alloc', regs_used =
      RS.fold (fun t (rst, r_used) -> try let r = choose_reg map t in
                                          (rst, RS.add r r_used)
                                      with Not_found -> (t::rst,r_used))
              to_alloc ([],RS.empty) in
    (to_alloc', diff cheap regs_used, diff hicost regs_used) in

  let (to_alloc, cheap, hicost) = remove_preallocs inmap temp_uses cheap hicost in
  <<choose\_register>>
@
Now, we expire any temps that die at this node and move on to the defs at the node.
<<choose\_varMaps finds varIn and varOut maps for a node>>=
  let midmap = expire_last_uses inmap in

  (* REFACTOR WITH EARLIER, ALMOST IDENTICAL CODE FOR USES *)
  let reg_classes = VM.classify_outregs target prefs.regs midmap node in
  let avail, cheap, hicost, unavail, unavail_lo =
    VM.unused                 reg_classes, VM.used_free_evict reg_classes,
    VM.used_can_spill         reg_classes, VM.unavailable     reg_classes,
    VM.unavailable_if_liveout reg_classes in
  let state,outmap = List.fold_left (spill_reg true_fun) (state, midmap) unavail in
  let state,outmap = List.fold_left (spill_reg (fun t -> RS.mem t live_out))
                                    (state, outmap) unavail_lo in

  let (to_alloc, cheap, hicost) = remove_preallocs outmap temp_defs cheap hicost in
  let (state,outmap,_,_,_) =
    allocate (alloc_defs inmap) (state, outmap, avail, cheap, hicost) to_alloc in
@
Here's an interesting case. If we have a def that is never used again, then we must
assign it a register, but we don't want it in the outmap.
So, we have a separate defmap and outmap, where the defmap keeps any dead definitions.
<<choose\_varMaps finds varIn and varOut maps for a node>>=
  let inmap,outmap = VM.sync_maps inmap outmap in
  let defmap = outmap in
  let outmap = expire_dead_defs outmap in
  state,inmap,defmap,outmap in
@
In [[expire_last_uses]], the guard supports instructions such as $x := x + y$; where
both x's must be the same register. It is the expander's responsibility to place the x's
in different temps if more flexibility is desired.
<<define remove\_last\_uses, alloc, initial\_inmap, and alloc\_hw\_regs>>=
let expire regset guard map =
  RS.fold (fun t m -> if guard t m then m
                      else List.fold_right (VM.remove t) (VM.var_locs m t) m)
          (rem_regs target regset) map in
let expire_last_uses =
  expire uses (fun t m -> RS.mem t live_out || RS.mem t defs) in
let expire_dead_defs = expire defs (fun t m -> RS.mem t live_out) in

let initial_inmap state preds succs =
  match preds with
  | n::_ -> IM.find (G.num n) state.varOutMaps
  | []   -> VM.empty in
@
The predecessor's outmap must map each live\_in temp to some location.
<<check pred map invariant>>=
  let () = let temp_live_in,_ = partition_regs target live_in in
           assert (RS.fold (fun t b -> b && not (null (VM.var_locs inmap t)))
                           temp_live_in true) in
@
%-------------------------------------------------------------------
\subsection{Spilling}
%-------------------------------------------------------------------
Spilling a temp from a register requires that we modify the state in addition to the
varmaps because we may have to set a spill location for the temp.
<<define spill functions>>=
  let spill state (_,_,w as temp) reg map =
    let (state,spill_loc) =
      try state,RM.find temp state.spillMap
      with Not_found ->
        let l = Automaton.allocate proc.Proc.priv w "" in
        ({state with spillMap = RM.add temp l state.spillMap},l) in
    (state,VM.add temp (Mem spill_loc) (VM.remove temp (Reg reg) map)) in
  let spill_reg guard (state, map) reg =
    match VM.reg_contents map reg with
    | Some t when guard t -> spill state t reg map
    | _                   -> (state,map) in
@
%-------------------------------------------------------------------
\subsection{Choosing a Register for a Single Temp}
%-------------------------------------------------------------------
<<choose\_register>>=
  let default_alloc (state, map, a, c, h) t =
    match (a, c, h) with
    | (r::rst, _,      _)      -> (state, VM.add t (Reg r) map, rst, c, h)
    | ([],     r::rst, _)      -> let (state,map) = spill_reg true_fun (state, map) r in
                                  (state, VM.add t (Reg r) map, a, rst, h)
    | ([],     [],     r::rst) -> let (state,map) = spill_reg true_fun (state, map) r in
                                  (state, VM.add t (Reg r) map, a, c, rst)
    | ([],     [],     [])     ->
        Impossible.impossible "No register available for temp" in
  let get_avail_reg ((state, map, a, c, h) as s) t reg fail =
    match List.partition ((=) reg) a with
    | [r], rst -> (state, VM.add t (Reg r) map, rst, c, h)
    | _   -> fail s t in
  (* include preferences *)
  let alloc_prefs s t =
    try get_avail_reg s t (choose_reg prefs.varMap t) default_alloc
    with Not_found -> default_alloc s t in
  (* include copy propagation *)
  let alloc_copy order map s t =
    match get_copy_regs node with
    | Some regs ->
      let (to_alloc, other) = order regs in
      if to_alloc = t then
         (try let r = if is_tmp target other then choose_reg map other else other in
              get_avail_reg s t r alloc_prefs
          with Not_found -> alloc_prefs s t)
      else alloc_prefs s t
    | None  -> alloc_prefs s t in
  let alloc_uses          = alloc_copy (fun (d,s) -> (s,d)) prefs.varMap in
  let alloc_defs uses_map = alloc_copy (fun (d,s) -> (d,s)) uses_map     in
  let allocate f s to_alloc = List.fold_left f s to_alloc in

  let (state,inmap,_,_,_) =
    allocate alloc_uses (state, inmap, avail, cheap, hicost) to_alloc in
@
%-------------------------------------------------------------------
\subsection{Shuffling Establishes Consistency}
%-------------------------------------------------------------------
  loads = in succ\_vm, but not in pred\_vm

  moves = in both, but not in same place

  stores = in pred\_vm, but not in succ\_vm; live into succ

We assume each variable is in a maximum of one register and a maximum of one memory
location.
<<definition of shuffle>>=
let do_shuffle effs =
  let strip_store rtl = match Rtl.Dn.rtl rtl with
    | RP.Rtl [(_,RP.Store (l, r, w))] -> (l, r, w)
    | _ -> Impossible.impossible "DLS bug: non-simple rtl in register shuffle" in
  let rec shuffle = function
    | []          -> []
    | ((l, (r:RP.exp), w) :: rest) as effs ->
        let assign l r w = Rtl.Up.effect (RP.Store (l, r, w)) in
        <<definition of [[try_first_effect]]>>
        try_first_effect effs
          (fun (l, r, w) rest -> assign l r w :: shuffle rest)
          (fun () ->
            (* NOT IDEAL -- SHOULD TRY TO MOVE THROUGH A REG FIRST.... *)
            match l, r with
            | RP.Reg lreg, RP.Fetch (RP.Reg rreg,_) ->
                let m = Automaton.allocate proc.Proc.priv w "" in
                List.concat [ target.Target.spill  (Target.space target) rreg m
                            ; shuffle rest
                            ; target.Target.reload (Target.space target) lreg m
                            ]
            | _ -> Impossible.impossible "Shuffle with non-reg as lhs or rhs")
  in shuffle (List.map strip_store effs) in
<<definition of [[try_first_effect]]>>=
let try_first_effect effects succ fail =
  let rec maybe bad = function
    | [] -> fail () (* Circular register moves *)
    | (l, r, w) :: rest ->
        let alias (_, r, _) = RU.MayAlias.exp' l r in
        if not (List.exists alias bad || List.exists alias rest) then
          succ (l, r, w) (List.rev_append bad rest)
        else
          maybe ((l, r, w) :: bad) rest in
  maybe [] effects in
@ 
<<definition of shuffle>>=
let shuffle state pred succ =
  let pred_vm   = IM.find (G.num pred) state.varOutMaps in
  let succ_vm   = IM.find (G.num succ) state.varInMaps  in
  let handle_locs temp succ_locs ((ms,ls,ss) as sets) =
    match (get_locs pred_vm temp, succ_locs) with
    | ([Reg p], [Reg s]) when p = s -> sets
    | ([Reg p], [Reg s])            -> (RS.add temp ms,ls,ss)
    | ([Mem p], [Reg s])            -> (ms,RS.add temp ls,ss)
    | ([Mem p], [Mem s]) when p = s -> sets
    | ([Mem p], [Mem s])            ->
      Impossible.impossible "Temp uses multiple memory locations"
    | ([Reg p], [Mem s])            -> (ms,ls,RS.add temp ss)
    | ([]     , [Reg _]) | ([]     , [Mem _]) ->
       Error.warningPrt ("Warning: Temp used without being initialized in proc " ^
					               (proc.Proc.symbol#original_text) ^ "\n");
       (ms,ls,ss) (* temp undef in pred *)
    | (_      , _      )            ->
        Impossible.impossible "Varmap has temp in unexpected locations" in
  let moves, loads, stores = VM.fold handle_locs succ_vm (RS.empty,RS.empty,RS.empty) in
  <<definition of make\_shuffle>>
  if RS.is_empty loads && RS.is_empty moves && RS.is_empty stores
  then state
  else make_shuffle () in
@

Make the shuffle instructions and add them into the cfg.
<<definition of make\_shuffle>>=
let make_shuffle () =
  let spill_slot_for (_,_,w) = Automaton.allocate proc.Proc.priv w "" in
  let space = Target.space target in
  let mk_spill_locs state set =
    RS.fold (fun t state ->
               if RM.mem t state.spillMap then state
               else {state with spillMap = RM.add t (spill_slot_for t) state.spillMap})
            set state in
  let state = mk_spill_locs (mk_spill_locs state loads) stores in
  let mem_access f vm tempset =
    RS.fold (fun t rst -> f space (choose_reg vm t) (RM.find t state.spillMap) @ rst)
            tempset [] in
  let load_rtls  = mem_access target.Target.reload succ_vm loads  in
  let store_rtls = mem_access target.Target.spill  pred_vm stores in
  let move_rtls  =
    RS.fold (fun (_,_,w as t) rst ->
               Rtl.store (Rtl.reg (choose_reg succ_vm t))
                         (Rtl.fetch (Rtl.reg (choose_reg pred_vm t)) w) w :: rst)
            moves [] in
  let nodes = List.map (fun rtl -> G.instruction cfg rtl ~succ:(G.illegal cfg))
                       (List.concat [store_rtls; do_shuffle move_rtls; load_rtls]) in
  let _ = List.fold_left
            (fun pred node -> (G.splice_on_every_edge_between ~entry:node ~exit:node
                                                              ~pred ~succ
                              ; node))
            pred nodes in
  state in
@
%-------------------------------------------------------------------
\subsection{Utilities}
%-------------------------------------------------------------------
<<printers>>=
let indent = "  "
let printTempSet msg set =
  Printf.eprintf msg;
  RS.iter (fun t -> Printf.eprintf "%s%s\n" indent (printReg t)) set;
  flush stderr
let printTempMap msg map =
  Printf.eprintf msg;
  RM.iter (fun t r -> Printf.eprintf "%s%s -> %s\n" indent (printReg t)
                                                           (printReg r)) map;
  flush stderr

let print_cfg cfg =
  let () = Printf.eprintf "\n\n\nBEGIN CFG\n" in
  let () = G.iter_nodes (fun n -> Printf.eprintf "%s\n" (G.print_node n)) cfg in
  let () = Printf.eprintf "END CFG\n" in
  flush stderr
@

Simple utilities used for register allocation.
Most of the functions are not even specific to this particular algorithm.
<<register utilities>>=
let part = List.partition
let printReg (s, i, w) = Printf.sprintf "%c%d" s i
let true_fun _ = true
let diff  lst set = List.filter (fun r -> not (RS.mem r set)) lst
let inter lst set = List.filter (fun r -> RS.mem r set) lst

exception Evict of Register.t * Register.t
let is_tmp target (s,_,_) = Target.is_tmp target s
let rem_regs target temps = RS.filter (is_tmp target) temps
let get_hw_regs target temps = RS.filter (fun t -> not (is_tmp target t)) temps
let partition_regs target temps = RS.partition (is_tmp target) temps
let get_copy_regs node =
  match G.to_instr node with
    | Some i ->
      (match Rtlutil.RTLType.singleAssignment i with
       | (Some (r1, r2) as copy) -> copy
       | _                       -> None)
    | None   -> None
let ( ++ ) = RS.union 
let irwk = Rtlutil.ReadWriteKill.sets
let defs node =
  let defs = match G.to_instr node with
    | None   -> RS.empty
    | Some i -> let uses, defs, kills = irwk i in defs ++ kills in
  G.union_over_outedges node (fun n -> defs)
    (fun {G.defs = d; G.kills = k} -> defs ++ d ++ k)
let uses node =
  let uses =
    match G.to_instr node with
    | None   -> RS.empty
    | Some i -> let uses, defs, kills = irwk i in uses in
  G.add_inedge_uses node uses
@
<<utilities>>=
let null = function [] -> true | _ -> false

let get_locs vm t = try VM.var_locs vm t with Not_found -> []
let get_regs vm t =
  List.fold_left (fun rst l -> match l with Reg r -> r::rst | _ -> rst)
                 [] (get_locs vm t)
let choose_reg vm t =
  match get_regs vm t with
  | r::_ -> r
  | []   -> raise Not_found

let setFromList l = List.fold_left (fun set r -> RS.add r set) RS.empty l
let is_allocated state node = IS.mem (G.num node) state.allocated
let is_visited   state node = IS.mem (G.num node) state.visited
let mark_allocated state node =
  {state with allocated = IS.add    (G.num node) state.allocated}
let mark_visited state node =
  {state with visited   = IS.add    (G.num node) state.visited}
let unmark_visited state node =
  {state with visited   = IS.remove (G.num node) state.visited}

let set_varIn  state node varIn =
  {state with varInMaps  = IM.add (G.num node) varIn  state.varInMaps}
let set_varOut state node varOut =
  {state with varOutMaps = IM.add (G.num node) varOut state.varOutMaps}

let make_map target reg_map reg =
  if is_tmp target reg
  then try  choose_reg reg_map reg
       with Not_found ->
         ( VM.print "" reg_map
         ; flush stderr
         ; Impossible.impossible ("DLS: failed to allocate temp " ^ (printReg reg))
         )
  else reg

let rewrite_defs target node varIn  =
  G.update_instr (Rtlutil.Subst2.reg_def ~map:(make_map target varIn))  node
let rewrite_uses target node varOut =
  G.update_instr (Rtlutil.Subst2.reg_use ~map:(make_map target varOut)) node

(*(time fn written by John Harrison)*)
let time f x =
  let start_time = Sys.time()  in
  let result = f x             in
  let finish_time = Sys.time() in
  print_string
    ("CPU time (user) used by dls():"^(string_of_float(finish_time -. start_time)));
  print_newline();
  result
@

%-------------------------------------------------------------------
\subsection{Exporting to Lua}
%-------------------------------------------------------------------
Boilerplate for exposing this register allocator to Lua.
<<dls.mli>>=
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.M'.action)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Ast2ir.proc
                                  and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.USERCODE with type 'a userdata' = 'a BackplaneT.combined
@
More code for exposing the register allocator to Lua.
<<dls.ml>>=
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.M'.action)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Ast2ir.proc
                                  and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.USERCODE with type 'a userdata' = 'a BackplaneT.combined = struct
  type 'a userdata' = 'a BackplaneT.combined
  module M (Interp : Lua.Lib.CORE with type 'a V.userdata' = 'a userdata') = struct

    <<dls type declarations and utilities>>
    <<dls algorithm>>

    module V       = Interp.V
    let proc       = ProcT.makemap V.userdata V.projection
    let ( **-> )   = V.( **-> )
    let stageFn    = V.unit **-> proc **-> V.result V.bool
    let dls_module = [ "dls", V.efunc stageFn dls ]

    let init g =
      Interp.register_module "DLS" dls_module g;
      Lua.Lib.StringList.empty (* FIX -- replace with init code *)
  end
end
@
