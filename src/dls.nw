%cg. -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
%-------------------------------------------------------------------
\section{DFS Linear Scan Register Allocation}
%-------------------------------------------------------------------

Before digging into the algorithm, we have a few shorthands for module names
and some type declarations.
The utilities are largely uninteresting, so we leave their exposition until
later.
<<dls type declarations and utilities>>=
type reg = Register.t
module RP = Rtl.Private
module RU = Rtlutil
module G = Cfgx.M
module IntMod = struct type t = int let compare = compare end
module IS = Set.Make (IntMod)
module IM = Map.Make (IntMod)
module RM = Register.Map
module RS = Register.Set
let printReg (s, i, w) = Printf.sprintf "%c%d" s i

<<register utilities>>
<<varmap module type>>
module VM = OneLocVarMap


<<type declarations>>
<<printers>>
<<utilities>>
@

A [[varMap]] maps a temp (temporary register) to a hardware register.
It is a dynamic invariant that the domain of this function contains only
temps and the range contains only hardware registers.
The [['a state]] is used to pass information as we traverse the flow graph:
\begin{itemize}
\item allocated:  the set of nodes that have been allocated (by node number)
\item stackMap:   a map from a temp to its spill location
\item varInMaps:  a map from a node (by node number) to the varMap representing
                  the location of eachtemp live\_in to the node
\item varOutMaps: a map from a node (by node number) to the varMap representing
                  the location of each temp live\_out from the node
\end{itemize}
<<type declarations>>=
type preferences = { varMap : VM.t
                   ; regs   : reg list
                   }

type state = { allocated  : IS.t
             ; visited    : IS.t
             ; stackMap   : Automaton.loc RM.t
             ; varInMaps  : VM.t IM.t
             ; varOutMaps : VM.t IM.t
             }
@
The preferences come in two forms: the register order and the variable map.
The register order indicates the order in which we assign registers.
The variable map suggests where a variable should be placed (if there is a choice).
We expect that the [[alloced_preds]] argument to [[update_pref_varmap]] holds all the
predecessors of the current node that have already been handled by the register
allocator (and therefore have useful outmaps).
Currently, the choice of predecessor is arbitrary.
<<updating preferences>>=
let update_pref_varmap state prefs alloced_preds =
  match alloced_preds with
  | []   -> prefs
  | p::_ -> { prefs with varMap = IM.find (G.num p) state.varOutMaps } in

let update_pref_regorder prefs node =
  let temp_defs,hw_defs = partition_regs target (defs node)           in
  let regs t =
    let lookup t = try VM.var_locs prefs.varMap t with Not_found -> [] in
    List.fold_left (fun rst t -> match t with
                            | Reg r -> r::rst
                            | Mem _ -> rst)
                   [] (lookup t) in
  let to_avoid = RS.fold (fun t rst -> List.fold_right RS.add (regs t) rst)
                         temp_defs (RS.inter hw_defs alloc_regset) in
  { prefs with regs = (diff prefs.regs to_avoid @ RS.elements to_avoid) } in

@
[[rpo_dfs]] traverses the cfg by a DFS, calling [[alloc_node]] in a reverse post-order.
This order ensures that [[alloc_node]] is called on each predecessor of a node $n$
before [[alloc_node]] is applied to $n$.

[[dls]] puts the allocator together: [[rpo_dfs]] is called with [[alloc_node]] to
place each temp at a node.
[[alloc_node]] calls [[choose_varMaps]] to decide where each temp belongs.
<<rpo_dfs determines the order for visiting nodes>>=
<<updating preferences>>
let rpo_dfs (state, prefs) =
  let rec visit (state, prefs) node =
    let state = mark_visited state node in
    let prefs = update_pref_regorder prefs node in
    let part  = List.partition                                                  in
    let preds = G.preds node in
    let (vis_preds, unvis_preds) = part (is_visited state) preds in

    let visit_pred (state, delays) node =
      let prefs = update_pref_varmap state prefs
                                     (List.filter (is_allocated state) preds) in
      let (state, new_ds) = visit (state, prefs) node in
      (state, new_ds @ delays) in
    let (state, delays) = List.fold_left visit_pred (state, []) unvis_preds in
    let (alloc_preds, unalloc_preds) = part (is_allocated state) preds in
    if null unalloc_preds || not (null alloc_preds)
    then (alloc_node state prefs node, delays)
    else (unmark_visited state node, [(prefs, node)]) in
  let rec handle_delays (state, ds) = match ds with
    | []  -> state
    | _   -> List.fold_left (fun s (p, n) -> handle_delays (visit (s, p) n)) state ds in
  handle_delays (visit (state, prefs) (G.exit cfg)) in
@
<<dls algorithm>>=
let dls () ({Proc.cfg = cfg; Proc.cc = cc; Proc.target = target} as proc) =
(* let () = print_cfg cfg in*)
  <<definition of shuffle>>
  let fits (s,_,_) r = Target.fits target s r  in
  let alloc_regset = cc.Call.volregs ++ cc.Call.pre_nvregs in
  <<choose_varMaps finds varIn and varOut maps for a node>>
  <<alloc_node allocates registers at a single node>>
  <<rpo_dfs determines the order for visiting nodes>>
  let state' = rpo_dfs (empty_state (RS.elements alloc_regset)) in
  let () = cleanup   cfg in
  (* let () = print_cfg cfg in *)
  true

module V = Interp.V
let proc = ProcT.makemap V.userdata V.projection
let ( **-> ) = V.( **-> )
let stageFn  = V.unit **-> proc **-> V.result V.bool
let dls_module = [ "dls", V.efunc stageFn dls ]
@

PARAMETERIZE BY: choose_varMaps

To allocate registers at a single node, we follow a simple process:
\begin{enumerate}
\item Find predecessors and successors of [[node]].
\item Choose a varMaps for [[node]].
\item Rewrite the instruction to reflect the placement of temps in the varMaps.
\item Insert a shuffle of moves, loads, and stores to settle differences
      between varMaps in adjacent nodes.
\end{enumerate}
<<alloc_node allocates registers at a single node>>=
let up_visit state node = () in
let alloc_node state prefs node =
  let state = mark_allocated state node in
  (*let () = Printf.eprintf "\nAllocating at node %d\n" (G.num node) in*)
  let preds = List.filter (is_allocated state) (G.preds node)               in
  let succs = List.filter (is_allocated state) (G.succs node)               in

  let state, varIn, defMap, varOut = choose_varMaps state prefs node preds succs   in
  let state = set_varIn  state node varIn                                      in
  let state = set_varOut state node varOut                                     in

  (*
  let () = Printf.eprintf "\nVarmaps for node %d\n" (G.num node) in
  let () = Printf.eprintf "varInMap:\n" in
  let () = VM.print varIn in
  let () = Printf.eprintf "defMap:\n" in
  let () = VM.print defMap in
  let () = Printf.eprintf "varOutMap:\n" in
  let () = VM.print varOut in
  *)

  let () = rewrite_uses target node varIn                                      in
  let () = rewrite_defs target node defMap                                     in
 let state = List.fold_left (fun state p -> shuffle state p node) state preds in
 let state = List.fold_left (fun state s -> shuffle state node s) state succs in
 {state with allocated = IS.add (G.num node) state.allocated} in
@
We clean up any move instruction where the source register is the same as the
destination register.
We are careful to accumulate the list of nodes we intend to delete before deleting them
because we do not want to modify the cfg while traversing it.
<<alloc_node allocates registers at a single node>>=
let cleanup cfg =
  let visit_node node rst =
    match get_copy_regs node with
    | Some (r1,r2) when r1 = r2 -> node::rst
    | _                         -> rst in
  List.iter G.delete (G.fold_nodes visit_node [] cfg) in
@

[[choose_varMaps]] is responsible for choosing the varMaps in and
out of each node.
This particular version does not do any preferencing.
We begin by gathering some useful information about registers
at the node.
<<choose_varMaps finds varIn and varOut maps for a node>>=
let choose_varMaps state prefs node preds succs =
  let defs = defs node                                         in
  let uses = uses node                                         in
  let live_in       = Cfgx.Live.live_in  node                  in
  let live_out      = Cfgx.Live.live_out node                  in
  (*let () = printTempSet "Live_in:\n" live_in in
  let () = printTempSet "Live_out:\n" live_out in
	*)
  let temp_uses,hw_uses = partition_regs target uses           in
  let temp_defs,hw_defs = partition_regs target defs           in

  <<define remove_last_uses, alloc, initial_inmap, and alloc_hw_regs>>

  let inmap = initial_inmap state preds succs in
  (*let () = Printf.eprintf "Initial inmap from %d preds:\n" (List.length preds) in
  let () = VM.print inmap in
	*)
  let () = 
    let temp_live_in,_ = partition_regs target live_in in
    assert (RS.fold (fun t b -> b && not (null (VM.var_locs inmap t)))
                    temp_live_in true) in

  let reg_classes = VM.classify_inregs target prefs.regs inmap node in
  let avail,cheap,hicost,unavail,unavail_lo =
    VM.unused                 reg_classes, VM.used_free_evict reg_classes,
    VM.used_can_spill         reg_classes, VM.unavailable     reg_classes,
	 	VM.unavailable_if_liveout reg_classes                                  in
  (*let () = printTempSet "Unavailable inregs (must spill):\n" (setFromList unavail)
	 in*)
@
Spilling a temp from register requires that we modify the state in addition to the
varmaps because we may have to set a spill location for the temp.
<<choose_varMaps finds varIn and varOut maps for a node>>=
  let spill state temp reg map =
    let spill_slot_for (_,_,w) = Automaton.allocate proc.Proc.priv w "" in
    let (state,spill_loc) =
      try state,RM.find temp state.stackMap
      with Not_found ->
        let l = spill_slot_for temp in
        ({state with stackMap = RM.add temp l state.stackMap},l) in
    (state,VM.add temp (Mem spill_loc) (VM.remove temp (Reg reg) map)) in
  let spill_temp state temp map = spill state temp (choose_reg map temp) map in
  let spill_reg  state reg  map =
    match VM.loc_contents map (Reg reg) with
    | Some t -> spill state t reg map
    | None   -> Impossible.impossible "Trying to spill register that is empty?" in
@
If any temps are in an unavailable register, then we need to spill the temp from that
register.
There is an opportunity for optimization here: even if the temp is not used in this
instruction, we could try to allocate it to a register if there are any free registers.
This optimization would insert a move instruction instead of a store.
<<choose_varMaps finds varIn and varOut maps for a node>>=
  let state,inmap =
    List.fold_left (fun (s,map) r -> match VM.loc_contents map (Reg r) with
                                     | Some t -> spill s t r map
                                     | None   -> (s,map))
                   (state,inmap) unavail in
  let state,inmap =
    List.fold_left (fun (s,map) r -> match VM.loc_contents map (Reg r) with
                                     | Some t when RS.mem t live_out -> spill s t r map
                                     | _ -> (s,map))
                   (state,inmap) unavail_lo in
  (*let () = Printf.eprintf "inmap after removing unavailable registers:\n" in
  let () = VM.print inmap in
	*)
@
Check each of the temps that remain to be allocated.
If a temp is already in a register, then we remove that register from the [[hicost]]
and [[cheap]] sets (alternatively, we could check whether the var is also in memory to
figure out which set to remove from).
After this part, this inmap is done.
<<choose_varMaps finds varIn and varOut maps for a node>>=
  let remove_preallocs map to_alloc cheap hicost =
    let to_alloc', regs_used =
      RS.fold (fun t (rst, r_used) -> try let r = choose_reg map t in
                                          (rst, RS.add r r_used)
                                      with Not_found -> (t::rst,r_used))
              to_alloc ([],RS.empty) in
      (to_alloc', diff cheap regs_used, diff hicost regs_used) in

  let (to_alloc, cheap, hicost) = remove_preallocs inmap temp_uses cheap hicost in

  let default_alloc (state, map, a, c, h) t =
    match (a, c, h) with
    | (r::rst, _,      _)      -> (state, VM.add t (Reg r) map, rst, c, h)
    | ([],     r::rst, _)      -> let (state,map) = spill_reg state r map in
                                  (state, VM.add t (Reg r) map, a, rst, h)
    | ([],     [],     r::rst) -> let (state,map) = spill_reg state r map in
                                  (state, VM.add t (Reg r) map, a, c, rst)
    | ([],     [],     [])     ->
        Impossible.impossible "No register available for temp" in
  let choose_pref ((state, map, a, c, h) as s) t =
    try let r = choose_reg prefs.varMap t in
        let found, rst = List.partition ((=) r) a in
        (match found with
         | [r] -> (state, VM.add t (Reg r) map, rst, c, h)
         | _   -> default_alloc s t)
    with Not_found -> default_alloc s t in
  let choose_pref_with_copy uses_map ((state, map, a, c, h) as s) t =
    match get_copy_regs node with
    | Some (dst, src) when dst = t ->
      let r = if is_tmp target src then choose_reg uses_map src else src in
      let found, rst = List.partition ((=) r) a in
      (match found with
       | [r] -> (state, VM.add t (Reg r) map, rst, c, h)
       | _   -> choose_pref s t)
    | _ -> choose_pref s t in
  let allocate_uses state          map avail cheap hicost to_alloc =
    List.fold_left choose_pref (state,map,avail,cheap,hicost) to_alloc in
  let allocate_defs state uses_map map avail cheap hicost to_alloc =
    List.fold_left (choose_pref_with_copy uses_map)
	                 (state,map,avail,cheap,hicost) to_alloc in


  let (state,inmap,_,_,_) = allocate_uses state inmap avail cheap hicost to_alloc in
  (*let () = Printf.eprintf "inmap after allocation:\n" in
  let () = VM.print inmap in
	*)
@
Now, we expire any temps that die at this node and move on to the defs at the node.
<<choose_varMaps finds varIn and varOut maps for a node>>=
  let midmap = expire_last_uses inmap in
  (*let () = flush stderr; Printf.eprintf "midmap:\n" in
  let () = VM.print midmap in
	*)

  let reg_classes = VM.classify_outregs target prefs.regs midmap node in
  let avail,cheap,hicost,unavail =
    VM.unused reg_classes, VM.used_free_evict reg_classes,
    VM.used_can_spill reg_classes, VM.unavailable reg_classes in
  let state,outmap =
    List.fold_left (fun (s,map) r -> match VM.loc_contents map (Reg r) with
                                     | Some t -> spill s t r map
                                     | None   -> (s,map))
                   (state,midmap) unavail in
  let state,outmap =
    List.fold_left (fun (s,map) r -> match VM.loc_contents map (Reg r) with
                                     | Some t when RS.mem t live_out -> spill s t r map
                                     | _ -> (s,map))
                   (state,outmap) unavail_lo in
  (*let () = printTempSet "unavail regs:\n" (setFromList unavail) in
  let () = Printf.eprintf "outmap after removing unavail regs:\n" in
  let () = VM.print outmap in
	*)
  let (to_alloc, cheap, hicost) = remove_preallocs outmap temp_defs cheap hicost in
  (*let () = printTempSet "\nhw_defs:\n" hw_defs in
  let () = printTempSet "\ntemp_defs:\n" temp_defs in
  let () = printTempSet "\nto_alloc:\n" (setFromList to_alloc)  in
  let () = Printf.eprintf "outmap before allocation:\n" in
  let () = VM.print outmap in
	*)
  let (state,outmap,_,_,_) =
	  allocate_defs state inmap outmap avail cheap hicost to_alloc in
  (*let () = Printf.eprintf "outmap after allocation:\n" in
  let () = VM.print outmap in
	*)
@
Here's an interesting case. If we have a def that is never used again, then we must
assign it a register, but we don't want it in the outmap.
So, we have a separate defmap and outmap, where the defmap keeps any dead definitions.
<<choose_varMaps finds varIn and varOut maps for a node>>=
  let inmap,outmap = VM.sync_maps inmap outmap in
  (*
  let () = Printf.eprintf "outmap after syncing:\n" in
  let () = VM.print outmap in
  *)
  let defmap = outmap in
  let outmap = expire_dead_defs outmap in
  state,inmap,defmap,outmap in
@
  
<<define remove_last_uses, alloc, initial_inmap, and alloc_hw_regs>>=
let expire_last_uses map =
  RS.fold (fun t m -> if RS.mem t live_out || RS.mem t defs then m
                      else List.fold_right (VM.remove t) (VM.var_locs m t) m)
          (rem_regs target uses) map in
let expire_dead_defs map =
  RS.fold (fun t m -> if RS.mem t live_out then m
                      else List.fold_right (VM.remove t) (VM.var_locs m t) m)
          (rem_regs target defs) map in

let initial_inmap state preds succs =
  match preds with
  | n::_ -> IM.find (G.num n) state.varOutMaps
  | []   -> VM.empty in
@

  loads = in succ_vm, but not in pred_vm
  moves = in both, but not in same place
  stores = in pred_vm, but not in succ_vm; live into succ
We assume each variable is in a maximum of one register and a maximum of one memory
location.
<<definition of shuffle>>=
let do_shuffle effs =
  (*let () = Printf.eprintf "Shuffles:\n" in
  let () = List.iter (fun r -> Printf.eprintf "%s\n" (Rtlutil.ToReadableString.rtl r)) effs in
  let () = flush stderr in
	*)
  
  let just_effect rtl = match Rtl.Dn.rtl rtl with
    | RP.Rtl [(_,eff)] -> eff
    | _ -> Impossible.impossible "DLS bug: non-simple rtl in register shuffle" in
  let just_effects = List.map just_effect in
  let strip_store rtl = match Rtl.Dn.rtl rtl with
    | RP.Rtl [(_,RP.Store (l, r, w))] -> (l, r, w)
    | _ -> Impossible.impossible "DLS bug: non-simple rtl in register shuffle" in
  let strip_stores = List.map strip_store in
  let rec shuffle =
    let assign l r w = RP.Store (l, r, w) in
    function
    | []          -> []
    | ((l, (r:RP.exp), w) :: rest) as effs ->
        <<definition of [[try_first_effect]]>>
        try_first_effect effs
          (fun (l, r, w) rest -> assign l r w :: shuffle rest)
          (fun () ->
            (* NOT IDEAL -- SHOULD TRY TO MOVE THROUGH A REG FIRST.... *)
            match l, r with
            | RP.Reg lreg, RP.Fetch (RP.Reg rreg,_) ->
                let m = Automaton.allocate proc.Proc.priv w "" in
                (just_effects (target.Target.spill  (Target.space target) rreg m) @
                 shuffle rest @
                 just_effects (target.Target.reload (Target.space target) lreg m))
                 (*
            let t = Talloc.Multiple.reg proc.Proc.temps 't' 32 in
            (assign (RP.Reg t) r w ::
             [assign l (RP.Fetch (RP.Reg t, w)) w])
            *)
            | _ -> Impossible.impossible "Shuffle with non-reg as lhs or rhs")
  in List.map Rtl.Up.effect (shuffle (strip_stores effs)) in
<<definition of [[try_first_effect]]>>=
let try_first_effect effects succ fail =
  let rec maybe bad = function
    | [] -> fail () (* Circular register moves *)
    | (l, r, w) :: rest ->
        let alias (_, r, _) = RU.MayAlias.exp' l r in
        if not (List.exists alias bad || List.exists alias rest) then
          succ (l, r, w) (List.rev_append bad rest)
        else
          maybe ((l, r, w) :: bad) rest in
  maybe [] effects in
@ 
<<definition of shuffle>>=
let shuffle state pred succ =
  (*let () = Printf.eprintf "Shuffling nodes %d and %d\n" (G.num pred) (G.num succ) in *)
  let pred_vm   = IM.find (G.num pred) state.varOutMaps in
  (*let () = VM.print pred_vm in*)
  let succ_vm   = IM.find (G.num succ) state.varInMaps  in
  (*let () = VM.print succ_vm in*)

  let handle_locs temp succ_locs ((ms,ls,ss) as sets) =
    let partition = List.partition (function | Reg _ -> true | Mem _ -> false) in
    let pred_regs,pred_mems = partition (VM.var_locs pred_vm temp) in
    let succ_regs,succ_mems = partition succ_locs in
    let ((ms,ls,ss) as sets) =
      match (pred_regs,succ_regs) with
      | ([Reg p],[Reg s]) when p = s -> sets
      | ([Reg p],[Reg s])            -> (RS.add temp ms,ls,ss)
      | ([],[Reg s])                 -> (ms,RS.add temp ls,ss)
      | (_ ,[])                      -> sets
      | (_,_)                        ->
          Impossible.impossible "Varmap has temp with multiple register locations" in
    match (pred_mems,succ_mems) with
    | ([Mem p],[Mem s]) when p = s -> sets
    | ([Mem p],[Mem s])            ->
      Impossible.impossible "Temp uses multiple memory locations"
    | ([],[Mem s])                 -> (ms,ls,RS.add temp ss)
    | (_,[])                       -> sets
    | (_,_)                        ->
        Impossible.impossible "Varmap has temp with multiple memory locations" in
  let moves,loads,stores =
    VM.fold (fun temp locs lsts -> handle_locs temp locs lsts)
            succ_vm (RS.empty,RS.empty,RS.empty) in
  <<definition of make_shuffle>>
  (*print_cfg cfg;*)
  let s = 
    if RS.is_empty loads && RS.is_empty moves && RS.is_empty stores
    then state
    else make_shuffle () in
  (*print_cfg cfg;*) s in
@

Make the shuffle instructions and add them into the cfg.
<<definition of make_shuffle>>=
let make_shuffle () =
  let spill_slot_for (_,_,w) = Automaton.allocate proc.Proc.priv w "" in
  let space = Target.space target in
  let state =
    RS.fold (fun t state ->
               if RM.mem t state.stackMap then state
               else {state with stackMap = RM.add t (spill_slot_for t) state.stackMap})
            (RS.union loads stores) state in
  let mem_access f vm tempset =
    RS.fold (fun t rst -> f space (choose_reg vm t) (RM.find t state.stackMap) @ rst)
            tempset [] in
  let load_rtls  = mem_access target.Target.reload succ_vm loads  in
  let store_rtls = mem_access target.Target.spill  pred_vm stores in
  let move_rtls  =
    RS.fold (fun (_,_,w as t) rst ->
               Rtl.store (Rtl.reg (choose_reg succ_vm t))
                         (Rtl.fetch (Rtl.reg (choose_reg pred_vm t)) w) w :: rst)
            moves [] in
  let nodes = List.map (fun rtl -> G.instruction cfg rtl ~succ:(G.illegal cfg))
                       (List.concat [store_rtls; do_shuffle move_rtls; load_rtls]) in
 (* let () = if not (null nodes) then Printf.eprintf "SHUFFLE_CFG\n" ; print_cfg cfg
  in*)
  let _ = List.fold_left
            (fun pred node -> (G.splice_on_every_edge_between ~entry:node ~exit:node
                                                              ~pred ~succ
                              ; node))
            pred nodes in
  (*let () = if not (null nodes) then print_cfg cfg in*)
  state in
@

<<printers>>=
let printTempSet msg set =
  let indent = "  " in
  Printf.eprintf msg;
  RS.iter (fun t -> Printf.fprintf stderr "%s%s\n" indent (printReg t)) set;
  flush stderr
let printTempMap map =
  let indent = "  " in
  RM.iter (fun t r -> Printf.fprintf stderr "%s%s -> %s\n" indent (printReg t)
                                                                  (printReg r)) map;
  flush stderr
@

Simple utilities used for register allocation.
Most of the functions are not even specific to this particular algorithm.

<<register utilities>>=
let diff  lst set = List.filter (fun r -> not (RS.mem r set)) lst
let inter lst set = List.filter (fun r -> RS.mem r set) lst

exception Evict of Register.t * Register.t
let is_tmp target (s,_,_) = Target.is_tmp target s
let rem_regs target temps = RS.filter (is_tmp target) temps
let get_hw_regs target temps = RS.filter (fun t -> not (is_tmp target t)) temps
let partition_regs target temps = RS.partition (is_tmp target) temps
let get_copy_regs node =
  match G.to_instr node with
    | Some i ->
      (match Rtlutil.RTLType.singleAssignment i with
       | (Some (r1, r2) as copy) -> copy
       | _                       -> None)
    | None   -> None
let ( ++ ) = RS.union 
let irwk = Rtlutil.ReadWriteKill.sets
let defs node =
  let defs = match G.to_instr node with
    | None   -> RS.empty
    | Some i -> let uses, defs, kills = irwk i in defs ++ kills in
  G.union_over_outedges node (fun n -> defs)
    (fun {G.node = n'; G.defs = d; G.kills = k} -> defs ++ d ++ k)
let uses node =
  let uses =
    match G.to_instr node with
    | None   -> RS.empty
    | Some i -> let uses, defs, kills = irwk i in uses in
  G.add_inedge_uses node uses
@
<<utilities>>=
let null = function [] -> true | _ -> false

(* val choose_reg : VarMap.t -> temp -> Register.t *)
let choose_reg vm t =
  match List.find (function Reg _ -> true | Mem _ -> false) (VM.var_locs vm t) with
  | Reg r -> r
  | Mem _ -> raise Not_found

let empty_state regs = ( { allocated  = IS.empty
                         ; visited    = IS.empty
                         ; stackMap   = RM.empty
                         ; varInMaps  = IM.empty
                         ; varOutMaps = IM.empty
                         }
                       , { varMap = VM.empty; regs = regs }
                       )

let setFromList l = List.fold_left (fun set r -> RS.add r set) RS.empty l
let is_allocated state node = IS.mem (G.num node) state.allocated
let is_visited   state node = IS.mem (G.num node) state.visited
let mark_allocated state node =
  {state with allocated = IS.add    (G.num node) state.allocated}
let mark_visited state node =
  {state with visited   = IS.add    (G.num node) state.visited}
let unmark_visited state node =
  {state with visited   = IS.remove (G.num node) state.visited}

let set_varIn  state node varIn =
  {state with varInMaps  = IM.add (G.num node) varIn  state.varInMaps}
let set_varOut state node varOut =
  {state with varOutMaps = IM.add (G.num node) varOut state.varOutMaps}

let make_map target reg_map reg =
  try  choose_reg reg_map reg
  with Not_found ->
    if is_tmp target reg
    then
      ( VM.print reg_map
      ; flush stderr
      ; Impossible.impossible ("DLS: failed to allocate temp " ^ (printReg reg))
      )
    else reg

let rewrite_defs target node varIn  =
  G.update_instr (Rtlutil.Subst2.reg_def ~map:(make_map target varIn))  node
let rewrite_uses target node varOut =
  G.update_instr (Rtlutil.Subst2.reg_use ~map:(make_map target varOut)) node

let print_cfg cfg =
  let () = Printf.fprintf stderr "\n\n\nBEGIN CFG\n" in
  let () = G.iter_nodes (fun n -> Printf.fprintf stderr "%s\n" (G.print_node n)) cfg in
  let () = Printf.fprintf stderr "END CFG\n" in
  flush stderr
@

Boilerplate for exposing this algorithm to Lua.
<<dls.mli>>=
module DLSType : Lua.Lib.USERTYPE
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.M'.action)
            (DLSType : Lua.Lib.TYPEVIEW with type 'a t = 'a DLSType.t
                                  and type 'a combined = 'a BackplaneT.combined)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Ast2ir.proc
                                  and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.USERCODE with type 'a userdata' = 'a BackplaneT.combined
@
More code for exposing the register allocator to Lua.
There is currently no type defined for this module - I am not using
the "typeless" constructor because I will probably want to have a type here
soon.
<<dls.ml>>=
type 'a ty = 'a

module DLSType = struct
  type 'a t = 'a ty
  let tname = "DLS"
  let eq _ a b = a = b
  let to_string pr t = "DLS Type"
end

module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.M'.action)
            (DLSType : Lua.Lib.TYPEVIEW with type 'a t = 'a DLSType.t
                                  and type 'a combined = 'a BackplaneT.combined)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Ast2ir.proc
                                  and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.USERCODE with type 'a userdata' = 'a BackplaneT.combined = struct
  type 'a userdata' = 'a BackplaneT.combined
  module M (Interp : Lua.Lib.CORE with type 'a V.userdata' = 'a userdata') = struct

    <<dls type declarations and utilities>>
    <<dls algorithm>>

    let init g =
      Interp.register_module "DLS" dls_module g;
      Lua.Lib.StringList.empty (* FIX -- replace with init code *)
  end
end
@

<<varmap module type>>=
type temp = Register.t
type loc = Reg of Register.t
         | Mem of Automaton.loc
let string_of_loc = function | Reg r -> printReg r | Mem _ -> "mem_loc"
module LocComp = struct type t = loc let compare = compare end
module LS = Set.Make (LocComp)

type tgt = ((Rtl.exp -> Automaton.t), Call.t) Target.t

module type VarMap = sig
  type t
  type reg_classes

  val empty            : t
  val add              : temp  -> loc -> t -> t
  val fold             : (temp -> loc list -> 'a -> 'a) -> t -> 'a -> 'a
  val remove           : temp  -> loc -> t -> t
  val var_locs         : t -> temp -> loc list
  val loc_contents     : t -> loc -> temp option
  val sync_maps        : t -> t -> t * t
  val print            : t -> unit

  val classify_inregs  : tgt -> reg list -> t -> Rtl.rtl G.node -> reg_classes
  val classify_outregs : tgt -> reg list -> t -> Rtl.rtl G.node -> reg_classes
  val unused           : reg_classes -> reg list
  val used_free_evict  : reg_classes -> reg list
  val used_can_spill   : reg_classes -> reg list
  (* Unavailable means that the register not only cannot be used to satisfy an
   * allocation, but any temp using the register must be evicted.
   * It is possible that the union of these four sets will not contain all the
   * registers. For example, in a variable map that can only keep each variable
   * in one location, if we have a temp that is placed in a register for
   * a use, then that register cannot be used for a definition if the variable is
   * live_out. But that does not mean we need to evict the variable, which would be
   * wrong. Instead, we just need to avoid using that register.
   *)
  val unavailable            : reg_classes -> reg list
  val unavailable_if_liveout : reg_classes -> reg list
end

module OneLocVarMap : VarMap = struct
  exception Found of temp
  type t = loc RM.t
  type reg_classes = { regs_unused        : reg list
                     ; regs_cheap         : reg list
                     ; regs_hicost        : reg list
                     ; regs_unavail       : reg list
                     ; regs_unavail_if_lo : reg list
                     }

  let empty = RM.empty
  let add   = RM.add
  let fold fn vm zero = RM.fold (fun t ls z -> fn t [ls] z) vm zero
  let remove temp loc vm =
    if RM.find temp vm = loc then RM.remove temp vm
    else Impossible.impossible "Removing temp from a loc it is not in"
  let var_locs vm temp = [RM.find temp vm]
  let loc_contents vm loc =
    try (RM.iter (fun t loc2 -> if loc = loc2 then raise (Found t)) vm; None)
    with Found t -> Some t
@

If the outmap incurrs spills for a temp that is in a reg in the inmap, then we need to
to reflect the spill in the inmap.
We assume that any spilled temp is not used in the instruction (which would make this
register assignment illegal for this representation).
Recall that in this representation, a temp can only be in one location -- a register or
a memory slot.
Note: we are folding over the outmap, with the inmap as the accumulating parameter.
<<varmap module type>>=
  let sync_maps inmap outmap =
    (RM.fold (fun temp loc inmap' ->
                match loc with
                | Mem l when RM.mem temp inmap' &&
                             RM.find temp inmap' <> loc -> RM.add temp loc inmap'
                | _                                     -> inmap')
             outmap inmap, outmap)
@

Printing is easy.
<<varmap module type>>=
  let print vm =
    ( Printf.eprintf "\nOneLocVarMap:\n"
    ; RM.iter (fun t l -> Printf.eprintf "%s -> %s\n" (printReg t) (string_of_loc l)) vm
    ; flush stderr
    )
@

We assume that the variable map only contains live variables -- i.e. no information is
out of date.
<<varmap module type>>=
  let classify_inregs target allregs vm node =
    let defs          = defs node                                in
    let uses          = uses node                                in
    let live_in       = Cfgx.Live.live_in  node                  in
    let live_out      = Cfgx.Live.live_out node                  in

    let hw_regs    = get_hw_regs target (defs ++ live_in ++ live_out)     in
    let regs       = diff allregs hw_regs                        in
    let occupied   =
      RM.fold (fun t l rst -> match l with
                 | Reg r -> RS.add r rst
                 | Mem _ -> rst)
              vm RS.empty                                        in
    { regs_unused        = diff regs occupied
    ; regs_cheap         = []
    ; regs_hicost        = inter regs (RS.diff occupied hw_regs)
		; regs_unavail       = RS.elements (get_hw_regs target live_in)
    ; regs_unavail_if_lo = inter allregs hw_regs
    }
@

If it's used and already in a register, then it's unavail (unless that register is used
by a HW reg).
<<varmap module type>>=
  let classify_outregs target allregs vm node =
    let defs          = defs node                                in
    let uses          = uses node                                in
    let live_in       = Cfgx.Live.live_in  node                  in
    let live_out      = Cfgx.Live.live_out node                  in

    let hw_regs    = get_hw_regs target (defs ++ live_out)       in
    let regs       = diff allregs hw_regs                        in
    let used_regs  =
      RM.fold (fun t l rst -> match l with
                 | Reg r -> RS.add r rst
                 | Mem _ -> rst)
              vm RS.empty                                        in
    let live_out_uses = RS.inter uses (RS.diff live_out defs) in
    let regs_for_live_out_uses =
      RS.fold (fun t set -> match RM.find t vm with
                            | Reg r -> RS.add r set
                            | Mem _ -> set)
              (rem_regs target live_out_uses) RS.empty in
    let cant_alloc = hw_regs ++ regs_for_live_out_uses in
		let unavail = inter allregs hw_regs in
    { regs_unused        = diff regs used_regs
    ; regs_cheap         = []
    ; regs_hicost        = inter regs (RS.diff used_regs cant_alloc)
    ; regs_unavail       = unavail
    ; regs_unavail_if_lo = unavail
    }
@

<<varmap module type>>=
  let unused                 rclasses = rclasses.regs_unused
  let used_free_evict        rclasses = rclasses.regs_cheap
  let used_can_spill         rclasses = rclasses.regs_hicost
  let unavailable            rclasses = rclasses.regs_unavail
  let unavailable_if_liveout rclasses = rclasses.regs_unavail_if_lo
end
@
