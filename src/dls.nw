%cg. -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
%-------------------------------------------------------------------
\section{DFS Linear Scan Register Allocation}
%-------------------------------------------------------------------
The goal of this register allocator is to allocate registers in linear time,
generating as few load and store instructions as possible.
We make two traversals of the cfg; the first traversal determines the order of
the second traversal, which allocates the registers.

This algorithm is very different from graph coloring.
Graph coloring builds up an abstract model of how temps interfere in a procedure.
Our algorithm builds no such representation; instead, liveness information
provides all the information we need to allocate registers.

The important invariant of the graph traversal is that we visit the predecessors of a
node before we visit the node.
Of course, this invariant does not apply to predecessors along backedges.
Also, from join points, we make sure that the information from the allocation of
one predecessor flows to the allocation of the other predecessors.
This information flow allows us to allocate a variable to the same register, so no
extra move instructions are required at the join point.

This algorithm takes its ideas primarily from two sources: linear scan and SSA.
Linear scan register allocation offers the idea of the reverse postorder depth-first
search.
Our contribution is to realize that this graph traversal, coupled only with liveness
information, allows us to treat the graph as if it has the SSA property of static
single-assignment.
Static single-assignment allows us to treat each definition as a separate temp.
Of course, it is a good idea to ensure that if two definitions of a temp are live
into a join point, they should be allocated to the same location; if not, shuffles must
be inserted to place them in the same location.
This behavior at join points is exactly what we would expect from a phi-node in SSA.

Because we take a local, graph-node-by-graph-node perspective, we never spill a temp
unless there are more live temps than registers.
Of course, the big concerns are whether we spill the right temps and whether we have
too many shuffle instructions at join points.
We use preferencing information as heuristics for each of these problems.
More on these later...

%-------------------------------------------------------------------
\section{DFS Linear Scan Register Allocation}
%-------------------------------------------------------------------
Before digging into the algorithm, we have a few shorthands for module names
and some type declarations.
The utilities are largely uninteresting, so we leave their exposition until
later.
<<dls type declarations and utilities>>=
module A  = Automaton
module R  = Register
module RP = Rtl.Private
module Dn = Rtl.Dn
module RU = Rtlutil
module RTD = Runtimedata
module G = Cfgx.M
module IntMod = struct type t = int let compare = compare end
module IS = Set.Make (IntMod)
module IM = Map.Make (IntMod)
module NodeMod = struct type t = Rtl.rtl G.node let compare = Pervasives.compare end
module NM = Map.Make (NodeMod)
module RM = R.Map
module RS = R.Set
module SM = Map.Make (struct type t = Rtl.space let compare = RU.Compare.space end)

type reg  = R.t
type temp = R.t
<<register utilities>>
<<printers>>
<<varmap module type>>
<<varmap module>>
module VM = OneLocVarMap

<<type declarations>>
<<utilities>>
@
%-------------------------------------------------------------------
\subsection{Variable Maps}
%-------------------------------------------------------------------
The variable map is the fundamental data structure that maps variables to locations
(registers and slots on the stack).
It is a dynamic, unchecked invariant that only temps (not hardware registers) are in
the domain of a variable map.

We have some simple types for temps and locations, and location sets.
<<varmap module type>>=
type loc  = Reg of Register.t
          | Mem of Automaton.loc
type tgt = ((Rtl.exp -> Automaton.t), Call.t) Target.t
type loc_pair = { reg : Register.t option; mem : Automaton.loc option }
@
%-------------------------------------------------------------------
\subsubsection{Interface}
%-------------------------------------------------------------------
The variable map supports standard map operations, as well as some unique operations
that help with register allocation.

We have simple constructors to create and empty map, add a temp to a map, and remove a
temp from a map.
<<varmap module type>>=
module type VarMap = sig
  type t
  val empty            : t
  val add              : temp  -> loc -> t -> t
  val remove           : temp  -> loc -> t -> t
@
We can also fold over a map, fold over each location a temp is in (the range), observe
the locations where a temp is stored, observe the temp stored in a register, or print a
map.
<<varmap module type>>=
  val fold             : (temp -> loc list -> 'a -> 'a) -> t -> 'a -> 'a
  val fold_range       : (temp -> loc -> 'a -> 'a)      -> t -> 'a -> 'a
  val var_locs         : t -> temp -> loc list
  val reg_contents     : t -> reg  -> temp option
  val print            : string -> t -> unit
@
The variable map also provides functions to determine which registers are available at
a given node.
The [[reg_classes]] datatype indicates the availability of registers.
The function [[classify_inregs]] determines which registers are available for the temps
used at a node.
The function [[classify_outregs]] determines which registers are available for the temps
defined at a node.
<<varmap module type>>=
  type reg_classes
  val print_reg_classes : string -> reg_classes -> unit
  val classify_inregs   : tgt -> reg list -> t -> Rtl.rtl G.node -> reg_classes
  val classify_outregs  : tgt -> reg list -> t -> Rtl.rtl G.node -> reg_classes
@
The registers may be divided into five categories:
\begin{enumerate}
\item unused: The registers are available for use.
\item used\_free\_evict: The registers are in use but may be evicted without a store
  instruction to spill the contents (because the contents has already been stored).
\item used\_can\_spill: The registers are in use but may be evicted, at the cost of
  a store instruction to spill the contents.
\item unavailable: The registers not only cannot be used to satisfy an allocation, but
  any temp using one of these registers must be evicted.
\item unavailable\_if\_liveout: The registers are unavailable for temps that are
  live\_out.
\end{enumerate}
It is possible that the union of these four sets will not contain all the
registers.
For example, in a variable map that can only keep each variable in one location, if we
have a temp that is placed in a register for a use, then that register cannot be used
for a definition if the variable is live\_out.
But that does not mean we need to evict the variable; we just need to avoid using that
register.
<<varmap module type>>=
  val unused                 : reg_classes -> reg list
  val unused_not_lo          : reg_classes -> reg list
  val used_free_evict        : reg_classes -> reg list
  val used_can_spill         : reg_classes -> reg list
  val unavailable            : reg_classes -> reg list
  val unavailable_if_liveout : reg_classes -> reg list
@
We also provide a function that makes two variable maps consistent.
The first map (the inmap) holds the variable that are live\_in to the node, and the
second map (the outmap) holds the variables that are live\_out of the node.
Because the second map may require spills to be inserted before the node, the maps have
to be synchronized.
<<varmap module type>>=
  val sync_maps        : t -> t -> t * t
end
@
%-------------------------------------------------------------------
\subsubsection{Implementations}
%-------------------------------------------------------------------
We currently have only one implementation of a variable map.
This implementation allows each temp to be stored in only one location at a time.
Our representation keeps a map from temps to locations and register locations to temps
(to facilitate the spilling function, [[reg_contents]]).
<<varmap module>>=
module OneLocVarMap : VarMap = struct
  type t = loc_pair RM.t * temp RM.t
@
The constructors and observers are simple.
<<varmap module>>=
  let empty_pair       = {reg = None; mem = None}
  let def_reg pair r   = {pair with reg = r}
  let def_mem pair m   = {pair with mem = m}
  let pair_to_list p   = match p with
    | {mem = Some m; reg = Some r} -> [Reg r; Mem m]
    | {mem = None  ; reg = Some r} -> [Reg r]
    | {mem = Some m; reg = None  } -> [Mem m]
    | {mem = None  ; reg = None  } -> []
  let pair_map_find    t   m = try RM.find t m with Not_found -> empty_pair
  let upd_pair_map upd t v m = RM.add t (upd (pair_map_find t m) v) m

  let empty            = (RM.empty, RM.empty)
  let remove t l (vm, lm) =
    match l with
    | Reg r ->
      let lm' = RM.remove r lm in
      if Aux.Option.is_none (pair_map_find t vm).mem then
        (RM.remove t vm, lm')
      else
        (upd_pair_map def_reg t None vm, lm')
    | Mem m ->
      if Aux.Option.is_none (pair_map_find t vm).reg then
        (RM.remove t vm, lm)
      else
        (upd_pair_map def_mem t None vm, lm)
@
We allow each temp to be in only one register and one memory location at a time.
There's an interesting time vs. memory tradeoff here:
we could change the remove function such that if it is asked to remove a
temp from a register, it verifies that the [[vm]] map also binds the temp
to the register -- that way, the add function need not change the [[lm]] map,
possibly saving memory.
location of the temp in the [[vm]] map
<<varmap module>>=
  let add t l (vm, lm) = match l with
    | Reg r ->
      let lm = match (pair_map_find t vm).reg with
               | Some r -> RM.remove r lm
               | None   -> lm                 in
      (upd_pair_map def_reg t (Some r) vm, RM.add r t lm)
    | Mem m -> (upd_pair_map def_mem t (Some m) vm, lm)
  let var_locs (vm, _) temp    = pair_to_list (RM.find temp vm)
  let reg_contents (_, lm) reg = try Some (RM.find reg lm) with Not_found -> None
  let fold f (vm, _) zero      = RM.fold (fun t ls z -> f t (pair_to_list ls) z) vm zero
  let fold_range f map zero    =
    fold (fun t ls z -> List.fold_right (f t) ls z) map zero
@
Printing is easy.
<<varmap module>>=
  let print msg map =
    let string_of_loc = function | Reg r -> printReg r | Mem _ -> "mem_loc" in
    ( Printf.eprintf "%s\nOneLocVarMap:\n" msg
    ; fold_range (fun t l () -> Printf.eprintf "%s -> %s\n"
                                               (printReg t) (string_of_loc l))
           map ()
    ; flush stderr
    )
@
If the outmap spills a temp that is assigned to a register in the inmap,
then the spill must happen in the inmap.
Note: We fold over the outmap, with the inmap as the accumulating parameter.
<<varmap module>>=
  let sync_maps inmap (om_vm,_ as outmap) =
    (RM.fold (fun temp loc_pair (im_vm',_ as inmap') ->
                match loc_pair.mem with
                | Some m ->
                  if Aux.Option.is_none (pair_map_find temp im_vm').mem then
                    add temp (Mem m) inmap'
                  else
                    inmap'
                | None   -> inmap')
             om_vm inmap, outmap)
@
The [[reg_classes]] are represented as a record of lists.
<<varmap module>>=
  type reg_classes = { regs_unused        : reg list
                     ; regs_unused_not_lo : reg list
                     ; regs_cheap         : reg list
                     ; regs_hicost        : reg list
                     ; regs_unavail       : reg list
                     ; regs_unavail_if_lo : reg list
                     }
@
Printers are our debugging friends.
<<varmap module>>=
let print_reg_classes msg classes =
    ( Printf.eprintf "%s\nReg Classes:\n" msg
    ; printTempSet "regs_unused:\n"        (setFromList classes.regs_unused)
    ; printTempSet "regs_cheap:\n"         (setFromList classes.regs_cheap)
    ; printTempSet "regs_hicost:\n"        (setFromList classes.regs_hicost)
    ; printTempSet "regs_unavail_if_lo:\n" (setFromList classes.regs_unavail_if_lo)
    ; flush stderr
    )
@
Any registers explicitly allocated to hardware registers are unavailable.
Otherwise, the availability of registers depends on whether they have been assigned to
temps (as shown by the variable map).
<<varmap module>>=
  let classify_inregs tgt allregs (vm, lm as map) node =
    let hw_defs       = get_hw_regs tgt (defs node)                                in
    let hw_live_in    = get_hw_regs tgt (get_live_in  node)                        in
    let hw_live_out   = get_hw_regs tgt (get_live_out node)                        in
    let hw_all_regs   = hw_defs ++ hw_live_in ++ hw_live_out                       in

    let free_regs = diff allregs hw_all_regs in
    let (hicost, unused) = part (fun r -> RM.mem r lm) free_regs in

    { regs_unused        = unused
    ; regs_unused_not_lo =
        inter allregs (((hw_live_out ++ hw_defs) -- hw_live_in) -- (setFromList hicost))
    ; regs_cheap         = []
    ; regs_hicost        = hicost
    ; regs_unavail       = inter allregs hw_live_in
    ; regs_unavail_if_lo = inter allregs hw_all_regs
    }
@
DOCO PAUSE HERE
<<varmap module>>=
  let classify_outregs tgt allregs (vm, _) node =
    let defs          = defs node                                in
    let uses          = uses node                                in
    let live_in       = get_live_in  node                        in
    let live_out      = get_live_out node                        in

    let used_hw_regs    = get_hw_regs tgt (defs ++ live_out)     in
    let regs       = diff allregs used_hw_regs                   in
    let used_regs  =
      RM.fold (fun t l rst -> match l with | {reg = Some r} -> RS.add r rst
                                           | _              -> rst) vm RS.empty in
    let live_out_uses = RS.inter uses (RS.diff live_out defs) in
    let regs_for_live_out_uses =
      RS.fold (fun t set -> match RM.find t vm with
                            | {reg = Some r} -> RS.add r set
                            | _              -> set)
              (rem_regs tgt live_out_uses) RS.empty in
    let cant_alloc = used_hw_regs ++ regs_for_live_out_uses in
    let unavail = inter allregs used_hw_regs in
    { regs_unused        = diff regs used_regs
    ; regs_unused_not_lo = []
    ; regs_cheap         = []
    ; regs_hicost        = inter regs (RS.diff used_regs cant_alloc)
    ; regs_unavail       = unavail
    ; regs_unavail_if_lo = unavail
    }
@
The observers for register classes.
<<varmap module>>=
  let unused                 rclasses = rclasses.regs_unused
  let unused_not_lo          rclasses = rclasses.regs_unused_not_lo
  let used_free_evict        rclasses = rclasses.regs_cheap
  let used_can_spill         rclasses = rclasses.regs_hicost
  let unavailable            rclasses = rclasses.regs_unavail
  let unavailable_if_liveout rclasses = rclasses.regs_unavail_if_lo
end
@

%-------------------------------------------------------------------
\subsection{Preferences}
%-------------------------------------------------------------------

A [[varMap]] maps a temp (temporary register) to a hardware register.
It is a dynamic invariant that the domain of this function contains only
temps and the range includes hardware registers and memory locations.
<<type declarations>>=
type preferences = { varMap : VM.t
                   ; regs   : (reg list) SM.t
                   }
@
Printers are our debugging friends.
<<define [[print_prefs]] to print preferences>>=
let print_prefs msg prefs =
  Printf.eprintf "%s\nPreferences VarMap:\n" msg;
  VM.print "" prefs.varMap;
  Printf.eprintf "Preferences RegQueue:\n";
  SM.iter (fun (s,_,_) regs ->
             Printf.eprintf "Space %c: " s;
             List.iter (fun r -> Printf.eprintf "%s " (printReg r)) regs)
    prefs.regs;
  Printf.eprintf "\n" in
@
The preferences come in two forms: the register order and the variable map.
The register order indicates the order in which we assign registers.
The variable map suggests where a variable should be placed (if there is a choice).
We expect that the [[alloced_preds]] argument to [[update_pref_varmap]] holds all the
predecessors of the current node that have already been handled by the register
allocator (and therefore have useful outmaps).
Currently, the choice of predecessor is arbitrary.
<<updating preferences>>=
let update_pref_varmap state prefs alloced_preds =
  match alloced_preds with
  | []   -> prefs
  | p::_ -> { prefs with varMap = IM.find (G.num p) state.varOutMaps } in

<<define [[avoid]] and [[aim_for]] to decrease or increase the likelihood of choosing a register>>
let update_prefs_at_node prefs node =
  let temp_defs,hw_defs = partition_regs tgt (defs node)                        in
  let get_regs = get_regs prefs.varMap                                          in
  let to_avoid = RS.fold (fun t rst -> List.fold_right RS.add (get_regs t) rst)
                         temp_defs (RS.inter hw_defs alloc_regset)              in
  let vm = match get_copy_regs node with
           | Some (d, s) when is_tmp tgt s ->
               if is_tmp tgt d then 
                  try VM.add s (Reg (choose_reg prefs.varMap d)) prefs.varMap
                  with Not_found  -> prefs.varMap
               else VM.add s (Reg d) prefs.varMap
           | _ -> prefs.varMap in
  { regs   = avoid prefs.regs to_avoid
  ; varMap = vm
  } in
@
After a node has been allocated, we need to update the register queue in the prefs
record.
When a temp expires, we send its register to the front of the queue.
When we allocate a temp to a register, we send that register to the end of the
queue.
Note that this function is called after the node has been rewritten to replace all
temps with hardware registers.
<<updating preferences>>=
let post_update_prefs node prefs outmap =
(*
  print_prefs (Printf.sprintf "Prefs before node %d" (G.num node)) prefs;
  *)
  let live_in  = regs_in_vm tgt outmap (get_live_in  node) in
  let live_out = regs_in_vm tgt outmap (get_live_out node) in
  let defs     = regs_in_vm tgt outmap (defs node) in
  let expired  = (defs ++ live_in) -- live_out in
  let live_out_defs = RS.inter alloc_regset (RS.inter defs live_out) in
  let expired_regs  = RS.inter alloc_regset (expired -- live_out_defs) in
  (*printTempSet "expired_regs"  expired_regs;
  Printf.eprintf "\n";
  printTempSet "live_out_def_regs" live_out_defs;
  Printf.eprintf "\n";
  *)
  let prefs = {prefs with regs = avoid (aim_for prefs.regs expired_regs) live_out_defs} in
  (*
  print_prefs (Printf.sprintf "Prefs after node %d" (G.num node)) prefs;
  *)
  prefs in
@
We decrease the likelihood that a set of registers are selected by moving them to the
end of the queue of registers.
<<define [[avoid]] and [[aim_for]] to decrease or increase the likelihood of choosing a register>>=
let move_regs move reg_map move_map =
  let move_map = separate_set move_map in
  let move_space s regs =
      try let to_move = SM.find s move_map in
          move (diff regs to_move) (RS.elements to_move)
      with Not_found -> regs in
  SM.mapi move_space reg_map in
let avoid   = move_regs (@) in
let aim_for = move_regs (fun a b -> b @ a) in
@

%-------------------------------------------------------------------
\subsection{The Basic Algorithm}
%-------------------------------------------------------------------
The [[state]] is used to pass information as we traverse the flow graph:
\begin{itemize}
\item allocated:  the set of nodes that have been allocated (by node number)
\item spillMap:   a map from a temp to its spill location
\item varInMaps:  a map from a node (by node number) to the varMap representing
                  the location of each temp live\_in to the node
\item varOutMaps: a map from a node (by node number) to the varMap representing
                  the location of each temp live\_out from the node
\end{itemize}
<<type declarations>>=
type state = { allocated  : IS.t
             ; visited    : IS.t
             ; spillMap   : Automaton.loc RM.t
             ; varInMaps  : VM.t IM.t
             ; varOutMaps : VM.t IM.t
             }

let separate temps =
  List.fold_left (fun map (s,_,_ as t) ->
                    let tlst = try SM.find s map with Not_found -> [] in
                    SM.add s (t::tlst) map)
                 SM.empty temps
let separate_set tempset =
  RS.fold (fun (s,_,_ as t) map ->
             let tset = try SM.find s map with Not_found -> RS.empty in
             SM.add s (RS.add t tset) map)
          tempset SM.empty
@
Find the registers that hold temps from the temporary space [[s]].
<<type declarations>>=
let get_regs_for_space tgt regmap s =
  let fits = Target.fits in
  List.concat (SM.fold (fun _ regs rst ->
                          match regs with
                          | r::_ -> if fits tgt s r then regs :: rst else rst
                          | _    -> rst)
                       regmap [])
let flatten_regmap regmap =
  List.concat (SM.fold (fun _ regs rst -> regs::rst) regmap [])

let empty_state regs =
  ( { allocated  = IS.empty
    ; visited    = IS.empty
    ; spillMap   = RM.empty
    ; varInMaps  = IM.empty
    ; varOutMaps = IM.empty
    }
  , { varMap = VM.empty; regs = separate regs }
  )
@
[[rpo_dfs]] traverses the cfg by a DFS, calling [[alloc_node]] in a reverse post-order.
This order ensures that [[alloc_node]] is called on each predecessor of a node $n$
before [[alloc_node]] is applied to $n$.

[[dls]] puts the allocator together: [[rpo_dfs]] is called with [[alloc_node]] to
place each temp at a node.
[[alloc_node]] calls [[choose_varMaps]] to decide where each temp belongs.

Note the aggressive use of continuations [[k]] to maintain tail recursion; tread
lightly.
<<rpo\_dfs determines the order for visiting nodes>>=
<<define [[print_prefs]] to print preferences>>
<<updating preferences>>
let rpo_dfs (state, prefs) =
  let (_, postorder) = G.postorder_dfs (fun n (i, map) -> (i+1, NM.add n i map))
                                       (0, NM.empty) cfg                              in
  let rec visit (state, prefs) node prev_delays k =
    if is_visited state node then
      k (state, prefs, prev_delays)
    else
      let state = mark_visited state node                                             in
      let prefs = update_prefs_at_node prefs node                                     in
      let preds = G.preds node                                                        in
      let unvis_preds = List.filter (fun p -> not (is_visited state p)) preds         in
      (* Not_found case only for nodes unreachable from entry node... *)
      let node_num = try NM.find node postorder with Not_found -> 0                   in
      let (to_vis, to_delay) =
        (* Not_found case only for nodes unreachable from entry node... *)
        let comparep p = try NM.find p postorder > node_num with Not_found -> false   in
        List.partition comparep unvis_preds                                           in

      let visit_pred node (state, prefs, delays) k =
        let prefs = update_pref_varmap state prefs
                                       (List.filter (is_allocated state) preds)       in
        visit (state, prefs) node delays k                                            in
      let alloc_curr_node (state, prefs, delays) =
        let state, prefs =
          if G.kind node =*= G.Illegal then state, prefs
          else
            let state = alloc_node state prefs node in
            let prefs =
              post_update_prefs node prefs (IM.find (G.num node) state.varOutMaps) in
            state, prefs in
        k ( state
          , prefs
          , (List.map (fun d -> (prefs,d)) to_delay) :: delays
          ) in
      let rec iter_preds preds spd =
        match preds with
        | []     -> alloc_curr_node spd
        | p::rst -> visit_pred p spd (iter_preds rst) in
      iter_preds to_vis (state, prefs, prev_delays) in
  let id x = x in
  let rec handle_delays (state, _, ds) = match List.concat ds with
    | []  -> state
    | ds  -> List.fold_left (fun s (p, n) -> handle_delays (visit (s, p) n [] id))
                            state ds in
  handle_delays (state, prefs, [[(prefs, G.exit cfg)]]) in
@
<<dls algorithm>>=
let dls () ({Proc.cfg = cfg; Proc.cc = cc; Proc.target = tgt} as proc) =
  ignore (Optimize.trim_unreachable_code () proc);
  if Debug.on "dls" then
    begin
      Cfgutil.print_cfg cfg;
      G.iter_nodes
        (fun n ->
          let set = Register.SetX.to_string in
          Printf.eprintf
            "%4d live_out = { %s }\n" (G.num n) (set (Cfgx.Live.live_out n));
          Printf.eprintf
            "%4d live_in  = { %s }\n" (G.num n) (set (Cfgx.Live.live_in n)))
        cfg
    end;
  let alloc_regset = cc.Call.volregs ++ cc.Call.pre_nvregs      in
  <<define spill functions>>
  <<define [[buffer_if_succ_is_join]] to insert a nop after instr leading to join>>
  <<definition of shuffle>>
  <<choose\_varMaps finds varIn and varOut maps for a node>>
  <<alloc\_node allocates registers at a single node>>
  <<rpo\_dfs determines the order for visiting nodes>>
  let state = rpo_dfs (empty_state (RS.elements alloc_regset)) in
  cleanup   cfg;
  (*Cfgutil.print_cfg cfg;*)
  (*G.iter_nodes (fun n ->
               Printf.eprintf "%s\n" (G.print_node n);
               try VM.print "varIn"  (IM.find (G.num n) state.varInMaps)  with _ -> ();
               try VM.print "varOut" (IM.find (G.num n) state.varOutMaps) with _ -> ())
               cfg;*)
  <<add spans for variable locations>>;
  true
@

To allocate registers at a single node, we follow a simple process:
\begin{enumerate}
\item Find predecessors and successors of [[node]].
\item Choose a varMap for [[node]].
\item Rewrite the instruction to reflect the placement of temps in the varMaps.
\item Insert a shuffle of moves, loads, and stores to settle differences
      between varMaps in adjacent nodes.
\end{enumerate}
<<alloc\_node allocates registers at a single node>>=
let alloc_node state prefs node =
  let state = mark_allocated state node                                          in
  let preds = List.filter (is_allocated state) (G.preds node)                    in
  let succs = List.filter (is_allocated state) (G.succs node)                    in

  (*Printf.eprintf "dls adding varmap for node %d\n" (G.num node);*)
  let state, varIn, defMap, varOut = choose_varMaps state prefs node preds succs in
  let state = set_varIn  state node varIn                                        in
  let state = set_varOut state node varOut                                       in

  let () = rewrite_uses tgt node varIn                                           in
  let () = rewrite_defs tgt node defMap                                          in
  let state = List.fold_left (fun state p -> shuffle state p node) state preds   in
  let (state, node) = buffer_if_succ_is_join state node in
  let state = List.fold_left (fun state s -> shuffle state node s) state succs   in
  let state = {state with allocated = IS.add (G.num node) state.allocated}       in

  (* Not sufficient; doesn't save any time *)
  let free_unused_maps state n =
    let not_all_allocated lst = List.exists (fun p -> not (is_allocated state p)) lst in
    let k = G.kind n in
    if G.is_call n || G.is_join n || G.is_fork n || k =*= G.Assertion ||
       k =*= G.Branch || not_all_allocated  (G.preds n) ||
       not_all_allocated  (G.succs n)
    then
       state
    else
      ((*Printf.eprintf "dls removing varmap for node %d\n" (G.num n);*)
       {state with varInMaps  = IM.remove (G.num n) state.varInMaps;
                   varOutMaps = IM.remove (G.num n) state.varOutMaps}) in
  let state = List.fold_left free_unused_maps state preds              in
  let state = List.fold_left free_unused_maps state (node::succs)      in
  state in
@
Before shuffling with the successors, we have to make sure that if the node is not a
control instruction, its immediate successor is not a join point.
If the successor is a join point, we insert a nop node after the current
node, and we shuffle between the nop and its successors.
That way, we can insert before the nop with impunity, which we could not do with the
original node.
<<define [[buffer_if_succ_is_join]] to insert a nop after instr leading to join>>=
let buffer_if_succ_is_join state node =
  match G.succs node with
  | [succ] when G.is_join succ && not (G.is_cti node) ->
    let varOut = IM.find (G.num node) state.varOutMaps in
    G.set_succ node (G.illegal cfg);
    let n' = G.assertion cfg (Rtl.par []) ~succ in
    G.set_succ node n';
    (set_varOut (set_varIn (mark_allocated state n') n' varOut) n' varOut, n')
  | _ -> (state, node) in
@
We clean up any move instruction where the source register is the same as the
destination register.
We accumulate the list of nodes we intend to delete before deleting them
because we do not want to modify the cfg while traversing it.
<<alloc\_node allocates registers at a single node>>=
let cleanup cfg =
  let visit_node node rst =
    match get_copy_regs node with
    | Some (r1,r2) when Register.eq r1 r2 -> node::rst
    | _                                   -> rst in
  List.iter (Cfgutil.delete cfg) (G.fold_nodes visit_node [] cfg) in
@

[[choose_varMaps]] is responsible for choosing the varMaps in and
out of each node.
This particular version does not do any preferencing.
We begin by gathering some useful information about registers
at the node.
<<choose\_varMaps finds varIn and varOut maps for a node>>=
let choose_varMaps state prefs node preds succs =
  let defs              = defs node                         in
  let uses              = uses node                         in
  let live_in           = get_live_in  node                 in
  let live_out          = get_live_out node                 in
  let temp_uses,hw_uses = partition_regs tgt uses           in
  let temp_defs,hw_defs = partition_regs tgt defs           in

  <<define remove\_last\_uses, alloc, initial\_inmap, and alloc\_hw\_regs>>
  let state, inmap = initial_inmap state preds succs in
  (*Printf.eprintf "choose_varMaps called on %s\n" (G.print_node node);
  VM.print "prefs" prefs.varMap;
  VM.print "initial inmap" inmap;
  *)
  <<check pred map invariant>>
@
If any temps are in an unavailable register, then we need to spill the temp from that
register.
There is an opportunity for optimization here: even if the temp is not used in this
instruction, we could try to allocate it to a register if there are any free registers.
This optimization would insert a move instruction instead of a store.

Check each of the temps that remain to be allocated.
If a temp is already in a register, then we remove that register from the [[hicost]]
and [[cheap]] sets (alternatively, we could check whether the var is also in memory to
figure out which set to remove from).
After this part, this inmap is done.
<<choose\_varMaps finds varIn and varOut maps for a node>>=
  <<choose\_register>>
  let (state,inmap) =
    alloc_temps alloc_uses state VM.classify_inregs prefs.regs temp_uses inmap in
@
Now, we expire any temps that die at this node and move on to the defs at the node.
<<choose\_varMaps finds varIn and varOut maps for a node>>=
  let midmap = expire_last_uses inmap in
  let (state,outmap) =
    alloc_temps (alloc_defs inmap) state VM.classify_outregs prefs.regs temp_defs
                midmap in
@
Here's an interesting case. If we have a def that is never used again, then we must
assign it a register, but we don't want it in the outmap.
So, we have a separate defmap and outmap, where the defmap keeps any dead definitions.
<<choose\_varMaps finds varIn and varOut maps for a node>>=
  let inmap,outmap = VM.sync_maps inmap outmap in
  let defmap = outmap in
  let outmap = expire_dead_defs outmap in
  (*
  VM.print "final  inmap" inmap;
  VM.print "final outmap" outmap;
  Printf.eprintf "final choose_varMaps called on %s\n" (G.print_node node);
  *)
  state,inmap,defmap,outmap in
@
In [[expire_last_uses]], the guard supports instructions such as $x := x + y$; where
both x's must be placed in the same register.
It is the expander's responsibility to place the x's in different temps if more
flexibility is desired.
In any case, we still have to remove obsolete memory references from the variable map.
<<define remove\_last\_uses, alloc, initial\_inmap, and alloc\_hw\_regs>>=
let expire regset guard map =
  RS.fold (fun t m ->
             let regs, mems = part_locs (VM.var_locs m t)          in
             let m          = List.fold_right (VM.remove t) mems m in
             if guard t m then
               m
             else
               List.fold_right (VM.remove t) regs m)
          (rem_regs tgt regset) map in
let expire_last_uses =
  expire uses (fun t m -> RS.mem t live_out || RS.mem t defs) in
let expire_dead_defs = expire defs (fun t m -> RS.mem t live_out) in
@
In [[initial_inmap]], we need to find an inmap that will have each live-in variable in
some location.
In an attempt to be fast, we will only take the first predecessor's variable map.
It may be a better idea to combine the maps of each of the predecessors.
If none of the predecessors have allocated a temp, we choose a new location for the
temp, preferring registers, if available.
<<define remove\_last\_uses, alloc, initial\_inmap, and alloc\_hw\_regs>>=
let initial_inmap state preds succs =
  let alloc_remaining (s,_,_ as t) (state, map, used) =
    match diff (get_regs_for_space tgt prefs.regs s) used with
    | r::rst -> (state, VM.add t (Reg r) map, RS.add r used)
    | []     -> let state, l = get_spill_loc state t in
                (state, VM.add t (Mem l) map, used) in
  match preds with
  | p::rst ->
    let predmap = try IM.find (G.num p) state.varOutMaps with Not_found -> VM.empty in
    let choose_loc t (map, used, rem) =
      if is_tmp tgt t then
        let locs    = VM.var_locs predmap t in
        let regs    =
        List.fold_left (fun rst t -> match t with | Reg r -> r::rst | _ -> rst)
                         [] locs in
        ( List.fold_left (fun m l -> VM.add t l m) map  locs
        , List.fold_left (fun s r -> RS.add r s)   used regs
        , rem
        )
      else (map, RS.add t used, rem) in
    let (inmap, used_regs, remaining) =
      RS.fold choose_loc live_in (VM.empty, RS.empty, RS.empty) in
    let (state', inmap, _) =
      RS.fold alloc_remaining remaining (state, inmap, used_regs) in
    state', inmap
  | []   ->
    (*Printf.eprintf "bad case...\n";
    printTempSet "live_in" live_in;
    printTempSet "live_out" live_out;
    *)
    let (temps, used)      = partition_regs tgt live_in in
    let (state', inmap, _) = RS.fold alloc_remaining temps (state, VM.empty, used) in
    state', inmap in
@
The predecessor's outmap must map each live\_in temp to some location.
<<check pred map invariant>>=
  let () = let temp_live_in,_ = partition_regs tgt live_in in
           assert (RS.fold (fun t b -> b && not (null (VM.var_locs inmap t)))
                           temp_live_in true) in
@
Any allocation of registers must meet the requirement that a node's inmap must be a
subset of the outmap of each predecessor.
I don't currently check this invariant because it only needs to be true after any
shuffling has occurred.
Since I'm not calculating the outmap on shuffled node, this check is useless.
<<check inmap invariant>>=
let pred_maps =
  List.fold_left (fun rst p -> try  (G.num p, IM.find (G.num p) state.varOutMaps) :: rst
                               with Not_found -> rst) [] preds in
let check_map (pnum,pmap) =
  VM.fold_range (fun t l () ->
                   let plocs = try VM.var_locs pmap t with Not_found -> [] in
                   match l with
                   | Reg r when List.mem l plocs -> ()
                   | Mem _ when List.exists (function | Mem _ -> true | _ -> false)
                                            plocs -> ()
                   | _ -> VM.print (Printf.sprintf "outmap for node %d" pnum) pmap;
                          VM.print (Printf.sprintf "inmap for node %d" (G.num node))
                                   inmap;
                          impossf "inmap invariant failed\n") inmap () in
let () = List.iter check_map pred_maps in
@
%-------------------------------------------------------------------
\subsection{Spilling}
%-------------------------------------------------------------------
Spilling a temp from a register requires that we modify the state in addition to the
varmaps because we may have to set a spill location for the temp.
<<define spill functions>>=
  let get_spill_loc state ((_, _, ms),_,c as temp) =
    try state,RM.find temp state.spillMap
    with Not_found ->
      let l = Automaton.allocate proc.Proc.priv (Cell.to_width ms c) "" in
      ({state with spillMap = RM.add temp l state.spillMap},l) in
  let spill state temp reg map =
    let (state,spill_loc) = get_spill_loc state temp in
    (state,VM.add temp (Mem spill_loc) (VM.remove temp (Reg reg) map)) in
  let spill_reg guard (state, map) reg =
    match VM.reg_contents map reg with
    | Some t when guard t -> spill state t reg map
    | _                   -> (state,map) in
@
%-------------------------------------------------------------------
\subsection{Choosing a Register for a Single Temp}
%-------------------------------------------------------------------
<<choose\_register>>=
  let default_alloc (state, map, a, c, h, not_lo) t =
    match (a, c, h, not_lo) with
    | (r::rst, _,      _,      _)                                   ->
      (state, VM.add t (Reg r) map, rst, c, h, not_lo)
    | ([],     _,      _,      r::rst) when not (RS.mem t live_out) ->
      (state, VM.add t (Reg r) map, a, c, h, rst)
    | ([],     _,      _,      r::rst) ->
      let (state,spill_loc) = get_spill_loc state t in
      (state, VM.add t (Reg r) (VM.add t (Mem spill_loc) map), a, c, h, rst)
    | ([],     r::rst, _,      [])                                  ->
      let (state,map) = spill_reg true_fun (state, map) r in
      (state, VM.add t (Reg r) map, a, rst, h, not_lo)
    | ([],     [],     r::rst, [])                                  ->
      let (state,map) = spill_reg true_fun (state, map) r in
      (state, VM.add t (Reg r) map, a, c, rst, not_lo)
    | ([],     _,      _,     _)                                    ->
        impossf "No register available for temp %s" (printReg t) in
@
Note that by calling [[get_avail_reg]], I am disallowing copies in which the used
temp lives past this node.
Is there a good reason to do this?
I could allocate them to the same register, and as long as I: 1.) have the variable map
remember that multiple temps are in the same register and 2.) when spilling, spill all
temps in the register to separate spill slots (b/c spill slots are allocated by temp
name, not value, and one of the temps may be redefined and spilled, overwriting the
other).
<<choose\_register>>=
  let get_avail_reg ((state, map, a, c, h, av_not_lo) as s) t reg fail =
    let split = List.partition (Register.eq reg) in
    match split a with
    | [r], rst -> (state, VM.add t (Reg r) map, rst, c, h, av_not_lo)
    | _   ->
      (match split av_not_lo with
       | [r], rst -> (state, VM.add t (Reg r) map, a, c, h, rst)
       | _        -> fail s t) in
  (* include preferences *)
  let alloc_prefs s t =
    try get_avail_reg s t (choose_reg prefs.varMap t) default_alloc
    with Not_found -> default_alloc s t in
  (* include copy propagation *)
  let alloc_copy order map s t =
    match get_copy_regs node with
    | Some regs ->
      let (to_alloc, other) = order regs in
      if Register.eq to_alloc t then
         ((*Printf.eprintf "allocating copy temp %s from %s\n" (printReg t) (printReg
                                                                           other);*)
          try let r = if is_tmp tgt other then choose_reg map other else other in
              get_avail_reg s t r alloc_prefs
          with Not_found -> ((*Printf.eprintf "failed to find\n";*)alloc_prefs s t))
      else alloc_prefs s t
    | None  -> alloc_prefs s t in
  let allocate f s to_alloc = List.fold_left f s to_alloc   in
  let alloc_uses            = allocate (alloc_copy (fun (d,s) -> (s,d)) prefs.varMap) in
  let alloc_defs uses_map   = allocate (alloc_copy (fun (d,s) -> (d,s)) uses_map)     in
@
<<choose\_register>>=
  let remove_preallocs map to_alloc cheap hicost =
    let to_alloc', regs_used =
      List.fold_left (fun (rst, r_used) t -> try let r = choose_reg map t in
                                                 (rst, RS.add r r_used)
                                             with Not_found -> (t::rst,r_used))
                     ([],RS.empty) to_alloc in
    (to_alloc', diff cheap regs_used, diff hicost regs_used) in
@
If any temps are in an unavailable register, then we need to spill the temp from that
register.
There is an opportunity for optimization here: even if the temp is not used in this
instruction, we could try to allocate it to a register if there are any free registers.
This optimization would insert a move instruction instead of a store.
<<choose\_register>>=
  let alloc_temps alloc state classify regs temps map =
    <<spill used registers>>
    let temp_map = separate (RS.elements temps) in
    let alloc_for_space regs temps (state, map) =
      let reg_classes = classify tgt regs map node in
      let avail, cheap, hicost, av_not_lo =
        VM.unused reg_classes,         VM.used_free_evict reg_classes,
        VM.used_can_spill reg_classes, VM.unused_not_lo reg_classes in
      let (to_alloc, cheap, hicost) = remove_preallocs map temps cheap hicost in
      let (state, map, _, _, _, _)  =
        alloc (state, map, avail, cheap, hicost, av_not_lo) to_alloc in
      (state, map) in
    SM.fold (fun s temps rst ->
               alloc_for_space (get_regs_for_space tgt regs s) temps rst)
            temp_map (state,map) in
@
Some registers may be defined, used, or killed by the node.
The contents of these registers must be spilled to memory.
<<spill used registers>>=
let rclasses = classify tgt (flatten_regmap regs) map node in
let state,map =
   List.fold_left (spill_reg true_fun) (state, map) (VM.unavailable rclasses) in
let state,map =
   List.fold_left (spill_reg (fun t -> RS.mem t live_out)) (state, map)
                  (VM.unavailable_if_liveout rclasses) in
@
%-------------------------------------------------------------------
\subsection{Shuffling Establishes Consistency}
%-------------------------------------------------------------------
\begin{alltt}
  loads = in succ\_vm, but not in pred\_vm

  moves = in both, but not in same place

  stores = in pred\_vm, but not in succ\_vm; live into succ
\end{alltt}

<<definition of shuffle>>=
<<define [[assign]], [[move]], [[store]], and [[load]]>>
let do_shuffle state moves =
  let rec shuffle state = function
    | []          -> state, []
    | ((t, dst, src) :: rest) as effs ->
        <<definition of [[try_first_effect]]>>
        try_first_effect effs
          (fun (t, dst, src) rest ->
             let mv            = move t dst src in
             let state, shuffs = shuffle state rest in
             state, mv :: shuffs)
          (fun () ->
            (* NOT IDEAL -- SHOULD TRY TO MOVE THROUGH A REG FIRST.... *)
            let state, spill  = store   state t src in
            let state, shuffs = shuffle state rest  in
            let state, reload = load    state t dst in
            state, spill :: shuffs @ [reload]) in
  shuffle state moves in
<<definition of [[try_first_effect]]>>=
let try_first_effect effects succ fail =
  let rec maybe bad = function
    | [] -> fail () (* Circular register moves *)
    | (t, dst, src) :: rest ->
        let alias (_, _, r) = RU.MayAlias.regs dst r in
        if not (List.exists alias bad || List.exists alias rest) then
          succ (t, dst, src) (List.rev_append bad rest)
        else
          maybe ((t, dst, src) :: bad) rest in
  maybe [] effects in
@ 
When we want to insert a shuffle between two nodes, we first have to check whether
we can insert between the nodes.
If not (as in multiway-branch, call, and cut-to instructions), we need to insert loads
and stores before and after the nodes.
<<definition of shuffle>>=
let shuffle state pred succ =
  (*Printf.eprintf "Shuffling pred %d and succ %d\n" (G.num pred) (G.num succ);*)
  let pred_vm   = IM.find (G.num pred) state.varOutMaps in
  let succ_vm   = IM.find (G.num succ) state.varInMaps  in
	(*
  VM.print "pred:" pred_vm;
  VM.print "succ:" succ_vm;
	*)
  <<define [[shuffle_around]] and [[shuffle_between]]>>
  match G.kind pred with
  | G.Mbranch | G.Call | G.CutTo -> shuffle_around state pred succ
  | _                            -> shuffle_between state pred succ in
@
First, we find the temps that are placed inconsistently between the nodes.
We insert the necessary load instructions after the succesor, and
we insert the necessary store instructions before the successor's predecessors,
We also update each variable map that is changed.
<<define [[shuffle_around]] and [[shuffle_between]]>>=
let shuffle_around state pred succ =
  assert (G.is_join succ);
  (*
	 VM.print (Printf.sprintf "\npred %d:" (G.num pred)) pred_vm;
   VM.print (Printf.sprintf "\nsucc %d:" (G.num succ)) succ_vm;
  *)

  let find_inconsistents temp succ_locs rst =
    let pred_regs, pred_mems = part_locs (VM.var_locs pred_vm temp) in
    let mems = not (null pred_mems) in
    List.fold_left
      (fun (state, ts, loads as rst) l -> match l with
         | Mem _ when mems                 -> rst
         | Reg _ when List.mem l pred_regs -> rst
         | Mem _                           -> (state, RS.add temp ts, loads)
         | Reg r                           ->
           let state', l = load state temp r in (state', RS.add temp ts, l::loads))
      rst succ_locs in
  let (state,temps,loads) = VM.fold find_inconsistents succ_vm (state,RS.empty,[]) in
@
We update the successor's variable map to have each inconsistent temp in memory.
<<define [[shuffle_around]] and [[shuffle_between]]>>=
  let succ_vm =
    RS.fold (fun t vm ->
               let vm' = List.fold_left (fun vm l -> VM.remove t l vm)
                                        vm (get_locs vm t) in
               VM.add t (Mem (RM.find t state.spillMap)) vm')
            temps succ_vm in
  let state = set_varIn  state succ succ_vm in
  let state = set_varOut state succ succ_vm in
@
<<define [[shuffle_around]] and [[shuffle_between]]>>=
  (* make the successor consistent *)
  let state, vm_out, nodes' = make_nodes' state succ_vm loads in
  let _ = List.fold_right
            (fun node succ -> (G.splice_after ~entry:node ~exit:node succ ; node))
            nodes' succ in

  (* make the predecessors consistent *)
  (*
  Cfgutil.print_cfg cfg;
  Printf.eprintf "#preds\n";
  List.iter (fun n -> Printf.eprintf "%d " (G.num n)) (G.preds succ);
  Printf.eprintf "\n#allocated preds\n";
  List.iter (fun n -> Printf.eprintf "%d " (G.num n))
            (List.filter (is_allocated state) (G.preds succ));
  Printf.eprintf "\n";
	*)

  let handle_pred state pred =
    let pred_vm = try IM.find (G.num pred) state.varOutMaps
                  with Not_found ->
                    (Cfgutil.print_cfg cfg;
                     Printf.eprintf "node %d; pred %d\n" (G.num succ) (G.num pred);
                     impossf "shuffling: pred node with no outmap") in
		(*
    VM.print (Printf.sprintf "\npred_vm %d:" (G.num pred)) pred_vm;
    VM.print (Printf.sprintf "\nsucc_vm %d:" (G.num succ)) succ_vm;
    printTempSet "pred_live_out\n" (get_live_out pred);
    printTempSet "succ_live_in\n"  (get_live_in  succ);
		*)
    let (state, stores) =
      RS.fold (fun t (state, stores) ->
                 match part_locs (VM.var_locs pred_vm t) with
                 | (_, _::_)      -> (state, stores)
                 | (Reg r::_, []) ->
                   let (state', s) = store state t r in
                   (state', s::stores)
                 | (_, _)         ->
                   impossf "Unallocated temp in pred's outmap")
              temps (state, []) in
    let state, pred_vm, nodes' = make_nodes' state pred_vm stores in

    let _ = List.fold_right
              (fun node pred -> (G.splice_before ~entry:node ~exit:node pred ; pred))
              nodes' pred in
    (*VM.print "new maps" pred_vm;*)
    set_varIn (set_varOut state pred pred_vm) pred pred_vm in
  List.fold_left handle_pred state (List.filter (is_allocated state) (G.preds succ)) in
@
<<define [[shuffle_around]] and [[shuffle_between]]>>=
let shuffle_between state pred succ =
  let find_shuffles temp succ_locs state_lists =
    let pred_regs, pred_mems = part_locs (get_locs pred_vm temp) in
    let one_loc (state, ms, ls, ss as state_lists) l =
      match (l, pred_regs, pred_mems) with
      | (Reg _, _       , _) when List.mem l pred_regs -> state_lists
      | (Reg d, Reg s::_, _)                           ->
        (state, (temp, d, s)::ms, ls, ss)
      | (Reg r, []      , _::_)                        ->
        let state', l = load  state temp r in (state', ms, l::ls, ss)
      | (Mem _, _       , _::_)                        -> state_lists
      | (Mem _, Reg r::_, [])                          ->
        let state', s = store state temp r in (state', ms, ls, s::ss)
      | (_    , []      , [] )                         ->
        impossf "%s %s %s %d %s %d %s %s"
             "DLS register allocator error in shuffle(): Temp" (printReg temp)
             "allocated in succ" (G.num succ) "but not pred" (G.num pred)
             "map in function" (proc.Proc.symbol#original_text)
      | (_    , _       , _  )                         ->
        VM.print "Pred VM:" pred_vm;
        VM.print "Succ VM:" succ_vm;
        impossf "Varmap has temp in unexpected locations" in
    List.fold_left one_loc state_lists succ_locs in

  let state, moves, loads, stores = VM.fold find_shuffles succ_vm (state, [],[],[]) in
  if null loads && null moves && null stores
  then state
  else
    let state, moves     = do_shuffle state moves                in
    let shuffles         = List.concat [ stores ; moves ; loads] in
    let state, _, nodes' = make_nodes' state pred_vm shuffles    in
    let last =
      List.fold_right
            (fun node pred -> (G.splice_on_every_edge_between ~entry:node ~exit:node
                                                              ~pred ~succ
                              ; node))
            nodes' pred in
    let state, _ = buffer_if_succ_is_join state last in
    state in
@
To reconcile variable maps, we need to create move, store, and load rtl's.
<<define [[assign]], [[move]], [[store]], and [[load]]>>=
let make_loc_empty loc vm =
  match loc with
  | Mem _ -> impossf "DLS: make_loc_empty called on memory location"
  | Reg r -> match VM.reg_contents vm r with
             | Some t -> VM.remove t loc vm
             | None   -> vm                 in
let space = Target.space tgt in
let move temp ((_,_,ms),_,c as dst) src =
  let w = Cell.to_width ms c in
  ((fun vm -> VM.add temp (Reg dst) (make_loc_empty (Reg dst) vm)),
   [Rtl.store (Rtl.reg dst) (Rtl.fetch (Rtl.reg src) w) w]) in
let store state temp src =
  let state', loc = get_spill_loc state temp in
  (state', ((fun vm -> VM.add temp (Mem loc) vm),
            tgt.Target.spill  space src loc)) in
let load state temp dst =
  let state', loc = get_spill_loc state temp in
  (state', ((fun vm -> VM.add temp (Reg dst) (make_loc_empty (Reg dst) vm)),
            tgt.Target.reload space dst loc)) in
let make_nodes' state start_vm shuffles =
  let rec make_node_lst (s, vm, rst) (upd_vm, rtls) =
    match rtls with (* note: rtls is a list of parallel assts *)
    | [r]    -> let vm' = upd_vm vm                                              in
                let n   = G.instruction cfg r ~succ:(G.illegal cfg)              in
                let s'  = mark_allocated (set_varOut (set_varIn s n vm) n vm') n in
								(*
                Printf.eprintf "on node %d:\n" (G.num n);
                VM.print "vm" vm;
                VM.print "vm'" vm';
								*)
                (s', vm', n::rst)
    | r::rs  -> let n   = G.instruction cfg r ~succ:(G.illegal cfg)              in
                let s'  = mark_allocated (set_varOut (set_varIn s n vm) n vm)  n in
                make_node_lst (s', vm,  n::rst) (upd_vm, rs)
    | []  -> impossf "empty rtl list for load, move, or store"     in
  List.fold_left make_node_lst (state, start_vm, []) shuffles                    in
@
%-------------------------------------------------------------------
\subsection{Variable Maps for the Runtime System}
%-------------------------------------------------------------------
After we have set all the variable maps, we need to propagate them to
the runtime system.
For each span, we replace temporaries with the registers they have been
assigned to.
<<add spans for variable locations>>=
let rewrite_spans (node, ss as rst) =
  (Debug.eprintf "dls" "adding dls span for node %d\n" (G.num node);
   let vm = try IM.find (G.num node) state.varInMaps
            with Not_found ->
                   impossf "DLS: Cannot modify runtime data for unknown node" in
   let rewrite_span l =
     let guard = function RP.Reg r -> is_tmp tgt r | _ -> false in
     let map l = match l with
       | RP.Reg r ->
           (try match VM.var_locs vm r with
                | Reg r :: _ -> RP.Reg r
                | Mem l :: _ -> Dn.loc (Automatonutil.aloc l (Register.width r))
                | [] -> raise RTD.DeadValue
            with Not_found -> raise RTD.DeadValue)
       | _          -> impossf "DLS reg allocator emitting RT data: guard failed" in
     Rtlutil.Subst.loc_of_loc ~guard ~map l in
   Runtimedata.upd_spans rewrite_span ss) in
List.iter rewrite_spans proc.Proc.spans;
<<dls.ml>>=
let () = Debug.register "dls" "(downstairs) linear-scan register allocator"
@
%-------------------------------------------------------------------
\subsection{Utilities}
%-------------------------------------------------------------------
<<printers>>=
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let indent = "  "
let printTemps iter msg collection =
  Printf.eprintf "%s" msg;
  iter (fun t -> Printf.eprintf "%s%s\n" indent (printReg t)) collection;
  flush stderr
let printTempSet  = printTemps RS.iter
let printTempList = printTemps List.iter
let printTempMap msg map =
  Printf.eprintf "%s" msg;
  RM.iter (fun t r -> Printf.eprintf "%s%s -> %s\n" indent (printReg t)
                                                           (printReg r)) map;
  flush stderr
@

Simple utilities used for register allocation.
Most of the functions are not even specific to this particular algorithm.
<<register utilities>>=
let setFromList l = List.fold_left (fun set r -> RS.add r set) RS.empty l
let part = List.partition
let printReg ((s,_,_), i, w) = Printf.sprintf "%c%d" s i
let true_fun _ = true
let diff  lst set = List.filter (fun r -> not (RS.mem r set)) lst
let inter lst set = List.filter (fun r -> RS.mem r set) lst

exception Evict of Register.t * Register.t
let is_tmp tgt (s,_,_) = Target.is_tmp tgt s
let rem_regs tgt temps = RS.filter (is_tmp tgt) temps
let get_hw_regs tgt temps = RS.filter (fun t -> not (is_tmp tgt t)) temps
let partition_regs tgt temps = RS.partition (is_tmp tgt) temps
let get_copy_regs node =
  match G.to_instr node with
    | Some i ->
      (match Rtlutil.RTLType.singleAssignment i with
       | (Some (r1, r2) as copy) -> copy
       | _                       -> None)
    | None   -> None
let ( ++ ) = RS.union 
let ( -- ) = RS.diff 
let irwk = Rtlutil.ReadWriteKill.sets_promote
let defs node =
  let defs = match G.to_instr node with
  | None   -> RS.empty
  | Some i -> let uses, defs, kills = irwk i in defs ++ kills in
  R.promote_rxset
    (G.union_over_outedges node (fun n -> R.rset_to_rxset defs)
        (fun {G.node = n'; G.defs = d; G.kills = k} ->
           (R.rset_to_rxset (defs ++ d ++ k))))
    
let uses node =
  let uses = match G.to_instr node with
  | None   -> RS.empty
  | Some i -> let uses, defs, kills = irwk i in uses in
  R.promote_rxset (G.add_inedge_uses node (R.rset_to_rxset uses))

let get_live_in  n = R.promote_rxset (Cfgx.Live.live_in  n)
let get_live_out n = R.promote_rxset (Cfgx.Live.live_out n)
@
<<utilities>>=
let null = function [] -> true | _ -> false
let part_locs lst = part (function | Reg _ -> true | Mem _ -> false) lst

let get_locs vm t = try VM.var_locs vm t with Not_found -> []
let get_regs vm t =
  List.fold_left (fun rst l -> match l with Reg r -> r::rst | _ -> rst)
                 [] (get_locs vm t)
let choose_reg vm t =
  match get_regs vm t with
  | r::_ -> r
  | []   -> raise Not_found

let regs_in_vm tgt vm temps =
  RS.fold (fun t set ->
             if is_tmp tgt t then
               List.fold_left (fun set r -> RS.add r set) set (get_regs vm t)
             else RS.add t set)
          temps RS.empty

let is_allocated state node = IS.mem (G.num node) state.allocated
let is_visited   state node = IS.mem (G.num node) state.visited
let mark_allocated state node =
  {state with allocated = IS.add    (G.num node) state.allocated}
let mark_visited state node =
  {state with visited   = IS.add    (G.num node) state.visited}
let unmark_visited state node =
  {state with visited   = IS.remove (G.num node) state.visited}

let set_varIn  state node varIn =
  {state with varInMaps  = IM.add (G.num node) varIn  state.varInMaps}
let set_varOut state node varOut =
  {state with varOutMaps = IM.add (G.num node) varOut state.varOutMaps}

let make_map tgt reg_map reg =
  if is_tmp tgt reg
  then try  choose_reg reg_map reg
       with Not_found ->
         ( VM.print "" reg_map
         ; flush stderr
         ; impossf "DLS: failed to allocate temp %s" (printReg reg)
         )
  else reg

let rewrite_defs tgt node varIn  =
  G.update_instr (Rtlutil.Subst.reg_def ~map:(make_map tgt varIn))  node
let rewrite_uses tgt node varOut =
  G.update_instr (Rtlutil.Subst.reg_use ~map:(make_map tgt varOut)) node

(*(time fn written by John Harrison)*)
let time f x =
  let start_time = Sys.time()  in
  let result = f x             in
  let finish_time = Sys.time() in
  print_string
    ("CPU time (user) used by dls():"^(string_of_float(finish_time -. start_time)));
  print_newline();
  result
@

%-------------------------------------------------------------------
\subsection{Exporting to Lua}
%-------------------------------------------------------------------
Boilerplate for exposing this register allocator to Lua.
<<dls.mli>>=
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.M.action)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Ast2ir.proc
                                  and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.USERCODE with type 'a userdata' = 'a BackplaneT.combined
@
More code for exposing the register allocator to Lua.
<<dls.ml>>=
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.M.action)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Ast2ir.proc
                                  and type 'a combined = 'a BackplaneT.combined)
       : Lua.Lib.USERCODE with type 'a userdata' = 'a BackplaneT.combined = struct
  type 'a userdata' = 'a BackplaneT.combined
  module M (Interp : Lua.Lib.CORE with type 'a V.userdata' = 'a userdata') = struct

    <<dls type declarations and utilities>>
    <<dls algorithm>>

    module V       = Interp.V
    let proc       = ProcT.makemap V.userdata V.projection
    let ( **-> )   = V.( **-> )
    let stageFn    = V.unit **-> proc **-> V.result V.bool
    let dls_module = [ "dls", V.efunc stageFn dls ]

    let init = Interp.register_module "DLS" dls_module
      (* FIX -- replace with init code *)
  end
end
@
