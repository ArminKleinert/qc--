% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

\ifx\ocaml\undefined
    \newcommand{\ocaml}{{\small OCAML}}
    \newcommand{\asdl}{{\small ASDL}}
    \newcommand{\C}{{\small C--}}
    \let\PAL\C
    \newcommand{\rtl}{{\small RTL}}
\fi

% ------------------------------------------------------------------ 
\section{The Fat Environment}
% ------------------------------------------------------------------ 

The meaning, or denotation, of names in a {\PAL} program are recorded
in one environment.  Because only one environment is used for all
different kinds of names it is called fat.  In particular the fat
environment holds informations about:

\begin{itemize}
\item Values, like constants, labels for goto and data, procedures.
\item Types, as they are declared by the [[typedef]] directive.
\item Target architecture, as declared by the [[target]] directive.
\item Source code positions, as recored by a [[Srcmap.map]].
\end{itemize}

The fat environment comes in two variants:  a \textit{dirty} and a
\textit{clean} one.  A dirty environment is built during the first
phases of compilation:  names bound in a dirty environment can be
either good or bad.  The error propagation combinators from the
[[Error]] module are used to deal with good and bad values.  After the
semantics of a {\PAL} program are checked and when no errors were
found a dirty environment is known to bind only good values.  At this
point a clean environment can be generated from the dirty one.  The
clean environment is easier to deal with since it guarantees
statically that all its bound values are good.
  
% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The dirty and the clean environment are modeled as sub-modules
[[Dirty]] and [[Clean]] respectively. The dirty nature of an environment
is captured by two types [[info]] and [[partial]]:

\begin{itemize}
\item An [['a info]] is a possibly erroneous [['a]] value in a dirty
      environment, but always an [['a]] in a clean environment.

\item An [['a partial]] is a possibly unavailable [['a]] value in a
      dirty environment, but always an [['a]] value in a clean
      environment.

\item The [[bad]] function creates a erroneous value of the [['a
      info]] type.  Using this function in a clean environment causes
      an assertion violation.

\end{itemize}      

<<module type Env>>=
module type Env = sig
    type 'a info
    type 'a partial
    val  bad: unit -> 'a info

    <<signature Env>>
end
@

A clean environment is obtained from a dirty environment by cleaning
it.  Only a dirty environment can be transformed in a clean
environment that contains only complete (wrt.~[[partial]]) and
error-free (wrt.[[info]]) values.  Applying [[clean]] to an
[[Dirty.env]] not meeting this requirement will result in an assertion
violation. 

<<fenv.mli>>=
<<module type Env>>

module Dirty : Env
    with type 'a info    = 'a Error.error
    with type 'a partial = 'a option

module Clean : Env
    with type 'a info    = 'a 
    with type 'a partial = 'a 

val clean: Dirty.env -> Clean.env 
@


% ------------------------------------------------------------------ 
\subsubsection{Informations about Types and Values}
% ------------------------------------------------------------------ 

The main purpose of a fat environment [[env]] is to bind names to
[[value]]s and types [[ty]].  Each binding has attributes [[attr]]
that tell about its [[scope]] and the location of its declaration in
the source code.  {\PAL} has only two scopes:  the top level and
section level constitutes the [[Global]] scope, a procedure a
[[Local]] level. 

<<signature Env>>=
type env
type scope          = Global | Local
type attr           = Srcmap.reg * scope
type endianness     = Big | Little
@            

A [[value]] comes in different flavors -- the [[denotation]] of a name
tells us the details.  Different [[kind]] of labels are subsumed under
one [[Label]] constructor.  A procedure entry holds the environment
for its local scope.

<<>>=
type kind           = Proc  of env partial
                    | Code
                    | Data
                    | Stack

type denotation     = Constant of Value.value
                    | Label    of kind
                    | Import
                    | Register
                    | Continuation
@

An entry for a value is a [[ventry]], an entry for a type a
[[tentry]].  The type constructor [[e]] wraps an entry in the dirty
variant of an environment and is the identity in case of a clean
environment.

<<>>=        
type ventry         = (denotation * Types.ty) info
type tentry         = Types.ty                info
@

% ------------------------------------------------------------------ 
\subsubsection{Type and Value Bindings}
% ------------------------------------------------------------------ 

Here are the functions that create and manipulate an environment. 

<<>>=
val empty           : Srcmap.map -> env
val bindv           : string -> attr * ventry  -> env -> env
val bindt           : string -> attr * tentry  -> env -> env
val findv           : string -> env -> attr * ventry
val findt           : string -> env -> attr * tentry
val srcmap          : env -> Srcmap.map
@

\begin{itemize}
\item An environment is created from a  [[Srcmap.map]] value; this
      value is returned by the [[srcmap]] function.

      \begin{tabular}{l}
        [[srcmap (empty x) = x]]\\
      \end{tabular}

\item Values are bound by [[bindv]].  Any attempt to re-bind a name in
      a given scope [[s]] results in in error-binding for the exsiting
      binding and an error message in a dirty environment.  Re-binding
      a value in a clean environment results in a run-time error.
      
      \begin{tabular}{l}
        [[findv n (bindv n (x,y) empty) = (x,y)]] \\
        [[bindv n ((a,s),b) (bindv n ((c,s),d) empty) = ]]\\
        [[bindv n ((c,s),bad ()) empty]]
      \end{tabular}

\item Types are bound by [[bindt]].  The principal behaviour is
      identical to [[bindv]] and [[findf]], i.e.~type can not be
      re-bound.
      
      \begin{tabular}{l}
        [[findt n (bindt n (x,y) empty) = (x,y)]] \\
        [[bindt n ((a,s),b) (bindt n ((c,s),d) empty) = ]]\\
        [[bindt n ((c,s),bad ()) empty]]
      \end{tabular}
\end{itemize}

During the first phases of the static analysis the local environment
of a procedure is unknown.  Once it is known we like to bind it to the
procedures name.  This requires a re-binding of the existing name
which is not possible when [[bindv]] is used.  We therefore have
[[rebindProc]] which can \emph{only} be used to re-bind a procedure
entry to a new ventry.

<<>>=
val rebindProc      : string -> ventry -> env -> env
@

% ------------------------------------------------------------------ 
\subsubsection{Error Flag}
% ------------------------------------------------------------------ 

The fat environment also holds an error flag.  Is is set at the first
error found in the static semantics of a program.  The function
[[flagError env]] sets the flag in the returned environment,
[[errorFlag]] returns the flag's value in [[env]].  The [[flagError]]
function obeys to the following law:

\begin{tabular}{l}
    [[flagError (flagError env) = flagError env]]\\
    [[errorFlag (flagError empty) = true]]       \\
    [[errorFlag empty = false]]
\end{tabular}

<<>>=
val flagError       : env -> env
val errorFlag       : env -> bool
@

% ------------------------------------------------------------------ 
\subsubsection{Target}
% ------------------------------------------------------------------ 

The environment stores informations about the target platform.  These
data may have some defaults and is specified in a {\PAL} program by
the [[target]] declaration.  Currently [[target memsize]] and [[target
byteorder]] are accessible.  Once an information is bound for a target
all subsequent binds must provide the same information.  In case an
inconsistent update is attempted the binding becomes erroneous.  In
order to provide a meaningful error message in this case the bind
functions receive a source code position.

\begin{quote}
    Should the error reporting be factored out by reporting
    inconsistencies with an exception?
\end{quote}


<<>>=
val bindMemsize     : Srcmap.reg -> int        -> env -> env
val bindEndianness  : Srcmap.reg -> endianness -> env -> env 
val findMemsize     : env -> int        partial info 
val findEndianness  : env -> endianness partial info
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation tries to exploit the commonalities between the
[[Clean]] and [[Dirty]] module by using a functor [[Env]].  The
facored out differences between [[Clean]] and [[Dirty]] are supplied
as an argument [[Arg]] of type [[Arg]].  The main part of the
impplementation is thus the generic functor [[Env]] which is described
in the following section.

<<fenv.ml>>=
module E            = Error
@

Name spaces are implemented as polymorphic functional maps from
[[string]] to some value.  The [[Map.Make]] functor must be provided
with the structure of the key, i.e.~the [[string]] type.

<<>>=
module Comparable   = struct type t=string let compare=compare end
module StrMap       = Map.Make(Comparable)
@
A handy error printing function: [[r]] is a [[Srcmap.reg]] source code
position that is used to describe the place where an error is located. 

<<>>=
let error r map msg = E.errorRegionPrt (map,r) msg 

<<module type Env>>

module type Arg = sig
    type 'a partial
    type 'a info
    
    val good    : 'a   -> 'a info
    val bad     : unit -> 'a info
    val update  : 'a partial info -> 'a -> (unit -> unit) -> 'a partial info
    val default : 'a   -> 'a partial info
end
@ 

We must not use the module type [[Env]] to describe the interface of
[[Env]]. This would hide the implementation of [[env]] which we need
to implement [[clean]].

<<>>=
module Env (Arg: Arg) = struct <<module Env>> end
@
    
Here are the two modules for the [[Clean]] and [[Dirty]] environment
which are instances of [[Env]].

<<>>=
module Dirty = Env (struct
    type 'a partial = 'a option
    type 'a info    = 'a Error.error
    
    let good    x   = Error.Ok(x)
    let bad     x   = Error.Error

    
    let update old new' error =
        E.sequence old
        ( function
        | Some x as old when x = new' -> Error.Ok(old)
        | Some x                      -> ( error ()
                                         ; Error.Error
                                         )
        | None                        -> Error.Ok(Some new') 
        )

    let default x = Error.Ok(None)
        
end)

module Clean = Env (struct
    type 'a partial             = 'a 
    type 'a info                = 'a

    let good x                  = x
    let bad  x                  = assert false
    let update old new' f       = new'
    let default x               = x
end)
@

The function [[clean]] translates a dirty environment into a clean
environment. 

<<>>=
<<clean function>>
@

% ------------------------------------------------------------------ 
\subsection{Implementation of functor [[Env]]}
% ------------------------------------------------------------------ 

<<module Env>>=
type 'a partial     = 'a Arg.partial
type 'a info        = 'a Arg.info
let  bad            = Arg.bad
@


Next we have to provide the type declarations. This includes the
implementation for the [[env]] type.

<<>>=
type scope          = Global | Local
type attr           = Srcmap.reg * scope
type endianness     = Big | Little
@            

<<>>=
type kind           = Proc  of env Arg.partial
                    | Code
                    | Data
                    | Stack

and  denotation     = Constant of Value.value
                    | Label    of kind
                    | Import
                    | Register
                    | Continuation

and  ventry         = (denotation * Types.ty) Arg.info
and  tentry         = Types.ty                Arg.info
@

Bindings for value and types are stored in a string-map [[StrMap]]. 
Each entry consists of attributes [[attr]] for the source code
location and scope of an entry and detailed informations about the
denotation of the bound name.

<<>>=
and  tenv           = (attr * tentry) StrMap.t
and  venv           = (attr * ventry) StrMap.t
@

<<>>=
and  target         = { memsize:      int        partial info
                      ; endianness:   endianness partial info
                      ; word:         Types.ty   partial info
                      ; code:         Types.ty   partial info
                      ; data:         Types.ty   partial info
                      ; float:        string     partial info
                      ; charset:      string     partial info
                      }
@

An [[env]] is a record that holds maps for types and values. The
target description is implemented as a record because the values bound
are not uniform.

<<>>=
and   env           = 
                      { tenv   :      tenv
                      ; venv   :      venv
                      ; srcmap :      Srcmap.map
                      ; error  :      bool
                      ; target :      target
                      }    
@

% ------------------------------------------------------------------ 
\subsubsection{Values}
% ------------------------------------------------------------------ 

The fat environment holds the source map for the program being
compiled. It is required to translate the annotations in the abstract
syntax into meaningful file, line, column notation.

<<>>=
let empty  map      = { tenv   = StrMap.empty
                      ; venv   = StrMap.empty
                      ; srcmap = map
                      ; error  = false
                      ; target = { memsize    = Arg.default 8
                                 ; endianness = Arg.default Little
                                 ; word       = Arg.default Types.word
                                 ; code       = Arg.default Types.code
                                 ; data       = Arg.default Types.data
                                 ; float      = Arg.default "ieee754"
                                 ; charset    = Arg.default "latin1"
                                 }
                      } 
@

The fat environment also holds an error flag.  Is is set at the first
error found in the static semantics of a program.  The function
[[flagError env]] sets the flag in the returned environment,
[[errorFlag]] returns the flag's value in [[env]].

<<>>=
let srcmap env    = env.srcmap
let flagError env = if env.error then env else { env with error = true }
let errorFlag env = env.error
@

When a name is re-declared we issue two error messages:  the first
describes the actual location [[reg]] where the problem is detected,
and the second the location of the declaration that clashes.  This one
is also re-bound to [[Error]] to flag the problem.

<<>>=
let bindv name ((reg,scope as attr),x) env =
    let add name x env = {env with venv = StrMap.add name x env.venv} in
    try 
        let (reg',scope' as attr'),_ = StrMap.find name env.venv in
        if scope' = scope then
            ( error reg  env.srcmap ("re-declaration of value "^name)
            ; error reg' env.srcmap ("previously declared here")
            ; add name (attr',Arg.bad ()) (flagError env)
            )
        else
            add name (attr,x) env
    with
        Not_found -> add name (attr,x) env

<<>>=
let bindt name ((reg,scope as attr),x) env =
    let add name x env = {env with tenv = StrMap.add name x env.tenv} in
    try 
        let (reg',scope' as attr'),_ = StrMap.find name env.tenv in
        if scope' = scope then
            ( error reg  env.srcmap ("re-declaration of type "^name)
            ; error reg' env.srcmap ("previously declared here")
            ; add name (attr',Arg.bad ()) (flagError env) 
            )
        else
            add name (attr,x) env
    with
        Not_found -> add name (attr,x) env
@

The following function [[rebindv name x env]] re-binds [[name]] to
[[x]]. Since this is only intended to update the informations for an
existing [[name]], [[name]] must be bound in [[env]] as a value. The
scope and source code location of the existing binding is re-used for
the new binding.

<<>>=
let rebindProc name x env = 
    try 
        let attr,_ = StrMap.find name env.venv in
            { env with venv = StrMap.add name (attr,x) env.venv }
      with Not_found -> assert false
   
@
    
The functions to lookup a value [[findv]] and a type [[findt]] raise
an [[E.Error]] exception in case the name can not be found.

<<>>=
let findv name env =
    try
        StrMap.find name env.venv
    with 
        Not_found -> E.error ("unknown value: "^name)

<<>>=
let findt name env =
    try
        StrMap.find name env.tenv
    with
        Not_found -> E.error ("unknown type: "^name)
@


The [[target]] directive in {\PAL} describes the target architecture
an program is intended for. The information can be distributed over
the program and can declare the same fact several times.  However, the
informations about the target architecture must be consistent. 

The implementation maintains a record of type [[target]] for the target
informations where each information is captured by an [[option]] type. 
Once an information has been supplied the [[bind]] functions enforce
that only the same fact can be entered again.  When an inconsistent
update is attempted the target information is bound to [[Error]] and an
error message is issued.

The [[update]] function computes the value inside the target record
based on an existing value and a new one. In case the target record
was un-set the new value is returned. Otherwise the new value must
match the existing one, or an inconsistency was found. In the latter
case [[Error]] is returned.

<<>>=
let bindMemsize r n env =
    let f ()     = error r env.srcmap "inconsistent memsize specification" in
    let memsize' = Arg.update env.target.memsize n f                       in
    let target'  = { env.target with memsize = memsize' }                  in
        { env with  target = target' }

<<>>=
let bindEndianness r e env =
    let f ()     = error r env.srcmap "inconsistent byteorder specification" in
    let e'       = Arg.update env.target.endianness e f                      in
    let target'  = { env.target with endianness = e' }                       in
        { env with target = target' }
        

<<>>=
let findMemsize    env = env.target.memsize
let findEndianness env = env.target.endianness
@   

% ------------------------------------------------------------------ 
\subsubsection{Cleaning a fat environment}
% ------------------------------------------------------------------ 

A [[Clean.env]] is created from a [[Dirty.env]] by copying values from
one to another.  The string typing discipline of {\ocaml} precludes
the use of patterns in most cases such that things must be copied
explicitly.


<<clean function>>=
let clean_scope = function
    | Dirty.Local  -> Clean.Local
    | Dirty.Global -> Clean.Global

let rec clean_venv map  =
    let copy key data map = match data with
        |  (pos,scope),E.Ok(denot,ty) ->
            let denot' = match denot with
                | Dirty.Constant(v)               -> Clean.Constant(v)
                | Dirty.Label(Dirty.Proc(Some e)) -> Clean.Label(Clean.Proc(clean e))
                | Dirty.Label(Dirty.Code)         -> Clean.Label(Clean.Code)
                | Dirty.Label(Dirty.Data)         -> Clean.Label(Clean.Data)
                | Dirty.Label(Dirty.Stack)        -> Clean.Label(Clean.Stack)
                | Dirty.Import                    -> Clean.Import
                | Dirty.Register                  -> Clean.Register
                | Dirty.Continuation              -> Clean.Continuation
                | _                               -> assert false
            in
                 StrMap.add key ((pos,clean_scope scope),(denot',ty)) map
        |  _  -> assert false
    in
        StrMap.fold copy map StrMap.empty      
<<>>=
and clean_tenv map =
    let copy key data map = match data with
        | (p,s), E.Ok(t) -> StrMap.add key ((p,clean_scope s),t) map
        | _             -> assert false
    in
        StrMap.fold copy map StrMap.empty

and clean_target = function
    |   { Dirty.memsize    = E.Ok(Some n)
        ; Dirty.endianness = E.Ok(Some e)
        ; Dirty.word       = E.Ok(Some w)
        ; Dirty.data       = E.Ok(Some d)
        ; Dirty.code       = E.Ok(Some c)
        ; Dirty.float      = E.Ok(Some f)
        ; Dirty.charset    = E.Ok(Some s)
        } ->
        { Clean.memsize    = n
        ; Clean.endianness = ( match e with
                             | Dirty.Little -> Clean.Little
                             | Dirty.Big    -> Clean.Big
                             )
        ; Clean.word       = w
        ; Clean.data       = d
        ; Clean.float      = f
        ; Clean.code       = c
        ; Clean.charset    = s
        }
    |   _ -> assert false 

and clean env =
    { Clean.tenv   = clean_tenv env.Dirty.tenv
    ; Clean.venv   = clean_venv env.Dirty.venv
    ; Clean.srcmap = env.Dirty.srcmap 
    ; Clean.error  = env.Dirty.error
    ; Clean.target = clean_target env.Dirty.target
    }
@


