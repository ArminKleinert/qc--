
\input{macros.tex}


% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{The Fat Environment}
% ------------------------------------------------------------------ 

The meaning, or denotation, of names in a {\PAL} program are recorded
in one environment.  Because only one environment is used for all
different kinds of names it is called fat.  The fat environment not
only serves the classic symbol table purpose but also represents some
global state of the compiler.  It is used to pass around informations
between the different phases of the compiler.  In particular the fat
environment holds informations about:

\begin{itemize}
\item Values, like constants, labels for goto and data, procedures.
\item Types, as they are declared by the [[typedef]] directive.
\item Target architecture, as declared by the [[target]] directive.
\item Source code positions, as recored by a [[Srcmap.map]].
\item An Index counter for registers.
\end{itemize}

The fat environment comes in two variants:  a \textit{dirty} and a
\textit{clean} one.  A dirty environment is built during the first
phases of compilation:  names bound in a dirty environment can be
either good or bad.  The error propagation combinators from the
[[Error]] module are used to deal with good and bad values.  After the
semantics of a {\PAL} program are checked and when no errors were
found a dirty environment is known to bind only good values.  At this
point a clean environment can be generated from the dirty one.  The
clean environment is easier to deal with since it guarantees
statically that all its bound values are good.
  
% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The dirty and the clean environment are modeled as sub-modules
[[Dirty]] and [[Clean]] respectively. The dirty nature of an environment
is captured by two types [[info]] and [[partial]]:

\begin{itemize}
\item An [['a info]] is a possibly erroneous [['a]] value in a dirty
      environment, but always an [['a]] in a clean environment.

\item An [['a partial]] is a possibly unavailable [['a]] value in a
      dirty environment, but always an [['a]] value in a clean
      environment.

\item The [[bad]] function creates a erroneous value of the [['a
      info]] type.  Using this function in a clean environment causes
      an assertion violation.

\end{itemize}      

<<module type Env>>=
module type Env = sig
    type 'a info
    type 'a partial
    val  bad: unit -> 'a info

    <<signature Env>>
end
@

A clean environment is obtained from a dirty environment by cleaning
it.  Only a dirty environment can be transformed in a clean
environment that contains only complete (wrt.~[[partial]]) and
error-free (wrt.[[info]]) values.  Applying [[clean]] to an
[[Dirty.env]] not meeting this requirement will result in an assertion
violation. 

<<fenv.mli>>=
module StrSet: Set.S with type elt = string
module StrMap: Map.S with type key = string

<<module type Env>>

module Dirty : Env
    with type 'a info    = 'a Error.error
    with type 'a partial = 'a option

module Clean : Env
    with type 'a info    = 'a 
    with type 'a partial = 'a 

val clean: Dirty.env -> Clean.env 
@


% ------------------------------------------------------------------ 
\subsubsection{Informations about Types and Values}
% ------------------------------------------------------------------ 

The main purpose of a fat environment [[env]] is to bind names to
[[value]]s and types [[ty]].  Each binding has attributes [[attr]]
that tell about its [[scope]] and the location of its declaration in
the source code.  {\PAL} has only two scopes:  the top level and
section level constitutes the [[Global]] scope, a procedure a
[[Local]] level. 

<<signature Env>>=
type env
type scope          = Global | Local
type attr           = Srcmap.rgn * scope
type endianness     = Big | Little
@            

A [[value]] comes in different flavors -- the [[denotation]] of a name
tells us the details.

\begin{itemize}
\item Different [[kind]] of labels are subsumed under one [[Label]]
      constructor. 

\item A procedure entry holds the environment for its local scope. 

\item A constant always holds a value and never a condition. It is
      thus of type [[Bits.bits]]. 
\end{itemize}
      
<<>>=
type reghint        = RReg  of string   (* hardare reg *)
                    | RHint of string   (* calling convention hint *)
                    | RNone             (* none of above *)

type register       = { index:      int           (* for run-time API *)
                      ; rhint:      reghint       
                      }
@

The [[sbase]] component of a procedures denotation contains a name for
an assembly symbol that hold the offset from the stackpointer sp to
the start of the stackdata.


<<>>=
type proc = 
    { env:        env partial
    ; sdata:      int partial       (* amount of stackdata  *)
    ; salign:     int partial       (* max align constraint *)
    }

type kind           = Proc          of proc
                    | Code
                    | Data
                    | Stack         of int partial (* stack offset *)    

type denotation     = Constant      of Bits.bits
                    | Label         of kind
                    | Import        of string option
                    | Register      of register
                    | Continuation
@

An entry for a value is a [[ventry]], an entry for a type a
[[tentry]].  The type constructor [[e]] wraps an entry in the dirty
variant of an environment and is the identity in case of a clean
environment.

<<>>=        
type ventry         = (denotation * Types.ty) info
type tentry         = Types.ty                info
@

Global registers can be mapped to hardware registers. The sequence of
their declarations matters and thus the fat environment provides their
asbtract sequence:

<<>>=
type hwregs         = ( string          (* register name        *)
                      * reghint         (* hint on register     *)        
                      * Types.ty        (* C-- type of register *)
                      ) list
@
 
% ------------------------------------------------------------------ 
\subsubsection{Type and Value Bindings}
% ------------------------------------------------------------------ 

Here are the functions that create and manipulate an environment. 

<<>>=
val empty           : Srcmap.map -> env
val bindv           : string -> attr * ventry  -> env -> env
val bindt           : string -> attr * tentry  -> env -> env
val findv           : string -> env -> attr * ventry
val findt           : string -> env -> attr * tentry
val srcmap          : env -> Srcmap.map
@

\begin{itemize}
\item An environment is created from a  [[Srcmap.map]] value; this
      value is returned by the [[srcmap]] function.

      \begin{tabular}{l}
        [[srcmap (empty x) = x]]\\
      \end{tabular}

\item Values are bound by [[bindv]].  Any attempt to re-bind a name in
      a given scope [[s]] results in in error-binding for the exsiting
      binding and an error message in a dirty environment.  Re-binding
      a value in a clean environment results in a run-time error.
      
      \begin{tabular}{l}
        [[findv n (bindv n (x,y) empty) = (x,y)]] \\
        [[bindv n ((a,s),b) (bindv n ((c,s),d) empty) = ]]\\
        [[bindv n ((c,s),bad ()) empty]]
      \end{tabular}

\item Types are bound by [[bindt]].  The principal behaviour is
      identical to [[bindv]] and [[findf]], i.e.~type can not be
      re-bound.
      
      \begin{tabular}{l}
        [[findt n (bindt n (x,y) empty) = (x,y)]] \\
        [[bindt n ((a,s),b) (bindt n ((c,s),d) empty) = ]]\\
        [[bindt n ((c,s),bad ()) empty]]
      \end{tabular}
\end{itemize}

During the early phases pf static analysis some denotaional aspects of
names are unknown which must be added later.  This is done using
[[rebindv]].  Sine [[bindv]] checks for re-definitons of names it can
not be used for this purpose.  The attributes (like source location,
scope) associated with a name from its first binding stay the same.

<<>>=
val rebindv     : string -> ventry -> env -> env
@

% ------------------------------------------------------------------ 
\subsubsection{Error Flag}
% ------------------------------------------------------------------ 

The fat environment also holds an error flag.  Is is set at the first
error found in the static semantics of a program.  The function
[[flagError env]] sets the flag in the returned environment,
[[errorFlag]] returns the flag's value in [[env]].  The [[flagError]]
function obeys to the following law:

\begin{tabular}{l}
    [[flagError (flagError env) = flagError env]]\\
    [[errorFlag (flagError empty) = true]]       \\
    [[errorFlag empty = false]]
\end{tabular}

<<>>=
val flagError       : env -> env
val errorFlag       : env -> bool
@

% ------------------------------------------------------------------ 
\subsubsection{Target}
% ------------------------------------------------------------------ 

The environment stores informations about the target platform.  These
data may have some defaults and is specified in a {\PAL} program by
the [[target]] declaration.  Currently [[target memsize]] and [[target
byteorder]] are accessible.  Once an information is bound for a target
all subsequent binds must provide the same information.  In case an
inconsistent update is attempted the binding becomes erroneous.  In
order to provide a meaningful error message in this case the bind
functions receive a source code position.

\begin{quote}
    Should the error reporting be factored out by reporting
    inconsistencies with an exception?
\end{quote}


<<>>=
val bindMemsize     : Srcmap.rgn -> int        -> env -> env
val bindEndianness  : Srcmap.rgn -> endianness -> env -> env 
val bindWordsize    : Srcmap.rgn -> int        -> env -> env
val bindPointersize : Srcmap.rgn -> int        -> env -> env
val bindFloat       : Srcmap.rgn -> string     -> env -> env
val bindCharset     : Srcmap.rgn -> string     -> env -> env

val findMemsize     : env -> int        partial info 
val findEndianness  : env -> endianness partial info
val findWordsize    : env -> int        partial info
val findPointersize : env -> int        partial info
val findFloat       : env -> string     partial info
val findCharset     : env -> string     partial info
@

% ------------------------------------------------------------------ 
\subsubsection{Register Index}
% ------------------------------------------------------------------ 

{\PAL} uses integers to identify global and local registers during
run-time at the run-time interface.  The fat environment maintains a
counter to facilitate the assignment of an integer to a register.

\begin{itemize}
\item [[setIndex]] sets the index counter.
\item [[getIndex]] returns the actual value of the index counter.
\item [[incrIndex]] advances the index counter.
\end{itemize}

The index-related functions obey the following laws:

\begin{quote}
\begin{verbatim}
getIndex (setIndex env n) = n
getIndex (incrIndex env) = (getIndex env) + 1
\end{verbatim}
\end{quote}

<<>>=
val setIndex        : env -> int -> env
val getIndex        : env -> int
val incrIndex       : env -> env         
@

% ------------------------------------------------------------------ 
\subsubsection{Stackdata Offset}
% ------------------------------------------------------------------ 

Inside of a procedure uninitialized data can be declared on the stack. 
For each procedure an [[offset]] is maintained that counts the amount
of memory declared on the stack and whose value is bound to label
inside of stack data declarations.  Since procedures do not nest in
{\PAL}, a single counter in the [[env]] is sufficient.  We have
decided to maintain the [[offset]] counter inside the fat environment
because the [[offset]] must be maintained over many functions and
becomes a non-local property.

<<>>=
val resetOffset     : env -> env
val incrOffset      : int -> env -> env
val alignOffset     : int -> env -> env
val maxOffsetAlign  : env -> int
val offset          : env -> int
@

Each procedure sets the offset to zero by calling [[resetOffset]].  A
data declaration increments the offset by its size using
[[incrOffset]].  The [[alignOffset n]] function advances the [[offset]]
to the next multiple of [[n]] unless [[offset]] is already a multiple
of [[n]].  The maximal alignment constraint is also remembered and
returned by [[maxOffsetAlign]].  For labels and the total amount of
[[stackdata]] [[offset]] reports the current value of the offset
counter.

Beware:  the value of [[offset]] is only meaningful in the context of
a procedure and not a global program property.

% ------------------------------------------------------------------ 
\subsubsection{Imports and Exports}
% ------------------------------------------------------------------ 

The translation process assigns certain {\PAL} \emph{names} assembly-level
\emph{symbols}. The relation between a name and its assembly symbol is
not straight forward, as explained in module \module{mangle}. In order
to build a map from {\PAL} names to symbols all imports and exports of
a {\PAL} program must be registered. This is done with [[import]] and
[[export]]. To provide meaningful error messages, both function receive
the region of the statement at hand in the source code. 

<<>>=
val import: Srcmap.rgn -> string -> string -> env -> env (* import g as f *)
val export: Srcmap.rgn -> string -> string -> env -> env (* export f as g *)
@

The assembly level symbols imported and exported from a compilation
unit can be obtained, as well as a map from {\PAL} names to these
symbols.  The union of the imported and exported sets equals the range
of the map.

<<>>=
val imported: env -> StrSet.t
val exported: env -> StrSet.t
val nam2sym:  env -> string StrMap.t
@

% ------------------------------------------------------------------ 
\subsubsection{Hardware Registers}
% ------------------------------------------------------------------

A {\PAL} program can declare global registers to use a specific target
hardware register.  The abstract \emph{sequence} of these declarations
is returned by [[hwreg_decls]]:

<<>>=
val hwreg_decls: env -> hwregs
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation tries to exploit the commonalities between the
[[Clean]] and [[Dirty]] module by using a functor [[Env]].  The
factored out differences between [[Clean]] and [[Dirty]] are supplied
as an argument [[Arg]] of type [[Arg]].  The main part of the
implementation is thus the generic functor [[Env]] which is described
in the following section.

<<fenv.ml>>=
module E            = Error
module T            = Types
@

Name spaces are implemented as polymorphic functional maps from
[[string]] to some value.  The [[Map.Make]] functor must be provided
with the structure of the key, i.e.~the [[string]] type. The
[[import]] and [[export]] functions build sets of symbol, so we need a
set of strings, too.

<<>>=
module Comparable   = struct type t=string let compare=compare end
module StrMap       = Map.Make(Comparable)
module StrSet       = Set.Make(Comparable)
@
A handy error printing function: [[r]] is a [[Srcmap.reg]] source code
position that is used to describe the place where an error is located. 

<<>>=
let error r map msg = E.errorRegionPrt (map,r) msg 

<<module type Env>>
@

The [[Arg]] modules captures the aspects not common to [[Clean]] and
[[Dirty]]:

\begin{itemize}
    \item First of all, are information more vaguely represented in
    [[Dirty]] than in [[Clean]]: a [[partial]] information might be
    absent in [[Dirty]], but not in [[Clean]]. And an information
    [[info]] can be marked as [[bad]] in [[Dirty]], but not in
    [[Clean]]. Functions help to create [[good]] and [[bad]] values. 

    \item The [[update x y f]] function compares a [[partial info]]
    value [[x]] with a plain one [[y]].  In case they differ, [[f]] is
    called.  This is used to implement the update of values in the
    target environment.  The [[Dirty]] module checks the new [[y]]
    value to be consistent with the old value [[x]]. 
    
    \item The default value is used to create an initial target record
    as part of a [[Dirty.empty]] and [[Clean.empty]]. In [[Dirty]]
    nothing is known about a target yet and thus all fields are
    considered as good, but unknown.

    \item The [[asgood]] function provides a way to access [[info]]
    information.  If the information is absent, [[None]] is returned. 
    In a [[Clean.env]] environment [[asgood]] alsways returns a
    [[Some]] value.
@

\end{itemize} 

<<>>=
module type Arg = sig
    type 'a partial
    type 'a info
    
    val good    : 'a   -> 'a info
    val asgood  : 'a info -> 'a option
    val bad     : unit -> 'a info
    val update  : 'a partial info -> 'a -> (unit -> unit) -> 'a partial info
    val default : 'a   -> 'a partial info
end
@ 

We must not use the module type [[Env]] to describe the interface of
[[Env]]. This would hide the implementation of [[env]] which we need
to implement [[clean]].

<<>>=
module Env (Arg: Arg) = struct <<module Env>> end
@
    
Here are the two modules for the [[Clean]] and [[Dirty]] environment
which are instances of [[Env]].

<<>>=
module Dirty = Env (struct
    type 'a partial = 'a option
    type 'a info    = 'a Error.error
    
    let good    x   = Error.Ok(x)
    let bad     x   = Error.Error
    let asgood = function
        | Error.Ok(x) -> Some x
        | Error.Error -> None
    
    let update old new' error =
        E.sequence old
        ( function
        | Some x as old when x = new' -> Error.Ok(old)
        | Some x                      -> ( error ()
                                         ; Error.Error
                                         )
        | None                        -> Error.Ok(Some new') 
        )

    let default x = Error.Ok(None)
        
end)

module Clean = Env (struct
    type 'a partial             = 'a 
    type 'a info                = 'a

    let good x                  = x
    let asgood x                = Some x
    let bad  x                  = assert false
    let update old new' f       = new'
    let default x               = x
end)
@

The function [[clean]] translates a dirty environment into a clean
environment. 

<<>>=
<<clean function>>
@

% ------------------------------------------------------------------ 
\subsection{Implementation of functor [[Env]]}
% ------------------------------------------------------------------ 

<<module Env>>=
type 'a partial     = 'a Arg.partial
type 'a info        = 'a Arg.info
let  bad            = Arg.bad
@


Next we have to provide the type declarations. This includes the
implementation for the [[env]] type.

<<>>=
type scope          = Global | Local
type attr           = Srcmap.rgn * scope
type endianness     = Big | Little
@            

<<>>=
type reghint        = RReg  of string   (* hardare reg *)
                    | RHint of string   (* calling convention hint *)
                    | RNone             (* none of above *)

type register       = { index:      int           (* for run-time API *)
                      ; rhint:      reghint       
                      }
@

A global register can be declared to use a specific hardware register. 
All hardware registers used by a program are remembered in the fat
environment such that a set of all used hardware registers can be
obtained.

<<>>=
and proc = 
    { env:        env partial
    ; sdata:      int partial       (* amount of stackdata  *)
    ; salign:     int partial       (* max align constraint *)
    }
                      
and  kind           = Proc          of proc
                    | Code
                    | Data
                    | Stack         of int partial (* stack offset *)

and  denotation     = Constant      of Bits.bits
                    | Label         of kind
                    | Import        of string option
                    | Register      of register
                    | Continuation

and  ventry         = (denotation * Types.ty) Arg.info
and  tentry         = Types.ty                Arg.info

<<>>=
and  hwregs         = ( string          (* register name        *)
                      * reghint         (* hint on register     *)        
                      * Types.ty        (* C-- type of register *)
                      ) list
@

Bindings for value and types are stored in a string-map [[StrMap]]. 
Each entry consists of attributes [[attr]] for the source code
location and scope of an entry and detailed informations about the
denotation of the bound name.

<<>>=
and  tenv           = (attr * tentry) StrMap.t
and  venv           = (attr * ventry) StrMap.t
@

<<>>=
and  target         = { memsize:      int        partial info
                      ; endianness:   endianness partial info
                      ; word:         int        partial info
                      ; pointer:      int        partial info
                      ; float:        string     partial info
                      ; charset:      string     partial info
                      }
@

Imports and exports are recorded (see module \module{mangle}) to build
a map from {\PAL} names to assembly symbols.  The [[asm]] type holds
two sets of assembly symbols:  [[imported]] and [[exported]], and a
map from {\PAL} names to symbols.

<<>>=
and asm             = { imported:     StrSet.t
                      ; exported:     StrSet.t
                      ; nam2sym:      string StrMap.t
                      }
@

An [[env]] is a record that holds maps for types and values. The
target description is implemented as a record because the values bound
are not uniform.

<<>>=
and   env           = 
                      { tenv    :      tenv
                      ; venv    :      venv
                      ; srcmap  :      Srcmap.map
                      ; error   :      bool
                      ; target  :      target
                      ; asm     :      asm
                      ; rindex  :      int       (* register index *)
                      ; offset  :      int       (* stack data offset *)
                      ; maxalign:      int       (* offset align constraint*)
                      ; hwregs  :      hwregs    (* hardware registers *)
                      }
                      
@

% ------------------------------------------------------------------ 
\subsubsection{Values}
% ------------------------------------------------------------------ 

The fat environment holds the source map for the program being
compiled. It is required to translate the annotations in the abstract
syntax into meaningful file, line, column notation.

<<>>=
let empty  map      = { tenv   = StrMap.empty
                      ; venv   = StrMap.empty
                      ; srcmap = map
                      ; error  = false
                      ; rindex = 0
                      ; offset = 0 
                      ; maxalign = 1
                      ; hwregs = []
                      ; target = { memsize    = Arg.default 8
                                 ; endianness = Arg.default Little
                                 ; word       = Arg.default 32
                                 ; pointer    = Arg.default 32
                                 ; float      = Arg.default "ieee754"
                                 ; charset    = Arg.default "latin1"
                                 }
                      ; asm    = { imported   = StrSet.empty
                                 ; exported   = StrSet.empty
                                 ; nam2sym    = StrMap.empty
                                 }
                      } 
@

The fat environment also holds an error flag.  Is is set at the first
error found in the static semantics of a program.  The function
[[flagError env]] sets the flag in the returned environment,
[[errorFlag]] returns the flag's value in [[env]].

<<>>=
let srcmap env    = env.srcmap
let flagError env = if env.error then env else { env with error = true }
let errorFlag env = env.error
@

When a name is re-declared we issue two error messages:  the first
describes the actual location [[reg]] where the problem is detected,
and the second the location of the declaration that clashes.  This one
is also re-bound to [[Error]] to flag the problem.

<<>>=
let bindv name ((reg,scope as attr),x) env =
    let add name x env = {env with venv = StrMap.add name x env.venv} in
    try 
        let (reg',scope' as attr'),_ = StrMap.find name env.venv in
        if scope' = scope then
            ( error reg  env.srcmap ("re-declaration of value "^name)
            ; error reg' env.srcmap ("previously declared here")
            ; add name (attr',Arg.bad ()) (flagError env)
            )
        else match Arg.asgood x with 
        | Some (Register({rhint=h} as reg),t) ->
               { env with venv   = StrMap.add name (attr,x) env.venv
               ;          hwregs = (name,h,t) :: env.hwregs  
               }          
        | _ -> { env with venv = StrMap.add name (attr,x) env.venv }
    with
        Not_found -> add name (attr,x) env

<<>>=
let bindt name ((reg,scope as attr),x) env =
    let add name x env = {env with tenv = StrMap.add name x env.tenv} in
    try 
        let (reg',scope' as attr'),_ = StrMap.find name env.tenv in
        if scope' = scope then
            ( error reg  env.srcmap ("re-declaration of type "^name)
            ; error reg' env.srcmap ("previously declared here")
            ; add name (attr',Arg.bad ()) (flagError env) 
            )
        else
            add name (attr,x) env
    with
        Not_found -> add name (attr,x) env
@

The following function [[rebindv name x env]] re-binds [[name]] to
[[x]]. Since this is only intended to update the informations for an
existing [[name]], [[name]] must be bound in [[env]] as a value. The
scope and source code location of the existing binding is re-used for
the new binding.

<<>>=
let rebindv name x env = 
    try 
        let attr,_ = StrMap.find name env.venv in
            { env with venv = StrMap.add name (attr,x) env.venv }
      with Not_found -> assert false
   
@
    
The functions to lookup a value [[findv]] and a type [[findt]] raise
an [[E.Error]] exception in case the name can not be found.

<<>>=
let findv name env =
    try
        StrMap.find name env.venv
    with 
        Not_found -> E.error ("unknown value: "^name)

<<>>=
let findt name env =
    try
        StrMap.find name env.tenv
    with
        Not_found -> E.error ("unknown type: "^name)
@


The [[target]] directive in {\PAL} describes the target architecture
an program is intended for. The information can be distributed over
the program and can declare the same fact several times.  However, the
informations about the target architecture must be consistent. 

The implementation maintains a record of type [[target]] for the target
informations where each information is captured by an [[option]] type. 
Once an information has been supplied the [[bind]] functions enforce
that only the same fact can be entered again.  When an inconsistent
update is attempted the target information is bound to [[Error]] and an
error message is issued.

The [[update]] function computes the value inside the target record
based on an existing value and a new one. In case the target record
was un-set the new value is returned. Otherwise the new value must
match the existing one, or an inconsistency was found. In the latter
case [[Error]] is returned.

<<>>=
let update_int r map old i errmsg =
    if   i > 0 
    then Arg.update old i errmsg
    else ( error r map "positive number expected"
         ; Arg.bad ()
         ) 

<<>>=
let bindMemsize r n env =
    let f ()     = error r env.srcmap "inconsistent memsize specification" in
    let memsize' = update_int r env.srcmap env.target.memsize n f          in
    let target'  = { env.target with memsize = memsize' }                  in
        { env with  target = target' }

<<>>=
let bindWordsize r n env =
    let f ()     = error r env.srcmap "inconsistent word size specification" in
    let word'    = update_int r env.srcmap env.target.word n f               in
    let target'  = { env.target with word = word' }                          in
        { env with  target = target' }

let bindPointersize r n env =
    let f ()     = error r env.srcmap "inconsistent word size specification" in
    let pointer' = update_int r env.srcmap env.target.pointer n f            in
    let target'  = { env.target with pointer = pointer' }                    in
        { env with  target = target' }

<<>>=
let bindEndianness r e env =
    let f ()     = error r env.srcmap "inconsistent byteorder specification" in
    let e'       = Arg.update env.target.endianness e f                      in
    let target'  = { env.target with endianness = e' }                       in
        { env with target = target' }
        
<<>>=
let bindFloat r fp env =
    let f ()     = error r env.srcmap "inconsistent floating point specification" in
    let fp'      = Arg.update env.target.float fp f               in
    let target'  = { env.target with float = fp' }                in
        { env with target = target' }

<<>>=
let bindCharset r cs env =
    let f ()     = error r env.srcmap "inconsistent charset specification" in
    let cs'      = Arg.update env.target.charset cs f                      in
    let target'  = { env.target with charset = cs' }                       in
        { env with target = target' }

<<>>=
let findMemsize     env = env.target.memsize
let findEndianness  env = env.target.endianness
let findPointersize env = env.target.pointer 
let findWordsize    env = env.target.word    
let findFloat       env = env.target.float
let findCharset     env = env.target.charset

@   

% ------------------------------------------------------------------ 
\subsubsection{Imports and Exports}
% ------------------------------------------------------------------ 

The fat environment maintains the set of imported and exported
assembly symbols and a map, that associates an imported or exported
{\PAL} name with it symbol. No assembly symbol may be imported and
exported at the same time. If such a case is detected, an error
message is issued. Details about the connection between {\PAL} names
and assembly symbols can be found in \module{mangle}.

<<>>=
let import r sym name env =
    if StrSet.mem sym env.asm.exported 
    then ( error r env.srcmap ("import of an exported name: "^name)
         ; flagError env
         )
    else let asm = { exported = env.asm.exported
                   ; imported = StrSet.add sym env.asm.imported
                   ; nam2sym  = StrMap.add name sym env.asm.nam2sym
                   }
         in
            { env with asm = asm }

let export r name sym env =
    if StrSet.mem sym env.asm.imported 
    then ( error r env.srcmap ("export of an imported name: "^name)
         ; flagError env
         )
    else let asm = { imported = env.asm.imported
                   ; exported = StrSet.add sym env.asm.exported
                   ; nam2sym  = StrMap.add name sym env.asm.nam2sym
                   }
         in
            { env with asm = asm }
@

<<>>=
let imported env = env.asm.imported
let exported env = env.asm.exported
let nam2sym  env = env.asm.nam2sym
@


% ------------------------------------------------------------------ 
\subsubsection{Register Index}
% ------------------------------------------------------------------ 

No surprises here.

<<>>=
let setIndex   env n = { env with rindex = n}
let getIndex   env   = env.rindex
let incrIndex  env   = { env with rindex = env.rindex + 1}
@

% ------------------------------------------------------------------ 
\subsubsection{Stackdata Offset}
% ------------------------------------------------------------------ 

The implementation of the [[offset]] functions for stack data are
straight forward:

<<>>=
let resetOffset env     = { env with offset = 0 }
let incrOffset n env    = { env with offset = env.offset + n }
let offset env          = env.offset
let maxOffsetAlign env  = env.maxalign
@

The [[alignOffset]] function aligns the [[offset]] counter and also
remembers the maximal alignment constraint.

<<>>=
let alignOffset n env = 
    let m = max n env.maxalign in
    let o = if   env.offset mod n = 0 
            then env.offset 
            else let q = env.offset / n in (q+1) * n
    in
        { env with
            offset   = o
        ;   maxalign = m
        }
@

% ------------------------------------------------------------------ 
\subsubsection{Hardware Registers}
% ------------------------------------------------------------------ 

The list of register declarations that use hardware registers is build
in reverse order by [[bindv]].  So we have to reverse it when we
return it.

<<>>=
let hwreg_decls env = List.rev env.hwregs
@

% ------------------------------------------------------------------ 
\subsubsection{Cleaning a fat environment}
% ------------------------------------------------------------------ 

A [[Clean.env]] is created from a [[Dirty.env]] by copying values from
one to another.  The string typing discipline of {\ocaml} precludes
the use of patterns in most cases such that things must be copied
explicitly.


<<clean function>>=
let clean_scope = function
    | Dirty.Local  -> Clean.Local
    | Dirty.Global -> Clean.Global

let clean_rhint = function
    | Dirty.RReg  s -> Clean.RReg  s
    | Dirty.RHint s -> Clean.RHint s
    | Dirty.RNone   -> Clean.RNone 


let clean_reg r =
    { Clean.index = r.Dirty.index
    ; Clean.rhint = clean_rhint r.Dirty.rhint
    }

let rec clean_venv map  =
    let copy key data map = match data with
        |  (pos,scope),E.Ok(denot,ty) ->
            let denot' = match denot with
                | Dirty.Constant(v)               -> Clean.Constant(v)
                | Dirty.Label(Dirty.Proc(p))      -> Clean.Label(Clean.Proc(clean_proc p))
                | Dirty.Label(Dirty.Code)         -> Clean.Label(Clean.Code)
                | Dirty.Label(Dirty.Data)         -> Clean.Label(Clean.Data)
                | Dirty.Label(Dirty.Stack(Some n))-> Clean.Label(Clean.Stack n)
                | Dirty.Import(n)                 -> Clean.Import(n)
                | Dirty.Register(n)               -> Clean.Register(clean_reg n)
                | Dirty.Continuation              -> Clean.Continuation
                | _                               -> assert false
            in
                 StrMap.add key ((pos,clean_scope scope),(denot',ty)) map
        |  _  -> assert false
    in
        StrMap.fold copy map StrMap.empty      
<<>>=
and clean_tenv map =
    let copy key data map = match data with
        | (p,s), E.Ok(t) -> StrMap.add key ((p,clean_scope s),t) map
        | _             -> assert false
    in
        StrMap.fold copy map StrMap.empty
<<>>=
and clean_target = function
    |   { Dirty.memsize    = E.Ok(Some n)
        ; Dirty.endianness = E.Ok(Some e)
        ; Dirty.word       = E.Ok(Some w)
        ; Dirty.pointer    = E.Ok(Some p)
        ; Dirty.float      = E.Ok(Some f)
        ; Dirty.charset    = E.Ok(Some s)
        } ->
        { Clean.memsize    = n
        ; Clean.endianness = ( match e with
                             | Dirty.Little -> Clean.Little
                             | Dirty.Big    -> Clean.Big
                             )
        ; Clean.word       = w
        ; Clean.pointer    = p
        ; Clean.float      = f
        ; Clean.charset    = s
        }
    |   _ -> assert false 

<<>>=
and clean_asm asm =
    { Clean.imported = asm.Dirty.imported
    ; Clean.exported = asm.Dirty.exported
    ; Clean.nam2sym  = asm.Dirty.nam2sym
    }

<<>>=
and clean_proc = function
    |   { Dirty.env       = Some env
        ; Dirty.sdata     = Some n 
        ; Dirty.salign    = Some m 
        } ->
        { Clean.env       = clean env
        ; Clean.sdata     = n
        ; Clean.salign    = m
        }
    |   _ -> assert false 

and clean_hwregs regs =
    List.map (fun (name, hint, ty) -> (name, clean_rhint hint, ty)) regs

<<>>=     
and clean env =
    { Clean.tenv   = clean_tenv env.Dirty.tenv
    ; Clean.venv   = clean_venv env.Dirty.venv
    ; Clean.srcmap = env.Dirty.srcmap 
    ; Clean.error  = env.Dirty.error
    ; Clean.target = clean_target env.Dirty.target
    ; Clean.rindex = env.Dirty.rindex
    ; Clean.offset = env.Dirty.offset
    ; Clean.maxalign = env.Dirty.maxalign
    ; Clean.hwregs = clean_hwregs env.Dirty.hwregs
    ; Clean.asm    = clean_asm env.Dirty.asm
    }
@


