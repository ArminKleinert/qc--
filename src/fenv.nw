
\input{macros.tex}

% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{The Fat Environment}
% ------------------------------------------------------------------ 

The meaning, or denotation, of names in a {\PAL} program are recorded
in an environment.  Because only one environment is used for all
different kinds of names, it is called fat.  The fat environment not
only serves the classic symbol table purpose but also represents some
global state of the compiler.  It is used to pass around informations
between the different phases of the compiler.  In particular the fat
environment holds informations about:

\begin{itemize}
\item Values, like constants, labels for goto and data, procedures.
\item Types, as they are declared by the [[typedef]] directive.
\item Target architecture, as declared by the [[target]] directive.
\item An index counter for registers.
\item A flag that indicates a serious error.
\end{itemize}

The fat environment comes in two variants:  a \textit{dirty} and a
\textit{clean} one.  A dirty environment is built during the first
phases of compilation:  names bound in a dirty environment can be
either good or bad.  The error propagation combinators from the
\module{error} module are used to deal with good and bad values. 
After the semantics of a {\PAL} program are checked and when no errors
were found a dirty environment is known to bind only good values.  At
this point a clean environment can be generated from the dirty one. 
The clean environment is easier to deal with since it guarantees
statically that all its bound values are good.

% ------------------------------------------------------------------ 
\subsection{Interface: Clean vs.~Dirty}
% ------------------------------------------------------------------ 

A dirty and a clean environment are structurally too different for one
polymorphic implementation of an environment to provide both.  As a
consequence, two modules are provided:  [[Dirty]] and [[Clean]]. 
However, the interfaces of both modules still can be derived from a
single interface [[Env]]:

<<module type Env>>=
module type Env = sig
    type 'a info
    type 'a partial
    val  bad: unit -> 'a info

    <<signature Env>>
end
@

By defining [[info]] and [[partial]] appropriately, the interface for
the [[Dirty]] and the [[Clean]] modules can be derived.  The types
[[info]] and [[partial]] describe possibly ``bad'' or unknown values
in the the signature.

\begin{itemize}
\item An [['a info]] is a possibly erroneous value [['a]] in a dirty
      environment, but always an [['a]] in a clean environment.

\item An [['a partial]] is a possibly unavailable value [['a]] in a
      dirty environment, but always an [['a]] value in a clean
      environment.

\item The [[bad]] function creates a erroneous value of the 
      [['a info]] type.  Using this function in a clean environment causes
      is a checked compile-time error.
\end{itemize}      

The two sub-modules [[Dirty]] and [[Clean]] just differ in the meaning
of [[info]] and [[partial]].  A clean environment ensures that all
values are present and that they are good.

<<fenv.mli>>=
module StrSet: Set.S with type elt = string
module StrMap: Map.S with type key = string

<<module type Env>>

<<fenv.mli>>=
module Dirty : Env
    with type 'a info    = 'a Error.error
    with type 'a partial = 'a option

module Clean : Env
    with type 'a info    = 'a 
    with type 'a partial = 'a 

val clean: Dirty.env -> Clean.env
@

The only way to obtain a clean environment is by cleaning a dirty
environment.  However, the dirty environment must not be really dirty: 
all informations must be provided, and they must be ``good''.  Trying
to clean a dirty environment with bad values will result in a checked
run-time error.

% ------------------------------------------------------------------ 
\subsection{General Interface \texttt{Env}}
% ------------------------------------------------------------------ 

The main purpose of the fat environment is to bind values to names. 
In {\PAL} same names have the same meaning everywhere in a program,
and others may differ inside and outside of a procedure.  Example of
the former are [[target]] declarations, and bindings for types and
values for the latter; these bindings are called \emph{scoped}.  This
interface provides a fat environment [[env]], that holds all bindings,
regardless whether they are scoped or un-scoped. 

Bindings for types and values have two scopes: the global scope of the
entire compilation unit, and the scope inside of a procedure. So in
principle, the scope changes, when a procedure is entered. However,
{\PAL} has some anomalies with respect to these well known static
scoping rules: 

\begin{itemize}
\item Labels defined inside procedures have global scope: they are
      visible in the entire compilation unit.
\item Values imported inside a procedure have global scope, too.
\end{itemize}

After a procedure is left, only the global bindings are in effect. 
Since a procedure is entered many times in a multi-pass compiler it
pays off to save the bindings for a procedure instead of re-computing
them every time the procedure is entered.  To facilitate this an
[[env]] value is internally divided into two parts:  the first is a
stack of [[scope]]s for values and types, and the second holds all
other \emph{global} informations.  The bottom scope in the scope stack
contains all global name and type bindings.  When a procedure is
active all its name and type bindings are in the top-scope.  A
procedure's bindings can be saved by saving the [[top]] scope and
re-used, by [[pop]]'ing it later.

<<signature Env>>=
type env 
type scope
<<types>>

<<signature Env>>=
val empty:      Srcmap.map -> env       (* empty scope stack *)
val srcmap:     env -> Srcmap.map

val emptyscope: scope   
val top:        env -> scope            (* top empty = assert false *)
val pop:        env -> env              (* pop empty = assert false *)
val push:       env -> scope -> env
@

This sounds more complicated than it is.  Since everything is part of
an [[env]] value, it is the only value that is passed around.  Only
before entering or leaving a procedure the scope stack must be
manipulated.

\begin{itemize}
\item  The scope stack of an [[empty]] [[env]] is also empty. Thus, an
       [[emptyscope]] should be [[push]]'ed first.  An [[env]]
       includes a [[Srcmpa.map]] value, which is required to give
       source code positions (type [[Scrpmap.rgn]] stored in the
       environment a meaning.

\item  Applying [[top]] or [[pop]] to an empty stack scope will result
       in an assertion violation.
\end{itemize}

To inspect the value bindings in a (local) [[scope]], [[foldv]] is
provided:  [[foldv f s z]] applies f to all [[ventry]] values found in
scope [[s]] together with a result value of type [['a]] passed along;
[[z]] is the initial value for the result.

<<signature Env>>=
val foldv:      (string -> ventry -> 'a -> 'a) -> scope -> 'a -> 'a
@  

% ------------------------------------------------------------------ 
\subsection{Bindings for Values and Types}
% ------------------------------------------------------------------

Register, label, and procedure declarations are examples for
declarations that bind values to names.  A {\PAL} [[typedef]]
declaration binds types to names.  These declarations are scoped:  a
declaration inside a procedure can shadow a declaration of the same
name at the level of the compilation unit.  The following types
capture the structure of values in {\PAL}.

\begin{itemize}
\item A constant denotes its value directly.
\item A register can be either bound to a hardware register, or it can
      be annotated with a hint. Hints are used to determine calling
      conventions (see module \module{callconv}). Each register has an
      index that identifies it for the run-time API.
\item Labels come in different flavors:  labels in [[goto]] or inside
      data declarations are plain vanilla.  Procedures are labels in a
      clean environment that include their saved local [[scope]] and
      informations about local stack data.  
\end{itemize}

Some care must be taken when dealing with [[goto]] labels and imported
values because of {\PAL} idiosyncrasies.  Both have global scope, even
when they are defined inside a procedure.  Consequently, they are
added to the environment (and bottom scope) during the first pass,
that enters all globally bound values.  A later pass that enters only
locally visible values must ignore them. 

<<types>>=
type proc = 
    { scope:      scope partial
    }

and  reghint        = RReg  of string   (* hardware reg *)
                    | RHint of string   (* calling convention hint *)
                    | RNone             (* none of above *)
                      
and  register =     { index:        int
                    ; rhint:        reghint
                    ; loc:          Alloc.Reg.loc option
                    }
                      
and  kind           = Proc          of proc
                    | Code
                    | Data          
                    | Stack         of Rtl.loc option

and  denotation     = Constant      of Bits.bits
                    | Label         of kind
                    | Import        of string option
                    | Register      of register
                    | Continuation
@

The complete entry [[ventry]] for a value includes not only its
denotation, but also its type [[Types.ty]], and its source code
position as a [[Srcmap.rgn]] value.

<<types>>=
and  ventry         = Srcmap.rgn * (denotation * Types.ty) info
@

Bindings for types, which are also scoped, are much simpler. A
[[tentry]] for a type includes just its source code position and the
type it denotes:

<<types>>=
and  tentry         = Srcmap.rgn * Types.ty info
@


% ------------------------------------------------------------------ 
\subsection{Binding and Finding Names and Values}
% ------------------------------------------------------------------ 

The following functions bind and find names and types in the top of
the scope stack inside an environment.  The scopes inside the
environment are searched from top to bottom and the first binding
found is returned.  The exception [[Error.ErrorExn]] is raised, if no
binding can be found (applies also when the scope stack is empty). 
 
Since it is illegal to re-bind names and values in the same scope, any
attempt to do so is reported as an error to stdout.  Additionally the
existing binding is re-bound to be bad in case the environment was a
Dirty one, and the error flag (see below) is set.

The denotation of some values include optional informations that are
added by later passes, after an initial binding was entered into the
environment.  Since [[bind]] reports any re-binding as an error, a
special function [[rebindv]] is introduced for this purpose. 
[[rebindv]] introduces the new binding in the topmost scope that has a
binding for the name at hand.  So if you want to update a global
binding make sure, that this scope is at the top because otherwise it
may be shadowed by a binding in a local scope and this one would be
replaced.  If no binding for the given name is found, the environment
is returned unaltered.
 
<<signature Env>>=
val bindv           : string -> ventry  -> env -> env
val rebindv         : string -> ventry  -> env -> env
val bindt           : string -> tentry  -> env -> env
val findv           : string -> env -> ventry   (* Error.ErrorExn *)
val findt           : string -> env -> tentry   (* Error.ErrorExn *)
@

\emph{Think of algebraic rules that describe the interaction of bind
and find}.

Sometimes is is necessary to know whether a value is bound in a local
scope.  The following predicate is true, if and only if a given name
is bound in the top scope, \emph{and} the top scope is not the bottom
scope at the same time.  It is an assertion failure to supply an
unknown value.

<<signature Env>>=
val is_localv       : string -> env -> bool     (* *)
@

% ------------------------------------------------------------------ 
\subsection{Error Flag}
% ------------------------------------------------------------------ 

The fat environment holds an error flag.  Is is set at the first error
found in the static semantics of a program.  The function
[[flagError]] sets the flag in the returned environment, [[errorFlag]]
returns the flag's value in [[env]].  The [[flagError]] function obeys
to the following law:

\begin{tabular}{l}
    [[flagError (flagError env) = flagError env]]\\
    [[errorFlag (flagError empty) = true]]       \\
    [[errorFlag empty = false]]
\end{tabular}

<<signature Env>>=
val flagError       : env -> env
val errorFlag       : env -> bool
@

% ------------------------------------------------------------------ 
\subsection{Target}
% ------------------------------------------------------------------ 

The environment stores informations about the target platform.  These
data may have some defaults and is specified in a {\PAL} program by
the [[target]] declaration.  Once an information is bound for a target
all subsequent binds must provide the same information.  In case an
inconsistent update is attempted the binding becomes erroneous.  In
order to provide a meaningful error message for this case, the bind
functions receive a source code position.

\begin{quote}
    Should the error reporting be factored out by reporting
    inconsistencies with an exception?
\end{quote}

<<types>>=
and  endianness     = Big | Little

<<signature Env>>=
val bindMemsize     : Srcmap.rgn -> int        -> env -> env
val bindEndianness  : Srcmap.rgn -> endianness -> env -> env 
val bindWordsize    : Srcmap.rgn -> int        -> env -> env
val bindPointersize : Srcmap.rgn -> int        -> env -> env
val bindFloat       : Srcmap.rgn -> string     -> env -> env
val bindCharset     : Srcmap.rgn -> string     -> env -> env

val findMemsize     : env -> int        partial info 
val findEndianness  : env -> endianness partial info
val findWordsize    : env -> int        partial info
val findPointersize : env -> int        partial info
val findFloat       : env -> string     partial info
val findCharset     : env -> string     partial info
@

% ------------------------------------------------------------------ 
\subsection{Register Index}
% ------------------------------------------------------------------ 

{\PAL} uses integers to identify global and local registers during
run-time at the run-time interface.  The fat environment maintains a
counter to facilitate the assignment of an integer to a register.
The current index is returned by [[getIndex]], and the index is
advanced by [[nextIndex]]:

<<signature Env>>=
val getIndex: env -> int
val nextIndex: env -> env
@

The above functions obey to the following rules:

\begin{quote}
\begin{verbatim}
getIndex empty = 0
getIndex (nextIndex env) = (getIndex env) + 1
\end{verbatim}
\end{quote}

% ------------------------------------------------------------------ 
\subsection{Imports and Exports}
% ------------------------------------------------------------------ 

The translation process assigns certain {\PAL} \emph{names}
to assembly-level \emph{symbols}.  The relation between a name and its
assembly symbol is not straight forward, as explained in module
\module{mangle}.  In order to build a map from {\PAL} names to symbols
all imports and exports of a {\PAL} program must be registered.  This
is done with [[import]] and [[export]].  To provide meaningful error
messages, both function receive the region of the statement at hand in
the source code. 

\emph{Describe interaction with bindv}

<<signature Env>>=
val import: Srcmap.rgn -> string -> string -> env -> env (* import g as f *)
val export: Srcmap.rgn -> string -> string -> env -> env (* export f as g *)
@

The assembly level symbols imported and exported from a compilation
unit can be obtained, as well as a map from {\PAL} names to these
symbols.  The union of the imported and exported sets equals the range
of the map.

<<signature Env>>=
val imported: env -> StrSet.t
val exported: env -> StrSet.t
val nam2sym:  env -> string StrMap.t
@

% ------------------------------------------------------------------ 
\subsection{Global Registers}
% ------------------------------------------------------------------

The declaration of a global register can include a hardware register
to use.  Since the sequence of these declarations is important to
determine the assignment of register to hardware register or memory,
[[globals]] returns the (unique) names of global registers.

<<signature Env>>=
val globals : env -> string list
@


% ------------------------------------------------------------------ 
\subsection{Implementation: Large Scale Structure}
% ------------------------------------------------------------------ 

The implementation tries to exploit the commonalities between the
[[Clean]] and [[Dirty]] module by using a functor [[Env]].  The
differences factored out of [[Clean]] and [[Dirty]] are supplied as an
argument [[Arg]] of type [[Arg]].  The main part of the implementation
is thus the generic functor [[Env]] which is described in the
following section.

<<fenv.ml>>=
module E            = Error     (* handy abbreviations *)
module T            = Types
@

Name spaces are implemented as polymorphic functional maps from
[[string]] to some value.  The [[Map.Make]] functor must be provided
with the structure of the key, i.e.~the [[string]] type.  The
[[import]] and [[export]] functions build sets of symbol, so we need a
set of strings, too.

<<fenv.ml>>=
module Comparable   = struct type t=string let compare=compare end
module StrMap       = Map.Make(Comparable)
module StrSet       = Set.Make(Comparable)

@

The [[Arg]] modules captures the diverse aspects of [[Clean]] and
[[Dirty]].  Different [[Arg]] implementations are passed to functor
[[Env]] to create [[Clean]] and [[Dirty]].

<<fenv.ml>>=
module type Arg = sig
    type 'a partial
    type 'a info
    
    val good    : 'a   -> 'a info
    val asgood  : 'a info -> 'a option
    val bad     : unit -> 'a info
    val update  : 'a partial info -> 'a -> (unit -> unit) -> 'a partial info
    val default : 'a   -> 'a partial info
end
@

\begin{itemize}
    \item First of all, informations are more vaguely represented in
    [[Dirty]] than in [[Clean]]: a [[partial]] information might be
    absent in [[Dirty]], but not in [[Clean]]. And an information
    [[info]] can be marked as [[bad]] in [[Dirty]], but not in
    [[Clean]]. Functions help to create [[good]] and [[bad]] values. 

    \item The [[update x y f]] function compares a [[partial info]]
    value [[x]] with a plain one [[y]].  In case they differ, [[f]] is
    called.  This is used to implement the update of values in the
    target environment.  The [[Dirty]] module checks the new [[y]]
    value to be consistent with the old value [[x]]. 
    
    \item The default value is used to create an initial target record
    as part of a [[Dirty.empty]] and [[Clean.empty]]. In [[Dirty]]
    nothing is known about a target yet and thus all fields are
    considered as good, but unknown.

    \item The [[asgood]] function provides a way to access [[info]]
    information.  If the information is absent, [[None]] is returned. 
    In a [[Clean.env]] environment [[asgood]] always returns a
    [[Some]] value.
\end{itemize} 

Here are the two modules for the [[Clean]] and [[Dirty]] environment
which are instances of [[Env]], which basically is \emph{the}
implementation of this module.  The arguments to [[Env]] are
implementations of [[Arg]].

<<fenv.ml>>=
<<module type Env>>
module Env (Arg: Arg) = struct <<module Env>> end

<<fenv.ml>>=
module Dirty = Env (struct
    type 'a partial = 'a option
    type 'a info    = 'a Error.error
    
    let good    x   = Error.Ok(x)
    let bad     x   = Error.Error
    let asgood = function
        | Error.Ok(x) -> Some x
        | Error.Error -> None
    
    let update old new' error =
        E.sequence old
        ( function
        | Some x as old when x = new' -> Error.Ok(old)
        | Some x                      -> ( error ()
                                         ; Error.Error
                                         )
        | None                        -> Error.Ok(Some new') 
        )

    let default x = Error.Ok(None)
end)

<<fenv.ml>>=
module Clean = Env (struct
    type 'a partial             = 'a 
    type 'a info                = 'a

    let good x                  = x
    let asgood x                = Some x
    let bad  x                  = assert false
    let update old new' f       = new'
    let default x               = x
end)
@


The function [[clean]] translates a dirty environment into a clean
environment. 

<<fenv.ml>>=
<<clean function>>
@

% ------------------------------------------------------------------ 
\subsection{The Heart of the Implementation: [[Env]]}
% ------------------------------------------------------------------ 

The fat and the clean version of an environment share the same basic
implementation [[Env]] which is functorized over [[Arg]]. [[Arg]]
provides us what we need to know about good and bad values:

<<module Env>>=
type 'a partial     = 'a Arg.partial
type 'a info        = 'a Arg.info
let  bad            = Arg.bad
@

Our interfaces includes definitions for types that capture the
denotation of values and types. Of course, these types must be defined
in the implementation as well.

<<module Env>>=
<<types>>
and env            =  { scopes     :    scope list (* top = hd scopes *)
                      ; srcmap     :    Srcmap.map
                      ; error      :    bool
                      ; target     :    target
                      ; asm        :    asm
                      ; rindex     :    int   (* register index *)
                      ; globals    :    string  list  (* global   registers *)
                      ; stackdata  :    stackdata
                      }

and stackdata =       { soffset    :    int    (* current offset *)
                      ; smaxalign  :    int    (* max stackdata align constr*)
                      ; sname      :    string (* label for offset *)
                      }
@
                       

The [[target]] type captures target specific informations, like the
byteorder, or sizes words and pointers.

<<module Env>>=
and  target         = { memsize:      int        partial info
                      ; endianness:   endianness partial info
                      ; word:         int        partial info
                      ; pointer:      int        partial info
                      ; float:        string     partial info
                      ; charset:      string     partial info
                      }
@

Imports and exports are recorded (see module \module{mangle}) to build
a map from {\PAL} names to assembly symbols.  The [[asm]] type holds
two sets of assembly symbols:  [[imported]] and [[exported]], and a
map from {\PAL} names to symbols.

<<module Env>>=
and asm             = { imported:     StrSet.t
                      ; exported:     StrSet.t
                      ; nam2sym:      string StrMap.t
                      }
@

A [[scope]] is record of two maps for values and types respectively:

<<module Env>>=
and scope           = { venv:   ventry StrMap.t
                      ; tenv:   tentry StrMap.t
                      }
@

An entire environment [[env]] contains the stack of scopes and members
for all non-scoped information, like the target, imports and exports,
error flag, and so on.

% ------------------------------------------------------------------ 
\subsection{Auxiliaries}
% ------------------------------------------------------------------ 

A handy error printing function: [[r]] is a [[Srcmap.reg]] source code
position that is used to describe the place where an error is located. 

<<module Env>>=
let error r map msg = E.errorRegionPrt (map,r) msg 
@

% ------------------------------------------------------------------ 
\subsection{Creating \texttt{env} and \texttt{scope} values}
% ------------------------------------------------------------------ 

Given the stack semantics for scopes, the implementation is obvious. 
The [[Arg.default]] function returns a [[None]] value in case the
environment is [[Dirty]]; the defaults for a [[Clean]] environment
should never be used because a clean environment is obtained by
cleaning a dirty one. 

<<module Env>>=
let empty  map =  
    { scopes    = []
    ; srcmap    = map
    ; error     = false
    ; rindex    = 0
    ; globals   = []
    ; stackdata = { smaxalign  = 1
                  ; soffset    = 0
                  ; sname      = "can't happen"
                  }
    ; target    = { memsize    = Arg.default 8
                  ; endianness = Arg.default Little
                  ; word       = Arg.default 32
                  ; pointer    = Arg.default 32
                  ; float      = Arg.default "ieee754"
                  ; charset    = Arg.default "latin1"
                  }
    ; asm       = { imported   = StrSet.empty
                  ; exported   = StrSet.empty
                  ; nam2sym    = StrMap.empty
                  }
    } 
@

The implementation of the [[scope]] stack provides no surprises.

<<module Env>>=
let emptyscope          = { venv  = StrMap.empty; tenv = StrMap.empty }
let srcmap {srcmap=m}   = m

let top env = match env.scopes with
    | []    -> assert false
    | s::ss -> s

let pop env = match env.scopes with
    | []     -> assert false
    | s::ss  -> { env with scopes = ss }

let push env scope = { env with scopes = scope :: env.scopes } 
@

<<module Env>>=
let foldv f {venv=v} z = StrMap.fold f v z
@


% ------------------------------------------------------------------ 
\subsection{Binding and Finding Names and Values}
% ------------------------------------------------------------------ 
    
New Bindings are recorded in the top scope; it is a checked run-time
error if the scope stack is empty.  It is illegal in {\PAL} to re-bind
names:  if the name to be bound is found in the top scope, an error is
issued, the error flag is set, and the existing binding is re-bound to
a bad value.  

Register values that use a hardware register are
additionally recorded in the [[regdecls]] component.

<<module Env>>=
let bindv name (rgn,x as ventry) env = 
    let scope = ( match env.scopes with
                | []    -> assert false
                | s::ss -> s
                ) in
    try let (rgn',x) = StrMap.find name scope.venv in
        ( error rgn  env.srcmap ("re-declaration of value "^name)
        ; error rgn' env.srcmap ("previously declared here")
        ; let scope = 
            { scope with venv = StrMap.add name (rgn',Arg.bad()) scope.venv} 
          in
            { env with 
              scopes = scope :: List.tl env.scopes  
            ; error  = true  
            }
        )              
    with Not_found -> 
        let scope = { scope with venv = StrMap.add name ventry scope.venv} in
        let env   = { env with scopes = scope :: List.tl env.scopes } in
            ( match Arg.asgood x with
            | Some(Register _,_) when List.length env.scopes = 1 ->
                  (* this is a global register declaration *)
                  { env with globals = name :: env.globals }
            | _ -> env
            ) 

<<module Env>>=
let bindt name (rgn,x as tentry) env = 
    let scope = ( match env.scopes with
                | []    -> assert false
                | s::ss -> s
                ) in
    try let (rgn',x) = StrMap.find name scope.tenv in
        ( error rgn  env.srcmap ("re-declaration of type "^name)
        ; error rgn' env.srcmap ("previously declared here")
        ; let scope = 
            { scope with tenv = StrMap.add name (rgn',Arg.bad()) scope.tenv} 
          in
            { env with 
              scopes = scope :: List.tl env.scopes  
            ; error  = true
            }
        )              
    with Not_found -> 
        let scope = { scope with tenv = StrMap.add name tentry scope.tenv} in
        let env   = { env with scopes = scope :: List.tl env.scopes } in
            env
@

The [[find]] functions start searching in the top of the stack and
move to the bottom. The first binding found is returned, and
[[Error.ErrorExn]] raised otherwise.

<<module Env>>=
let findv name env =
    let rec loop = function
        | []    -> E.error ("unknown value: "^name)
        | s::ss -> ( try StrMap.find name s.venv with
                   | Not_found -> loop ss
                   )
    in
        loop env.scopes
<<module Env>>=
let findt name env =
    let rec loop = function
        | []    -> E.error ("unknown type: "^name)
        | s::ss -> ( try StrMap.find name s.tenv with
                   | Not_found -> loop ss
                   )
    in
        loop env.scopes
@

The [[rebindv]] function replaces the most local binding for a name. If
the name is not bound in the environment, it is returned unaltered. 

<<module Env>>=
let rebindv name x env =
    let rec loop = function
        | []    -> []
        | s::ss -> if StrMap.mem name s.venv 
                   then { s with venv = StrMap.add name x s.venv } :: ss
                   else loop ss
    in
        { env with scopes = loop env.scopes }
@

An assertion fails, if the scope stack is empty.

<<module Env>>=
let is_localv name env = 
    ( match env.scopes with
    | []    -> assert false
    | [s]   -> false
    | s::ss -> StrMap.mem name s.venv
    )
@
    

% ------------------------------------------------------------------ 
\subsection{The Error Flag}
% ------------------------------------------------------------------ 

The fat environment also holds an error flag.  Is is set at the first
error found in the static semantics of a program.  The function
[[flagError env]] sets the flag in the returned environment,
[[errorFlag]] returns the flag's value in [[env]].

<<module Env>>=
let flagError env = if env.error then env else { env with error = true }
let errorFlag env = env.error
@

% ------------------------------------------------------------------ 
\subsection{The \texttt{target} architecture}
% ------------------------------------------------------------------ 

The [[target]] directive in {\PAL} describes the target architecture
an program is intended for. The information can be distributed over
the program and can declare the same fact several times.  However, the
informations about the target architecture must be consistent. 

The implementation maintains a record of type [[target]] for the target
informations where each information is captured by an [[option]] type. 
Once an information has been supplied the [[bind]] functions enforce
that only the same fact can be entered again.  When an inconsistent
update is attempted the target information is bound to [[Error]] and an
error message is issued.

The [[update]] function computes the value inside the target record
based on an existing value and a new one. In case the target record
was un-set the new value is returned. Otherwise the new value must
match the existing one, or an inconsistency was found. In the latter
case [[Error]] is returned.

<<module Env>>=
let update_int r map old i errmsg =
    if   i > 0 
    then Arg.update old i errmsg
    else ( error r map "positive number expected"
         ; Arg.bad ()
         ) 

<<module Env>>=
let bindMemsize r n env =
    let f ()     = error r env.srcmap "inconsistent memsize specification" in
    let memsize' = update_int r env.srcmap env.target.memsize n f          in
    let target'  = { env.target with memsize = memsize' }                  in
        { env with  target = target' }

<<module Env>>=
let bindWordsize r n env =
    let f ()     = error r env.srcmap "inconsistent word size specification" in
    let word'    = update_int r env.srcmap env.target.word n f               in
    let target'  = { env.target with word = word' }                          in
        { env with  target = target' }

let bindPointersize r n env =
    let f ()     = error r env.srcmap "inconsistent word size specification" in
    let pointer' = update_int r env.srcmap env.target.pointer n f            in
    let target'  = { env.target with pointer = pointer' }                    in
        { env with  target = target' }

<<module Env>>=
let bindEndianness r e env =
    let f ()     = error r env.srcmap "inconsistent byteorder specification" in
    let e'       = Arg.update env.target.endianness e f                      in
    let target'  = { env.target with endianness = e' }                       in
        { env with target = target' }
        
<<module Env>>=
let bindFloat r fp env =
    let f ()     = error r env.srcmap "inconsistent floating point specification" in
    let fp'      = Arg.update env.target.float fp f               in
    let target'  = { env.target with float = fp' }                in
        { env with target = target' }

<<module Env>>=
let bindCharset r cs env =
    let f ()     = error r env.srcmap "inconsistent charset specification" in
    let cs'      = Arg.update env.target.charset cs f                      in
    let target'  = { env.target with charset = cs' }                       in
        { env with target = target' }

<<module Env>>=
let findMemsize     env = env.target.memsize
let findEndianness  env = env.target.endianness
let findPointersize env = env.target.pointer 
let findWordsize    env = env.target.word    
let findFloat       env = env.target.float
let findCharset     env = env.target.charset

@   

% ------------------------------------------------------------------ 
\subsection{Imports and Exports}
% ------------------------------------------------------------------ 

The fat environment maintains the set of imported and exported
assembly symbols and a map, that associates an imported or exported
{\PAL} name with it symbol. No assembly symbol may be imported and
exported at the same time. If such a case is detected, an error
message is issued. Details about the connection between {\PAL} names
and assembly symbols can be found in \module{mangle}.

<<module Env>>=
let import r sym name env =
    if StrSet.mem sym env.asm.exported 
    then ( error r env.srcmap ("import of an exported name: "^name)
         ; flagError env
         )
    else let asm = { exported = env.asm.exported
                   ; imported = StrSet.add sym env.asm.imported
                   ; nam2sym  = StrMap.add name sym env.asm.nam2sym
                   }
         in
            { env with asm = asm }

let export r name sym env =
    if StrSet.mem sym env.asm.imported 
    then ( error r env.srcmap ("export of an imported name: "^name)
         ; flagError env
         )
    else let asm = { imported = env.asm.imported
                   ; exported = StrSet.add sym env.asm.exported
                   ; nam2sym  = StrMap.add name sym env.asm.nam2sym
                   }
         in
            { env with asm = asm }
@

<<module Env>>=
let imported env = env.asm.imported
let exported env = env.asm.exported
let nam2sym  env = env.asm.nam2sym
@


% ------------------------------------------------------------------ 
\subsection{Register Index}
% ------------------------------------------------------------------ 

No surprises here.

<<module Env>>=
let nextIndex  env   = { env with rindex = env.rindex + 1}
let getIndex   env   = env.rindex
@

% ------------------------------------------------------------------ 
\subsubsection{Hardware Registers}
% ------------------------------------------------------------------ 

The list of global register declarations is built in reverse order by
[[bindv]].  So we have to reverse it when we return it.

<<module Env>>=
let globals env = List.rev env.globals
@

% ------------------------------------------------------------------ 
\subsection{Cleaning a fat environment}
% ------------------------------------------------------------------ 

A [[Clean.env]] is created from a [[Dirty.env]] by copying values from
one to another.  The string typing discipline of {\ocaml} precludes
the use of patterns in most cases such that values must be copied
explicitly.

<<clean function>>=
let clean_rhint = function
    | Dirty.RReg  s -> Clean.RReg  s
    | Dirty.RHint s -> Clean.RHint s
    | Dirty.RNone   -> Clean.RNone 


let clean_reg r =
    { Clean.index = r.Dirty.index
    ; Clean.rhint = clean_rhint r.Dirty.rhint
    ; Clean.loc   = r.Dirty.loc
    }

let rec clean_venv map  =
    let copy key data map = match data with
        |  pos,E.Ok(denot,ty) ->
            let denot' = match denot with
                | Dirty.Constant(v)               -> Clean.Constant(v)
                | Dirty.Label(Dirty.Proc(p))      -> Clean.Label(Clean.Proc(clean_proc p))
                | Dirty.Label(Dirty.Code)         -> Clean.Label(Clean.Code)
                | Dirty.Label(Dirty.Data  )       -> Clean.Label(Clean.Data  )
                | Dirty.Label(Dirty.Stack x)      -> Clean.Label(Clean.Stack x)
                | Dirty.Import(n)                 -> Clean.Import(n)
                | Dirty.Register(n)               -> Clean.Register(clean_reg n)
                | Dirty.Continuation              -> Clean.Continuation
            in
                 StrMap.add key (pos,(denot',ty)) map
        |  _  -> assert false
    in
        StrMap.fold copy map StrMap.empty      
<<clean function>>=
and clean_tenv map =
    let copy key data map = match data with
        | p, E.Ok(t) -> StrMap.add key (p,t) map
        | _          -> assert false
    in
        StrMap.fold copy map StrMap.empty
<<clean function>>=
and clean_target = function
    |   { Dirty.memsize    = E.Ok(Some n)
        ; Dirty.endianness = E.Ok(Some e)
        ; Dirty.word       = E.Ok(Some w)
        ; Dirty.pointer    = E.Ok(Some p)
        ; Dirty.float      = E.Ok(Some f)
        ; Dirty.charset    = E.Ok(Some s)
        } ->
        { Clean.memsize    = n
        ; Clean.endianness = ( match e with
                             | Dirty.Little -> Clean.Little
                             | Dirty.Big    -> Clean.Big
                             )
        ; Clean.word       = w
        ; Clean.pointer    = p
        ; Clean.float      = f
        ; Clean.charset    = s
        }
    |   _ -> assert false 

<<clean function>>=
and clean_asm asm =
    { Clean.imported = asm.Dirty.imported
    ; Clean.exported = asm.Dirty.exported
    ; Clean.nam2sym  = asm.Dirty.nam2sym
    }

<<clean function>>=
and clean_scope { Dirty.venv = v; Dirty.tenv = t } =
    { Clean.tenv = clean_tenv t
    ; Clean.venv = clean_venv v
    }
    
<<clean function>>=
and clean_proc x = match x with
    |   { Dirty.scope     = Some s
        } ->
        { Clean.scope     = clean_scope s
        }
    |   _ -> assert false 

and clean_stackdata sd =
    { Clean.sname     = sd.Dirty.sname
    ; Clean.soffset   = sd.Dirty.soffset
    ; Clean.smaxalign = sd.Dirty.smaxalign
    } 

<<clean function>>=
and clean env =
    { Clean.scopes    = List.map clean_scope env.Dirty.scopes
    ; Clean.srcmap    = env.Dirty.srcmap 
    ; Clean.error     = env.Dirty.error
    ; Clean.target    = clean_target env.Dirty.target
    ; Clean.rindex    = env.Dirty.rindex
    ; Clean.stackdata = clean_stackdata env.Dirty.stackdata
    ; Clean.globals   = env.Dirty.globals
    ; Clean.asm       = clean_asm env.Dirty.asm
    }
@


