% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

\ifx\ocaml\undefined
    \newcommand{\ocaml}{{\small OCAML}}
    \newcommand{\asdl}{{\small ASDL}}
    \newcommand{\C}{{\small C--}}
    \let\PAL\C
    \newcommand{\rtl}{{\small RTL}}
\fi

% ------------------------------------------------------------------ 
\section{The Fat Environment}
% ------------------------------------------------------------------ 

The meaning, or denotation, of names in a {\PAL} program are recorded
in one environment.  Because only one environment is used for all
different kinds of names it is called fat.  In particular the fat
environment holds informations about:

\begin{itemize}
\item Values, like constants, labels for goto and data, procedures.
\item Types, as they are declared by the [[typedef]] directive.
\item Target architecture, as declared by the [[target]] directive.
\item Source code positions, as recored by a [[Srcmap.map]].
\end{itemize}

The fat environment comes in two variants:  a \textit{dirty} and a
\textit{clean} one.  A dirty environment is built during the first
phases of compilation:  names bound in a dirty environment can be
either good or bad.  The error propagation combinators from the
[[Error]] module are used to deal with good and bad values.  After the
semantics of a {\PAL} program are checked and when no errors were
found a dirty environment is known to bind only good values.  At this
point a clean environment can be generated from the dirty one.  The
clean environment is easier to deal with since it guarantees
statically that all its bound values are good.
  
% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The clean interface is a super-type of the dirty interface:  using the
clean interface an environment can only be queried but it can not be
manipulated.  This interface provides less options than the interface
to a dirty environment that can both query and manipulate an
environment.

The dirty and the clean environment are modeled as sub-modules
[[Dirty]] and [[Clean]] respectively.  Their signatures share a common
part which is factored out.


<<fenv.mli>>=
<<shared types>>

module Dirty : sig
    <<signature Dirty>>
end

module Clean : sig
    <<signature Clean>>
end
@

The main purpose of a fat environment is to bind names to [[value]]s
and types [[ty]].  Each binding has attributes [[attr]] that tell
about its [[scope]] and the location of its declaration in the source
code. {\PAL} has only two scopes: the top level and section level
constitutes the [[Global]] scope, a procedure a [[Local]] level. 

<<shared types>>=
type value          = Value.value
type ty             = Types.ty
type scope          = Global | Local
type attr           = Srcmap.reg * scope
type endianness     = Big | Little
type memsize        = int
@            

% ------------------------------------------------------------------ 
\subsection{Interface to [[Dirty]]}
% ------------------------------------------------------------------ 

Of course, we have a type [[env]] for a fat environment. 
Implementation details are hidden such that we can make it fatter when
we have to.

<<signature Dirty>>=
type env
@

A [[value]] comes in different flavors -- the [[denotation]] of a name
tells us the details.  Different [[kind]] of labels are subsumed under
one [[Label]] constructor.  A procedure entry can optionally hold the
environment for its local scope.

<<>>=
type kind           = Proc  of env option
                    | Code
                    | Data
                    | Stack

type denotation     = Constant of value
                    | Label    of kind
                    | Import
                    | Register
                    | Continuation
@

An entry for a value is a [[ventry]], an entry for a type a
[[tentry]].  The type constructor [[e]] wraps an entry in the dirty
variant of an environment and is the identity in case of a clean
environment.

<<>>=        
type ventry         = (denotation * ty) Error.error
type tentry         = ty                Error.error
@

% ------------------------------------------------------------------ 
\subsubsection{Type and Value Bindings}
% ------------------------------------------------------------------ 

Here are the functions that create and manipulate an environment. 

\begin{itemize}

\item An environment is created from an [[x]] value where the type
      [[x]] is different for a clean and dirty environment.

\item Values are bound by [[bindv]] and can be re-bound be
      [[rebindv]].  re-binding a value does not change its attributes
      [[attr]].

\item Types are bound by [[bindt]].

\item Values and types are looked up in an environment by [[findv]]
      and [[findt]] respectively. The prime variants [[findv']] and
      [[findt'']] come in handy when the attributes are of no interest.

\item An environment holds a source map [[Srcmap.map]] that translates
      source code positions as they are stored in the abstract syntax
      into meaningful file, line, column triples.  It can be accessed
      by [[srcmap]]. 

\end{itemize}

<<>>=
val create          : Srcmap.map -> env
val bindv           : string -> attr  -> ventry  -> env -> env
val rebindv         : string ->          ventry  -> env -> env
val bindt           : string -> attr  -> tentry  -> env -> env
val findv           : string -> env -> scope * ventry
val findt           : string -> env -> scope * tentry
val findv'          : string -> env -> ventry
val findt'          : string -> env -> tentry
val srcmap          : env -> Srcmap.map
@

% ------------------------------------------------------------------ 
\subsubsection{Target}
% ------------------------------------------------------------------ 

The environment stores informations about the target platform. These
data may have some defaults and is specified in a {\PAL} program by
the [[target]] declaration. Currently [[target memsize]] and [[target
byteorder]] are accessible. The type constructor [[e]] is again used
to define different types for the dirty and the clean case.

<<>>=
val bindMemsize     : Srcmap.reg -> memsize    -> env -> env
val bindEndianness  : Srcmap.reg -> endianness -> env -> env 
val findMemsize     : env -> memsize    option Error.error
val findEndianness  : env -> endianness option Error.error
@

% ------------------------------------------------------------------ 
\subsubsection{Error Flag}
% ------------------------------------------------------------------ 

The fat environment also holds an error flag.  Is is set at the first
error found in the static semantics of a program.  The function
[[flagError env]] sets the flag in the returned environment,
[[errorFlag]] returns the flag's value in [[env]]. The [[flagError]]
function obeys to the following law:

$$[[flagError (flagError env) = flagError env]]$$

<<>>=
val flagError       : env -> env
val errorFlag       : env -> bool
@

% ------------------------------------------------------------------ 
\subsection{Interface to [[Clean]]}
% ------------------------------------------------------------------ 

The [[Clean]] interface is roughly a super-type of the [[Dirty]]
interface.  However, I was not able to express this at the level of
{\ocaml} because of the subtle differences in the inner parts the two
interfaces.  The main difference is that bindings do not use the
[[Error.error]] type and so bound values are always good.  A clean
environment is created from a dirty environment and can't be
manipulated, only queried.

<<signature Clean>>=
type kind           = Proc  of env 
                    | Code
                    | Data
                    | Stack

and  denotation     = Constant of value
                    | Label    of kind
                    | Import
                    | Register
                    | Continuation
and  env
and  ventry         = (denotation * ty)
and  tentry         = ty 
       
val create          : Dirty.env -> env
val findv           : string -> env -> scope * ventry
val findt           : string -> env -> scope * tentry
val findv'          : string -> env -> ventry
val findt'          : string -> env -> tentry
val srcmap          : env -> Srcmap.map

val findMemsize     : env -> memsize    
val findEndianness  : env -> endianness 
@


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<fenv.ml>>=
module E = Error
<<shared types>>
<<misc>>
@

Name spaces are implemented as polymorphic functional maps from
[[string]] to some value.  The [[Map.Make]] functor must be provided
with the structure of the key, i.e.~the [[string]] type.

<<>>=
module Comparable   = struct type t=string let compare=compare end
module StrMap       = Map.Make(Comparable)
module Dirty        = struct <<module Dirty>> end
module Clean        = struct <<module Clean>> end
@

A handy error printing function: [[r]] is a [[Srcmap.reg]] source code
position that is used to describe the place where the error is located. 

<<misc>>=
let error r map msg = E.errorRegionPrt (map,r) msg 
@

% ------------------------------------------------------------------ 
\subsection{Implementation of [[Dirty]]}
% ------------------------------------------------------------------ 

First we have to provide the type declarations. This includes the
implementation for the [[env]] type.

<<module Dirty>>=
type kind           = Proc  of env option
                    | Code
                    | Data
                    | Stack

and  denotation     = Constant of value
                    | Label    of kind
                    | Import
                    | Register
                    | Continuation

and  ventry         = (denotation * ty) Error.error
and  tentry         = ty Error.error
@

Bindings for value and types are stored in a string-map [[StrMap]]. 
Each entry consists of attributes [[attr]] for the source code
location and scope of an entry and detailed informations about the
denotation of the bound name.

<<>>=
and  tenv           = (attr * tentry) StrMap.t
and  venv           = (attr * ventry) StrMap.t
<<>>=
and  target         = { memsize:      int        option E.error
                      ; endianness:   endianness option E.error
                      ; word:         Types.ty   option E.error
                      ; code:         Types.ty   option E.error
                      ; data:         Types.ty   option E.error
                      ; float:        string     option E.error
                      ; charset:      string     option E.error
                      }
@

An [[env]] is a record that holds maps for types and values. The
target description is implemented as a record because the values bound
are not uniform.

<<>>=
and   env           = { tenv   :      tenv
                      ; venv   :      venv
                      ; target :      target
                      ; srcmap :      Srcmap.map
                      ; error  :      bool
                      }    
@

% ------------------------------------------------------------------ 
\subsubsection{Values}
% ------------------------------------------------------------------ 

The fat environment holds the source map for the program being
compiled. It is required to translate the annotations in the abstract
syntax into meaningful file, line, column notation.

<<>>=
let create map      = { tenv   = StrMap.empty
                      ; venv   = StrMap.empty
                      ; target = { memsize    = E.Ok(None)
                                 ; endianness = E.Ok(None)
                                 ; word       = E.Ok(None)
                                 ; code       = E.Ok(None)
                                 ; data       = E.Ok(None)
                                 ; float      = E.Ok(None)
                                 ; charset    = E.Ok(None)
                                 }
                      ; srcmap = map
                      ; error  = false
                      }
@

The fat environment also holds an error flag.  Is is set at the first
error found in the static semantics of a program.  The function
[[flagError env]] sets the flag in the returned environment,
[[errorFlag]] returns the flag's value in [[env]].

<<>>=
let srcmap env    = env.srcmap
let flagError env = if env.error then env else { env with error = true }
let errorFlag env = env.error
@

When a name is re-declared we issue two error messages:  the first
describes the actual location [[reg]] where the problem is detected,
and the second the location of the declaration that clashes.  This one
is also re-bound to [[Error]] to flag the problem.

<<>>=
let bindv name (reg,scope as attr) x env =
    let add name x env = {env with venv = StrMap.add name x env.venv} in
    try 
        let (reg',scope' as attr'),_ = StrMap.find name env.venv in
        if scope' = scope then
            ( error reg  env.srcmap ("re-declaration of value "^name)
            ; error reg' env.srcmap ("previously declared here")
            ; add name (attr',E.Error) (flagError env)
            )
        else
            add name (attr,x) env
    with
        Not_found -> add name (attr,x) env

<<>>=
let bindt name (reg,scope as attr) x env =
    let add name x env = {env with tenv = StrMap.add name x env.tenv} in
    try 
        let (reg',scope' as attr'),_ = StrMap.find name env.tenv in
        if scope' = scope then
            ( error reg  env.srcmap ("re-declaration of type "^name)
            ; error reg' env.srcmap ("previously declared here")
            ; add name (attr',E.Error) (flagError env) 
            )
        else
            add name (attr,x) env
    with
        Not_found -> add name (attr,x) env
@

The following function [[rebindv name x env]] re-binds [[name]] to
[[x]]. Since this is only intended to update the informations for an
existing [[name]], [[name]] must be bound in [[env]] as a value. The
scope and source code location of the existing binding is re-used for
the new binding.

<<>>=
let rebindv name x env =
    try 
        let attr,_ = StrMap.find name env.venv in
            { env with venv = StrMap.add name (attr,x) env.venv }
    with
        Not_found -> assert false
@

The functions to lookup a value [[findv]] and a type [[findt]] raise
an [[E.Error]] exception in case the name can not be found.

<<>>=
let findv name env =
    try
        let (_,scope),x = StrMap.find name env.venv
        in 
            scope,x
    with 
        Not_found -> E.error ("unknown value: "^name)

<<>>=
let findt name env =
    try
        let (_,scope),x = StrMap.find name env.tenv
        in
            scope,x
    with
        Not_found -> E.error ("unknown type: "^name)
@

The following primed functions return just the entry for a name
without its attributes.  This is a special case of the functions above
and only for convenience.

<<>>=
let findv' name env = snd (findv name env)
let findt' name env = snd (findt name env)
@

The [[target]] directive in {\PAL} describes the target architecture
an program is intended for. The information can be distributed over
the program and can declare the same fact several times.  However, the
informations about the target architecture must be consistent. 

The implementation maintains a record of type [[target]] for the target
informations where each information is captured by an [[option]] type. 
Once an information has been supplied the [[bind]] functions enforce
that only the same fact can be entered again.  When an inconsistent
update is attempted the target information is bound to [[Error]] and an
error message is issued.

The [[update]] function computes the value inside the target record
based on an existing value and a new one. In case the target record
was un-set the new value is returned. Otherwise the new value must
match the existing one, or an inconsistency was found. In the latter
case [[Error]] is returned.

<<>>=
let update r env name old new' =
        E.sequence old
        ( function
        | Some x as old when x = new' -> E.Ok(old) (* consistent   *)
        | Some x               -> 
            ( error r env.srcmap 
                    ("inconsistent target specification for "^name)
            ; E.Error                              (* inconsistent *)
            )
        | None                        -> E.Ok(Some new') (* set *)
        ) 
    

<<>>=
let bindMemsize r n env =
    let memsize' = update r env "memsize" env.target.memsize n in
    let target'  = { env.target with memsize = memsize' }      in
        { env with  target = target' }

<<>>=
let bindEndianness r e env =
    let e'       = update r env "endianness" env.target.endianness e in
    let target'  = { env.target with endianness = e' }               in
        { env with target = target' }
        

<<>>=
let findMemsize    env = env.target.memsize
let findEndianness env = env.target.endianness
@   

% ------------------------------------------------------------------ 
\subsection{Implementation of [[Clean]]}
% ------------------------------------------------------------------ 

Again, we have to provide the type declarations for this specific
variant of a fat environment. 

<<module Clean>>=
type kind           = Proc  of env 
                    | Code
                    | Data
                    | Stack

and  denotation     = Constant of value
                    | Label    of kind
                    | Import
                    | Register
                    | Continuation

and  ventry         = (denotation * ty) 
and  tentry         = ty 

<<>>=
and  tenv           = (attr * tentry) StrMap.t
and  venv           = (attr * ventry) StrMap.t
<<>>=
and  target         = { memsize:      int        
                      ; endianness:   endianness 
                      ; word:         Types.ty   
                      ; code:         Types.ty   
                      ; data:         Types.ty   
                      ; float:        string     
                      ; charset:      string     
                      }
@

A [[Clean.env]] no longer contains an [[error]] component.

<<>>=
and   env           = { tenv   :      tenv
                      ; venv   :      venv
                      ; target :      target
                      ; srcmap :      Srcmap.map
                      }    
@

% ------------------------------------------------------------------ 
\subsubsection{Values}
% ------------------------------------------------------------------ 

A [[Clean.env]] is created from a [[Dirty.env]] by copying values from
one to another. The string typing discipline of {\ocaml} precludes the
use of patterns in most cases.

<<>>=
let rec copy_venv map  =
    let copy key data map = match data with
        |  attr,E.Ok(denot,ty) ->
            let denot' = match denot with
                | Dirty.Constant(v)               -> Constant(v)
                | Dirty.Label(Dirty.Proc(Some e)) -> Label(Proc(create e))
                | Dirty.Label(Dirty.Code)         -> Label(Code)
                | Dirty.Label(Dirty.Data)         -> Label(Data)
                | Dirty.Label(Dirty.Stack)        -> Label(Stack)
                | Dirty.Import                    -> Import
                | Dirty.Register                  -> Register
                | Dirty.Continuation              -> Continuation
                | _                               -> assert false
            in
                StrMap.add key (attr,(denot',ty)) map
        |  _  -> assert false
    in
        StrMap.fold copy map StrMap.empty      
<<>>=
and copy_tenv (map:Dirty.tenv) =
    let copy key data map = match data with
        | attr, E.Ok(t) -> StrMap.add key (attr,t) map
        | _             -> assert false
    in
        StrMap.fold copy map StrMap.empty

<<>>=
and copy_target = function
    |   { Dirty.memsize    = E.Ok(Some n)
        ; Dirty.endianness = E.Ok(Some e)
        ; Dirty.word       = E.Ok(Some w)
        ; Dirty.data       = E.Ok(Some d)
        ; Dirty.code       = E.Ok(Some c)
        ; Dirty.float      = E.Ok(Some f)
        ; Dirty.charset    = E.Ok(Some s)
        } ->
        { memsize    = n
        ; endianness = e
        ; word       = w
        ; data       = d
        ; float      = f
        ; code       = c
        ; charset    = s
        }
    |   _ -> assert false 

and create (env:Dirty.env) =
    { tenv   = copy_tenv env.Dirty.tenv
    ; venv   = copy_venv env.Dirty.venv
    ; target = copy_target env.Dirty.target
    ; srcmap = env.Dirty.srcmap 
    }
@

The functions to access a [[Clean.env]] are straight forward to
implement. Maybe the [[Not_found]] exceptions should be turned into
assertion violations because nobody should ever ask for an unknown
name in the later phases of the compiler.

<<>>=
let findv name env =
    try
        let (_,scope),x = StrMap.find name env.venv
        in 
            scope,x
    with 
        Not_found -> E.error ("unknown value: "^name)

<<>>=
let findt name env =
    try
        let (_,scope),x = StrMap.find name env.tenv
        in
            scope,x
    with
        Not_found -> E.error ("unknown type: "^name)
@

<<>>=
let srcmap env          = env.srcmap
let findv' name env     = snd (findv name env)
let findt' name env     = snd (findt name env)
let findMemsize    env  = env.target.memsize
let findEndianness env  = env.target.endianness
@   
@
