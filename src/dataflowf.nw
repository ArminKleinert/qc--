% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Support for forward dataflow problems}


A dataflow pass is based on a single dataflow fact of type~[['a]].
Values of type~[['a]] should form a lattice.
The dataflow engine uses the lattice structure to compute a least
solution to a set of dataflow equations.
The engine works by starting at the bottom and iterating to a fixed
point, so we require the
bottom element, a join (least upper bound) operation, and a comparison
to find out if a value has changed (grown).
<<exported types>>=
type 'a fact = 'a Dataflowp.fact = {
  fact_name : string;                     (* documentation *)
  init_info : 'a;                         (* lattice bottom element *)
  add_info  : 'a -> 'a -> 'a;             (* lattice join (least upper bound) *)
  changed   : old:'a -> new':'a -> bool;  (* is new one bigger? *)
  prop      : 'a Unique.Prop.t;           (* access to mutable state by uid *)
}
@ Finally, we require a way to store dataflow facts in global mutable
state, associated with unique IDs.  This capability is provided by the
[[prop]] field.
@
The computation of a fact is the basis of a dataflow pass.
A~computation takes not one but two type parameters:
\begin{itemize}
\item
Type parameter [['i]] is an input, from which it should be possible to
derived a dataflow fact of interest.
For example, [['i]] might be equal to a fact, or it might be a tuple
of which one element is a fact.
\item
Type parameter [['o]] is an output.
\end{itemize}
<<exported types>>=
type 'a edge_fact_setter = (Zipcfg.uid -> 'a -> unit) -> unit
type 'a answer = Dataflow of 'a | Rewrite of Zipcfg.graph

type ('i, 'om, 'ol) computation =
 { name       : string;
   middle_out : 'i -> Zipcfg.Rep.middle -> 'om;
   last_outs  : 'i -> Zipcfg.Rep.last -> 'ol;
 } 
@ 
From these elements we build several kinds of passes:
\begin{itemize}
\item
A pure analysis computes a fact, using that fact as input and
output.
\item
A~pure transformation computes no facts but only changes the graph.
\item
A fully general pass both computes a fact and rewrites the graph.
\end{itemize}
<<exported types>>=
type 'a analysis       = 'a fact * ('a, 'a, 'a edge_fact_setter) computation
type 'a pass           = 'a fact * ('a, 'a answer, 'a edge_fact_setter answer) computation
type 'a transformation = ('a, Zipcfg.graph option, Zipcfg.graph option) computation
@ Still to come: composition operators.
@
WE NEED TO TRACK THINGS TO DISCOVER WHETHER THE GRAPH HAS CHANGED AS A
RESULT OF RUNNING A PASS.
@
<<dataflowf.mli>>=
<<exported types>>
<<declarations of exported values>>
@ 
\paragraph{Analyses (the dataflow engine)}
The analysis function sets properties on unique IDs.
<<declarations of exported values>>=
val forward_anal : 'a analysis -> entry_fact:'a -> Zipcfg.graph -> unit
@ The rewrite pass sets properties and also rewrites the graph.
The Boolean result tells if the graph changed.
<<declarations of exported values>>=
val forward_rewrite : 'a pass -> entry_fact:'a -> Zipcfg.graph -> Zipcfg.graph * bool
@ If the graph is already solved, we can take a short cut.
<<declarations of exported values>>=
val forward_rewrite_solved :
  'a pass -> entry_fact:'a -> Zipcfg.graph -> Zipcfg.graph * bool
@ 
\paragraph{Composition operators}
Here we will make new passes from old ones.

We can make an analysis pass, or we can 
 combine a related analysis and transformation into a full pass.
<<declarations of exported values>>=
val anal : 'a analysis -> 'a pass
val a_t  : 'a analysis -> 'a transformation -> 'a pass
@ 
Diagnostic help:
<<declarations of exported values>>=
val debug : ('a -> string) -> 'a pass -> 'a pass
@
\section{Implementation}

<<dataflowf.ml>>=
module G  = Zipcfg
module GR = Zipcfg.Rep
module P  = Unique.Prop
module UA = Unique.Array
let impossf fmt = Printf.kprintf Impossible.impossible fmt

<<exported types>>
<<utilities>>
<<definitions of exported functions>>
@ 
In a backward problem, we compute \emph{in} facts from \emph{out}
facts.
The analysis gives us [[last_in]], [[middle_in]], and [[first_in]],
each of which computes an \emph{in} fact for one kind of node.
We provide [[head_in]], which computes the \emph{in} fact for a first
node followed by zero or more middle nodes.

We don't compute and return the \emph{in} fact for block; instead, we
use [[P.set]] to attach that fact to the block's unique~ID.
We iterate until no more facts have changed.
<<definitions of exported functions>>=
let forward_anal (fact, comp) ~entry_fact graph =
  let changed = ref false in
  let update u a =
    let old_a = P.get fact.prop u in
    let new_a = fact.add_info a old_a in
    if fact.changed ~old:old_a ~new':new_a then
      begin
        Debug.eprintf "dataflow" "Dataflow fact changed at unknown uid\n";
        P.set fact.prop u new_a;
        changed := true
      end in
  let set_successor_facts b =
    let rec forward in' t = match t with
    | GR.Tail (m, t) -> forward (comp.middle_out in' m) t
    | GR.Last l -> comp.last_outs in' l update in
    let f, t = b in
    let blockname = match f with GR.Entry -> "<entry>" | GR.Label ((_, l), _, _) -> l in
    Debug.eprintf "dataflow" "Setting successor fact of block %s\n" blockname;
    forward (P.get fact.prop (GR.fid f)) t in

  (* get blocks, initialize, and iterate to fixed point *)
  let blocks = G.postorder_dfs graph in
  let init () = 
    List.iter (fun b -> P.set fact.prop (GR.id b) fact.init_info) blocks;
    P.set fact.prop GR.entry_uid entry_fact in
  let rec iterate n =
    let () = changed := false in
    let () = List.iter set_successor_facts blocks in
    if !changed then
      if n < 1000 then iterate (n + 1)
      else impossf "%s didn't converge in %n iterations" comp.name n
    else
      Debug.eprintf comp.name "%s converged in %d iterations\n" comp.name n in
  init();
  iterate 1
@ 
In the general case we solve a graph in the context of a larger subgraph.
To do this, we need a locally modified computation that allows an
``exit fact'' to flow out of the exit node.
<<utilities>>=
let comp_with_exit comp exit_fact_ref =
  let last_outs in' l = match l with
  | GR.Exit -> Dataflow (fun set -> exit_fact_ref := in')
  | _ -> comp.last_outs in' l in
  { comp with last_outs = last_outs } 
@ 
Given this function, we can now solve a graph simply by doing a
backward analysis on the modified computation.
<<definitions of exported functions>>=
let rec solve_graph fact comp in_fact graph =
  let exit_fact_ref = ref fact.init_info in
  general_forward fact (comp_with_exit comp exit_fact_ref) graph in_fact;
  !exit_fact_ref
and general_forward fact comp graph entry_fact =
  let changed = ref false in
  let update u a =
    let old_a = P.get fact.prop u in
    let new_a = fact.add_info a old_a in
    if fact.changed ~old:old_a ~new':new_a then
      begin
        Debug.eprintf "dataflow" "Dataflow fact changed at unknown uid\n";
        P.set fact.prop u new_a;
        changed := true
      end in
  let set_successor_facts b =
    let rec set_tail_facts in' t = match t with
      | GR.Tail (m, t) ->
          (Debug.eprintf "dataflow" "Solving middle node %s\n"
             (Rtlutil.ToString.rtl (GR.mid_instr m));
           match comp.middle_out in' m with
           | Dataflow a -> set_tail_facts a t
           | Rewrite g -> set_tail_facts (solve_graph fact comp in' g) t)
      | GR.Last l -> 
          Debug.eprintf "dataflow" "Solving last node %s\n"
             (Rtlutil.ToString.rtl (GR.last_instr l));
          match comp.last_outs in' l with
          | Dataflow setter -> setter update
          | Rewrite g -> ignore (solve_graph fact comp in' g) in
    let f, t = b in
    let in' = match f with
    | GR.Entry -> entry_fact
    | GR.Label ((u, l), _, _) ->
        Debug.eprintf "dataflow" "Solving block with label: %s\n" l;
        P.get fact.prop u in
    set_tail_facts in' t in
  let blocks = G.postorder_dfs graph in
  let init () = List.iter (fun b -> P.set fact.prop (GR.id b) fact.init_info) blocks in
  let rec iterate n =
    let () = changed := false in
    let () = List.iter set_successor_facts blocks in
    if !changed then
      if n < 1000 then iterate (n + 1)
      else impossf "%s didn't converge in %n iterations" comp.name n
    else
      Debug.eprintf comp.name "%s converged in %d iterations\n" comp.name n in
  init();
  iterate 1
@
We solve and rewrite in two passes: the first pass iterates to a fixed
point to reach a dataflow solution, and the second pass uses that
solution to rewrite the graph.

The key job is done by [[propagate]], which propagates a fact of type~[['a]]
between a head and tail.
The tail is in final form; the head is still to be rewritten.
<<definitions of exported functions>>=
let rec solve_and_rewrite fact comp in_fact graph changed =
  solve_graph fact comp in_fact graph;                              (* pass 1 *)
  let exit_ref = ref fact.init_info in
  let gc = forward_rewrite fact (comp_with_exit comp exit_ref) in_fact graph changed in
  !exit_ref, gc
and forward_rewrite (fact : 'a fact) comp entry_fact graph changed =
  let rec rewrite_blocks rewritten fresh changed : G.graph * bool = match fresh with
    | []      -> G.of_block_list rewritten, changed
    | b :: bs ->
        let rec rewrite_next_block () =
          let f, t = b in
          let in' = match f with
            | GR.Entry -> entry_fact
            | GR.Label ((u, _), _, _) -> P.get fact.prop u in
          propagate (GR.First f) in' t rewritten changed
        and propagate :
              GR.head -> 'a -> GR.tail -> GR.block list -> bool -> G.graph * bool =
          fun h in' t rewritten changed -> match t with
          | GR.Tail (m, t) -> (
              Debug.eprintf "dataflow" "Rewriting middle node %s\n"
                (Rtlutil.ToString.rtl (GR.mid_instr m));
              match comp.middle_out in' m with
              | Dataflow a -> propagate (GR.Head (h, m)) a t rewritten changed
              | Rewrite g ->
                  Debug.eprintf "dataflow" "Rewriting middle node...\n";
                  let a, (g, _) = solve_and_rewrite fact comp in' g changed in
                  Debug.eprintf "dataflow" "Rewrite of middle node completed\n";
                  let h, t, rewritten = splice_in_forward h g t rewritten in
                  propagate h a t rewritten true)
          | GR.Last l ->
              match comp.last_outs in' l with
              | Dataflow set ->
                  set (check_property_match fact);
                  let b = GR.zip (GR.End (h, l)) in
                  rewrite_blocks (b :: rewritten) bs changed
              | Rewrite g ->
                  (* could test here that [[exits g = exits (GR.Entry, GR.Last l)]] *)
                  let a, (g, _) = solve_and_rewrite fact comp in' g changed in
                  let rewritten = splice_in_forward_last h g rewritten in
                  rewrite_blocks rewritten bs true in
        rewrite_next_block () in
  rewrite_blocks [] (G.postorder_dfs graph) changed

let forward_rewrite_solved (fact, comp) ~entry_fact g =
  forward_rewrite fact comp entry_fact g false

let forward_rewrite (fact, comp) ~entry_fact g =
  snd (solve_and_rewrite fact comp entry_fact g false)
<<utilities>>=
let eqfact fact a a' = (* poor man's approximation of equality *)
  not (fact.changed a a' or fact.changed a' a)
let check_property_match fact u a =
  let old_a = P.get fact.prop u in
  let new_a = fact.add_info a old_a in
  if not (eqfact fact old_a new_a) then
    impossf "property '%s' changed after supposedly reaching fixed point"
            fact.fact_name
@
<<utilities>>=
module UM = Unique.Map
let rec revapp h t = match t with
| GR.Last l -> h, l
| GR.Tail (m, t) -> revapp (GR.Head (h, m)) t

let must_be_empty g =
  if not (UM.is_empty g) then
    impossf "entry connects to exit, but there are more blocks"

let add_blocks map list =
  let add _ b bs = b :: bs in
  UM.fold add map list

<<utilities>>=
let splice_in_forward head graph tail oldblocks =
  let gentry, gblocks = G.openz (G.entry graph) in
  let gf, gt = GR.zip gentry in
  (match gf with GR.Entry -> () | _ -> impossf "entry is not entry?!");
  let h, l = revapp head gt in
  match l with
  | GR.Exit ->
      must_be_empty gblocks;
      h, tail, oldblocks
  | _ ->
      let gexit, gblocks = G.openz (G.exit graph) in
      let gh, gl = GR.goto_end gexit in
      (match gl with GR.Exit -> () | _ -> impossf "exit is not exit?!");
      let block = GR.zip (GR.End (h, l)) in
      gh, tail, (block :: add_blocks gblocks oldblocks)
@ 
<<utilities>>=
let splice_in_forward_last head graph oldblocks =
  let gentry, gblocks = G.openz (G.entry graph) in
  let gf, gt = GR.zip gentry in
  (match gf with GR.Entry -> () | _ -> impossf "entry is not entry?!");
  let h, l = revapp head gt in   (* zips in wrong dir, but OK *)
  let block = GR.zip (GR.End (h, l)) in  (* because now we zip back to first *)
  block :: add_blocks gblocks oldblocks
@ 
<<utilities>>=
let ( << ) f g = fun x -> f (g x)
<<definitions of exported functions>>=
let debug s (f, comp) =
  let pr = Printf.eprintf in
  let module RS = Rtlutil.ToString in
  let fact dir node a = pr "%s %s for %s = %s\n" f.fact_name dir node (s a) in
  let rewr node g = pr "%s rewrites %s to <not-shown>\n" comp.name node in
  let wrap f nodestring showout in' node =
    fact "in " (nodestring node) in';
    let answer = f in' node in
    let () = match answer with
    | Dataflow a -> showout (nodestring node) a
    | Rewrite g  -> rewr (nodestring node) g in
    answer in
  let middle_out = wrap comp.middle_out (RS.rtl << GR.mid_instr) (fact "out") in
(*  let last_in = wrap comp.last_in (RS.rtl << GR.last_instr) in *)
  let last_outs = comp.last_outs in
  f, { comp with last_outs = last_outs; middle_out = middle_out; }
@ 
<<definitions of exported functions>>=
let anal (fact, comp) =
  let wrap  f in' node = Dataflow (f in' node) in
  fact,
  { name = comp.name;
    last_outs = wrap comp.last_outs; middle_out = wrap comp.middle_out; }
<<definitions of exported functions>>=
let a_t (fact, comp) tx =
 let last_outs in' l =
   match tx.last_outs in' l with
   | Some g -> Rewrite g
   | None   -> Dataflow (comp.last_outs in' l) in
 let middle_out in' m =
   match tx.middle_out in' m with
   | Some g -> Rewrite g
   | None   -> Dataflow (comp.middle_out in' m) in
 fact, 
 { name = Printf.sprintf "%s and %s" comp.name tx.name;
   last_outs = last_outs; middle_out = middle_out;
 }
