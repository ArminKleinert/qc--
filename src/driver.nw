
\input{macros.tex}


% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Driver}
% ------------------------------------------------------------------ 

An action specified on the {\qcc} command line is usually too complex
to be carried out by the \module{main} module that parses the command
line.  Modules like \module{ast} or \module{elab} implement the
functionality to do what the user asks for; however, in order to keep
these modules as clean as possible they should be not concerned with
opening a file and parsing it just to get the abstract syntax of a
file.  This module mediates between the \module{main} module and the
task specific modules.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[dispatch]] function takes an abstract command line and performs
the requested action.  It returns an [[int]] return code to be used by
the \module{main} module for the [[exit]] function.  A returned value
of [[0]] indicates success, [[1]] an error in a source file, and [[2]]
an internal compiler error.

The [[Cmdline.cmd]] values [[Help]] and [[Version]] are covered by the
\module{main} module and must be not passed to [[dispatch]].

<<driver.mli>>=
val dispatch : Cmdline.cmd -> int
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<driver.ml>>=
module E = Error
@

The abstract syntax tree ({\AST}) of a {\PAL} source is the most
frequently required data structure. Function [[ast_of]] returns it for a
name [[file]] together with a [[Srcmap.map]] for that file.  It raises
[[Error.ErrorExn]] in case of problems. 


<<driver.ml>>=
let ast_of file = 
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; Parse.program scanner lexbuf, map 
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.error "parse error - compilation aborted"
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.error "parse error - compilation aborted"
              )
            | e ->
              ( finally()
              ; raise e
              )
@

% ------------------------------------------------------------------ 
\subsubsection{\texttt{-lex} command line option}
% ------------------------------------------------------------------ 

The [[lex]] function is a bit special because unlike most other
functions it works at the lexical level.  We thus can't use the
[[ast_of]] function from above.  The funtion reads a file token by
token and prints it together with its position to [[stdout]].

<<driver.ml>>=
let lex file =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
    let location lb = Srcmap.location map (Lexing.lexeme_start lb) in
    let rec loop lb =
        match scanner lb with
            | Parse.EOF -> ()
            | tok       ->
                let (file,line,col) = location lb           in
                let tok             = Scan.tok2str tok      in
                    ( Printf.printf "%-16s %3d %2d %s\n" file line col tok
                    ; loop lb
                    )
    in
        ( Srcmap.sync map 0 (file,1,1)
        ; loop lexbuf
        ; finally ()
        )
@

% ------------------------------------------------------------------ 
\subsubsection{\texttt{-asdl} command line option}
% ------------------------------------------------------------------ 

The [[asdl]] command exports the abstract syntax
of a a file in {\asdl} format to [[stdout]].

<<driver.ml>>=
let asdl file =
    let ast,map = ast_of file in
        AstUtil.sexp_wr_program ast stdout
        
@

% ------------------------------------------------------------------ 
\subsubsection{\texttt{-pp} command line option}
% ------------------------------------------------------------------ 

The [[pp]] command parses a file and pretty-prints it for a line
[[width]] to [[stdout]].

<<driver.ml>>=
let pp file width =
    let ast,map = ast_of file in
        Astpp.ppToFile stdout width ast
@


% ------------------------------------------------------------------ 
\subsubsection{\texttt{-check} command line option}
% ------------------------------------------------------------------ 

The [[check]] command parses a file and checks its static semantics. 

<<driver.ml>>=
let check file = 
    let ast, map = ast_of file                       in
    let env      = Fenv.Dirty.empty map              in
    let env      = Fenv.Dirty.push env (Fenv.Dirty.emptyscope) in
    let env      = Elab.Env.global   env ast         in
    let env      = Elab.Check.global env ast         in
    let env      = Elab.Env.setDefaults env          in
        match Fenv.Dirty.errorFlag env with
            | true  -> 1
            | false -> 0
@

% ------------------------------------------------------------------ 
\subsubsection{A {\PAL} to {\PAL} compiler}
% ------------------------------------------------------------------ 

The following [[Mangle.symbol]] value is used to construct a
[[Mangle.mangler]] function that respects the syntax of {\PAL}.

<<driver.ml>>=
let cmangle =
    let reserved =
        [ "aborts"; "align"; "aligned"; "also"; "as"; "big"; "byteorder";
        "case"; "const"; "continuation"; "cut"; "cuts"; "else"; "equal";
        "export"; "foreign"; "goto"; "if"; "import"; "invariant"; "jump";
        "little"; "memsize"; "pragma"; "register"; "return"; "returns";
        "section"; "semi"; "span"; "stackdata"; "switch"; "target"; "targets";
        "to"; "typedef"; "unicode"; "unwinds"; "float"; "charset";
        "pointersize"; "wordsize"]
    in
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '.' 
        | '_' 
        | '$' 
        | '@'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '@' in    
        { Mangle.preprocess = (fun x -> x)
        ; Mangle.replace    = replace
        ; Mangle.reserved   = reserved
        ; Mangle.avoid      = (fun x -> x ^ "$")
        }
@

An assembler if functorized over a personality that determines its
target characteristics and provides a name mangler. The interaction
between the various module types in the following code is subtle:

\begin{itemize}
\item [[Graph0]] implements [[Agraph.S]], the abstract flow graph
      interface, plus some extra functions [[ginit]] and [[stmts]] to
      obtain informations from a constructed flow graph.

\item [[Graph1]] implements [[Agraph.S]] by using another [[Agraph.S]]
      implementation.  Essentially, all data structures of [[Graph1]]
      are the ones provided by [[Graph0]].  The difference between
      [[Graph0]] and [[Graph1]] are dynamic:  a graph built by
      [[Graph1]] does not include [[CopyIn/Out]] nodes.

\item The interface of [[Graph1]] reveals, that [[Graph0]] and
      [[Graph1]] share the same data structures.  This makes it
      possible to call [[Graph0.stmts]] with a graph built by
      [[Graph1]], to access the extra functionality ([[stmts]],
      [[ginit]]) provided by [[Graph0]].

\end{itemize}

<<driver.ml>>=
module DummyTarget = struct
    let t = Target.dummy
end

module Graph0   = Cfg.Make(DummyTarget)
module Graph1   = Lowercopy.Make(Graph0)
@

The [[Personality]] structure determines the calling convention,
byteorder and many other aspects of the target architecture.  It also
defines what is an instruction in our assembler.  An instruction is en
entire procedure and is represented by an asbtract flow graph. 

<<driver.ml>>=
module Personality = struct
    module F = Fenv.Clean
    module A = Ast

    <<module Personality>>
end

<<module Personality>>=
let target          = Target.dummy
type instr          = Graph1.cfg (* = Graph0.cfg *)

let map             = Mangle.StrMap.empty
let mangle          = Mangle.make cmangle map
@

Our assembler creates {\PAL} abstract syntax.  Consequently,
instructions must be translated to an {\AST}, too.  This is done by
the [[ext]] function, that translates an instruction to an
[[Ast.proc]] value.

The body of the procedure can be obtained from the [[Graph0.stmts]]
function,  that returns a list of (assign-) statements. These
statements use local variables that need to be declared. Declarations
are (re-) constructed by scanning the [[scope]] of the procedure for
register declarations. 

<<module Personality>>=
let rdecl mangle name ventry dd = match ventry with
    | (_, (F.Register _ , Types.Bits n)) -> 
        let r = (A.Variant, None, A.BitsTy n ,mangle name, None)
        in r::dd
    | _ -> dd
@

A procedure can hold data on the local run-time stack.  The usage of
such [[stackdata]] must be declared.  No!  Even in our translation to
{\PAL} the stack data lies on the run-time stack and is nor represented
as [[stackdata]].

<<unused>>=
let sdecl name proc =
    [ A.Align (proc.F.salign)
    ; A.Label(mangle (Idgen.id' name))
    ; A.MemDecl ( A.BitsTy target.Target.memsize
                , A.FixSize(A.Int(Bits.of_int proc.F.sdata 32, None ))
                , None
                )
    ]
    
<<module Personality>>=
let ext i           = 
    let (name,proc) = Graph0.init i                           in
    let scope       = proc.F.scope                            in  
    let name        = mangle name                             in 
    let stmts       = Graph0.stmts i mangle                   in
    let stmts       = List.map (fun s -> A.StmtBody s) stmts  in 
    let decls       = F.foldv (rdecl mangle) scope []         in
        ( None
        , name
        , []
        ,     A.DeclBody(A.Registers(decls)) 
           :: stmts
        )
@

<<driver.ml>>=
module Asm      = Asm2ast.Make(Personality)
module Ast2IR   = Ast2ir.Make (Graph1) (Asm)
@




The [[compile]] compiles a source file from {\PAL} to {\PAL}.  The
[[target]] provided from the command line is currently ignored.  Code
generation is only performed when the check of the static semantics is
passed. 
    
<<driver.ml>>=
let compile target file =
    let ast, map = ast_of file                       in
    let env      = Fenv.Dirty.empty map              in
    let env      = Fenv.Dirty.push env (Fenv.Dirty.emptyscope) in
    let env      = Elab.Env.global   env ast         in
    let env      = Elab.Check.global env ast         in
    let env      = Elab.Env.setDefaults env          in
        if Fenv.Dirty.errorFlag env = true then 1 else
        let env    = Fenv.clean env                  in
        let target = Target.dummy                    in
        let width  = 72                              in
        let _,asm  = Ast2IR.translate env target ast in
            ( Astpp.ppToFile stdout width (Asm.ast asm)
            ; 0
            )
@

The command line flags [[-version]] and [[-help]] trigger short
messages going to stdout.  The [[usage]] function is also called from
[[main]] when the command line syntax is wrong. 

<<driver.ml>>=
let version () =
    ( This.name     stdout 
    ; output_string stdout " "
    ; This.version  stdout 
    ; output_string stdout "\n(c) 2000 President and Fellows of Harvard University" 
    ; output_string stdout "\nhttp://www.cminusminus.org/\n"
    )
@

<<driver.ml>>=
let usage this =
  let msg = 
  [   "\t -help                      (this to stdout)"
  ;   "\t -version                   (version to stdout)"
  ;   "\t -lex file.c--              (scan file)"
  ;   "\t -asdl file.c--             (parse file)"
  ;   "\t -pp [-w width] file.c--    (parse and pretty print file for width)"
  ;   "\t -check file.c--            (check static semantics of file)"
  ;   "\t -ir file.c--               (create abstract c-- )"
  ;   "\t file.c--                   (same as -check file)"
  ] in
    Printf.printf "%s command line syntax\n" this ;
    List.iter print_endline msg
@

% ------------------------------------------------------------------ 
\subsection{Dispatch over command line options}
% ------------------------------------------------------------------ 

The (exported) dispatch function just invokes the appropriate function
that implements a command. The cases [[Help]] and [[Version]] are
expexted to be handled by the \module{main} module. 
            
<<driver.ml>>=
let dispatch cmd = 
    try 
        ( match cmd with 
        | Cmdline.Help                  -> usage "qc--"   ; 0
        | Cmdline.Version               -> version ()     ; 0
        | Cmdline.Lex(file)             -> lex  file      ; 0
        | Cmdline.Asdl(file)            -> asdl file      ; 0
        | Cmdline.PP(file,width)        -> pp file width  ; 0
        | Cmdline.Check(file)           -> check file
        | Cmdline.Compile(target,file)  -> compile target file
        )
    with
        | E.ErrorExn(msg)               -> E.errorPrt msg; 1
@

