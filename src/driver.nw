
\input{macros.tex}


% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Driver}
% ------------------------------------------------------------------ 

An action specified on the {\qcc} command line is usually too complex
to be carried out by the \module{main} module that parses the command
line.  Modules like \module{ast} or \module{elab} implement the
functionality to do what the user asks for; however, in order to keep
these modules as clean as possible they should be not concerned with
opening a file and parsing it just to get the abstract syntax of a
file.  This module mediates between the \module{main} module and the
task specific modules.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[dispatch]] function takes an abstract command line and performs
the requested action.  It returns an [[int]] return code to be used by
the \module{main} module for the [[exit]] function.  A returned value
of [[0]] indicates success, [[1]] an error in a source file, and [[2]]
an internal compiler error.

The [[Cmdline.cmd]] values [[Help]] and [[Version]] are covered by the
\module{main} module and must be not passed to [[dispatch]].

<<driver.mli>>=
val dispatch : Cmdline.cmd -> int
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<driver.ml>>=
module E = Error
@

The abstract syntax tree ({\AST}) of a {\PAL} source is the most
frequently required data structure. Function [[ast_of]] returns it for a
name [[file]] together with a [[Srcmap.map]] for that file.  It raises
[[Error.ErrorExn]] in case of problems. 


<<driver.ml>>=
let ast_of file = 
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; Parse.program scanner lexbuf, map 
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.error "parse error - compilation aborted"
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.error "parse error - compilation aborted"
              )
            | e ->
              ( finally()
              ; raise e
              )
@

% ------------------------------------------------------------------ 
\subsubsection{\texttt{-lex} command line option}
% ------------------------------------------------------------------ 

The [[lex]] function is a bit special because unlike most other
functions it works at the lexical level.  We thus can't use the
[[ast_of]] function from above.  The funtion reads a file token by
token and prints it together with its position to [[stdout]].

<<driver.ml>>=
let lex file =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
    let location lb = Srcmap.location map (Lexing.lexeme_start lb) in
    let rec loop lb =
        match scanner lb with
            | Parse.EOF -> ()
            | tok       ->
                let (file,line,col) = location lb           in
                let tok             = Scan.tok2str tok      in
                    ( Printf.printf "%-16s %3d %2d %s\n" file line col tok
                    ; loop lb
                    )
    in
        ( Srcmap.sync map 0 (file,1,1)
        ; loop lexbuf
        ; finally ()
        )
@

% ------------------------------------------------------------------ 
\subsubsection{\texttt{-asdl} command line option}
% ------------------------------------------------------------------ 

The [[asdl]] command exports the abstract syntax
of a a file in {\asdl} format to [[stdout]].

<<driver.ml>>=
let asdl file =
    let ast,map = ast_of file in
        AstUtil.sexp_wr_program ast stdout
        
@

% ------------------------------------------------------------------ 
\subsubsection{\texttt{-pp} command line option}
% ------------------------------------------------------------------ 

The [[pp]] command parses a file and pretty-prints it for a line
[[width]] to [[stdout]].

<<driver.ml>>=
let pp file width =
    let ast,map = ast_of file in
        Astpp.ppToFile stdout width ast
@


% ------------------------------------------------------------------ 
\subsubsection{\texttt{-check} command line option}
% ------------------------------------------------------------------ 

The [[check]] command parses a file and checks its static semantics. 

<<driver.ml>>=
let check file = 
    let ast, map = ast_of file                       in
    let env      = Fenv.Dirty.empty map              in
    let env      = Fenv.Dirty.push env (Fenv.Dirty.emptyscope) in
    let env      = Elab.Env.global   env ast         in
    let env      = Elab.Check.global env ast         in
    let env      = Elab.Env.setDefaults env          in
        match Fenv.Dirty.errorFlag env with
            | true  -> 1
            | false -> 0
@

% ------------------------------------------------------------------ 
\subsubsection{A {\PAL} to {\PAL} compiler}
% ------------------------------------------------------------------ 

The following [[Mangle.symbol]] value is used to construct a
[[Mangle.mangler]] function that respects the syntax of {\PAL}.

<<driver.ml>>=
let cmangle =
    let reserved =
        [ "aborts"; "align"; "aligned"; "also"; "as"; "big"; "byteorder";
        "case"; "const"; "continuation"; "cut"; "cuts"; "else"; "equal";
        "export"; "foreign"; "goto"; "if"; "import"; "invariant"; "jump";
        "little"; "memsize"; "pragma"; "register"; "return"; "returns";
        "section"; "semi"; "span"; "stackdata"; "switch"; "target"; "targets";
        "to"; "typedef"; "unicode"; "unwinds"; "float"; "charset";
        "pointersize"; "wordsize"]
    in
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '.' 
        | '_' 
        | '$' 
        | '@'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '@' in    
        { Mangle.preprocess = (fun x -> x)
        ; Mangle.replace    = replace
        ; Mangle.reserved   = reserved
        ; Mangle.avoid      = (fun x -> x ^ "$")
        }
@

The [[compile]] compiles a source file from {\PAL} to {\PAL}.  The
[[target]] provided from the command line is currently ignored.  Code
generation is only performed when the check of the static semantics is
passed. 
    
<<driver.ml unused>>=
let compile target file =
    let ast, map = ast_of file                       in
    let env      = Fenv.Dirty.empty map              in
    let env      = Fenv.Dirty.push env (Fenv.Dirty.emptyscope) in
    let env      = Elab.Env.global   env ast         in
    let env      = Elab.Check.global env ast         in
    let env      = Elab.Env.setDefaults env          in
        if Fenv.Dirty.errorFlag env = true then 1 else
        let env    = Fenv.clean env                  in
        let target = Target.dummy                    in
        let width  = 72                              in
        let _,asm  = Ast2IR.translate env target ast in
            ( Astpp.ppToFile stdout width (Asm.ast asm)
            ; 0
            )
@

The command line flags [[-version]] and [[-help]] trigger short
messages going to stdout.  The [[usage]] function is also called from
[[main]] when the command line syntax is wrong. 

<<driver.ml>>=
let version () =
    ( This.name     stdout 
    ; output_string stdout " "
    ; This.version  stdout 
    ; output_string stdout "\n(c) 2000,2001 President and Fellows of Harvard University" 
    ; output_string stdout "\nhttp://www.cminusminus.org/\n"
    )
@

<<driver.ml>>=
let usage this =
  let msg = 
  [   "\t -help                      (this to stdout)"
  ;   "\t -version                   (version to stdout)"
  ;   "\t -lex file.c--              (scan file)"
  ;   "\t -asdl file.c--             (parse file)"
  ;   "\t -pp [-w width] file.c--    (parse and pretty print file for width)"
  ;   "\t -check file.c--            (check static semantics of file)"
  ;   "\t -ir file.c--               (create abstract c-- )"
  ;   "\t file.c--                   (same as -check file)"
  ] in
    Printf.printf "%s command line syntax\n" this ;
    List.iter print_endline msg
@

% ------------------------------------------------------------------ 
\subsection{Dispatch over command line options}
% ------------------------------------------------------------------ 

The (exported) dispatch function just invokes the appropriate function
that implements a command. The cases [[Help]] and [[Version]] are
expexted to be handled by the \module{main} module. 
            
<<driver.ml>>=
let dispatch cmd = 
    try 
        ( match cmd with 
        | Cmdline.Help                  -> usage "qc--"   ; 0
        | Cmdline.Version               -> version ()     ; 0
        | Cmdline.Lex(file)             -> lex  file      ; 0
        | Cmdline.Asdl(file)            -> asdl file      ; 0
        | Cmdline.PP(file,width)        -> pp file width  ; 0
        | Cmdline.Check(file)           -> check file
    (*  | Cmdline.Compile(target,file)  -> compile target file *)
        )
    with
        | E.ErrorExn(msg)               -> E.errorPrt msg; 1
@

