
\input{macros.tex}

% l2h substitution AST AST
% l2h substitution rtl RTL
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Driver}
% ------------------------------------------------------------------ 

An action specified on the {\qcc} command line is usually too complex
to be carried out by the \module{main} module that parses the command
line.  Modules like \module{ast} or \module{elab} implement the
functionality to do what the user asks for; however, in order to keep
these modules as clean as possible they should be not concerned with
opening a file and parsing it just to get the abstract syntax of a
file.  This module mediates between the \module{main} module and the
task specific modules.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[dispatch]] function takes an abstract command line and performs
the requested action.  It returns an [[int]] return code to be used by
the \module{main} module for the [[exit]] function.  A returned value
of [[0]] indicates success, [[1]] an error in a source file, and [[2]]
an internal compiler error.

The [[Cmdline.cmd]] values [[Help]] and [[Version]] are covered by the
\module{main} module and must be not passed to [[dispatch]].

<<driver.mli>>=
val dispatch : Cmdline.cmd -> int
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<driver.ml>>=
module E = Error
@

The abstract syntax tree ({\AST}) of a {\PAL} source is the most
frequently required data structure. Function [[ast_of]] returns it for a
name [[file]] together with a [[Srcmap.map]] for that file.  It raises
[[Error.ErrorExn]] in case of problems. 


<<>>=
let ast_of file = 
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; Parse.program scanner lexbuf, map 
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.error "parse error - compilation aborted"
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.error "parse error - compilation aborted"
              )
            | e ->
              ( finally()
              ; raise e
              )
@

% ------------------------------------------------------------------ 
\subsubsection{\texttt{-lex} command line option}
% ------------------------------------------------------------------ 

The [[lex]] function is a bit special because unlike most other
functions it works at the lexical level.  We thus can't use the
[[ast_of]] function from above.  The funtion reads a file token by
token and prints it together with its position to [[stdout]].

<<>>=
let lex file =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.empty                          in
    let scanner     = Scan.scan map                         in
    let location lb = Srcmap.location map (Lexing.lexeme_start lb) in
    let rec loop lb =
        match scanner lb with
            | Parse.EOF -> ()
            | tok       ->
                let (file,line,col) = location lb           in
                let tok             = Scan.tok2str tok      in
                    ( Printf.printf "%-16s %3d %2d %s\n" file line col tok
                    ; loop lb
                    )
    in
        ( Srcmap.sync map 0 (file,1,1)
        ; loop lexbuf
        ; finally ()
        )
@

% ------------------------------------------------------------------ 
\subsubsection{\texttt{-asdl} command line option}
% ------------------------------------------------------------------ 

The [[asdl]] command exports the abstract syntax
of a a file in {\asdl} format to [[stdout]].

<<>>=
let asdl file =
    let ast,map = ast_of file in
        AstUtil.sexp_wr_program ast stdout
        
@

% ------------------------------------------------------------------ 
\subsubsection{\texttt{-pp} command line option}
% ------------------------------------------------------------------ 

The [[pp]] command parses a file and pretty-prints it for a line
[[width]] to [[stdout]].

<<>>=
let pp file width =
    let ast,map = ast_of file in
        Astpp.ppToFile stdout width ast
@


% ------------------------------------------------------------------ 
\subsubsection{\texttt{-check} command line option}
% ------------------------------------------------------------------ 

The [[check]] command parses a file and checks its static semantics. 

<<>>=
let check file = 
    let ast, map = ast_of file                       in
    let env      = Fenv.Dirty.empty map              in
    let env      = Fenv.Dirty.push env (Fenv.Dirty.emptyscope) in
    let env      = Elab.Env.global   env ast         in
    let env      = Elab.Check.global env ast         in
        match Fenv.Dirty.errorFlag env with
            | true  -> 1
            | false -> 0
@

% ------------------------------------------------------------------ 
\subsubsection{A dummy target}
% ------------------------------------------------------------------ 

<<>>=
let dummy =     
    let sp = Rtl.Cell( 'm'
                    , Rtl.BigEndian
                    , 32
                    , Rtl.Const(Rtl.Link("sp ",32))
                    , -1
                    ) in
    let conv = 
        { Target.sp             = sp
        ; Target.proc_param     = Automaton.Build.cc 
        ; Target.proc_result    = Automaton.Build.cc 
        ; Target.cont_param     = Automaton.Build.cc
        } in
    let convmap = Target.StrMap.add "C--" conv Target.StrMap.empty
    in             
        { Target.name           = "dummy"
        ; Target.byteorder      = Rtl.BigEndian
        ; Target.wordsize       = 32
        ; Target.pointersize    = 32
        ; Target.memsize        = 8
        ; Target.float          = "ieee754"
        ; Target.charset        = "latin1"
        ; Target.conv           = convmap
        ; Target.globals        = Automaton.Build.globals
        ; Target.regmap         = Target.StrMap.empty
        }
@

% ------------------------------------------------------------------ 
\subsubsection{A {\PAL} to {\PAL} compiler}
% ------------------------------------------------------------------ 

        
<<>>=       
let cmangle =
    let reserved =
        [ "aborts"; "align"; "aligned"; "also"; "as"; "big"; "byteorder";
        "case"; "const"; "continuation"; "cut"; "cuts"; "else"; "equal";
        "export"; "foreign"; "goto"; "if"; "import"; "invariant"; "jump";
        "little"; "memsize"; "pragma"; "register"; "return"; "returns";
        "section"; "semi"; "span"; "stackdata"; "switch"; "target"; "targets";
        "to"; "typedef"; "unicode"; "unwinds"; "float"; "charset";
        "pointersize"; "wordsize"]
    in
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '.' 
        | '_' 
        | '$' 
        | '@'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '@' in    
        { Mangle.preprocess = (fun x -> x)
        ; Mangle.replace    = replace
        ; Mangle.reserved   = reserved
        ; Mangle.avoid      = (fun x -> x ^ "$")
        }

module Personality = struct
    let target          = dummy
    type instruction    = Agraph2ast.graph
    let map             = Mangle.StrMap.empty
    let mangle          = Mangle.make cmangle map
    let proc_of_instr i = 
        let name  = mangle (Agraph2ast.name  i) in
        let stmts = Agraph2ast.stmts i mangle   in
            (None, name, [], List.map (fun s -> Ast.StmtBody s) stmts) 
end

module Asm = Asm2ast.Make(Personality)

module Ast2IR = Ast2ir.Make (Agraph2ast) (Asm)
@

    
<<>>=
let compile target file =
    let ast, map = ast_of file                       in
    let env      = Fenv.Dirty.empty map              in
    let env      = Fenv.Dirty.push env (Fenv.Dirty.emptyscope) in
    let env      = Elab.Env.global   env ast         in
    let env      = Elab.Check.global env ast         in
        if Fenv.Dirty.errorFlag env = true then 1 else
        let env    = Fenv.clean env                  in
        let target = dummy                           in
        let width  = 72                              in
        let _,asm  = Ast2IR.translate env target ast in
            ( Astpp.ppToFile stdout width (Asm.ast asm)
            ; 0
            )
@
        
    

                      



% ------------------------------------------------------------------ 
\subsection{Dispatch over command line options}
% ------------------------------------------------------------------ 

The (exported) dispatch function just invokes the appropriate function
that implements a command. The cases [[Help]] and [[Version]] are
expexted to be handled by the \module{main} module. 
            
<<>>=
let dispatch cmd = 
    try 
        ( match cmd with 
        | Cmdline.Help                  -> assert false
        | Cmdline.Version	        -> assert false
        | Cmdline.Lex(file)             -> lex  file      ; 0
        | Cmdline.Asdl(file)            -> asdl file      ; 0
        | Cmdline.PP(file,width)        -> pp file width  ; 0
        | Cmdline.Check(file)           -> check file
        | Cmdline.Compile(target,file)  -> compile target file
        )
    with
        | E.ErrorExn(msg)               -> E.errorPrt msg; 1
@

