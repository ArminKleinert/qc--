% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ------------------------------------------------------------------ 
\section{Emitting Code for the Interpreter}
% ------------------------------------------------------------------ 

A procedure is translated for the interpreter by walking over its
control-flow graph and emitting code for each node. 
<<interpemit.mli>>=
val proc: Ast2ir.proc -> (string -> unit) -> unit
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation is against the ``new'' control-flow graph module
\module{cfg.nw}.

<<interpemit.ml>>=
module C = Cfgx.M
module P = Proc
module E = Interpemitrtl
module T = Target
module R = Rtl.Private
@

\paragraph{Helper functions}.

<<interpemit.ml>>=
let sprintf          = Printf.sprintf
let quoted s         = "\"" ^ s ^ "\""

let open_span printer (token, reloc) = 
   let (_,bits) = Reloc.Simple.normalize reloc in
   let dnexp  = Rtl.Dn.exp (Rtl.bits bits Interp.target'.T.pointersize) in
   let imposs = (fun () -> Impossible.impossible "open_span:invalid span val.")
   in
   let const  = function
       | R.Link(sym,_,_) -> (Some sym#mangled_text, 0              )
       | R.Late(name, _) -> (Some name            , 0              )
       | R.Bits b        -> (None                 , Bits.S.to_int b)
       | R.Diff _        -> Impossible.impossible "PIC not supported"
       | _               -> Impossible.impossible "open_span:invalid span val."
   in
   let rec viewexp = function
       | R.Const c -> const c
       | R.Fetch _ -> imposs()
       | R.App   (("add",_), [exp' ; exp'']) ->
           let v'  = viewexp exp'  in
           let v'' = viewexp exp'' in
             (match (v', v'') with
              | ((Some s, i'), (None  , i'')) -> (Some s, i' + i'')
              | ((None  , i'), (Some s, i'')) -> (Some s, i' + i'')
              | _                             -> imposs()
             )
       | _         -> imposs()
   in
   let spanval, offset = viewexp dnexp
   in
      printer (sprintf "CMM.begin_span(%d,'%s',%d)\n"
                (Bits.S.to_int token)
                (match spanval with | Some s -> s | _ -> imposs())
                offset)

let close_span printer (token, _) =
    printer (sprintf "CMM.end_span(%d)\n" (Bits.S.to_int token))

let instr n =
    match C.to_executable n with
    | None      -> Impossible.impossible "expected instruction in this node"
    | Some i    -> i
@

The [[node]] function does all the work. Depending on the type of node,
code is emitted. 


<<interpemit.ml>>=
let node proc printer n = match C.kind n with
    | C.Join | C.Exit -> 
        List.iter (fun l -> printer (sprintf "CMM.define_label('%s')\n" l))
          (C.labels n)
    | C.Call ->
        let rec sublist lst i length = 
           let helper lst i length = match lst with
               | []        -> []
               | (elt::es) -> if   i > 0 then sublist es (i-1) length
                              else if    length <= 0 then []
                                   else  elt::(sublist es i (length-1))
           in  List.rev (helper lst i length)
        in

        let nreturns = C.altrets    n
        and nunwinds = C.unwinds_to n
        and ncuts    = C.cuts_to    n
        in

        let spans   = 
          let num = C.num (C.succ_n n nreturns) in
          try Runtimedata.user_spans (snd (List.find (fun (n,_) -> C.num n = num)
                                                     proc.Proc.spans))
          with Not_found -> [] in
					
        let succs   = C.succs n     in

        let returns = sublist succs 0                nreturns
        and cuts    = sublist succs nreturns         ncuts
        and unwinds = sublist succs (nreturns+ncuts) nunwinds
        and aborts  = List.length succs > nreturns + 1 + nunwinds + ncuts
        and e       = match C.to_executable n with
                      | None   -> Impossible.impossible "call w/o instruction"
                      | Some i -> Interp.target'.T.call.T.project i
        in

        let string_of_annotation lst = 
           let get_label n = 
              if   not (C.is_join n)
              then Impossible.impossible "interpemit: invalid annotation"
              else C.label n
            (* FIX ^^^^^^^^^ this might be okay, but not sure *)
           in String.concat "," (List.map (fun n -> quoted (get_label n)) lst)
        in
           ( List.iter (open_span printer) (List.rev spans) 
           ; E.exp printer e  
           ; printer
              (sprintf "CMM.call({%s}, {%s}, {%s}, %s) -- %s\n"
                (string_of_annotation cuts   )
                (string_of_annotation unwinds)
                (string_of_annotation returns)
                (if aborts then "1" else "0" )
                "cuts, unwinds, returns, aborts")
           ; List.iter (close_span printer) spans
           ) 

    (* FIX cut to is not being translated well *)
    | C.CutTo ->
        ( E.rtl printer (instr n)
        ; ( let e  = match C.to_executable n with
              | None   -> Impossible.impossible "cut w/o instruction"
              | Some i -> Interp.target'.T.call.T.project i in
            let e = (match Rtl.Dn.exp e with
              | Rtl.Private.Fetch (Rtl.Private.Mem (_,_,exp,_), _) ->
                 Rtl.Up.exp exp
              | _ -> e) in
            E.exp printer e)
        ; printer "CMM.cut()\n"
        )
    | C.Cbranch ->
        let t = C.tsucc n in
        let l = C.label t in
        let i = instr n   in
        let (g,_) = Interp.target'.T.branch.T.project i in
            ( E.exp printer g
            ; printer (sprintf "CMM.cbrancht('%s')\n" l)
            )
    | C.Branch when C.is_br n ->
        let i = instr n in
        let e = Interp.target'.T.goto.T.project i in
            ( E.exp printer e
            ; printer "CMM.goto()\n"
            )
    | C.Return ->
        (* THIS IS WRONG; WE DO _NOT_ ALWAYS TAKE THE 0th RETURN *)
        printer (sprintf "CMM.cmm_return(%d,%d)\n" 0 0)

    | C.Jump ->
        let i = instr n in
        let e = Interp.target'.T.jump.T.project i in
            ( E.exp printer e
            ; printer "CMM.cmm_tail_call()\n"
            )

    | _ ->  ( match C.to_executable n with
            | None   -> ()
            | Some i -> E.rtl printer i
            )
@            


We specialize the fold function provided by the {\cfg} to an iterator
and apply it to all nodes.

<<interpemit.ml>>=
let proc p printer =
    let iter f cfg = C.fold_layout (fun node () -> f p printer node) () cfg in
        iter node p.P.cfg
@    
