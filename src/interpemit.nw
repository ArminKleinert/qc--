% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ------------------------------------------------------------------ 
\section{Emitting Code for the Interpreter}
% ------------------------------------------------------------------ 

A procedure is translated for the interpreter by walking over its
control-flow graph and emitting code for each node. 
<<interpemit.mli>>=
val proc: Ast2ir.proc -> (string -> unit) -> unit
@
% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation is against the ``new'' control-flow graph module
\module{cfg.nw}.
<<interpemit.ml>>=
module C   = Cfgx.M
module P   = Proc
module E   = Interpemitrtl
module T   = Target
module RP  = Rtl.Private
module RU  = Rtlutil
module RTD = Runtimedata

let unimpf fmt = Printf.kprintf Impossible.unimp fmt
let quoted s = "\"" ^ s ^ "\""
@
\paragraph{Helper functions}.

THIS FUNCTION APPEARS TO MAKE NO SENSE WHATEVER.
IT SCRUTINIZES [[dnexp]], WHICH IS KNOWN TO BE [[RP.Bits]].
AN ORIGINAL VERSION ALWAYS FAILED.
LET'S TRY IT WITH [[sym]].
<<definitions of emission functions>>=
let open_span (token, reloc) = 
   match Reloc.as_simple reloc with
   | Some s, offset ->
       let offset = Bits.S.to_int offset in
       printf "CMM.begin_span(%d,'%s',%d)\n" (Bits.S.to_int token) s#mangled_text offset
   | None, _ -> unimpf "missing name in interpreter's span" in

let close_span (token, _) = printf "CMM.end_span(%d)\n" (Bits.S.to_int token) in

let instr n =
    match C.to_executable n with
    | None      -> Impossible.impossible "expected instruction in this node"
    | Some i    -> i in
@
The [[node]] function does all the work. Depending on the type of node,
code is emitted. 
<<definitions of emission functions>>=
let node proc n = match C.kind n with
    | C.Join | C.Exit -> 
        List.iter (fun l -> printf "CMM.define_label('%s')\n" l) (C.labels n)
    | C.Call ->
        let rec sublist lst i length = 
           let helper lst i length = match lst with
               | []        -> []
               | (elt::es) -> if   i > 0 then sublist es (i-1) length
                              else if    length <= 0 then []
                                   else  elt::(sublist es i (length-1))
           in  List.rev (helper lst i length)
        in

        let nreturns = C.altrets    n
        and nunwinds = C.unwinds_to n
        and ncuts    = C.cuts_to    n in

        let spans   = match C.spans n with Some ss -> RTD.user_spans ss | None -> [] in
        let succs   = C.succs n     in
        let returns = sublist succs 0                nreturns
        and cuts    = sublist succs nreturns         ncuts
        and unwinds = sublist succs (nreturns+ncuts) nunwinds
        and aborts  = List.length succs > nreturns + 1 + nunwinds + ncuts
        and e       = match C.to_executable n with
                      | None   -> Impossible.impossible "call w/o instruction"
                      | Some i -> Interp.target'.T.call.T.project i in

        let string_of_annotation lst = 
           let get_label n = 
              if   not (C.is_join n)
              then Impossible.impossible "interpemit: invalid annotation"
              else C.label n
            (* FIX ^^^^^^^^^ this might be okay, but not sure *)
           in String.concat "," (List.map (fun n -> quoted (get_label n)) lst) in
           ( List.iter open_span (List.rev spans) 
           ; E.exp printer e  
           ; printf "CMM.call({%s}, {%s}, {%s}, %s) -- %s\n"
                (string_of_annotation cuts   )
                (string_of_annotation unwinds)
                (string_of_annotation returns)
                (if aborts then "1" else "0" )
                "cuts, unwinds, returns, aborts"
           ; List.iter close_span spans
           ) 

    (* FIX cut to is not being translated well *)
    | C.CutTo ->
        ( E.rtl printer (instr n)
        ; ( let e  = match C.to_executable n with
              | None   -> Impossible.impossible "cut w/o instruction"
              | Some i -> Interp.target'.T.call.T.project i in
            let e = (match Rtl.Dn.exp e with
              | Rtl.Private.Fetch (Rtl.Private.Mem (_,_,exp,_), _) ->
                 Rtl.Up.exp exp
              | _ -> e) in
            E.exp printer e)
        ; printf "CMM.cut()\n"
        )
    | C.Cbranch ->
        let t = C.tsucc n in
        let l = C.label t in
        let i = instr n   in
        let (g,_) = Interp.target'.T.branch.T.project i in
            ( E.exp printer g
            ; printf "CMM.cbrancht('%s')\n" l
            )
    | C.Branch when C.is_br n ->
        let i = instr n in
        let e = Interp.target'.T.goto.T.project i in
            ( E.exp printer e
            ; printf "CMM.goto()\n"
            )
    | C.Return ->
        (* THIS IS WRONG; WE DO _NOT_ ALWAYS TAKE THE 0th RETURN *)
        printf "CMM.cmm_return(%d,%d)\n" 0 0

    | C.Jump ->
        let i = instr n in
        let e = Interp.target'.T.jump.T.project i in
            ( E.exp printer e
            ; printf "CMM.cmm_tail_call()\n"
            )

    | _ ->  ( match C.to_executable n with
            | None   -> ()
            | Some i -> E.rtl printer i
            ) in
@            
We specialize the fold function provided by the {\cfg} to an iterator
and apply it to all nodes.
<<interpemit.ml>>=
let proc p printer =
  let printf fmt = Printf.kprintf printer fmt in
  <<definitions of emission functions>>
  let iter f cfg = C.fold_layout (fun node () -> f p node) () cfg in
  iter node p.P.cfg
@    
