% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ------------------------------------------------------------------ 
\section{Emitting Code for the Interpreter}
% ------------------------------------------------------------------ 

A procedure is translated for the interpreter by walking over its
control-flow graph and emitting code for each node. 
<<interpemit.mli>>=
val proc: Ast2ir.proc -> (string -> unit) -> unit
@
% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation is against the ``new'' control-flow graph module
\module{cfg.nw}.
<<interpemit.ml>>=
module G   = Zipcfg
module GR  = Zipcfg.Rep
module P   = Proc
module E   = Interpemitrtl
module T   = Target
module RP  = Rtl.Private
module RU  = Rtlutil
module RTD = Runtimedata

let impossf fmt = Printf.kprintf Impossible.impossible fmt
type 'a printf = ('a, out_channel, unit) format -> 'a
@
\paragraph{Helper functions}.

THIS FUNCTION APPEARS TO MAKE NO SENSE WHATEVER.
IT SCRUTINIZES [[dnexp]], WHICH IS KNOWN TO BE [[RP.Bits]].
AN ORIGINAL VERSION ALWAYS FAILED.
LET'S TRY IT WITH [[sym]].
<<definitions of printing functions>>=
let open_span (token, reloc) = 
   let (sym,bits)  = Reloc.Simple.normalize reloc in
   let symname     = Aux.Option.map (fun s -> s#mangled_text) sym in
   let dnexp       = Rtl.Dn.exp (Rtl.bits bits Interp.target'.T.pointersize) in
   let to_string e = RU.ToString.exp (Rtl.Up.exp e) in
   let const = function
       | RP.Link(sym,_,_) -> (Some sym#mangled_text, 0              )
       | RP.Late(name, _) -> (Some name            , 0              )
       | RP.Bits b        -> (symname              , Bits.S.to_int b)
       | RP.Diff _        -> Impossible.impossible "PIC not supported"
       | RP.Bool _        -> impossf "Boolean constant in span" in
   let rec viewexp e = match e with
       | RP.Const c -> const c
       | RP.App   (("add",_), [exp' ; exp'']) ->
           let v'  = viewexp exp'  in
           let v'' = viewexp exp'' in
             (match (v', v'') with
              | ((Some s, i'), (None  , i'')) -> (Some s, i' + i'')
              | ((None  , i'), (Some s, i'')) -> (Some s, i' + i'')
              | _ -> impossf "bad addition %s in span" (to_string e)
             )
       | _ -> impossf "unexpected %s in span" (to_string e) in
   let spanval, offset = viewexp dnexp in
   printf "CMM.begin_span(%d,'%s',%d)\n"
                (Bits.S.to_int token)
                (match spanval with | Some s -> s | _ -> impossf "missing name in span")
                offset in

let close_span (token, _) =
    printf "CMM.end_span(%d)\n" (Bits.S.to_int token) in
@
The [[node]] function does all the work. Depending on the type of node,
code is emitted. 
<<definitions of printing functions>>=
let first f () = match f with
| GR.Label ((_, l), _, _) -> printf "CMM.define_label('%s')\n" l
| GR.Entry -> () in

let middle m () = match m with
| GR.Assertion _ -> ()
| _ -> E.rtl print (GR.mid_instr m) in

let last l () = match l with
| GR.Call call ->
        let rec sublist lst i length = 
           let helper lst i length = match lst with
               | []        -> []
               | (elt::es) -> if   i > 0 then sublist es (i-1) length
                              else if    length <= 0 then []
                                   else  elt::(sublist es i (length-1))
           in  List.rev (helper lst i length) in

        let nreturns = call.GR.cal_altrets 
        and nunwinds = call.GR.cal_unwinds_to
        and ncuts    = call.GR.cal_cuts_to in

        let spans   = match call.GR.cal_spans with
        | Some ss -> RTD.user_spans ss
        | None -> [] in
        let succs   = GR.succs l     in
        let returns = sublist succs 0                nreturns
        and cuts    = sublist succs nreturns         ncuts
        and unwinds = sublist succs (nreturns+ncuts) nunwinds
        and aborts  = List.length succs > nreturns + 1 + nunwinds + ncuts
        and e       = Interp.target'.T.call.T.project (GR.last_instr l) in

        let string_of_annotation lst = String.concat "," (List.map quoted_label lst) in
        begin
          List.iter open_span (List.rev spans);
          E.exp print e;
          printf "CMM.call({%s}, {%s}, {%s}, %s) -- %s\n"
                (string_of_annotation cuts   )
                (string_of_annotation unwinds)
                (string_of_annotation returns)
                (if aborts then "1" else "0" )
                "cuts, unwinds, returns, aborts";
          List.iter close_span spans;
        end

    (* FIX cut to is not being translated well *)
    | GR.Cut (rtl, edges, regs) ->
        ( E.rtl print rtl
        ; ( let e  = Interp.target'.T.call.T.project rtl in
            let e = (match Rtl.Dn.exp e with
              | Rtl.Private.Fetch (Rtl.Private.Mem (_,_,exp,_), _) -> Rtl.Up.exp exp
              | _ -> e) in
            E.exp print e)
        ; printf "CMM.cut()\n"
        )
    | GR.Cbranch (rtl, t, f) ->
        let (g,_) = Interp.target'.T.branch.T.project rtl in
            ( E.exp print g
            ; printf "CMM.cbrancht('%s')\n" (snd t)
            )
    | GR.Branch (rtl, (u,l)) ->
        (match successor with
        | Some (u', l) when Unique.eq u u' -> ()
        | _ ->
            let e = Interp.target'.T.goto.T.project rtl in
            ( E.exp print e
            ; printf "CMM.goto()\n"
            ))
    | GR.Mbranch (rtl, _) ->
        let e = Interp.target'.T.goto.T.project rtl in
        ( E.exp print e
        ; printf "CMM.goto()\n"
        )

    | GR.Return (exit, rtl, _) ->
        (* THIS IS WRONG; CONT COUNT IS NOT ALWAYS EXIT NUMBER *)
        printf "CMM.cmm_return(%d,%d)\n" exit exit

    | GR.Jump (rtl, _, _) ->
        let e = Interp.target'.T.jump.T.project rtl in
            ( E.exp print e
            ; printf "CMM.cmm_tail_call()\n"
            )

    | GR.Forbidden _ -> printf "CMM.forbidden()\n" 

    | GR.Exit -> Impossible.impossible "exit node in procedure" in
@            
We specialize the fold function provided by the {\cfg} to an iterator
and apply it to all nodes.
<<interpemit.ml>>=
let proc (g, p) print =
  let printf fmt = Printf.kprintf print fmt in
  let quoted_label =
    let blockmap = G.to_blocks g in
    fun u ->
      let fail () = Impossible.impossible "interpemit: invalid annotation" in
      try match GR.blocklabel (Unique.Map.find u blockmap) with
      | Some (_, l) -> Printf.sprintf "%S" l
      | None -> fail ()
      with Not_found -> fail() in
  let emit_block block successor () =
    <<definitions of printing functions>>
    GR.fold_fwd_block first middle last block () in
  G.fold_layout emit_block () g
@    
