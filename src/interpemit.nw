
% ------------------------------------------------------------------ 
\section{Emitting Code for the Interpreter}
% ------------------------------------------------------------------ 

A procedure is translated for the interpreter by walking over its
control-flow graph and emitting code for each node. 

<<interpemit.mli>>=

val proc: Ast2ir.proc -> out_channel -> unit
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation is against the ``new'' control-flow graph module
\module{cfg.nw}.

<<interpemit.ml>>=
module C = Cfgx.M
module P = Proc
module E = Rtltolua
module T = Target2
@

\paragraph{Helper functions}.

<<interpemit.ml>>=
let fprintf = Printf.fprintf

let open_span fd = function
    | token, (Some s, offset) -> 
        fprintf fd "CMM.begin_span(%d,'%s') -- offset: %d\n"
            (Bits.S.to_int token)
            (s#mangled_text)
            (Bits.S.to_int offset)
    | token, (None  , offset) ->
        Impossible.impossible "cannot handle link-time constant in call"

let close_span fd (token,_) =
    fprintf fd "CMM.end_span(%d)\n" (Bits.S.to_int token)

let instr n =
    match C.to_executable n with
    | None      -> Impossible.impossible "expected instruction in this node"
    | Some i    -> i
@

The [[node]] function does all the work. Depending on the type of node,
code is emitted. 


<<interpemit.ml>>=
let node fd n = match C.kind n with
    | C.Join | C.Exit -> 
        List.iter (fprintf fd "CMM.define_label('%s')\n") (C.labels n)
    | C.Call ->
        let spans   = [] (* XXX fix, can't be observed at the moment *) 
        and cuts    = []
        and unwinds = []
        and returns = []
        and aborts  = false
        and e       = match C.to_executable n with
                      | None   -> Impossible.impossible "call w/o instruction"
                      | Some i -> Interp.target'.T.call.T.project i
        in
            ( List.iter (open_span fd) (List.rev spans) 
            ; E.exp fd e  
            ; fprintf fd "CMM.call({%s}, {%s}, {%s}, %s) -- %s \n"
                (String.concat "," cuts)   
                (String.concat "," unwinds) 
                (String.concat "," returns) 
                (if aborts then "1" else "0")
                "cuts, unwinds, returns, aborts"
            ; List.iter (close_span fd) spans
            ) 
    | C.CutTo ->
        ( E.rtl fd (instr n)
        ; fprintf fd "CMM.cut()\n"
        )
    | C.Cbranch ->
        let t = C.tsucc n in
        let l = C.label t in
        let i = instr n   in
        let (g,_) = Interp.target'.T.branch.T.project i in
            ( E.exp fd g
            ; fprintf fd "CMM.cbrancht('%s')\n" l
            )
    | C.Branch when C.is_br n ->
        let i = instr n in
        let e = Interp.target'.T.goto.T.project i in
            ( E.rtl fd i
            ; fprintf fd "CMM.goto()\n"
            )
    | C.Return ->
        fprintf fd "CMM.cmm_return(%d,%d)\n" 0 0    (* FIX *)

    | C.Jump ->
        let i = instr n in
        let e = Interp.target'.T.jump.T.project i in
            ( E.exp fd e
            ; fprintf fd "CMM.cmm_tail_call()\n"
            )

    | _ ->  ( match C.to_executable n with
            | None   -> ()
            | Some i -> E.rtl fd i
            )
@            


We specialize the fold function provided by the {\cfg} to an iterator
and apply it to all nodes.

<<interpemit.ml>>=
let proc p fd =
    let iter f cfg = C.fold_layout (fun node () -> f fd node) () cfg in
        iter node p.P.cfg
@    
