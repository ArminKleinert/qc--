% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4 sts=4
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% $Id$

% ------------------------------------------------------------------ 
\section{Main}\label{sect:main}
% ------------------------------------------------------------------ 

This module contains the [[main]] function that is executed when the
\C~compiler starts.  Its main purposes are command line processing,
catching of exceptions, and providing the exit code.
It is executed only for side effect, so it exports an empty interface.

<<main2.mli>>=
@

% ------------------------------------------------------------------ 
\subsection{Back End}
% ------------------------------------------------------------------ 

Because the back end is in large parts functorized it must be assembled
before it can be used. For the lack of a better place we do it here.

<<main2.ml>>=
module Reloc             = Sledlib.MkReloc
                            (struct type symbol = Symbol.t end)
module MSparcRtlEncoder  = Msparcenc.Mk(Reloc)
module MSparcRtlExpander = Sparcexpander.Make (Reloc) (MSparcRtlEncoder)
@

% ------------------------------------------------------------------ 
\subsection{Lua-Interpreter}
% ------------------------------------------------------------------ 

The compiler is controlled by an embedded Lua interpreter. Types and
values of the compiler are made available as Lua primitives and allow
the user to control the compiler. We build here an interpreter with our
extensions.

<<main2.ml>>=
module E = Error

module T    = Lua.Lib.Combine.T9                    (* types *)
                (Driver2.Export.AsmT)       (* T1 *)
                (Driver2.Export.AstT)       (* T2 *)
                (Driver2.Export.EnvT)       (* T3 *)
                (Driver2.Export.ProcT)      (* T4 *)
                (Driver2.Export.TargetT)    (* T5 *)
                (Driver2.Export.DocT)       (* T6 *)
                (Luaiolib.T)                (* T7 *)
                (Backplane.T)               (* T8 *)
                (Colorgraph.GCT)            (* T9 *)

module AsmT        = T.T1
module AstT        = T.T2
module EnvT        = T.T3
module ProcT       = T.T4
module TargetT     = T.T5
module DocT        = T.T6
module LuaioT      = T.T7
module BackplaneT  = T.T8
module ColorgraphT = T.T9

module IO = Lua.Lib.Extend (LuaioT)

module L1 = 
  Lua.Lib.Combine.L10                   (* up to 10 libraries *)
    (Luaiolib.Make (LuaioT))
    (IO (Luastrlib.M))
    (IO (Luamathlib.M))
    (Driver2.Export.MakeLib (AsmT) (AstT) (EnvT) (ProcT) (TargetT) (DocT) (LuaioT))
    (Backplane.Make  (BackplaneT) (ProcT))
    (Colorgraph.Make (BackplaneT) (ColorgraphT) (ProcT))
    (Targets.MakeLib (TargetT))
    (Placevar.Make (BackplaneT) (ProcT))
    (Linscan.Make (ProcT))
    (IO (Luautil.MakeLib))
                

module XXX = MSparcRtlExpander.Lua


module L2 = 
  Lua.Lib.Combine.L6                    (* up to 9 more libs *)
    (L1)
    (Dummyexpander.Make          (ProcT))
    (Placevar2.Make (BackplaneT) (ProcT))
    (MSparcRtlExpander.Lua       (ProcT))
    (Expander.Lua                (ProcT))
    (IO (Rtleval2.Lua)) 

module I = 
  Lua.MakeInterp                            (* our interpreter *)
    (Lua.Parser.MakeStandard)
    (Lua.MakeCore (T) (L2))

module V = I.Value
@

% ------------------------------------------------------------------ 
\subsection{Interactive Lua-Interpreter}
% ------------------------------------------------------------------ 

For extreme debugging an interactive session with the compiler's Lua
interpreter might be helpful.

<<main2.ml>>=
let run_interactive state infile =
    let prompt = "-- " in
    let msg = [ "This is Lua for QC--"
              ; "Call ``Main.dump()'' to dump name space"
              ] in
    let rec loop n pfx =
        let ()   = print_string prompt; flush stdout in
        let line = input_line infile in
        if String.length line > 0 && 
            String.get line (String.length line - 1) = '\\' then
            loop n (pfx ^ String.sub line 0 (String.length line - 1) ^ "\n")
        else
        begin
            ignore (I.dostring state (pfx ^ line ^ "\n"));
            flush stdout; flush stderr;
            loop (n+1) ""
        end
    in  try 
            ( List.iter (fun s -> print_string (prompt ^ s ^ "\n")) msg
            ; flush stdout
            ; loop 1 ""
            )
        with End_of_file -> ()
@

% ------------------------------------------------------------------ 
\subsection{Command Line Processing}
% ------------------------------------------------------------------ 

The [[main]] function gets the command line arguments and tries to parse
them.  Command line arguments are evaluated as follows:

\begin{itemize}
\item From left to right, all arguments of the form [[-]]$a$, where
$a$~is not [[e]] or [[i]], are converted to [[-e CommandLineOption.]]$a$[[()]].
\item
Any argument $a$ containing an [[=]] sign is converted to [[-e]]~$a$.
<<main2.ml>>=
let expandable_regexp = Str.regexp "-[a-zA-Z][a-zA-Z0-9_]*$"
let is_expandable opt = Str.string_match expandable_regexp opt 0
let rec expand_args = function
  | "-e" :: a :: args -> "-e" :: a :: expand_args args
  | "-i" :: args      -> "-i" :: expand_args args
  | opt  :: args when is_expandable opt ->
        "-e" :: ("CommandLineOption." ^ String.sub opt 1 (String.length opt - 1) ^ "()") 
             :: expand_args args
  | opt  :: _   when String.get opt 0 = '-' -> 
        E.error ("Unrecognized option " ^ opt)
  | a    :: args when String.contains a '=' ->
        "-e" :: a :: expand_args args
  | a    :: args      -> a :: expand_args args
  | []                -> []
@                
\item From left to right, all arguments to [[-e]] are collected.
\item When the next command line argument is [[-i]]:
    \begin{itemize}
    \item All remaining arguments are passed to Lua as [[Sys.argv]]. 
    \item The collected arguments to [[-e]] are evaluated from left to right. 
    \item The interpreter reads input from stdin.
    \end{itemize}
\item When the next command line argument is not [[-e]]:
    \begin{itemize}
    \item All remaining arguments are passed to Lua as [[Sys.argv]]. 
    \item The collected arguments to [[-e]] are evaluated from left to right. 
    \end{itemize}
\end{itemize}

We export some command line arguments to the Lua value [[Sys.argv]]. The
[[Sys]] table is created, if it does not exist. 
<<main2.ml>>=
let export_argv g strings =
    let list = V.list V.string in
    ( I.register_module "Sys" ["argv", list.V.embed strings] g
    )
@

At start-up, we load the file [[qc--.lua]] into the interpreter. It
defines commonly used functions. Later we will compile the corresponding
string into the compiler such that it is always available. During
development it is easier to have an external file.
<<main2.ml>>=
let main () =
    let argv        = Array.to_list Sys.argv in
    let this        = Filename.basename (List.hd argv) in
    let args        = List.tl argv in
    let args        = expand_args args in
    let usage       = "usage: " ^ this ^ " -e 'arg' [arg arg ..]" in
    let state       = I.mk () in (* fresh Lua state *)       
    let evaluate e  = ignore (I.dostring state e) in
    let ()          = I.register_module "Boot"  (* build Boot table *)
                        ["qc--.lua" , V.String This.boot] state in
    let bootscript  = "Util.dosearchfile('qc--.lua', Boot)" in
        try 
            let rec loop todo = function
                | ("-e"::code::args) -> loop (code::todo) args
                | ["-e"] -> E.error usage
                | ("-i"::args) -> 
                    ( export_argv state args
                    ; List.iter evaluate (List.rev todo)
                    ; run_interactive state stdin
                    )
                | args -> 
                    ( export_argv state args
                    ; List.iter evaluate (List.rev todo)
                    )
            in
                ( evaluate bootscript       (* boot interpreter *)
                ; loop [] args              (* cmdline *)
                )
        with
            E.ErrorExn(msg) -> 
                ( E.errorPrt msg
                ; E.errorPrt "Exit with exit code 1" 
                ; exit 1  (* failure *)
                )
@                

In \ocaml~no [[main]] function like in C exists but simply all values
in a module are evaluated.  However, we simulate this by evaluating
[[main ()]]. 

<<main2.ml>>=
let _ = main ()
@

During development bugs are easier to find with the debugger if we
don't catch exceptions on the top-level. Shipping code, however,
should use instead the following:

<<main2.ml unused>>=
let _ = try main () with e -> 
        ( Printf.eprintf "%s\n" (Printexc.to_string e)
        ; Printf.eprintf "Please report this problem to bugs@cminusminus.org\n"
        ; Printf.eprintf "Exit with exit code 2\n"
        ; exit 2
        )
@

% ------------------------------------------------------------------ 
\section{Lua Startup Script}
% ------------------------------------------------------------------ 

When the compiler starts, it looks for the Lua script  [[qc--.lua]] in
the actual directory.

THIS SCRIPT SHOULD BE BROKEN UP INTO PIECES, AND MANY OF THE PIECES
SHOULD BE FARMED OUT TO OTHER MODULES.  FOR EXAMPLE, THE
REGISTER-ALLOCATION PIECES SHOULD WIND UP IN colograph.lua.\footnote
{Note to self: ``It's time to break up \texttt{stan.c}, Stan.''}
<<qc--.lua>>= 
$debug 1

-- 
-- $Id$
------------------------------------------------------------------ 
-- The Lua interpreter in the qc-- compiler loads this program 
-- at startup. Command line arguments of the qc-- compiler later call
-- functions defined here. To obtain the actual start-up code from 
-- the compiler, run "qc-- -script".
------------------------------------------------------------------ 
    
------------------------------------------------------------------ 
-- Dump (inspect Lua name space)
-- This code comes first such that we have it available for problems
-- with the subsequent code.
------------------------------------------------------------------ 

-- dump
-- dumps the entire name space of the Lua interpreter to see what is
-- there

Dump = Dump or {}

function Dump.vars ()
    local s
    local key,val = nextvar(nil)
    while key do
        s = format ("%-40s%s\n",key, type(val))
        write (s)
        if type(val) == "table" then Dump.table (key .. ".", val) end
        key,val = nextvar(key)
    end
end    

function Dump.table (name,table)    -- helper for Dump.vars 
    local key,val = next(table,nil)
    local s
    while key do
        s = format("%-40s%s\n", name .. key, type(val))
        write(s)
        if type(val) == "table" then 
            Dump.table (name .. key .. ".", val) 
        end
        key,val = next(table,key)
    end
end

-- Dump the builtin Lua script to stdout such that the user can study 
-- and alter it.

function Dump.script ()
    write(Boot["qc--.lua"])
end    
@ 
<<qc--.lua>>= 
Util = Util or { }
function Util.funname(x)
  local i, v, ii, vv
  -- search global tables for x
  i, v = nextvar(nil)
  while i ~= nil do
    if type(v) == "table" then
      ii, vv = next(v, nil)
      while ii ~= nil do
        if vv == x then
          return i .. "." .. ii
        else
          ii, vv = next(v, ii)
        end
      end
    end
    i, v = nextvar(i)
  end
  -- search globals for x
  i, v = nextvar(nil)
  while i ~= nil do
    if v == x then
      return i
    else
      i, v = nextvar(i)
    end
  end
  return nil
end
@ 
@ 
Register-allocation support is elsewhere.
<<qc--.lua>>= 
<<Lua startup code for [[Colorgraph]] module>>
@ 
<<qc--.lua>>= 
B = Backplane

------------------------------------------------------------------ 
-- Linear-Scan Register Allocator
------------------------------------------------------------------ 

Linscan = Linscan or {}
Linscan.scan = B.stage { name="linscan", fn = Linscan.allocate }
@ 
The Caml code exports mostly functions, but we want stages.
Because the embedding/projection pairs have no access to interpreter
state, we can't easily discover the name of a function.
Accordingly, we patch things here.
<<qc--.lua>>= 
------------------------------------------------------------------ 
-- Stage patching
------------------------------------------------------------------ 

function Util.make_stage(t, short, long)
  if type(t[short]) == 'function' then
    t[short] = B.stage { name=long, fn = t[short] }
  end
end

Util.make_stage(Placevar, 'fortran', "fortran variable placer")
Util.make_stage(Expander, 'dummy',   'dummy expander')
Util.make_stage(Expander, 'sparc',   'sparc expander')
Util.make_stage(Driver,   'freeze',  'freeze stack frame')
@ 
Some additional thought needs to be given to how [[Default]]
should work.
It would be pleasant if a great many simple
reconfigurations could be done simply by assigning to an element of
the [[Default]] table.
(But maybe they'll be done by assigning to [[backend]] instead.)
<<qc--.lua>>= 
------------------------------------------------------------------ 
-- Defaults (independent of target)
------------------------------------------------------------------ 

Default = Default or {}

Default.linewidth = 72          -- for text assembler
Default.solaris   = not nil     -- for sparc
Default.allocator = CG.color 
@ 
How to do some old-world things in the new world:
\begin{itemize}
\item
To exercise the SPARC expander, instead of using the former [[Opt.sparc]],
assign [[backend.expand=Expander.sparc]] and
[[backend.target=Targets.sparc]] and
[[backend.asm=Targets.sparc_asm]].
\item
To exercise the SPARC expander in debugging mode, instead of using the
former [[Opt.sparc_dbg]], assign [[backend.expand=Expander.sparc]] and
[[backend.target=Targets.sparc]].
\item
To exercise the toy code expander, assign 
[[backend.expand=Expander.toy]].
\item
To emit dot output, assign [[backend.asm=Asm.dot]].
\item
To turn off any stage for debugging (e.g., to see code or dot output),
assign [[nil]] to that stage.
\item
To check only, without emitting, assign [[backend.emit=nil]].
\item
To emit ASDL, assign [[backend.asm=Asm.asdl]].
\end{itemize}
\emph{It still remains to be done to try these cases out and add them
to the test suite.}
@ 
The [[Target]] and [[Targets]] stuff is still confusing.
In particular, it's not clear what's the most convenient way to manage
the interactions between a ``target'' and a ``backend.''
<<qc--.lua>>= 
------------------------------------------------------------------ 
-- Our Targets. Each target holds an assembler back end, an optimizer
-- and a primitive value that describes details like byte order and
-- sizes.
------------------------------------------------------------------ 

-- Targets has two primitive entries defined in OCaml: "dummy", "sparc"
Targets = Targets or {}

-- helper function
function Targets.sparc_asm(io) -- helper, Lua 2.5 has no lambda functions
    return Asm.sparc(Default.solaris,io)
end    
@ 
The modules [[Main]] and [[Util]] might be merged?
<<qc--.lua>>=
------------------------------------------------------------------ 
-- Main
-- High-level functions
------------------------------------------------------------------ 

Main = Main or {}

function Main.getfile ()
    if Sys.argv[1] == nil then
        error ("expected file on command is line missing")
    elseif Sys.argv[1] ~= nil and Sys.argv[2] ~= nil then
        error ("cannot compile more than one file at a time")
    else
        return Sys.argv[1]
    end
end    

function Main.pp (file) -- pretty print AST
    local ast = Driver.parse(file)
    local doc = Driver.pretty(ast)
    Driver.print(doc,Default.linewidth)
end  
@ 
The functions below define the command line options. The command line
option [[-x]] calls [[CommandLineOption.x]], hence option [[-dot]] calls
[[CommandLineOption.dot]] and so forth.
<<qc--.lua>>= 
------------------------------------------------------------------ 
-- CommandLineOption
-- Functions called directly by command-line option
------------------------------------------------------------------ 

CommandLineOption = CommandLineOption or { }

CLO = CommandLineOption

function CLO.c     ()  Main.newcompile(backend, Main.getfile()) end
function CLO.dot   ()  backend.asm = Asm.dot; CLO.c()           end
function CLO.check ()  backend.emit = nil;    CLO.c()           end
function CLO.pp    ()  Main.pp(Main.getfile())                  end
CLO.dump   =  Dump.vars
Main.dump  =  Dump.vars
CLO.script =  Dump.script
function CLO.sparc () -- wildly untested
  backend.expand=Expander.sparc
  backend.target=Targets.sparc
  backend.asm=Targets.sparc_asm
  CLO.c()
end
@
A backend is represented by a table that contains the following
fields:\\
\begin{tabularx}{\linewidth}{@{}lX@{}
[[target]]&  
  The target.  What's here and why it has to be here is a bit fuzzy,
  but I think at minimum it is used to check to see that the {\PAL}
  source code uses the same assumptions as the target machine.
\\
[[emit]]&
  An assembly emitter.  The only reason to mess with this would be to
  set it to [[nil]], which would stop the compiler from emitting
  code.  Presto!  The compiler is now checks syntax and semantics.
  (To suppress code generation would require turning off all the
  passes as well.)
\\
\emph{passes}&
  The backend must contain the following standard set of passes:
  [[widen]], [[placevars]], [[expand]], [[liveness]], [[ralloc]],
  [[freeze]], and [[asm]].  (The names are supposed to be verbs, and
  most of them are.)  Each pass is a stage in the optimization
  backplane.
  Any pass can be turned off by assigning [[nil]]
  to it.
\\
\end{tabularx}
<<qc--.lua>>=
------------------------------------------------------------------ 
-- Backend
------------------------------------------------------------------ 
Stages = Stages or { }
function Stages.nullf () return nil end
Stages.null = B.stage { name="empty stage", fn = Stages.nullf }

Backend = Backend or { }

Backend.debug =     --- debugging back end
  { target    = Targets.dummy
  , widen     = Stages.null
  , placevars = Placevar.fortran
  , expand    = Expander.toy
  , liveness  = Stages.null
  , ralloc    = CG.color
  , freeze    = Driver.freeze
  , asm       = Asm.cmm
  , emit      = Driver.assemble
  }   

Backend.old =     --- compatible with old back end
  { target    = Targets.dummy
  , widen     = Stages.null
  , placevars = Placevar.fortran
  , expand    = Expander.dummy
  , liveness  = Stages.null
  , ralloc    = Default.allocator
  , freeze    = Driver.freeze
  , asm       = Asm.cmm
  , emit      = Driver.assemble
  }   

function run_assembler(self)
  Driver.assemble(self.asm)
  return nil -- don't repeat in fixed point (didn't change the program)
end

function assembler_stage(asm)
  return B.stage  { name = "assembler " .. Util.funname(asm)
                  , fn = { asm = asm, apply = run_assembler }
                  } 
end
                
@ 
The standard optimizer simply runs the standard passes in the standard
sequence.
<<qc--.lua>>=
------------------------------------------------------------------ 
-- Opt -- the standard optimizer
------------------------------------------------------------------ 
Opt = Opt or { }

function Opt.standard(backend, asm)
  local x = B.seq
    { backend.widen      or Stages.null
    , backend.placevars  or Stages.null
    , backend.expand     or Stages.null
    , backend.liveness   or Stages.null
    , backend.ralloc     or Stages.null
    , backend.freeze     or Stages.null
    , B.stage { name="assemble procedure", fn = Driver.proc_assembler(asm) }
    } 
  return x
end

function Main.run_optimizer(self, proc)
  B.run(self.action, proc)
end

function Main.newcompile(backend, file)
    local ast = Driver.parse(file) 
    local asm = backend.asm(Driver.stdout) 
    local env = Driver.check(ast,asm) -- asm is stored in env
    local opt = { apply = Main.run_optimizer, action = Opt.standard(backend, asm) }
    Driver.compilec(opt, ast, backend.target, env)
    if backend.emit then backend.emit(asm) end
end    

backend = Backend.old
@
% ------------------------------------------------------------------  
\section{Manual Page}
% ------------------------------------------------------------------  

Writing manual pages for the Troff formatter is a tedious job.  I have
found the highly readable \textit{plain old document} (\textsc{pod})
format used by the Perl community very helpful.  Every Perl
installation comes with a \texttt{pod2man} tool which creates a man
page from \textsc{pod} file.  Today we can assume that Perl is
installed nearly everywhere such that the use of this tool does not
spoil portability of our code.

The format of \textsc{pod} files is documented in the \texttt{perlpod}
manual page.  Besides the \texttt{pod2man} filter there exist other
filters to convert a \textsc{pod} file to \textsc{html} and \LaTeX,
which makes it a very versatile format.

<<qc--.pod>>=
=head1 NAME

qc-- - the Quick C-- compiler

=head1 SYNOPSIS

B<qc--> [[B<-e>] I<command>] [[B<-e>] I<command>] [I<arg> I<arg> ...] 

B<qc--> [[B<-e>] I<command>] [[B<-e>] I<command>] B<-i> [I<arg> I<arg> ...] 

=head1 DESCRIPTION

B<qc--> compiles C-- code. The compiler 
does not yet produce executable code, but it checks 
syntax and static semantics.  The grammar is described in L<"GRAMMAR">. 

B<qc--> is controlled by a built-in Lua interpreter (Version 2.5). 
Many compiler phases are available as Lua primitives,
and the compiler can be reconfigured dynamically by Lua commands on the command line. 
Most command-line options are executed by the Lua interpreter, not by the
directly.

On startup, B<qc--> proceeds as follows:

=over

=item 1.

Divide the command line into I<command>s and I<arg>s.
Loosely speaking, a I<command> is identified because it begins with a minus sign,
it is preceded by B<-e>, or it contains an B<=> sign.
An I<arg> is anything else.

=item 2.

Place the I<arg>s in the vector B<Sys.argv> in the Lua interpreter.

=item 3.

Search for the file F<qc--.lua> as described below (B<LUA STARTUP>)
and execute it.

=item 4.

Execute the I<command>s one by one in order of appearance.
Most likely one I<command> does something useful with the contents of B<Sys.argv>. 

=back

=head1 OPTIONS

Except for B<-e> and B<-i>, which can be thought of as ``meta-options,'' 
every option is executed by the Lua interpreter.

=over

=item B<-e> I<command>

The I<command> is passed to the Lua interpreter and I<evaluated>. This
option can be repeated.

=item I<command>

The I<command> must contain an B<=> sign to be identifiable 
as a I<command> and not an I<arg>.
The I<command> is passed to the Lua interpreter and I<evaluated>. 

=item B<-i> 

Starts an I<interactive> session with the interpreter that reads from
stdin. All command-line arguments to the right of B<-i> are considered
as generic I<arg> arguments that are passed to the Lua interpreter in
the B<Sys.argv> table.  Therefore, B<-i -e> I<arg> does not evaluate
I<arg> but passes B<-e> and I<arg> in the table B<Sys.argv>.

=item B<->I<x>

The option is equivalent to B<-e 'CommandLineOption.>I<x>B<()'> and thus executes the
function B<CommandLineOption.>I<x>. 
N.B. I<x> may be any string except B<e> or B<i>.
The Lua code defines some standard options, which will be documented here one day.
Meanwhile there are examples below.

=item I<arg> ...

The first argument that does not begin with B<-> and does not contain B<=>
starts the
sequence of arguments. They are placed in the
B<Sys.argv> table for the Lua interpreter.

=back

=head1 EXAMPLES

=over 

=item B<qc-->  B<-e> B<'CommandLineOption.c()'> I<file.c-->

Compile I<file.c--> for the B<Default.target>.

=item B<qc--> B<-c> I<file.c-->

Same as before, because C<-c> is equivalent to C<-e 'CommandLineOption.c()'>.

=item B<qc--> B<-e> B<'CommandLineOption.check()'> I<file.c-->

Check the static semantic of I<file.c-->. Could be also called as
C<-check> I<file.c-->.

=back

=head1 HIGH-LEVEL LUA FUNCTIONS

The following functions are intended to be called from the B<qc-->
command line. For most of them a one-letter alias I<x> exists such that
they can be called using the B<->I<x> notation explained above in
L<OPTIONS>.

=over

=item B<CommandLineOption.check()>

Check static semantic of file named as first command line argument. Does
a type check, but generates no code.  
I<LEGACY OPTION; MAY DISAPPEAR.  ASSIGN> B<backend.emit=nil> I<INSTEAD.>

=item B<CommandLineOption.c()>

Compiles the file named as the first command line argument. Uses Lua
defaults for the targets, optimizer, and assembler. Emits to stdout.

=item B<CommandLineOption.dot()>

Compiles the file named as the first command line argument and emits the
control flow graph of each procedure as a B<dot> diagram to stdout.
Uses Lua defaults for the targets, optimizer, and assembler. 
I<LEGACY OPTION; MAY DISAPPEAR.  ASSIGN> B<backend.asm=Asm.dot> I<INSTEAD.>


=item B<CommandLineOption.asdl()>

Compiles the file named as the first command line argument and each
procedure in ASDL format to stdout.  Uses Lua defaults for the targets,
optimizer, and assembler. 
I<LEGACY OPTION; MAY DISAPPEAR.  ASSIGN> B<backend.asm=Asm.asdl> I<INSTEAD.>

=item B<CommandLineOption.sparc()>

Compiles the file named as the first command line argument to I<SPARC>
assembly code and emits it to stdout.  Uses Lua defaults for the
targets, optimizer, and assembler. 
Will certainly change in the future.

=back


=head1 LUA STARTUP

To find the Lua startup file F<qc--.lua>, B<qc--> takes the following
steps: It reads the contents of the environment variable B<QCMMLUAPATH>
as a search path. If the environment variable is undefined, the default
is "B<:.:*>". A search path contains a list of colon separated
directories. Two directory names are special: the empty directory refers
to an implementation-dependent system-wide directory, like
B</usr/local/lib/qc-->. The star B<*> refers to a ``directory'' that is 
actually compiled into the B<qc--> executable. 
With the default search path, B<qc-->
therefore looks first in the system-wide directory for F<qc--.lua>, then
in the current directory, and then takes the built-in F<qc--.lua>. 

=head1 LUA CODE AND VARIABLES

The Lua startup code that is embedded into the compiler is accessible
from the Lua interpreter itself. The table B<Boot> is treated as as
the directory B<*> in the B<QCMMLUAPATH> as explained above and
therefore B<Boot["qc--.lua"]> contains the embedded Lua code. You can
dump it to stdout using the following command line. This is also a good
way to check what command line options are available in case this manual
page is not up to date.

    qc-- -script > qc--.lua  

When you alter the file F<qc--.lua> and use the default B<QCMMLUAPATH>
environment variable, B<qc--> will read it at startup and execute it
instead of the builtin script from B<Boot>. This is a good way to play
with customized Lua code.

To get an idea what functions and variables are defined, dump the name
space of the Lua interpreter using the following command
line:

    qc-- -dump  | sort 


=head1 LUA TYPES

In addition to the six Lua core-types the Lua interpreter in the
B<qc--> compiler offers the following types that represent internal
compiler data structures:

=over 12

=item I<asm>

Assembler

=item I<ast>

C-- abstract syntax

=item I<env>

Symbol table

=item I<proc>

Back-end representation of a procedure

=item I<doc>

Printable output

=item I<target>

Target architecture

=item I<optimize>

Code optimizer

=item I<io>

File handle for input or output

=item I<inchan>

Input channel

=item I<outchan>

Output channel

=back

=head1 LUA TARGETS

=over

=item B<Targets.dummy>. A I<target> value for our only current target.

=back

=head1 LUA DRIVER FUNCTIONS 

The B<qc--> compiler is controlled by functions that consume and produce
the above types. However, these functions are usually not called
directly. Instead, higher-level Lua functions as part of the Lua startup
script are invoked from the command line.
In other words, B<this section is for compiler hackers only>.

=over

=item B<Driver.version>(). Prints version information and
copyright to stdout.


=item B<Driver.scan>(I<string>). Takes a file name, scans it and prints
all tokens to stdout. This is only useful to debug the scanner.

=item B<Driver.parse>(I<string>). Takes a file name and parses the file
as a B<C--> program. Returns its abstract syntax as an I<ast> value.

=item B<Driver.emit_asdl>(I<ast>). Emits an abstract syntax I<ast> to
stdout in ASDL format.  The ASDL format is a cross-platform
cross-compiler format to exchange an abstract syntax.  

=item B<Driver.check>(I<ast>). Takes an abstract syntax I<ast> and checks
its static semantics. Returns a symbol table I<env> upon success.

=item B<Driver.pretty>(I<ast>). Returns a printable I<doc> value of an
I<ast>. 

=item B<Driver.compilec>(I<optimize>, I<ast>, I<target>, I<env>).
Compiles an I<ast> for a I<target>, using symbol table I<env>. Returns
an assembly program I<asm>. The function B<compilec> passes every C--
procedure to B<optimize>.
(Replaces the obsolete function B<Driver.compile>.  Both should be renamed 
once experiments are finished and revision is complete.)

=item B<Driver.assemble>(I<asm>). Emits an assembler program.

=item B<Driver.print>(I<doc>, I<number>). Formats I<doc> for a line width
of I<number> characters and prints it to stdout.

=item B<Asm.cmm>(I<io>). Creates an assembler that emits C-- code.

=item B<Asm.dot>(I<io>). Creates an assembler that emits B<dot> output.

=item B<Asm.sparc>(I<bool>,I<io>). Creates an assembler that emits output
for the I<SPARC> assembler. The boolean flag is false (zero) on SunOS
systems.  I<(Is falsehood zero or nil???)>

=back

=head1 ENVIRONMENT

B<QCMMLUAPATH>: search path for Lua scripts loaded by B<qc-->; default
B<:.:*>. 

=head1 EXIT CODE

The B<qc--> compiler returns with exit code 0 of successful
operation.  In case of errors in a source file B<qc--> returns with
exit code 1.  Any internal compiler error leads to exit code 2.

=head1 SEE ALSO

I<dot(1)>.

http://www.cminusminus.org/, 
http://www.lua.org/,
http://www.cs.princeton.edu/zephyr/ASDL/,
http://www.research.att.com/sw/tools/graphviz/.

=head1 AUTHORS

Christian Lindig <lindig@eecs.harvard.edu>, 
Norman Ramsey <nr@eecs.harvard.edu>,
Daniel Damian <damian@eecs.harvard.edu>,
John Dias <dias@eecs.harvard.edu>,
Jonathan D. Eddy <eddy@fas.harvard.edu>.
@
          
      
% ------------------------------------------------------------------  
\section{Grammar Manual Page}
% ------------------------------------------------------------------  

<<qc--grammar.pod>>=
=head1 NAME

qc--grammar - the c-- grammar recognized by qc--(1).

=head1 DESCRIPTION

During the development of the compiler it happens easily that the
documentation of the C-- language and the language recognized by the
compiler differ.  To give at least a hint about the language
recognized by the implementation its grammar is presented here.  The
grammar is created automatically from the implementation such that
errors are less likely.  However, the grammar comes without any
further explanation.  It is only meant as a least resort when the
implementation reports an otherwise unexplainable parse error.

##grammar##


=head1 SEE ALSO

http://www.cminusminus.org/, 
http://www.cs.princeton.edu/zephyr/ASDL/

=head1 AUTHORS

Christian Lindig <lindig@eecs.harvard.edu> 
Norman Ramsey <nr@eecs.harvard.edu>
Daniel Damian <damian@eecs.harvard.edu>
John Dias <dias@eecs.harvard.edu>
Jonathan D. Eddy <eddy@fas.harvard.edu>
@
          
      
% ------------------------------------------------------------------  
\section{This}
% ------------------------------------------------------------------  

To include some version information into the main binary we provide the
[[This]] module.  Its source code [[this.ml]] is created during the
build process from [[this.in]].  Currently only the version information
stays here but it is a useful place for other informations that change
frequently.  Note, that version informations  should \emph{not} be used
to control the behavior of the program.  We therefore write all these
informations to a stream to emphasize this.

At startup the compiler executes a file [[qc--.lua]] in the Lua
interpreter. One version of this file is compiled into the binary as
[[This.boot]].

<<this.mli>>=
val name    : out_channel -> unit
val version : out_channel -> unit 
val boot    : string (* contents of "qc--.lua" *)
@

Here is the implementation. The golory details are also in the [[mk]]
file in this directory.

<<this.in>>=
(* Do not edit - this file is created from this.in through mk(1) 
 * If this file does not compile, check the following files:
 * (1) main2.nw - this.in is defined here
 * (2) mkfile target this.ml - constructs the boot string
 *)

let system          = "@this@"
@

The functions [[name]] and [[version]] decompose the [[system]]
string to get its name and version. 

<<this.in>>=
let name channel = 
    let s = try let minus = String.index system '-' in
                String.sub system 0 minus
            with Not_found -> "not configured"
    in
         output_string channel s

<<this.in>>=
let version channel = 
    let s = try let minus = String.rindex system '-' in
                String.sub system (minus+1) (String.length system - minus - 1)
            with Not_found -> "not configured"
    in
        output_string channel s
@


