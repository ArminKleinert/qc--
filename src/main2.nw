% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml

% ------------------------------------------------------------------ 
\section{Main}\label{sect:main}
% ------------------------------------------------------------------ 

This module contains the [[main]] function that is executed when the
\C~compiler starts.  Its main purposes are command line processing,
catching of exceptions, and providing the exit code.
It is executed only for side effect, so it exports an empty interface.

<<main2.mli>>=
@

% ------------------------------------------------------------------ 
\subsection{Lua-Interpreter}
% ------------------------------------------------------------------ 

The compiler is controlled by an embedded Lua interpreter. Types and
values of the compiler are made available as Lua primitives and allow
the user to control the compiler. We build here an interpreter with our
extensions.

<<main2.ml>>=
module T    = Lua.Lib.Combine.T9                         (* types *)
                (Driver2.Export.AsmT)       (* T1 *)
                (Driver2.Export.AstT)       (* T2 *)
                (Driver2.Export.EnvT)       (* T3 *)
                (Driver2.Export.ProcT)      (* T4 *)
                (Driver2.Export.TargetT)    (* T5 *)
                (Driver2.Export.DocT)       (* T6 *)
                (Luaiolib.T)                (* T7 *)
                (Backplane.T)               (* T8 *)
                (Colorgraph.GCT)            (* T9 *)

module IO   = Lua.Lib.Extend (T.T7)

module L    = Lua.Lib.Combine.L8                        (* libraries *)
                (Luaiolib.Make (T.T7))
                (IO (Luastrlib.M))
                (IO (Luamathlib.M))
                (Driver2.Export.MakeLib (T.T1) (T.T2) (T.T3) (T.T4) 
                                        (T.T5) (T.T6))
                (Backplane.Make  (T.T8) (T.T4))
                (Colorgraph.Make (T.T8) (T.T9) (T.T4))
                (Targets.MakeLib (T.T5))
                (Placevar.Make (T.T8) (T.T4))
                
module I    = Lua.MakeInterp                            (* our interpreter *)
                (Lua.Parser.MakeStandard)
                (Lua.MakeCore (T) (L))
@

% ------------------------------------------------------------------ 
\subsection{Interactive Lua-Interpreter}
% ------------------------------------------------------------------ 

For extreme-debugging an interactive session with the compiler's Lua
interpreter might be helpful.

<<main2.ml>>=
let run_interactive state infile =
    let rec loop n pfx =
        let line = input_line infile in
        if String.length line > 0 && 
            String.get line (String.length line - 1) = '\\' then
            loop n (pfx ^ String.sub line 0 (String.length line - 1) ^ "\n")
        else
        begin
            ignore (I.dostring state (pfx ^ line ^ "\n"));
            flush stdout; flush stderr;
            loop (n+1) ""
        end
    in  try loop 1 "" with End_of_file -> ()
@

% ------------------------------------------------------------------ 
\subsection{Command Line Processing}
% ------------------------------------------------------------------ 

The [[main]] function gets the command line arguments and tries to
parse them. We expect a single string argument that is evaluated by the
Lua interpreter.

<<main2.ml>>=
module E = Error
module V = I.Value
@

We add members  to an existing or new Lua table [[tabname]] with
[[bind_table]]. The table is created, if it does not already exist.

<<main2.ml>>=
let bind_table g tabname members =
  let t = I.getglobal g (V.String tabname) in
  let t = match t with
  | V.Nil       -> V.Table.create (List.length members)
  | V.Table t   -> t
  | _           -> I.error g ("Global value " ^ tabname ^ " is not a table") in
  let _ = V.Table.bind g.V.globals (V.String tabname) (V.Table t) in
      List.iter (fun (k, v) -> V.Table.bind t (V.String k) v) members
@ 


We export some command line arguments to the Lua value [[Sys.argv]]. The
[[Sys]] table is created, if it does not exist.

<<main2.ml>>=
let export_argv g strings =
    let list = V.list V.string in
    bind_table g "Sys" ["argv", list.V.embed strings]
@

At start-up, we load the file [[qc--.lua]] into the interpreter. It
defines commonly used functions. Later we will compile the corresponding
string into the compiler such that it is always available. During
development it is easier to have an external file.

Command line arguments are evaluated as follows:

\begin{itemize}
\item From left to right, all arguments of the form [[-]]$a$, where
$a$~is not [[e]] or [[i]], are converted to [[-e Main.]]$a$[[()]].
<<main2.ml>>=
let expandable_regexp = Str.regexp "-[a-zA-Z0-9_]$"
let is_expandable opt = Str.string_match expandable_regexp opt 0
let rec expand_args = function
  | "-e" :: a :: args -> "-e" :: a :: expand_args args
  | "-i" :: args -> "-i" :: expand_args args
  | opt  :: args when is_expandable opt ->
      "-e" :: ("Main." ^ String.sub opt 1 (String.length opt - 1) ^ "()") ::
      expand_args args
  | a :: args -> a :: expand_args args
  | [] -> []
@                
                                       
\item From left to right, all arguments to [[-e]] are collected.
\item When the next command line argument is [[-i]]:
    \begin{itemize}
    \item All remaining arguments are passed to Lua as [[Sys.argv]]. 
    \item The collected arguments to [[-e]] are evaluated from left to right. 
    \item The interpreter reads input from stdin.
    \end{itemize}
\item When the next command line argument is not [[-e]]:
    \begin{itemize}
    \item All remaining arguments are passed to Lua as [[Sys.argv]]. 
    \item The collected arguments to [[-e]] are evaluated from left to right. 
    \end{itemize}
\end{itemize}

<<main2.ml>>=
let main () =
    let argv        = Array.to_list Sys.argv in
    let this        = Filename.basename (List.hd argv) in
    let args        = List.tl argv in
    let args        = expand_args args in
    let usage       = "usage: " ^ this ^ " -e 'arg' [arg arg ..]" in
    let state       = I.state () in (* fresh Lua state *)       
    let evaluate e  = ignore (I.dostring state e) in
        try 
            let rec loop todo = function
                | ("-e"::code::args) -> loop (code::todo) args
                | ["-e"] -> E.error usage
                | ("-i"::args) -> 
                    ( export_argv state args
                    ; List.iter evaluate (List.rev todo)
                    ; run_interactive state stdin
                    )
                | args -> 
                    ( export_argv state args
                    ; List.iter evaluate (List.rev todo)
                    )
            in
                ( ignore(I.dofile state "qc--.lua")     (* startup *)
                ; loop [] args                          (* cmdline *)
                )
        with
            E.ErrorExn(msg) -> 
                ( E.errorPrt msg
                ; E.errorPrt "Exit with exit code 1" 
                ; exit 1  (* failure *)
                )
@                

In \ocaml~no [[main]] function like in C exists but simply all values
in a module are evaluated.  However, we simulate this by evaluating
[[main ()]]. 

<<main2.ml>>=
let _ = main ()
@

During development bugs are easier to find with the debugger if we
don't catch exceptions on the top-level. Shipping code, however,
should use instead the following:

<<main2.ml unused>>=
let _ = try main () with e -> 
        ( Printf.eprintf "%s\n" (Printexc.to_string e)
        ; Printf.eprintf "Please report this problem to bugs@cminusminus.org\n"
        ; Printf.eprintf "Exit with exit code 2\n"
        ; exit 2
        )
@

% ------------------------------------------------------------------ 
\section{Lua Startup Script}
% ------------------------------------------------------------------ 

When the compiler starts, it looks for the Lua script  [[qc--.lua]] in
the actual directory.

<<qc--.lua>>=
------------------------------------------------------------------ 
-- Optimizer
-- I think these functions should go into Optimize or a similar name
-- space --CL
------------------------------------------------------------------ 

function mkS (nm, f)
    return { name = nm
           , fn = f
           } end

-- Here, liveness and the other second args to "mkS" are the Caml functions
-- that have been embedded into Lua.

CGStages = { liveness = mkS("liveness", CG.liveness)
           , build = nil -- build should be added by calling makeBuild
           , makeWorklist = mkS("makeWorklist", CG.makeWorklist)
           , simplify = mkS("simplify", CG.simplify)
           , coalesce = mkS("coalesce", CG.coalesce)
           , freeze = mkS("freeze", CG.freeze)
           , selectSpill = mkS("selectSpill", CG.selectSpill)
           , assignColors = mkS("assignColors", CG.assignColors)
           , haveSpilledNodes = mkS("haveSpilledNodes", CG.haveSpilledNodes)
           , rewriteProgram = mkS("rewriteProgram", CG.rewriteProgram)
           , applyColors = mkS("applyColors", CG.applyColors)
		   , printCG = mkS("printCG", CG.printCG)
		   , printCFGLive = mkS("printCFGLive", CG.printCFGLive)
           }

function makeBuild (colors)
    CGStages.build = mkS("build", CG.makeBuild(colors)) end

CodeExpandStages = { placeVars = mkS("placeVars", PV.placeVars)
                   , expander  = mkS("expander", PV.expander)
                   }

codeExpand = seq({ single(CodeExpandStages.placeVars)
                 , single(CodeExpandStages.expander)
                 })

placeVars = single(CodeExpandStages.placeVars)

pcg = ignore(single(CGStages.printCG))
prLive = ignore(single(CGStages.printCFGLive))
plive = seq({single(CGStages.liveness), single(CGStages.printCFGLive)})
live = single(CGStages.liveness)

function graphColoring (colors)
  makeBuild(colors);
  return
     share(initInfo, "cgInfo",
        seq({fix(
               seq({ignore(seq(
                      { single(CGStages.liveness)
, prLive
                      , single(CGStages.build)
, pcg
                      , single(CGStages.makeWorklist)
                      , fix(
                          unless_do(single(CGStages.simplify),
                                    unless_do(single(CGStages.coalesce),
                                       unless_do(single(CGStages.freeze),
                                          single(CGStages.selectSpill)))))
                      , single(CGStages.assignColors)}))
                   , when_do(single(CGStages.haveSpilledNodes),
                             single(CGStages.rewriteProgram))
                   }))
          , single(CGStages.applyColors)
          }))
    end

function fullRun (colors) 
    return seq({codeExpand, graphColoring(colors)}) end
prCFG = seq({codeExpand, live})

colors = {1,2,3,4}

Optimize = Optimize or {}
function Optimize.default (cfg, frame) run(graphColoring(colors), cfg, {}) end
function Optimize.default (cfg, frame) run(codeExpand, cfg, {}) end
function Optimize.default (cfg, frame) run(fullRun(colors), cfg, {}) end
--function Optimize.default (cfg, frame) run(prCFG, cfg, {}) end
-- function Optimize.default () return end

------------------------------------------------------------------ 
-- Defaults
------------------------------------------------------------------ 

Default = Default or {}
Default.target          = Targets.dummy          -- target
Default.optimizer       = Optimize.default
Default.linewidth       = 72                     -- output line width

------------------------------------------------------------------ 
-- Main
-- High-level functions the user is most likely to use
------------------------------------------------------------------ 

Main = Main or {}

-- check 
-- check static semantics of Sys.argv[1]

function Main.check () 
    local f = Sys.argv[1]
    if f == nil then error("Main.check: no file in Sys.argv[1]") end
        
    local ast = Driver.parse(f)
    Driver.check(ast)
end

-- compile
-- compile Sys.argv[1]
-- defaults: Default.target, Default.optimizer, Default.linewidth

function Main.compile ()
    local f = Sys.argv[1]
    if f == nil then error("Main.check: no file in Sys.argv[1]") end

    local ast = Driver.parse(f)
    local env = Driver.check(ast)
    local asm = Driver.compile(Default.optimizer, ast, Default.target, env)
    local doc = Driver.assemble(asm)
    Driver.print(doc,Default.linewidth)
end    
Main.c = Main.compile -- abbreviation
@

 
% ------------------------------------------------------------------  
\section{Manual Page}
% ------------------------------------------------------------------  

Writing manual pages for the Troff formatter is a tedious job.  I have
found the highly readable \textit{plain old document} (\textsc{pod})
format used by the Perl community very helpful.  Every Perl
installation comes with a \texttt{pod2man} tool which creates a man
page from \textsc{pod} file.  Today we can assume that Perl is
installed nearly everywhere such that the use of this tool does not
spoil portability of our code.

The format of \textsc{pod} files is documented in the \texttt{perlpod}
manual page.  Besides the \texttt{pod2man} filter there exist other
filters to convert a \textsc{pod} file to \textsc{html} and \LaTeX,
which makes it a very versatile format.

<<qc--.pod>>=
=head1 NAME

qc-- - the quick c-- compiler

=head1 SYNOPSIS

B<qc--> [B<-e> I<command>] [B<-e> I<command>] [I<arg> I<arg> ...] 

B<qc--> [B<-e> I<command>] [B<-e> I<command>] B<-i> [I<arg> I<arg> ...] 

=head1 DESCRIPTION

B<qc--> compiles C-- code. The compiler is still under development and
currently does not yet produce executable code.  However, it checks
the syntax and static semantics of a C-- program.  The grammar
currently accepted by B<qc--> is described in section L<"GRAMMAR">. 

=head1 OPTIONS

Unlike most compilers B<qc--> is not controlled by command line switches
but by a built-in Lua 2.5 interpreter. Different phases of the compiler are
available as Lua primitives such that the user can write a Lua script to
control B<qc-->. The few existing command line switches therefore
control the Lua interpreter, rather than the compiler directly.

Upon start-up B<qc--> reads the file B<qc--.lua> in the current
directory and then processes command line options in the following
order: first all generic I<arg> arguments are passed in B<Sys.argv> to
the Lua interpreter, then B<-e> arguments are evaluated from left to
right. If the interactive option B<-i> is present, it is honored last.  

=over

=item B<-e> I<command>

The I<command> is passed to the Lua interpreter and I<evaluated>. This
option can be used multiple times. 

=item B<-i> 

Starts an I<interactive> session with the interpreter that reads from
stdin. All command line arguments to the right of B<-i> are considered
as generic I<arg> arguments that are passed to the Lua interpreter.
Therefore B<-i -e> I<arg> does not evaluate I<arg> but passes B<-e> and
I<arg> in B<Sys.argv>.

=item I<arg> ...

The first argument that is not any of the above options starts the
sequence of generic arguments. They are passed literally in B<Sys.argv>
to the Lua interpreter.

=back


=head1 EXAMPLES

=over 

=item B<qc-->  B<-e> B<'Main.compile()'> I<file.c-->

Compile I<file.c--> for the B<Default.target>.

=item B<qc--> B<-e> B<'Main.check()'> I<file.c-->

Check the static semantic of I<file.c-->.

=back

=head1 LUA DEFAULTS

Defaults are stored in the Lua table B<Default>. In particular:


=over 

=item B<target>: I<target>

Target architecuture of type B<target>.

=item B<linewidth>: I<number>

Linewidth for output.

=item B<optimizer>: I<optimizer>

Code optimizer.

=back

=head1 LUA TYPES

In addition to the six Lua core-types the Lua interpreter in the
B<qc--> compiler offers the following types that represent internal
compiler data structures:

=over

=item I<asm> Assembly code.

=item I<ast> C-- abstract syntax.

=item I<env> Symbol table.

=item I<proc> Back-end representation of a procedure.

=item I<doc> Printable output.

=item I<target> Target architecture.

=item I<optimize> Code optimizer.
=back

=head1 LUA TARGETS

=over

=item B<Targets.dummy>. A I<target> value for our only current target.

=back

=head1 LUA DRIVER FUNCTIONS 

The B<qc--> compiler is controlled by functions that consume and produce
the above types:

=over

=item B<Driver.version>(I<string>). Prints version information and
copyright to stdout.


=item B<Driver.scan>(I<string>). Takes a file name, scans it and prints
all tokens to stdout. This is only useful to debug the scanner.

=item B<Driver.parse>(I<string>). Takes a file name and parses the file
as a B<C--> program. Returns its abstract syntax as an I<ast> value.

=item B<Driver.emit_asdl>(I<ast>). Emits an abstract syntax I<ast> to
stdout in ASDL format.  The ASDL format is a cross-platform
cross-compiler format to exchange an abstract syntax.  

=item B<Driver.check>(I<ast>). Takes an abstract syntax I<ast> and checks
its static semantics. Returns a symbol table I<env> upon success.

=item B<Driver.compile>(I<optimize>, I<ast>, I<target>, I<env>).
Compiles an I<ast> for a I<target>, using symbol table I<env>. Returns
an assembly program I<asm>. The function B<compile> passes every C--
procedure to B<optimize>.

=item B<Driver.assemble>(I<asm>). Assembles an I<asm> value to a
printable I<doc> format.

=item B<Driver.print>(I<doc>, I<number>). Formats I<doc> for a line width
of I<number> characters and prints it to stdout.

=back

=head1 EXIT CODE

The B<qc--> compiler returns with exit code 0 of successful
operation.  In case of errors in a source file B<qc--> returns with
exit code 1.  Any internal compiler error leads to exit code 2.

=head1 SEE ALSO

http://www.cminusminus.org/, 
http://www.lua.org/,
http://www.cs.princeton.edu/zephyr/ASDL/

=head1 AUTHORS

Christian Lindig <lindig@eecs.harvard.edu>, 
Norman Ramsey <nr@eecs.harvard.edu>,
Daniel Damian <damian@eecs.harvard.edu>,
John Dias <dias@eecs.harvard.edu>,
Jonathan D. Eddy <eddy@fas.harvard.edu>
@
          
      
% ------------------------------------------------------------------  
\section{Grammar Manual Page}
% ------------------------------------------------------------------  

<<qc--grammar.pod>>=
=head1 NAME

qc--grammar - the c-- grammar recognized by qc--(1).

=head1 DESCRIPTION

During the development of the compiler it happens easily that the
documentation of the C-- language and the language recognized by the
compiler differ.  To give at least a hint about the language
recognized by the implementation its grammar is presented here.  The
grammar is created automatically from the implementation such that
errors are less likely.  However, the grammar comes without any
further explanation.  It is only meant as a least resort when the
implementation reports an otherwise unexplainable parse error.

##grammar##


=head1 SEE ALSO

http://www.cminusminus.org/, 
http://www.cs.princeton.edu/zephyr/ASDL/

=head1 AUTHORS

Christian Lindig <lindig@eecs.harvard.edu> 
Norman Ramsey <nr@eecs.harvard.edu>
Daniel Damian <damian@eecs.harvard.edu>
John Dias <dias@eecs.harvard.edu>
Jonathan D. Eddy <eddy@fas.harvard.edu>
@
          
      
% ------------------------------------------------------------------  
\section{This}
% ------------------------------------------------------------------  

To include some version information into the main binary we provide
the [[This]] module.  Its source code [[this.ml]] is created during
the build process from [[this.in]].  Currently only the version
information stays here but it is a useful place for other informations
that change frequently.  Note, that this code should \emph{not} be
used to control the behavior of the program.  We therefore write all
these informations to a stream to emphasize this.

<<this.in>>=
(* do not edit - this file is created from this.in through make(1) *)

let system          = "@this@"

@ The functions [[name]] and [[version]] decompose the [[system]]
string to get the name and version of the system. 

<<this.in>>=
let name channel = 
    let s = try let minus = String.index system '-' in
                String.sub system 0 minus
            with Not_found -> "not configured"
    in
         output_string channel s

<<this.in>>=
let version channel = 
    let s = try let minus = String.rindex system '-' in
                String.sub system (minus+1) (String.length system - minus - 1)
            with Not_found -> "not configured"
    in
        output_string channel s
@

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

<<this.mli>>=
val name    : out_channel -> unit
val version : out_channel -> unit 
@

