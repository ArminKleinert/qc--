% -*- mode: Noweb; noweb-code-mode: caml-mode; comment-column: 32 -*-

% vim: ts=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Please add grades for this module below. The line must start with % "%%".
% 

%%Grades: I Peripheral Immediate

\section{Back end for an Intel x86 subset}

\label{x86.sec}

This exploratory back end is designed both to help us develop good
procedures for writing back ends and to serve as an example.
The names of spaces are standard.
<<x86.mli>>=
val arch : string                       (* name of machine*)
module Spaces : sig
  val m : Space.t
  val r : Space.t
  val t : Space.t
  val c : Space.t   (* PC at 0 and condition codes at 2 *)
end
module Post : Postexpander.S
module X    : Expander.S
val target : Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@ 
\section{Implementation}

Here are some abbreviations.
<<x86.ml>>=
module A  = Automaton
module PX = Postexpander
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module Up = Rtl.Up
module Dn = Rtl.Dn
module Rg = X86regs
module RO = Rewrite.Ops

let impossf fmt = Printf.kprintf Impossible.impossible fmt

let ( =$  ) = Register.eq
let ( =/  ) = RU.Eq.loc
let ( =// ) = RU.Eq.exp

let (<:>) = PX.(<:>)
let rtl r = PX.Rtl r
@ 
At initialization, we register the x86 machine invariant as a property
for the optimization backplane.
<<x86.ml>>=
let _ = Backplane.M.register "x86 invariant"
    ["The x86 machine invariant.  For more explanation, see '<machine> invariant'."]
@ 
\subsection{Architecture name and storage spaces}
<<x86.ml>>=
module SS = Space.Standard32
let arch = "x86"                (* architecture name *)
@ 
We use the standard storage spaces, with the PC and
condition codes in their standard locations from [[Space.Standard32]].
We can't use the standard \texttt{f} space because Pentium
floating-point values are 80~bits wide.
We pretend that the machine is a 32-bit machine, which simplifies a lot.
<<x86.ml>>=
module Spaces = struct
  module S = Space
  let bo = Rtl.LittleEndian
  let id = Rtl.Identity
  let m = Space.Standard32.m bo [8; 16; 32]
  let r = Space.Standard32.r 7 id [32]
  let t = Space.Standard32.t   id [32]
  let c = Space.Standard32.c 3 id [32]
end
@
\subsection{Postexpander}

Program counter and condition codes (called [[eflags]] on the Pentium)
are standard.
We ignore the floating-point control register except for two bits that
represent the rounding mode.
<<x86.ml>>=
let {SS.pc = pc; SS.cc = eflags} = SS.locations Spaces.c
let rounding_model = R.slice 2 ~lsb:10 Rg.fpuctl
let rounding_mode  = R.fetch rounding_model 2
let fpuctl_reg = match Dn.loc Rg.fpuctl with
  | RP.Reg r -> r | _ -> impossf "unexpected rep of FPU control register"

module Post = struct
  <<x86 postexpander>>
end
@ 
We ought to find a good way to tie this information into the target
metrics, so as to avoid duplication and potential inconsistency.
<<x86 postexpander>>=
let byte_order = Rtl.LittleEndian
let wordsize   = 32
let memsize    = 8
let _, _, mcell as mspace = ('m', byte_order, Cell.of_size memsize)
let mcount     = Cell.to_count mcell
@ 
These synonyms, which are required by the postexpander interface, are a nuisance.
<<x86 postexpander>>=
type temp      = Register.t
type rtl       = Rtl.rtl
type width     = Rtl.width
type assertion = Rtl.assertion
type operator  = Rtl.Private.opr
@
The postexpander may need to allocate temporaries.
<<x86 postexpander>>=
let talloc = Postexpander.Alloc.temp
@ 
\paragraph{Contexts}
Addresses go in the integer registers.
The floating-point registers are treated as a stack, so anything that
actually gets allocated through a context should go in the integer
registers as well, even if it would be in a floating-point register on
an ordinary machine.
Hence there is only one context: the integer context.
<<x86 postexpander>>=
type context = (Talloc.Multiple.t -> int -> Register.t) * (Register.t -> bool)
let icontext = Talloc.Multiple.reg 't', fun ((c, _, _), _, _) -> c =<= 'r' || c =<= 't'
let fcontext = icontext  (* required by interface *)
let acontext = icontext
let rcontext = (fun x y -> Impossible.unimp "Unsupported soft rounding mode")
               ,(fun _ -> false)
let itempwidth = 32
@ IT WOULD BE GOOD TO RESTRUCTURE THE CONTEXTS AND THE
[[Talloc.Multiple]] INTERFACE SO THAT REQUESTING A BAD WIDTH COULD
MAKE A SUITABLE CALL INTO [[Unsupported]].  
AN EVEN MORE AMBITIOUS PLAN MIGHT MAKE THE WIDTHS EXPLICIT IN THE
CONTEXT.
@
\paragraph{Addressing modes}
The only addressing mode is the obvious one: register direct.
<<x86 postexpander>>=
module Address = struct
  type t = Rtl.exp
  let reg r = R.fetch (R.reg r) (Register.width r)
end
@ 
\subsubsection{Basic locations, flags, and helper functions}
We need to record the various side effects.

Here are some utility functions for computing locations, values, and widths.
<<x86 postexpander>>= 
let tempwidth = Register.width
let temploc t = Rtl.reg t
let tempval t = R.fetch (temploc t) (tempwidth t)
let mem addr  = R.mem R.none mspace (R.C 4) addr  (* single word in memory *)

let upint32 n = RO.unsigned 32 n
let upint8  n = RO.unsigned 8  n
@ 
Here are some important locations and values.
<<x86 postexpander>>=
let {SS.pc = pc; SS.cc = eflags} = SS.locations Spaces.c
let eax = temploc Rg.eax
let ecx = temploc Rg.ecx
let edx = temploc Rg.edx
let esp = temploc Rg.esp
let esi = temploc Rg.esi
let edi = temploc Rg.edi

let ah_val = R.fetch Rg.ah 8
let carrybit = R.app (R.opr "x86_carrybit" []) [RU.fetch eflags]
@ 
Code to transfer flags between [[eflags]] and [[ah]].
We invent a couple of operators.
EVENTUALLY, WE WILL WANT TO TELL THE SIMPLIFIER THAT THESE OPERATORS
ARE HALF-INVERSES.
IT WOULD BE GOOD TO BE ABLE TO WRITE THE CODE HERE AND REGISTER IT
SOMEHOW. 
<<x86 postexpander>>=
let sahf = rtl (R.store eflags (R.app (R.opr "x86_ah2flags" []) [ah_val]) 16)
let lahf = rtl (R.store Rg.ah (R.app (R.opr "x86_flags2ah" []) [R.fetch eflags 16]) 8)
@ 
These invented operators hide the real truth about what
happens to the flags.
It's up to the recognizer to know such facts as
$\mathtt{x86\_adcflags}(x, y, 0) = \mathtt{x86\_adcflags}(x, y)$.
<<x86 postexpander>>=
let c = carrybit
let addflags   x y w = R.store eflags (R.app (R.opr "x86_addflags"   [w]) [x; y])    32
let adcflags   x y w = R.store eflags (R.app (R.opr "x86_adcflags"   [w]) [x; y; c]) 32
let logicflags exp w = R.store eflags (R.app (R.opr "x86_logicflags" [w]) [exp])     32
let mulflags   x y w = R.store eflags (R.app (R.opr "x86_mulflags"   [w]) [x; y])    32
let muluxflags x y w = R.store eflags (R.app (R.opr "x86_muluxflags" [w]) [x; y])    32
let mulxflags  x y w = R.store eflags (R.app (R.opr "x86_mulxflags"  [w]) [x; y])    32
let negflags   x   w = R.store eflags (R.app (R.opr "x86_negflags"   [w]) [x])       32
let subflags   x y w = R.store eflags (R.app (R.opr "x86_subflags"   [w]) [x; y])    32
let sbbflags   x y w = R.store eflags (R.app (R.opr "x86_sbbflags"   [w]) [x; y; c]) 32
let undefflags       = R.store eflags (R.app (R.opr "x86_undefflags" [])  [])        32
let shflags sh x y w =
  let flagsop = "x86_" ^ sh ^ "flags" in
  R.store eflags (R.app (R.opr flagsop [w]) [x; y]) 32
@ 
\subsubsection{Data movement}
Most data movement is simple assignment; the MOV instruction is quite powerful.
Because we're treating the Pentium as a 32-bit machine, we assert the
width of everything is~32. 
<<x86 postexpander>>=
let load ~dst ~addr assn =
  assert (tempwidth dst = 32);
  rtl (R.store (temploc dst) (R.fetch (R.mem assn mspace (R.C 4) addr) 32) 32)
let store ~addr ~src assn =
  assert (tempwidth src = 32);
  rtl (R.store (R.mem assn mspace (R.C 4) addr) (tempval src) 32)
@ 
The Pentium provides sign-extending loads and stores.
It's a bit bogus to use EAX to do the [[lostore]], but we have no easy
way of asking for a temporary that supports low-store instructions.
<<x86 postexpander>>=
let extend opname n e = R.app (R.opr opname   [n; 32]) [e]
let lobits        n e = R.app (R.opr "lobits" [32; n]) [e]
let sxload ~dst ~addr n assn =
  if tempwidth dst <> 32 then Impossible.unimp "widening of temporaries";
  rtl (R.store (temploc dst)
             (extend "sx" n (R.fetch (R.mem assn mspace (mcount n) addr) n)) 32)
let zxload ~dst ~addr n assn =
  assert (tempwidth dst = 32);
  rtl (R.store (temploc dst)
             (extend "zx" n (R.fetch (R.mem assn mspace (mcount n) addr) n)) 32)
let lostore ~addr ~src n assn =
  assert (tempwidth src = 32);
  rtl (R.store eax (tempval src) 32) <:>
  rtl (R.store (R.mem assn mspace (mcount n) addr) (lobits n (R.fetch eax n)) n)
@ 
This code hasn't yet been checked for compatility with floating point.
<<x86 postexpander>>=
let move_rtl dst src = rtl (R.store (temploc dst) (tempval src) (tempwidth src))
let move ~dst ~src   = if Register.eq dst src then PX.Nop else move_rtl dst src
@ 
Load immediate is also a simple move.
<<x86 postexpander>>=
let li  ~dst const = rtl (R.store (temploc dst) (Up.const const) (tempwidth dst))
let lix ~dst e     = rtl (R.store (temploc dst) e                (tempwidth dst))
@ 
\subsubsection{Operator contexts}
Here are tentative contexts for all the operators.
Anything that has to do with rounding modes is surely wrong.
<<x86 postexpander>>=
let bcontext = (fun x y -> impossf "allocate from bcontext")
               ,fun _ -> false
let operators = Context.standard icontext fcontext rcontext acontext bcontext

module SM = Strutil.Map
let resmap = List.fold_left (fun m (n, a, r)-> SM.add n r m) SM.empty operators
let argmap = List.fold_left (fun m (n, a, r)-> SM.add n a m) SM.empty operators

let arg_contexts   (n, _) =
  try SM.find n argmap with Not_found -> impossf "cannot find arg context for %s" n
let result_context (n, _) =
  try SM.find n resmap with Not_found -> impossf "cannot find result context for %s" n
let constant_context w = icontext
@ 
\subsubsection{Operator implementations (with flags)}
Operator hell (or heaven).
We support (so far) two kinds of abstract operations on the flags.
An arithmetic-like or comparison instruction needs {two} \emph{operands}
to set the flags; a logical instruction needs only the \emph{result}.
<<x86 postexpander>>=
let exp_with_flags setflags dst exp x y w =
  rtl (R.par [R.store (temploc dst) exp w; setflags x y w])

let with_flags setflags dst op x y w =
  let x = tempval x in
  let y = tempval y in
  let exp = R.app op [x; y] in
  exp_with_flags setflags dst exp x y w

let with_lflags dst op x y w =
  let exp = R.app op [x; y] in
  rtl (R.par [R.store (temploc dst) exp w; logicflags exp w])
@ 
We insist on using most operators at their natural 32-bit width, and
this function is the forcing function that makes it so.
<<x86 postexpander>>=
let at32 = function
  | "lobits", [32; 32] -> "lobits"
  | opr, [32] -> opr
  | opr, [n]  -> Impossible.unimp ("%" ^ opr ^ string_of_int n ^ "(...)")
  | opr, ws   -> impossf "operator %%%s specialized to %d widths" opr (List.length ws)
@ 
We start our implementation with a function that provides binary
operators in $L \mathrel{:=} L \oplus R$ form. 
<<x86 postexpander>>=
let llr op x y = match at32 op with
| "add" -> with_flags addflags x (Up.opr op) x y 32
| "sub" -> with_flags subflags x (Up.opr op) x y 32
| "mul" -> with_flags mulflags x (Up.opr op) x y 32
@
Division is rather painful on the x86.
We have to place the dividend in the EDX:EAX register pair, and we have to represent
the destination as a register pair.
[[regpairv]] does most of the work, creating the rtl's to form the register pair, as
well as the expression representation of the register pair.
I have tried to make [[regpairv]] fairly general; we won't know if this is a success
until we try it with other versions of the x86 divide instruction.
<<x86 postexpander>>=
| "mod" ->
    let modexp = Rewrite.(mod) 32 (tempval x) (tempval y) in
    PX.Expand.block (rtl (R.store (temploc x) modexp 32))
| ("div" | "divu" | "quot" | "modu" | "rem") as opname ->
    let unsigned = opname =$= "divu" || opname =$= "modu" in
    let regpairv w hreg lreg =
      let rval  r = R.fetch (temploc r) w in
      let sh op l r = R.app (R.opr op [w]) [l; R.bits (Bits.U.of_int r w) w] in
      let zxreg l = RO.zx w (w*2) (rval l) in
      let pairval = RO.(or) (w*2) (sh "shl" (zxreg hreg) w) (zxreg lreg) in
            (* notice the ill-typed shift-left *)
      let sethi =
        if unsigned then
          rtl (R.store (temploc hreg) (R.bits (Bits.zero w) w) w)
        else
          let sbit = temploc (talloc 't' w) in
          let sbitval = R.fetch sbit w in
          rtl (R.store sbit (rval lreg) w) <:>
          rtl (R.store sbit (sh "shra" sbitval (w-1)) w) <:>
          rtl (R.store (temploc hreg) sbitval w) in
      sethi, pairval in
    let (is, regpair) = regpairv 32 Rg.edx Rg.eax in
    let q, r = if unsigned then "divu", "modu" else "quot", "rem" in
    let div = R.par [R.store eax (R.app (R.opr q [32]) [regpair; tempval y]) 32;
                     R.store edx (R.app (R.opr r [32]) [regpair; tempval y]) 32;
                     undefflags] in
    let finish = match opname with
    | "rem" | "modu" -> move_rtl x Rg.edx
    | "div" ->
        let d = Rewrite.div' 32 ~dst:(R.reg x) (tempval x) (tempval y)
                  ~quot:(tempval Rg.eax) ~rem:(tempval Rg.edx) in
        PX.Expand.block d
    | _ -> move_rtl x Rg.eax in
    move_rtl Rg.eax x <:> is <:> rtl div <:> finish
@ 
I don't know why it's safe to clobber ECX here.
The problem would arise if the {\PAL} source mentioned ECX, perhaps
because it wants to use ECX as the heap pointer or somethign like
that.

The safe thing to do would be to save and restore ECX before using it,
but at present we don't have an optimization pass capable of
eliminating all those dead saves and restores.  So we live dangerously.
<<x86 postexpander>>=
| ("shl" | "shrl" | "shra" | "rotl" | "rotr") as shop ->
    let cl = R.fetch Rg.cl 8 in
    let sh = exp_with_flags (shflags shop) x (R.app (Up.opr op) [tempval x; cl])
              (tempval x) cl 32 in
    move_rtl Rg.ecx y <:> sh
<<x86 postexpander>>=
| ("and"|"or"|"xor") -> with_lflags x (Up.opr op) (tempval x) (tempval y) 32 
| _  ->
    rtl (R.store (temploc x) (R.app (Up.opr op) [tempval x; tempval y]) (tempwidth x))
@ 
NOTE THERE IS NO REAL REASON THAT DIVISION SHOULD BE HANDLED AS LLR
SINCE WE USE SPECIAL REGISTERS ANYWAY!  
<<x86 postexpander>>=
let binop ~dst op x y = match at32 op with
| _     -> move dst x <:> llr op dst y
@ 
Other operators are surely wrong.
<<x86 postexpander>>=
let inplace op op32 x = match op32 with
| "neg" ->
    rtl (R.par [R.store (temploc x) (R.app (Up.opr op) [tempval x]) 32;
                         negflags (tempval x) 32])
| "lobits" -> PX.Nop  (* lobits32 is identity *)
| _ -> rtl (R.store (temploc x) (R.app (Up.opr op) [tempval x]) (tempwidth x))

let unop ~dst op x = match at32 op with
| "popcnt" -> PX.Expand.block (Rewrite.popcnt 32 ~dst:(temploc dst) (tempval x))
| op32 -> move dst x <:> inplace op op32 dst
@ 
<<x86 postexpander>>=
let unrm  ~dst op x   = impossf "operator %%%s in register" (fst op)
let binrm ~dst op x y = impossf "operator %%%s in register" (fst op)
@ 
<<x86 postexpander>>=
let extended_multiply op y =
  let opfun, flagfun = match op with
  | "mulx"  -> RO.mulx,  mulxflags
  | "mulux" -> RO.mulux, muluxflags
  | _ -> impossf "non-multiplying dblop" in
  let product = opfun 32 (tempval Rg.eax) (tempval y) in
  rtl (R.par [R.store edx (RO.lobits 64 32 (RO.shrl 64 product (RO.unsigned 64 32)))32;
              R.store eax (RO.lobits 64 32 product) 32;
              flagfun (tempval Rg.eax) (tempval y) 32])
@               
<<x86 postexpander>>=
let dblop ~dsthi ~dstlo op x y =
  move Rg.eax x <:>
  extended_multiply (at32 op) y <:>
  move dsthi Rg.edx <:>
  move dstlo Rg.eax
@ 
<<x86 postexpander>>=
let weird_tmp tmp z = match z with
| PX.WTemp (Register.Reg t) -> t, PX.Nop
| PX.WTemp (Register.Slice (w, 0, t)) -> t, PX.Nop
| PX.WTemp (Register.Slice (w, lsb, t)) -> Impossible.unimp "weird value in slice"
| PX.WBits b -> tmp, rtl (R.store (temploc tmp) (R.bits (Bits.Ops.zx 32 b) 32) 32)

let set_carry ~tmp z =
  let t, is = weird_tmp tmp z in
  let bit0 = RO.lobits 32 1 (tempval t) in
  is <:>
  rtl (R.store eflags (R.app (R.opr "x86_setcarry" []) [RU.fetch eflags; bit0]) 32)

let wrdop  ~dst op x y z =
  let dv, yv = tempval dst, tempval y in
  let is_add =
    match at32 op with "addc" -> true | "subb" -> false | _ -> impossf "wrdop" in
  let flags  = (if is_add then adcflags else sbbflags) dv yv 32 in
  let arith  = R.store (temploc dst) (R.app (Up.opr op) [dv; yv; carrybit]) 32 in
  set_carry ~tmp:dst z <:> move dst x <:> rtl (R.par [arith; flags])
<<x86 postexpander>>=
let rcl _ = impossf "don't do this; you'll lose the carry flag!  use jcs!"
let wrdrop  ~dst:(fill, dt) op x y z =
  let is_add =
    match at32 op with "carry" -> true | "borrow" -> false | _ -> impossf "wrdrop" in
  let t = talloc 't' 32 in
  wrdop ~dst:t ((if is_add then "addc" else "subb"), [32]) x y z <:>
  rtl (R.store (temploc dt) (R.bits (Bits.zero 32) 32) 32) <:>
  lahf <:> 
  rtl (R.store eax (RO.shrl 32 (RU.fetch eax) (R.bits (Bits.U.of_int 8 32) 32)) 32) <:>
  rtl (R.store (temploc dt) (R.fetch eax 32) 32) <:>
  match fill with
  | PX.HighAny -> PX.Nop
  | PX.HighZ -> 
      PX.Expand.block (rtl (R.store (temploc dt) (Rewrite.zxlo 1 32 (tempval dt)) 32))
  | PX.HighS ->
      PX.Expand.block (rtl (R.store (temploc dt) (Rewrite.sxlo 1 32 (tempval dt)) 32))
@ 
Setting the rounding mode is an experience.
History:
\begin{verbatim}
  ar x /usr/lib/libm.a fesetround.o
  objdump -d fesetround.o
\end{verbatim}
Then connect the dots.
(Unlike the GNU code, we do \emph{not} set the rounding mode in the
MMX unit.)
@ 
<<x86 postexpander>>=
let rmask_clear = R.bits (Bits.Ops.com (Bits.U.of_int 0xc00 32)) 32  (* 0xfffff3ff *)
let rmask_set   = R.bits (Bits.U.of_int 0xc00 32)  32
let and32 = R.opr "and" [32]
let or32  = R.opr "or"  [32]
let ten = RO.unsigned 32 10 

let hwset ~dst ~src =
  match dst with
  | Register.Slice (2, 10, r) when r =$ fpuctl_reg ->
      let slot      = PX.Alloc.slot 16 in
      let t         = PX.Alloc.temp 't' 32 in
      let t2, ldsrc = weird_tmp (PX.Alloc.temp 't' 32) src in
      rtl (slot.A.store (R.fetch Rg.fpuctl 16) 16) <:>                  (* fnstcw *)
      rtl (R.store (temploc t) (RO.zx 16 32 (slot.A.fetch 16)) 32) <:>  (* movzwl *)
      with_lflags t and32 (tempval t) rmask_clear 32 <:>      (* mask out round bits *)
      ldsrc <:>
      rtl (R.store (temploc t2) (RO.shl 32 (tempval t2) ten) 32) <:>
      with_lflags t or32 (tempval t) (tempval t2) 32 <:>
      rtl (slot.A.store (RO.lobits 32 16 (tempval t)) 16) <:>      
      rtl (R.store Rg.fpuctl (slot.A.fetch 16) 16)                   (* fldcw *)
  | _ -> impossf "setting unexposed hardware register"

let hwget ~dst:(fill,dt) ~src =
  match src with
  | Register.Slice (2, 10, r) when r =$ fpuctl_reg ->
      let slot      = PX.Alloc.slot 16 in
      let clear_others = with_lflags dt and32 (tempval dt) rmask_set 32 in
      let shift op n =
        rtl (R.store (temploc dt) (op 32 (tempval dt) (RO.unsigned 32 n)) 32) in
      rtl (slot.A.store (R.fetch Rg.fpuctl 16) 16) <:>                   (* fnstcw *)
      rtl (R.store (temploc dt) (RO.zx 16 32 (slot.A.fetch 16)) 32) <:>  (* movzwl *)
      (match fill with
      | PX.HighAny ->
          shift RO.shrl 10
      | PX.HighZ ->
          clear_others <:> shift RO.shrl 10
      | PX.HighS ->
          clear_others <:> shift RO.shl 20 <:> shift RO.shra 30
      )
  | _ -> impossf "getting unexposed hardware register"
@ 
\subsubsection{Control flow}

There's just one PC on the Pentium.
<<x86 postexpander>>=
let pc_lhs = pc
let pc_rhs = pc
@ 
There are some hairy semantics attached to some Pentium jump
instructions, but I~think we can stick with the simple ones for now. 
<<x86 postexpander>>=
let br ~tgt = PX.Nop, R.store pc_lhs (tempval tgt) 32
let b  ~tgt = PX.Nop, R.store pc_lhs (Up.const tgt) 32
@ 
The call instructions came from us, so we can rely on the single extra effects pushing the program counter.
<<x86 postexpander>>=
let effects = List.map Up.effect
let call  ~tgt ~others =
  PX.Nop, R.par (R.store pc_lhs (Up.const tgt) 32 :: effects others)
let callr ~tgt ~others =
  PX.Nop, R.par (R.store pc_lhs (tempval tgt) 32 :: effects others)
@ 
The [[cut to]] is our own little conspiracy.
<<x86 postexpander>>=
let cut_to effs = PX.Nop, R.par (effects effs)
@ 
We don't touch anything that pops the PC.
That means the return instruction!
<<x86 postexpander>>=
let don't_touch_me = 
  let lowpc = Dn.loc pc in
  function
  | [ RP.Store (pc', _, _)
    ; RP.Store (RP.Reg sp, RP.App (("add", [32]), [RP.Fetch (RP.Reg sp2, _);
                                                      RP.Const (RP.Bits b)]), _)] ->
      pc' =/ lowpc && sp =$ Rg.esp && sp2 =$ Rg.esp && Bits.S.to_int b = 4
  | _ -> false
@
To implement the comparisons, we define new operators that are private
to the $x$86 architecture. 
\begin{itemize}
\item [[x86_subflags]] returns what goes into the flags after a
[[sub]] or [[cmp]]
instruction.
\item [[x86_addflags]] returns what goes into the flags after a
[[add]] or [[adc]]
instruction.
\item [[x86_mulflags]] returns what goes into the flags after an
[[imul]] instruction.
\item [[x86_divflags]] returns what goes into the flags after an
[[idiv]] instruction.
\item
Operators [[x86_a]], [[x86_ae]], and so on, accept one argument, the
flags, and return a Boolean value that tells whether [[JA]], [[JAE]],
and so one, would jump.
\end{itemize}
<<x86 postexpander>>=
<<important functions on $x$86 operators>>
let cmp x y =
  R.store eflags (R.app (R.opr "x86_subflags" [32]) [tempval x; tempval y]) 32

let bc_x86_cond x86opname = R.app (R.opr x86opname [32]) [R.fetch eflags 32]
let bc_x86 x86opname ~ifso ~ifnot = (bc_x86_cond x86opname, ifso, ifnot)

let bc x (opr, ws) y ~ifso ~ifnot =
  assert (ws =*= [32]);
  match opr with
  | "div_overflows" | "quot_overflows" ->
      let ov = Rewrite.div_overflows 32 (tempval x) (tempval y) in
      PX.Expand.cbranch (PX.Test (PX.Nop, (ov, ifso, ifnot)))
  | _ ->
      PX.Test (cmpfun opr x y, bc_x86 (cmpopr opr) ifso ifnot)

let bnegate r = match Dn.rtl r with
| RP.Rtl [RP.App((cop, [32]), [RP.Fetch (flags, 32)]), RP.Store (pc, tgt, 32)]
  when RU.Eq.loc pc (Dn.loc pc_lhs) && RU.Eq.loc flags (Dn.loc eflags) ->
    Up.rtl (RP.Rtl [RP.App((cmpneg cop, [32]), [RP.Fetch (flags, 32)]),
                   RP.Store (pc, tgt, 32)])
| _ -> impossf "ill-formed x86 conditional branch"
@ 
The first ``important'' function converts a {\PAL} operator into the
corresponding Intel operator.
<<important functions on $x$86 operators>>=
let cmpopr = function
  | "eq"  -> "x86_e" 
  | "ne"  -> "x86_ne"
  | "lt"  -> "x86_l" 
  | "le"  -> "x86_le"
  | "gt"  -> "x86_g" 
  | "ge"  -> "x86_ge"
  | "ltu" -> "x86_b" 
  | "leu" -> "x86_be"
  | "gtu" -> "x86_a" 
  | "geu" -> "x86_ae"
  | "add_overflows"
  | "div_overflows"
  | "mul_overflows"
  | "mulu_overflows"
  | "sub_overflows" -> "x86_o"
  | _ -> impossf "non-comparison in x86 conditional branch"
@ 
The second important function negates an Intel operator.
<<important functions on $x$86 operators>>=
let cmpneg = function
  | "x86_ne" -> "x86_e"
  | "x86_e"  -> "x86_ne"
  | "x86_ge" -> "x86_l"
  | "x86_g"  -> "x86_le"
  | "x86_le" -> "x86_g"
  | "x86_l"  -> "x86_ge"
  | "x86_ae" -> "x86_b"
  | "x86_a"  -> "x86_be"
  | "x86_be" -> "x86_a"
  | "x86_b"  -> "x86_ae"
  | "x86_np" -> "x86_p"
  | "x86_p"  -> "x86_np"
  | "x86_nc" -> "x86_c"
  | "x86_c"  -> "x86_nc"
  | "x86_nz" -> "x86_z"
  | "x86_z"  -> "x86_nz"
  | "x86_o"  -> "x86_no"
  | "x86_no" -> "x86_o"
  | _ -> impossf "bad comparison in expanded x86 conditional branch"
@ 
The third important function returns the ``flag set'' function for an
operator. This is normally just [[cmp]], but in the case of overflow,
we need to emit arithmetic instructions to set the flags. Division is
a bit more complex since a division overflow causes a fault. However,
there is only one possibility for division overflow ($MIN_INT / -1$)
to check for.
<<important functions on $x$86 operators>>=
let cmpfun =
  let set_flags op x y = binop (talloc 't' 32) (op, [32]) x y
  and cmp x y = rtl (subflags (tempval x) (tempval y) 32) in
  function
  | "eq"
  | "ne"
  | "lt"
  | "le"
  | "gt"
  | "ge"
  | "ltu"
  | "leu"
  | "gtu"
  | "geu"            -> cmp
  | "add_overflows"  -> set_flags "add"
  | "mul_overflows"  -> set_flags "mul"
  | "mulu_overflows" ->
      (fun x y ->
        if Register.eq Rg.eax y then
          extended_multiply "mulux" x
        else
          move Rg.eax x <:> extended_multiply "mulux" y)
  | "sub_overflows"  -> set_flags "sub"
  | ("div_overflows" | "quot_overflows" as o) ->
      impossf "operator %%%s not rewritten in x86 postexpander" o
  | o -> impossf "non-comparison %%%s in x86 conditional branch" o
@ 
\subsection{Stack operations}

Regarding floating-point division, don't be fooled by wrongness in
the Pentium manual.
Full explanation is found in the recognizer.
<<x86 postexpander>>=
let opclass (op, _) =
  match op with
  | "i2f" | "f2f" | "f2f_implicit_round" | "f2i" | "fabs" | "fneg" | "fsqrt" ->
      PX.Stack(PX.LeftFirst, 1)
  | "fadd" | "fcmp" | "fdiv" | "fmul" | "fmulx" | "fsub"    
  | "feq" | "fge" | "fgt" | "fne"      
  | "fordered" | "funordered" -> PX.Stack(PX.RightFirst, 2)
  | "fle" | "flt"  -> PX.Stack(PX.LeftFirst, 2)  (* computed by swapping *)
  | _ ->
      PX.Register

let converts_stack_to_temp (op, _) = op =$= "f2i" || op =$= "f2f"

<<x86 postexpander>>=
let stspace = ('F', Rtl.Identity, Cell.of_size 3)
let fspace  = ('f', Rtl.Identity, Cell.of_size 80)
let st = temploc (stspace, 0, R.C 1)
let stval = R.fetch st 3
let freg_at a = R.mem R.none fspace (R.C 1) a
let streg = freg_at stval
let stadd = Rtlutil.addk 3 stval
let stsub n = RO.sub 3 stval (RO.unsigned 3 n)
let stregplus n = freg_at (stadd n)
let ffetch l = R.fetch l 80
<<x86 postexpander>>=
let st_pop_with f = (* rtl got by popping (f e), where e is top of floating-pt stack *)
  let top = ffetch streg in
  R.par [ f top; R.store st (stadd 1) 3 ]

let st_push e = (* effect of pushing e *)
  let next_st = stsub 1 in
  R.par [ R.store (freg_at next_st) e 80; R.store st next_st 3 ]


let stack_depth = 8
let stack_width = 80
let stack_top_proxy_reg = X86call.stack_top_proxy_reg
let stack_top_proxy = R.reg stack_top_proxy_reg
let is_stack_top_proxy = function
  | RP.Reg r -> Register.eq r stack_top_proxy_reg
  | _ -> false
@ 
Rounding.
<<x86 postexpander>>=
let wargval = function
  | PX.WTemp (Register.Reg t) -> R.fetch (R.reg t) (tempwidth t)
  | PX.WTemp (Register.Slice (w, lsb, t)) -> R.fetch (R.slice w ~lsb (R.reg t)) w
  | PX.WBits b -> R.bits b (Bits.width b)

let with_rm rm block = 
  match rm with
  | PX.WTemp (Register.Slice (2, 10, r)) when r =$ fpuctl_reg ->
      block
  | _ ->
      let t = talloc 't' 32 in
      let save    = rtl (R.store (temploc t) (RO.zx 2 32 rounding_mode) 32) in
      let set     = rtl (R.store rounding_model (wargval rm) 2) in
      let restore = rtl (R.store rounding_model (RO.lobits 32 2 (tempval t)) 2) in
      PX.Expand.block (save <:> set) <:> block <:> PX.Expand.block restore


<<x86 postexpander>>=
let push ~addr assn = 
(*
  let memval = R.fetch (R.mem assn mspace 80 addr) 80 in
  [st_push memval] (* bound to break *)
*)
impossf "push 80-bit float without conversion"

let store_pop ~addr assn = 
  let store regval = R.store (R.mem assn mspace (mcount 80) addr) regval 80 in
  rtl (st_pop_with store) (* bound to break *)
(*Impossible.impossible "store 80-bit float without conversion"*)

let push_cvt op w ~addr assn =
  assert (Cell.divides mcell w);
  let memval = R.fetch (R.mem assn mspace (mcount w) addr) w in
  let regval = R.app (Up.opr op) [memval; rounding_mode] in
  rtl (st_push regval)

let push_cvt_rm op rm w ~addr assn = with_rm rm (push_cvt op w ~addr assn)

let store_pop_cvt op w ~addr assn =
  assert (Cell.divides mcell w);
  let memval regval = R.app (Up.opr op) [regval; rounding_mode] in
  let store regval = R.store (R.mem assn mspace (mcount w) addr) (memval regval) w in
  rtl (st_pop_with store)
let store_pop_cvt_rm op rm w ~addr assn =
  with_rm rm (store_pop_cvt op w ~addr assn)
<<x86 postexpander>>=
let pushk _ = impossf "load 80-bit floating-point constant"
let pushk_cvt _ _ _ = Impossible.unimp "load floating-point constant"
<<x86 postexpander>>=
let stack_op op = match opclass op with
| PX.Register -> impossf "passed register operator to stack_op"
| PX.Stack(first, depth) -> (* by lucky accident, depth is arity *)
    let positions = Aux.from 0 (depth-1) in
    let positions = match first with PX.RightFirst -> positions
                                   | PX.LeftFirst  -> List.rev positions in
    let argvals = List.map (fun n -> ffetch (stregplus n)) positions in
    let argvals = match op with
    | ("fadd"|"fsub"|"fdiv"|"fmul"|"f2f"|"f2i"|"i2f"), _ ->
        argvals @ [rounding_mode]
    | _ -> argvals in
    let result = R.app (Up.opr op) argvals in
    let next_st = stadd (depth-1) in
    if depth = 1 then
      rtl ( R.store (freg_at next_st) result 80)
    else
      rtl (R.par [ R.store (freg_at next_st) result 80; R.store st next_st 3])
let stack_op_rm op rm = with_rm rm (stack_op op)
@ 
The machine from hell:
\begin{itemize}
\item
The result of a floating point comparison goes in C0--C3,
which are respectively bits 8--10 and~11 of the FPU status word, where
bit~0 is the least significant bit.
\item
The \texttt{fstsw} instruction moves the FPU status word into AX,
which is the least significant 16~bits of EAX.
\item
The \texttt{sahf} instruction moves AH~into the flags:
\begin{quote}
\begin{tabular}{|llll|cccc|}
\hline
Flag& AH bit& FPU bit&FPU code&$\parallel$&$>$&$<$&$=$\\
\hline
SF&7&15& B (FPU busy)&&&&\\
ZF&6&14& C3& 1&0&0&1\\
AF&4&12& middle bit of TOP&&&&\\
PF&2&10& C2& 1& 0&0&0\\
CF&0&8& C0& 1&0&1&0\\
\hline
\end{tabular}
\end{quote}
Apparently it suffices to test ZF and CF.
\item
Therefore
\begin{quote}
\def\f#1{\mathord{\mbox{\uppercase{#1F}}}}
\begin{tabular}{lll}
\emph{Comparison}& \emph{Test}& \emph{Instruction}\\
Float $\parallel$& $\f p = 1$& JP\\
Float $\not\parallel$&$\f p = 0$& JNP\\
Float $<$& ugly & swap and compute $>$\\
Float $\le$& ugly & swap and compute $\ge$\\
Float $>$& $\f c = 0 \land \f z = 0$& JA \\
Float $\ge$& $\f c = 0$& JNC \\
Float $=$&$\f p = 0 \land \f z = 1$& ANDB AH,0x44; XORB AH, 0x40; JZ\\
Float $\ne$&$\lnot(\f p = 0 \land \f z = 1)$& ANDB AH,0x44; XORB AH, 0x40; JNZ\\
\end{tabular}
\end{quote}
\end{itemize}
<<x86 postexpander>>=
let fpcmpopr = function
  | "feq"  -> "x86_z"  (* AH is    zero when xor'ed with the flag pattern for feq *)
  | "fne"  -> "x86_nz" (* AH is nonzero when xor'ed with the flag pattern for feq *)
  | "flt" | "fgt" -> "x86_a"   (* flt is swapped fgt *)
  | "fle" | "fge" -> "x86_nc"  (* fle is swapped fge *)
  | "fordered"    -> "x86_np"
  | "funordered"  -> "x86_p"
  | _ -> impossf "floating-point comparison operator"

let bc_stack op ~ifso ~ifnot = match op with
| ("fordered"|"funordered"|"flt"|"fgt"|"fle"|"fge"|"feq"|"fne") as opname, [w] ->
    let positions = Aux.from 0 1 in
    let argvals = List.map (fun n -> ffetch (stregplus n)) positions in
    let result = R.app (R.opr "x86_fcmp" [w]) argvals in
    let next_st = stadd 2 in
    let setcc = rtl (R.par [R.store Rg.fpcc result 2; R.store st next_st 3]) in
    let fstsw = rtl (R.store Rg.ax (R.fetch Rg.fpustatus 16) 16) in
    (match opname with
    | "feq" | "fne" ->
        let logic f l r = rtl (R.par [f l r 8; logicflags r 8]) in
        let clear_extra     = logic R.store Rg.ah (RO._and 8 ah_val (upint8 0x45)) in
        let xor_with_eq_pat = logic R.store Rg.ah (RO.xor  8 ah_val (upint8 0x40)) in
        (* at this point, ZF = 0 iff the flags showed floating eq *)
        PX.Test (setcc <:> fstsw <:> clear_extra <:> xor_with_eq_pat,
                 bc_x86 (fpcmpopr opname) ifso ifnot)
    | _ ->
        PX.Test (setcc <:> fstsw <:> sahf, bc_x86 (fpcmpopr opname) ifso ifnot))
| _ -> impossf "strange operator in x86 bc_stack"
@ 
The general block copy is implemented with the ``[[x86_repmovs]]''
operator which translates to and [[rep movs]] in the recognizer. This
implementation assumes that the direction flag is set properly. The
emitted code could be improved by using [[movsw]] or [[movsd]] if the
number of bytes to copy is a multiple of 2 or 4 respectively. However,
I am not sure where this optimization should take place. -PG
<<x86 postexpander>>=
let i2f_64_80 = ("i2f", [64; 80])
let f2i_80_64 = ("f2i", [80; 64])
let block_copy ~dst dassn ~src sassn w =
  match w with
  | 16 | 8 ->
      let t = talloc 't' 32 in
      zxload t src w sassn <:> lostore dst t w dassn
  | 32 ->
      let t = talloc 't' 32 in
      load t src sassn <:> store dst t dassn
  | 64 ->
      push_cvt i2f_64_80 64 src sassn <:> store_pop_cvt f2i_80_64 64 dst dassn
  | n ->
      let bytes     = n / 8
      and const n   = RO.signed 32 n
      and sub r c   = RO.sub 32 (R.fetch r 32) c
      and byte_at r = R.mem R.none mspace (R.C 1) (R.fetch r 32) in
      let repmovsb =
        R.par [ R.store ecx (sub ecx (const 1)) 32
              ; R.store esi (sub esi (const bytes)) 32
              ; R.store edi (sub edi (const bytes)) 32
              ; R.store (byte_at esi) (R.fetch (byte_at edi) 8) 8
              ; R.guard (R.fetch ecx 32) (R.store pc (R.fetch pc 32) 32)
              ] in
      rtl (R.store esi src 32) <:>
      rtl (R.store edi dst 32) <:>
      rtl (R.store ecx (const bytes) 32) <:>
      rtl repmovsb
@
\subsection{Building the target}
With the postexpander in place, we can build a target.
We begin with more utility functions
<<x86.ml>>=
module P = Post
let pc        = pc
let espval    = P.tempval X86regs.esp
let add       = Rtlutil.add 32
let sub x y   = RO.sub 32 x y
let const n   = RO.signed 32 n
let mem       = P.mem
let fetch l   = R.fetch l 32
let store l r = R.store l r 32
@ 
These functions help with instructions that push and pop.
<<x86.ml>>=
let pop_with f = (* rtl got by popping (f e), where e is top of stack *)
  let top = fetch (P.mem espval) in
  R.par [ f top; store P.esp (add espval (const 4)) ]

let push e = (* effect of pushing e *)
  let next_sp = sub espval (const 4) in
  R.par [ store (mem next_sp) e; store P.esp next_sp ]
@ 
We now build the standard control flow.
<<x86.ml>>=
module T = Target
module FS = Mflow.MakeStandard (
  struct
     let pc_lhs = P.pc_lhs
     let pc_rhs = P.pc_rhs
     let ra_reg =
       P.temploc (('?', Rtl.Identity, Cell.of_size 0), 99, R.C 1) (* not used *)
     let ra_offset = 33                       (* not used *)
  end)
module F = struct
  include FS
  let call =
    { T.embed = (fun e -> R.par [FS.goto.T.embed e; push (fetch pc)])
    ; T.project = FS.call.T.project (* should be OK *)
    }
  let return = 
    { T.embed = (fun () -> pop_with (fun ra -> store pc ra))
    ; T.project = (fun r  -> Impossible.unimp "projected return")
    }
end
@      
There's no science here---just a lot of goo.
The [[Target.t]] abstraction could use some thought.
<<x86.ml>>=
module X = Expander.IntFloatAddr (Post)
(* expansion here once caused infinite loop *)
let spill_expand p r = [r]
let spill  p t l =
  spill_expand p (Automaton.store l (P.tempval t) (P.tempwidth t))
let reload p t l =
  spill_expand p (R.store (P.temploc t) (Automaton.fetch l (P.tempwidth t)) (P.tempwidth t))
@ 
Parts of the target record are reasonable.
Parts are lies.
Parts are baffling---why is character set characterized by the target?
<<x86.ml>>=
let downrtl = Dn.rtl
let uploc   = Up.loc
let upexp   = Up.exp

let ( *> ) = A.( *> )
let globals base = 
  let width w = if w <= 8 then 8 else if w <= 16 then 16 else Aux.round_up_to 32 w in
  let align = function 8 -> 1 | 16 -> 2 | _ -> 4 in
  A.at P.mspace ~start:base 
    (A.widen width *> A.align_to align *>
     A.overflow ~growth:Memalloc.Up ~max_alignment:4)

let target =
  let spaces = [Spaces.m; Spaces.r; Spaces.t; Spaces.c] in
  { T.name = "x86"
  ; T.memspace = P.mspace
  (* basic metrics and spaces are OK *)
  ; T.byteorder   = P.byte_order  
  ; T.wordsize    = P.wordsize
  ; T.pointersize = P.wordsize
  ; T.vfp         = SS.vfp
  ; T.alignment = 1
  ; T.memsize = P.memsize
  ; T.spaces = spaces
  ; T.reg_ix_map          = T.mk_reg_ix_map spaces
  ; T.distinct_addr_sp = false

  (* Does the Pentium really implement IEEE 754?  I think so *)
  ; T.float = Float.ieee754

  (* spill and reload are believed OK *)
  ; T.spill  = spill
  ; T.reload = reload

  (* control flow is solid, except [[cutto]] is a lie *)
  ; T.bnegate = F.bnegate eflags
  ; T.goto    = F.goto
  ; T.jump    = F.jump
  ; T.call    = F.call
  ; T.return  = F.return
  ; T.branch  = F.branch

  ; T.cc_specs         = A.init_cc
  ; T.cc_spec_to_auto  = X86call.cconv 
                           ~return_to:(fun ra -> 
                                         pop_with (fun ra -> store pc ra))
                           (F.cutto P.esp)

  ; T.is_instruction = X86rec.M.is_instruction

  ; T.capabilities =   {T.memory = [8;16;32]; T.block_copy = true;
                        T.itemps = [32]; T.ftemps = [32; 64];
                        T.iwiden = true; T.fwiden = true;
                        T.operators = List.map Up.opr [
                         "sx",      [ 8; 32]
                       ; "sx",      [ 1; 32]
                       ; "sx",      [16; 32]
                       ; "zx",      [ 1; 32]
                       ; "zx",      [ 8; 32]
                       ; "zx",      [16; 32]
                       ; "lobits",  [32;  1]
                       ; "lobits",  [32;  8]
                       ; "lobits",  [32; 16]
                       ; "lobits",  [32; 32]
                       ; "add",     [32]
                       ; "addc",    [32]
                       ; "and",     [32]
                       ; "borrow",  [32]
                       ; "carry",   [32]
                       ; "com",     [32]
                       ; "div",     [32]
                       ; "divu",    [32]
                       ; "mod",     [32]
                       ; "modu",    [32]
                       ; "mul",     [32]
                       ; "mulx",    [32]
                       ; "mulux",   [32]
                       ; "neg",     [32]
                       ; "or",      [32]
                       ; "quot",    [32]
                       ; "popcnt",  [32]
                       ; "rem",     [32]
                       ; "rotl",    [32]
                       ; "rotr",    [32]
                       ; "shl",     [32]
                       ; "shra",    [32]
                       ; "shrl",    [32]
                       ; "sub",     [32]
                       ; "subb",    [32]
                       ; "xor",     [32]
                       ; "eq",      [32]
                       ; "ge",      [32]
                       ; "geu",     [32]
                       ; "gt",      [32]
                       ; "gtu",     [32]
                       ; "le",      [32]
                       ; "leu",     [32]
                       ; "lt",      [32]
                       ; "ltu",     [32]
                       ; "ne",      [32]
                       ; "fabs", [32]
                       ; "fadd", [32]
                       ; "fdiv", [32]
                       ; "feq", [32]
                       ; "fge", [32]
                       ; "fgt", [32]
                       ; "fle", [32]
                       ; "flt", [32]
                       ; "fne", [32]
                       ; "fordered", [32]
                       ; "fmul", [32]
                       ; "fneg", [32]
                       ; "funordered", [32]
                       ; "fsqrt", [32]
                       ; "fsub", [32]
                       ; "fabs", [64]
                       ; "fadd", [64]
                       ; "fdiv", [64]
                       ; "feq", [64]
                       ; "fge", [64]
                       ; "fgt", [64]
                       ; "fle", [64]
                       ; "flt", [64]
                       ; "fne", [64]
                       ; "fordered", [64]
                       ; "fmul", [64]
                       ; "fneg", [64]
                       ; "funordered", [64]
                       ; "fsqrt", [64]
                       ; "fsub", [64]
                       ; "f2f", [32; 64]
                       ; "f2f", [64; 32]
                       ; "i2f", [32; 64]
                       ; "f2i", [64; 32]
                       ; "minf", [32]  (* from simplifier *)
                       ; "minf", [64]  (* from simplifier *)
                       ; "pinf", [32]  (* from simplifier *)
                       ; "pinf", [64]  (* from simplifier *)
                       ; "mzero", [32]  (* from simplifier *)
                       ; "mzero", [64]  (* from simplifier *)
                       ; "pzero", [32]  (* from simplifier *)
                       ; "pzero", [64]  (* from simplifier *)
                       ; "round_up", []  (* from simplifier *)
                       ; "round_down", []  (* from simplifier *)
                       ; "round_zero", []  (* from simplifier *)
                       ; "round_nearest", []  (* from simplifier *)
                       ; "NaN",   [23; 32]  (* from simplifier *)
                    (*   ; "NaN",   [52; 64]  from simplifier *)
                       ;  "add_overflows",  [32]
                       ;  "div_overflows",  [32]
                       ;  "mul_overflows",  [32]
                       ;  "mulu_overflows", [32]
                       ;  "quot_overflows", [32]
                       ;  "sub_overflows",  [32]
                       ; "not",     []
                       ; "bool",    []
                       ; "disjoin", []
                       ; "conjoin", []
                       ; "bit",     []
                   ]; T.literals = [32;64]}

  (* global or hardware registers *)
  ; T.globals  = globals
  ; T.rounding_mode = rounding_model
  ; T.named_locs   = Strutil.assoc2map 
                     ["IEEE 754 rounding mode",    rounding_model]
  
  (* bogosity *)
  ; T.data_section = "data" (* NOT REALLY A PROPERTY OF THE TARGET MACHINE... *)
  ; T.charset = "latin1" (* THIS IS NONSENSE!! NOT A PROPERTY OF THE MACHINE?? *)
  } 

type tgt  = ((Rtl.exp -> Automaton.t), Call.t) Target.t
@ 
\subsection{Variable placement}
The machine accepts only three widths of floating-point variables: 32,
64, and 80~bits.
Any 80-bit value is seen as a float (this might be wrong in the case
of an 80-bit structure variable, so the decision should be revisited).
A~32-bit or 64-bit value would have to be suitably hinted to be seen
as a float.
Because floating-point registers are organized as a stack, we can't
use the registers effectively for variables, so floats go in memory.

Any other value of width at most~32 goes into a temporary.
Larger values go straight to memory.

FOR WARNINGS, IT MIGHT BE USEFUL TO INCLUDE A VARIABLE NAME SOMEWHERE,
SOMEHOW.
<<x86.ml>>=
let warning s = Printf.eprintf "backend warning: %s\n" s
let placevars = 
  let is_float      w hint _ = w = 80 || (hint=$="float" && (w = 32 || w = 64)) in
  let strange_float w hint   = w = 80 && Pervasives.(<>) hint "float" in
  let strange_int   w hint   = hint =$= "float" && not (is_float w hint ()) in
  let warn ~width:w ~alignment:a ~hint:h =
      if strange_float w h then
        warning "80-bit variable not hinted float but will go as float anyway"
      else if strange_int w h then
        warning
          (Printf.sprintf "%d-bit variable hinted float but will go as integer" w) in
  let mk_stage ~temps =
    A.choice
      [ is_float,               A.widen (Aux.round_up_to ~multiple_of: 32); 
        (fun w h _ -> w <= 32), A.widen (fun _ -> 32) *> temps 't';
        A.is_any,               A.widen (Aux.round_up_to ~multiple_of: 8);
      ] in
  Placevar.mk_automaton ~warn ~vfp:target.T.vfp ~memspace:P.mspace mk_stage
@ 
\section{Tentative example Lua code}

An automaton needs a ``base'' argument.
This argument must somehow be handled behind the scenes.
<<example Lua>>=
X86.Regs = { r = Register.space('r', 8, 32), f = Register.space('f', 8, 80),
             c = Register.space('c', 4, 32) }
Register.addnames(X86.Regs, X86.Regs.r, 
  { 'eax', 'ecx', 'edx', 'ebx', 'esp', 'ebp', 'esi', 'edi' })

X86.CC = Call.make(X86.target)

function X86.CC.results(rs) 
  local CC = X86.CC
  return 
      CC.choice ( 'float',  { CC.widen(CC.multiple_of(80))
                            , CC.widths(80, "x86 FP too wide")
                            , CC.useregs(X86.Regs.f[0], "internal error")
                            }
                , {},       { CC.widen(CC.multiple_of(32))
                            , CC.widths(32, "x86 return too wide")
                            , CC.useregs(rs, "internal error")
                            }
                )
end

function X86.setccs() 
  local vfp = Vfp.mk(32)
  local R = X86.Regs
  local eax, ecx, edx, ebx, esi, edi, ebp =
    R.eax, R.ecx, R.edx, R.ebx, R.esi, R.edi, R.ebp

  local allregs = {eax, ecx, edx, ebx, esi, edi, ebp}
  local volregs = {eax, ecx, edx}
  local nvregs  = {ebx, esi, edi, ebp}

  local CC = X86.CC
  local c_results   = CC.results(eax)
  local cmm_results = CC.results(volregs)
  local c_args    = { CC.widen(CC.multiple_of(32)), CC.overflow("up", 4)}
  local cut_args  =
    { CC.widen(CC.multiple_of(32))
    , CC.widths(32, "at most 32 bits in cut-to argument")
    , CC.useregs(allregs)
    , CC.overflow("up", 4)
    }
  local cmm_args = 
    { CC.widen(CC.multiple_of(32))
    , CC.useregs(allregs)
    , CC.overflow("up", 4)
    }
end  


