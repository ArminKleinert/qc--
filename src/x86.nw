% -*- mode: Noweb; noweb-code-mode: caml-mode; comment-column: 32 -*-

% vim: ts=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Please add grades for this module below. The line must start with % "%%".
% 

%%Grades: I Peripheral Immediate

\section{Back end for an Intel x86 subset}

This exploratory back end is designed both to help us develop good
procedures for writing back ends and to serve as an example.
The names of spaces are standard.
<<x86.mli>>=
val arch : string                       (* name of machine*)
module Spaces : sig
  val m : Space.t
  val r : Space.t
  val t : Space.t
  val f : Space.t
  val u : Space.t
  val c : Space.t   (* PC at 0 and condition codes at 2 *)
end
module Post : Postexpander.S
module X    : Expander.S
val target : Target2.t
@ 

\paragraph{Name}
<<x86.ml>>=
let arch = "x86"                (* architecture name *)
@ 
We use the standard storage spaces, with the PC and
condition codes in their standard locations from [[Space.Standard32]].
We pretend that the machine is a 32-bit machine, which simplifies a lot.
<<x86.ml>>=
module Spaces = struct
  module S = Space
  let bo = Rtl.LittleEndian
  let id = Rtl.Identity
  let m = Space.Standard32.m bo [8; 16; 32]
  let r = Space.Standard32.r 8 id [32]
  let t = Space.Standard32.t   id [32]
  let f = S.checked { S.space = 'f'; S.doc = "floating-point registers"
                    ; S.cellwidth = 80
                    ; S.indexwidth = 3; S.indexlimit = Some 8
                    ; S.aggregation = id; S.widths = [80]
                    ; S.classification = S.Reg
                    } 
  let all_floats = { S.stands_for = 'f'; S.index_ok = (fun _ -> true)
                   ; S.set_doc = "all floating-point registers"
                   } 
  let u = S.checked { S.space = 'u'; S.doc = "floating-point temporaries"
                    ; S.cellwidth = 80
                    ; S.indexwidth = 31; S.indexlimit = None
                    ; S.aggregation = id; S.widths = [80]
                    ; S.classification = S.Temp all_floats
                    } 
  let c = S.checked { S.space = 'c'; S.doc = "PC and condition codes"
                    ; S.cellwidth = 32
                    ; S.indexwidth = 31; S.indexlimit = Some 2
                    ; S.aggregation = id; S.widths = [32]
                    ; S.classification = S.Fixed
                    } 
end

<<x86.ml>>=
module R = Rtl
module RP = Rtl.Private
module Post = struct
  <<x86 expander>>
end
@ 
<<x86 expander>>=
let byte_order = Rtl.LittleEndian
let wordsize = 32
@ 
These copies are a nuisance.
<<x86 expander>>=
type temp = Register.t
type rtl = Rtl.rtl
type width = Rtl.width
type assertion = Rtl.assertion
type operator = Rtl.Private.opr
@ 
Here are the spaces.
<<x86 expander>>=
type context = Rtl.space * (Register.t -> bool)
let icontext = 't', fun (c, _, _) -> c = 'r' || c = 't'
let fcontext = 'u', fun (c, _, _) -> c = 'f' || c = 'u'
let acontext = icontext
@ 
<<x86 expander>>=
module Address = struct
  type t = Rtl.exp
  let rindex n = R.bits (Bits.U.of_int n wordsize) wordsize
  let reg (space, n, w) = 
    R.fetch (R.cell R.none space byte_order w (rindex n)) w
end
@ 
We need to record the various side effects.
IF WE WANT TO MAKE BORROW AND CARRY WORK, WE WILL NEED TO PASS A THIRD
ARGUMENT TO SUBFLAGS AND ADDFLAGS.  THIS WILL MEAN CHANGES IN THE
RECOGNIZER, OF COURSE.
<<x86 expander>>=
let rindex = Address.rindex
module SS = Space.Standard32
let {SS.pc = pc; SS.cc = eflags} = SS.locations Spaces.c
let eax    = R.cell R.none 'r' byte_order 32 (rindex 0)
let edx    = R.cell R.none 'r' byte_order 32 (rindex 2)
let subflags x y w = R.store eflags (R.app (R.opr "x86_subflags" [w]) [x; y]) 32
let addflags x y w = R.store eflags (R.app (R.opr "x86_addflags" [w]) [x; y]) 32
let logicflags exp w = R.store eflags (R.app (R.opr "x86_logicflags" [w]) [exp]) 32

let temploc (space, n, w) = Rtl.cell Rtl.none space byte_order w (rindex n)
let tempval ((space, n, w) as t) = R.fetch (temploc t) w
let tempwidth (space, n, w) = w
let mem addr = R.cell R.none 'm' byte_order 32 addr
@ 
It's not clear whether the MOV instruction sets the flags or not.
For the moment, I assume not.
<<x86 expander>>=
let as_mov rtl = rtl

let load ~dst:((_, _, w) as dst) ~addr assn =
  assert (w = 32);
  [as_mov (R.store (temploc dst) (R.fetch (R.cell assn 'm' byte_order 32 addr) 32) 32)]
let store ~addr ~src:((_, _, w) as src) assn =
  assert (w = 32);
  [as_mov (R.store (R.cell assn 'm' byte_order 32 addr) (tempval src) 32)]
@ 
I assume the sign-extending loads and stores are there.
<<x86 expander>>=
let extend opname n e = R.app (R.opr opname   [n; 32]) [e]
let lobits        n e = R.app (R.opr "lobits" [32; n]) [e]
let sxload ~dst:((_, _, w) as dst) ~addr n assn =
  if w <> 32 then Impossible.unimp "widening of temporaries";
  [as_mov (R.store (temploc dst)
             (extend "sx" n (R.fetch (R.cell assn 'm' byte_order n addr) n)) 32)]
let zxload ~dst:((_, _, w) as dst) ~addr n assn =
  assert (w = 32);
  [as_mov (R.store (temploc dst)
             (extend "zx" n (R.fetch (R.cell assn 'm' byte_order n addr) n)) 32)]
let lostore ~addr ~src:((_, _, w) as src) n assn =
  assert (w = 32);
  [as_mov (R.store (R.cell assn 'm' byte_order n addr) (lobits n (tempval src)) n)]
@ 
Who knows if the move instruction goes freely from int to float?
Who knows if the flags are affected?
It has to be looked up!
<<x86 expander>>=
let width (_, _, w) = w
let move_rtl dst src = as_mov (R.store (temploc dst) (tempval src) (width src))
let move ~dst ~src = 
  if dst = src then [] else [move_rtl dst src]
@ 
Load immediate should also be a simple move.
<<x86 expander>>=
let upconst c = R.Revert.exp (RP.Const c)
let li ~dst const =
  [as_mov (R.store (temploc dst) (upconst const) (width dst))]
@ 
Here are tentative contexts for all the operators.
Anything that has to do with [[bool]] or with rounding modes is surely wrong.
<<x86 expander>>=
let upop = R.Revert.opr
let operators =
[ "add", [icontext; icontext], icontext
; "and", [icontext; icontext], icontext
; "bit", [icontext], icontext  (* BOGUS *)
; "bitExtract", [icontext; icontext], icontext
; "bitInsert", [icontext; icontext; icontext], icontext
; "bitTransfer", [icontext; icontext; icontext; icontext; icontext], icontext
; "bool", [icontext], icontext   (* BOGUS *)
; "borrow", [icontext; icontext; icontext], icontext
; "carry", [icontext; icontext; icontext], icontext
; "com", [icontext], icontext
; "conjoin", [icontext; icontext], icontext    (* BOGUS *)
; "disjoin", [icontext; icontext], icontext   (* BOGUS *)
; "div", [icontext; icontext], icontext
; "divu", [icontext; icontext], icontext
; "eq", [icontext; icontext], icontext
; "f2f", [fcontext; fcontext], fcontext
; "f2i", [fcontext; fcontext], fcontext  (* conversion done in float unit?? *)
; "fabs", [fcontext], fcontext
; "fadd", [fcontext; fcontext; fcontext], fcontext  (* ROUNDING MODES *)
; "fcmp", [fcontext; fcontext], fcontext
; "fdiv", [fcontext; fcontext; fcontext], fcontext  (* ROUNDING MODES *)
; "float_eq", [], fcontext
; "float_gt", [], fcontext
; "float_lt", [], fcontext
; "fmul", [fcontext; fcontext; fcontext], fcontext  (* ROUNDING MODES *)
; "fmulx", [fcontext; fcontext], fcontext
; "fneg", [fcontext], fcontext
; "fsqrt", [fcontext; fcontext], fcontext  (* ROUNDING MODES *)
; "fsub", [fcontext; fcontext; fcontext], fcontext  (* ROUNDING MODES *)
; "ge", [icontext; icontext], icontext
; "geu", [icontext; icontext], icontext
; "gt", [icontext; icontext], icontext
; "gtu", [icontext; icontext], icontext
; "i2f", [fcontext; fcontext], fcontext  (* conversion done in float unit? *)
; "le", [icontext; icontext], icontext
; "leu", [icontext; icontext], icontext
; "lt", [icontext; icontext], icontext
; "ltu", [icontext; icontext], icontext
; "minf", [], fcontext
; "mod", [icontext; icontext], icontext
; "modu", [icontext; icontext], icontext
; "mul", [icontext; icontext], icontext
; "mulu", [icontext; icontext], icontext
; "mzero", [], fcontext
; "NaN", [fcontext], fcontext           (* ??? *)
; "ne", [icontext; icontext], icontext
; "neg", [icontext], icontext
; "not", [icontext], icontext
; "or", [icontext; icontext], icontext
; "pinf", [], fcontext
; "popcnt", [icontext], icontext
; "pzero", [], fcontext
; "quot", [icontext; icontext], icontext
; "rem", [icontext; icontext], icontext
; "round_down", [], icontext      (* ROUNDING MODES *)
; "round_nearest", [], icontext  (* ROUNDING MODES *)
; "round_up", [], icontext  (* ROUNDING MODES *)
; "round_zero", [], icontext  (* ROUNDING MODES *)
; "shl", [icontext; icontext], icontext
; "shra", [icontext; icontext], icontext
; "shrl", [icontext; icontext], icontext
; "sub", [icontext; icontext], icontext
; "sx", [icontext], icontext
; "unordered", [], fcontext
; "xor", [icontext; icontext], icontext
; "zx", [icontext], icontext
] 

module SM = Strutil.Map
let resmap = List.fold_left (fun m (n, a, r) -> SM.add n r m) SM.empty operators
let argmap = List.fold_left (fun m (n, a, r) -> SM.add n a m) SM.empty operators

let arg_contexts   (n, _) = SM.find n argmap
let result_context (n, _) = SM.find n resmap
@ 
Operator hell (or heaven).
We start with binary operators in $L \mathrel{:=} L \oplus R$ form.
<<x86 expander>>=
let with_flags setflags dst op x y w =
  let x = tempval x in
  let y = tempval y in
  let exp = R.app op [x; y] in
  R.par [R.store (temploc dst) exp w; setflags x y w]

let with_lflags dst op x y w =
  let x = tempval x in
  let y = tempval y in
  let exp = R.app op [x; y] in
  R.par [R.store (temploc dst) exp w; logicflags exp w]

let at32 = function
  | opr, [32] -> opr
  | opr, [n]  -> Impossible.unimp ("%" ^ opr ^ string_of_int n ^ "(...)")
  | opr, _    -> Impossible.impossible ("ill-formed " ^ opr)

let llr op x y move = match at32 op with
| "add" -> with_flags addflags x (upop op) x y 32 :: move
| "sub" -> with_flags subflags x (upop op) x y 32 :: move
| ("and"|"or"|"xor") -> with_lflags x (upop op) x y 32 :: move
| _  ->
    R.store (temploc x) (R.app (upop op) [tempval x; tempval y]) (width x) :: move


let regpairv x y =
  let rval r = R.fetch r 32 in
  let zxreg l = R.app (R.opr "zx" [32; 64]) [rval l] in
  let shl v = R.app (R.opr "shl" [64]) [v; R.bits (Bits.U.of_int 32 32) 32]
  in R.app (R.opr "or" [64]) [shl (zxreg x); zxreg y]

let binop ~dst op x y = match at32 op with
(*
| "divu_trunc" ->
    let (ialloc, _) = icontext in
    let tmpd = ialloc 32 in
    let tmpa = ialloc 32 in
    let divmod =
      R.par [ R.store eax (R.app (R.opr "divu", [64;32]) [regpairv edx eax; tempval y])
            ; R.store edx (R.app (R.opr "modu", [64;32]) [regpairv edx eax; tempval y])
            ; R.kill eflags
            ]  in
    [ move_rtl eax tmpa; move_rtl edx tmpd    (* restore *)
    ; move_rtl dst eax; divmod                (* divide *)
    ; move_rtl eax x; R.store eax 0 32
    ; move_rtl tmpa eax; move_rtl tmpd edx    (* save *)
    ]
*)
| _ -> llr op dst y (move dst x)
@ 
Other operators are surely wrong.
<<x86 expander>>=
let unop ~dst op x =
  [R.store (temploc dst) (R.app (upop op) [tempval x])             (width dst)]

let rtlop ~dst op args =
  [R.store (temploc dst) (R.app (upop op) (List.map tempval args)) (width dst)]
@ 
\subsection{Control flow}
<<x86 expander>>=
let pc_lhs = pc
let pc_rhs = pc
@ 
There are some hairy semantics attached to some Pentium jumps, but
I~think we can stick with the simple ones for now.
<<x86 expander>>=
let br ~tgt = [R.store pc_lhs (tempval tgt) 32]
let b  ~tgt = [R.store pc_lhs (upconst tgt) 32]
@
To implement the comparisons, we define new operators that are private
to the $x$86 architecture. 
\begin{itemize}
\item [[x86_subflags]] returns what goes into the flags after a
[[sub]] or [[cmp]]
instruction.
\item [[x86_addflags]] returns what goes into the flags after a
[[add]] or [[adc]]
instruction.
\item
Operators [[x86_a]], [[x86_ae]], and so on, accept one argument, the
flags, and return a Boolean value that tells whether [[JA]], [[JAE]],
and so one, would jump.
\end{itemize}


<<x86 expander>>=
<<important functions on $x$86 operators>>
let cmp x y =
  R.store eflags (R.app (R.opr "x86_subflags" [32]) [tempval x; tempval y]) 32
let bc x (opr, ws) y ~tgt =
  assert (ws = [32]);
  [ R.guard (R.app (R.opr (cmpopr opr) [32]) [R.fetch eflags 32]) 
            (R.store pc_lhs (upconst tgt) 32)
  ; cmp x y
  ]

let uprtl   = R.Revert.rtl
let downrtl = R.Convert.rtl
let uploc   = R.Revert.loc
let downloc = R.Convert.loc

let bnegate r = match downrtl r with
| RP.Rtl [RP.App((cop, [32]), [RP.Fetch (flags, 32)]), RP.Store (pc, tgt, 32)]
  when pc = downloc pc_lhs && flags = downloc eflags ->
    uprtl (RP.Rtl [RP.App((cmpneg cop, [32]), [RP.Fetch (flags, 32)]),
                   RP.Store (pc, tgt, 32)])
| _ -> Impossible.impossible "ill-formed x86 conditional branch"
@ 
The first important functions converts a {\PAL} operator into the
corresponding Intel operator.
<<important functions on $x$86 operators>>=
let cmpopr = function
  | "eq"  -> "x86_e"
  | "ne"  -> "x86_ne"
  | "lt"  -> "x86_l"
  | "le"  -> "x86_le"
  | "gt"  -> "x86_g"
  | "ge"  -> "x86_ge"
  | "ltu" -> "x86_b"
  | "leu" -> "x86_be"
  | "gtu" -> "x86_a"
  | "geu" -> "x86_ae"
  | "feq"  -> Impossible.unimp "floating-point comparison"
  | "fne"  -> Impossible.unimp "floating-point comparison"
  | "flt"  -> Impossible.unimp "floating-point comparison"
  | "fle"  -> Impossible.unimp "floating-point comparison"
  | "fgt"  -> Impossible.unimp "floating-point comparison"
  | "fge"  -> Impossible.unimp "floating-point comparison"
  | "fordered"   -> Impossible.unimp "floating-point comparison"
  | "funordered" -> Impossible.unimp "floating-point comparison"
  | _ -> Impossible.impossible "non-comparison in x86 conditional branch"
@ 
The second important function negates an Intel operator.
<<important functions on $x$86 operators>>=
let cmpneg = function
  | "x86_ne" -> "x86_e"
  | "x86_e"  -> "x86_ne"
  | "x86_ge" -> "x86_l"
  | "x86_g"  -> "x86_le"
  | "x86_le" -> "x86_g"
  | "x86_l"  -> "x86_ge"
  | "x86_ae" -> "x86_b"
  | "x86_a" -> "x86_be"
  | "x86_be" -> "x86_a"
  | "x86_b" -> "x86_ae"
  | _ -> Impossible.impossible "bad comparison in expanded x86 conditional branch"
@ 
Some generic utilities.
<<x86.ml>>=
module PX = Post
let esp = PX.temploc ('r', 4, 32)
let espval = PX.tempval ('r', 4, 32)
let add x y = R.app (R.opr "add" [32]) [x; y]
let sub x y = R.app (R.opr "sub" [32]) [x; y]
let const n = R.bits (Bits.S.of_int n 32) 32
let mem = PX.mem
let fetch l = R.fetch l 32
let store l r = R.store l r 32
let pc = PX.pc

let pop_with f = (* rtl got by popping (f e), where e is top of stack *)
  let top = fetch (PX.mem espval) in
  R.par [ f top; store esp (add espval (const 4)) ]

let push e = (* effect of pushing e *)
  let next_sp = sub espval (const 4) in
  R.par [ store (mem next_sp) e; store esp next_sp ]

module T = Target2
module F = Mflow.Make (
  struct
     let pc_lhs = PX.pc_lhs
     let pc_rhs = PX.pc_rhs
     let ra_reg    = PX.temploc ('?', 99, 32) (* not used *)
     let ra_offset = 33                      (* not used *)
  end)
     
<<x86.ml>>=
module X = Expander.IntFloatAddr (PX)
(* expansion here causes infinite loop *)
let spill_expand = X.expand
let spill_expand r = [r]
let spill  _ t l =
  spill_expand (R.store l (PX.tempval t) (PX.tempwidth t))
let reload _ t l =
  spill_expand (R.store (PX.temploc t) (R.fetch l (PX.tempwidth t)) (PX.tempwidth t))

let target =
  { T.name = "x86"
  ; T.cc = (fun _ -> 
           { T.sp = esp
           ; T.return = pop_with (fun ra -> store pc ra)
           ; T.proc = Targets.dummy_automaton PX.byte_order
           ; T.cont = Targets.dummy_automaton PX.byte_order
           ; T.ret  = Targets.dummy_automaton PX.byte_order
           ; T.allocatable = List.map (fun n -> ('r', n, 32)) [0; 1; 2; 3]
           }) 
  ; T.byteorder = PX.byte_order
  ; T.wordsize = PX.wordsize
  ; T.pointersize = PX.wordsize
  ; T.alignment = 1
  ; T.memsize = 8
  ; T.float = "ieee754"
  ; T.charset = "latin1" (* THIS IS NONSENSE!! NOT A PROPERTY OF THE MACHINE?? *)
  ; T.globals = Targets.dummy_automaton PX.byte_order
  ; T.spaces = [Spaces.m; Spaces.r; Spaces.t; Spaces.f; Spaces.u; Spaces.c]
  ; T.data_section = "data"
  ; T.goto = F.goto
  ; T.jump = F.jump
  ; T.cutto = F.cutto (* BOGUS *)
  ; T.call = { T.embed = (fun e -> R.par [F.goto.T.embed e; push (fetch pc)])
             ; T.project = F.call.T.project (* should be OK *)
             } 
  ; T.branch = F.branch
  ; T.spill  = spill
  ; T.reload = reload
  ; T.stack_slots = Targets.dummy_automaton PX.byte_order
  } 
                          
