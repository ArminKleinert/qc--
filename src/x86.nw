x% -*- mode: Noweb; noweb-code-mode: caml-mode; comment-column: 32 -*-

% vim: ts=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Please add grades for this module below. The line must start with % "%%".
% 

%%Grades: I Peripheral Immediate

\section{Back end for an Intel x86 subset}

\label{x86.sec}

This exploratory back end is designed both to help us develop good
procedures for writing back ends and to serve as an example.
The names of spaces are standard.
<<x86.mli>>=
val arch : string                       (* name of machine*)
module Spaces : sig
  val m : Space.t
  val r : Space.t
  val t : Space.t
  val c : Space.t   (* PC at 0 and condition codes at 2 *)
end
module Post : Postexpander.S
module X    : Expander.S
val target : Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@ 

\subsection{Name and storage spaces}
<<x86.ml>>=
module SS = Space.Standard32
let arch = "x86"                (* architecture name *)
@ 
We use the standard storage spaces, with the PC and
condition codes in their standard locations from [[Space.Standard32]].
We can't use the standard \texttt{f} space because Pentium
floating-point values are 80~bits wide.
We pretend that the machine is a 32-bit machine, which simplifies a lot.
<<x86.ml>>=
module Spaces = struct
  module S = Space
  let bo = Rtl.LittleEndian
  let id = Rtl.Identity
  let m = Space.Standard32.m bo [8; 16; 32]
  let r = Space.Standard32.r 7 id [32]
  let t = Space.Standard32.t   id [32]
  let c = Space.Standard32.c 3 id [32]
end
@
                
end

@ 
\subsection{Postexpander}
<<x86.ml>>=
module R    = Rtl
module RP   = Rtl.Private
module RU   = Rtlutil
module Up   = Rtl.Up
module Down = Rtl.Dn
module Rg   = X86regs

let ( =$  ) = Register.eq
let ( =/  ) = RU.Eq.loc
let ( =// ) = RU.Eq.exp

let dspace = ('d', Rtl.Identity, Cell.of_size 2)

let fpcond n          = Rtl.reg  (dspace,n,R.C 1)  (* FP modes *)
let rounding_modesl   = fpcond 0
let rounding_resultsl = fpcond 1

let {SS.pc = pc; SS.cc = eflags} = SS.locations Spaces.c

let rounding_modesl = R.slice 2 ~lsb:10 Rg.fpuctl  (* OK, SO WHICH IS IT??? *)
let rounding_modes  = R.fetch rounding_modesl 2


module Post = struct
  <<x86 postexpander>>
end
@ 
<<x86 postexpander>>=
let byte_order = Rtl.LittleEndian
let wordsize   = 32
let memsize    = 8
let _, _, mcell as mspace = ('m', byte_order, Cell.of_size memsize)
let mcount = Cell.to_count mcell
@ 
These copies are a nuisance.
<<x86 postexpander>>=
type temp      = Register.t
type rtl       = Rtl.rtl
type width     = Rtl.width
type assertion = Rtl.assertion
type operator  = Rtl.Private.opr
@
The postexpander may need to allocate temporaries.
<<x86 postexpander>>=
let talloc = Reinit.ref None
let get_talloc () = match !talloc with
  | Some s -> s
  | None   -> Impossible.impossible "Temp allocator not registered with postexpander"
let remember_allocator ta = talloc := Some ta
let talloc space = Talloc.Multiple.reg space (get_talloc ()) (* don't eta-reduce *)
let remember_slot_allocator _ = ()
@ 
\paragraph{Contexts}
Addresses go in the integer registers, so we use these contexts:
<<x86 postexpander>>=
type context = (Talloc.Multiple.t -> int -> Register.t) * (Register.t -> bool)
let icontext = Talloc.Multiple.reg 't', fun ((c, _, _), _, _) -> c =<= 'r' || c =<= 't'
let fcontext = Talloc.Multiple.reg 'u', fun ((c, _, _), _, _) -> c =<= 'f' || c =<= 'u'
let fcontext = icontext  (* should be better with the stack?? *)
let acontext = icontext
let rcontext = (fun x y -> Impossible.unimp "Unsupported soft rounding mode")
               ,(function (('d',_,_), 0, R.C 1) -> true | _ -> false)
let itempwidth = 32
@ 
\paragraph{Addressing modes}
The only addressing mode is the obvious one.
<<x86 postexpander>>=
module Address = struct
  type t = Rtl.exp
  let reg r = R.fetch (R.reg r) (Register.width r)
end
@ 
\subsubsection{Basic locations, flags, and helper functions}
We need to record the various side effects.

Here are some utility functions for computing locations, values, and widths.
<<x86 postexpander>>= 
let tempwidth = Register.width
let temploc t = Rtl.reg t
let tempval t = R.fetch (temploc t) (tempwidth t)
let mem addr = R.mem R.none mspace (R.C 4) addr
@ 
Here are some important locations.
<<x86 postexpander>>=
let {SS.pc = pc; SS.cc = eflags} = SS.locations Spaces.c
let eax = temploc Rg.eax
let ecx = temploc Rg.ecx
let edx = temploc Rg.edx
let esp = temploc Rg.esp
let esi = temploc Rg.esi
let edi = temploc Rg.edi

let upint32 n = Up.const (RP.Bits(Bits.U.of_int n 32))
let upint8  n = Up.const (RP.Bits(Bits.U.of_int n 8))

let ah_val = R.fetch Rg.ah 8
@ 
Here are some invented operators that hide the real truth about what
happens to the flags.
IF WE WANT TO MAKE BORROW AND CARRY WORK, WE WILL NEED TO PASS A THIRD
ARGUMENT TO SUBFLAGS AND ADDFLAGS.  THIS WILL MEAN CHANGES IN THE
RECOGNIZER, OF COURSE.
@ 
<<x86 postexpander>>=
let negflags   x   w = R.store eflags (R.app (R.opr "x86_negflags"   [w]) [x])    32
let subflags   x y w = R.store eflags (R.app (R.opr "x86_subflags"   [w]) [x; y]) 32
let addflags   x y w = R.store eflags (R.app (R.opr "x86_addflags"   [w]) [x; y]) 32
let mulflags   x y w = R.store eflags (R.app (R.opr "x86_mulflags"   [w]) [x; y]) 32
let muluxflags x y w = R.store eflags (R.app (R.opr "x86_muluxflags" [w]) [x; y]) 32
let undefflags       = R.store eflags (R.app (R.opr "x86_undefflags" [])  [])     32
let logicflags exp w = R.store eflags (R.app (R.opr "x86_logicflags" [w]) [exp])  32
let shflags sh x y w =
  let flagsop = "x86_" ^ sh ^ "flags" in
  R.store eflags (R.app (R.opr flagsop [w]) [x; y]) 32
@ 
\subsubsection{Data movement}
Most data movement is simple assignment; the MOV instruction is quite powerful.
Because we're treating the Penitum as a 32-bit machine, we assert the
width of everything is~32. 
<<x86 postexpander>>=
let load ~dst ~addr assn =
  assert (tempwidth dst = 32);
  [R.store (temploc dst) (R.fetch (R.mem assn mspace (R.C 4) addr) 32) 32]
let store ~addr ~src assn =
  assert (tempwidth src = 32);
  [R.store (R.mem assn mspace (R.C 4) addr) (tempval src) 32]
@ 
The Pentium provides sign-extending loads and stores.
<<x86 postexpander>>=
let extend opname n e = R.app (R.opr opname   [n; 32]) [e]
let lobits        n e = R.app (R.opr "lobits" [32; n]) [e]
let sxload ~dst ~addr n assn =
  if tempwidth dst <> 32 then Impossible.unimp "widening of temporaries";
  [R.store (temploc dst)
             (extend "sx" n (R.fetch (R.mem assn mspace (mcount n) addr) n)) 32]
let zxload ~dst ~addr n assn =
  assert (tempwidth dst = 32);
  [R.store (temploc dst)
             (extend "zx" n (R.fetch (R.mem assn mspace (mcount n) addr) n)) 32]
let lostore ~addr ~src n assn =
  assert (tempwidth src = 32);
  [ R.store (R.mem assn mspace (mcount n) addr) (lobits n (R.fetch eax n)) n
  ; R.store eax (tempval src) 32
  ]
@ 
This code hasn't yet been checked for compatility with floating point.
<<x86 postexpander>>=
let move_rtl dst src = R.store (temploc dst) (tempval src) (tempwidth src)
let move ~dst ~src   = if Register.eq dst src then [] else [move_rtl dst src]
@ 
Load immediate is also a simple move.
<<x86 postexpander>>=
let li  ~dst const = [R.store (temploc dst) (Up.const const) (tempwidth dst)]
let lix ~dst e     = [R.store (temploc dst) e                (tempwidth dst)]
@ 
\subsubsection{Operator contexts}
Here are tentative contexts for all the operators.
Anything that has to do with rounding modes is surely wrong.
<<x86 postexpander>>=
let bcontext = (fun x y -> Impossible.impossible "allocate from bcontext")
               ,fun _ -> false
let operators = Context.standard icontext fcontext rcontext acontext bcontext

module SM = Strutil.Map
let resmap = List.fold_left (fun m (n, a, r)-> SM.add n r m) SM.empty operators
let argmap = List.fold_left (fun m (n, a, r)-> SM.add n a m) SM.empty operators

let arg_contexts   (n, _) = try SM.find n argmap 
                            with Not_found -> Impossible.impossible 
                                    ("cannot find arg context for "^n)
let result_context (n, _) = try SM.find n resmap
                            with Not_found -> Impossible.impossible
                                    ("cannot find result context for "^n)
let constant_context w = icontext
@ 
\subsubsection{Operator implementations (with flags)}
Operator hell (or heaven).
We support (so far) two kinds of abstract operations on the flags.
An arithmetic-like or comparison instruction needs {two} \emph{operands}
to set the flags; a logical instruction needs only the \emph{result}.
<<x86 postexpander>>=
let exp_with_flags setflags dst exp x y w =
  R.par [R.store (temploc dst) exp w; setflags x y w]

let with_flags setflags dst op x y w =
  let x = tempval x in
  let y = tempval y in
  let exp = R.app op [x; y] in
  exp_with_flags setflags dst exp x y w

let with_lflags dst op x y w =
  let x = tempval x in
  let y = tempval y in
  let exp = R.app op [x; y] in
  R.par [R.store (temploc dst) exp w; logicflags exp w]
@ 
We insist on using most operators at their natural 32-bit width, and
this function is the forcing function that makes it so.
<<x86 postexpander>>=
let at32 = function
  | "lobits", [32; 32] -> "lobits"
  | opr, [32] -> opr
  | opr, [n]  -> Impossible.unimp ("%" ^ opr ^ string_of_int n ^ "(...)")
  | opr, ws   ->
      Impossible.impossible
        (Printf.sprintf "operator %%%s specialized to %d widths" opr (List.length ws))
@ 
We start our implementation with a function that provides binary
operators in $L \mathrel{:=} L \oplus R$ form. 
<<x86 postexpander>>=
let llr op x y move = match at32 op with
| "add" -> with_flags addflags x (Up.opr op) x y 32 :: move
| "sub" -> with_flags subflags x (Up.opr op) x y 32 :: move
| "mul" -> with_flags mulflags x (Up.opr op) x y 32 :: move
@
Division is rather painful on the x86.
We have to place the dividend in the EDX:EAX register pair, and we have to represent
the destination as a register pair.
[[regpairv]] does most of the work, creating the rtl's to form the register pair, as
well as the expression representation of the register pair.
I have tried to make [[regpairv]] fairly general; we won't know if this is a success
until we try it with other versions of the x86 divide instruction.
<<x86 postexpander>>=
| ("div" | "mod") -> Unsupported.div_and_mod()
| ("divu" | "quot" | "modu" | "rem") as opname ->
    let unsigned = opname =$= "divu" || opname =$= "modu" in
    let regpairv w hreg lreg =
      let rval  r = R.fetch (temploc r) w in
      let sh op l r = R.app (R.opr op [w]) [l; R.bits (Bits.U.of_int r w) w] in
      let zxreg l = R.app (R.opr "zx" [w; w*2]) [rval l] in
      let pairval = R.app (R.opr "or" [w*2]) [sh "shl" (zxreg hreg) w; zxreg lreg] in
            (* notice the ill-typed shift-left *)
      let sethi =
        if unsigned then
          [ R.store (temploc hreg) (R.bits (Bits.zero w) w) w ]
        else
          let sbit = temploc (talloc 't' w) in
          let sbitval = R.fetch sbit w in
          [ R.store (temploc hreg) sbitval w
          ; R.store sbit           (sh "shra" sbitval (w-1)) w
          ; R.store sbit           (rval lreg) w
          ] in
      sethi, pairval in
    let (is, regpair) = regpairv 32 Rg.edx Rg.eax in
    let q, r = if unsigned then "divu", "modu" else "quot", "rem" in
    let div = R.par [R.store eax (R.app (R.opr q [64;32]) [regpair; tempval y]) 32;
                     R.store edx (R.app (R.opr r [64;32]) [regpair; tempval y]) 32;
                     undefflags] in
    let answer = if opname =$= "rem" || opname =$= "modu" then Rg.edx else Rg.eax in
    move_rtl x answer :: div :: is @ move_rtl Rg.eax x :: move
@ 
Unsigned, extended multiplication is also painful---especially as we
don't have any 64-bit temporaries!
The multiplicand goes in EAX and the product winds up in 
the EDX:EAX register pair.
<<unused code for x86 postexpander>>=
| "mulux" ->
    let regpairstore hreg lreg v =
      let lobits32 v = R.app (R.opr "lobits" [32]) [v] in
      let hibits32 v = lobits32 (R.app (R.opr "shrl" [64])
                                 [v; R.bits (Bits.U.of_int 32 64) 64]) in
      R.par [R.store hreg (hibits32 v) 32; R.store lreg (lobits32 v) 32] in
    let mulux =
      R.par [regpairstore edx eax
               (R.app (R.opr "mulux" [32]) [R.fetch eax 32; tempval y]);
             muluxflags (R.fetch eax 32) (tempval y) 32] in
    move_rtl x Rg.eax :: mulux :: move_rtl Rg.eax x :: move
@ 
I don't know why it's safe to clobber ECX here.
The problem would arise if the {\PAL} source mentioned ECX, perhaps
because it wants to use ECX as the heap pointer or somethign like
that.

The safe thing to do would be to save and restore ECX before using it,
but at present we don't have an optimization pass capable of
eliminating all those dead saves and restores.  So we live dangerously.
<<x86 postexpander>>=
| ("shl" | "shrl" | "shra") as shop ->
    let cl = R.fetch Rg.cl 8 in
    let sh = exp_with_flags (shflags shop) x (R.app (Up.opr op) [tempval x; cl])
              (tempval x) cl 32 in
    sh :: move_rtl Rg.ecx y :: move
<<x86 postexpander>>=
| ("and"|"or"|"xor") -> with_lflags x (Up.opr op) x y 32 :: move
| _  ->
    R.store (temploc x) (R.app (Up.opr op) [tempval x; tempval y]) (tempwidth x) :: move
@ 
<<x86 postexpander>>=
let binop ~dst op x y = match at32 op with
| _     -> llr op dst y (move dst x)
@ 
Multiplication and division are bound to be a nightmare.
Here is some tentative code that will one day be generalized to ``move
hardware registers out of the way.''
<<x86 postexpander>>=
let regpairv x y =
  let rval r = R.fetch r 32 in
  let zxreg l = R.app (R.opr "zx" [32; 64]) [rval l] in
  let shl v = R.app (R.opr "shl" [64]) [v; R.bits (Bits.U.of_int 32 32) 32]
  in R.app (R.opr "or" [64]) [shl (zxreg x); zxreg y]

let divu_trunc icontext dst x y =
    let (ialloc, _) = icontext in
    let tmpd = ialloc 32 in
    let tmpa = ialloc 32 in
    let divmod = R.par
        [ R.store eax (R.app (R.opr "divu" [64;32]) [regpairv edx eax; tempval y]) 32
        ; R.store edx (R.app (R.opr "modu" [64;32]) [regpairv edx eax; tempval y]) 32
        ; R.kill eflags
        ]  in
    [ move_rtl Rg.eax tmpa; move_rtl Rg.edx tmpd    (* restore *)
    ; move_rtl dst Rg.eax; divmod                (* divide *)
    ; move_rtl Rg.eax x; R.store (temploc Rg.eax) (upint32 0) 32
    ; move_rtl tmpa Rg.eax; move_rtl tmpd Rg.edx    (* save *)
    ]
@ 
Other operators are surely wrong.
<<x86 postexpander>>=
let inplace op x move = match at32 op with
| "neg" -> R.par [R.store (temploc x) (R.app (Up.opr op) [tempval x]) 32;
                  negflags (tempval x) 32]
           :: move
| "lobits" -> move  (* lobits32 is identity *)
| _ ->
    R.store (temploc x) (R.app (Up.opr op) [tempval x]) (tempwidth x) :: move

let unop ~dst op x = inplace op dst (move dst x)

let rtlop ~dst op args =
  [R.store (temploc dst) (R.app (Up.opr op) (List.map tempval args)) (tempwidth dst)]
@ 
\subsubsection{Control flow}

There's just one PC on the Pentium.
<<x86 postexpander>>=
let pc_lhs = pc
let pc_rhs = pc
@ 
There are some hairy semantics attached to some Pentium jump
instructions, but I~think we can stick with the simple ones for now. 
<<x86 postexpander>>=
let br ~tgt = [R.store pc_lhs (tempval tgt) 32]
let b  ~tgt = [R.store pc_lhs (Up.const tgt) 32]
@ 
The call instructions came from us, so we can rely on the single extra effects pushing the program counter.
<<x86 postexpander>>=
let effects = List.map Up.effect
let call  ~tgt ~others = [R.par (R.store pc_lhs (Up.const tgt) 32 :: effects others)]
let callr ~tgt ~others = [R.par (R.store pc_lhs (tempval tgt) 32 :: effects others)]
@ 
The [[cut to]] is our own little conspiracy.
<<x86 postexpander>>=
let cut_to effs = [R.par (effects effs)]
@ 
We don't touch anything that pops the PC.
That means the return instruction!
<<x86 postexpander>>=
let don't_touch_me = 
  let lowpc = Down.loc pc in
  function
  | [ RP.Store (pc', _, _)
    ; RP.Store (RP.Reg sp, RP.App (("add", [32]), [RP.Fetch (RP.Reg sp2, _);
                                                      RP.Const (RP.Bits b)]), _)] ->
      pc' =/ lowpc && sp =$ Rg.esp && sp2 =$ Rg.esp && Bits.S.to_int b = 4
  | _ -> false
@
To implement the comparisons, we define new operators that are private
to the $x$86 architecture. 
\begin{itemize}
\item [[x86_subflags]] returns what goes into the flags after a
[[sub]] or [[cmp]]
instruction.
\item [[x86_addflags]] returns what goes into the flags after a
[[add]] or [[adc]]
instruction.
\item [[x86_mulflags]] returns what goes into the flags after an
[[imul]] instruction.
\item [[x86_divflags]] returns what goes into the flags after an
[[idiv]] instruction.
\item
Operators [[x86_a]], [[x86_ae]], and so on, accept one argument, the
flags, and return a Boolean value that tells whether [[JA]], [[JAE]],
and so one, would jump.
\end{itemize}
<<x86 postexpander>>=
<<important functions on $x$86 operators>>
let cmp x y =
  R.store eflags (R.app (R.opr "x86_subflags" [32]) [tempval x; tempval y]) 32

let bc_x86 x86opname tgt =
  R.guard (R.app (R.opr x86opname [32]) [R.fetch eflags 32]) 
    (R.store pc_lhs (Up.const tgt) 32)

let bc x (opr, ws) y ~tgt =
  assert (ws =*= [32]);
  bc_x86 (cmpopr opr) tgt :: (cmpfun tgt opr) x y

let bnegate r = match Down.rtl r with
| RP.Rtl [RP.App((cop, [32]), [RP.Fetch (flags, 32)]), RP.Store (pc, tgt, 32)]
  when RU.Eq.loc pc (Down.loc pc_lhs) && RU.Eq.loc flags (Down.loc eflags) ->
    Up.rtl (RP.Rtl [RP.App((cmpneg cop, [32]), [RP.Fetch (flags, 32)]),
                   RP.Store (pc, tgt, 32)])
| _ -> Impossible.impossible "ill-formed x86 conditional branch"
@ 
The first ``important'' function converts a {\PAL} operator into the
corresponding Intel operator.
<<important functions on $x$86 operators>>=
let cmpopr = function
  | "eq"  -> "x86_e" 
  | "ne"  -> "x86_ne"
  | "lt"  -> "x86_l" 
  | "le"  -> "x86_le"
  | "gt"  -> "x86_g" 
  | "ge"  -> "x86_ge"
  | "ltu" -> "x86_b" 
  | "leu" -> "x86_be"
  | "gtu" -> "x86_a" 
  | "geu" -> "x86_ae"
  | "add_overflows"
  | "div_overflows"
  | "mul_overflows"
  | "mulu_overflows"
  | "sub_overflows" -> "x86_o"
  | _ -> Impossible.impossible "non-comparison in x86 conditional branch"
@ 
The second important function negates an Intel operator.
<<important functions on $x$86 operators>>=
let cmpneg = function
  | "x86_ne" -> "x86_e"
  | "x86_e"  -> "x86_ne"
  | "x86_ge" -> "x86_l"
  | "x86_g"  -> "x86_le"
  | "x86_le" -> "x86_g"
  | "x86_l"  -> "x86_ge"
  | "x86_ae" -> "x86_b"
  | "x86_a"  -> "x86_be"
  | "x86_be" -> "x86_a"
  | "x86_b"  -> "x86_ae"
  | "x86_np" -> "x86_p"
  | "x86_p"  -> "x86_np"
  | "x86_nc" -> "x86_c"
  | "x86_c"  -> "x86_nc"
  | "x86_nz" -> "x86_z"
  | "x86_z"  -> "x86_nz"
  | "x86_o"  -> "x86_no"
  | "x86_no" -> "x86_o"
  | _ -> Impossible.impossible "bad comparison in expanded x86 conditional branch"
@ 
The third important function returns the ``flag set'' function for an
operator. This is normally just [[cmp]], but in the case of overflow,
we need to emit arithmetic instructions to set the flags. Division is
a bit more complex since a division overflow causes a fault. However,
there is only one possibility for division overflow ($MIN_INT / -1$)
to check for.
<<important functions on $x$86 operators>>=
let cmpfun tgt =
  let set_flags op x y = binop (talloc 't' 32) (op, [32]) x y
  and cmp x y = [subflags (tempval x) (tempval y) 32] in
  let div_flags x y = Unsupported.div_overflows () in
  function
  | "eq"
  | "ne"
  | "lt"
  | "le"
  | "gt"
  | "ge"
  | "ltu"
  | "leu"
  | "gtu"
  | "geu"            -> cmp
  | "add_overflows"  -> set_flags "add"
  | "div_overflows"  -> div_flags
  | "quot_overflows" -> div_flags
  | "mul_overflows"  -> set_flags "mul"
  | "mulu_overflows" -> set_flags "mulux"
  | "sub_overflows"  -> set_flags "sub"
  | _ -> Impossible.impossible "non-comparison in x86 conditional branch"
@ 
\subsection{Stack operations}
<<x86 postexpander>>=
module PX = Postexpander
let opclass (op, _) =
  match op with
  | "i2f" | "f2f" | "f2f_implicit_round" | "f2i" | "fabs" | "fneg" | "fsqrt" ->
      PX.Stack(PX.LeftFirst, 1)
  | "fadd" | "fcmp" | "fdiv" | "fmul" | "fmulx" | "fsub"    
  | "feq" | "fge" | "fgt" | "fne"     
  | "fordered" | "funordered" ->
      PX.Stack(PX.RightFirst, 2)
  | "fle" | "flt"  -> PX.Stack(PX.LeftFirst, 2)  (* computed by swapping *)
  | _ ->
      PX.Register

let converts_stack_to_temp (op, _) = op =$= "f2i" || op =$= "f2f"

<<x86 postexpander>>=
let stspace = ('F', Rtl.Identity, Cell.of_size 3)
let fspace  = ('f', Rtl.Identity, Cell.of_size 80)
let st = temploc (stspace, 0, R.C 1)
let stval = R.fetch st 3
let freg_at a = R.mem R.none fspace (R.C 1) a
let streg = freg_at stval
let stadd = Rtlutil.addk 3 stval
let stsub n = R.app (R.opr "sub" [3]) [stval; R.bits (Bits.U.of_int n 3) 3]
let stregplus n = freg_at (stadd n)
let ffetch l = R.fetch l 80
<<x86 postexpander>>=
let st_pop_with f = (* rtl got by popping (f e), where e is top of floating-pt stack *)
  let top = ffetch streg in
  R.par [ f top; R.store st (stadd 1) 3 ]

let st_push e = (* effect of pushing e *)
  let next_st = stsub 1 in
  R.par [ R.store (freg_at next_st) e 80; R.store st next_st 3 ]


let stack_depth = 8
let stack_width = 80
let stack_top_proxy_reg = X86call.stack_top_proxy_reg
let stack_top_proxy = R.reg stack_top_proxy_reg
let is_stack_top_proxy = function
  | RP.Reg r -> Register.eq r stack_top_proxy_reg
  | _ -> false
<<x86 postexpander>>=
let push ~addr assn = 
(*
  let memval = R.fetch (R.mem assn mspace 80 addr) 80 in
  [st_push memval] (* bound to break *)
*)
Impossible.impossible "push 80-bit float without conversion"

let store_pop ~addr assn = 
  let store regval = R.store (R.mem assn mspace (mcount 80) addr) regval 80 in
  [st_pop_with store] (* bound to break *)
(*Impossible.impossible "store 80-bit float without conversion"*)

let push_cvt op w ~addr assn =
  assert (Cell.divides mcell w);
  let memval = R.fetch (R.mem assn mspace (mcount w) addr) w in
  let regval = R.app (Up.opr op) [memval; rounding_modes] in
  [st_push regval]

let store_pop_cvt op w ~addr assn =
  assert (Cell.divides mcell w);
  let memval regval = R.app (Up.opr op) [regval; rounding_modes] in
  let store regval = R.store (R.mem assn mspace (mcount w) addr) (memval regval) w in
  [st_pop_with store]
<<x86 postexpander>>=
let pushk _ = Impossible.impossible "load 80-bit floating-point constant"
let pushk_cvt _ _ _ = Impossible.unimp "load floating-point constant"
<<x86 postexpander>>=
let stack_op op = match opclass op with
| PX.Register -> Impossible.impossible "passed register operator to stack_op"
| PX.Stack(_, depth) -> (* by lucky accident, depth is arity *)
    let positions = Aux.from 0 (depth-1) in
    let argvals = List.map (fun n -> ffetch (stregplus n)) positions in
    let argvals = match op with
    | ("fadd"|"fsub"|"fdiv"|"fmul"|"f2f"|"f2i"|"i2f"), _ ->
        argvals @ [rounding_modes]
    | _ -> argvals in
    let result = R.app (Up.opr op) argvals in
    let next_st = stadd (depth-1) in
    if depth = 1 then
      [ R.store (freg_at next_st) result 80]
    else
      [R.par [ R.store (freg_at next_st) result 80; R.store st next_st 3]]
@ 
The machine from hell:
\begin{itemize}
\item
The result of a floating point comparison goes in C0--C3,
which are respectively bits 8--10 and~11 of the FPU status word, where
bit~0 is the least significant bit.
\item
The \texttt{fstsw} instruction moves the FPU status word into AX,
which is the least significant 16~bits of EAX.
\item
The \texttt{sahf} instruction moves AH~into the flags:
\begin{quote}
\begin{tabular}{|llll|cccc|}
\hline
Flag& AH bit& FPU bit&FPU code&$\parallel$&$>$&$<$&$=$\\
\hline
SF&7&15& B (FPU busy)&&&&\\
ZF&6&14& C3& 1&0&0&1\\
AF&4&12& middle bit of TOP&&&&\\
PF&2&10& C2& 1& 0&0&0\\
CF&0&8& C0& 1&0&1&0\\
\hline
\end{tabular}
\end{quote}
Apparently it suffices to test ZF and CF.
\item
Therefore
\begin{quote}
\def\f#1{\mathord{\mbox{\uppercase{#1F}}}}
\begin{tabular}{lll}
\emph{Comparison}& \emph{Test}& \emph{Instruction}\\
Float $\parallel$& $\f p = 1$& JP\\
Float $\not\parallel$&$\f p = 0$& JNP\\
Float $<$& ugly & swap and compute $>$\\
Float $\le$& ugly & swap and compute $\ge$\\
Float $>$& $\f c = 0 \land \f z = 0$& JA \\
Float $\ge$& $\f c = 0$& JNC \\
Float $=$&$\f p = 0 \land \f z = 1$& ANDB AH,0x44; XORB AH, 0x40; JZ\\
Float $\ne$&$\lnot(\f p = 0 \land \f z = 1)$& ANDB AH,0x44; XORB AH, 0x40; JNZ\\
\end{tabular}
\end{quote}
\end{itemize}
<<x86 postexpander>>=
let fpcmpopr = function
  | "feq"  -> "x86_z"  (* AH is    zero when xor'ed with the flag pattern for feq *)
  | "fne"  -> "x86_nz" (* AH is nonzero when xor'ed with the flag pattern for feq *)
  | "flt" | "fgt" -> "x86_a"   (* flt is swapped fgt *)
  | "fle" | "fge" -> "x86_nc"  (* fle is swapped fge *)
  | "fordered"    -> "x86_np"
  | "funordered"  -> "x86_p"
  | _ -> Impossible.impossible "floating-point comparison operator"

let bc_stack op ~tgt = match op with
| ("fordered"|"funordered"|"flt"|"fgt"|"fle"|"fge"|"feq"|"fne") as opname, [w] ->
    let positions = Aux.from 0 1 in
    let argvals = List.map (fun n -> ffetch (stregplus n)) positions in
    let result = R.app (R.opr "x86_fcmp" [w]) argvals in
    let next_st = stadd 2 in
    let setcc = R.par [R.store Rg.fpcc result 2; R.store st next_st 3] in
    let fstsw = R.store Rg.ax (R.fetch Rg.fpustatus 16) 16 in
    (match opname with
    | "feq" | "fne" ->
        let andb = R.opr "and" [8] in
        let xorb = R.opr "xor" [8] in
        let logic f l r = R.par [f l r 8; logicflags r 8] in
        let clear_extra     = logic R.store Rg.ah (R.app andb [ah_val; upint8 0x45]) in
        let xor_with_eq_pat = logic R.store Rg.ah (R.app xorb [ah_val; upint8 0x40]) in
        (* at this point, ZF = 0 iff the flags showed floating eq *)
        [bc_x86 (fpcmpopr opname) tgt; xor_with_eq_pat; clear_extra; fstsw; setcc]
    | _ ->
        let sahf  = R.store eflags (R.app (R.opr "x86_ah2flags" []) [ah_val]) 16 in
        [bc_x86 (fpcmpopr opname) tgt; sahf; fstsw; setcc])
| _ ->
    Impossible.impossible "strange operator in x86 bc_stack"
@ 
The general block copy is implemented with the ``x86_repmovs''
operator which translates to and [[rep movs]] in the recognizer. This
implementation assumes that the direction flag is set properly. The
emitted code could be improved by using [[movsw]] or [[movsd]] if the
number of bytes to copy is a multiple of 2 or 4 respectively. However,
I am not sure where this optimization should take place. -PG
<<x86 postexpander>>=
let i2f_64_80 = ("i2f", [64; 80])
let f2i_80_64 = ("f2i", [80; 64])
let block_copy ~dst dassn ~src sassn w =
  match w with
  | 16 | 8 ->
      let t = talloc 't' 32 in
      lostore dst t w dassn @ zxload t src w sassn
  | 32 ->
      let t = talloc 't' 32 in
      store dst t dassn @ load t src sassn
  | 64 ->
      store_pop_cvt f2i_80_64 64 dst dassn @ push_cvt i2f_64_80 64 src sassn
  | n ->
      let bytes     = n / 8
      and const n   = R.bits (Bits.S.of_int n 32) 32
      and sub r c   = R.app (R.opr "sub" [32]) [R.fetch r 32; c]
      and byte_at r = R.mem R.none mspace (R.C 1) (R.fetch r 32) in
      let repmovsb =
        R.par [ R.store ecx (sub ecx (const 1)) 32
              ; R.store esi (sub esi (const bytes)) 32
              ; R.store edi (sub edi (const bytes)) 32
              ; R.store (byte_at esi) (R.fetch (byte_at edi) 8) 8
              ; R.guard (R.fetch ecx 32) (R.store pc (R.fetch pc 32) 32)
              ]
      in
      List.rev
        [ R.store esi src 32
        ; R.store edi dst 32
        ; R.store ecx (const bytes) 32
        ; repmovsb
        ]
@
\subsection{Building the target}
With the postexpander in place, we can build a target.
We begin with more utility functions
<<x86.ml>>=
module PX = Post
let pc        = pc
let espval    = PX.tempval X86regs.esp
let add       = Rtlutil.add 32
let sub x y   = R.app (R.opr "sub" [32]) [x; y]
let const n   = R.bits (Bits.S.of_int n 32) 32
let mem       = PX.mem
let fetch l   = R.fetch l 32
let store l r = R.store l r 32
@ 
These functions help with instructions that push and pop.
<<x86.ml>>=
let pop_with f = (* rtl got by popping (f e), where e is top of stack *)
  let top = fetch (PX.mem espval) in
  R.par [ f top; store PX.esp (add espval (const 4)) ]

let push e = (* effect of pushing e *)
  let next_sp = sub espval (const 4) in
  R.par [ store (mem next_sp) e; store PX.esp next_sp ]
@ 
We now build the standard control flow.
<<x86.ml>>=
module T = Target
module FS = Mflow.MakeStandard (
  struct
     let pc_lhs = PX.pc_lhs
     let pc_rhs = PX.pc_rhs
     let ra_reg =
       PX.temploc (('?', Rtl.Identity, Cell.of_size 0), 99, R.C 1) (* not used *)
     let ra_offset = 33                       (* not used *)
  end)
module F = struct
  include FS
  let call =
    { T.embed = (fun e -> R.par [FS.goto.T.embed e; push (fetch pc)])
    ; T.project = FS.call.T.project (* should be OK *)
    }
  let return = 
    { T.embed = (fun () -> pop_with (fun ra -> store pc ra))
    ; T.project = (fun r  -> Impossible.unimp "projected return")
    }
end
@      
There's no science here---just a lot of goo.
The [[Target.t]] abstraction could use some thought.
<<x86.ml>>=
module X = Expander.IntFloatAddr (PX)
(* expansion here once caused infinite loop *)
let spill_expand p r = [r]
let spill  p t l =
  spill_expand p (Automaton.store l (PX.tempval t) (PX.tempwidth t))
let reload p t l =
  spill_expand p (R.store (PX.temploc t) (Automaton.fetch l (PX.tempwidth t)) (PX.tempwidth t))
@ 
Parts of the target record are reasonable.
Parts are lies.
Parts are baffling---why is character set characterized by the target?
<<x86.ml>>=
let downrtl = Down.rtl
let uploc   = Up.loc
let upexp   = Up.exp

module A = Automaton
let ( *> ) = A.( *> )
let globals base = 
  let width w = if w <= 8 then 8 else if w <= 16 then 16 else Aux.round_up_to 32 w in
  let align = function 8 -> 1 | 16 -> 2 | _ -> 4 in
  A.at PX.mspace ~start:base 
    (A.widen width *> A.align_to align *>
     A.overflow ~growth:Memalloc.Up ~max_alignment:4)

let target =
  let spaces = [Spaces.m; Spaces.r; Spaces.t; Spaces.c] in
  let b i = Types.Bits i in
  { T.name = "x86"
  ; T.memspace = PX.mspace
  (* basic metrics and spaces are OK *)
  ; T.byteorder   = PX.byte_order  
  ; T.wordsize    = PX.wordsize
  ; T.pointersize = PX.wordsize
  ; T.vfp         = SS.vfp
  ; T.alignment = 1
  ; T.memsize = PX.memsize
  ; T.spaces = spaces
  ; T.reg_ix_map          = T.mk_reg_ix_map spaces
  ; T.distinct_addr_sp = false

  (* Does the Pentium really implement IEEE 754?  I think so *)
  ; T.float = Float.ieee754

  (* spill and reload are believed OK *)
  ; T.spill  = spill
  ; T.reload = reload

  (* control flow is solid, except [[cutto]] is a lie *)
  ; T.bnegate = F.bnegate eflags
  ; T.goto    = F.goto
  ; T.jump    = F.jump
  ; T.call    = F.call
  ; T.return  = F.return
  ; T.branch  = F.branch

  ; T.cc_specs         = A.init_cc
  ; T.cc_spec_to_auto  = X86call.cconv 
                           ~return_to:(fun ra -> 
                                         pop_with (fun ra -> store pc ra))
                           (F.cutto PX.esp)

  ; T.is_instruction = X86rec.M.is_instruction

  ; T.machine_env = {T.ops = [
                         "sx",      [b  8; b 32]
                       ; "sx",      [b  1; b 32]
                       ; "sx",      [b 16; b 32]
                       ; "zx",      [b  1; b 32]
                       ; "zx",      [b  8; b 32]
                       ; "zx",      [b 16; b 32]
                       ; "lobits",  [b 32; b  1]
                       ; "lobits",  [b 32; b  8]
                       ; "lobits",  [b 32; b 16]
                       ; "lobits",  [b 32; b 32]
                       ; "sxlo",    [b 32; b 32]
                       ; "zxlo",    [b 32; b 32]
                       ; "add",     [b 32]
                       ; "and",     [b 32]
                       ; "com",     [b 32]
                       ; "div",     [b 32]
                       ; "divu",    [b 32]
                       ; "mod",     [b 32]
                       ; "modu",    [b 32]
                       ; "mul",     [b 32]
                       ; "mulx",    [b 32]
                       ; "mulux",   [b 32]
                       ; "neg",     [b 32]
                       ; "or",      [b 32]
                       ; "quot",    [b 32]
                       ; "rem",     [b 32]
                       ; "shl",     [b 32]
                       ; "shra",    [b 32]
                       ; "shrl",    [b 32]
                       ; "sub",     [b 32]
                       ; "xor",     [b 32]
                       ; "eq",      [b 32]
                       ; "ge",      [b 32]
                       ; "geu",     [b 32]
                       ; "gt",      [b 32]
                       ; "gtu",     [b 32]
                       ; "le",      [b 32]
                       ; "leu",     [b 32]
                       ; "lt",      [b 32]
                       ; "ltu",     [b 32]
                       ; "ne",      [b 32]
                       ; "not",     []
                       ; "bool",    []
                       ; "disjoin", []
                       ; "bit",     []
                   ]; T.literal = [32;64]}

  (* global or hardware registers *)
  ; T.globals  = globals
  ; T.rounding_mode = rounding_modesl
  ; T.named_locs   = Strutil.assoc2map 
                     ["IEEE 754 rounding mode",    rounding_modesl
                     ;"IEEE 754 rounding results", rounding_resultsl
                     ]
  
  (* bogosity *)
  ; T.data_section = "data" (* NOT REALLY A PROPERTY OF THE TARGET MACHINE... *)
  ; T.charset = "latin1" (* THIS IS NONSENSE!! NOT A PROPERTY OF THE MACHINE?? *)
  } 

type tgt  = ((Rtl.exp -> Automaton.t), Call.t) Target.t
@ 
\subsection{Variable placement}
The machine accepts only three widths of floating-point variables: 32,
64, and 80~bits.
Any 80-bit value is seen as a float (this might be wrong in the case
of an 80-bit structure variable, so the decision should be revisited).
A~32-bit or 64-bit value would have to be suitably hinted to be seen
as a float.
Because floating-point registers are organized as a stack, we can't
use the registers effectively for variables, so floats go in memory.

Any other value of width at most~32 goes into a temporary.
Larger values go straight to memory.

FOR WARNINGS, IT MIGHT BE USEFUL TO INCLUDE A VARIABLE NAME SOMEWHERE,
SOMEHOW.
<<x86.ml>>=
let warning s = Printf.eprintf "backend warning: %s\n" s
let placevars = 
  let is_float      w hint _ = w = 80 || (hint=$="float" && (w = 32 || w = 64)) in
  let strange_float w hint   = w = 80 && Pervasives.(<>) hint "float" in
  let strange_int   w hint   = hint =$= "float" && not (is_float w hint ()) in
  let warn ~width:w ~alignment:a ~hint:h =
      if strange_float w h then
        warning "80-bit variable not hinted float but will go as float anyway"
      else if strange_int w h then
        warning
          (Printf.sprintf "%d-bit variable hinted float but will go as integer" w) in
  let mk_stage ~temps =
    A.choice
      [ is_float,               A.widen (Aux.round_up_to ~multiple_of: 32); 
        (fun w h _ -> w <= 32), A.widen (fun _ -> 32) *> temps 't';
        A.is_any,               A.widen (Aux.round_up_to ~multiple_of: 8);
      ] in
  Placevar.mk_automaton ~warn ~vfp:target.T.vfp ~memspace:PX.mspace mk_stage
@ 
\section{Tentative example Lua code}

An automaton needs a ``base'' argument.
This argument must somehow be handled behind the scenes.
<<example Lua>>=
X86.Regs = { r = Register.space('r', 8, 32), f = Register.space('f', 8, 80),
             c = Register.space('c', 4, 32) }
Register.addnames(X86.Regs, X86.Regs.r, 
  { 'eax', 'ecx', 'edx', 'ebx', 'esp', 'ebp', 'esi', 'edi' })

X86.CC = Call.make(X86.target)

function X86.CC.results(rs) 
  local CC = X86.CC
  return 
      CC.choice ( 'float',  { CC.widen(CC.multiple_of(80))
                            , CC.widths(80, "x86 FP too wide")
                            , CC.useregs(X86.Regs.f[0], "internal error")
                            }
                , {},       { CC.widen(CC.multiple_of(32))
                            , CC.widths(32, "x86 return too wide")
                            , CC.useregs(rs, "internal error")
                            }
                )
end

function X86.setccs() 
  local vfp = Vfp.mk(32)
  local R = X86.Regs
  local eax, ecx, edx, ebx, esi, edi, ebp =
    R.eax, R.ecx, R.edx, R.ebx, R.esi, R.edi, R.ebp

  local allregs = {eax, ecx, edx, ebx, esi, edi, ebp}
  local volregs = {eax, ecx, edx}
  local nvregs  = {ebx, esi, edi, ebp}

  local CC = X86.CC
  local c_results   = CC.results(eax)
  local cmm_results = CC.results(volregs)
  local c_args    = { CC.widen(CC.multiple_of(32)), CC.overflow("up", 4)}
  local cut_args  =
    { CC.widen(CC.multiple_of(32))
    , CC.widths(32, "at most 32 bits in cut-to argument")
    , CC.useregs(allregs)
    , CC.overflow("up", 4)
    }
  local cmm_args = 
    { CC.widen(CC.multiple_of(32))
    , CC.useregs(allregs)
    , CC.overflow("up", 4)
    }
end  


