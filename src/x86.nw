% -*- mode: Noweb; noweb-code-mode: caml-mode; comment-column: 32 -*-

% vim: ts=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Please add grades for this module below. The line must start with % "%%".
% 

%%Grades: I Peripheral Immediate

\section{Back end for an Intel x86 subset}

\label{x86.sec}

This exploratory back end is designed both to help us develop good
procedures for writing back ends and to serve as an example.
The names of spaces are standard.
<<x86.mli>>=
val arch : string                       (* name of machine*)
module Spaces : sig
  val m : Space.t
  val r : Space.t
  val t : Space.t
  val f : Space.t
  val u : Space.t
  val c : Space.t   (* PC at 0 and condition codes at 2 *)
end
module Post : Postexpander.S
module X    : Expander.S
val target : Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@ 

\subsection{Name and storage spaces}
<<x86.ml>>=
module SS = Space.Standard32
let arch = "x86"                (* architecture name *)
@ 
We use the standard storage spaces, with the PC and
condition codes in their standard locations from [[Space.Standard32]].
We can't use the standard \texttt{f} space because Pentium
floating-point values are 80~bits wide.
We pretend that the machine is a 32-bit machine, which simplifies a lot.
<<x86.ml>>=
module Spaces = struct
  module S = Space
  let bo = Rtl.LittleEndian
  let id = Rtl.Identity
  let m = Space.Standard32.m bo [8; 16; 32]
  let r = Space.Standard32.r 8 id [32]
  let t = Space.Standard32.t   id [32]
  let f = S.checked { S.space = 'f'; S.doc = "floating-point registers"
                    ; S.cellwidth = 80
                    ; S.indexwidth = 3; S.indexlimit = Some 8
                    ; S.aggregation = id; S.widths = [80]
                    ; S.classification = S.Reg
                    } 
  let all_floats = { S.stands_for = 'f'; S.index_ok = (fun _ -> true)
                   ; S.set_doc = "all floating-point registers"
                   } 
  let u = S.checked { S.space = 'u'; S.doc = "floating-point temporaries"
                    ; S.cellwidth = 80
                    ; S.indexwidth = 31; S.indexlimit = None
                    ; S.aggregation = id; S.widths = [80]
                    ; S.classification = S.Temp all_floats
                    } 
  let c = Space.Standard32.c 3 id [32]
  let d = Space.checked
                { Space.space          = 'd'
                ; Space.doc            = "FP rounding mode"
                ; Space.cellwidth      = 2  
                ; Space.indexwidth     = 1
                ; Space.indexlimit     = Some 2
                ; Space.aggregation    = Rtl.Identity
                ; Space.widths         = [2]
                ; Space.classification = Space.Reg
                }
                
end
@
                
end

@ 
\subsection{Postexpander}
<<x86.ml>>=
module R    = Rtl
module RP   = Rtl.Private
module Up   = Rtl.Up
module Down = Rtl.Dn

let {SS.pc = pc; SS.cc = eflags} = SS.locations Spaces.c
module Post = struct
  <<x86 postexpander>>
end
@ 
<<x86 postexpander>>=
let byte_order = Rtl.LittleEndian
let wordsize = 32
@ 
These copies are a nuisance.
<<x86 postexpander>>=
type temp      = Register.t
type rtl       = Rtl.rtl
type width     = Rtl.width
type assertion = Rtl.assertion
type operator  = Rtl.Private.opr
@
The postexpander may need to allocate temporaries.
<<x86 postexpander>>=
let talloc = ref None
let get_talloc () = match !talloc with
  | Some s -> s
  | None   -> Impossible.impossible "Temp allocator not registered with postexpander"
let register_talloc ta = talloc := Some ta
@ 
\paragraph{Contexts}
Addresses go in the integer registers, so we use these contexts:
<<x86 postexpander>>=
type context = Rtl.space * (Register.t -> bool)
let icontext = 't', fun (c, _, _) -> c = 'r' || c = 't'
let fcontext = 'u', fun (c, _, _) -> c = 'f' || c = 'u'
let acontext = icontext
@ 
\paragraph{Addressing modes}
The only addressing mode is the obvious one.
<<x86 postexpander>>=
module Address = struct
  type t = Rtl.exp
  let reg (space, n, w) = R.fetch (R.reg (space, n, w)) w
end
@ 
\subsubsection{Basic locations, flags, and helper functions}
We need to record the various side effects.

Here are some utility functions for computing locations, values, and widths.
<<x86 postexpander>>= 
let temploc  t = Rtl.reg t
let tempval  ((space, n, w) as t) = R.fetch (temploc t) w
let tempwidth (space, n, w)       = w
let mem addr = R.mem R.none 'm' byte_order 32 addr
@ 
Here are some important locations.
<<x86 postexpander>>=
let {SS.pc = pc; SS.cc = eflags} = SS.locations Spaces.c
let eax_reg = ('r', 0, 32)
let eax = temploc eax_reg
let edx_reg = ('r', 2, 32)
let edx = temploc edx_reg
let ecx_reg = ('r', 1, 32)
let esp = temploc ('r', 4, 32)
let espreg = ('r', 4, 32)
@ 
Here are some invented operators that hide the real truth about what
happens to the flags.
IF WE WANT TO MAKE BORROW AND CARRY WORK, WE WILL NEED TO PASS A THIRD
ARGUMENT TO SUBFLAGS AND ADDFLAGS.  THIS WILL MEAN CHANGES IN THE
RECOGNIZER, OF COURSE.
@ 
<<x86 postexpander>>=
let negflags   x   w = R.store eflags (R.app (R.opr "x86_negflags"   [w]) [x])    32
let subflags   x y w = R.store eflags (R.app (R.opr "x86_subflags"   [w]) [x; y]) 32
let addflags   x y w = R.store eflags (R.app (R.opr "x86_addflags"   [w]) [x; y]) 32
let mulflags   x y w = R.store eflags (R.app (R.opr "x86_mulflags"   [w]) [x; y]) 32
let divflags   x y w = R.store eflags (R.app (R.opr "x86_divflags"   [w]) [x; y]) 32
let logicflags exp w = R.store eflags (R.app (R.opr "x86_logicflags" [w]) [exp])  32
let shflags sh x y w =
  let flagsop = "x86_" ^ sh ^ "flags" in
  R.store eflags (R.app (R.opr flagsop [w]) [x; y]) 32
@ 
\subsubsection{Data movement}
Most data movement is simple assignment; the MOV instruction is quite powerful.
Because we're treating the Penitum as a 32-bit machine, we assert the
width of everything is~32. 
<<x86 postexpander>>=
let load ~dst:((_, _, w) as dst) ~addr assn =
  assert (w = 32);
  [R.store (temploc dst) (R.fetch (R.mem assn 'm' byte_order 32 addr) 32) 32]
let store ~addr ~src:((_, _, w) as src) assn =
  assert (w = 32);
  [R.store (R.mem assn 'm' byte_order 32 addr) (tempval src) 32]
@ 
The Pentium provides sign-extending loads and stores.
<<x86 postexpander>>=
let extend opname n e = R.app (R.opr opname   [n; 32]) [e]
let lobits        n e = R.app (R.opr "lobits" [32; n]) [e]
let sxload ~dst:((_, _, w) as dst) ~addr n assn =
  if w <> 32 then Impossible.unimp "widening of temporaries";
  [R.store (temploc dst)
             (extend "sx" n (R.fetch (R.mem assn 'm' byte_order n addr) n)) 32]
let zxload ~dst:((_, _, w) as dst) ~addr n assn =
  assert (w = 32);
  [R.store (temploc dst)
             (extend "zx" n (R.fetch (R.mem assn 'm' byte_order n addr) n)) 32]
let lostore ~addr ~src:((_, _, w) as src) n assn =
  assert (w = 32);
  [R.store (R.mem assn 'm' byte_order n addr) (lobits n (tempval src)) n]
@ 
This code hasn't yet been checked for compatility with floating point.
<<x86 postexpander>>=
let move_rtl dst src = R.store (temploc dst) (tempval src) (tempwidth src)
let move ~dst ~src   = if dst = src then [] else [move_rtl dst src]
@ 
Load immediate is also a simple move.
<<x86 postexpander>>=
let li  ~dst const = [R.store (temploc dst) (Up.const const) (tempwidth dst)]
let lix ~dst e     = [R.store (temploc dst) e                (tempwidth dst)]
@ 
\subsubsection{Operator contexts}
Here are tentative contexts for all the operators.
Anything that has to do with rounding modes is surely wrong.
<<x86 postexpander>>=
let bcontext = ' ', fun _ -> false  (* should never be used *)
let operators = Context.standard icontext fcontext acontext bcontext

module SM = Strutil.Map
let resmap = List.fold_left (fun m (n, a, r)-> SM.add n r m) SM.empty operators
let argmap = List.fold_left (fun m (n, a, r)-> SM.add n a m) SM.empty operators

let arg_contexts   (n, _) = try SM.find n argmap 
                            with Not_found -> Impossible.impossible 
                                    ("cannot find arg context for "^n)
let result_context (n, _) = try SM.find n resmap
                            with Not_found -> Impossible.impossible
                                    ("cannot find result context for "^n)
@ 
\subsubsection{Operator implementations (with flags)}
Operator hell (or heaven).
We support (so far) two kinds of abstract operations on the flags.
An arithmetic-like or comparison instruction needs {two} \emph{operands}
to set the flags; a logical instruction needs only the \emph{result}.
<<x86 postexpander>>=
let exp_with_flags setflags dst exp x y w =
  R.par [R.store (temploc dst) exp w; setflags x y w]

let with_flags setflags dst op x y w =
  let x = tempval x in
  let y = tempval y in
  let exp = R.app op [x; y] in
  exp_with_flags setflags dst exp x y w

let with_lflags dst op x y w =
  let x = tempval x in
  let y = tempval y in
  let exp = R.app op [x; y] in
  R.par [R.store (temploc dst) exp w; logicflags exp w]
@ 
We insist on using most operators at their natural 32-bit width, and
this function is the forcing function that makes it so.
<<x86 postexpander>>=
let at32 = function
  | opr, [32] -> opr
  | opr, [n]  -> Impossible.unimp ("%" ^ opr ^ string_of_int n ^ "(...)")
  | opr, ws   ->
      Impossible.impossible
        (Printf.sprintf "operator %%%s specialized to %d widths" opr (List.length ws))
@ 
We start our implementation with a function that provides binary
operators in $L \mathrel{:=} L \oplus R$ form. 
<<x86 postexpander>>=
let llr op x y move = match at32 op with
| "add"       -> with_flags addflags x (Up.opr op) x y 32 :: move
| "sub"       -> with_flags subflags x (Up.opr op) x y 32 :: move
| "mul_trunc" -> with_flags mulflags x (Up.opr op) x y 32 :: move
@
Division is rather painful on the x86.
We have to place the dividend in the EDX:EAX register pair, and we have to represent
the destination as a register pair.
[[regpairv]] does most of the work, creating the rtl's to form the register pair, as
well as the expression representation of the register pair.
I have tried to make [[regpairv]] fairly general; we won't know if this is a success
until we try it with other versions of the x86 divide instruction.
<<x86 postexpander>>=
| "div" ->
    let regpairv w hreg lreg =
      let rval      r = R.fetch (temploc r) w in
      let sxreg     l = R.app (R.opr "sx" [w; w*2]) [rval l] in
      let sbit        = Talloc.Multiple.reg (get_talloc ()) 't' w in
      let high_reg    = Talloc.Multiple.reg (get_talloc ()) 't' w in
      let sh op dst s = R.app (R.opr op [w]) [ dst
                                             ; R.bits (Bits.U.of_int s w) w] in
      let shl  = sh "shl"  in
      let shra = sh "shra" in
      ( [ R.store (temploc hreg) (rval sbit)                             w
        ; R.store (temploc sbit) (shra (R.fetch (temploc sbit) w) (w-1)) w
        ; R.store (temploc sbit) (rval lreg)                             w
        ]
      , (R.app (R.opr "or" [w*2]) [shl (sxreg hreg) w; sxreg lreg])) in

    let (is, regpair) = regpairv 32 edx_reg eax_reg in
    let div = exp_with_flags divflags eax_reg
                             (R.app (R.opr "div" [32;32]) [regpair; tempval y])
                             regpair (tempval y) 32 in
    let upint n = Up.const (RP.Bits(Bits.U.of_int n 32)) in
    move_rtl x eax_reg :: div :: (is @ (move_rtl eax_reg x :: move))
@ 
I don't know why it's safe to clobber ECX here.
<<x86 postexpander>>=
| ("shl" | "shrl" | "shra") as shop ->
    let cl = lobits 8 (tempval ecx_reg) in
    let sh = exp_with_flags (shflags shop) x (R.app (Up.opr op) [tempval x; cl])
              (tempval x) cl 32 in
    sh :: move_rtl ecx_reg y :: move
<<x86 postexpander>>=
| ("and"|"or"|"xor") -> with_lflags x (Up.opr op) x y 32 :: move
| _  ->
    R.store (temploc x) (R.app (Up.opr op) [tempval x; tempval y]) (tempwidth x) :: move
@ 
<<x86 postexpander>>=
let binop ~dst op x y = match at32 op with
| _     -> llr op dst y (move dst x)
@ 
Multiplication and division are bound to be a nightmare.
Here is some tentative code that will one day be generalized to ``move
hardware registers out of the way.''
<<x86 postexpander>>=
let regpairv x y =
  let rval r = R.fetch r 32 in
  let zxreg l = R.app (R.opr "zx" [32; 64]) [rval l] in
  let shl v = R.app (R.opr "shl" [64]) [v; R.bits (Bits.U.of_int 32 32) 32]
  in R.app (R.opr "or" [64]) [shl (zxreg x); zxreg y]

let divu_trunc icontext dst x y =
    let (ialloc, _) = icontext in
    let tmpd = ialloc 32 in
    let tmpa = ialloc 32 in
    let divmod = R.par
        [ R.store eax (R.app (R.opr "divu" [64;32]) [regpairv edx eax; tempval y]) 32
        ; R.store edx (R.app (R.opr "modu" [64;32]) [regpairv edx eax; tempval y]) 32
        ; R.kill eflags
        ]  in
    let eax = ('r', 0, 32) in
    let edx = ('r', 2, 32) in
    let upint n = Up.const (RP.Bits(Bits.U.of_int n 32)) in
    [ move_rtl eax tmpa; move_rtl edx tmpd    (* restore *)
    ; move_rtl dst eax; divmod                (* divide *)
    ; move_rtl eax x; R.store (temploc eax) (upint 0) 32
    ; move_rtl tmpa eax; move_rtl tmpd edx    (* save *)
    ]
@ 
Other operators are surely wrong.
<<x86 postexpander>>=
let inplace op x move = match at32 op with
| "neg" -> R.par [R.store (temploc x) (R.app (Up.opr op) [tempval x]) 32;
                  negflags (tempval x) 32]
           :: move
| _ ->
    R.store (temploc x) (R.app (Up.opr op) [tempval x]) (tempwidth x) :: move

let unop ~dst op x = inplace op dst (move dst x)

let rtlop ~dst op args =
  [R.store (temploc dst) (R.app (Up.opr op) (List.map tempval args)) (tempwidth dst)]
@ 
\subsubsection{Control flow}

There's just one PC on the Pentium.
<<x86 postexpander>>=
let pc_lhs = pc
let pc_rhs = pc
@ 
There are some hairy semantics attached to some Pentium jump
instructions, but I~think we can stick with the simple ones for now. 
<<x86 postexpander>>=
let br ~tgt = [R.store pc_lhs (tempval tgt) 32]
let b  ~tgt = [R.store pc_lhs (Up.const tgt) 32]
@ 
The call instructions came from us, so we can rely on the single extra effects pushing the program counter.
<<x86 postexpander>>=
let effects = List.map Up.effect
let call  ~tgt ~others = [R.par (R.store pc_lhs (Up.const tgt) 32 :: effects others)]
let callr ~tgt ~others = [R.par (R.store pc_lhs (tempval tgt) 32 :: effects others)]
@ 
The [[cut to]] is our own little conspiracy.
<<x86 postexpander>>=
let cut_to effs = [R.par (effects effs)]
@ 
We don't touch anything that pops the PC.
That means the return instruction!
<<x86 postexpander>>=
let don't_touch_me = 
  let lowpc = Down.loc pc in
  function
  | [ RP.Store (pc', _, _)
    ; RP.Store (RP.Reg sp, RP.App (("add", [32]), [RP.Fetch (RP.Reg sp2, _);
                                                      RP.Const (RP.Bits b)]), _)] ->
      pc' = lowpc & sp = espreg & sp2 = espreg & Bits.S.to_int b = 4
  | _ -> false
@
To implement the comparisons, we define new operators that are private
to the $x$86 architecture. 
\begin{itemize}
\item [[x86_subflags]] returns what goes into the flags after a
[[sub]] or [[cmp]]
instruction.
\item [[x86_addflags]] returns what goes into the flags after a
[[add]] or [[adc]]
instruction.
\item [[x86_mulflags]] returns what goes into the flags after an
[[imul]] instruction.
\item [[x86_divflags]] returns what goes into the flags after an
[[idiv]] instruction.
\item
Operators [[x86_a]], [[x86_ae]], and so on, accept one argument, the
flags, and return a Boolean value that tells whether [[JA]], [[JAE]],
and so one, would jump.
\end{itemize}
<<x86 postexpander>>=
<<important functions on $x$86 operators>>
let cmp x y =
  R.store eflags (R.app (R.opr "x86_subflags" [32]) [tempval x; tempval y]) 32

let bc x (opr, ws) y ~tgt =
  assert (ws = [32]);
  [ R.guard (R.app (R.opr (cmpopr opr) [32]) [R.fetch eflags 32]) 
            (R.store pc_lhs (Up.const tgt) 32)
  ; cmp x y
  ]

let bnegate r = match Down.rtl r with
| RP.Rtl [RP.App((cop, [32]), [RP.Fetch (flags, 32)]), RP.Store (pc, tgt, 32)]
  when pc = Down.loc pc_lhs && flags = Down.loc eflags ->
    Up.rtl (RP.Rtl [RP.App((cmpneg cop, [32]), [RP.Fetch (flags, 32)]),
                   RP.Store (pc, tgt, 32)])
| _ -> Impossible.impossible "ill-formed x86 conditional branch"
@ 
The first ``important'' function converts a {\PAL} operator into the
corresponding Intel operator.
<<important functions on $x$86 operators>>=
let cmpopr = function
  | "eq"  -> "x86_e"
  | "ne"  -> "x86_ne"
  | "lt"  -> "x86_l"
  | "le"  -> "x86_le"
  | "gt"  -> "x86_g"
  | "ge"  -> "x86_ge"
  | "ltu" -> "x86_b"
  | "leu" -> "x86_be"
  | "gtu" -> "x86_a"
  | "geu" -> "x86_ae"
  | "feq"  -> Impossible.unimp "floating-point comparison"
  | "fne"  -> Impossible.unimp "floating-point comparison"
  | "flt"  -> Impossible.unimp "floating-point comparison"
  | "fle"  -> Impossible.unimp "floating-point comparison"
  | "fgt"  -> Impossible.unimp "floating-point comparison"
  | "fge"  -> Impossible.unimp "floating-point comparison"
  | "fordered"   -> Impossible.unimp "floating-point comparison"
  | "funordered" -> Impossible.unimp "floating-point comparison"
  | _ -> Impossible.impossible "non-comparison in x86 conditional branch"
@ 
The second important function negates an Intel operator.
<<important functions on $x$86 operators>>=
let cmpneg = function
  | "x86_ne" -> "x86_e"
  | "x86_e"  -> "x86_ne"
  | "x86_ge" -> "x86_l"
  | "x86_g"  -> "x86_le"
  | "x86_le" -> "x86_g"
  | "x86_l"  -> "x86_ge"
  | "x86_ae" -> "x86_b"
  | "x86_a" -> "x86_be"
  | "x86_be" -> "x86_a"
  | "x86_b" -> "x86_ae"
  | _ -> Impossible.impossible "bad comparison in expanded x86 conditional branch"
@ 
\subsection{Building the target}
With the postexpander in place, we can build a target.
We begin with more utility functions
<<x86.ml>>=
module PX = Post
let pc        = pc
let espval    = PX.tempval ('r', 4, 32)
let add       = Rtlutil.add 32
let sub x y   = R.app (R.opr "sub" [32]) [x; y]
let const n   = R.bits (Bits.S.of_int n 32) 32
let mem       = PX.mem
let fetch l   = R.fetch l 32
let store l r = R.store l r 32
@ 
These functions help with instructions that push and pop.
<<x86.ml>>=
let pop_with f = (* rtl got by popping (f e), where e is top of stack *)
  let top = fetch (PX.mem espval) in
  R.par [ f top; store PX.esp (add espval (const 4)) ]

let push e = (* effect of pushing e *)
  let next_sp = sub espval (const 4) in
  R.par [ store (mem next_sp) e; store PX.esp next_sp ]
@ 
We now build the standard control flow.
<<x86.ml>>=
module T = Target
module F = Mflow.MakeStandard (
  struct
     let pc_lhs = PX.pc_lhs
     let pc_rhs = PX.pc_rhs
     let ra_reg    = PX.temploc ('?', 99, 32) (* not used *)
     let ra_offset = 33                       (* not used *)
  end)
@      
There's no science here---just a lot of goo.
The [[Target.t]] abstraction could use some thought.
<<x86.ml>>=
module X = Expander.IntFloatAddr (PX)
let spill_expand = X.expand
(* expansion here once caused infinite loop *)
let spill_expand p r = [r]
let spill  p t l =
  spill_expand p (Automaton.store l (PX.tempval t) (PX.tempwidth t))
let reload p t l =
  spill_expand p (R.store (PX.temploc t) (Automaton.fetch l (PX.tempwidth t)) (PX.tempwidth t))
@ 
Parts of the target record are reasonable.
Parts are lies.
Parts are baffling---why is character set characterized by the target?
<<x86.ml>>=
let downrtl = Down.rtl
let uploc   = Up.loc
let upexp   = Up.exp

let fpcond n      = Rtl.reg  ('d',n,2)  (* FP modes *)
@ 

This is an ugly wart.  The only reason we need to distinguish [[cmm]]
from [[notail]] is to tell whether a tail call is permitted, but this
information is actually encapsulated in the stack-frame layout,
\emph{not} in the [[Call.t]].
<<x86.ml>>=
let c_convention =
  X86call.c      (fun ra -> pop_with (fun ra -> store pc ra)) (F.cutto PX.esp)
let cmm_convention =
  X86call.cmm    (fun ra -> pop_with (fun ra -> store pc ra)) (F.cutto PX.esp)
let notail_convention =
  X86call.notail (fun ra -> pop_with (fun ra -> store pc ra)) (F.cutto PX.esp)
let c'_convention = (* uses Callspec implementation *)
  X86call.c'     (fun ra -> pop_with (fun ra -> store pc ra)) (F.cutto PX.esp)

module A = Automaton
let ( *> ) = A.( *> )
let globals base = 
  let width w = if w <= 8 then 8 else if w <= 16 then 16 else Aux.round_up_to 32 w in
  let align = function 8 -> 1 | 16 -> 2 | _ -> 4 in
  A.at ~start:base (A.widen width *> A.align_to align *>
  A.overflow ~memsize:8 ~byteorder:PX.byte_order ~growth:Memalloc.Up ~max_alignment:4)

let target =
  { T.name = "x86"

  (* basic metrics and spaces are OK *)
  ; T.byteorder   = PX.byte_order  
  ; T.wordsize    = PX.wordsize
  ; T.pointersize = PX.wordsize
  ; T.vfp         = SS.vfp
  ; T.alignment = 1
  ; T.memsize = 8
  ; T.spaces = [Spaces.m; Spaces.r; Spaces.t; Spaces.f; Spaces.u; Spaces.c]
  ; T.tspace_of_ctxt =
      (function | "int" | "addr" -> Spaces.t
                | "float"        -> Spaces.u
                | c -> Impossible.impossible ("unsupported context " ^ c ^
                                              " requested temp space"))

  (* Does the Pentium really implement IEEE 754?  I think so *)
  ; T.float = "ieee754"

  (* spill and reload are believed OK *)
  ; T.spill  = spill
  ; T.reload = reload

  (* control flow is solid, except [[cutto]] is a lie *)
  ; T.bnegate = F.bnegate eflags
  ; T.goto    = F.goto
  ; T.jump    = F.jump
  ; T.call    = { T.embed = (fun e -> R.par [F.goto.T.embed e; push (fetch pc)])
                ; T.project = F.call.T.project (* should be OK *)
                } 
  ; T.branch  = F.branch

  ; T.cc = (function "C" | "c" -> c_convention
            | "C--" | "c--"    -> cmm_convention
            | "C'"  | "c'"     -> c'_convention (* uses Callspec *) 
            | "notail"         -> notail_convention
            | cc -> Impossible.impossible ("unsupported calling convention "^cc))
  (* global or hardware registers *)
  ; T.globals  = globals
  ; T.is_rounding_mode = (fun loc -> loc = fpcond 0) (* see globals value *)
  ; T.named_locs   = Strutil.assoc2map 
                     ["IEEE 754 rounding mode",    fpcond 0
                     ;"IEEE 754 rounding results", fpcond 1
                     ]
  
  (* bogosity *)
  ; T.data_section = "data" (* NOT REALLY A PROPERTY OF THE TARGET MACHINE... *)
  ; T.charset = "latin1" (* THIS IS NONSENSE!! NOT A PROPERTY OF THE MACHINE?? *)
  } 

type tgt  = ((Rtl.exp -> Automaton.t), Call.t) Target.t
@ 
\subsection{Variable placement}
The machine accepts only three widths of floating-point variables: 32,
64, and 80~bits.
Any 80-bit value is seen as a float (this might be wrong in the case
of an 80-bit structure variable, so the decision should be revisited).
A~32-bit or 64-bit value would have to be suitably hinted to be seen
as a float.
Because floating-point registers are organized as a stack, we can't
use the registers effectively for variables, so floats go in memory.

Any other value of width at most~32 goes into a temporary.
Larger values go straight to memory.

FOR WARNINGS, IT MIGHT BE USEFUL TO INCLUDE A VARIABLE NAME SOMEWHERE,
SOMEHOW.
<<x86.ml>>=
let warning s = Printf.eprintf "backend warning: %s\n" s

let from_temps proc space = (* stage to allocate a temporary location *)
  let allocator = Talloc.Multiple.loc proc.Proc.temps space in
  let alloc ~width:w ~alignment:a ~hint:h = A.of_loc (allocator w) in
  A.wrap (fun methods -> {A.allocate = alloc; A.freeze = methods.A.freeze})

let placevars proc = 
  let is_float      hint w = w = 80 || (hint = "float" && (w = 32 || w = 64)) in
  let strange_float hint w = w = 80 && hint <> "float" in
  let strange_int   hint w = hint = "float" && not (is_float hint w) in
  let warn methods =
    let alloc ~width:w ~alignment:a ~hint:h =
      if strange_float h w then
        warning "80-bit variable not hinted float but will go as float anyway"
      else if strange_int h w then
        warning
          (Printf.sprintf "%d-bit variable hinted float but will go as integer" w);
      methods.A.allocate w a h in
    {A.allocate = alloc; A.freeze = methods.A.freeze} in
  Block.srelative target.T.vfp "variables placed in memory" A.at
  (
    A.wrap warn *>
    A.choice
      [ is_float,               A.widen (Aux.round_up_to ~multiple_of: 64); 
        (fun h w -> w <= 32),   A.widen (fun _ -> 32) *> from_temps proc 't';
        A.is_any,               A.widen (Aux.round_up_to ~multiple_of: 32);
      ] *>
  A.align_to (fun _ -> 4) *>
  A.overflow ~memsize:8 ~byteorder:PX.byte_order ~growth:Memalloc.Up ~max_alignment:4)
@ 
\section{Tentative example Lua code}

An automaton needs a ``base'' argument.
This argument must somehow be handled behind the scenes.
<<example Lua>>=
X86.Regs = { r = Register.space('r', 8, 32), f = Register.space('f', 8, 80),
             c = Register.space('c', 4, 32) }
Register.addnames(X86.Regs, X86.Regs.r, 
  { 'eax', 'ecx', 'edx', 'ebx', 'esp', 'ebp', 'esi', 'edi' })

X86.CC = Call.make(X86.target)

function X86.CC.results(rs) 
  local CC = X86.CC
  return 
      CC.choice ( 'float',  { CC.widen(CC.multiple_of(80))
                            , CC.widths(80, "x86 FP too wide")
                            , CC.useregs(X86.Regs.f[0], "internal error")
                            }
                , nil,      { CC.widen(CC.multiple_of(32))
                            , CC.widths(32, "x86 return too wide")
                            , CC.useregs(rs, "internal error")
                            }
                )
end

function X86.setccs() 
  local vfp = Vfp.mk(32)
  local R = X86.Regs
  local eax, ecx, edx, ebx, esi, edi, ebp =
    R.eax, R.ecx, R.edx, R.ebx, R.esi, R.edi, R.ebp

  local allregs = {eax, ecx, edx, ebx, esi, edi, ebp}
  local volregs = {eax, ecx, edx}
  local nvregs  = {ebx, esi, edi, ebp}

  local CC = X86.CC
  local c_results   = CC.results(eax)
  local cmm_results = CC.results(volregs)
  local c_args    = { CC.widen(CC.multiple_of(32)), CC.overflow("up", 4)}
  local cut_args  =
    { CC.widen(CC.multiple_of(32))
    , CC.widths(32, "at most 32 bits in cut-to argument")
    , CC.useregs(allregs)
    , CC.overflow("up", 4)
    }
  local cmm_args = 
    { CC.widen(CC.multiple_of(32))
    , CC.useregs(allregs)
    , CC.overflow("up", 4)
    }
end  


