% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml

% ------------------------------------------------------------------  
\section{Environments}\label{sec:env}
% ------------------------------------------------------------------ 

An environment is a map from some keys to some values. Typical
examples include symbol tables that map names to types and
substitutions that map variable names to types. This module provides a
functor to create a module that implements an environment. The
argument to the functor determines the structure of the keys used in
the environment. The resulting module implements polymorphic
environments. 

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------  

The keys used in the environment must be ordered: a module must be
provided that implements the type [[t]] of the keys and a [[compare]]
function over [[t]]. The [[compare]] function must behave like the
[[compare]] function from the [[Pervasives]] module.

<<env.mli>>=
module type OrderedType = sig
    type t
    val compare: t -> t -> int
end

<<Make>>

@ To create a module that implements an environment a module of type
[[OrderedType]] is be passed to the [[Make]] functor.  The resulting
module of type [[S]] implements the polymorphic environment [['a env]]
using keys of type [[key]]. 

<<Make>>=
<<signature S>>
module Make (Ord: OrderedType): (S with type key = Ord.t)
@

<<signature S>>=
module type S = sig
    type key
    type 'a env
    
    <<functions>>
end

@ The empty environment is provided as [[empty]].

<<functions>>=
    val empty   : 'a env

@ Pairs of key and value are entered into an environment by [[enter
key value env]]. When [[key]] is already part of [[env]] the new
binding shadows the old.

<<>>=
    val enter       : key -> 'a       -> 'a env -> 'a env
    val enterList   : (key * 'a) list -> 'a env -> 'a env

@ To lookup the value belonging to [[key]] use [[lookup key env]]. 
The [[lookup]] function returns the binding for [[key]] or raises the
[[Error.ErrorAt]] exception in case no binding for [[key]] exists.
    
<<>>=
    val lookup  : key -> 'a env -> 'a
@

To check the existence of a binding [[domain key env]] can be used.
The returned value is [[true]] if and only if [[key]] is bound in
[[env]]. 

<<>>=
    val domain  : key -> 'a env -> bool

@ To walk over all entries a [[fold]] function is provided. In [[fold f
env]] [[f]] is applied to all entries in [[env]]; [[f]] receives the
key and the value of an entry in the environment. The order at which
elements are presented to [[f]] is unspecified.

<<>>=

    val fold    : (key -> 'a -> 'b -> 'b) -> 'a env -> 'b -> 'b      

@ For debugging [[dump]] returns all bindings of an environment in an
(unsorted) list of key, value pairs.

<<>>=
    val dump    : 'a env -> (key * 'a) list

@ ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation uses the [[Map]] module from the \ocaml~standard
library.

<<env.ml>>=
module type OrderedType = sig
    type t
    val compare: t -> t -> int
end

<<signature S>>

module Make(Ord: OrderedType) = struct
    module MyMap = Map.Make(Ord)

    type key        = Ord.t 
    type 'a env     = 'a MyMap.t
    
    let empty       = MyMap.empty
    let enter       = MyMap.add
    let domain      = MyMap.mem
    let fold        = MyMap.fold
    
    let lookup key env = 
        try MyMap.find key env with
        | Not_found -> Error.error "unknown key"
    
    let dump env    = 
        let f key data res = (key,data)::res
        in MyMap.fold f env []

    let enterList pairs env =
        let f env (key,value) = enter key value env in 
            List.fold_left f env pairs
end


@



