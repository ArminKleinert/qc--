% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Widening}

A simple widener for floating-point values.
Parameter [[rm]] contains the hardware rounding modes.
<<widen.mli>>=
val float : rm:Rtl.exp -> int list -> Rtl.rtl -> Rtl.rtl
  (* widen all floating-point operations *)

val store_const : int -> Rtl.rtl -> Rtl.rtl
  (* l := k   =>   l := lobits(k') *)
@ 
<<widen.ml>>=
module R = Rtl
module RP = Rtl.Private

module Down = Rtl.Dn
module Up   = Rtl.Up
@ 
We're given [[goodwidths]], and our goal is to change all
floating-point operations in an RTL to be using one of the widths in
[[goodwidths]].
(In practice we choose [[bestwidth w]], which is the smallest width in
[[goodwidths]] that is at least as large as~[[w]].)
<<widen.ml>>=
let float ~rm goodwidths =
  let rm = Down.exp rm in
  let goodwidths = List.sort compare goodwidths in
  let isgood w = List.exists (fun w' -> w' = w) goodwidths in
  let bestwidth w =
    try List.find (fun w' -> w' >= w) goodwidths
    with Not_found -> Unsupported.widen_float w in
  <<floating-point widening>>
  rtl
@ 
I'm a little shaky what is the postcondition regarding float-to-float
conversions.
It's embarrassing!!
For example, suppose the source program tries to narrow a
floating-point value to single precision.
We owe it to ourselve to arrange to store and reload it at that
precision, but I'm sure that doesn't happen.
There may be other errors lurking as well.

Anyway [[f2f']] implements a float-to-float conversion, which may or
may not combine with a conversion underneath it.
<<floating-point widening>>=
let f2f' combine srcw dstw e =
  let rec make_f2f s d e rm =
    if isgood s || isgood d then
      RP.App(("f2f", [s; d]), [e; rm])
    else
      let w = bestwidth (max s d) in
      make_f2f w d (make_f2f s w e rm) rm in
  if srcw = dstw then
    e
  else
    match e with 
    | RP.App(("f2f", [from; to']), [e; rm]) when combine ->
        assert (to' = srcw);
        make_f2f from dstw e rm
    | RP.App(("f2f_implicit_round", [from; to']), [e]) when combine ->
        assert (to' = srcw);
        make_f2f from dstw e rm
    | e -> 
        make_f2f srcw dstw e rm in
let f2f = f2f' true in
let force_f2f = f2f' false in
@ 
Function [[convert]] takes an expression that is known to produce a
floating-point value, and it changes the width of the expression,
while rewriting all subexpressions.
<<floating-point widening>>=
let rec convert ~(from:int) ~(to':int) e =
  let cvt = convert ~from ~to' in
  match e with
  | RP.Const _ ->
      f2f from to' e
  | RP.Fetch(l, w) ->
      f2f from to' (RP.Fetch(loc l, w))
  | RP.App (("f2f" , [f; t]), [x; rm]) ->
      convert ~from:f ~to' x
  | RP.App (("f2f_implicit_round" , [f; t]), [x]) ->
      convert ~from:f ~to' x
  | RP.App (("i2f", [f; t]), [x; rm]) ->
      RP.App (("i2f", [f; to']), [rewrite x; rm])
  | RP.App ((("fabs"|"fneg") as op, [w]), [x]) -> 
	assert (w=from);
	RP.App((op, [to']), [cvt x])
  | RP.App ((("fadd"|"fsub"|"fmul"|"fdiv") as op, [w]), [x; y; rm]) -> 
	RP.App((op, [to']), [cvt x; cvt y; rm])
  | RP.App ((("fsqrt") as op, [w]), [x; rm]) -> 
	assert (w=from);
	RP.App((op, [to']), [cvt x; rm])
  | RP.App ((op, _), _) ->
      Impossible.impossible
        ("float widener widening non-float value (applied " ^ op ^ ")")
@ 
Function [[rewrite]] rewrites all subexpressions to ensure the postcondition.
Its major job is to call [[convert]] when it spots a floating-point subexpression.
<<floating-point widening>>=
and rewrite e = match e with
  | RP.Const _      -> e
  | RP.Fetch (l, e) -> RP.Fetch(loc l, e)
  | RP.App (op, args) when Rtlop.Types.has_floating_result (Up.opr op) ->
      Impossible.impossible "asked to rewrite (not convert) floating-point result"
  | RP.App (("f2i", [fw; iw]), [x; rm]) ->
      let fw' = bestwidth fw in
      RP.App (("f2i", [fw'; iw]), [convert ~from:fw ~to':fw' x; rm])
  | RP.App ((("fcmp"|"flt"|"fle"|"fgt"|"fge"|"feq"|"fne"|"fordered"|"funordered")
               as opname, [w]), [x; y]) ->
      let w' = bestwidth w in
      RP.App ((opname, [w']), [convert ~from:w ~to':w' x; convert ~from:w ~to':w' y])
  | RP.App(op, args) ->
      RP.App (op, List.map rewrite args)
@ 
Function [[loc]] rewrites all subexpressions that appear in a location
(i.e., in an addressing expression).
<<floating-point widening>>=
and loc l = match l with
| RP.Mem(sp, agg, w, addr, assn)    -> RP.Mem(sp, agg, w, rewrite addr, assn)
| RP.Slice(w, lsb, l)               -> RP.Slice(w, lsb, loc l)
| RP.Reg(_, _, _) | RP.Var(_, _, _) -> l in
@ 
Assignment requires that we know whether the right-hand side is a
floating-point expression.  If so, [[convert]], otherwise [[rewrite]].
<<floating-point widening>>=
let is_floating_exp = function
  | RP.App(op, args) -> Rtlop.Types.has_floating_result (Up.opr op)
  | _ -> false in
let guarded (g, eff) =
  let eff = match eff with
  | RP.Store(l, r, w) ->
      if is_floating_exp r then (* && bestwidth w <> w then *)
        let r = convert ~from:w ~to':(bestwidth w) r in
        RP.Store(loc l, force_f2f (bestwidth w) w r, bestwidth w)
      else
        RP.Store(loc l, rewrite r, w)
  | RP.Kill l -> RP.Kill (loc l) in
  (rewrite g, eff) in
@ 
In the common case where we have no operators that need conversion, we
avoid rewriting the RTL, thereby reducing the load on the major heap.
<<floating-point widening>>=
let rtl r = 
  let needs_conversion op =
    Rtlop.Types.has_floating_result op ||
    match fst (Down.opr op) with
    | "fcmp"|"flt"|"fle"|"fgt"|"fge"|"feq"|"fne"|"fordered"|"funordered"|"f2i" -> true
    | _ -> false in
  if Rtlutil.ExistsOpr.rtl needs_conversion r then
    let r' =
      let RP.Rtl es = Down.rtl r in Up.rtl (RP.Rtl (List.map guarded es)) in
    let rtl r = Rtlutil.ToReadableString.rtl r in
    Verbose.say 5 ["Widened "; rtl r; " into\n  "; rtl r'; "\n"];
    r'
  else
    r in
@ 
<<widen.ml>>=
let store_const goodwidth rtl = match Down.rtl rtl with
  | RP.Rtl [(g, RP.Store(l, (RP.Const (RP.Bits b) as k), w))] when w < goodwidth ->
      let widek = RP.App(("zx", [w; goodwidth]), [k]) in
      let widek = Down.exp (Simplify.exp (Up.exp widek)) in
      let lobits = RP.App(("lobits", [goodwidth; w]), [widek]) in
      Up.rtl (RP.Rtl [(g, RP.Store(l, lobits, w))])
  | _ -> rtl

