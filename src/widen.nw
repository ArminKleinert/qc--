% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Widening}

A simple widener for floating-point values.
Parameter [[rm]] contains the hardware rounding modes.
<<widen.mli>>=
val float : rm:Rtl.exp -> int list -> Rtl.rtl -> Rtl.rtl
@ 
<<widen.ml>>=
module R = Rtl
module RP = Rtl.Private

module Down = Rtl.Dn
module Up   = Rtl.Up
@ 
We're given [[goodwidths]], and our goal is to change all
floating-point operations in an RTL to be using one of the widths in
[[goodwidths]].
(In practice we choose [[bestwidth w]], which is the smallest width in
[[goodwidths]] that is at least as large as~[[w]].)
<<widen.ml>>=
let float ~rm goodwidths =
  let rm = Down.exp rm in
  let goodwidths = List.sort compare goodwidths in
  let bestwidth w =
    try List.find (fun w' -> w' >= w) goodwidths
    with Not_found -> Unsupported.widen_float w in
  <<widening>>
  rtl
@ 
I'm a little shaky what is the postcondition regarding float-to-float
conversions.
For example, suppose the source program tries to narrow a
floating-point value to single precision.
We owe it to ourselve to arrange to store and reload it at that
precision, but I'm sure that doesn't happen.
There may be other errors lurking as well.

Anyway [[f2f']] implements a float-to-float conversion, which may or
may not combine with a conversion underneath it.
<<widening>>=
let f2f' combine srcw dstw e =
  if srcw = dstw then
    e
  else
    match e with 
    | RP.App(("f2f", [from; to']), [e; rm]) when combine ->
        assert (to' = srcw);
        RP.App(("f2f", [from; dstw]), [e; rm])
    | e -> 
        RP.App(("f2f", [srcw; dstw]), [e; rm]) in
let f2f = f2f' true in
let force_f2f = f2f' false in
@ 
Function [[convert]] takes an expression that is known to produce a
floating-point value, and it changes the width of the expression,
while rewriting all subexpressions.
<<widening>>=
let rec convert ~(from:int) ~(to':int) e =
  let cvt = convert ~from ~to' in
  match e with
  | RP.Const _ ->
      f2f from to' e
  | RP.Fetch(l, w) ->
      f2f from to' (RP.Fetch(loc l, w))
  | RP.App (("f2f", [f; t]), [x; rm]) ->
      convert ~from:f ~to' x
  | RP.App (("i2f", [f; t]), [x; rm]) ->
      RP.App (("i2f", [f; to']), [rewrite x; rm])
  | RP.App ((("fabs"|"fneg") as op, [w]), [x]) -> 
	assert (w=from);
	RP.App((op, [to']), [cvt x])
  | RP.App ((("fadd"|"fsub"|"fmul"|"fdiv") as op, [w]), [x; y; rm]) -> 
	RP.App((op, [to']), [cvt x; cvt y; rm])
  | RP.App ((("fsqrt") as op, [w]), [x; rm]) -> 
	assert (w=from);
	RP.App((op, [to']), [cvt x; rm])
  | RP.App (_, _) -> Impossible.impossible "float widener widening non-float value"
@ 
Function [[rewrite]] rewrites all subexpressions to ensure the postcondition.
Its major job is to call [[convert]] when it spots a floating-point subexpression.
<<widening>>=
and rewrite e = match e with
  | RP.Const _      -> e
  | RP.Fetch (l, e) -> RP.Fetch(loc l, e)
  | RP.App (op, args) when Rtlop.Types.has_floating_result (Up.opr op) ->
      Impossible.impossible "asked to rewrite (not convert) floating-point result"
  | RP.App (("f2i", [fw; iw]), [x; rm]) ->
      let fw' = bestwidth fw in
      RP.App (("f2i", [fw'; iw]), [convert ~from:fw ~to':fw' x; rm])
  | RP.App ((("fcmp"|"flt"|"fle"|"fgt"|"fge"|"feq"|"fne"|"fordered"|"funordered")
               as opname, [w]), [x; y]) ->
      let w' = bestwidth w in
      RP.App ((opname, [w']), [convert ~from:w ~to':w' x; convert ~from:w ~to':w' y])
  | RP.App(op, args) ->
      RP.App (op, List.map rewrite args)
@ 
Function [[loc]] rewrites all subexpressions that appear in a location
(i.e., in an addressing expression).
<<widening>>=
and loc l = match l with
| RP.Mem(sp, agg, w, addr, assn)    -> RP.Mem(sp, agg, w, rewrite addr, assn)
| RP.Slice(w, lsb, l)               -> RP.Slice(w, lsb, loc l)
| RP.Reg(_, _, _) | RP.Var(_, _, _) -> l in
@ 
Assignment requires that we know whether the right-hand side is a
floating-point expression.  If so, [[convert]], otherwise [[rewrite]].
<<widening>>=
let is_floating_exp = function
  | RP.App(op, args) -> Rtlop.Types.has_floating_result (Up.opr op)
  | _ -> false in
let guarded (g, eff) =
  let eff = match eff with
  | RP.Store(l, r, w) ->
      if is_floating_exp r && bestwidth w <> w then
        let r = convert ~from:w ~to':(bestwidth w) r in
        RP.Store(loc l, force_f2f (bestwidth w) w r, bestwidth w)
      else
        RP.Store(loc l, rewrite r, w)
  | RP.Kill l -> RP.Kill (loc l) in
  (rewrite g, eff) in
@ 
In the common case where we have no operators that need conversion, we
avoid rewriting the RTL, thereby reducing the load on the major heap.
<<widening>>=
let rtl r = 
  let needs_conversion op =
    Rtlop.Types.has_floating_result op ||
    match fst (Down.opr op) with
    | "fcmp"|"flt"|"fle"|"fgt"|"fge"|"feq"|"fne"|"fordered"|"funordered"|"f2i" -> true
    | _ -> false in
  if Rtlutil.ExistsOpr.rtl needs_conversion r then
    match Down.rtl r with
    | RP.Rtl es -> Up.rtl (RP.Rtl (List.map guarded es))
  else
    r in
