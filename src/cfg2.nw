
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution AST AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ################################################################## 
\section{Control Flow Graph}
% ################################################################## 

The dynamic part of a procedure is represented by a control flow
graph (\cfg):  nodes represent statements, and edges possible flow of
control between statements.  This interface allows to build a control
flow graph for a procedure.  Many aspects are left abstract to foster
different implementations.

The interface is divided into two parts:  the first defines types that
are used in the interface and also shared among all implementations. 
The second part defines a module type [[S]] that describes the
interface for building, inspecting, and altering a flow graph. 

<<cfg2.mli>>=
module type S = sig
    <<signature S>>
end
<<signature S>>
@

<<signature S>>=
<<concrete types>>
<<abstract types and values>>
@

For the nodes of a {\cfg} at least two plausible designs exist:  the
information a node represents can be either target-specific or not.  A
target-independent node is in later phases of the backend replaced by
a target-specific {\rtl}.  If a node is target specific right from the
start all kinds of nodes can be represented as {\rtl}s.  On the other
hand, target-specific informations must be used when nodes are
created.  We have decided to strive for greater uniform in the back
end and use target-specific nodes.


% ------------------------------------------------------------------ 
\subsection{Shared Types}
% ------------------------------------------------------------------ 

A control flow graph is cyclic in general.  In order to express cycles
while building the graph nodes can be labeled and referred to by name. 
In particular it is possible to use these names before its defining
label exists.

<<concrete types>>=
type label      = string
@

{\PAL} continuations can be used to model exception handling.  Nodes
that can transfer control to a continuation are annotated with a
[[cuts]] value that lists the different possible nodes/continuations.

<<concrete types>>=
type cuts =     { cuts    : label list
                ; unwinds : label list
                ; returns : label list
                ; aborts  : bool
                }
@
                
A formal parameter is a variable, an actual parameter an expression. 
Both can have optional hints, and have a [[width]], i.e.~a type. 

<<concrete types>>=
type formal =   { name:      string 
                ; width:     Rtl.width       (* bits *)
                ; hint:      string option   (* C-- hint *)
                ; api:       int             (* run-time API index*)
                } 

type actual     = Rtl.exp 
                * Rtl.width 
                * string option               (* hint *)
@


% ------------------------------------------------------------------ 
\subsection{Construction}
% ------------------------------------------------------------------ 

A control flow graph (\cfg) is an abstract value [[cfg]] that includes
nodes which have successor nodes.  Although a control flow graph is an
arbitrary graph in general, this interface demands that the graph is
created in a linear order that basically defines the code layout of
machine instructions. 

Nodes have to have properties---notably, span bindings. A node's
properties are fixed upon its creation.

\begin{itemize}
\item Span bindings allow to mark regions of source code with a
      compile-time constant key, and a link-time constant value.
\item Comments attached to nodes by [[add_comment]] help to debug
      generated code. A comment must not contain a newline character. 
\end{itemize}


<<abstract types and values>>=
module Props: sig
    type t
    val empty: t
    val comment: t -> string -> t
end
@

A control-flow graph [[cfg]] is created from a list of [[nodes]] where
the first node in the list is the graph's entry node, and the last
node its exit node.  Nodes are created by construction functions, like
[[exit]] or [[branch]], which are detailed below. 

<<abstract types and values>>=
exception Error of string       
type node
type cfg
val freeze: node list -> cfg (* raises Error if node list empty *) 
@

Nodes that can be reached from a given node at run-time are called the
nodes \emph{successors}.  During construction of a node, two methods
exist to specify its successors:  [[label]] nodes are referred to by
their name.  For some nodes, like the [[assign]] node, the successor
is the node following it in the node list that is constructed.  For
other nodes, like [[goto]], the following node in the list has no
special meaning. Nodes that have the node following them as a
successor are marked with [[(*succ*)]] below.

Every node includes a mutable set of variables for liveness analysis. 
For this reason every node can only participate in one [[cfg]] value: 
sharing of nodes between different control-flow graphs is asking for
trouble.

The {\rtl}s passed to node creation functions are in general
target-specific.  For example:  the target of a [[goto]] can be
described by an target-independent [[Rtl.exp]] value.  The [[rtl]]
implementing the [[goto]] is target specific.  The [[rtl]] taken by
the [[return]] function is provided by the actual target description.

<<abstract types and values>>=
val exit:                             Props.t -> node
val goto:   Rtl.rtl  -> label list -> Props.t -> node
val call:   Rtl.rtl  -> cuts       -> Props.t -> node (*succ*)
val assign: Rtl.rtl                -> Props.t -> node (*succ*)
val branch: Rtl.rtl  -> label      -> Props.t -> node (*succ*)
val label:  label                  -> Props.t -> node (*succ*)

val copyi:  formal list -> Automaton2.t -> Props.t -> node list * Automaton2.area (*succ*)

val return: int*int    -> Rtl.rtl -> actual list -> Automaton2.t -> Props.t -> node list * Automaton2.area
val jump:   label list -> Rtl.rtl -> actual list -> Automaton2.t -> Props.t -> node list * Automaton2.area
val cutto:  cuts       -> Rtl.rtl -> actual list -> Automaton2.t -> Props.t -> node list * Automaton2.area
@

The [[copyi]] function actually does not create a single node each,
but sequences of [[assign]] nodes.  Analysis functions for a {\cfg}
will thus never report a [[copyi]] node.

% ------------------------------------------------------------------ 
\subsection{Inspection}\label{sect:cfgliveness}
% ------------------------------------------------------------------ 

The following functions allow to inspect a {\cfg}.  One of the most
important functions is [[succ]] that returns a list of all nodes
directly reachable (in the control-flow sense) from a given node. 
Everything in a flow graph should be reachable from the [[entry]]
node.  Note, that nodes reported by the analysis functions have type
[[node']] that is different from the type [[node]] that was used by
the construction functions.

The dual operation is finding the predecessors of a node.

Finding the successors or predecessors of a node requires to resolve
labels. 
It is a checked run-time error to call [[succ]] or [[pred]] on a graph
that contains unresolved labels.

<<abstract types and values>>=
type node'
val entry: cfg -> node' 
val succ:  cfg -> node' -> node' list (* precondition: no undefined labels *)
val pred:  cfg -> node' -> node' list (* precondition: no undefined labels *)
@

The [[kind]] function reports a node's flavor and most of the data
that was used to create it.  The liveness analysis (module
\module{live}) ususally deduces the register usage from a node's
{\rtl}.  In some cases liveness analysis needs some extra help
provided by registers sets that are part of nodes.

<<concrete types>>=
type  set       = Register.Set.t

type  kind      = Goto          of Rtl.rtl * label list 
                | Call          of Rtl.rtl * cuts       
                | Assign        of Rtl.rtl               
                | Branch        of Rtl.rtl * label      
                | Label         of label                   
                | Exit
                | Jump          of set * Rtl.rtl * label list 
                | Cutto         of set * Rtl.rtl * cuts       
                | Return        of set * Rtl.rtl * (int*int)             
@

<<abstract types and values>>=
val kind: node' -> kind
@

Liveness analysis (module \module{liveness}) determines the set of
variables \emph{live before} a given node.  This set [[live]] is
stored in every node and can be updated by side effect using
[[set_live]] -- see below. 

<<abstract types and values>>=
val live:     node' -> set
@

A [[cfg]] is created from a list of nodes.  The function [[foldl cfg
f]] walks over the list from head to tail and applies [[f]] to each
node.  At each node, [[f]] receives the current [[node']] and an
intermediate result [['a]] which it combines to a new result [['a]]. 
The intermediate result for the first node is the 3rd argument to
[[foldl]].  \emph{This is a rather clumsy description.}
  
<<abstract types and values>>=
val foldl: cfg -> (node' -> 'a -> 'a) -> 'a -> 'a
@

\begin{quote}\it
        We currently have no function to inspect the properties of a
        node. 
\end{quote}

% ------------------------------------------------------------------ 
\subsection{Manipulation}
% ------------------------------------------------------------------ 

The [[live]] set of a node can be set to a new value using
[[set_Live]]:

<<abstract types and values>>=
val set_live: node' -> set -> unit
@

To apply a function to all nodes of a [[cfg]] call [[iter]].  The
function walks over the list of nodes from back to front.  Since most
control flows from front to back, [[iter]] is well suited for data
flow problems like liveness analysis, that prefer backward walks over
the control flow.

<<abstract types and values>>=
val iter:   cfg -> (node' -> unit) -> unit
@

The code expansion-step in the compiler back end expands single
[[rtl]] values into a list.  The [[expand]] function supports this by
walking over an [[cfg]] and passing all relevant nodes to an expansion
function.  The result is then used to build a new and expanded [[cfg]]
value.

<<abstract types and values>>=
val expand: cfg -> (Rtl.rtl -> Rtl.rtl list) -> cfg
@

The register allocation process substitutes temporary locations in the
[[cfg]] with hardware registers.  Both are represented as [[Rtl.loc]]
values.  The [[subst map cfg]] function returns a [[cfg]] where all
locations in the domain of [[map]] are replaced by the associated
location.

<<abstract types and values>>=
val subst: cfg -> (Rtl.loc -> Rtl.loc) -> cfg
@

% ################################################################## 
\subsection{Implementation}
% ################################################################## 

The implementation re-uses the generative type declarations and the
signature [[S]] as it is defined in the internet. The interesting
stuff that implements this signature comes next.

<<cfg2.ml>>=
module A = Automaton2
module type S = sig
    <<signature S>> 
end
<<concrete types>>
<<implementation of S>>    
@

% ------------------------------------------------------------------ 
\subsubsection{Properties}
% ------------------------------------------------------------------ 

The implementation for properties is ``preliminary''. We yet have no
real idea about it.

<<implementation of S>>=
module Props = struct
    type t = unit
    let empty = ()
    let comment () str = ()
end
@

% ------------------------------------------------------------------ 
\subsubsection{Construction Functions}
% ------------------------------------------------------------------ 

A [[node]] during construction of a [[cfg]] bundles its [[kind]], live
set and properties. A [[node']] on the other hand is a list of
[[nodes]] such that we have access to the successor of a given node.

<<implementation of S>>=
module StrMap = Map.Make(struct type t=label let compare=compare end)

exception       Error of string (* general purpose *)
type node =     { kind:         kind
                ; mutable live: set
                ; props:        Props.t
                }
type node'      = node list   
@

A [[cfg]] holds the list of all nodes plus an index that resolves all
labels. The [[index]] is a map from a [[label]] to a [[node']].

<<implementation of S>>=
type cfg =      { entry: node'
                ; index: node' StrMap.t
                }
@

The [[node]] construction function helps to set up nodes properly.
In particular the [[live]] is initialized to the empty set.
Constructing nodes provides no surprises. The interface provides no
value added services like inventing labels or linearizing code. This
must be done by the client where all the other logic for constructing
the control-flow graph is anyway.

<<implementation of S>>=
let node props kind =
    { kind  = kind
    ; live  = Register.Set.empty
    ; props = props
    }

let exit              props = node props (Exit)             
let goto   rtl labels props = node props (Goto(rtl,labels))
let call   rtl cuts   props = node props (Call(rtl,cuts))
let assign rtl        props = node props (Assign(rtl))  
let label  l          props = node props (Label(l))    
let branch rtl label  props = node props (Branch(rtl,label)) 
@



A [[jump]], [[cutto]], or [[return]] statement exits a function. 
These statements are not translated to a single node, but to a list of
nodes and an overflow [[area]].  The [[area]] captures the space
allocated in the parameter passing area on the stack.  Code that
passes parameters is translated into a sequence of {\rtl}s which in
turm become assignment nodes.  This sequence is terminated by a
[[return]] node, which carries the data otherwise associated with the
original statement.

The terminating node does not include enough information for the
liveness analysis to deduce what registers are live. We therefore
analyze the assignment nodes we have generated to deduce the set of
registers that are defined by it and annotate the final node with this
set. 

The [[store_actual]] function asks to calling convention automaton
[[cc]] for a location [[loc]] to store an actual parameter and stores
it there.  This store is represented by the [[rtl]] that is returned. 
The automaton [[cc]] is mutated!

To get the 
<<implementation of S>>=
let store_actual (cc: A.t) (expr,width,hint) = (* updates cc *)
    let loc = A.ty cc width hint  in
        (A.store loc expr width: Rtl.rtl)

let fetch_formal (cc: A.t) formal = (* updates cc *)
    let loc = A.ty cc formal.width formal.hint in
    let exp = A.fetch loc formal.width         in (* value of formal *)
    let var = Rtl.var formal.name formal.api formal.width in
        Rtl.store var exp formal.width
@

The [[copyi]] function creates a list of assignement nodes that
together implement the calling convention.  Each node copies one
parameter from the location determined by the calling convention to a
local {\PAL} variable. 

<<implementation of S>>=
let copyi formals cc props =
    let rtls  = List.map (fetch_formal cc) formals          in
    let area  = A.freeze cc                                 in
    let nodes = List.map (fun rtl -> assign rtl props) rtls in     
        nodes, area
@
_
The next four functions help to a compute the set of registers read
and written by a list of {\rtl}s.  Function [[rw]] returns two sets
$(\mathit{read},\mathit{write})$ of registers read and written by a
list of {\rtl}s.

<<implementation of S>>=
let (reg: Rtl.space -> int -> Rtl.width -> Register.t) = fun 
    space index width -> (space,index,width)

let add_left  space index width (left,right) = 
    (Register.Set.add (reg space index width) left, right)

let add_right  space index width (left,right) = 
    (left, Register.Set.add (reg space index width) right)

let rw rtls =
    let empty      = (Register.Set.empty, Register.Set.empty)           in
    let add rw rtl = Rtlutil.read_write_lists add_left add_right rtl rw in
        List.fold_left add empty rtls
@

The [[return]] function generates a list of assign nodes for actual
parameters plus a return node with liveness annotation:  all locations
defined by the assign nodes are considered to be used by the
[[return]] node in order to keep them live.  The same applies for the
other nodes that exit a precedure:  [[jump]] and [[cutto]].
        
<<implementation of S>>=
let return xy rtl actuals cc props = 
    let rtls      = List.map (store_actual cc) actuals          in
    let assigns   = List.map (fun rtl -> assign rtl props) rtls in
    let (use,def) = rw rtls                                     in
    let ret       = node props (Return (def,rtl,xy))            in  
    let area      = A.freeze cc                                 in
        assigns@[ret], area
@

<<implementation of S>>=
let jump labels rtl actuals cc props =
    let rtls      = List.map (store_actual cc) actuals          in
    let assigns   = List.map (fun rtl -> assign rtl props) rtls in
    let (use,def) = rw rtls                                     in
    let jump      = node props (Jump(def,rtl,labels))           in  
    let area      = A.freeze cc                                 in
        assigns@[jump], area

<<implementation of S>>=
let cutto cuts rtl actuals cc props =
    let rtls      = List.map (store_actual cc) actuals          in
    let assigns   = List.map (fun rtl -> assign rtl props) rtls in
    let (use,def) = rw rtls                                     in
    let jump      = node props (Cutto(def,rtl,cuts))            in  
    let area      = A.freeze cc                                 in
        assigns@[jump], area


@

 

The [[freeze]] function computes an [[index]] from labels to the node
it precedes.  This map is used to look up labels when computing
successors. It is illegal to build a completely empty [[cfg]]---it
must have at leat an [[exit]] node.

The [[index]] function walks over the list of nodes and puts every
node following a label into a map under the name of the label.

<<implementation of S>>=
let rec index map = function
    | x::nodes -> 
        ( match x.kind with
        |  Label(label) -> index (StrMap.add label nodes map) nodes
        |  _            -> index map nodes
        )
    | []                -> map
    
let freeze = function
    | []    -> raise (Error "freeze: empty list of nodes")
    | nodes -> 
        { entry = nodes
        ; index = index StrMap.empty nodes
        }   
@

% ------------------------------------------------------------------ 
\subsection{Inspection}
% ------------------------------------------------------------------     

Analysis functions return [[node']] values, which are actually list of
[[node]] (without quote) values. The [[entry]] point of a [[cfg]] is
the first [[node]] in the list, and thus the entire list as a
[[node']] value.

<<implementation of S>>=
let entry = function
    | {entry=x::xx as nodes} -> nodes
    | {entry=[]}             -> []
@
  
The [[live]] and [[kind]] functions simply report what is there.

<<implementation of S>>=
let live = function
    | x::xx -> x.live
    | []    -> assert false

let kind = function
    | x::xx -> x.kind
    | []    -> assert false
@

The successors of a node depend on the kind of the node. Some nodes name
successors by names, for others the following node in the list of node is
a successor. The [[lookup]] function uses the [[cfg.index]] to resolve
names. If a name is not found because it was never defined by a label
this is an internal error. User programs with undefined labels are
rejected; at this stage all labels must be defined.
    
<<implementation of S>>=
let lookup cfg label =
    try StrMap.find label cfg.index
    with Not_found -> assert false

let lookup_cuts cfg cuts =
    let targets = List.map (lookup cfg) in
    List.concat [ targets cuts.cuts
                ; targets cuts.unwinds
                ; targets cuts.returns
                ]
@

The [[succ]] function looks at the kind of node and collects its
successors. 
                
<<implementation of S>>=
let succ cfg = function
    | []          -> assert false
    | node::next -> 
        ( match node.kind with 
        | Goto(_,labels)   -> List.map (lookup cfg) labels
        | Jump(_,_,labels) -> List.map (lookup cfg) labels
        | Cutto(_,_,cuts)  -> lookup_cuts cfg cuts
        | Return _         -> []
        | Call(_,cuts)     -> next::(lookup_cuts cfg cuts)  
        | Assign _         -> [next]
        | Branch(_,label)  -> [next;lookup cfg label]
        | Label _          -> [next]
        | Exit             -> []
        )                           

let pred _ _ = assert false (* should be fixed *)
@

To implement [[foldl]] we can't use [[List.foldl]] because a [[node']]
is a [[node list]] and not a [[node]]. So we implement our own version
of a [[fold]].

<<implementation of S>>=
let foldl cfg f z =
    let rec fold  r = function
        | []             -> r
        | n::nn as node' -> fold (f node' r) nn
    in
        fold z cfg.entry
@

 ------------------------------------------------------------------ 
\subsection{Manipulation}
% ------------------------------------------------------------------ 
        
The functions for manipulation of [[cfgs]] are mostly not yet
implemented. 

<<implementation of S>>=
let set_live node set = match node with
    | x::xx -> x.live <- set
    | []    -> assert false
@


The [[iter]] function is \emph{not} tail-recursive: before we process
the actual node, we have to process all following nodes first.

<<implementation of S>>=
let iter cfg f = 
    let rec loop = function
        | []             -> ()
        | n::nn as node' -> loop nn; f node'
    in
        loop cfg.entry
@

The [[expand]] function takes a function [[f]] that expands a single
[[rtl]] into a list of them in order to establish the machine
invariant.  For efficiency we build first a list of lists and flatten
it later.  Once we have done this we also have to re-build our index.

The expansion has to preserve the kind of a node.  When a [[rtl]] is
expanded into a list, all except the last [[rtl]] becomes an
[[assign]] node each.  The last [[rtl]] replaces the [[rtl]] in the
original node and thus preserves its kind.  But there is more:  each
node has properties and a set of live registers.  The fresh nodes will
have the same properties as the expanded nodes plus an \emph{empty}
set of live registers.  We rely on the fact that code expansion
happens before liveness analysis and thus all live sets are still
empty.  We use [[assert]] to secure this assumption.

its live set.  Since register sets are mutable, we have to makes
copies to avoid sharing.

[[subst_rtl]] takes a kind and returns a similar [[kind]] value with
the [[rtl]] replaced.

<<implementation of S>>=
let subst_rtl: kind -> Rtl.rtl -> kind = fun kind rtl -> match kind with
    | Goto   (_  ,x) -> Goto (rtl,x)
    | Call   (_  ,x) -> Call (rtl,x)
    | Assign  _      -> Assign(rtl)
    | Branch (_  ,x) -> Branch(rtl,x)
    | Jump   (s,_,x) -> Jump(s,rtl,x)
    | Cutto  (s,_,x) -> Cutto(s,rtl,x)
    | Return (s,_,x) -> Return(s,rtl,x)
    | Label  _       -> kind
    | Exit           -> kind
@

During the expansion a list of {\rtl}s must be transformed into a list
of nodes.  All except the last {\rtl} become an assignment node and
the last {\rtl} replaces the {\rtl} in the node that was expanded.

<<implementation of S>>=
let rtls2nodes: node -> Rtl.rtl list -> node list = fun n rtls ->
    let rec loop = function
        | []    -> assert false
        | [rtl] -> [node n.props (subst_rtl n.kind rtl)]
        | r::rr -> node n.props (Assign r) :: loop rr (* not tail rec. *)
    in
        ( assert (n.live = Register.Set.empty)
        ; loop rtls
        )
@

[[Exp]] takes the {\rtl} expansion function [[f]] and applies it to a
node [[n]]'s {\rtl}.  The resulting [[rtl list]] is transformed into a
list of node by [[rtls2nodes]]. 

<<implementation of S>>=
let exp: (Rtl.rtl -> Rtl.rtl list) -> node -> node list = fun f n ->
    match n.kind with
    | Goto   (rtl,_)   -> rtls2nodes n (f rtl)
    | Call   (rtl,_)   -> rtls2nodes n (f rtl)
    | Assign  rtl      -> rtls2nodes n (f rtl) 
    | Branch (rtl,_)   -> rtls2nodes n (f rtl)  
    | Jump   (_,rtl,_) -> rtls2nodes n (f rtl)  
    | Cutto  (_,rtl,_) -> rtls2nodes n (f rtl)  
    | Return (_,rtl,_) -> rtls2nodes n (f rtl)
    | Label  _         -> [n]
    | Exit             -> [n]
@

Finally, here is the exported function [[expand]].  It applies [[f]]
to all nodes to expand them.  After this is done, the [[index]] for
labels must be re-computed since the list of nodes has been changed.

<<implementation of S>>=
let expand: cfg -> (Rtl.rtl -> Rtl.rtl list) -> cfg = fun cfg f ->
    let entry = List.flatten (List.map (exp f) cfg.entry) in
        { entry = entry
        ; index = index StrMap.empty entry
        }   
@

Substitution of locations inside an [[Rtl.rtl]] is implemented by
[[Rtlutil.subst]]. Since each [[rtl]] is hidden in a [[kind]] we have
to provide a substitution at the level of kinds.

<<implementation of S>>=
let subst_loc: kind -> (Rtl.loc -> Rtl.loc) -> kind = fun kind map -> 
    let subst = Rtlutil.Subst.loc map in 
        match kind with
        | Goto   (rtl,x)    -> Goto (subst rtl,x)
        | Call   (rtl,x)    -> Call (subst rtl,x)
        | Assign  rtl       -> Assign(subst rtl)
        | Branch (rtl,x)    -> Branch(subst rtl,x)
        | Jump   (s,rtl,x)  -> Jump(s,subst rtl,x)
        | Cutto  (s,rtl,x)  -> Cutto(s,subst rtl,x)
        | Return (s,rtl,x)  -> Return(s,subst rtl,x)
        | Label  _          -> kind
        | Exit              -> kind
@

The substitution of locations in a [[cfg]] is quite simple. Because of
the applicative nature of [[cfg]] we have to re-compute the index that
is part of a [[cfg]]. Otherwise index entries still would point to the
old nodes.

<<implementation of S>>=
let subst cfg map =
    let subst_node n = { n with kind = subst_loc n.kind map } in
    let entry        = List.map subst_node cfg.entry          in
    let indx         = index StrMap.empty entry               in
        { entry = entry
        ; index = indx
        }
@    
