% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Typechecking Expressions}
% ------------------------------------------------------------------ 

The {\qcc} compiler type checks expressions during several phases: 
evaluation of constant expressions, static semantics, translation to
intermediate representation.  To avoid code duplication, type checks
for expressions are factored out into this module. 

The type of an expression depends on the types of named values, named
types and the target dependent word size. These are supplied as a
record [[env]] for the [[check]] function. 
<<types>>=
type env = 
    { tlookup:  string -> Types.ty       Error.error    (* type aliases *)
    ; vlookup:  string -> Types.ty       Error.error    (* types of values *)
    ; wordsize:           Rtl.width      
    ; pointersize:        Rtl.width      
    ; byteorder:          Rtl.aggregation 
    }   
@

<<expcheck.mli>>=
<<types>>
val check: env -> Ast.expr -> Types.ty Error.error      (* Error.ErrorExn *)
val exprfuns :
  'a Fenv.Dirty.env' ->
  (Ast.expr -> (Rtl.exp * Types.ty) Error.error) *
  (Ast.name_or_mem -> (Automaton.loc * Rtl.width) Error.error)
 (* exprfuns env = typed_expr, lvalue *)
@
The [[check]] function allows to work with incomplete functions,
indicated by [[Error.Error]] values.  The policy is as follows:
\begin{itemize}
\item In case of a success, [[check]] returns the type of the
      expression at hand as a [[Error.Ok]] value.
\item If the type check must use an erroneous information from the
      environment, it propagates this error and returns [[E.Error]].
\item If the type check detects a new error, for example a type
      inconsistency, the [[Error.ErrorExn]] exception is raised.
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<expcheck.ml>>=
module A = Ast
module AT = Automaton
module E = Error
module F = Fenv.Dirty
module FE = Fenv

let impossible = Impossible.impossible
let unimp = Impossible.unimp

<<types>> (* from interface *)

let (@<<) f g = fun x -> f (g x) (* function composition *)
    
let is2power x = x > 0 && x land (x - 1) = 0

(* NEAR-DUPLICATION WITH Oast2ir.astty *)
let elab env =
  let rec astty  = function
      | A.TyAt(x,r)  -> astty x
      | A.BitsTy(n)  -> E.Ok(Types.bits n)
      | A.TypeSynonym(x) -> env.tlookup x in

  let astwidth _ = assert false in
  let assertion _ = assert false in
  let rvalue_name_or_mem _ = assert false in
  let rec lvalue = function
      | A.NameOrMemAt(x,r) -> lvalue x
      | A.Name(hint,id)    -> unimp "lvalue name" (*lvalue_name id*)
      | A.Mem(ty,e,aligned,_)     -> 
          E.ematchTriple  (astwidth "memory access" env ty, typed_expr env e, assertion aligned)
            (fun (w,(addre, addrt),assn) ->
              if astwidth "address" addrt = env.pointersize then
                AT.of_loc (Rtl.mem assn 'm' env.byteorder w addre), w
              else
                E.error "address's type is not the machine's pointer size")
@
<<expcheck.ml>>=
and typed_expr env exp =
  let apply tx op args =
    E.ematch (E.Raise.list (List.map (typed_expr env) args))
    (fun args ->
      let arges, argtys = List.split args in
      let resty,  opr   = tx op argtys    in
      Rtl.app opr arges, resty) in
            
  let literal default cvt v ty =
    let w = match ty with
    | None    -> default
    | Some ty -> astwidth "literal bit vector" env ty  in
    let omsg w =
      Printf.sprintf "literal bit vector overflows when packed into %d bits" w in
    try Rtl.bits (cvt v w) w, Types.Bits w 
    with Bits.Overflow -> Error.error (omsg w) in
  match exp with
  | A.ExprAt(x,r)     -> E.catch E.errorPrt   (typed_expr env) x
  | A.Int   (x,ty)    -> E.Ok (literal env.wordsize Bits.U.of_string x ty)
  | A.Float (x,ty)    -> E.Ok (literal env.wordsize Bits.U.of_string x ty)
  | A.Char  (x,ty)    -> E.Ok (literal 8            Bits.U.of_int    x ty)
      (* perhaps suprisingly, [[Bits.U.of_string]] copes with all 
         literal formats. Update: I have changed the type of A.Char, it
         now contains an integer. -- CL *)
  | A.Fetch (v)       -> rvalue_name_or_mem v
  | A.BinOp (l,op,r)  -> apply Rtlop.Translate.binary op [l;r]
  | A.UnOp  (op,e)    -> apply Rtlop.Translate.unary  op [e]
  | A.PrimOp(op,args) -> apply Rtlop.Translate.prefix op (List.map snd args)
 
in typed_expr env

let check env e = E.ematch (elab env e) snd
@
% ------------------------------------------------------------------
\subsection{The translation of types, names, and expressions}
% ------------------------------------------------------------------ 

<<expcheck.ml>>=
module M = Metrics
<<utilities>>
<<definition of [[lvalue_name_in_env]]>>
let exprfuns env =
  let metrics = F.metrics env in
  let lvalue_name = lvalue_name_in_env env in
  <<definition of [[rvalue_name]]>> in
  let catch r f x = E.catch (E.errorRegionPrt (F.srcmap env, r)) f x in
  <<mutually recursive nest of [[typed_expr]] and [[lvalue]]>> in
  typed_expr, lvalue
@

There are four interesting syntactic categories here:
\begin{itemize}
\item
A \emph{type} is interesting only for its width.
We have two forms: one from [[Types]] and one from [[Ast]].We provide functions [[tywidth]] and [[astwidth]].
\item
A \emph{name} may occur in an lvalue context or an rvalue context; we
provide [[lvalue_name_in_env]] and [[rvalue_name]].
Many names are meaningful only in an rvalue context.
\item
A \emph{name-or-mem} may occur in an lvalue context or an rvalue context; we
provide [[lvalue]] and [[rvalue_name_or_mem]].
\item
An \emph{expression} may occur only in an rvalue context; we provide
[[typed_expr]].
\end{itemize}
Of the functions above, only [[lvalue_name_in_env]] and [[astwidth]]
are parameterized 
by an environment.
The rest appear in a context (under [[exprfuns]]) in which the
environment is bound to [[env]].
@
\subsubsection {Translation of type and conversion from type to width}
\nwaddbox{tywidth  : 'a Types.t -> 'a}
\nwaddbox{astwidth : F.env -> A.ty -> int}
\deeperbox{2pt}
<<utilities>>=
let tywidth a_bad_thing = function
  | Types.Bits n -> n
  | Types.Bool   -> E.error (Printf.sprintf "A boolean may not be %s" a_bad_thing)

let emap f x = E.ematch x f

let astwidth msg env =
  let rec astty = function
    | A.TyAt(x,r)  -> astty x
    | A.BitsTy(n)  -> E.Ok (Types.bits n)
    | A.TypeSynonym(x) -> snd (F.findt x env) in
  emap (tywidth msg) << astty 
@
\subsubsection{The meanings of names}

Only the name of a {\PAL} register variable is meaningful in an lvalue
context.
The environment is explicit.
\nwaddbox{lvalue_name_in_inv : F.env -> name -> AT.loc * Rtl.width}
\deeperbox{16pt}
<<definition of [[lvalue_name_in_env]]>>=
let lvalue_name_in_env env x = 
  E.ematch (snd (F.findv x env))
  (fun (denot,t) ->
    let w = tywidth "assigned to" t  in
    match denot with
    | FE.Variable {FE.loc=l} -> AT.of_loc l, w
    | _ -> 
        let what = match denot with
        | FE.Constant _ -> "constant"
        | FE.Label    _ -> "label"
        | FE.Import   _ -> "imported symbol"
        | FE.Continuation _ -> "continuation"
        | FE.Variable _ -> "register" in
        impossible ("asked for lvalue of " ^ what ^ " " ^ x))
@ 
Any name can be meaningful in an rvalue context.
The environment is implicit.
\nwaddbox{val rvalue_name : name -> Rtl.exp * Types.t}
<<definition of [[rvalue_name]]>>=
let rvalue_name x =
  E.seq (snd (F.findv x env))
  (fun (denot, t) ->
    let w = tywidth "named variable" t in
    let rval = match denot with
    | FE.Constant(bits)            -> E.Ok (Rtl.bits bits w)
    | FE.Label(FE.Proc s)           -> E.Ok (Rtl.codesym s w)
    | FE.Label(FE.Code s)           -> E.Ok (Rtl.codesym s w)
    | FE.Label(FE.Data s)           -> E.Ok (Rtl.datasym s w)
    | FE.Import(_,s)               -> E.Ok (Rtl.impsym  s w)
    | FE.Continuation c            -> (c.FE.escapes <- true; E.Ok (Block.base c.FE.base))
    | FE.Label(FE.Stack addr) -> E.Ok addr  (* a fetch would be wrong *)
    | FE.Variable _                -> emap atfetch (lvalue_name x) in
    E.Raise.left (rval, t))
@ 
Help for fetching and storing automata locations.
<<utilities>>=
let atfetch (loc, w)     = loc.AT.fetch w
let atstore (loc, w) exp = loc.AT.store exp w
@ 
\subsubsection{General lvalues}

Again, the environment is implicit.
\nwaddbox{lvalue : Ast.lvalue -> AT.loc * Rtl.width}
\deeperbox{14pt}
<<mutually recursive nest of [[typed_expr]] and [[lvalue]]>>=
let rec lvalue lhs = match lhs with
  | A.NameOrMemAt(lhs,_) -> lvalue lhs
  | A.Name(hint,x)       -> lvalue_name x 
  | A.Mem(t,addr,aligned,aliasing) ->
      let w    = astwidth "value in memory" env t in
      let addr = typed_expr addr in
      E.ematchTriple  (w, addr, assertion aligned)
        (fun (w, (addre, addrt), assn) ->
          if tywidth "address" addrt = metrics.M.pointersize then
            AT.of_loc (Rtl.mem assn 'm' metrics.M.byteorder w addre), w
          else
            E.error "address's type is not the machine's pointer size")
and expr e = emap fst (typed_expr e) 
and rvalue_name_or_mem nm = match nm with
  | A.NameOrMemAt(v, _) -> rvalue_name_or_mem v
  | A.Name(hint, x)     -> rvalue_name x
  | A.Mem(_, _, _, _)   ->
      E.ematch (lvalue nm) (fun (loc, w) -> loc.AT.fetch w, Types.Bits w)
@
<<utilities>>=
let assertion = function
  | None -> Rtl.none
  | Some n when is2power n -> Rtl.aligned n 
  | Some n -> E.error (Printf.sprintf "Alignment %d is not a power of 2" n) 
let assertion x = E.catch E.errorPrt (fun x -> E.Ok (assertion x)) x
@ 
% ------------------------------------------------------------------ 
\subsubsection{The meaning of expressions}
% ------------------------------------------------------------------ 

Although in many cases we need only the RTL associated with an
expression, it is simple and efficient to produce both the type and
the RTL at one time. 
\nwaddbox{typed_expr : Ast.exp -> Rtl.exp * Types.t}
<<mutually recursive nest of [[typed_expr]] and [[lvalue]]>>=
and typed_expr exp = 
  let apply tx op args =
    E.ematch (E.Raise.list (List.map typed_expr args))
    (fun args ->
      let arges, argtys = List.split args in
      let resty,  opr   = tx op argtys    in
      Rtl.app opr arges, resty) in
  let literal cvt v width = Rtl.bits (cvt v width) width, Types.Bits width in
  let literal cvt v = emap (literal cvt v) in
  let const default_width = function
    | Some ty -> astwidth "literal constant" env ty
    | None    -> E.Ok default_width in
  match exp with
  | A.ExprAt(x,r)     -> catch r typed_expr x
  | A.Int(str,t)      -> literal Bits.U.of_string str (const metrics.M.wordsize t) 
  | A.Float(str,t)    -> literal Bits.U.of_string str (const metrics.M.wordsize t) 
  | A.Char(int,t)     -> literal Bits.U.of_int    int (const 8                  t) 
      (* perhaps suprisingly, [[Bits.U.of_string]] copes with all 
         literal formats. Update: I have changed the type of A.Char, it
         now contains an integer. -- CL *)
  | A.Fetch(v)        -> rvalue_name_or_mem v
  | A.BinOp (l,op,r)  -> apply Rtlop.Translate.binary op [l;r]
  | A.UnOp  (op,e)    -> apply Rtlop.Translate.unary  op [e]
  | A.PrimOp(op,args) -> apply Rtlop.Translate.prefix op (List.map snd args)
<<utilities>>=

