% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:
% Area.nw is going to be replaced by this module. It is much simpler and
% purely functional.

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Please add grades for this module below. The line must start with % "%%".
% 

%Grades: C Subsystem Later

% ------------------------------------------------------------------ 
\section{Memory Blocks}
% ------------------------------------------------------------------ 

\begin{quote}\it It would be nice to have an \emph{empty} block that
    acts as a unit for the [[cat]] and [[overlap]] operations.
    This way operations on block lists became well defined. The problem
    is the address expression: what width should it have? -- CL
\end{quote}

This module defines memory blocks that can be composed into complex
blocks. The main application is the definition of a procedure's stack
frame. However, this module is completely general.

A block [[t]] is a contiguous piece of memory with a base address $b$
and a size $s$. It covers the open address interval $[b, b+s)$. The base
address $b$ respects the alignment requirement $a$: at run time, $b
\bmod a = 0$ is known to hold. The base, size, and alignment are used to
construct a block and can be observed as well.

<<block.mli>>=
type t

(* constructors *)
val mk: base:Rtl.exp -> size:int -> alignment:int -> t

(* observers *)
val base:           t -> Rtl.exp
val size:           t -> int
val alignment:      t -> int
val constraints:    t -> Const2.t list
@

The base address of a block is typically not fixed, but contains some
\emph{late compile-time constants}. The values of these are determined
by the compositions a block takes part in. Once all compositions are
done, the final constraints can be observed and fed into an equation
solver. The result of the constraints are values for the late
compile-time constants. A separate substitution step must replace the
late compile-time constants in {\rtl} expressions that emerged from the
block operations.

\emph{Attention:} the semantis of [[cat]] might counter your intuition.
The result of [[cat x y]] is one block into which [[x]] and [[y]] are
embedded side by side. Block [[y]] occupies a lower addresses, and [[x]]
the higher. This might be counter intuitive if you think about [[x]] and
[[y]] as a string $(x,y)$ where $x$ is the beginning, i.e.~low end of
the string.  The problem becomes even more apparent when lists of blocks
are concatenated: in $[x,y,z]$ the $x$ is a the top, not the bottom.

Two blocks whose data are live at the same time can be concatenated into
one bigger block. Inside the new block, the data from the first block
occupies the higher addresses, and the second block the lower addresses.
Both address spaces do not overlap. Between those two blocks might be a
gap to fulfill the alignment requirements of both blocks.

Two blocks whose data are never live at the same time can be overlapped
into one block where the two blocks share memory. In the resulting block
the two original blocks can either share their [[Low]] or [[High]] end.
Both blocks must be \emph{adjusted}: their size is a multiple of their
alignment requirement. The [[adjust]] function enlarges a block if
necessary to make it adjusted.

<<block.mli>>=
type placement = High | Low

val cathl:      t -> t -> t                  (* cat x y : x and y adjacent 
                                                with x at *higher* address *)  
val overlap:    placement -> t -> t -> t     (* req: arguments are adjusted *)
val adjust:     t -> t                       (* result is adjusted *)
@

Convenient functions -- they could be easily implemented outside
this module in terms of the above primitives; it is a checked run-time
error when the argument lists are empty.

<<block.mli>>=
val cathl_list:       t list -> t
val overlap_list:   placement -> t list -> t
@

% ------------------------------------------------------------------ 
\subsection{Lua Interface}
% ------------------------------------------------------------------ 

Blocks are exported as abstract user data to Lua. However, not all
operations available in {\ocaml} are also available in Lua. Blocks can
be observed and composed, but there is no way to create primitive
blocks. The main reason for these limitations that blocks rely on other
data types that have no Lua representation.

From the Lua point of view, blocks provide the following (C-style)
signature: :

<<lua block signature>>=
block   Block.mk(block addr, int size, int alignment, string offset)
int     Block.size(block block)
int     Block.alignment(block)
block   Block.adjust(block)
block   Block.cat(block table)
block   Block.overlap("high"|"low", block table)
@

The [[Block.mk]] function does not take an address directly, but another
block whose address $a$ is used to form a new address $a+k$, where $k$
is a late compile-time constant. The last string argument is optional
and is used to build a unique compile-time constant. The other two
arguments are identical to that of the {\ocaml} function [[mk]] and
provide size and alignment.

<<block.mli>>=
module Lua: sig
    val size:       t -> int
    val alignment:  t -> int
    val adjust:     t -> t
    val cat:        (string -> t) -> t list -> t
    val overlap:    (string -> t) -> string -> t list -> t
    val mk:         t -> int (*size*) -> int -> string option -> t
end
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<block.ml>>=
module C = Const2

type t =
    { base:         Rtl.exp
    ; size:         int
    ; alignment:    int
    ; constraints:  C.t list
    }

let base t          = t.base
let size t          = t.size
let alignment t     = t.alignment
let constraints t   = t.constraints

let mk ~base ~size ~alignment =
    { base          = base
    ; size          = size
    ; alignment     = alignment
    ; constraints   = []
    }

type placement = High | Low
@

[[Align x n]] returns the smallest multiple of $n$ that is not smaller
than $x$. Think of $x$ becoming $n$-aligned. 

<<block.ml>>=
let align x n = if x mod n = 0 then x else n * (x/n+1)
@

[[Add]] adds an integer to an {\rtl} expression and returns an {\rtl}
expression.

<<block.ml>>=
let add exp i = 
    let width = Rtlutil.Width.exp exp in
    let opr   = Rtl.opr "add" [width] in
        Rtl.app opr [exp; Rtl.bits (Bits.S.of_int i width) width]
@

The size of an adjusted block is a multiple of its alignment.

<<block.ml>>=
let adjust t = { t with size = align (size t) (alignment t) }
@


When concatenating, we have to leave a gap between the first and the
second block to make sure we respect the alignment of the second block.
We do so by virtually increasing the size of the first block to
[[size']] which is a multiple of the second block's allignment. The
alignment of the resulting block is the maximum of the two incoming
alignments.

\emph{Attention:} as discussed above, there is a possability for
confusion here which block goes into low memory and which into high
memory. Block [[x]] sits on top of [[y]].

<<block.ml>>=
let cathl x y =
    let size' = align (size y) (alignment x) in
        { base          = base y
        ; size          = size' + size x
        ; alignment     = max (alignment y) (alignment x)
        ; constraints   = C.equate (add (base y) size') (base x)  
                          :: (constraints y) @ (constraints x) 
        }
@

When overlapping blocks, the resulting block must be large enough for
the bigger of the two. The constraints express that either the lower
ends align, or the higher ends.

<<block.ml>>=
let overlap place x y = 
    (* assert ((size x) mod (alignment x) = 0)
     * assert ((size y) mod (alignment y) = 0)
     *) 
    
    let x = adjust x        (* to avoid trouble for now *)
    and y = adjust y in
    match place with
    | Low ->      
        { base          = base x
        ; size          = max (size x) (size y)
        ; alignment     = max (alignment x) (alignment y)
        ; constraints   = C.equate (base x) (base y)
                          :: (constraints x) @ (constraints y)
        }    
    | High ->      
        { base          = if size x > size y then base x else base y
        ; size          = max (size x) (size y)
        ; alignment     = max (alignment x) (alignment y)
        ; constraints   = C.equate (add (base x) (size x))
                                   (add (base y) (size y))
                          :: (constraints x) @ (constraints y)
        }           

@        

Not essential, but convenient functions.

<<block.ml>>=
let cathl_list     ts = List.fold_left cathl       (List.hd ts) (List.tl ts)
let overlap_list p ts = List.fold_left (overlap p) (List.hd ts) (List.tl ts)
@

% ------------------------------------------------------------------ 
\subsection{Export to Lua}
% ------------------------------------------------------------------ 

We export the block abstraction to Lua. The actual export is handled in
module \module{lualink}. Here we just provide the {\ocaml} functions
that implement the new Lua primitives and the representation [[T]] for
blocks in Lua..

<<block.ml>>=
module Lua = struct
    let size      = size
    let alignment = alignment
    let adjust    = adjust
    
    <<Block primitives for Lua>>
end
@

Some primitives are not simply the {\oacml} functions but need
additionally check arguments to prevent the interpreter fail. For error
reporting functions receive a function [[error]] that expects a string.

<<Block primitives for Lua>>=
let cat error = function
    | [] -> error "Block.cat: empty argument list"
    | bs -> cathl_list bs

let overlap error placement blocks = match (placement, blocks) with
    | _     , [] -> error "Block.overlap: empty block list"
    | "high", bs -> overlap_list High bs
    | "low" , bs -> overlap_list Low  bs
    | _          -> error "Block.overlap: 'high' or 'low' expected"
@    

The Lua version for [[mk']] is significantly different from the {\ocaml}
version of [[mk]]. The address $a'$ for the new block is derived from
the address $a$ of an existing block. We form a new address $a'=a+k$
where $k$ is a late compile-time constant. The client can optionally
provide a name for the constant that is fed into [[Idgen]] to make it
unique.

<<Block primitives for Lua>>=
let offset base name ptrwidth =
    let k = Rtl.late (Idgen.offset name) ptrwidth in
        Rtl.app (Rtl.opr "add" [ptrwidth]) [base;k] 

let mk block size alignment name =
    let name  = Aux.Option.get "Block.mk" name in (* name for late *)
    let width = Rtlutil.Width.exp (base block) in (* width of addr *)  
    let late  = Rtl.late name width in
    let addr  = offset (base block) name width in
        mk addr size alignment
@


