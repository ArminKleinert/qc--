% Area.nw is going to be replaced by this module. It is much simpler and
% purely functional.

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Please add grades for this module below. The line must start with % "%%".
% 

%Grades: C Subsystem Later

% ------------------------------------------------------------------ 
\section{Memory Blocks}
% ------------------------------------------------------------------ 

\begin{quote}\it It would be nice to have an \emph{empty} block that
    acts as a unit for the [[cat]] and [[overlap]] operations.
    This way operations on block lists became well defined. The problem
    is the address expression: what width should it have? -- CL
\end{quote}

This module defines memory blocks that can be composed into complex
blocks. The main application is the definition of a procedure's stack
frame. However, this module is completely general.

A block [[t]] is a contiguous piece of memory with a base address $b$
and a size $s$. It covers the open address interval $[b, b+s)$. The base
address $b$ respects the alignment requirement $a$: at run time, $b
\bmod a = 0$ is known to hold. The base, size, and alignment are used to
construct a block and can be observed as well.

<<block.mli>>=
type t

(* constructors *)
val mk: base:Rtl.exp -> size:int -> alignment:int -> t

(* observers *)
val base:           t -> Rtl.exp
val size:           t -> int
val alignment:      t -> int
val constraints:    t -> Const2.t list
@

The base address of a block is typically not fixed, but contains some
\emph{late compile-time constants}. The values of these are determined
by the compositions a block takes part in. Once all compositions are
done, the final constraints can be observed and fed into an equation
solver. The result of the constraints are values for the late
compile-time constants. A separate substitution step must replace the
late compile-time constants in {\rtl} expressions that emerged from the
block operations.

Two blocks whose data are live at the same time can be concatenated into
one bigger block. Inside the new block, the data from the first block
occupies the lower addresses, and the second block the higher addresses.
Both address spaces do not overlap. Between those two blocks might be a
gap to fulfill the alignment requirements of both blocks.

Two blocks whose data are never live at the same time can be overlapped
into one block where the two blocks share memory. In the resulting block
the two original blocks can either share their [[Low]] or [[High]] end.
Both blocks must be \emph{adjusted}: their size is a multiple of their
alignment requirement. The [[adjust]] function enlarges a block if
necessary to make it adjusted.

<<block.mli>>=
type placement = High | Low

val cat:        t -> t -> t
val overlap:    placement -> t -> t -> t     (* req: arguments are adjusted *)
val adjust:     t -> t                       (* result is adjusted *)
@

Convenient functions -- they could be easily implemented outside
this module in terms of the above primitives; it is a checked run-time
error when the argument lists are empty.

<<block.mli>>=
val cat_list:       t list -> t
val overlap_list:   placement -> t list -> t
@

% ------------------------------------------------------------------ 
\subsection{Lua Interface}
% ------------------------------------------------------------------ 

Blocks are exported as abstract user data to Lua. However, not all
operations available in {\ocaml} are also available in Lua. Blocks can
be observed and composed, but there is no way to create primitive
blocks. The main reason for these limitations that blocks rely on other
data types that have no Lua representation.

From the Lua point of view, blocks provide the following signature:

<<lua block signature>>=
Block.size(block): int
Block.alignment(block): int
Block.adjust(block): block
Block.cat(block list): block
Block.overlap("high"|"low", block list): block
@

We export a module and a functor that are linked into the Lua
interpreter in module \module{lualink}.

<<block.mli>>=
module T: Lua.Lib.USERTYPE
module MakeLib  (V : Lua.Lib.TYPEVIEW with type 'a t = 'a T.t)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a V.combined 
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<block.ml>>=
module C = Const2

type t =
    { base:         Rtl.exp
    ; size:         int
    ; alignment:    int
    ; constraints:  C.t list
    }

let base t          = t.base
let size t          = t.size
let alignment t     = t.alignment
let constraints t   = t.constraints

let mk ~base ~size ~alignment =
    { base          = base
    ; size          = size
    ; alignment     = alignment
    ; constraints   = []
    }

type placement = High | Low
@

[[Align x n]] returns the smallest multiple of $n$ that is not smaller
than $x$. Think of $x$ becoming $n$-aligned. 

<<block.ml>>=
let align x n = if x mod n = 0 then x else n * (x/n+1)
@

[[Add]] adds an integer to an {\rtl} expression and returns an {\rtl}
expression.

<<block.ml>>=
let add exp i = 
    let width = Rtlutil.Width.exp exp in
    let opr   = Rtl.opr "add" [width] in
        Rtl.app opr [exp; Rtl.bits (Bits.S.of_int i width) width]
@

The size of an adjusted block is a multiple of its alignment.

<<block.ml>>=
let adjust t = { t with size = align (size t) (alignment t) }
@


When concatenating, we have to leave a gap between the first and the
second block to make sure we respect the alignment of the second block.
We do so by virtually increasing the size of the first block to
[[size']] which is a multiple of the second block's allignment. The
alignment of the resulting block is the maximum of the two incoming
alignments.

<<block.ml>>=
let cat x y =
    let size' = align (size x) (alignment y) in
        { base          = base x
        ; size          = size' + size y
        ; alignment     = max (alignment x) (alignment y)
        ; constraints   = C.equate (add (base x) size') (base y)  
                          :: (constraints x) @ (constraints y) 
        }
@

When overlapping blocks, the resulting block must be large enough for
the bigger of the two. The constraints express that either the lower
ends align, or the higher ends.

<<block.ml>>=
let overlap place x y = 
    (* assert ((size x) mod (alignment x) = 0)
     * assert ((size y) mod (alignment y) = 0)
     *) 
    
    let x = adjust x        (* to avoid trouble for now *)
    and y = adjust y in
    match place with
    | Low ->      
        { base          = base x
        ; size          = max (size x) (size y)
        ; alignment     = max (alignment x) (alignment y)
        ; constraints   = C.equate (base x) (base y)
                          :: (constraints x) @ (constraints y)
        }    
    | High ->      
        { base          = if size x > size y then base x else base y
        ; size          = max (size x) (size y)
        ; alignment     = max (alignment x) (alignment y)
        ; constraints   = C.equate (add (base x) (size x))
                                   (add (base y) (size y))
                          :: (constraints x) @ (constraints y)
        }           

@        

Not essential, but convenient functions.

<<block.ml>>=
let cat_list       ts = List.fold_left cat         (List.hd ts) (List.tl ts)
let overlap_list p ts = List.fold_left (overlap p) (List.hd ts) (List.tl ts)
@

% ------------------------------------------------------------------ 
\subsection{Export to Lua}
% ------------------------------------------------------------------ 

A block is represented as a [[userdata]] type in Lua. We could use the
[[Rtlutil.ToString]] module to provide a better [[to_string]] function.

<<block.ml>>=
module T = struct
    type block      = t         (* just to access outer type t *)
    type 'a t       = block
    let tname       = "block"
    let eq _        = fun x y -> x = y
    let to_string   = fun _ t -> "<block>"
end
@

The [[MakeLib]] functor is exported such that the Lua interpreter can be
linked together. The details how this exactly works are beyond me. 

<<block.ml>>=
module MakeLib (BlockV: Lua.Lib.TYPEVIEW with type 'a t = 'a T.t) =
struct
    type 'a combined = 'a BlockV.combined
    module M (C: Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
    struct
        module V = C.V
        let ( **-> ) = V.( **-> )
        <<export functions to Lua>>
    end (*M*)
end (*MakeLib*)
@

An interpreter should never fails with internal errors. Therefore we
have to wrap the [[cat]] and [[overlap]] function to check for possible
problems be fore we call them.

<<export functions to Lua>>=
let cat' g = function
    | [] -> C.error g "Block.cat: empty argument list"
    | bs -> cat_list bs

let overlap' g placement blocks = match (placement, blocks) with
    | _     , [] -> C.error g "Block.overlap: empty block list"
    | "high", bs -> overlap_list High bs
    | "low" , bs -> overlap_list Low  bs
    | _          -> C.error g "Block.overlap: 'high' or 'low' expected"
@    

The [[init]] function is called during the initialization phase of the
interpreter. It creates a new table [[Block]] and registers all
functions in there. 

<<export functions to Lua>>=
let init g =
    let block = BlockV.makemap V.userdata V.projection in
    C.register_module "Block"
        [ "size"       , V.efunc (block        **-> V.result V.int) size
        ; "alignment"  , V.efunc (block        **-> V.result V.int) alignment
        ; "adjust"     , V.efunc (block        **-> V.result block) adjust
        ; "cat"        , V.efunc (V.list block **-> V.result block) (cat' g)
        ; "overlap"    , V.efunc (V.string **-> V.list block 
                                           **-> V.result block) (overlap' g)
        ] g;
    Lua.Lib.StringList.empty    
        
@
