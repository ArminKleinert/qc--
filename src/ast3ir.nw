
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Translation to Intermediate Representation}
% ------------------------------------------------------------------ 

<<ast3ir.ml>>=
module Target   = Target2
module A        = Ast
module T        = Types
module E        = Error
module F        = Fenv.Clean
module StrMap   = Map.Make(struct type t=string let compare=compare end)

<<auxilliaries>>
<<ExprTypes>>

module Make
    (G:     Cfg3.S)
    (Asm:   Asm2.S with type instruction = G.t
                   with type init        = unit) = 
struct
    <<Make expressions>>
    <<Make constant evaluation>>
    <<Make auxilliaries>>
    <<Make continuation bundles>>
    <<Make assignment>>    
    <<Make global registers>>    
    <<Make formals and actuals>>    
    <<Make statements>>
    <<Make procedure>>
    <<Make memory declarations>>
    <<Make toplevel>>
    <<Make translate program>>
end
@

% ------------------------------------------------------------------
\subsection{Auxilliaries}
% ------------------------------------------------------------------ 

<<auxilliaries>>=
let default_cc          = "C--"
let default_space       = ('m':Rtl.space)
let default_section     = "text"

(* the @ is required by NOWEB and not part of the operator! *)
let (@<<) f g = fun x -> f (g x) (* function composition *)

(* val width : 'a T.t -> 'a *)
let width = function
    | T.Bits n -> n
    | _        -> Impossible.impossible "ast3ir.width"

(* val astty : F.env -> A.ty -> Types.ty *)
let rec astty env = function
    | A.TyAt(x,r)  -> astty env x
    | A.BitsTy(n)  -> Types.bits n
    | A.AliasTy(x) -> snd (F.findt x env)

(* val astwidth : F.env -> A.ty -> int *)
let astwidth env = width @<< (astty env) 

let foldl = List.fold_left
let foldr = List.fold_right
@

% ------------------------------------------------------------------ 
\subsection{Expression Types}
% ------------------------------------------------------------------ 

<<ExprTypes body>>=

let rec astFetch env target = function
    | A.LValueAt(x,r)   -> astFetch env target x
    | A.Var(hint,id)    -> (match F.findv id env with (attr,(_,t)) -> t)
    | A.Mem(ty,e,align) -> 
        let et = expr env target e      in
        let t  = astty env ty           in
        let a  = Aux.Option.get 1 align in
            t
@

The types for primitive operators are looked up in the [[Value]]
model.  This is a hack; we need a model for run-time primitive
operators. 

<<ExprTypes body>>=
and primOp env target op args =
    let argtys = List.map (expr env target) args     in
    let opty   = snd (Value.Ops.lookup op Value.ops) in (*XXX*)
        Types.appl opty argtys 
            
and expr env target exp =
    let word          = T.bits target.Target.wordsize in
    let optty default = function
        | None    -> default
        | Some t  -> astty env t       
    in match exp with
        | A.ExprAt(x,r)     -> expr env target x
        | A.Int   (_,ty)    -> optty word ty
        | A.Float (_,ty)    -> optty word ty
        | A.Char  (_,ty)    -> optty word ty
        | A.Fetch (v)       -> astFetch env target v
        | A.BinOp (l,op,r)  -> primOp env target op [l;r]
        | A.UnOp  (op,e)    -> primOp env target op [e]
        | A.PrimOp(op,args) -> primOp env target op (List.map snd args)


<<ExprTypes>>=
module ExprTypes = struct
    <<ExprTypes body>>
end
@

% ------------------------------------------------------------------ 
\subsection{Make}
% ------------------------------------------------------------------ 

<<Make auxilliaries>>=
let (++)           = Asm.append
let idwidth id env = match F.findv id env with (attr,(_,t)) -> width t
@


% ------------------------------------------------------------------ 
\subsection{Expression Translation}
% ------------------------------------------------------------------ 

Expressions denotes values, represented by compile-time, link-time, or
run-time values.  The translation of a variable depends on its
denotation. 

\begin{quote}\it
    \begin{enumerate}
        \item Translation of primitive operators needs fix.
        \item Translation of variables denoting stack labels missing.
    \end{enumerate} --CL
\end{quote}

Lookup for operations is a hack; we need a module for primitive
operators.

<<Make expressions>>=
let rec fetch env target globals = function
    | A.LValueAt(x,_) -> fetch env target globals x
    | A.Var(hint,x)   -> variable env target globals hint x
    | A.Mem(t,e,a)    -> 
        let width = astwidth env t in
        let cell  = 
            Rtl.cell
                (match a with None -> Rtl.none | Some n -> Rtl.aligned n)
                default_space  (* m *) 
                target.Target.byteorder
                width
                (expr env target globals e)
        in
            Rtl.fetch cell width     

(* XXX stack data labels don't work *)
            
and variable env target globals hint x =
    let (_,(denot,t)) = F.findv x env in
    ( match denot with
    | F.Constant(bits)  -> Rtl.bits bits (width t)
    | F.Label(F.Proc _) -> Rtl.link x (width t)
    | F.Label(F.Code)   -> Rtl.link x (width t)
    | F.Label(F.Data)   -> Rtl.link x (width t)
    | F.Import(None)    -> Rtl.link x (width t)
    | F.Import(Some n)  -> Rtl.link n (width t)
    | F.Continuation    -> Impossible.impossible "Ast3ir.Make.variable cont"
    | F.Label(F.Stack(o,l)) -> Impossible.unimp "Ast3ir.Make.variable stack"
    | F.Register({F.index=i;F.rhint=F.RReg(hw)}) ->
        (* global h/w register *)
        Rtl.fetch (target.Target.register hw) (width t) 
    | F.Register({F.index=i;F.rhint=_}) ->
        (* global or local register in memory, ignoring hint *)
        if F.is_localv x env then
            let w = width t in
            Rtl.fetch (Rtl.var x i w) w
        else (* global register in memory *)
            Automaton2.fetch (globals x) (width t)
    )
    
and prim env target globals op args =
    let argtys  = List.map (ExprTypes.expr env target) args in
    let opty    = snd (Value.Ops.lookup op Value.ops)      in (*XXX*)
    let widths  = Types.widthlist opty argtys               in
        Rtl.app (Rtl.opr op widths) (List.map (expr env target globals) args)

and expr env target globals exp = 
    let word = target.Target.wordsize in
    let const default_width = function
        | Some ty -> astwidth env ty
        | None    -> default_width
    in match exp with
        | A.ExprAt(x,_)     -> expr env target globals x
        | A.Int(bits,t)     -> Rtl.bits bits (const word t)
        | A.Float(bits,t)   -> Rtl.bits bits (const word t)
        | A.Char(bits,t)    -> Rtl.bits bits (const word t)
        | A.Fetch(v)        -> assert false
        | A.BinOp (l,op,r)  -> prim env target globals op [l;r]
        | A.UnOp  (op,e)    -> prim env target globals op [e]
        | A.PrimOp(op,args) -> prim env target globals op (List.map snd args)
@

% ------------------------------------------------------------------ 
\subsection{Constant Evaluation}
% ------------------------------------------------------------------ 

<<Make constant evaluation>>=
let compile_const env target exp =
    let lookup n = raise Consteval.Not_constant in   
        try 
            Consteval.compile (expr env target lookup exp)
        with 
            Consteval.Not_constant -> assert false (* we need a better way!*)
        
let link_const env target globals exp =
    Consteval.link (expr env target globals exp)
@


% ------------------------------------------------------------------ 
\subsection{Continuation Bundles}
% ------------------------------------------------------------------ 

<<Make continuation bundles>>=
let continuations ast cfg =
    let lookup = List.map (G.lookup cfg)  in
    let rec loop conts = function
        | (A.FlowAt(f,_)):: ff -> 
            loop conts (f::ff)
        | (A.CutsTo n)   :: ff -> 
            loop {conts with G.cuts    = lookup n @ conts.G.cuts   } ff
        | (A.UnwindsTo n):: ff -> 
            loop {conts with G.unwinds = lookup n @ conts.G.unwinds} ff
        | (A.ReturnsTo n):: ff -> 
            loop {conts with G.returns = lookup n @ conts.G.returns} ff
        | (A.Aborts)     :: ff -> 
            loop {conts with G.aborts   = true                     } ff 
        | []                   -> conts in
    let empty =
        { G.cuts = []; G.unwinds = []; G.returns = []; G.aborts = false
        } 
    in
        loop empty ast
@

% ------------------------------------------------------------------ 
\subsection{Assignment}
% ------------------------------------------------------------------ 

<<Make assignment>>=
let rec assign env target globals lhs exp = match lhs with
    | A.LValueAt(lhs,_) -> assign env target globals lhs exp
    | A.Var(hint,x) ->
        let (_,(denot,t)) = F.findv x env in
        let w = width t                   in
            ( match denot with
            | F.Register({F.index=i;F.rhint=F.RReg(hw)}) ->
                (* global h/w register *)
                Rtl.store (target.Target.register hw) exp w
            | F.Register({F.index=i;F.rhint=_}) ->
                (* global or local register in memory, ignoring hint *)
                if F.is_localv x env then
                    Rtl.store (Rtl.var x i w) exp w
                else (* global register in memory *)
                        Automaton2.store (globals x) exp w
            | _ -> assert false (* impossible *)
            )
    | A.Mem(t,addr,align) ->
        let w     = astwidth env t in
        let cell  = 
            Rtl.cell
                (match align with None -> Rtl.none | Some n -> Rtl.aligned n)
                default_space  (* m *) 
                target.Target.byteorder
                w
                (expr env target globals addr)                        
        in
            Rtl.store cell exp w
@

% ------------------------------------------------------------------
\subsection{Formal and Actual Parameters}
% ------------------------------------------------------------------ 

<<Make formals and actuals>>=
let actual env target globals (hint, e) =
    let w   = width (ExprTypes.expr env target e) in
    let exp = expr env target globals e           in
        (exp, w, hint) 
@

\begin{quote}\it
    As NR pointed out, hints on global registers have no semantics in 
    {\qcc}. They thus must be ignored when computing parameter
    passing. --CL
\end{quote} 

<<Make formals and actuals>>=
let formal env globals (khint, n) = 
    ( match snd (F.findv n env) with 
    | (F.Register {F.index=i},ty) when F.is_localv n env  -> 
        { G.repr  = G.Local (n,i)
        ; G.width = width ty
        ; G.hint  = khint  
        } 
    | (F.Register {F.index=i; F.rhint=h},ty) -> 
        { G.repr  = G.Global (globals n)
        ; G.width = width ty
        ; G.hint  = khint  
        } 
    | _ -> assert false
    )
@
    

% ------------------------------------------------------------------ 
\subsection{Global Registers}
% ------------------------------------------------------------------ 

The global registers of a {\PAL} program are assigned to hardware
register or memory locations using a target specific automaton.  Each
assignment results in an abstract [[Automaton2.loc]] value that is
entered under the name of the register to a map.  If a global register
declaration specifies a hardware register the register \emph{is not}
entered into said map.  Since the hardware register is part of the
declaration the [[Rtl.loc]] corresponding to the register can be
looked where it is used.
 
The [[globals]] function returns a map from registers to abstract
locations and the overflow area used to represent global registers.

<<Make global registers>>=
let globals target (base:Rtl.exp) decls =
    let atm = Automaton2.mk target.Target.globals base in
    let rec loop map = function
        | [] -> map
        | (name, F.RNone, t) :: rr -> (* no hint, no h/w register *)
            let loc = Automaton2.ty atm (width t) None  in
            let map = StrMap.add name loc map           in  
                loop map rr
        | (name, F.RHint h, t) :: rr -> (* hint, no h/w register *)
            let loc = Automaton2.ty atm (width t) (Some h)  in
            let map = StrMap.add name loc map               in
                loop map rr
        | (name, F.RReg _, t) :: rr -> (* hardware register - ignore *)
                loop map rr
    in
        loop StrMap.empty decls, Automaton2.freeze atm  

let lookup_global map x = 
    try StrMap.find x map
    with Not_found -> Impossible.impossible ("lookup_global "^x)
@


% ------------------------------------------------------------------ 
\subsection{Statements}
% ------------------------------------------------------------------ 

<<Make statements>>=
type state =
    { env:      F.env
    ; target:   Target.t
    ; globals:  string -> Automaton2.loc
    ; cfg:      G.t
    ; node:     G.node
    ; outbase:  Rtl.exp
    ; inbase:   Rtl.exp
    ; outgoing: Automaton2.area list
    ; incoming: Automaton2.area list
    }

let rec stmt s state = match s with
    | A.StmtAt(x,r)        -> stmt x state 
    | A.SpanStmt    x      -> spanStmt      state x
    | A.IfStmt      x      -> ifStmt        state x
    | A.SwitchStmt  x      -> switchStmt    state x
    | A.LabelStmt   x      -> labelStmt     state x
    | A.ContStmt    x      -> contStmt      state x
    | A.AssignStmt  x      -> assignStmt    state x
    | A.CallStmt    x      -> callStmt      state x
    | A.PrimStmt    x      -> primStmt      state x
    | A.GotoStmt    x      -> gotoStmt      state x
    | A.JumpStmt    x      -> jumpStmt      state x
    | A.CutStmt     x      -> cutStmt       state x
    | A.ReturnStmt  x      -> returnStmt    state x 
    | A.EmptyStmt          -> state     
    | A.CommentStmt _      -> state    

and body b state = match b with
    | A.BodyAt(x, _)        -> body x state
    | A.DeclBody(d)         -> state (*XXX*)
    | A.StmtBody(s)         -> stmt s state 
    | A.DataBody(dd)        -> state (*XXX*)
    

and labelStmt state x =
    let _   = G.set_label state.cfg x state.node in
        state    

and ifStmt state (e,ifso,ifnot) =
    let left  = foldr body ifso  state  in
    let right = foldr body ifnot left  in
    let exp   = expr state.env state.target state.globals e in
    let rtl   = state.target.Target.mkBranch exp in
        { right with node = 
          G.gm_branch state.cfg rtl left.node right.node
        }

and assignStmt state (lhs,rhs) =
    let effect lhs (guard,rhs) =
        let exp = expr   state.env state.target state.globals rhs     in
        let rtl = assign state.env state.target state.globals lhs exp in 
            ( match guard with
            | None   -> rtl
            | Some g -> Rtl.guard 
                            (expr state.env state.target state.globals g) rtl
            ) 
    in
    let rtl = Rtl.par (List.map2 effect lhs rhs) in
        { state with node = G.gm_assign state.cfg rtl state.node }
             
and gotoStmt state (e,labels) =
    let exp   = expr state.env state.target state.globals e  in
    let rtl   = state.target.Target.mkGoto exp               in
    let nodes = List.map (G.lookup state.cfg) labels         in
        {state with node = G.gm_goto state.cfg rtl nodes}

and jumpStmt state (cconv,e,args,labels) =
    let exp     = expr state.env state.target state.globals e    in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let atm     = Automaton2.mk cc.Target.proc state.outbase     in
    let rtl     = state.target.Target.mkJump exp                 in
    let args    = List.map 
                        (actual state.env state.target state.globals) args in
    let nodes   = List.map (G.lookup state.cfg) labels           in
    let rtl     = state.target.Target.mkJump exp                 in
    let jmp     = G.gm_jump state.cfg rtl nodes                  in
        if args = [] then (* no copyout nodes *)
            { state with node = jmp }
        else
            let node, atm =  G.gm_copyo state.cfg args atm jmp in
            { state with
                node     = node
            ;   outgoing = Automaton2.freeze atm :: state.outgoing
            }  
@

The copy-out code must honor the hints attached to the actual
parameters, the copy-in code the hints on the l-lvalues.  The
[[formal]] function translate these into a format suitable for the
automaton that guides the parameter passing.

<<Make statements>>=
and callStmt state (lhs,cconv, e, args, targets, conts) = 
    let rec lvalue = function
        | A.LValueAt(x,_) -> lvalue x
        | A.Var x         -> formal state.env state.globals x 
        | A.Mem _         -> assert false                        in
    let exp     = expr state.env state.target state.globals e    in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let atmo    = Automaton2.mk cc.Target.proc state.outbase   in
    let atmi    = Automaton2.mk cc.Target.ret  state.outbase   in
    let rtl     = state.target.Target.mkCall exp                 in
    let args    = List.map 
                  (actual state.env state.target state.globals) args in
    let nodes   = List.map (G.lookup state.cfg) targets          in
    let conts   = continuations conts state.cfg                  in
    let rtl     = state.target.Target.mkCall exp                 in
    (* linking nodes from back to front: copyin<-call<-copyout *) 
    let copyi,atmi = G.gm_copyi state.cfg 
                        (List.map lvalue lhs) atmi state.node    in
    let call       = G.gm_call state.cfg rtl conts copyi in
    let copyo,atmo = G.gm_copyo state.cfg args atmo call in
        { state with
            node     = copyo
        ;   outgoing = Automaton2.freeze atmo :: state.outgoing
        ;   incoming = Automaton2.freeze atmi :: state.incoming
        }  

and returnStmt state (cconv, kont, args) =
    let const e   = Bits.to_int (compile_const state.env state.target e)     in
    let cc        = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let atm       = Automaton2.mk cc.Target.ret state.inbase                 in
    let (x,y)     = match kont with
                    | None       -> (0,0) (* default *)
                    | Some (x,y) -> (const x, const y) in
    let rtl       = cc.Target.return                                         in
    let args      = List.map
                    (actual state.env state.target state.globals) args       in
    let ret       = G.gm_return state.cfg rtl (x, y)   in
    let copyo,atm = G.gm_copyo state.cfg args atm ret                        in
        { state with
            node     = ret
        ;   outgoing = Automaton2.freeze atm :: state.outgoing
        }

(*
 * args = [(hint option,name)]
 * 
 * We have two sources for hints: register declartion AND formal
 * parameters for continuations. Which one should be used/ignored?
 * If there is a problem it must be also corrected in the Eval module.
 *)

and contStmt state (label,args)  =
    let cc        = state.target.Target.cc default_cc               in
    let args      = List.map (formal state.env state.globals) args in
    let atm       = Automaton2.mk cc.Target.cont state.inbase       in
    let copyi,atm = G.gm_copyi state.cfg args atm state.node        in
    let _         = G.set_label state.cfg label copyi               in
        { state with
            node     = copyi
        ;   incoming = Automaton2.freeze atm :: state.incoming
        }

and cutStmt state (e, args, conts) = 
    let cc        = state.target.Target.cc default_cc                  in
    let args      = List.map 
                    (actual state.env state.target state.globals) args in
    let atm       = Automaton2.mk cc.Target.cont state.outbase         in
    let exp       = expr state.env state.target state.globals e        in
    let rtl       = state.target.Target.mkCutto exp                    in
    let conts     = continuations conts state.cfg                      in
    let cut       = G.gm_cutto state.cfg rtl conts                     in
    let copyo,atm = G.gm_copyo state.cfg args atm cut                  in
        { state with
            node     = cut
        ;   incoming = Automaton2.freeze atm :: state.outgoing
        }

and primStmt      state x  = Impossible.unimp "primitive"
and spanStmt      state x  = Impossible.unimp "span"
and switchStmt    state x  = Impossible.unimp "switch"
@

% ------------------------------------------------------------------ 
\subsection{Procedure Translation}
% ------------------------------------------------------------------ 

<<Make procedure>>=
let proc env target globals (*props*) asm (cconv,name,args,bdy) = 
assert false
@
   
% ------------------------------------------------------------------ 
\subsection{Global Memory declarations}
% ------------------------------------------------------------------ 

<<Make memory declarations>>=
(*XXX*)
let initialized_data asm expr = 
    Impossible.unimp "initialized data in global memory declaration"

(*XXX*)    
let rec init env target asm = function
    | A.InitAt(x,_)   -> init env target asm x
    | A.InitExprs(es) -> foldl initialized_data asm es
    | A.InitStr(s)    -> Impossible.unimp "initialized data in global memory declaration"
    | A.InitUStr(s)   -> Impossible.unimp "initialized data in global memory declaration"
@

In order to reserve memory for data we have to know how many objects
an sequence of initializing expressions defined. This number is
returned by [[init_size]].

<<Make memory declarations>>=
let rec init_size = function
    | None   -> 1
    | Some i -> let rec loop = function 
                    | A.InitAt(x,_)   -> loop x
                    | A.InitExprs(es) -> List.length es
                    | A.InitStr(s)    -> assert false
                    | A.InitUStr(s)   -> assert false
                in 
                    loop i 
@

Data can be declared initialized or un-initialized. The amount of
memory used by a declaration is the size of the base-type times the
number of values of this type. 

<<Make memory declarations>>=
let memdecl (env:F.env) target asm t size ini = 
    let sizeof  = astwidth env t / target.Target.memsize          in
    let const e = Bits.to_int (compile_const env target e)     in
    let n      = ( match size with
                 | A.DynSize    -> init_size ini
                 | A.NoSize     -> 1
                 | A.FixSize(e) -> const e
                 ) in
        ( match ini with
        | None    -> asm ++ Asm.zeroes (n * sizeof)
        | Some ii -> init env target asm ii
        )
@

Data can be declared globally inside a section or a section-level
[[span]] and locally, inside a procedure as [[stackdata]].  The former
is directly translated into assembly action that reserve memory inside
a section, the latter becomes just an amount of memory that is
allocated inside a procedure's activation record.  Since the amount of
stack allocated data and the offsets associated with labels inside of
it are already entered into the fat environment (by
[[Elab.Check.stackdatum]]), stack data declaration can be ignored. 
Global data declarations, on the other hand, must be translated to
assembly actions.
 
<<Make memory declarations>>=
let rec datum env target asm = function
    | A.DatumAt(x,_)        -> datum env target asm x
    | A.Label(n)            -> asm ++ Asm.define_local (Asm.mksym n)
    | A.Align(a)            -> asm ++ Asm.align a 
    | A.MemDecl(t,m,init)   -> memdecl env target asm t m init
@
    
% ------------------------------------------------------------------ 
\subsection{Toplevel}
% ------------------------------------------------------------------ 

All global declarations have been processed at this stage and thus can
be ignored.  The only exception are (global) register declarations. 
Global registers can name a hardware register they are placed in.  We
need ia way to record such an assignment.  All other locations for
global registers are determined by an automaton, see module
\module{callconv}. 

A [[span]] on the section level must be pushed to the statement level: 
when we come across a [[span]] we modify the properties [[props]]
accordingly.  The next time we come across a procedure, the properties
including the span will be used.

<<Make toplevel>>=
let rec sspan env target globals asm (e1,e2,ss) =    
    let key   = compile_const env target e1 in
    let value = link_const    env target globals e2 in
    (* construct props value, pass it to section. not implemented *)
        foldl (section env target globals) asm ss 

<<Make toplevel>>=
and section env target globals (asm: Asm.asm) = function
    | A.SectionAt(x,_)     -> section env target globals asm x
    | A.Decl(d)            -> asm
    | A.Datum( d)          -> datum   env target         asm d
    | A.Procedure(p)       -> proc    env target globals asm p
    | A.SSpan ss           -> sspan   env target globals asm ss
@            

What to do with top-level procedures? They should go into some section
because otherwise they will end up in whatever section is currently
active which just seems wrong.

<<Make toplevel>>=
let rec toplevel env target globals asm = function
    | A.ToplevelAt(x, _)  -> toplevel env target globals asm x
    | A.Section(name, ss) -> 
        let asm = asm ++ Asm.section name in  
            foldl (section env target globals (*props*)) asm ss
    | A.TopDecl(d)        -> asm (* nothing to do here *)
    | A.TopProcedure(p)   -> let asm = asm ++ Asm.section default_section  
                             in proc env target globals (*props*) asm p
@


% ------------------------------------------------------------------ 
\subsubsection{Program}
% ------------------------------------------------------------------ 

Imports and exports of assembly symbols are announced once at the top
of the assembly program.  The sets of imported and exported symbols
are registered in the fat environment.  For details, see modules
\module{mangle}, and \module{elab}. 

<<Make translate program>>=
let exports env asm = 
    Fenv.StrSet.fold (fun s asm -> asm ++ Asm.export (Asm.mksym s)) 
    (F.exported env) asm

let imports env asm =
    Fenv.StrSet.fold (fun s asm -> asm ++ Asm.import (Asm.mksym s)) 
    (F.imported env) asm
@

The assembler maintains a current section. To guarantee that
everything goes into a meaningful section, the first action is to
start the [[text]] section.


<<Make translate program>>=
let program env target globals asm tt = 
    let asm = asm ++ Asm.section "text"           in
    let asm = exports env asm                     in
    let asm = imports env asm                     in
        foldl (toplevel env target globals) asm tt

let translate env target prog =
    let base     = Rtl.link "global_base" target.Target.pointersize in (*XXX*)
    let map,area = globals target base (F.regdecls env) in
    let lookup   = lookup_global map in
    let asm      = Asm.init () in
        ( lookup
        , program env target lookup asm prog  (* asm *)
        )
@    
