
\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h substitution gets <-
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% Table of Contents
% egrep '^\\(sub)*section' ast3ir.nw 
%
% \section{Translation to Intermediate Representation}
% \subsection{Implementation}
% \subsection{Auxilliaries}
% \subsection{Expression Types}
% \subsection{Expression Translation}
% \subsection{Constant Evaluation}
% \subsection{Auxilliaries for Make}
% \subsection{Continuation Bundles}
% \subsection{Assignment}
% \subsection{Formal and Actual Parameters}
% \subsection{Global Registers}
% \subsection{Statements}
% \subsection{Procedure Translation}
% \subsection{Global Memory declarations}
% \subsection{Stack Data Declarations}
% \subsection{Toplevel}
% \subsubsection{Program}




% ------------------------------------------------------------------ 
\section{Translation to Intermediate Representation}
% ------------------------------------------------------------------ 

The [[translate]] function takes an environment, the actual target and
a program and translates it into an abstract assembler program.  The
assembler is functorized over the data type of instructions. This module
puts a whole procedure body into a single instruction by basically
treating a control-flow graph as an instruction. 

<<ASM>>=
Asm2.S with type instruction = Proc.t
       and  type init        = unit
@


<<ast3ir.mli>>=
module Make (A: <<ASM>>) : sig
    val translate: Fenv.Clean.env -> Target2.t 
                                  -> Ast.program 
                                  -> A.asm
end
@

% ------------------------------------------------------------------ 
\subsection{Name Mangling}
% ------------------------------------------------------------------ 

The assembler we emit code for has certain rules for its names. It
andvertises these rules in its [[A.mangle]] symbol. Names that are
passed to the assembler are therefore first mangled with a function that
was build with the help of [[A.mangle]]. The names that are created
inside control-flow graphs are \emph{not} mangled upon creation. But
each instruction includes the mangler function such that at any later
time when instructions are passed to the assember the right mangler can
be used to mangle the names. To summaraize: names passed to the
assembler are mangled, names part of instructions are not mangled, but
the instruction includes a mangler to do so later as needed.


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<ast3ir.ml>>=
module Target   = Target2
module A        = Ast
module T        = Types
module E        = Error
module F        = Fenv.Clean

<<auxilliaries>>
<<ExprTypes>>
module Make (Asm: <<ASM>>) = 
struct
    module G  = Cfg3 
    module IO = Copyinout.Make(G)

    <<Make expressions>>
    <<Make constant evaluation>>
    <<Make auxilliaries>>
    <<Make continuation bundles>>
    <<Make assignment>>    
    <<Make global registers>>    
    <<Make formals and actuals>>    
    <<Make statements>>
    <<Make stack data declarations>>
    <<Make procedure>>
    <<Make memory declarations>>
    <<Make toplevel>>
    <<Make translate program>>
end
@

% ------------------------------------------------------------------
\subsection{Auxilliaries}
% ------------------------------------------------------------------ 

<<auxilliaries>>=
let default_cc          = "C--"
let default_space       = ('m':Rtl.space)
let default_section     = "text"

(* the @ is required by NOWEB and not part of the operator! *)
let (@<<) f g = fun x -> f (g x) (* function composition *)

(* val width : 'a T.t -> 'a *)
let width = function
    | T.Bits n -> n
    | _        -> Impossible.impossible "ast3ir.width"

(* val astty : F.env -> A.ty -> Types.ty *)
let rec astty env = function
    | A.TyAt(x,r)  -> astty env x
    | A.BitsTy(n)  -> Types.bits n
    | A.AliasTy(x) -> snd (F.findt x env)

(* val astwidth : F.env -> A.ty -> int *)
let astwidth env = width @<< (astty env) 

let foldl = List.fold_left
let foldr = List.fold_right
@


% ------------------------------------------------------------------ 
\subsection{Expression Types}
% ------------------------------------------------------------------ 

We use the generic [[Expcheck]] module to find an expression's type.
Values from the environment are always [[Ok]] because at this stage we
have a clean environment.

<<ExprTypes>>=
    let exprtype env target exp =
        let word      = Error.Ok(Types.bits target.Target.wordsize)    in
        let pointer   = Error.Ok(Types.bits target.Target.pointersize) in
        let tlookup   = fun x -> Error.Ok(snd (F.findt x env))         in
        let vlookup   = fun x -> Error.Ok( match (F.findv x env) with
                                         | (_,(_,t)) -> t 
                                         ) in
        let e = { Expcheck.wordsize    = word
                ; Expcheck.pointersize = pointer
                ; Expcheck.tlookup     = tlookup
                ; Expcheck.vlookup     = vlookup
                } 
        in try ( match Expcheck.check e exp with
               | Error.Ok(t) -> t
               | Error.Error -> assert false
               )
           with Error.ErrorExn msg -> assert false
@




% ------------------------------------------------------------------ 
\subsection{Expression Translation}
% ------------------------------------------------------------------ 

Expressions denotes values, represented by compile-time, link-time, or
run-time values.  The translation of a variable depends on its
denotation. 

Lookup for operations is a hack; we need a module for primitive
operators. We should also evaluate constant expressions as far as
possible. Module \module{rtleval} does this for link-time
expressions and could possibly extended.

<<Make expressions>>=
let rec fetch env target = function
    | A.LValueAt(x,_) -> fetch env target x
    | A.Var(hint,x)   -> variable env target hint x
    | A.Mem(t,e,a)    -> 
        let width = astwidth env t in
        let cell  = 
            Rtl.cell
                (match a with None -> Rtl.none | Some n -> Rtl.aligned n)
                default_space  (* m *) 
                target.Target.byteorder
                width
                (expr env target e)
        in
            Rtl.fetch cell width     
@

A continuation has two labels: one for its code ([[x]]), and one that is
used as its value ([[label]]). The label is later re-written to a
pointer expression that denotes a pair of values in the activation
record. The label is part of the continuation's denotation.

<<Make expressions>>=
and variable env target hint x =
    let (_,(denot,t)) = F.findv x env in
    ( match denot with
    | F.Constant(bits)  -> Rtl.bits bits (width t)
    | F.Label(F.Proc _) -> Rtl.link x (width t)
    | F.Label(F.Code)   -> Rtl.link x (width t)
    | F.Label(F.Data  ) -> Rtl.link x (width t)
    | F.Import(None)    -> Rtl.link x (width t)
    | F.Import(Some n)  -> Rtl.link n (width t)
    | F.Continuation label  -> Rtl.link label (width t)
    | F.Label(F.Stack(None))  -> Impossible.impossible "Ast3ir.Make.variable"
    | F.Label(F.Stack(Some loc)) ->
        let w    = width t                                   in 
        let agg  = target.Target.byteorder                   in
        let cell = Rtl.cell Rtl.none default_space agg w loc in
            Rtl.fetch cell (width t)

    
    | F.Register({F.loc=Some l}) -> Automaton.fetch l (width t)
    | F.Register({F.index=i;F.loc=None}) ->
        (* local register in memory, ignoring hint *)
        if F.is_localv x env then
            let w = width t in
            Rtl.fetch (Rtl.var x i w) w
        else (* global register without location *)
            Impossible.impossible "Ast3ir.Make.variable"
    )
@

\begin{quote}\it
    Since evaluation and type-checking are separated, types in nested
    expressions are checked multiple times. This introduces a
    quadratic complexity. The only way to avoid this, as far as I can
    see, is a combined bottom-up evaluation and type checking. --CL
\end{quote}
    
    
<<Make expressions>>=
and prim env target op args =
    let argtys  = List.map (exprtype env target) args in
    let _,opr   = Rtlop.Translate.operator op argtys   in
        Rtl.app opr (List.map (expr env target) args)

and expr env target exp = 
    let word = target.Target.wordsize in
    let const default_width = function
        | Some ty -> astwidth env ty
        | None    -> default_width
    in match exp with
        | A.ExprAt(x,_)     -> expr env target x
        | A.Int(bits,t)     -> Rtl.bits bits (const word t)
        | A.Float(bits,t)   -> Rtl.bits bits (const word t)
        | A.Char(bits,t)    -> Rtl.bits bits (const word t)
        | A.Fetch(v)        -> fetch env target v
        | A.BinOp (l,op,r)  -> prim env target op [l;r]
        | A.UnOp  (op,e)    -> prim env target op [e]
        | A.PrimOp(op,args) -> prim env target op (List.map snd args)
@

% ------------------------------------------------------------------ 
\subsection{Constant Evaluation}
% ------------------------------------------------------------------ 

We translate constants  to {\rtl} expressions which then evaluate.

<<Make constant evaluation>>=
module Eval = Rtleval.Make(Asm.RelAddr)

let compile_const env target exp = Eval.compile (expr env target exp)
let link_const    env target exp = Eval.link    (expr env target exp)
@

% ------------------------------------------------------------------ 
\subsection{Auxilliaries for Make}
% ------------------------------------------------------------------ 


<<Make auxilliaries>>=
let (++)           = Asm.append
let idwidth id env = match F.findv id env with (attr,(_,t)) -> width t
@

% ------------------------------------------------------------------ 
\subsection{Continuation Bundles}
% ------------------------------------------------------------------ 

A continuation bundle on the {\AST} level is a record of names, and an
asbtract type at the {\cfg} level.  The continuations function
translates from the former to the latter.

<<Make continuation bundles>>=
type conts =    { cuts    : G.node list
                ; unwinds : G.node list
                ; returns : G.node list
                ; aborts  : bool
                }

let continuations ast cfg =
    let lookup = List.map (G.lookup cfg)  in
    let rec loop conts = function
        | (A.FlowAt(f,_)):: ff -> 
            loop conts (f::ff)
        | (A.CutsTo n)   :: ff -> 
            loop {conts with cuts    = lookup n @ conts.cuts   } ff
        | (A.UnwindsTo n):: ff -> 
            loop {conts with unwinds = lookup n @ conts.unwinds} ff
        | (A.ReturnsTo n):: ff -> 
            loop {conts with returns = lookup n @ conts.returns} ff
        | (A.Aborts)     :: ff -> 
            loop {conts with aborts  = true                     } ff 
        | []                   -> conts in
    let empty = { cuts = []; unwinds = []; returns = [] ; aborts = false } in
    let conts = loop empty ast in
        G.conts conts.cuts conts.unwinds conts.returns conts.aborts
@

% ------------------------------------------------------------------ 
\subsection{Assignment}
% ------------------------------------------------------------------ 

The left hand side of a simple assignment $x \gets y$ can be a memory
cell, or a register which in turn can be local or global.  Each case
requires its own method to compute the {\rtl} that represents the
assignment.

<<Make assignment>>=
let rec assign env target lhs exp = match lhs with
    | A.LValueAt(lhs,_) -> assign env target lhs exp
    | A.Var(hint,x) ->
        let (_,(denot,t)) = F.findv x env in
        let w = width t                   in
            ( match denot with
            | F.Register({F.loc=Some l}) -> Automaton.store l exp w
            | F.Register({F.index=i;F.loc=None}) ->
                if F.is_localv x env then
                    Rtl.store (Rtl.var x i w) exp w
                else 
                    Impossible.impossible "Ast3ir.Make.assign"
            | _ -> assert false (* impossible *)
            )
    | A.Mem(t,addr,align) ->
        let w     = astwidth env t in
        let cell  = 
            Rtl.cell
                (match align with None -> Rtl.none | Some n -> Rtl.aligned n)
                default_space  (* m *) 
                target.Target.byteorder
                w
                (expr env target addr)                        
        in
            Rtl.store cell exp w
@

% ------------------------------------------------------------------
\subsection{Formal and Actual Parameters}
% ------------------------------------------------------------------ 

An actual parameter is an expression and must be translated to the
format expected by the [[IO.copyout]] function.  A formal procedure
parameter denotes a local variable, a formal continuation parameter
either a local or \emph{global} variable.  Both are translated to the
format expected by the [[IO.copyin]] function.

<<Make formals and actuals>>=
let actual env target (hint, e) =
    let w   = width (exprtype env target e) in
    let exp = expr env target e           in
        (exp, w, hint) 
@

\begin{quote}\it
    As NR pointed out, hints on global registers have no semantics in 
    {\qcc}. They thus must be ignored when computing parameter
    passing. --CL
\end{quote} 

<<Make formals and actuals>>=
let formal env (khint, n) = (* for continuations *)
    ( match snd (F.findv n env) with 
    | (F.Register {F.index=i;F.loc=None},ty) when F.is_localv n env  -> 
        { IO.repr  = IO.Local (n,i)
        ; IO.width = width ty
        ; IO.hint  = khint  
        } 
    | (F.Register {F.loc=Some l},ty) -> 
        { IO.repr  = IO.Global (l)
        ; IO.width = width ty
        ; IO.hint  = khint  
        } 
    | _ -> assert false
    )

let procformal env (hint, inv, ty, name) = 
    ( match snd (F.findv name env) with 
    | (F.Register {F.index=i;F.loc=None},ty) -> 
        { IO.repr  = IO.Local (name,i)
        ; IO.width = width ty
        ; IO.hint  = hint  
        } 
    | _ -> assert false
    )
@
    

% ------------------------------------------------------------------ 
\subsection{Global Registers}
% ------------------------------------------------------------------ 

The global registers of a {\PAL} program are assigned to hardware
register or memory locations using a target specific automaton.  Each
assignment results in an abstract [[Automaton.loc]] value that is
entered under the name of the register to a map.
 
The [[globals]] function pushes all global registers through a target
specific automaton to obtain locations for each of them.  A location
is added to a register's denoation in the environment.  The updated
environment plus the area of memory that hold global registers.

When different compilation units are linked together they all must
declare exactly the same global registers. We compute a cryptographic
hash value for all global register declarations as a finger print. The
finger print is a string of 16 characters which are not guaranteed to be
printable.

<<Make global registers>>=
let globals env target (base:Rtl.exp) names =
    let t = Automaton.mk target.Target.globals base in
    let decls = Buffer.create 128 in (* initial size - grows as needed *)
    let rec assign env n =
        try 
            ( match F.findv n env with
            | (rgn,(F.Register(reg),ty)) ->
                let h,h'  = match reg.F.rhint with
                            | F.RReg x -> Some x, x     (* h/w register *)
                            | _        -> None  , "" in
                let w     = width ty in
                (* sig is string representation of this declaration *)
                let sign  = Printf.sprintf "[%d <%s>]" w h' in
                let ()    = Buffer.add_string decls sign    in
                let loc   = Automaton.ty t w h in
                let entry = ( rgn
                            , (F.Register({reg with F.loc = Some loc}),ty)
                            ) in F.rebindv n entry env
            | _ -> Impossible.impossible "Ast3ir.Make.globals"
            )
        with Error.ErrorExn msg -> Impossible.impossible msg
    in
    let env = List.fold_left assign env names in
        env, Automaton.freeze t, Digest.string (Buffer.contents decls)    
@


% ------------------------------------------------------------------ 
\subsection{Statements}
% ------------------------------------------------------------------ 

The translation of statements in a procedure body requires a bunch of
value that are passed as a functional [[state]] value around. Using
\ocaml's functional record update this allows to add more informations
as needed without breaking any code.

<<Make statements>>=
type state =
    { proc:         string           (* proc under translation (const) *)
    ; env:          F.env            (* fat environment        (const) *)
    ; target:       Target.t         (* current target         (const) *)
    ; cfg:          G.t              (* CFG under construction (const) *)
    ; node:         G.node           (* node following current unit    *)   
    ; outbase:      Rtl.exp          (* addr of OUTGOING area          *)   
    ; inbase:       Rtl.exp          (* addr of INCOMING ares          *)
    ; outgoing:     Area.t list      (* areas to be overlayed in OUTGOING *)   
    ; incoming:     Area.t list      (* ditto for INCOMING *)
    ; conts:        string list      (* local continuations *)    
    }
@
    
\begin{itemize}
\item [[proc]] is the name of the procedure under translation. The
      name is used to generate labels with the name inside. Constant.
\item [[env]] is the fat environment to resolve the meaning of names.
      Constant. 
\item [[target]] is the current target architecture. This provides
      target-specific pointer sizes, {\rtl}s and so forth. Constant.
\item [[cfg]] is the control-flow graph under construction. It
      represents the body of the procedure. Constant.
\item [[node]] is the node in the {\cfg} following the current unit
      under translation.
\item [[outbase]] is the run-time expression for the base-address of
      the \emph{outgoing} area on the stack. See also \module{stack}.
\item [[inbase]] is the run-time expression for the base-address of the
      \emph{incoming} area.
\item [[outgoing]] contains areas of disjoint lifetimes that are overlaid
      in the \emph{outgoing} area.
\item [[incoming]] overlaid areas in the \emph{incoming} area.        
\end{itemize}

It is important that all areas in the [[outgoing]] list have a base
address that is related to [[outbase]], and analogously for [[incoming]]
and [[inbase]]. Otherwise the equations (c.f.~modules \module{eqn},
\module{const}) that are generated when area are arranged to form an
activation record won't be solvable.


<<Make statements>>=
let rec stmt s state = match s with
    | A.StmtAt(x,r)        -> stmt x state 
    | A.SpanStmt    x      -> spanStmt      state x
    | A.IfStmt      x      -> ifStmt        state x
    | A.SwitchStmt  x      -> switchStmt    state x
    | A.LabelStmt   x      -> labelStmt     state x
    | A.ContStmt    x      -> contStmt      state x
    | A.AssignStmt  x      -> assignStmt    state x
    | A.CallStmt    x      -> callStmt      state x
    | A.PrimStmt    x      -> primStmt      state x
    | A.GotoStmt    x      -> gotoStmt      state x
    | A.JumpStmt    x      -> jumpStmt      state x
    | A.CutStmt     x      -> cutStmt       state x
    | A.ReturnStmt  x      -> returnStmt    state x 
    | A.EmptyStmt          -> state     
    | A.CommentStmt _      -> state    

and body b state = match b with
    | A.BodyAt(x, _)        -> body x state
    | A.DeclBody(d)         -> state (* nothing to be done *)
    | A.StmtBody(s)         -> stmt s state 
    | A.DataBody(dd)        -> state (* already done *)
    

and labelStmt state x =
    { state with node = G.set_label state.cfg x state.node }
@

An if-statement is translated into a seqence of nodes such that the
two branches are linearized.  The branch is taken is the governing
expression is evaluated to [[false]].  The fall-through-branch is
taken otherwise and ends with a [[goto]] around the other branch. 

\begin{enumerate}
\item A branch node holding the governing expression and a label [[l1]].
      If the expression evaluates to true at run-time, the branch is taken
      to [[l1]]. Otherwise the branch falls trough.
\item Nodes for the [[ifnot]] branch of the statement.
\item A jump to label [[l2]].
\item A label [[l1]] that marks the entry to the node for the [[ifso]] branch.
\item Nodes for the [[ifso]] branch.
\item A label [[l2]] in front of the code following the [[if]] statement. 
\end{enumerate}

<<Make statements>>=
and ifStmt state (e,ifso,ifnot) =
    let l_ifso = Idgen.label state.proc in (* label for ifso/left *)
    let l_join = Idgen.label state.proc in (* label for join *)
    let state  = { state with (* label join *)
                   node = G.set_label state.cfg l_join state.node } in  
    let ifso   = foldr body ifso state  in
    let state  = { state with (* label ifso *)
                   node = G.set_label state.cfg l_ifso ifso.node  } in 
    
    let l2exp  = Rtl.link l_join state.target.Target.pointersize in
    let l2rtl  = state.target.Target.goto.Target.embed l2exp in
    let l2goto = G.gm_goto state.cfg l2rtl [G.lookup state.cfg l_join] in
    let ifnot  = foldr body ifnot {ifso with node = l2goto} in
    let exp    = expr state.env state.target e in
    let link   = Rtl.link l_ifso state.target.Target.pointersize in
    let rtl    = state.target.Target.branch.Target.embed (exp,link)  in
        { ifnot with node = 
          G.gm_branch state.cfg rtl ifso.node ifnot.node
        }

and assignStmt state (lhs,rhs) =
    let effect lhs (guard,rhs) =
        let exp = expr   state.env state.target rhs     in
        let rtl = assign state.env state.target lhs exp in 
            ( match guard with
            | None   -> rtl
            | Some g -> Rtl.guard 
                            (expr state.env state.target g) rtl
            ) 
    in
    let rtl = Rtl.par (List.map2 effect lhs rhs) in
        { state with node = G.gm_assign state.cfg rtl state.node }
             
and gotoStmt state (e,labels) =
    let exp   = expr state.env state.target e  in
    let rtl   = state.target.Target.goto.Target.embed exp    in
    let nodes = List.map (G.lookup state.cfg) labels         in
        {state with node = G.gm_goto state.cfg rtl nodes}
@
        
The overflowing outgoing parameters passed by a tail-call go into the
\emph{incoming} area of the current activation, but the \emph{copyout}
mechanism is used. 

\begin{quote}\it
    I believe the [[labels]] for jump targets should not be translated
    into nodes because they do not belong to the current procedure. --CL
\end{quote}

<<Make statements>>=
and jumpStmt state (cconv,e,args,labels) = 
    let exp     = expr state.env state.target e    in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let args    = List.map (actual state.env state.target) args in
    let rtl     = state.target.Target.jump.Target.embed exp      in
    let jmp     = G.gm_jump state.cfg rtl labels                 in
        if args = [] then (* no copyout nodes *)
            { state with node = jmp }
        else
            let node,area,defs = IO.copyout state.cfg args cc.Target.proc 
                                       state.inbase jmp in
            let result = 
                { state with node     = node
                ;            incoming = area :: state.incoming
                } in 
            let () = G.gm_insert_dataflow_between
		  ~defs:Register.Set.empty ~uses:defs ~kills:Register.Set.empty
		  ~src:jmp ~dst:(G.exit(state.cfg)) in
                result
@


%% \begin{quote}\small
%% \begin{verbatim}
%% 
%%             /   |
%%             |   o  r0 = x  
%%  copy-out:  |   |                      
%%  defs r0,r1 |   o  r1 = y 
%%             \   |
%%              ------
%%             | call | x = f(x,y) call: kills y, ... 
%%            ///-----
%%           ///   |
%%          ///    o               data-flow: uses r0, r1; defs x 
%%  continuations  |
%%                 o  x = r0       copy-in:   uses r0
%%                 |
%%                         
%% \end{verbatim}
%% \end{quote}

\begin{figure}
\centerline{\includegraphics[width=\hsize]{../figures/callstmt}}
\caption{\label{fig:ast3ir:call} Principle translation of a call
statement. A data-flow node expresses inter-procedural data-flow.}
\end{figure}

\begin{quote}\it
    We need data-flow-edges for the conintuations, too. --CL
\end{quote}

<<Make statements>>=
and callStmt state (lhs,cconv, e, args, targets (*unused*), conts) = 
    let rec lvalue = function
        | A.LValueAt(x,_) -> lvalue x
        | A.Var x         -> formal state.env x 
        | A.Mem _         -> assert false                        in
    let exp     = expr state.env state.target e    in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let rtl     = state.target.Target.call.Target.embed exp   in
    let args    = List.map (actual state.env state.target) args  in
    let conts   = continuations conts state.cfg                  in
    let rtl     = state.target.Target.call.Target.embed exp      in
    (* linking nodes from back to front: copyin<-call<-copyout *) 
    let copyi,areai,uses = IO.copyin state.cfg (List.map lvalue lhs) 
                      cc.Target.ret state.inbase  state.node  in
    let call        = G.gm_call  state.cfg rtl conts copyi in
    let copyo,areao,defs = IO.copyout state.cfg args 
                      cc.Target.proc state.outbase call in
    let result = { state with
                     node     = copyo
                 ;   outgoing = areao :: state.outgoing
                 ;   incoming = areai :: state.incoming
                 } in
    (* fix data-flow *)
    let () = G.gm_insert_dataflow_between 
            ~defs:uses ~uses:defs ~kills:Register.Set.empty
            ~src:call ~dst:copyi in 
        result        
@

A procedure returns value in the \emph{incoming} area of its
activation but uses the \emph{copy-out} method.  Don't get confused
and refer to the big picture in \module{stack}. 

\begin{quote}\it
    Does the {\rtl} used for the return depend on $(x,y)$. I believe
    so and this means the [[Target]] interface should be changed. --CL
\end{quote}

<<Make statements>>=
and returnStmt state (cconv, kont, args) = 
    let const e = Bits.to_int (compile_const state.env state.target e)     in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let (x,y)   = match kont with
                  | None       -> (0,0) (* default *)
                  | Some (x,y) -> (const x, const y) in
    let rtl     = cc.Target.return                                         in
    let args    = List.map
                  (actual state.env state.target) args       in
    let ret     = G.gm_return state.cfg rtl (x, y)   in
    let copy, area, defs =
                  IO.copyout state.cfg args cc.Target.ret state.inbase ret in
    let result  = {state with node = copy; incoming = area :: state.incoming}in
		  (* fix data-flow *)
    let ()      = G.gm_insert_dataflow_between
		  ~defs:Register.Set.empty ~uses:defs ~kills:Register.Set.empty
		  ~src:ret ~dst:(G.exit(state.cfg)) in
	result
	
@

A continuation receives its parameters in the \emph{incoming} area of
its activation. For the moment we assume that all continuations escape
and collect them in [[state.conts]]. Therefore we simply add the
[[label]] of this continuation to the list.

<<Make statements>>=
and contStmt state (label,args)  = 
    let cc      = state.target.Target.cc default_cc              in
    let args    = List.map (formal state.env) args in
    let atm     = Automaton.mk cc.Target.cont state.inbase       in
    let copy,area,uses = IO.copyin state.cfg args 
                  cc.Target.cont state.inbase state.node in
    let copy    = G.set_label state.cfg label copy               in
    let result  = { state with
                    node     = copy
                  ; incoming = area :: state.incoming
                  ; conts    = label :: state.conts
                  } in
        result
@

\begin{quote}\it
    The implementation of cutto currently lacks all details to find the
    activation for the continuation and thus the \emph{incoming} area
    in that activations. This is where the [[cut to]] statement puts
    the \emph{outgoing} overflow parameters. Some abstraction for a
    continuation's runt-time representation, similar to
    [[Automaton.loc]] might be appropriate. --CL
\end{quote}

<<Make statements>>=
and cutStmt state (e, args, conts) = 
    let cc        = state.target.Target.cc default_cc                  in
    let args      = List.map 
                    (actual state.env state.target) args in
    let exp       = expr state.env state.target e        in
    let rtl       = state.target.Target.cutto.Target.embed exp (*XXX*) in
    let conts     = continuations conts state.cfg                      in
    let cut       = G.gm_cutto state.cfg rtl conts                     in
    let copy,area,defs = IO.copyout (* XXX *)
                        state.cfg args cc.Target.cont state.inbase cut  in
    let result    =    { state with node     = cut
                       ;            incoming = area :: state.incoming
                       } in
    let ()      = G.gm_insert_dataflow_between
		  ~defs:Register.Set.empty ~uses:defs ~kills:Register.Set.empty
		  ~src:cut ~dst:(G.exit(state.cfg)) in
        result

and primStmt      state x  = Impossible.unimp "primitive"
and spanStmt      state x  = Impossible.unimp "span"
and switchStmt    state x  = Impossible.unimp "switch"
@

% ------------------------------------------------------------------ 
\subsection{Procedure Translation}
% ------------------------------------------------------------------ 

\begin{quote}\it
    Todo: callee saved registers, data-flow-nodes. Do we put a label here
    for the procedure or is this handled on the assermbler level? --CL
\end{quote}

<<Make procedure>>=
let create_cont (a:Automaton.t) (sp:Rtl.loc) (env:F.env) (label:string) =
    let reference = match F.findv label env with
        | (_, (F.Continuation(r),_)) -> r
        | x                          -> assert false in
    Cont.allocate a sp label reference
        
let init_cont (cfg:G.cfg) (c:Cont.t) =
    G.gm_insert_assign_after (Cont.init c) (G.entry cfg)


<<Make procedure>>=
let proc env target (mangle:string->string)  asm (cconv,name,args,bdy) = 
    let p           = match F.findv name env with
                      | _,(F.Label(F.Proc p),_) -> p
                      | _                        -> assert false in
    let env         = F.push env p.F.scope in  (* activate local scope *)
    let pointer     = target.Target.pointersize in
    let cc          = target.Target.cc (Aux.Option.get default_cc cconv) in
    let sp          = Rtl.fetch (cc.Target.sp) pointer in (* stack pointer *)
    let cfg         = G.mk ()   in      (* empty control-flow graph *)
    (* symbolic compile-time constants to be used for stack areas *)
    let eqns        = Const.empty pointer        in (* eqns over pointers *)
    let eqns, stack = Const.sym "stackdata" eqns in
    let eqns, inb   = Const.sym "inbase"    eqns in
    let eqns, outb  = Const.sym "outbase"   eqns in
    let eqns, privb = Const.sym "private"   eqns in
    let eqns        = Const.make_equal sp outb eqns in
    (* calculate amount of user stack data - updates env! *)
    let stackd      = Area.mk stack in
    let ( env, stackd, conts) = StackData.proc env target stackd bdy in
    (* priv provides spill slots etc *)    
    let priv        = Automaton.mk target.Target.stack_slots privb in
    (* build CFG for body *)                    
    let exit        = G.set_label cfg (Idgen.exit name) (G.exit cfg) in
    (* dummy area in outgoing area because the the body of the procedure
       might not create any. This would confuse Area.overlap below *)
    let dummy       = Area.freeze (Area.mk outb) in   
    let state = (* this is needed for translation of the body *)
        { proc      = name       (* name of this procedure *)
        ; env       = env        (* fat environment *)
        ; target    = target     (* current target  *)
        ; cfg       = cfg        (* cfg we are building *)
        ; node      = exit       (* what follows current element in cfg *)
        ; incoming  = []         (* overlapping areas in incoming area *)
        ; outgoing  = [dummy]    (* overlapping areas in outgoing area *)
        ; inbase    = inb
        ; outbase   = outb
        ; conts     = []         (* continuations *)
        } in  
    (* translate body of procedure *)
    let state = foldr body bdy state in
    (* add nodes for incoming parameters *)
    let atmi  = Automaton.mk cc.Target.proc  state.outbase   in
    let args  = List.map (procformal state.env) args in
    let copy,area,uses = IO.copyin state.cfg args 
                    cc.Target.proc state.inbase state.node    in
    let state = 
        { state with    
          node     = copy
        ; incoming = area :: state.incoming
        } in
    let _     = G.gm_redirect_all (G.entry cfg) (G.exit cfg) state.node in
    (* insert initializing assignements for continuations *)
    let conts = List.map (create_cont priv cc.Target.sp env) state.conts in
    let ()    = List.iter (init_cont state.cfg) conts in
    let eqn   = List.fold_left (fun eqns c->Cont.register c eqns) eqns conts in
    (* prepare stack *)
    let incoming, eqns = Area.overlap Area.EqualLowEnds state.incoming eqns in
    let outgoing, eqns = Area.overlap Area.EqualLowEnds state.outgoing eqns in
    let i =    
        { Proc.name     = name
        ; Proc.cfg      = cfg
        ; Proc.mangle   = mangle
        ; Proc.incoming = incoming   (* incoming area *)   
        ; Proc.outgoing = outgoing   (* outgoing area *)   
        ; Proc.stackd   = stackd     (* stack data *)
        ; Proc.priv     = priv       (* Automaton for spill loc, etc *)
        ; Proc.eqns     = eqns       (* constraints for compile-time consts *)
        } 
    in
        asm ++ Asm.instr i
@
        
% ------------------------------------------------------------------ 
\subsection{Stack Data Declarations and Continuations}
% ------------------------------------------------------------------ 

Stack data declarations may appear everywhere in a procedure body. We
process them in a single descent into the body. Each stack data
declaration allocates memory in the [[mem]] field of the [[state]] record
that is passed around. A procedure must create entries for all
continuations in its body that escape it. We simply collect all
continuations and thus assume that they all escape. This is a gross
simplification - a more detailed escape analysis would traverse all
expressions in the body of a procedure and report only those
continuations that appear in expressions. 

<<Make stack data declarations>>=
module StackData = struct 

    type state = 
        { env:    F.env
        ; mem:    Area.builder
        ; target: Target.t
        ; conts:  string list
        }

    let rec stackdatum state = function
        | A.DatumAt(x,_) -> stackdatum state x
        | A.Label(l) -> 
            let loc = Area.location state.mem in
                let x = F.findv l state.env in
                ( match x with
                | (r,(F.Label(F.Stack(None)),t)) ->
                    { state with env = 
                        F.rebindv l (r,(F.Label(F.Stack(Some loc)),t)) 
                                  state.env
                    }
                | _ -> assert false
                )
        | A.Align n -> { state with mem = Area.align state.mem n} 
        | A.MemDecl(ty,size,None) ->
            let w = astwidth state.env ty in
            let s = ( match size with 
                    | A.NoSize     -> 1 
                    | A.DynSize    -> assert false (* impossible *)
                    | A.FixSize(e) -> 
                        Bits.to_int (compile_const state.env state.target e)
                    ) in
            let n = s * w / state.target.Target.memsize in
                { state with mem = Area.alloc state.mem n} 
                    
        | _ -> assert false (* illegal memory initializer *)

    let rec stmt state = function 
        | A.StmtAt(x,r)        -> stmt state x
        | A.SpanStmt    x      -> spanStmt      state x
        | A.IfStmt      x      -> ifStmt        state x
        | A.SwitchStmt  x      -> switchStmt    state x
        | A.ContStmt(n,_)      -> { state with 
                                    conts = n :: state.conts }
        | _                    -> state

    and body state = function 
        | A.BodyAt(x, _)        -> body state x
        | A.DeclBody(d)         -> state (* nothing to be done *)
        | A.StmtBody(s)         -> stmt state s 
        | A.DataBody(data)      -> foldl stackdatum state data

    and ifStmt state (e,ifso,ifnot) =
        let left  = foldl body state  ifso  in
        let right = foldl body left   ifnot in
            state

    and spanStmt      state x  = Impossible.unimp "span"
    and switchStmt    state x  = Impossible.unimp "switch"

    let proc env target priv bb =
        let state = 
            { env    = env
            ; target = target
            ; mem    = priv
            ; conts  = []
            } in
        let state = foldl body state bb in 
                (state.env, Area.freeze state.mem, state.conts)

end (* of module StackData *)
@
      
% ------------------------------------------------------------------ 
\subsection{Global Memory declarations}
% ------------------------------------------------------------------ 

\begin{note}\it
    The [[Asm]] interface for emitting link-time expressions is
    incompatible with the [[Rtl]]s that represent link-time expressions.
    --CL
\end{note}

<<Make memory declarations>>=
let initialized_data target asm expr = 
    Impossible.unimp "initialized data in global memory declaration"

let rec init env target asm = function
    | A.InitAt(x,_)   -> init env target asm x
    | A.InitExprs(es) -> foldl (initialized_data target) asm es
    | A.InitUStr(_)      (*XXX*)
    | A.InitStr(_)    -> (*XXX*)
        Impossible.unimp "initialized data in global memory declaration"
@

In order to reserve memory for data we have to know how many objects
an sequence of initializing expressions defined. This number is
returned by [[init_size]].

<<Make memory declarations>>=
let rec init_size = function
    | None   -> 1
    | Some i -> let rec loop = function 
                    | A.InitAt(x,_)   -> loop x
                    | A.InitExprs(es) -> List.length es
                    | A.InitStr(s)    -> assert false
                    | A.InitUStr(s)   -> assert false
                in 
                    loop i 
@

Data can be declared initialized or un-initialized. The amount of
memory used by a declaration is the size of the base-type times the
number of values of this type. 

<<Make memory declarations>>=
let memdecl (env:F.env) target asm t size ini = 
    let sizeof  = astwidth env t / target.Target.memsize          in
    let const e = Bits.to_int (compile_const env target e)     in
    let n      = ( match size with
                 | A.DynSize    -> init_size ini
                 | A.NoSize     -> 1
                 | A.FixSize(e) -> const e
                 ) in
        ( match ini with
        | None    -> asm ++ Asm.zeroes (n * sizeof)
        | Some ii -> init env target asm ii
        )
@

Data can be declared globally inside a section or a section-level
[[span]] and locally, inside a procedure as [[stackdata]].  The former
is directly translated into assembly action that reserve memory inside
a section, the latter becomes just an amount of memory that is
allocated inside a procedure's activation record.  Since the amount of
stack allocated data and the offsets associated with labels inside of
it are already entered into the fat environment (by
[[Elab.Check.stackdatum]]), stack data declaration can be ignored. 
Global data declarations, on the other hand, must be translated to
assembly actions.
 
<<Make memory declarations>>=
let rec datum env target mangle asm = function
    | A.DatumAt(x,_)        -> datum env target mangle asm x
    | A.Label(n)            -> asm ++ Asm.define_local (Asm.mksym (mangle n))
    | A.Align(a)            -> asm ++ Asm.align a 
    | A.MemDecl(t,m,init)   -> memdecl env target asm t m init
@

 
% ------------------------------------------------------------------ 
\subsection{Toplevel}
% ------------------------------------------------------------------ 

All global declarations have been processed at this stage and thus can
be ignored.  The only exception are (global) register declarations. 
Global registers can name a hardware register they are placed in.  We
need ia way to record such an assignment.  All other locations for
global registers are determined by an automaton, see module
\module{callconv}. 

A [[span]] on the section level must be pushed to the statement level: 
when we come across a [[span]] we modify the properties [[props]]
accordingly.  The next time we come across a procedure, the properties
including the span will be used.

<<Make toplevel>>=
let rec sspan env target mangle asm (e1,e2,ss) =    
    let key   = compile_const env target e1 in
    let value = link_const    env target e2 in
    (* construct props value, pass it to section. not implemented *)
        foldl (section env target mangle) asm ss 

<<Make toplevel>>=
and section env target mangle (asm: Asm.asm) = function
    | A.SectionAt(x,_)     -> section env target mangle asm x
    | A.Decl(d)            -> asm
    | A.Datum( d)          -> datum   env target mangle asm d
    | A.Procedure(p)       -> proc    env target mangle asm p
    | A.SSpan ss           -> sspan   env target mangle asm ss
@            

What to do with top-level procedures? They should go into some section
because otherwise they will end up in whatever section is currently
active which just seems wrong.

<<Make toplevel>>=
let rec toplevel env target mangle asm = function
    | A.ToplevelAt(x, _)  -> toplevel env target mangle asm x
    | A.Section(name, ss) -> 
        let asm = asm ++ Asm.section (mangle name)in  
            foldl (section env target mangle (*props*)) asm ss
    | A.TopDecl(d)        -> asm (* nothing to do here *)
    | A.TopProcedure(p)   -> let asm = asm ++ Asm.section default_section  
                             in proc env target mangle (*props*) asm p
@


% ------------------------------------------------------------------ 
\subsubsection{Program}
% ------------------------------------------------------------------ 

Imports and exports of assembly symbols are announced once at the top
of the assembly program.  The sets of imported and exported symbols
are registered in the fat environment.  For details, see modules
\module{mangle}, and \module{elab}. 

<<Make translate program>>=
let exports env asm = 
    Str.Set.fold (fun s asm -> asm ++ Asm.export (Asm.mksym s)) 
    (F.exported env) asm

let imports env asm =
    Str.Set.fold (fun s asm -> asm ++ Asm.import (Asm.mksym s)) 
    (F.imported env) asm
@

The assembler maintains a current section. To guarantee that
everything goes into a meaningful section, the first action is to
start the [[text]] section.
                      
<<Make translate program>>=
let program env target mangle asm tt = 
    let asm = asm ++ Asm.section "text"           in
    let asm = exports env asm                     in
    let asm = imports env asm                     in
        foldl (toplevel env target mangle) asm tt
@

The finger print [[disgest]] for global register declarations is a 16
character long string of unprintable characters. We make it printable by
applying the {\ocaml} escaping rules and [[mangle]]. Note: this symbol
should be exported but currently it is not.

\begin{quote}\it
    The memory block for global registers should go into one compilation
    unit and be imported by all others. Currently we just emit it
    because we are far from linking several {\PAL} compilation units.
    This has to be fixed. --CL
\end{quote}

<<Make translate program>>=
let translate env target prog =
    let mangle   = Asm.mangle (F.nam2sym env) in 
    let base_sym = mangle "global base" in
    let base     = Rtl.link base_sym target.Target.pointersize in (*XXX*)
    let env
       ,area
       ,digest   = globals env target base (F.globals env) in
    let digest   = mangle (String.escaped digest) in
    let asm      = Asm.init () in
    let asm      = asm ++ Asm.section (target.Target.data_section)
                       ++ Asm.comment "memory for global registers"
                       ++ Asm.align area.Area.align
                       ++ Asm.addloc area.Area.size
                       ++ Asm.define_local (Asm.mksym base_sym) (*XXX ok? *)
                       ++ Asm.define_local (Asm.mksym digest) (*XXX*)
    in   
        program env target mangle asm prog  (* asm *)
@    
