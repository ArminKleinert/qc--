% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et sts=4
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
%%Grades: C Central Soon


% Table of Contents
% egrep '^\\(sub)*section' ast3ir.nw 
%
% \section{Translation to Intermediate Representation}
% \subsection{Implementation}
% \subsection{Auxilliaries}
% \subsection{Expression Types}
% \subsection{Expression Translation}
% \subsection{Constant Evaluation}
% \subsection{Auxilliaries for Make}
% \subsection{Continuation Bundles}
% \subsection{Assignment}
% \subsection{Formal and Actual Parameters}
% \subsection{Global Registers}
% \subsection{Statements}
% \subsection{Procedure Translation}
% \subsection{Global Memory declarations}
% \subsection{Stack Data Declarations}
% \subsection{Toplevel}
% \subsubsection{Program}




% ------------------------------------------------------------------ 
\section{Translation to Intermediate Representation}
% ------------------------------------------------------------------ 

The [[translate]] function takes an environment, the actual target and
a program and translates it into an abstract assembler program.  The
assembler is functorized over the data type of instructions. This module
puts a whole procedure body into a single instruction by basically
treating a control-flow graph as an instruction. 


<<ast3ir.mli>>=
val translate: Fenv.Clean.env 
            -> Target2.t 
            -> optimizer: (Proc.t -> unit)
            -> Ast.program 
            -> Proc.t Asm3.assembler
(*
 * val freeze : Proc.t -> unit     (* will be replaced by Stackstage *)
 *)
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<ast3ir.ml>>=
module Target   = Target2
module A        = Ast
module T        = Types
module E        = Error
module F        = Fenv.Clean
module AT       = Automaton2

<<auxilliaries>>
<<ExprTypes>>

module G  = Cfg4 
module IO = Copyinout.Make(G)
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module U  = Rtl.Up
module D  = Rtl.Dn

<<Make expressions>>
<<Make constant evaluation>>
<<Make auxilliaries>>
<<Make continuation bundles>>
<<Make assignment>>    
<<Make global registers>>    
<<Make formals and actuals>>    
<<Make statements>>
<<Make stack data declarations>>
<<Make procedure>>
<<Make memory declarations>>
<<Make toplevel>>
<<Make translate program>>
@

% ------------------------------------------------------------------
\subsection{Auxilliaries}
% ------------------------------------------------------------------ 

<<auxilliaries>>=
let default_cc          = "C--"
let default_space       = ('m':Rtl.space)
let default_section     = "text"

(* the @ is required by NOWEB and not part of the operator! *)
let (@<<) f g = fun x -> f (g x) (* function composition *)

(* val width : 'a T.t -> 'a *)
let width = function
    | T.Bits n -> n
    | _        -> Impossible.impossible "ast3ir.width"

(* val astty : F.env -> A.ty -> Types.ty *)
let rec astty env = function
    | A.TyAt(x,r)  -> astty env x
    | A.BitsTy(n)  -> Types.bits n
    | A.AliasTy(x) -> snd (F.findt x env)

(* val astwidth : F.env -> A.ty -> int *)
let astwidth env = width @<< (astty env) 


let foldl = List.fold_left
let foldr = List.fold_right


(* Useful for adding a list of RTL's to the cfg.
 * Usage: add_to_cfg cfg (f: G.node -> 'a -> 'a) (rtls: Rtl.rtl list)
 *                       (succ:G.node, 'a)
 *)
let add_to_cfg cfg f =
    List.fold_right
        (fun rtl (succ,rst) ->
             let node = Cfg4.gm_assign cfg rtl succ in
             (node, f node rst))
@

We often know that the address of a block has the form $b+k$, where $b$
is a known address and $k$ some unkown offset. The function [[offset]]
provides returns an {\rtl} address of this form, where $k$ is
represented as a fresh late compile time constant.
<<auxilliaries>>=
let offset base ptrwidth =
  Rtlutil.add ptrwidth base (Rtl.late (Idgen.offset "Ast3ir.offset") ptrwidth)
@



% ------------------------------------------------------------------ 
\subsection{Expression Types}
% ------------------------------------------------------------------ 

We use the generic [[Expcheck]] module to find an expression's type.
Values from the environment are always [[Ok]] because at this stage we
have a clean environment.

<<ExprTypes>>=
let exprtype env target exp =
    let word      = Error.Ok(Types.bits target.Target.wordsize)    in
    let pointer   = Error.Ok(Types.bits target.Target.pointersize) in
    let tlookup   = fun x -> Error.Ok(snd (F.findt x env))         in
    let vlookup   = fun x -> Error.Ok( match (F.findv x env) with
                                     | (_,(_,t)) -> t 
                                     ) in
    let e = { Expcheck.wordsize    = word
            ; Expcheck.pointersize = pointer
            ; Expcheck.tlookup     = tlookup
            ; Expcheck.vlookup     = vlookup
            } 
    in try ( match Expcheck.check e exp with
           | Error.Ok(t) -> t
           | Error.Error -> assert false
           )
       with Error.ErrorExn msg -> assert false
@




% ------------------------------------------------------------------ 
\subsection{Expression Translation}
% ------------------------------------------------------------------ 

Expressions denote values, represented by compile-time, link-time, or
run-time values.  The translation of a variable depends on its
denotation. 

We should evaluate constant expressions as far as possible. Module
\module{rtleval} does this for link-time expressions and could possibly
be extended.

<<Make expressions>>=
let rec fetch env target = function
    | A.NameOrMemAt(x,_) -> fetch env target x
    | A.Name(hint,x)   -> variable env target hint x
    | A.Mem(t,e,a)    -> 
        let width = astwidth env t in
        let cell  = 
            Rtl.cell
                (match a with None -> Rtl.none | Some n -> Rtl.aligned n)
                default_space  (* m *) 
                target.Target.byteorder
                width
                (expr env target e)
        in
            Rtl.fetch cell width     
@

The translation of continuations in \path|Ast3ir| is bogus.
A continuation \emph{value} is a pointer into the stack where two values
are stored: a pointer to the code of the continuation, and a stack
pointer.
A continuation \emph{value} is a late compile-time expression: a sum of
the stack pointer value and some late compile-time constant. The stack
pointer in turn, depends on the currently active calling convention.

For example, we expect the following C--:
\begin{alltt}
p () {
    continuation k():
}
\end{alltt}
to cause the following initialization at the start of the enclosing procedure:
\begin{alltt}
sym@p()
{
    $m[sp + sym@k + 4] = sym@k;
    $m[sp + sym@k]     = sp;
    sym@k:
}
\end{alltt}

<<Make expressions>>=
and variable env target hint x =
    let (_,(denot,t)) = F.findv x env in
    ( match denot with
    | F.Constant(bits)          -> Rtl.bits bits (width t)
    | F.Label(F.Proc (s,_,_))   -> Rtl.link s (width t)
    | F.Label(F.Code s)         -> Rtl.link s (width t)
    | F.Label(F.Data s)         -> Rtl.link s (width t)
    | F.Import(_,s)             -> Rtl.link s (width t)
    | F.Continuation(st,s)       ->
        let cc     = target.Target.cc default_cc          in
        let offset = Rtl.late st (width t)                in
        let sp     = cc.Target2.sp                        in
        Rtlutil.add target.Target.pointersize (Rtlutil.fetch sp) offset
    | F.Label(F.Stack(None))  -> Impossible.impossible "Ast3ir.Make.variable"
    | F.Label(F.Stack(Some loc)) ->
        let w    = width t                                   in 
        let agg  = target.Target.byteorder                   in
        let cell = Rtl.cell Rtl.none default_space agg w loc in
            Rtl.fetch cell (width t)

    
    | F.Register({F.loc=Some l}) -> AT.fetch l (width t)
    | F.Register({F.index=i;F.loc=None}) ->
        (* local register in memory, ignoring hint *)
        if F.is_localv x env then
            let w = width t in
            Rtl.fetch (Rtl.var x i w) w
        else (* global register without location *)
            Impossible.impossible "Ast3ir.Make.variable"
    )
@

\begin{quote}\it
    Since evaluation and type-checking are separated, types in nested
    expressions are checked multiple times. This introduces a
    quadratic complexity. The only way to avoid this, as far as I can
    see, is a combined bottom-up evaluation and type checking. --CL

    Link time constants are not atomic but have an expression structure.
    We should try to push some operators down into link time constants:
    The sum of a symbol and a constant can be represented as a link-time
    constant. This requires that [[Rtl.Link]] values carry a
    [[Reladdr.t]] value rather just a [[Reladdr.symbol]]. --CL
\end{quote}
    
    
    
<<Make expressions>>=
and prim env target op args =
    let argtys  = List.map (exprtype env target) args in
    let _,opr   = Rtlop.Translate.operator op argtys   in
        Rtl.app opr (List.map (expr env target) args)

and expr env target exp = 
    let word = target.Target.wordsize in
    let literal str width cvt = Rtl.bits (cvt str width) width in
    let const default_width = function
        | Some ty -> astwidth env ty
        | None    -> default_width
    in match exp with
        | A.ExprAt(x,_)     -> expr env target x
        | A.Int(str,t)      -> literal  str (const word t) Bits.U.of_string
        | A.Float(str,t)    -> literal  str (const word t) Bits.U.of_string
        | A.Char(str,t)     -> literal  str (const word t) Bits.U.of_string
        | A.Fetch(v)        -> fetch env target v
        | A.BinOp (l,op,r)  -> prim env target op [l;r]
        | A.UnOp  (op,e)    -> prim env target op [e]
        | A.PrimOp(op,args) -> prim env target op (List.map snd args)
@

% ------------------------------------------------------------------ 
\subsection{Constant Evaluation}
% ------------------------------------------------------------------ 

We translate constants to {\rtl} expressions which we then evaluate.

<<Make constant evaluation>>=
let compile_const env target exp     = Rtleval2.bits (expr env target exp)
let eval_const    env target asm exp = Rtleval2.exp  (expr env target exp)  
let link_const    env target exp = 
    match D.exp (Rtleval2.exp  (expr env target exp)) with
    | RP.Const(RP.Bits(b))   -> Reloc.Simple.of_const b
    | RP.Const(RP.Link(l,w)) -> Reloc.Simple.of_sum l (Bits.zero w)
    | RP.App(("add",_),[RP.Const(RP.Link(l,w)); RP.Const(RP.Bits(b))]) ->
        Reloc.Simple.of_sum l b
    | RP.App(("sub",_),[RP.Const(RP.Link(l,w)); RP.Const(RP.Link(l',w'))]) ->
        Impossible.unimp "difference of link-time constants"
    | e -> (prerr_string "Bad link-time constant ";
            prerr_string (Rtlutil.ToString.exp (U.exp e));
            prerr_string "\n";
            assert false)
@

% ------------------------------------------------------------------ 
\subsection{Auxilliaries for Make}
% ------------------------------------------------------------------ 


<<Make auxilliaries>>=
let idwidth id env = match F.findv id env with (attr,(_,t)) -> width t
@

% ------------------------------------------------------------------ 
\subsection{Continuation Bundles}
% ------------------------------------------------------------------ 

A continuation bundle on the {\AST} level is a record of names, and an
asbtract type at the {\cfg} level.  The continuations function
translates from the former to the latter.

<<Make continuation bundles>>=
type conts =    { cuts    : G.node list
                ; unwinds : G.node list
                ; returns : G.node list
                ; aborts  : bool
                }

let continuations ast cfg =
    let lookup = List.map (G.lookup cfg)  in
    let rec loop conts = function
        | (A.FlowAt(f,_)):: ff -> 
            loop conts (f::ff)
        | (A.CutsTo n)   :: ff -> 
            loop {conts with cuts    = lookup n @ conts.cuts   } ff
        | (A.UnwindsTo n):: ff -> 
            loop {conts with unwinds = lookup n @ conts.unwinds} ff
        | (A.ReturnsTo n):: ff -> 
            loop {conts with returns = lookup n @ conts.returns} ff
        | (A.Aborts)     :: ff -> 
            loop {conts with aborts  = true                     } ff 
        | []                   -> conts in
    let empty = { cuts = []; unwinds = []; returns = [] ; aborts = false } in
    let conts = loop empty ast in
        G.conts conts.cuts conts.unwinds conts.returns conts.aborts
@

% ------------------------------------------------------------------ 
\subsection{Assignment}
% ------------------------------------------------------------------ 

The left hand side of a simple assignment $x \gets y$ can be a memory
cell, or a register which in turn can be local or global.  Each case
requires its own method to compute the {\rtl} that represents the
assignment.

<<Make assignment>>=
let rec assign env target lhs exp = match lhs with
    | A.NameOrMemAt(lhs,_) -> assign env target lhs exp
    | A.Name(hint,x) ->
        let (_,(denot,t)) = F.findv x env in
        let w = width t                   in
            ( match denot with
            | F.Register({F.loc=Some l}) -> AT.store l exp w
            | F.Register({F.index=i;F.loc=None}) ->
                if F.is_localv x env then
                    Rtl.store (Rtl.var x i w) exp w
                else 
                    Impossible.impossible "Ast3ir.Make.assign"
            | _ -> assert false (* impossible *)
            )
    | A.Mem(t,addr,align) ->
        let w     = astwidth env t in
        let cell  = 
            Rtl.cell
                (match align with None -> Rtl.none | Some n -> Rtl.aligned n)
                default_space  (* m *) 
                target.Target.byteorder
                w
                (expr env target addr)                        
        in
            Rtl.store cell exp w
@

% ------------------------------------------------------------------
\subsection{Formal and Actual Parameters}
% ------------------------------------------------------------------ 

An actual parameter is an expression and must be translated to the
format expected by the [[IO.copyout]] function.  A formal procedure
parameter denotes a local variable, a formal continuation parameter
either a local or \emph{global} variable.  Both are translated to the
format expected by the [[IO.copyin]] function.

<<Make formals and actuals>>=
let actual env target (hint, e) =
    let w   = width (exprtype env target e) in
    let exp = expr env target e           in
        (exp, w, hint) 
@

\begin{quote}\it
    As NR pointed out, hints on global registers have no semantics in 
    {\qcc}. They thus must be ignored when computing parameter
    passing. --CL
\end{quote} 

<<Make formals and actuals>>=
let formal env (khint, n) = (* for continuations *)
    ( match snd (F.findv n env) with 
    | (F.Register {F.index=i;F.loc=None},ty) when F.is_localv n env  -> 
        { IO.repr  = IO.Local (n,i)
        ; IO.width = width ty
        ; IO.hint  = khint  
        } 
    | (F.Register {F.loc=Some l},ty) -> 
        { IO.repr  = IO.Global (l)
        ; IO.width = width ty
        ; IO.hint  = khint  
        } 
    | _ -> assert false
    )

let procformal env (hint, inv, ty, name) = 
    ( match snd (F.findv name env) with 
    | (F.Register {F.index=i;F.loc=None},ty) -> 
        { IO.repr  = IO.Local (name,i)
        ; IO.width = width ty
        ; IO.hint  = hint  
        } 
    | _ -> assert false
    )
@
    

% ------------------------------------------------------------------ 
\subsection{Global Registers}
% ------------------------------------------------------------------ 

The global registers of a {\PAL} program are assigned to hardware
register or memory locations using a target specific automaton.  Each
assignment results in an abstract [[AT.loc]] value that is
entered under the name of the register to a map.
 
The [[globals]] function pushes all global registers through a target
specific automaton to obtain locations for each of them.  A location
is added to a register's denoation in the environment.  The updated
environment plus the area of memory that hold global registersi are
returned as a pair.

When different compilation units are linked together they all must
declare exactly the same global registers. We compute a cryptographic
hash value for all global register declarations as a finger print. The
finger print is a string of 16 characters which are not guaranteed to be
printable.

<<Make global registers>>=
let globals env target (base:Rtl.exp) names =
    let t = AT.mk target.Target.globals base in
    let decls = Buffer.create 128 in (* initial size - grows as needed *)
    let rec assign env n =
        try 
            ( match F.findv n env with
            | (rgn,(F.Register(reg),ty)) ->
                let h,h'  = match reg.F.rhint with
                            | F.RReg x -> Some x, x     (* h/w register *)
                            | _        -> None  , "" in
                let w     = width ty in
                (* sig is string representation of this declaration *)
                let sign  = Printf.sprintf "[%d <%s>]" w h' in
                let ()    = Buffer.add_string decls sign    in
                let loc   = AT.allocate t w h in
                let entry = ( rgn
                            , (F.Register({reg with F.loc = Some loc}),ty)
                            ) in F.rebindv n entry env
            | _ -> Impossible.impossible "Ast3ir.Make.globals"
            )
        with Error.ErrorExn msg -> Impossible.impossible msg
    in
    let env = List.fold_left assign env names in
        env, AT.freeze t, Digest.string (Buffer.contents decls)    
@


% ------------------------------------------------------------------ 
\subsection{Statements}
% ------------------------------------------------------------------ 

The translation of statements in a procedure body requires a bunch of
value that are passed as a functional [[state]] value around. Using
\ocaml's functional record update this allows to add more informations
as needed without breaking any code.

<<Make statements>>=
type state =
    { proc:         string           (* proc under translation (const) *)
    ; env:          F.env            (* fat environment        (const) *)
    ; target:       Target.t         (* current target         (const) *)
    ; cfg:          G.cfg            (* CFG under construction (const) *)
    ; node:         G.node           (* node following current unit    *)   
    ; outbase:      Rtl.exp          (* addr of OUTGOING area          *)   
    ; inbase:       Rtl.exp          (* addr of INCOMING ares          *)
    ; outgoing:     Block.t list     (* areas to be overlayed in OUTGOING *)   
    ; incoming:     Block.t list     (* ditto for INCOMING *)
    ; conts:        Contn.t Strutil.Map.t (* local *)    
    ; esc_conts:    Strutil.Set.t    (* escaping conts *)
    }
    
@
    
\begin{itemize}
\item [[proc]] is the name of the procedure under translation. The
      name is used to generate labels with the name inside. Constant.
\item [[env]] is the fat environment to resolve the meaning of names.
      Constant. 
\item [[target]] is the current target architecture. This provides
      target-specific pointer sizes, {\rtl}s and so forth. Constant.
\item [[cfg]] is the control-flow graph under construction. It
      represents the body of the procedure. Constant.
\item [[node]] is the node in the {\cfg} following the current unit
      under translation.
\item [[outbase]] is the run-time expression for the base-address of
      the \emph{outgoing} area on the stack. See also \module{stack}.
\item [[inbase]] is the run-time expression for the base-address of the
      \emph{incoming} area.
\item [[outgoing]] contains areas of disjoint lifetimes that are overlaid
      in the \emph{outgoing} area.
\item [[incoming]] overlaid areas in the \emph{incoming} area.        
\end{itemize}

It is important that all areas in the [[outgoing]] list have a base
address that is related to [[outbase]], and analogously for [[incoming]]
and [[inbase]]. Otherwise the equations (c.f.~modules \module{eqn},
\module{const}) that are generated when areas are arranged to form an
activation record will be unsolvable.


<<Make statements>>=
let rec stmt spans s state = match s with
    | A.StmtAt(x,r)        -> stmt spans x state 
    | A.SpanStmt    x      -> spanStmt      spans state x
    | A.IfStmt      x      -> ifStmt        spans state x
    | A.SwitchStmt  x      -> switchStmt    spans state x
    | A.LabelStmt   x      -> labelStmt     spans state x
    | A.ContStmt    x      -> contStmt      spans state x
    | A.AssignStmt  x      -> assignStmt    spans state x
    | A.CallStmt    x      -> callStmt      spans state x
    | A.PrimStmt    x      -> primStmt      spans state x
    | A.GotoStmt    x      -> gotoStmt      spans state x
    | A.JumpStmt    x      -> jumpStmt      spans state x
    | A.CutStmt     x      -> cutStmt       spans state x
    | A.ReturnStmt  x      -> returnStmt    spans state x 
    | A.EmptyStmt          -> state     
    | A.CommentStmt _      -> state    

and body spans b state = match b with
    | A.BodyAt(x, _)        -> body spans x state
    | A.DeclBody(d)         -> state (* nothing to be done *)
    | A.StmtBody(s)         -> stmt spans s state 
    | A.DataBody(dd)        -> state (* already done *)
    

and labelStmt spans state x =
    let s = match F.findv x state.env with
        | _, (F.Label(F.Code(s)),_) -> s
        | _ -> assert false
    in    
        { state with node = G.gm_label state.cfg x s state.node }
@

An if-statement is governed by a boolean expression that has no side
effects. A simple translation is to use this expression as a guard for a
conditional branch to implement the if-statement. The guard finally
becomes a guard in the {\rtl} that implements the conditional branch.
The problem is, that the guarding expression can be quite complex and
must be simplified before a machine instruction can be found that
implements it. We translate a boolean expression $e$ into a sequence of
nodes. If $e$ evaluates to true, the control flow reaches the end of the
sequence, otherwise it branches to a provided label. 


\begingroup % keeps definitions local
\def\C#1{{\cal C}[\![#1]\!]}
\let\i\textit

The translation is summarized by the following function $\C{\cdot}~f$
that takes a boolean expression $e$ and a continuation $f$ to branch if
the expression evaluates to false. The result is a sequence of nodes,
that branches to $f$ if $e$ is false, and falls through otherwise.

\begin{center}
\begin{eqnarray*}
    \C{\i{true}}~f              & \to & \i{nop}\\
    \C{\i{false}}~f             & \to & \i{goto}~f\\
    \C{x \vee y}~f              & \to & \C x~l; l: \C y~f\\
    \C{x \wedge y}~f            & \to & \C x~f; \C y~f\\
    \C{\lnot x}~f               & \to & \C x~l; \i{goto}~f; l:\\
    \C{\oplus(e_1, \dots, e_n)} & \to & 
        \i{if}(\lnot \oplus(e_1, \dots, e_n)\{\i{goto}~f\}
\end{eqnarray*}
\end{center}

The last line covers the case of an application with a boolean result
but non-boolean arguments. Currently only the logical operators $\lnot$,
$\vee$, and $\wedge$ \emph{take} boolean arguments.

The implementation first translates the governing expression into an
{\rtl} and then tranlate it into the sequence of nodes.

\begin{quote}\it
    I think the code below shows a design weakness: we have decided to
    have explicit label nodes in the {\cfg}. In order to jump or branch
    to a node one needs the symbol associated with the label. This,
    however, cannot be observed. This means, labels can only be used
    where they are constructed. In the implementation of the {\cfg}
    labels could be made a sub-class of nodes. However, since we shield
    the object-oriented nature of nodes behind standard types, this is
    not easily possible. Nodes must be more abstract or labels must
    become special.  --CL
\end{quote}

\endgroup

<<Make statements>>=
and guard state succ fail e = 
    let rec guard' succ fail = function

    | RP.Const(RP.Bool(true))         -> succ
    | RP.Const(RP.Bool(false))        -> fail
    | RP.Const(_)                     -> assert false
    | RP.Fetch(_)                     -> assert false
    <<special cases that match floating-point comparisons>>
    | RP.App(("conjoin",_), [x;y])    -> 
        let ll    = Idgen.label state.proc    in
        let ls    = F.symbol state.env ll     in
        let fail  = G.gm_label state.cfg ll ls fail in
            let tail = guard' succ fail y in
            let head = guard' tail fail x in
                head
    | RP.App(("not",_), [x])          -> guard' fail succ x
    | RP.App(("disjoin",_), [x;y])    ->
        let ll    = Idgen.label state.proc    in
        let ls    = F.symbol state.env ll     in
        let succ  = G.gm_label state.cfg ll ls succ in
        let y     = guard' succ fail y    in
        let lexp  = Rtl.link ls state.target.Target.pointersize in
        let lrtl  = state.target.Target.goto.Target.embed lexp in
        let succ  = G.gm_goto state.cfg lrtl [G.lookup state.cfg ll] in
                guard' succ y x              
    | RP.App(opr, args) as e -> 
        let sl    = Idgen.label state.proc    in
        let ss    = F.symbol state.env sl     in
        let succ  = G.gm_label state.cfg sl ss succ in
        
        let fl    = Idgen.label state.proc    in
        let fs    = F.symbol state.env fl     in
        let fail  = G.gm_label state.cfg fl fs fail in
        
        let oexp  = Rtl.link fs state.target.Target.pointersize in
        let ortl  = state.target.Target.goto.Target.embed oexp in
        let fail  = G.gm_goto state.cfg ortl [G.lookup state.cfg fl] in
        
        let e     = R.Up.exp e in
        let link  = Rtl.link ss state.target.Target.pointersize in
        let rtl   = state.target.Target.branch.Target.embed (e,link)  in
            G.gm_branch state.cfg rtl succ fail 
    in
        { state with node = guard' succ fail e }
        
@
<<special cases that match floating-point comparisons>>=
(* the evil empire *)
@


An if-statement is translated into a seqence of nodes such that the
two branches are linearized.  The branch is taken if the governing
expression is evaluated to [[false]].  The fall-through-branch is
taken otherwise and ends with a [[goto]] around the other branch. 

\begin{enumerate}
\item A branch node holding the governing expression and a label [[l1]].
      If the expression evaluates to true at run-time, the branch is taken
      to [[l1]]. Otherwise the branch falls trough.
\item Nodes for the [[ifnot]] branch of the statement.
\item A jump to label [[l2]].
\item A label [[l1]] that marks the entry to the node for the [[ifso]] branch.
\item Nodes for the [[ifso]] branch.
\item A label [[l2]] in front of the code following the [[if]] statement. 
\end{enumerate}

<<Make statements old>>=
and ifStmt' spans state (e,ifso,ifnot) =
    let l_ifso = Idgen.label state.proc in (* label for ifso/left *)
    let l_join = Idgen.label state.proc in (* label for join *)
    let s_ifso = F.symbol state.env l_ifso in   (* register symbol *)
    let s_join = F.symbol state.env l_join in   (* register symbol *)
    let n_join = G.gm_label state.cfg l_join s_join state.node in
    let ifso   = foldr body ifso { state with node = n_join } in
    let ifso   = { ifso with node = 
                   G.gm_label state.cfg l_ifso s_ifso ifso.node } in
    let l2exp  = Rtl.link s_join state.target.Target.pointersize in
    let l2rtl  = state.target.Target.goto.Target.embed l2exp in
    let l2goto = G.gm_goto state.cfg l2rtl [G.lookup state.cfg l_join] in
    let ifnot  = foldr body ifnot {ifso with node = l2goto} in
    let exp    = expr state.env state.target e in
    let link   = Rtl.link s_ifso state.target.Target.pointersize in
    let rtl    = state.target.Target.branch.Target.embed (exp,link)  in
        { ifnot with node = 
          G.gm_branch state.cfg rtl ifso.node ifnot.node
        }

<<Make statements>>=
and ifStmt spans state (e,ifso,ifnot) =
    let l_join = Idgen.label state.proc in (* label for join *)
    let s_join = F.symbol state.env l_join in   (* register symbol *)
    let n_join = G.gm_label state.cfg l_join s_join state.node in
    let ifso   = foldr (body spans) ifso { state with node = n_join } in
    
    let l2exp  = Rtl.link s_join state.target.Target.pointersize in
    let l2rtl  = state.target.Target.goto.Target.embed l2exp in
    let l2goto = G.gm_goto state.cfg l2rtl [G.lookup state.cfg l_join] in
    let ifnot  = foldr (body spans) ifnot {ifso with node = l2goto} in
    
    let e      = R.Dn.exp (expr state.env state.target e) in
        guard ifnot ifso.node ifnot.node e 
        

and assignStmt spans state (lhs,rhs) =
    let effect lhs (guard,rhs) =
        let exp = expr   state.env state.target rhs     in
        let rtl = assign state.env state.target lhs exp in 
            ( match guard with
            | None   -> rtl
            | Some g -> Rtl.guard 
                            (expr state.env state.target g) rtl
            ) 
    in
    let rtl = Rtl.par (List.map2 effect lhs rhs) in
        { state with node = G.gm_assign state.cfg rtl state.node }
@

If the {\AST} does not mention any labels, we know that the expression
must be a label.
             
<<Make statements>>=
and gotoStmt spans state (e,labels) =
    let rec label_of = function
        | A.ExprAt(x,_)             -> label_of x
        | A.Fetch(A.NameOrMemAt(x,_))  -> label_of (A.Fetch x)
        | A.Fetch(A.Name(_,x))       -> x
        | _                         -> assert false in
    let labels = if labels <> [] then labels else [label_of e] in
    let exp   = expr state.env state.target e  in
    let rtl   = state.target.Target.goto.Target.embed exp    in
    let nodes = List.map (G.lookup state.cfg) labels         in
        {state with node = G.gm_goto state.cfg rtl nodes}
@
        
The overflowing outgoing parameters passed by a tail-call go into the
\emph{incoming} area of the current activation, but the \emph{copyout}
mechanism is used. 

\begin{quote}\it
    I believe the [[labels]] for jump targets should not be translated
    into nodes because they do not belong to the current procedure. --CL
\end{quote}

<<Make statements>>=
and jumpStmt spans state (cconv,e,args,labels) = 
    let exp     = expr state.env state.target e    in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let args    = List.map (actual state.env state.target) args in
    let rtl     = state.target.Target.jump.Target.embed exp      in
    let jmp     = G.gm_jump state.cfg rtl labels                 in
        if args = [] then (* no copyout nodes *)
            { state with node = jmp }
        else
            let rtls,area = IO.copyout args cc.Target.proc state.inbase in
            let node, defs =
                add_to_cfg state.cfg (fun n rst -> Register.Set.union rst (G.defs n))
                           rtls (jmp, Register.Set.empty) in
            let result = 
                { state with node     = node
                ;            incoming = area :: state.incoming
                } in 
            let () = G.gm_insert_dataflow_between
		  ~defs:Register.Set.empty ~uses:defs ~kills:Register.Set.empty
		  ~src:jmp ~dst:(G.exit(state.cfg)) in
                result
@


% \begin{quote}\small
% \begin{verbatim}
% 
%             /   |
%             |   o  r0 = x  
%  copy-out:  |   |                      
%  defs r0,r1 |   o  r1 = y 
%             \   |
%              ------
%             | call | x = f(x,y) call: kills y, ... 
%            ///-----
%           ///   |
%          ///    o               data-flow: uses r0, r1; defs x 
%  continuations  |
%                 o  x = r0       copy-in:   uses r0
%                 |
%                         
% \end{verbatim}
% \end{quote}

\begin{figure}
\centerline{\includegraphics[width=\hsize]{../figures/callstmt}}
\caption{\label{fig:ast3ir:call} Principle translation of a call
statement. A data-flow node expresses inter-procedural data-flow.}
\end{figure}

\begin{quote}\it
    We need data-flow-edges for the conintuations, too. --CL
\end{quote}

<<Make statements>>=
and callStmt spans state (lhs,cconv, e, args, targets (*unused*), conts) = 
    let rec lvalue = function
        | A.NameOrMemAt(x,_) -> lvalue x
        | A.Name x         -> formal state.env x 
        | A.Mem _         -> assert false                        in
    let ptrsize = state.target.Target.pointersize in    
    let exp     = expr state.env state.target e    in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let rtl     = state.target.Target.call.Target.embed exp   in
    let args    = List.map (actual state.env state.target) args  in
    let conts   = continuations conts state.cfg                  in
    let rtl     = state.target.Target.call.Target.embed exp      in
    (* linking nodes from back to front: copyin<-call<-copyout *) 
    let rtls,areai = IO.copyin (List.map lvalue lhs) cc.Target.ret
                            (offset state.inbase ptrsize) in
    let copyi,uses =
        add_to_cfg state.cfg (fun n rst -> Register.Set.union rst (G.uses n))
                   rtls (state.node, Register.Set.empty) in
    let call        = G.gm_call  state.cfg rtl conts spans copyi in
    let rtls,areao = IO.copyout args cc.Target.proc (offset state.outbase ptrsize) in
    let copyo,defs =
        add_to_cfg state.cfg (fun n rst -> Register.Set.union rst (G.defs n))
                   rtls (call, Register.Set.empty) in
    let result = { state with
                     node     = copyo
                 ;   outgoing = areao :: state.outgoing
                 ;   incoming = areai :: state.incoming
                 } in
    (* fix data-flow *)
    let () = G.gm_insert_dataflow_between 
            ~defs:uses ~uses:defs ~kills:Register.Set.empty
            ~src:call ~dst:copyi in 
        result        
@

A procedure returns value in the \emph{incoming} area of its
activation but uses the \emph{copy-out} method.  Don't get confused
and refer to the big picture in \module{stack}. 

\begin{quote}\it
    Does the {\rtl} used for the return depend on $(x,y)$. I believe
    so and this means the [[Target]] interface should be changed. --CL
\end{quote}

<<Make statements>>=
and returnStmt spans state (cconv, kont, args) = 
    let const e = Bits.S.to_int (compile_const state.env state.target e)     in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let (x,y)   = match kont with
                  | None       -> (0,0) (* default *)
                  | Some (x,y) -> (const x, const y) in
    let rtl     = cc.Target.return                                         in
    let args    = List.map
                  (actual state.env state.target) args       in
    let ret     = G.gm_return state.cfg rtl (x, y)   in
    let ptr     = state.target.Target.pointersize in
    let rtls, area =
              IO.copyout args cc.Target.ret (offset state.inbase ptr) in
    let copy, defs =
        add_to_cfg state.cfg (fun n rst -> Register.Set.union rst (G.defs n))
                   rtls (ret, Register.Set.empty) in
                    
    let result  = {state with node = copy; incoming = area :: state.incoming}in
		  (* fix data-flow *)
    let ()      = G.gm_insert_dataflow_between
		  ~defs:Register.Set.empty ~uses:defs ~kills:Register.Set.empty
		  ~src:ret ~dst:(G.exit(state.cfg)) in
	result
	
@
Each continuation receives its parameters in its own area.
Only continuations that escape are given space on the stack.
<<Make statements>>=
and contStmt spans state (label,args)  = 
    let ptr     = state.target.Target.pointersize in
    let cc      = state.target.Target.cc default_cc      in
    let sp      = Rtl.fetch cc.Target.sp  ptr in
    let args    = List.map (formal state.env) args in

    let contID, symbol =
        match F.findv label state.env with
        | _,(F.Continuation(n,s),_) -> n,s
        | _ -> assert false                               in

    let succ,state =
        if Strutil.Set.mem label state.esc_conts
        then begin
            let variable  = Rtl.late contID ptr in
            let offset    = Rtlutil.add ptr sp variable in
            let newBase   = Rtl.late (Idgen.block ("contParams"^label)) ptr in
            let newBase   = Rtlutil.add ptr offset newBase in
            let rtls,area = IO.copyin args cc.Target.cont newBase in
            let copy,_ =
                add_to_cfg state.cfg (fun n rst ->
                                          Register.Set.union rst (G.uses n))
                           rtls (state.node, Register.Set.empty) in
            let cont      = Contn.with_overflow state.target area in
            let state     = { state with conts =
                                 Strutil.Map.add label cont state.conts} in
            copy,state
        end else begin
            state.node,state
        end in
    let succ    = G.gm_label state.cfg label symbol succ         in
        { state with node = succ }
@

A [[cut to]] instruction passes arguments according to a calling convention.
Each continuation has its own overflow area. The [[copyout]] routine returns
an [[area]] that corresponds to the overflow area. Since this area may
not belong on this stack, we will discard it. Because we discard
the area, late compile-time constants indexed into this area must be replaced
immediately.
We solve the constraints on the area and use the resulting substitution
to replace the late compile-time constants in the rtl's returned from
[[copyout]].

<<Make statements>>=
and cutStmt spans state (e, args, conts) = 
    let cc        = state.target.Target.cc default_cc                  in
    let ptr       = state.target.Target.pointersize                    in
    let mem       = state.target.Target.memsize                        in
    let sp        = cc.Target2.sp                                      in
    let args      = List.map (actual state.env state.target) args      in
    let contn     = expr state.env state.target e                      in
    let rtl       = Contn.cutto state.target cc.Target.cutto.Target.embed
                                contn in
    let conts     = continuations conts state.cfg                      in
    let cut       = G.gm_cutto state.cfg rtl conts                     in

    let size      = ptr / state.target.Target.memsize                  in
    let oflow     = Rtlutil.addk ptr contn (2 * size)                  in
                      (* CONTN REP IS EXPOSED HERE *)
    let rtls,area = IO.copyout args cc.Target.cont oflow in

    (* solve the equations *)
    let solution =
        try Const2.solve ptr (Block.constraints area)
        with Const2.Can'tSolve -> Impossible.impossible 
                ("can't solve equations in "^ state.proc)              in

    (* substitute for the compile-time constants *)
    let map      = Strutil.assoc2map solution.Const2.known             in
    let guard    = function
        | RP.Const(RP.Late(_)) -> true
        | _                    -> false in
    let rec subst (e:RP.exp) = match e with              
        | RP.Const(RP.Late(x,_)) -> 
            ( try Rtl.Dn.exp (Strutil.Map.find x map)
              with Not_found -> e   (* we don't know all the constants yet *)
            )  
        | x -> x in

    let copy,defs =
        add_to_cfg state.cfg
          (fun node rst ->
            let () = G.upd_instr node (Rtlutil.Subst2.exp ~guard ~map:subst) in
            let () = G.upd_instr node Rtleval2.rtl in
                Register.Set.union rst (G.defs node))
           rtls (cut, Register.Set.empty) in

    let result    =    { state with node     = copy } in
    let ()      = G.gm_insert_dataflow_between
		  ~defs:Register.Set.empty ~uses:defs ~kills:Register.Set.empty
		  ~src:cut ~dst:(G.exit(state.cfg)) in
        result
@

The span statement just evaluates the two span arguments and adds them
to the list of active spans.

<<Make statements>>=
and spanStmt spans state (e1,e2,b) =
    let key   = compile_const state.env state.target  e1 in
    let value = link_const    state.env state.target  e2 in
    let spans = (key,value) :: spans                     in
        foldr (body spans) b state

and primStmt    spans state x  = Impossible.unimp "primitive"
and switchStmt  spans state x  = Impossible.unimp "switch"
@

% ------------------------------------------------------------------ 
\subsection{Procedure Translation}
% ------------------------------------------------------------------ 

\begin{quote}\it
    Todo: callee saved registers, data-flow-nodes. Do we put a label here
    for the procedure or is this handled on the assembler level? --CL
\end{quote}

For each continuation we have reserved memory on the stack that must be
initialized when the procedure is entered. The following function
inserts this code into the procedure.

<<Make procedure>>=
let init_cont env (cfg:G.cfg) (target:Target.t) (cc:Target.cc) label (c:Contn.t) = 
    let ptr  = target.Target.pointersize in
    let sp    = Rtl.fetch cc.Target.sp (Rtlutil.Width.loc cc.Target.sp) in
    let sym  = match F.findv label env with
         | (_, (F.Continuation(r,s),_)) -> s
         | _                            -> assert false in
    let pc   = Rtl.link sym ptr in
        ignore (G.gm_insert_assign_after (G.entry cfg) (Contn.init_code c sp pc))
    
@
<<Make procedure>>=
let proc spans env target optimizer (cconv,name,args,bdy) = 
    let ( symbol
        , scope
        , vars )    = match F.findv name env with
                      | _,(F.Label(F.Proc (sym,scope,i)),_) -> sym,scope,i
                      | _                          -> assert false in
    let env         = F.push env scope  in  (* activate local scope *)
    let pointer     = target.Target.pointersize in
    let addk        = Rtlutil.add pointer in
    let cc          = target.Target.cc (Aux.Option.get default_cc cconv) in
    let sp          = Rtl.fetch (cc.Target.sp) pointer in (* stack pointer *)
    let cfg         = G.mk target (Rtl.par []) in (* empty control-flow graph *)
    (* symbolic late compile-time constants to be used for stack areas *)
    let sp_offset k = addk sp k in
    let inb         = sp_offset (Rtl.late "inbase"    pointer) in
    let outb        = sp_offset (Rtl.late "outbase"   pointer) in
    let privb       = sp_offset (Rtl.late "private"   pointer) in
    (* calculate amount of user stack data - updates env! *)
    let stackd      = Memalloc.relative sp "stackdata" Memalloc.Up in
    let ( env, stackd, conts, esc_conts) = StackData.proc env target stackd cc bdy in
    (* priv provides spill slots etc *)    
    let priv        = AT.mk cc.Target.stack_slots privb in
    (* build CFG for body *)                    
    let exit_label  = Idgen.exit name in
    let exit_symbol = F.symbol env exit_label in
    let exit        = G.gm_label cfg exit_label exit_symbol (G.exit cfg) in
    (* dummy area in outgoing area because the the body of the procedure
       might not create any. This would confuse Area.overlap below *)
    let dummy       = Block.at outb 0 1 in   
    let state = (* this is needed for translation of the body *)
        { proc      = name       (* name of this procedure *)
        ; env       = env        (* fat environment *)
        ; target    = target     (* current target  *)
        ; cfg       = cfg        (* cfg we are building *)
        ; node      = exit       (* what follows current element in cfg *)
        ; incoming  = []         (* overlapping areas in incoming area *)
        ; outgoing  = [dummy]    (* overlapping areas in outgoing area *)
        ; inbase    = inb
        ; outbase   = outb
        ; conts     = conts
        ; esc_conts = esc_conts
        } in  
    (* translate body of procedure *)
    let state = foldr (body spans) bdy state in
    (* add nodes for incoming parameters *)
    let atmi  = AT.mk cc.Target.proc  (offset state.outbase pointer) in
    let args  = List.map (procformal state.env) args in
    let rtls,area = IO.copyin args cc.Target.proc state.inbase in
    let copy,_ =
        add_to_cfg state.cfg (fun n rst -> Register.Set.union rst (G.uses n))
                   rtls (state.node, Register.Set.empty) in
    let state = 
        { state with    
          node     = copy
        ; incoming = area :: state.incoming
        } in
    let _     = G.gm_redirect_all (G.entry cfg) (G.exit cfg) state.node in
    (* insert initializing assignments for continuations *)
    let () = Strutil.Map.iter (init_cont env cfg target cc) state.conts in

    let incoming = Block.overlap_list pointer Block.Low  state.incoming in
    let outgoing = Block.overlap_list pointer Block.High state.outgoing in
    
    let conts = Block.cathl_list pointer
                (Strutil.Map.fold (fun _ c rst -> Contn.rep c :: rst) state.conts [])in
    (* order cfg *)
    let ()    = G.gm_enumerate cfg in
    let i =    
        { Proc.symbol   = symbol
        ; Proc.cc       = cc
        ; Proc.target   = target
        ; Proc.temps    = Talloc.Multiple.for_spaces target.Target.spaces
        ; Proc.cfg      = cfg
        ; Proc.incoming = incoming   (* incoming   block *)   
        ; Proc.outgoing = outgoing   (* outgoing   block *)   
        ; Proc.stackd   = stackd     (* stack data block *)
        ; Proc.sp       = Block.at (Rtl.fetch cc.Target.sp pointer) 0 4
            (* N.B. 4 IS BOGUS; SHOULD BE ALIGNMENT OF STACK.  FIXED IN [[Ast2ir]] *)
        ; Proc.priv     = priv       (* Automaton for spill loc, etc *)
        ; Proc.eqns     = []
        ; Proc.conts    = conts
        ; Proc.vars     = vars       (* number of variables *)
        ; Proc.varMap   = Proc.VarMap.empty
        } in
    optimizer i (* runs optimizer, freezes, and assembles proc *)
@
        
% ------------------------------------------------------------------ 
\subsection{Stack Data Declarations and Continuations}
% ------------------------------------------------------------------ 

Stack data declarations may appear everywhere in a procedure body. We
process them in a single descent into the body. Allocated memory is
tracked with a [[Memalloc.t]] value in the [[mem]] field of a [[state]]
value.

A procedure must create entries for all continuations in its body that
escape it. We simply collect all continuations and thus assume that they
all escape. This is a gross simplification - a more detailed escape
analysis would traverse all expressions in the body of a procedure and
report only those continuations that appear in expressions. 

<<Make stack data declarations>>=
module StackData = struct 

    type state = 
        { env:              F.env
        ; mem:              Memalloc.t
        ; target:           Target.t
        ; cc:               Target.cc     (* current calling convention *)  
        ; conts:            Contn.t Strutil.Map.t
        ; esc_conts:        Strutil.Set.t    (* escaping conts *)
        }

    let rec stackdatum state = function
        | A.DatumAt(x,_) -> stackdatum state x
        | A.Label(l) -> 
            let loc = Memalloc.current state.mem in
                let x = F.findv l state.env in
                ( match x with
                | (r,(F.Label(F.Stack(None)),t)) ->
                    { state with env = 
                        F.rebindv l (r,(F.Label(F.Stack(Some loc)),t)) 
                                  state.env
                    }
                | _ -> assert false
                )
        | A.Align n -> { state with mem = Memalloc.align state.mem n} 
        | A.MemDecl(ty,size,None) ->
            let w = astwidth state.env ty in
            let s = ( match size with 
                    | A.NoSize     -> 1 
                    | A.DynSize    -> assert false (* impossible *)
                    | A.FixSize(e) -> 
                        Bits.U.to_int (compile_const state.env state.target e)
                    ) in
            let n = s * w / state.target.Target.memsize in
                { state with mem = Memalloc.allocate state.mem n} 
                    
        | _ -> assert false (* illegal memory initializer *)

    let rec stmt state = function 
        | A.StmtAt(x,r)        -> stmt       state x
        | A.IfStmt      x      -> ifStmt     state x
        | A.SwitchStmt  _      -> Impossible.unimp "switch"
        | A.LabelStmt   x      -> state
        | A.ContStmt    x      -> state
        | A.SpanStmt    _      -> Impossible.unimp "span"
        | A.AssignStmt  x      -> assignStmt state x
        | A.CallStmt    x      -> callStmt   state x
        | A.PrimStmt    _      -> Impossible.unimp "primitive"
        | A.GotoStmt    x      -> gotoStmt   state x
        | A.JumpStmt    x      -> jumpStmt   state x
        | A.CutStmt     x      -> cutStmt    state x
        | A.ReturnStmt  x      -> returnStmt state x
        | A.EmptyStmt          -> state
        | A.CommentStmt _      -> state

    and body state = function 
        | A.BodyAt(x, _)        -> body state x
        | A.DeclBody(d)         -> state (* nothing to be done *)
        | A.StmtBody(s)         -> stmt state s 
        | A.DataBody(data)      -> foldl stackdatum state data

    and ifStmt state (e,ifso,ifnot) =
        let test  = expr state e in
        let left  = foldl body test  ifso  in
        let right = foldl body left  ifnot in
            right
    and assignStmt  state (lhs,rhs) =
        let left  = foldl lvalue  state lhs in
        let right = foldl guarded left  rhs in
        right
    and callStmt    state (lhs,cconv, e, args, targets (*unused*), conts) =
        let left = foldl lvalue state lhs in
        let estate = expr left e in
        let actual = foldl actual estate args in
        actual
    and gotoStmt    state (e,labels) = expr state e
    and jumpStmt    state (cconv,e,args,labels) =
        let estate = expr state e in
        let actual = foldl actual estate args in
        actual
    and cutStmt     state (e, args, conts) =
        let estate = expr state e in
        let actual = foldl actual estate args in
        actual
    and returnStmt  state (cconv, altcont, args) =
        let altstate = match altcont with
            | Some (e1,e2) -> expr (expr state e2) e1
            | None -> state in
        let actual = foldl actual altstate args in
        actual
    and expr state e = match e with
      | A.ExprAt (e,_) -> expr state e
      | A.Fetch (lv) -> lvalue state lv
      | A.BinOp (e1,_,e2) -> expr (expr state e1) e2
      | A.UnOp (_,e) -> expr state e
      | A.PrimOp (_,actuals) -> foldl actual state actuals
      | _ -> state
    and actual state (_,e) = expr state e
    and lvalue state l = match l with
      | A.NameOrMemAt (lv,_) -> lvalue state lv
      | A.Mem (_,e,_)      -> expr   state e
      | A.Name (_,name)     ->
            ( match F.findv name state.env with
              | (_,(F.Continuation _,_)) ->
                  {state with esc_conts = Strutil.Set.add name state.esc_conts}
              | _ -> state
            )
    and guarded state (e1,e2) =
        let e1state = match e1 with
                      | None -> state
                      | Some e -> expr state e in
        let e2state = expr e1state e2 in
        e2state

    let proc env target priv cc bb =
        let state = 
            { env    = env
            ; target = target
            ; mem    = priv
            ; cc     = cc
            ; conts  = Strutil.Map.empty
            ; esc_conts = Strutil.Set.empty
            } in
        let state = foldl body state bb in 
                (state.env, Memalloc.freeze state.mem, state.conts, state.esc_conts)

end (* of module StackData *)
@
      
% ------------------------------------------------------------------ 
\subsection{Global Memory declarations}
% ------------------------------------------------------------------ 

\begin{quote}\it
    The [[Asm]] interface for emitting link-time expressions is
    incompatible with the [[Rtl]]s that represent link-time expressions.
    --CL
\end{quote}

<<Make memory declarations>>=
let initialized_data env target asm expr = 
        asm#addr (link_const env target expr)

let rec init env target asm = function
    | A.InitAt(x,_)   -> init env target asm x
    | A.InitExprs(es) -> List.iter (initialized_data env target asm) es
    | A.InitUStr(_)      (*XXX*)
    | A.InitStr(_)    -> (*XXX*)
        Impossible.unimp "strings as initialized data not implemented"
@

In order to reserve memory for data we have to know how many objects
an sequence of initializing expressions defined. This number is
returned by [[init_size]].

<<Make memory declarations>>=
let rec init_size = function
    | None   -> 1
    | Some i -> let rec loop = function 
            | A.InitAt(x,_)   -> loop x
            | A.InitExprs(es) -> List.length es
            | A.InitStr(s)    -> Impossible.unimp "strings as initialized data"
            | A.InitUStr(s)   -> Impossible.unimp "strings as initialized data"
        in 
            loop i 
@

Data can be declared initialized or un-initialized. The amount of
memory used by a declaration is the size of the base-type times the
number of values of this type. 

<<Make memory declarations>>=
let memdecl (env:F.env) target asm t size ini = 
    let sizeof  = astwidth env t / target.Target.memsize          in
    let const e = Bits.U.to_int (compile_const env target e)     in
    let n      = ( match size with
                 | A.DynSize    -> init_size ini
                 | A.NoSize     -> 1
                 | A.FixSize(e) -> const e
                 ) in
        ( match ini with
        | None    -> asm#zeroes (n * sizeof)
        | Some ii -> init env target asm ii
        )
@

Data can be declared globally inside a section or a section-level
[[span]] and locally, inside a procedure as [[stackdata]].  The former
is directly translated into assembly action that reserve memory inside
a section, the latter becomes just an amount of memory that is
allocated inside a procedure's activation record.  Since the amount of
stack allocated data and the offsets associated with labels inside of
it are already entered into the fat environment (by
[[Elab.Check.stackdatum]]), stack data declaration can be ignored. 
Global data declarations, on the other hand, must be translated to
assembly actions.
 
<<Make memory declarations>>=
let rec datum env target asm = function
    | A.DatumAt(x,_)        -> datum env target asm x
    | A.Label(n)            -> let s = match F.findv n env with
                               | _,(F.Label(F.Data(s)),_) -> s 
                               | _ -> assert false in 
                               asm#label s
    | A.Align(a)            -> asm#align a 
    | A.MemDecl(t,m,init)   -> memdecl env target asm t m init
@

 
% ------------------------------------------------------------------ 
\subsection{Toplevel}
% ------------------------------------------------------------------ 

All global declarations have been processed at this stage and thus can
be ignored.  The only exception are (global) register declarations. 
Global registers can name a hardware register they are placed in.  We
need ia way to record such an assignment.  All other locations for
global registers are determined by an automaton, see module
\module{callconv}. 

A [[span]] on the section level must be pushed to the statement level: 
when we come across a [[span]] we modify the properties [[spans]]
accordingly.  The next time we come across a procedure, the properties
including the span will be used.

<<Make toplevel>>=
let rec sspan spans env target optimizer asm (e1,e2,ss) =    
    let key   = compile_const env target      e1 in
    let value = link_const    env target  e2 in
    let spans = (key,value) :: spans             in
        List.iter (section spans env target optimizer asm) ss 

<<Make toplevel>>=
and section spans env target optimizer asm = function
    | A.SectionAt(x,_)     -> section spans env target optimizer asm x
    | A.Decl(d)            -> ()
    | A.Datum( d)          -> datum         env target asm d
    | A.Procedure(p)       -> proc    spans env target optimizer p
    | A.SSpan ss           -> sspan   spans env target optimizer asm ss
@            

What to do with top-level procedures? They should go into some section
because otherwise they will end up in whatever section is currently
active which just seems wrong.

<<Make toplevel>>=
let rec toplevel env target optimizer asm = function
    | A.ToplevelAt(x, _)  -> toplevel env target optimizer asm x
    | A.Section(name, ss) -> 
        let () = asm#section (name)in  
            List.iter (section [] env target (*props*) optimizer asm) ss
    | A.TopDecl(d)        -> ()
    | A.TopProcedure(p)   -> let () = asm#section default_section  in 
                             proc [] env target optimizer p
@


% ------------------------------------------------------------------ 
\subsubsection{Program}
% ------------------------------------------------------------------ 

The assembler maintains a current section. To guarantee that
everything goes into a meaningful section, the first action is to
start the [[text]] section.
                      
<<Make translate program>>=
let program env target asm optimizer tt = 
    let () = asm#section "text"           in
        List.iter (toplevel env target optimizer asm) tt
@

The finger print [[disgest]] for global register declarations is a 16
character long string of unprintable characters. We make it printable by
applying the {\ocaml} escaping rules. Note: this symbol
should be exported but currently it is not.

\begin{quote}\it
    The memory block for global registers should go into one compilation
    unit and be imported by all others. Currently we just emit it
    because we are far from linking several {\PAL} compilation units.
    This has to be fixed. --CL
\end{quote}

<<Make translate program>>=
let translate env target ~optimizer prog =
    let base_sym = F.symbol env "Cmm_private_global_area" in
    let base     = Rtl.link base_sym target.Target.pointersize in 
    let env
       ,area    
       ,digest   = globals env target base (F.globals env) in
    let digest   = String.escaped digest in
    let asm      = F.asm env in
    let ()       = ( () (* asm#export digest *)
                   ; asm#section (target.Target.data_section)
                   ; asm#comment "memory for global registers"
                   ; asm#align (Block.alignment area)
                   ; asm#label base_sym
                   ; asm#addloc (Block.size area)
                   )
    in   
        ( program env target asm optimizer prog 
        ; asm
        )
@    
