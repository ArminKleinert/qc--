
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Translation to Intermediate Representation}
% ------------------------------------------------------------------ 

<<ast3ir.ml>>=
module Target   = Target2
module A        = Ast
module T        = Types
module E        = Error
module F        = Fenv.Clean
module StrMap   = Map.Make(struct type t=string let compare=compare end)

<<auxilliaries>>
<<ExprTypes>>

module Make
    (G:     Cfg3.S)
    (Asm:   Asm2.S with type instruction = G.t
                   with type init        = unit) = 
struct
    <<Make expressions>>
    <<Make constant evaluation>>
    <<Make auxilliaries>>
    <<Make continuation bundles>>
    <<Make assignment>>    
    <<Make global registers>>    
    <<Make formals and actuals>>    
    <<Make statements>>
    <<Make stack data declarations>>
    <<Make procedure>>
    <<Make memory declarations>>
    <<Make toplevel>>
    <<Make translate program>>
end
@

% ------------------------------------------------------------------
\subsection{Auxilliaries}
% ------------------------------------------------------------------ 

<<auxilliaries>>=
let default_cc          = "C--"
let default_space       = ('m':Rtl.space)
let default_section     = "text"

(* the @ is required by NOWEB and not part of the operator! *)
let (@<<) f g = fun x -> f (g x) (* function composition *)

(* val width : 'a T.t -> 'a *)
let width = function
    | T.Bits n -> n
    | _        -> Impossible.impossible "ast3ir.width"

(* val astty : F.env -> A.ty -> Types.ty *)
let rec astty env = function
    | A.TyAt(x,r)  -> astty env x
    | A.BitsTy(n)  -> Types.bits n
    | A.AliasTy(x) -> snd (F.findt x env)

(* val astwidth : F.env -> A.ty -> int *)
let astwidth env = width @<< (astty env) 

let foldl = List.fold_left
let foldr = List.fold_right
@


% ------------------------------------------------------------------ 
\subsection{Expression Types}
% ------------------------------------------------------------------ 

<<ExprTypes body>>=

let rec astFetch env target = function
    | A.LValueAt(x,r)   -> astFetch env target x
    | A.Var(hint,id)    -> (match F.findv id env with (attr,(_,t)) -> t)
    | A.Mem(ty,e,align) -> 
        let et = expr env target e      in
        let t  = astty env ty           in
        let a  = Aux.Option.get 1 align in
            t
@

The types for primitive operators are looked up in the [[Value]]
model.  This is a hack; we need a model for run-time primitive
operators. 

<<ExprTypes body>>=
and primOp env target op args =
    let argtys = List.map (expr env target) args     in
    let opty   = snd (Value.Ops.lookup op Value.ops) in (*XXX*)
        Types.appl opty argtys 
            
and expr env target exp =
    let word          = T.bits target.Target.wordsize in
    let optty default = function
        | None    -> default
        | Some t  -> astty env t       
    in match exp with
        | A.ExprAt(x,r)     -> expr env target x
        | A.Int   (_,ty)    -> optty word ty
        | A.Float (_,ty)    -> optty word ty
        | A.Char  (_,ty)    -> optty word ty
        | A.Fetch (v)       -> astFetch env target v
        | A.BinOp (l,op,r)  -> primOp env target op [l;r]
        | A.UnOp  (op,e)    -> primOp env target op [e]
        | A.PrimOp(op,args) -> primOp env target op (List.map snd args)


<<ExprTypes>>=
module ExprTypes = struct
    <<ExprTypes body>>
end
@

% ------------------------------------------------------------------ 
\subsection{Make}
% ------------------------------------------------------------------ 

<<Make auxilliaries>>=
let (++)           = Asm.append
let idwidth id env = match F.findv id env with (attr,(_,t)) -> width t
@


% ------------------------------------------------------------------ 
\subsection{Expression Translation}
% ------------------------------------------------------------------ 

Expressions denotes values, represented by compile-time, link-time, or
run-time values.  The translation of a variable depends on its
denotation. 

\begin{quote}\it
    \begin{enumerate}
        \item Translation of primitive operators needs fix.
        \item Translation of variables denoting stack labels missing.
    \end{enumerate} --CL
\end{quote}

Lookup for operations is a hack; we need a module for primitive
operators.

<<Make expressions>>=
let rec fetch env target = function
    | A.LValueAt(x,_) -> fetch env target x
    | A.Var(hint,x)   -> variable env target hint x
    | A.Mem(t,e,a)    -> 
        let width = astwidth env t in
        let cell  = 
            Rtl.cell
                (match a with None -> Rtl.none | Some n -> Rtl.aligned n)
                default_space  (* m *) 
                target.Target.byteorder
                width
                (expr env target e)
        in
            Rtl.fetch cell width     

and variable env target hint x =
    let (_,(denot,t)) = F.findv x env in
    ( match denot with
    | F.Constant(bits)  -> Rtl.bits bits (width t)
    | F.Label(F.Proc _) -> Rtl.link x (width t)
    | F.Label(F.Code)   -> Rtl.link x (width t)
    | F.Label(F.Data  ) -> Rtl.link x (width t)
    | F.Import(None)    -> Rtl.link x (width t)
    | F.Import(Some n)  -> Rtl.link n (width t)
    | F.Continuation    -> Impossible.impossible "Ast3ir.Make.variable cont"
    | F.Label(F.Stack(Some loc)) -> Rtl.fetch loc (width t)
    | F.Label(F.Stack(None))  -> Impossible.impossible "Ast3ir.Make.variable"

    
    | F.Register({F.loc=Some l}) -> Alloc.Reg.fetch l (width t)
    | F.Register({F.index=i;F.loc=None}) ->
        (* local register in memory, ignoring hint *)
        if F.is_localv x env then
            let w = width t in
            Rtl.fetch (Rtl.var x i w) w
        else (* global register without location *)
            Impossible.impossible "Ast3ir.Make.variable"
    )
    
and prim env target op args =
    let argtys  = List.map (ExprTypes.expr env target) args in
    let opty    = snd (Value.Ops.lookup op Value.ops)      in (*XXX*)
    let widths  = Types.widthlist opty argtys               in
        Rtl.app (Rtl.opr op widths) (List.map (expr env target) args)

and expr env target exp = 
    let word = target.Target.wordsize in
    let const default_width = function
        | Some ty -> astwidth env ty
        | None    -> default_width
    in match exp with
        | A.ExprAt(x,_)     -> expr env target x
        | A.Int(bits,t)     -> Rtl.bits bits (const word t)
        | A.Float(bits,t)   -> Rtl.bits bits (const word t)
        | A.Char(bits,t)    -> Rtl.bits bits (const word t)
        | A.Fetch(v)        -> assert false
        | A.BinOp (l,op,r)  -> prim env target op [l;r]
        | A.UnOp  (op,e)    -> prim env target op [e]
        | A.PrimOp(op,args) -> prim env target op (List.map snd args)
@

% ------------------------------------------------------------------ 
\subsection{Constant Evaluation}
% ------------------------------------------------------------------ 

<<Make constant evaluation>>=
let compile_const env target exp =
    try 
        Rtleval.compile Rtleval.empty (expr env target exp)
    with 
        Rtleval.Not_constant -> 
                Impossible.unimp "compile time expression not constant"
        
let link_const env target exp =
    Rtleval.link Rtleval.empty (expr env target exp)
@


% ------------------------------------------------------------------ 
\subsection{Continuation Bundles}
% ------------------------------------------------------------------ 

<<Make continuation bundles>>=
let continuations ast cfg =
    let lookup = List.map (G.lookup cfg)  in
    let rec loop conts = function
        | (A.FlowAt(f,_)):: ff -> 
            loop conts (f::ff)
        | (A.CutsTo n)   :: ff -> 
            loop {conts with G.cuts    = lookup n @ conts.G.cuts   } ff
        | (A.UnwindsTo n):: ff -> 
            loop {conts with G.unwinds = lookup n @ conts.G.unwinds} ff
        | (A.ReturnsTo n):: ff -> 
            loop {conts with G.returns = lookup n @ conts.G.returns} ff
        | (A.Aborts)     :: ff -> 
            loop {conts with G.aborts   = true                     } ff 
        | []                   -> conts in
    let empty =
        { G.cuts = []; G.unwinds = []; G.returns = []; G.aborts = false
        } 
    in
        loop empty ast
@

% ------------------------------------------------------------------ 
\subsection{Assignment}
% ------------------------------------------------------------------ 

<<Make assignment>>=
let rec assign env target lhs exp = match lhs with
    | A.LValueAt(lhs,_) -> assign env target lhs exp
    | A.Var(hint,x) ->
        let (_,(denot,t)) = F.findv x env in
        let w = width t                   in
            ( match denot with
            | F.Register({F.loc=Some l}) -> Alloc.Reg.store l exp w
            | F.Register({F.index=i;F.loc=None}) ->
                if F.is_localv x env then
                    Rtl.store (Rtl.var x i w) exp w
                else 
                    Impossible.impossible "Ast3ir.Make.assign"
            | _ -> assert false (* impossible *)
            )
    | A.Mem(t,addr,align) ->
        let w     = astwidth env t in
        let cell  = 
            Rtl.cell
                (match align with None -> Rtl.none | Some n -> Rtl.aligned n)
                default_space  (* m *) 
                target.Target.byteorder
                w
                (expr env target addr)                        
        in
            Rtl.store cell exp w
@

% ------------------------------------------------------------------
\subsection{Formal and Actual Parameters}
% ------------------------------------------------------------------ 

<<Make formals and actuals>>=
let actual env target (hint, e) =
    let w   = width (ExprTypes.expr env target e) in
    let exp = expr env target e           in
        (exp, w, hint) 
@

\begin{quote}\it
    As NR pointed out, hints on global registers have no semantics in 
    {\qcc}. They thus must be ignored when computing parameter
    passing. --CL
\end{quote} 

<<Make formals and actuals>>=
let formal env (khint, n) = (* for continuations *)
    ( match snd (F.findv n env) with 
    | (F.Register {F.index=i;F.loc=None},ty) when F.is_localv n env  -> 
        { G.repr  = G.Local (n)
        ; G.width = width ty
        ; G.hint  = khint  
        } 
    | (F.Register {F.loc=Some l},ty) -> 
        { G.repr  = G.Global (l)
        ; G.width = width ty
        ; G.hint  = khint  
        } 
    | _ -> assert false
    )

let procformal env (hint, inv, ty, name) = (* where goes the invariant??*)
    { G.repr  = G.Local(name)
    ; G.width = astwidth env ty
    ; G.hint  = hint
    }  
@
    

% ------------------------------------------------------------------ 
\subsection{Global Registers}
% ------------------------------------------------------------------ 

The global registers of a {\PAL} program are assigned to hardware
register or memory locations using a target specific automaton.  Each
assignment results in an abstract [[Alloc.Reg.loc]] value that is
entered under the name of the register to a map.
 
The [[globals]] function pushes all global registers through a target
specific automaton to obtain locations for each of them.  A location
is added to a register's denoation in the environment.  The updated
environment plus the area of memory that hold global registers.

<<Make global registers>>=
let globals env target (base:Rtl.exp) names =
    let t = Alloc.Reg.mk target.Target.globals base in
    let hint = function
        | F.RReg x -> Some x
        | _        -> None
    in 
    let rec assign env n =
        try 
            ( match F.findv n env with
            | (rgn,(F.Register(reg),ty)) ->
                let loc   = Alloc.Reg.ty t (width ty) (hint reg.F.rhint) in
                let entry = ( rgn
                            , (F.Register({reg with F.loc = Some loc}),ty)
                            ) in F.rebindv n entry env
            | _ -> Impossible.impossible "Ast3ir.Make.globals"
            )
        with Error.ErrorExn msg -> Impossible.impossible msg
    in
    let env = List.fold_left assign env names in
        env, Alloc.Reg.freeze t    
@


% ------------------------------------------------------------------ 
\subsection{Statements}
% ------------------------------------------------------------------ 

<<Make statements>>=
type state =
    { env:          F.env
    ; target:       Target.t
    ; cfg:          G.t
    ; node:         G.node
    ; outbase:      Rtl.exp
    ; inbase:       Rtl.exp
    ; stackdata:    Alloc.area
    ; outgoing:     Alloc.area list
    ; incoming:     Alloc.area list
    }

let rec stmt s state = match s with
    | A.StmtAt(x,r)        -> stmt x state 
    | A.SpanStmt    x      -> spanStmt      state x
    | A.IfStmt      x      -> ifStmt        state x
    | A.SwitchStmt  x      -> switchStmt    state x
    | A.LabelStmt   x      -> labelStmt     state x
    | A.ContStmt    x      -> contStmt      state x
    | A.AssignStmt  x      -> assignStmt    state x
    | A.CallStmt    x      -> callStmt      state x
    | A.PrimStmt    x      -> primStmt      state x
    | A.GotoStmt    x      -> gotoStmt      state x
    | A.JumpStmt    x      -> jumpStmt      state x
    | A.CutStmt     x      -> cutStmt       state x
    | A.ReturnStmt  x      -> returnStmt    state x 
    | A.EmptyStmt          -> state     
    | A.CommentStmt _      -> state    

and body b state = match b with
    | A.BodyAt(x, _)        -> body x state
    | A.DeclBody(d)         -> state (* nothing to be done *)
    | A.StmtBody(s)         -> stmt s state 
    | A.DataBody(dd)        -> state (* aleady done *)
    

and labelStmt state x =
    let _   = G.set_label state.cfg x state.node in
        state    

and ifStmt state (e,ifso,ifnot) =
    let left  = foldr body ifso  state  in
    let right = foldr body ifnot left  in
    let exp   = expr state.env state.target e in
    let rtl   = state.target.Target.mkBranch exp in
        { right with node = 
          G.gm_branch state.cfg rtl left.node right.node
        }

and assignStmt state (lhs,rhs) =
    let effect lhs (guard,rhs) =
        let exp = expr   state.env state.target rhs     in
        let rtl = assign state.env state.target lhs exp in 
            ( match guard with
            | None   -> rtl
            | Some g -> Rtl.guard 
                            (expr state.env state.target g) rtl
            ) 
    in
    let rtl = Rtl.par (List.map2 effect lhs rhs) in
        { state with node = G.gm_assign state.cfg rtl state.node }
             
and gotoStmt state (e,labels) =
    let exp   = expr state.env state.target e  in
    let rtl   = state.target.Target.mkGoto exp               in
    let nodes = List.map (G.lookup state.cfg) labels         in
        {state with node = G.gm_goto state.cfg rtl nodes}

and jumpStmt state (cconv,e,args,labels) =
    let exp     = expr state.env state.target e    in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let atm     = Alloc.Reg.mk cc.Target.proc state.outbase     in
    let rtl     = state.target.Target.mkJump exp                 in
    let args    = List.map 
                        (actual state.env state.target) args in
    let nodes   = List.map (G.lookup state.cfg) labels           in
    let rtl     = state.target.Target.mkJump exp                 in
    let jmp     = G.gm_jump state.cfg rtl nodes                  in
        if args = [] then (* no copyout nodes *)
            { state with node = jmp }
        else
            let node, atm =  G.gm_copyo state.cfg args atm jmp in
            { state with
                node     = node
            ;   outgoing = Alloc.Reg.freeze atm :: state.outgoing
            }  
@

The copy-out code must honor the hints attached to the actual
parameters, the copy-in code the hints on the l-lvalues.  The
[[formal]] function translate these into a format suitable for the
automaton that guides the parameter passing.

<<Make statements>>=
and callStmt state (lhs,cconv, e, args, targets, conts) = 
    let rec lvalue = function
        | A.LValueAt(x,_) -> lvalue x
        | A.Var x         -> formal state.env x 
        | A.Mem _         -> assert false                        in
    let exp     = expr state.env state.target e    in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let atmo    = Alloc.Reg.mk cc.Target.proc state.outbase   in
    let atmi    = Alloc.Reg.mk cc.Target.ret  state.outbase   in
    let rtl     = state.target.Target.mkCall exp                 in
    let args    = List.map 
                  (actual state.env state.target) args in
    let nodes   = List.map (G.lookup state.cfg) targets          in
    let conts   = continuations conts state.cfg                  in
    let rtl     = state.target.Target.mkCall exp                 in
    (* linking nodes from back to front: copyin<-call<-copyout *) 
    let copyi,atmi = G.gm_copyi state.cfg 
                        (List.map lvalue lhs) atmi state.node    in
    let call       = G.gm_call state.cfg rtl conts copyi in
    let copyo,atmo = G.gm_copyo state.cfg args atmo call in
        { state with
            node     = copyo
        ;   outgoing = Alloc.Reg.freeze atmo :: state.outgoing
        ;   incoming = Alloc.Reg.freeze atmi :: state.incoming
        }  

and returnStmt state (cconv, kont, args) =
    let const e   = Bits.to_int (compile_const state.env state.target e)     in
    let cc        = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let atm       = Alloc.Reg.mk cc.Target.ret state.inbase                 in
    let (x,y)     = match kont with
                    | None       -> (0,0) (* default *)
                    | Some (x,y) -> (const x, const y) in
    let rtl       = cc.Target.return                                         in
    let args      = List.map
                    (actual state.env state.target) args       in
    let ret       = G.gm_return state.cfg rtl (x, y)   in
    let copyo,atm = G.gm_copyo state.cfg args atm ret                        in
        { state with
            node     = ret
        ;   outgoing = Alloc.Reg.freeze atm :: state.outgoing
        }


and contStmt state (label,args)  =
    let cc        = state.target.Target.cc default_cc               in
    let args      = List.map (formal state.env) args in
    let atm       = Alloc.Reg.mk cc.Target.cont state.inbase       in
    let copyi,atm = G.gm_copyi state.cfg args atm state.node        in
    let _         = G.set_label state.cfg label copyi               in
        { state with
            node     = copyi
        ;   incoming = Alloc.Reg.freeze atm :: state.incoming
        }

and cutStmt state (e, args, conts) = 
    let cc        = state.target.Target.cc default_cc                  in
    let args      = List.map 
                    (actual state.env state.target) args in
    let atm       = Alloc.Reg.mk cc.Target.cont state.outbase         in
    let exp       = expr state.env state.target e        in
    let rtl       = state.target.Target.mkCutto exp                    in
    let conts     = continuations conts state.cfg                      in
    let cut       = G.gm_cutto state.cfg rtl conts                     in
    let copyo,atm = G.gm_copyo state.cfg args atm cut                  in
        { state with
            node     = cut
        ;   incoming = Alloc.Reg.freeze atm :: state.outgoing
        }

and primStmt      state x  = Impossible.unimp "primitive"
and spanStmt      state x  = Impossible.unimp "span"
and switchStmt    state x  = Impossible.unimp "switch"
@

% ------------------------------------------------------------------ 
\subsection{Procedure Translation}
% ------------------------------------------------------------------ 

(* where to invoke 
        - code expansion 
        - liveness analysis 
        - register allocation ?
*)

<<Make procedure>>=
let proc env target (*props*) asm (cconv,name,args,bdy) = 
    let cfg            = G.mk ()   in 
    let sdbase         = Rtl.link "stack data" target.Target.pointersize in
    let env, stackdata = StackData.proc env target sdbase bdy in
    let state = 
        { env       = env
        ; target    = target
        ; cfg       = cfg
        ; node      = G.exit cfg
        ; stackdata = stackdata
        ; incoming  = []    
        ; outgoing  = []
        ; inbase    = Rtl.link "inbase" target.Target.pointersize (*XXX*)
        ; outbase   = Rtl.link "outbase" target.Target.pointersize (*XXX*)
        } in  
    let state = foldr body bdy state in
    let cc    = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let atmi  = Alloc.Reg.mk cc.Target.proc  state.outbase   in
    let args  = List.map (procformal state.env) args in
    let copyi,atmi = G.gm_copyi state.cfg args atmi state.node    in
    let state = 
        { state with    
          node     = copyi
        ; incoming = Alloc.Reg.freeze atmi :: state.incoming
        } in
    let _     = G.gm_redirect_all (G.entry cfg) (G.exit cfg) state.node in
    (* what to do with all the areas for stack data, parameter passing?
    *)
        asm ++ Asm.instr cfg
@
        
   
% ------------------------------------------------------------------ 
\subsection{Global Memory declarations}
% ------------------------------------------------------------------ 

<<Make memory declarations>>=
(*XXX*)
let initialized_data asm expr = 
    Impossible.unimp "initialized data in global memory declaration"

(*XXX*)    
let rec init env target asm = function
    | A.InitAt(x,_)   -> init env target asm x
    | A.InitExprs(es) -> foldl initialized_data asm es
    | A.InitStr(s)    -> Impossible.unimp "initialized data in global memory declaration"
    | A.InitUStr(s)   -> Impossible.unimp "initialized data in global memory declaration"
@

In order to reserve memory for data we have to know how many objects
an sequence of initializing expressions defined. This number is
returned by [[init_size]].

<<Make memory declarations>>=
let rec init_size = function
    | None   -> 1
    | Some i -> let rec loop = function 
                    | A.InitAt(x,_)   -> loop x
                    | A.InitExprs(es) -> List.length es
                    | A.InitStr(s)    -> assert false
                    | A.InitUStr(s)   -> assert false
                in 
                    loop i 
@

Data can be declared initialized or un-initialized. The amount of
memory used by a declaration is the size of the base-type times the
number of values of this type. 

<<Make memory declarations>>=
let memdecl (env:F.env) target asm t size ini = 
    let sizeof  = astwidth env t / target.Target.memsize          in
    let const e = Bits.to_int (compile_const env target e)     in
    let n      = ( match size with
                 | A.DynSize    -> init_size ini
                 | A.NoSize     -> 1
                 | A.FixSize(e) -> const e
                 ) in
        ( match ini with
        | None    -> asm ++ Asm.zeroes (n * sizeof)
        | Some ii -> init env target asm ii
        )
@

Data can be declared globally inside a section or a section-level
[[span]] and locally, inside a procedure as [[stackdata]].  The former
is directly translated into assembly action that reserve memory inside
a section, the latter becomes just an amount of memory that is
allocated inside a procedure's activation record.  Since the amount of
stack allocated data and the offsets associated with labels inside of
it are already entered into the fat environment (by
[[Elab.Check.stackdatum]]), stack data declaration can be ignored. 
Global data declarations, on the other hand, must be translated to
assembly actions.
 
<<Make memory declarations>>=
let rec datum env target asm = function
    | A.DatumAt(x,_)        -> datum env target asm x
    | A.Label(n)            -> asm ++ Asm.define_local (Asm.mksym n)
    | A.Align(a)            -> asm ++ Asm.align a 
    | A.MemDecl(t,m,init)   -> memdecl env target asm t m init
@

% ------------------------------------------------------------------ 
\subsection{Stack Data Declarations}
% ------------------------------------------------------------------ 

<<Make stack data declarations>>=
module StackData = struct 

    type state = 
        { env:    F.env
        ; mem:    Alloc.Mem.t
        ; target: Target.t
        }

    let stackdatum state = function
        | A.Label(l) -> 
            let loc = Alloc.Mem.location state.mem in
                ( match F.findv l state.env with
                | (r,(F.Label(F.Stack(None)),t)) ->
                    { state with env = 
                        F.rebindv l (r,(F.Label(F.Stack(Some loc)),t)) 
                                  state.env
                    }
                | _ -> assert false
                )
        | A.Align n -> { state with mem = Alloc.Mem.align n state.mem} 
        | A.MemDecl(ty,size,None) ->
            let w = astwidth state.env ty in
            let s = ( match size with 
                    | A.NoSize     -> 1 
                    | A.DynSize    -> assert false (* impossible *)
                    | A.FixSize(e) -> 
                        Bits.to_int (compile_const state.env state.target e)
                    ) in
            let n = s * w / state.target.Target.memsize in
                { state with mem = Alloc.Mem.alloc n state.mem} 
                    
        | _ -> assert false (* illegal memory initializer *)

    let rec stmt state = function 
        | A.StmtAt(x,r)        -> stmt state x
        | A.SpanStmt    x      -> spanStmt      state x
        | A.IfStmt      x      -> ifStmt        state x
        | A.SwitchStmt  x      -> switchStmt    state x
        | _                    -> state

    and body state = function 
        | A.BodyAt(x, _)        -> body state x
        | A.DeclBody(d)         -> state (* nothing to be done *)
        | A.StmtBody(s)         -> stmt state s 
        | A.DataBody(data)      -> foldl stackdatum state data

    and ifStmt state (e,ifso,ifnot) =
        let left  = foldl body state  ifso  in
        let right = foldl body left   ifnot in
            state

    and spanStmt      state x  = Impossible.unimp "span"
    and switchStmt    state x  = Impossible.unimp "switch"

    let proc env target base bb =
        let state = 
            { env    = env
            ; target = target
            ; mem    = Alloc.Mem.mk base
            } in
        let state' = foldl body state bb in 
                (state.env, Alloc.Mem.freeze state.mem)

end (* of module StackData *)
@
    
% ------------------------------------------------------------------ 
\subsection{Toplevel}
% ------------------------------------------------------------------ 

All global declarations have been processed at this stage and thus can
be ignored.  The only exception are (global) register declarations. 
Global registers can name a hardware register they are placed in.  We
need ia way to record such an assignment.  All other locations for
global registers are determined by an automaton, see module
\module{callconv}. 

A [[span]] on the section level must be pushed to the statement level: 
when we come across a [[span]] we modify the properties [[props]]
accordingly.  The next time we come across a procedure, the properties
including the span will be used.

<<Make toplevel>>=
let rec sspan env target asm (e1,e2,ss) =    
    let key   = compile_const env target e1 in
    let value = link_const    env target e2 in
    (* construct props value, pass it to section. not implemented *)
        foldl (section env target) asm ss 

<<Make toplevel>>=
and section env target (asm: Asm.asm) = function
    | A.SectionAt(x,_)     -> section env target asm x
    | A.Decl(d)            -> asm
    | A.Datum( d)          -> datum   env target asm d
    | A.Procedure(p)       -> proc    env target asm p
    | A.SSpan ss           -> sspan   env target asm ss
@            

What to do with top-level procedures? They should go into some section
because otherwise they will end up in whatever section is currently
active which just seems wrong.

<<Make toplevel>>=
let rec toplevel env target asm = function
    | A.ToplevelAt(x, _)  -> toplevel env target asm x
    | A.Section(name, ss) -> 
        let asm = asm ++ Asm.section name in  
            foldl (section env target (*props*)) asm ss
    | A.TopDecl(d)        -> asm (* nothing to do here *)
    | A.TopProcedure(p)   -> let asm = asm ++ Asm.section default_section  
                             in proc env target (*props*) asm p
@


% ------------------------------------------------------------------ 
\subsubsection{Program}
% ------------------------------------------------------------------ 

Imports and exports of assembly symbols are announced once at the top
of the assembly program.  The sets of imported and exported symbols
are registered in the fat environment.  For details, see modules
\module{mangle}, and \module{elab}. 

<<Make translate program>>=
let exports env asm = 
    Fenv.StrSet.fold (fun s asm -> asm ++ Asm.export (Asm.mksym s)) 
    (F.exported env) asm

let imports env asm =
    Fenv.StrSet.fold (fun s asm -> asm ++ Asm.import (Asm.mksym s)) 
    (F.imported env) asm
@

The assembler maintains a current section. To guarantee that
everything goes into a meaningful section, the first action is to
start the [[text]] section.


<<Make translate program>>=
let program env target asm tt = 
    let asm = asm ++ Asm.section "text"           in
    let asm = exports env asm                     in
    let asm = imports env asm                     in
        foldl (toplevel env target) asm tt

let translate env target prog =
    let base     = Rtl.link "global_base" target.Target.pointersize in (*XXX*)
    let env,area = globals env target base (F.globals env) in
                   (*XXX where does area go?*)
    let asm      = Asm.init () in
        program env target asm prog  (* asm *)
@    
