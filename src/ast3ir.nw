
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Translation to Intermediate Representation}
% ------------------------------------------------------------------ 

<<ast3ir.ml>>=
module Target   = Target2
module A        = Ast
module T        = Types
module E        = Error
module F        = Fenv.Clean
module StrMap   = Map.Make(struct type t=string let compare=compare end)

<<auxilliaries>>
<<ExprTypes>>

module Make
    (G:     Cfg3.S)
    (Asm:   Asm2.S with type instruction = G.t
                   with type init        = unit) = 
struct
    <<Make expressions>>
    <<Make auxilliaries>>
    <<Make continuation bundles>>
    <<Make assignment>>    
    <<Make global registers>>    
    <<Make formals and actuals>>    
    <<Make statements>>
    <<Make>>
end
@

<<Make>>=
(*Make*)
@

% ------------------------------------------------------------------
\subsection{Auxilliaries}
% ------------------------------------------------------------------ 

<<auxilliaries>>=
let default_cc          = "C--"
let default_space       = ('m':Rtl.space)
let default_section     = "text"

(* the @ is required by NOWEB and not part of the operator! *)
let (@<<) f g = fun x -> f (g x) (* function composition *)

(* val width : 'a T.t -> 'a *)
let width = function
    | T.Bits n -> n
    | _        -> Impossible.impossible "ast3ir.width"

(* val astty : F.env -> A.ty -> Types.ty *)
let rec astty env = function
    | A.TyAt(x,r)  -> astty env x
    | A.BitsTy(n)  -> Types.bits n
    | A.AliasTy(x) -> snd (F.findt x env)

(* val astwidth : F.env -> A.ty -> int *)
let astwidth env = width @<< (astty env) 

let foldl = List.fold_left
let foldr = List.fold_right

(* evaluation of constant expressions - bogus *)

let eval_const e = 123 (*XXX*)
@

% ------------------------------------------------------------------ 
\subsection{Expression Types}
% ------------------------------------------------------------------ 

<<ExprTypes body>>=

let rec astFetch env target = function
    | A.LValueAt(x,r)   -> astFetch env target x
    | A.Var(hint,id)    -> (match F.findv id env with (attr,(_,t)) -> t)
    | A.Mem(ty,e,align) -> 
        let et = expr env target e      in
        let t  = astty env ty           in
        let a  = Aux.Option.get 1 align in
            t
@

The types for primitive operators are looked up in the [[Value]]
model.  This is a hack; we need a model for run-time primitive
operators. 

<<ExprTypes body>>=
and primOp env target op args =
    let argtys = List.map (expr env target) args     in
    let opty   = snd (Value.Ops.lookup op Value.ops) in (*XXX*)
        Types.appl opty argtys 
            
and expr env target exp =
    let word          = T.bits target.Target.wordsize in
    let optty default = function
        | None    -> default
        | Some t  -> astty env t       
    in match exp with
        | A.ExprAt(x,r)     -> expr env target x
        | A.Int   (_,ty)    -> optty word ty
        | A.Float (_,ty)    -> optty word ty
        | A.Char  (_,ty)    -> optty word ty
        | A.Fetch (v)       -> astFetch env target v
        | A.BinOp (l,op,r)  -> primOp env target op [l;r]
        | A.UnOp  (op,e)    -> primOp env target op [e]
        | A.PrimOp(op,args) -> primOp env target op (List.map snd args)


<<ExprTypes>>=
module ExprTypes = struct
    <<ExprTypes body>>
end
@

% ------------------------------------------------------------------ 
\subsection{Make}
% ------------------------------------------------------------------ 

<<Make auxilliaries>>=
let (++)           = Asm.append
let idwidth id env = match F.findv id env with (attr,(_,t)) -> width t
@


% ------------------------------------------------------------------ 
\subsection{Expression Translation}
% ------------------------------------------------------------------ 

Expressions denotes values, represented by compile-time, link-time, or
run-time values.  The translation of a variable depends on its
denotation. 

\begin{quote}\it
    \begin{enumerate}
        \item Translation of primitive operators needs fix.
        \item Translation of variables denoting stack labels missing.
    \end{enumerate} --CL
\end{quote}

Lookup for operations is a hack; we need a module for primitive
operators.

<<Make expressions>>=
let rec fetch env target globals = function
    | A.LValueAt(x,_) -> fetch env target globals x
    | A.Var(hint,x)   -> variable env target globals hint x
    | A.Mem(t,e,a)    -> 
        let width = astwidth env t in
        let cell  = 
            Rtl.cell
                (match a with None -> Rtl.none | Some n -> Rtl.aligned n)
                default_space  (* m *) 
                target.Target.byteorder
                width
                (expr env target globals e)
        in
            Rtl.fetch cell width     

(* XXX stack data labels don't work *)
            
and variable env target globals hint x =
    let (_,(denot,t)) = F.findv x env in
    ( match denot with
    | F.Constant(bits)  -> Rtl.bits bits (width t)
    | F.Label(F.Proc _) -> Rtl.link x (width t)
    | F.Label(F.Code)   -> Rtl.link x (width t)
    | F.Label(F.Data)   -> Rtl.link x (width t)
    | F.Import(None)    -> Rtl.link x (width t)
    | F.Import(Some n)  -> Rtl.link n (width t)
    | F.Continuation    -> Impossible.impossible "Ast3ir.Make.variable cont"
    | F.Label(F.Stack(o,l)) -> Impossible.unimp "Ast3ir.Make.variable stack"
    | F.Register({F.index=i;F.rhint=F.RReg(hw)}) ->
        (* global h/w register *)
        Rtl.fetch (target.Target.register hw) (width t) 
    | F.Register({F.index=i;F.rhint=_}) ->
        (* global or local register in memory, ignoring hint *)
        if F.is_localv x env then
            let w = width t in
            Rtl.fetch (Rtl.var x i w) w
        else (* global register in memory *)
            Automaton2.fetch (globals x) (width t)
    )
    
and prim env target globals op args =
    let argtys  = List.map (ExprTypes.expr env target) args in
    let opty    = snd (Value.Ops.lookup op Value.ops)      in (*XXX*)
    let widths  = Types.widthlist opty argtys               in
        Rtl.app (Rtl.opr op widths) (List.map (expr env target globals) args)

and expr env target globals exp = 
    let word = target.Target.wordsize in
    let const default_width = function
        | Some ty -> astwidth env ty
        | None    -> default_width
    in match exp with
        | A.ExprAt(x,_)     -> expr env target globals x
        | A.Int(bits,t)     -> Rtl.bits bits (const word t)
        | A.Float(bits,t)   -> Rtl.bits bits (const word t)
        | A.Char(bits,t)    -> Rtl.bits bits (const word t)
        | A.Fetch(v)        -> assert false
        | A.BinOp (l,op,r)  -> prim env target globals op [l;r]
        | A.UnOp  (op,e)    -> prim env target globals op [e]
        | A.PrimOp(op,args) -> prim env target globals op (List.map snd args)
@


% ------------------------------------------------------------------ 
\subsection{Continuation Bundles}
% ------------------------------------------------------------------ 

<<Make continuation bundles>>=
let continuations ast cfg =
    let lookup = List.map (G.lookup cfg)  in
    let rec loop conts = function
        | (A.FlowAt(f,_)):: ff -> 
            loop conts (f::ff)
        | (A.CutsTo n)   :: ff -> 
            loop {conts with G.cuts    = lookup n @ conts.G.cuts   } ff
        | (A.UnwindsTo n):: ff -> 
            loop {conts with G.unwinds = lookup n @ conts.G.unwinds} ff
        | (A.ReturnsTo n):: ff -> 
            loop {conts with G.returns = lookup n @ conts.G.returns} ff
        | (A.Aborts)     :: ff -> 
            loop {conts with G.aborts   = true                     } ff 
        | []                   -> conts in
    let empty =
        { G.cuts = []; G.unwinds = []; G.returns = []; G.aborts = false
        } 
    in
        loop empty ast
@

% ------------------------------------------------------------------ 
\subsection{Assignment}
% ------------------------------------------------------------------ 

<<Make assignment>>=
let rec assign env target globals lhs exp = match lhs with
    | A.LValueAt(lhs,_) -> assign env target globals lhs exp
    | A.Var(hint,x) ->
        let (_,(denot,t)) = F.findv x env in
        let w = width t                   in
            ( match denot with
            | F.Register({F.index=i;F.rhint=F.RReg(hw)}) ->
                (* global h/w register *)
                Rtl.store (target.Target.register hw) exp w
            | F.Register({F.index=i;F.rhint=_}) ->
                (* global or local register in memory, ignoring hint *)
                if F.is_localv x env then
                    Rtl.store (Rtl.var x i w) exp w
                else (* global register in memory *)
                        Automaton2.store (globals x) exp w
            | _ -> assert false (* impossible *)
            )
    | A.Mem(t,addr,align) ->
        let w     = astwidth env t in
        let cell  = 
            Rtl.cell
                (match align with None -> Rtl.none | Some n -> Rtl.aligned n)
                default_space  (* m *) 
                target.Target.byteorder
                w
                (expr env target globals addr)                        
        in
            Rtl.store cell exp w
@

% ------------------------------------------------------------------
\subsection{Formal and Actual Parameters}
% ------------------------------------------------------------------ 

<<Make formals and actuals>>=
let actual env target globals (hint, e) =
    let w   = width (ExprTypes.expr env target e) in
    let exp = expr env target globals e           in
        (exp, w, hint) 

let formal env n =
    ( match snd (F.findv n env) with 
    | (F.Register {F.index=i; F.rhint=h},ty) when F.is_localv n env  -> 
        { G.name  = n
        ; G.width = width ty
        ; G.hint  = ( match h with
                    | F.RReg _  -> assert false (* impossible *)
                    | F.RHint s -> Some s
                    | F.RNone   -> None
                    )
        ; G.index = i
        } 
    | (F.Register {F.index=i; F.rhint=h},ty) -> assert false 
        (* don't how to to translate global registers *)
    | _ -> assert false
    )
@
    

% ------------------------------------------------------------------ 
\subsection{Global Registers}
% ------------------------------------------------------------------ 

The global registers of a {\PAL} program are assigned to hardware
register or memory locations using a target specific automaton.  Each
assignment results in an abstract [[Automaton2.loc]] value that is
entered under the name of the register to a map.  If a global register
declaration specifies a hardware register the register \emph{is not}
entered into said map.  Since the hardware register is part of the
declaration the [[Rtl.loc]] corresponding to the register can be
looked where it is used.
 
The [[globals]] function returns a map from registers to abstract
locations and the overflow area used to represent global registers.

<<Make global registers>>=
let globals target (base:Rtl.exp) decls =
    let atm = Automaton2.mk target.Target.globals base in
    let rec loop map = function
        | [] -> map
        | (name, F.RNone, t) :: rr -> (* no hint, no h/w register *)
            let loc = Automaton2.ty atm (width t) None  in
            let map = StrMap.add name loc map           in  
                loop map rr
        | (name, F.RHint h, t) :: rr -> (* hint, no h/w register *)
            let loc = Automaton2.ty atm (width t) (Some h)  in
            let map = StrMap.add name loc map               in
                loop map rr
        | (name, F.RReg _, t) :: rr -> (* hardware register - ignore *)
                loop map rr
    in
        loop StrMap.empty decls, Automaton2.freeze atm  
@


% ------------------------------------------------------------------ 
\subsection{Statements}
% ------------------------------------------------------------------ 

<<Make statements>>=

type state =
    { env:      F.env
    ; target:   Target.t
    ; globals:  string -> Automaton2.loc
    ; cfg:      G.t
    ; node:     G.node
    ; outbase:  Rtl.exp
    ; inbase:   Rtl.exp
    ; outgoing: Automaton2.area list
    ; incoming: Automaton2.area list
    }

let rec stmt s state = match s with
    | A.StmtAt(x,r)        -> stmt x state 
    | A.SpanStmt    x      -> spanStmt      state x
    | A.IfStmt      x      -> ifStmt        state x
    | A.SwitchStmt  x      -> switchStmt    state x
    | A.LabelStmt   x      -> labelStmt     state x
    | A.ContStmt    x      -> contStmt      state x
    | A.AssignStmt  x      -> assignStmt    state x
    | A.CallStmt    x      -> callStmt      state x
    | A.PrimStmt    x      -> primStmt      state x
    | A.GotoStmt    x      -> gotoStmt      state x
    | A.JumpStmt    x      -> jumpStmt      state x
    | A.CutStmt     x      -> cutStmt       state x
    | A.ReturnStmt  x      -> returnStmt    state x 
    | A.EmptyStmt          -> state     
    | A.CommentStmt _      -> state    

and body b state = match b with
    | A.BodyAt(x, _)        -> body x state
    | A.DeclBody(d)         -> state (*XXX*)
    | A.StmtBody(s)         -> stmt s state 
    | A.DataBody(dd)        -> state (*XXX*)
    

and labelStmt state x =
    let _   = G.set_label state.cfg x state.node in
        state    

and ifStmt state (e,ifso,ifnot) =
    let left  = foldr body ifso  state  in
    let right = foldr body ifnot left  in
    let exp   = expr state.env state.target state.globals e in
    let rtl   = state.target.Target.mkBranch exp in
        { right with node = 
          G.gm_branch state.cfg rtl left.node right.node
        }

and assignStmt state (lhs,rhs) =
    let effect lhs (guard,rhs) =
        let exp = expr   state.env state.target state.globals rhs     in
        let rtl = assign state.env state.target state.globals lhs exp in 
            ( match guard with
            | None   -> rtl
            | Some g -> Rtl.guard 
                            (expr state.env state.target state.globals g) rtl
            ) 
    in
    let rtl = Rtl.par (List.map2 effect lhs rhs) in
        { state with node = G.gm_assign state.cfg rtl state.node }
             
and gotoStmt state (e,labels) =
    let exp   = expr state.env state.target state.globals e  in
    let rtl   = state.target.Target.mkGoto exp               in
    let nodes = List.map (G.lookup state.cfg) labels         in
        {state with node = G.gm_goto state.cfg rtl nodes}

and jumpStmt state (cconv,e,args,labels) =
    let exp     = expr state.env state.target state.globals e    in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let atm     = Automaton2.mk cc.Target.proc state.outbase     in
    let rtl     = state.target.Target.mkJump exp                 in
    let args    = List.map 
                        (actual state.env state.target state.globals) args in
    let nodes   = List.map (G.lookup state.cfg) labels           in
    let rtl     = state.target.Target.mkJump exp                 in
    let jmp     = G.gm_jump state.cfg rtl nodes                  in
        if args = [] then (* no copyout nodes *)
            { state with node = jmp }
        else
            let node, atm =  G.gm_copyo state.cfg args atm jmp in
            { state with
                node     = node
            ;   outgoing = Automaton2.freeze atm :: state.outgoing
            }  

(* 
 * Both automatons use the same base - correct?
 *)

and callStmt state (lhs,cconv, e, args, targets, conts) = 
    let rec lvalue = function
        | A.LValueAt(x,_) -> lvalue x
        | A.Var(hint,x)   -> formal state.env x
        | A.Mem _         -> assert false                        in
    let exp     = expr state.env state.target state.globals e    in
    let cc      = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let atmo    = Automaton2.mk cc.Target.proc state.outbase   in
    let atmi    = Automaton2.mk cc.Target.ret  state.outbase   in
    let rtl     = state.target.Target.mkCall exp                 in
    let args    = List.map 
                  (actual state.env state.target state.globals) args in
    let nodes   = List.map (G.lookup state.cfg) targets          in
    let conts   = continuations conts state.cfg                  in
    let rtl     = state.target.Target.mkCall exp                 in
    (* linking nodes from back to front: copyin<-call<-copyout *) 
    let copyi,atmi = G.gm_copyi state.cfg 
                        (List.map lvalue lhs) atmi state.node    in
    let call       = G.gm_call state.cfg rtl conts copyi in
    let copyo,atmo = G.gm_copyo state.cfg args atmo call in
        { state with
            node     = copyo
        ;   outgoing = Automaton2.freeze atmo :: state.outgoing
        ;   incoming = Automaton2.freeze atmi :: state.incoming
        }  

(*
 * what's the default for x/y if no pair given given in source?
 *)         
        
and returnStmt state (cconv, kont, args) =
    let cc        = state.target.Target.cc (Aux.Option.get default_cc cconv) in
    let atm       = Automaton2.mk cc.Target.ret state.inbase                 in
    let const n   = A.Int (Bits.of_int n Bits.maxwidth, None) in (*XXX*)
    let (x,y)     = Aux.Option.get (const 0, const 0) kont    in (*XXX*)
    let rtl       = cc.Target.return                                         in
    let args      = List.map
                    (actual state.env state.target state.globals) args       in
    let ret       = G.gm_return state.cfg rtl (eval_const x, eval_const y)   in
    let copyo,atm = G.gm_copyo state.cfg args atm ret                        in
        { state with
            node     = ret
        ;   outgoing = Automaton2.freeze atm :: state.outgoing
        }

(*
 * args = [(hint option,name)]
 * 
 * We have two sources for hints: register declartion AND formal
 * parameters for continuations. Which one should be used/ignored?
 * If there is a problem it must be also corrected in the Eval module.
 *)

and contStmt state (label,args)  =
    let cc        = state.target.Target.cc default_cc               in
    let args      = List.map (fun (_,n) -> formal state.env n) args in
    let atm       = Automaton2.mk cc.Target.cont state.inbase       in
    let copyi,atm = G.gm_copyi state.cfg args atm state.node        in
    let _         = G.set_label state.cfg label copyi               in
        { state with
            node     = copyi
        ;   incoming = Automaton2.freeze atm :: state.incoming
        }


and primStmt      state x  = assert false 
and cutStmt       state x  = assert false 

and spanStmt      state x  = Impossible.unimp "span"
and switchStmt    state x  = Impossible.unimp "switch"
@

% ------------------------------------------------------------------ 
\subsection{Procedure Translation}
% ------------------------------------------------------------------ 

% ------------------------------------------------------------------ 
\subsection{Program Translation}
% ------------------------------------------------------------------ 

