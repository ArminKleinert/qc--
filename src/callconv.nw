
\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Calling Conventions}
% ------------------------------------------------------------------ 

Each target platform requires an implementation of its procedure
calling convention:  which arguments goes into registers and which are
passed on the stack.  Calling convetions also exists for returning
values and passing them to a continuation.  Mark W.~Bailey and Jack
W.~Davidson have shown in \cite{bailey:davidson:95} that the process of
choosing registers to pass values can be modeled with finite state
automata.  The automaton receives a stream of enriched {\PAL} types
and the automaton responds for each data type with a location that the
parameter is passed in.  However, the calling convention includes much
more details like which registers to use as a stack pointer and so on. 
This module provides an unified interface to calling conventions for
all targets.


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface to calling conventions is divided in two parts:  a
general part and a part for using automata for passing values from and
to procedures.  The interface to automata is used to describe the
general interface and thus comes first in the file describing the
interface.

<<callconv.mli>>=
module type S = sig 
    <<module type s>>   (* trick; we don't have an implementation yet *)
end
@

<<module type s>>=
module Automaton : sig
    <<sig automaton>>
end
<<sig general>>
@

% ------------------------------------------------------------------ 
\subsection{General Calling Convention Interface}
% ------------------------------------------------------------------ 

The various aspects of a calling convention are bundled into one type
[[convention]]. The individual components are:

\begin{itemize}
\item The stack pointer [[sp]]. The stack pointer is used to address
      elements of a procedure's activation record at run-time. 
\end{itemize}

<<sig general>>=
type convention = { sp:     Rtl.location
                    (* more to come *)
                  }
@

A platform's calling convention can be accessed directly as a value. 

<<>>=                  
val convention:   convention (* the actual convention *)
@

% ------------------------------------------------------------------ 
\subsection{Interface to Automaton}
% ------------------------------------------------------------------ 

The interface for the calling convention automata serves two purposes: 
construction of automata and using them.  To keep {\qcc} as flexible
as possible, automata for calling conventions are at least in
principle constructed at run-time (of the compiler) and not
hard-wired.  Once an automaton is defined, it is used by the code
generator to find the locations parameters are passed to or from
procedures and continuations.  The difference between these two
aspects of the interface are expressed by using sub-modules for them
in the interface.

<<sig automaton>>=
<<basic types>>

module Run  : sig <<signature run>>   end
module Make : sig <<signature build>> end
@

% ------------------------------------------------------------------ 
\subsubsection{Basic Types}
% ------------------------------------------------------------------ 

Pure {\PAL} data types like [[bits32]] are usually not descriptive
enough to find the location a parameter of that value is passed in. 
Calling conventions usually not only only rely on the size of a
parameter, but to some degree on its purpose, too.  A type from the
perspective of calling conventions is thus a tuple of a {\PAL} type
and a hint:

<<basic types>>= 
type ty = Types.ty * Ast.hint
@

An automaton is used at a caller's side to find the locations 
values to be passed are stored in, and at the callee's side to find
the location incoming parameters are read from. The same situation
arises at a [[return]] and when [[cut]]'ing to a continuation. A
[[location]] thus includes two values: a function that returns a
location for a value to be stored, and an expression that yields the
value of a parameter.

<<>>=
type location = Rtl.expr -> Rtl.location        (* pass parameter *)
              * Rtl.expr                        (* get  parameter *)
@

Of course, there is the automaton itself.  An automaton maintains
an internal actual state that changes when the automaton is run.  

<<>>=
type automaton
@

% ------------------------------------------------------------------ 
\subsubsection{Running an Automaton}
% ------------------------------------------------------------------ 

This sub-module defines everything an automaton's client needs to
know.  Especially all details about a calling convention is left
abstract.

Use [[reset]], to get an automaton that is in its initial state.  See
below for equations describing the actual state of an automaton
partially.

<<signature run>>=
val reset: automaton -> automaton
@

Running an automaton means to ask for the [[location]] of a [[ty]]. 
This advances an automaton to its [[next]] state.  The answers to the
question includes the desired [[location]] and the automaton in its
new (internal) state.  When the automaton lacks a transition from its
current state for the requested type, the [[Error.ErrorExn]] exception
is raised.

<<>>=
val next: automaton -> ty -> location * automaton (* Error.ErrorExn *)
@

The code generator not only needs to know where parameters are stored,
but also the overall size of the area (overflow) parameters are stored
in and its alignment.  This information is captured by the
[[overflow]] type and function.  The memory requirements for
overflowing parameters are determined by the \emph{state} of an
automaton and thus can be obtained from it.  In contrast, the
[[location]] for a parameter is determined by the \emph{transition}
between two states and thus it is returned by the [[next]] function.

<<>>=
type overflow   = { size:   int   (* overflow area in memsize units *)
                  ; align:  int   (* alignment in memsize units     *)
                  }
val overflow: automaton -> overflow
@

% ------------------------------------------------------------------ 
\subsubsection{Building an Automaton -- preliminary}
% ------------------------------------------------------------------ 

Creating an automaton for an existing calling conventions is not a
straight forward task.  This interface is rather low-level and does
not go beyond the automaton perspective.  An additional high-level
approach may be adequate that provides a domain specific notation that
ultimately can be converted into an automaton using this interface.

A state captures which locations have been used for parameter passing
and where the next parameter goes, depending on its type.

<<signature build>>=
type state
@

Since conceptually an infinite number of parameters can be placed in
memory, a pure finite state automaton can not keep track of the
consumed locations.  We thus assume that an [[automaton]] contains
some form of counter that keeps track of parameters in memory in order
to use still a finite number of states.  The [[info]] type represents
this counter, and the [[info]] function returns this information for
an automaton:

<<>>=
type info
val info: automaton -> info
@

An automaton has a current and an initial state and so it is natural
to use a state to create an automaton and make it the initial state at
the same time.  The initial [[info]] value must be supplied, too.  We
introduce [[state_of]] to obtain the \emph{actual} state of an
automaton and use it to express some rules:

<<>>=
val make    : state -> info -> automaton   
val state_of: automaton -> state
@

\begin{quote}
\begin{verbatim}
state_of (make s i)             = s
state_of (Run.reset (make s i)) = s     
\end{verbatim}
\end{quote}

A \emph{transition} from one state to another describes which
locations to use for the type [[ty]] that caused this transition.  So
a transition between two states is labeled with two informations:  a
type [[ty]] and a location.  Locations in memory (opposed to those in
registers) depend on previous parameters placed into memory.  This
makes the location dependent on the counter [[info]] maintained by an
automaton.  A transition is thus added to an automaton by specifying
two states, a type, and an [[info]] dependent [[location]].
       
<<>>=
val add: automaton -> state -> ty -> (info -> location) -> state -> automaton
@

Adding a transition does not alter the state of an automaton:

\begin{quote}
\begin{verbatim}
state_of (add a s1 t f s2) = state_of a
info     (add a s1 t f s2) = info a
\end{verbatim}
\end{quote}

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

An implementation is postponed.

