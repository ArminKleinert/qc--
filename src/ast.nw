%
% $Id$
%


\section{Abstract Syntax Definition}

The abstract syntax for \C~is not directly encoded into \ocaml~data
types but specified as a \asdl~\cite{adsl97} definition.  This
\asdl~compiler generates suitable data types and additionally code to
serialize the abstract syntax.  This permits to exchange the abstract
syntax with applications written in languages other than \ocaml~more
easily. 

The abstract syntax is specified in [[ast.asdl]]; the resulting
modules are [[Ast]] and [[AstUtil]].

<<ast.asdl>>=
module ast {
    <<ast declaration>>
}

<<ast declaration>>=
name        = (string)
conv        = (string)  -- names for calling conventions
hint        = (string)  -- hints for register allocation
reg         = (string)  -- names for global registers
target      = (string)  -- labels
size        = (int)     -- power of 2 (bits8, float16, ..)
align       = (int)     -- power of 2
aligned     = (int)     -- power of 2
op          = (string)

@ Every important node includes source code position [[pos]]. This is
the character span in the input character sequence that covers the
node. The first character in the stream has index 0. The first number
in a [[pos]] denotes the first character covered by the node, the
second number the first character \textit{after} the node.

<<ast declaration>>=
pos         = (int,int) -- source code positions span

program     = (pos,topdecl*)

topdecl     = Import  (pos, ty, name*)
            | Export  (pos, name*)
            | Const   (pos, const*)
            | Section (pos, name, section*)
            | Global  (pos, register*)
            | Pragma  (pos)                   -- just for testing

@ Extensions to the language are syntactically covered by [[pragma]]s. 
Extensions that are recognized by this implementation cover them in
the abstract syntax.  For testing purposes currently a meaningless
[[Pragma]] constructor is returned by the parser for recognized
pragmas. 

<<ast declaration>>=

const       = (pos, name, expr)

register    = (pos, invariant, ty, name, reg?)

section     = SSpan (pos, expr key, expr value, section*)
            | Datum (pos, datum)
            | Procedure ( pos
                        , conv?
                        , name
                        , formal*
                        , decl*
                        , stmt*
                        )
memsize     = NoSize
            | DynSize
            | FixSize (expr)
                       
datum       = Label (pos, name)
            | Align (pos, align)
            | MemDecl (pos, ty, memsize, init?)

@ Escape sequence in the concrete syntax of strings and charaxter
literals are removed during the translation to the abstract syntax. 
So [[InitStr]] and [[InitUStr]] do not contain escaped characters.

<<ast declaration>>=
init        = InitExprs (expr*)
            | InitStr   (string)
            | InitUStr  (string)

ty          = BitsTy  (pos, size)
            | FloatTy (pos, size)

@ To encode the [[invariant]] keyword a boolean value would suffice.
But this type is not provided by \asdl.

<<ast declaration>>=

invariant   = Invariant
            | Variant

formal      = (pos, hint?, invariant, ty, name)
actual      = (pos, hint?, expr)

decl        = Register  (pos, invariant, ty, name)
            | Stackdata (pos, datum*)
           
flow        = CutsTo    (pos, name*)
            | UnwindsTo (pos, name*)
            | ReturnsTo (pos, name*)
            | Aborts    (pos)

lvalue      = Var (pos, name)
            | Mem (pos, ty, expr, aligned?)

assign      = (lvalue,expr)
altcont     = (expr, expr)

stmts       = (stmt*)
targets     = (target*)
flows       = (flow*)
lvalues     = (lvalue*)

@ The abstract syntax does not make a difference between an empty list
of statements and an absent optional list of statements. An [[if]]
statement without an [[else]] block looks on this level like an [[if]]
with an empty [[else]] block.

<<ast declaration>>=

stmt        = IfStmt     (pos, expr, stmts, stmts)
            | LabelStmt  (pos, name)
            | ContStmt   (pos, name, name*)
            | SpanStmt   (pos, expr key, expr value, stmts)
            | AssignStmt (pos, assign*)
            | CallStmt   (pos, lvalue*, conv?, expr, actual*, targets, flows)
            | PrimStmt   (pos, lvalue*, conv?, name, actual*, flows)
            | GotoStmt   (pos, expr, targets)
            | JumpStmt   (pos, conv?, expr, actual*, targets)
            | CutStmt    (pos, name, actual*, flows)
            | ReturnStmt (pos, conv?, altcont?, actual*)
            | EmptyStmt  (pos)

expr        = Int    (pos, int,size?)
            | Float  (pos, string,size?)
            | Char   (pos, string,size?)
            | Fetch  (pos, lvalue)
            | BinOp  (pos, expr, op, expr)
            | UnOp   (pos, op, expr)
            | PrimOp (pos, name, actual*)

@ Infix operators are abbreviations for primitive operations. The
parser could perform this translation right away. But we want to
unparse the abstract syntax back to concrete syntax and thus we keep
them. 
