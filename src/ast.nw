%
% $Id$
%


\section{Abstract Syntax Definition}

The abstract syntax for \C~is not directly encoded into \ocaml~data
types but specified as a \asdl~\cite{adsl97} definition.  This
\asdl~compiler generates suitable data types and additionally code to
serialize the abstract syntax.  This permits to exchange the abstract
syntax with applications written in languages other than \ocaml~more
easily. 

The abstract syntax is specified in [[ast.asdl]]; the resulting
modules are [[Ast]] and [[AstUtil]].

<<ast.asdl>>=
module ast {
    <<ast declaration>>
}

<<ast declaration>>=
name        = (string)
conv        = (string)  -- names for calling conventions
hint        = (string)  -- hints for register allocation
reg         = (string)  -- names for global registers
target      = (string)  -- labels
size        = (int)     -- power of 2 (bits8, float16, ..)
align       = (int)     -- power of 2
aligned     = (int)     -- power of 2
op          = (string)

pos         = (int,int) -- source code positions span

program     = (pos,topdecl*)

topdecl     = Import  (pos, ty, name*)
            | Export  (pos, name*)
            | Const   (pos, const*)
            | Section (pos, name, section*)
            | Global  (pos, register*)
            | Pragma  (pos)                   -- just for testing


const       = (pos, name, expr)

register    = (pos, invariant, ty, name, reg?)

section     = SSpan (pos, expr key, expr value, section*)
            | Datum (pos, datum)
            | Procedure ( pos
                        , conv?
                        , name
                        , formal*
                        , decl*
                        , stmt*
                        )
memsize     = NoSize
            | DynSize
            | FixSize (expr)
                       
datum       = Label (pos, name)
            | Align (pos, align)
            | MemDecl (pos, ty, memsize, init?)

@ Escape sequence in the concrete syntax are removed during the
translation to the abstract syntax.  So [[InitStr]] and [[InitUStr]]
do not contain escaped characters.

<<ast declaration>>=
init        = InitExprs (expr*)
            | InitStr   (string)
            | InitUStr  (string)

ty          = BitsTy  (pos, size)
            | FloatTy (pos, size)

@ To encode the [[invariant]] keyword a boolean value would suffice.
But this type is not provided by \asdl.

<<ast declaration>>=

invariant   = Invariant
            | Variant

formal      = (pos, hint?, invariant, ty, name)
actual      = (pos, hint?, expr)

decl        = Register  (pos, invariant, ty, name)
            | Stackdata (pos, datum*)
           
flow        = CutsTo    (pos, name*)
            | UnwindsTo (pos, name*)
            | ReturnsTo (pos, name*)
            | Aborts    (pos)

lvalue      = Var (pos, name)
            | Mem (pos, ty, expr, aligned?)

assign      = (lvalue,expr)
altcont     = (expr, expr)

stmts       = (stmt*)
targets     = (target*)
flows       = (flow*)
lvalues     = (lvalue*)

stmt        = IfStmt     (pos, expr, stmts, stmts)
            | LabelStmt  (pos, name)
            | ContStmt   (pos, name, name*)
            | SpanStmt   (pos, expr key, expr value, stmts)
            | AssignStmt (pos, assign*)
            | CallStmt   (pos, lvalue*, conv?, expr, actual*, targets, flows)
            | PrimStmt   (pos, lvalue*, conv?, name, actual*, flows)
            | GotoStmt   (pos, expr, targets)
            | JumpStmt   (pos, conv?, expr, actual*, targets)
            | CutStmt    (pos, name, actual*, flows)
            | ReturnStmt (pos, conv?, altcont?, actual*)
            | EmptyStmt  (pos)

expr        = Int    (pos, int,size?)
            | Float  (pos, string,size?)
            | Char   (pos, string,size?)
            | Fetch  (pos, lvalue)
            | BinOp  (pos, expr, op, expr)
            | UnOp   (pos, op, expr)
            | PrimOp (pos, name, actual*)

@ Infix operators are abbreviations for primitive operations. The
parser could perform this translation right away. But we want to
unparse the abstract syntax back to concrete syntax and thus we keep
them. 
