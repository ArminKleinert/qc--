%
% $Id$
%

\input{../config/macros.tex}

% l2h substitution rtl RTL
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall

% ------------------------------------------------------------------  
\section{Abstract Syntax Definition}\label{sec:ast}
% ------------------------------------------------------------------  

The abstract syntax for \C~is not directly encoded into \ocaml~data
types but specified as an \asdl~\cite{adsl97} definition.  The
\asdl~compiler generates suitable data types and additionally code to
serialize the abstract syntax.  This permits to exchange the abstract
syntax with applications written in languages other than \ocaml~more
easily. 

The abstract syntax is specified in [[ast.asdl]]; the resulting
modules are [[Ast]] and [[AstUtil]]. {\asdl} does not provide all the
data types we require so we have to define some views. A view is a
one-to-one mapping between an external representation using {\asdl}
primitive types and and internal user-defined representation.

<<ast.asdl>>=
module ast {
    <<ast declaration>>
}
@

% ------------------------------------------------------------------ 
\subsection{The \asdl-definition}
% ------------------------------------------------------------------ 

<<ast declaration>>=
name        = (string)
conv        = (string)  -- names for calling conventions
hint        = (string)  -- hints for register allocation
reg         = (string)  -- names for global registers
target      = (string)
size        = (int)     
align       = (int)     -- power of 2
aligned     = (int)     -- power of 2
op          = (string)
@

Every important node is wrapped by a node that includes a source
code position [[region]].  This is the character span in the input
character stream that covers the node.  The first character in the
stream has index 0.  The first number in a [[region]] denotes the
first character covered by the node, the second number the first
character \textit{after} the node.

<<ast declaration>>=
region      = (int,int) -- (* Srcmap.reg *)

program     = (toplevel*)

toplevel    = ToplevelAt    (toplevel, region)
            | Section       (name, section*)
            | TopDecl       (decl)
            | TopProcedure  (proc)
@

<<ast declaration>>=
section     = SectionAt     (section, region)
            | Decl          (decl)
            | Procedure     (proc)
            | Datum         (datum)
            | SSpan         (expr key, expr value, section*)
@
            
Extensions to the language are syntactically covered by [[pragma]]s.
Unknown extensions are represented by the [[Pragma]] value.

<<ast declaration>>=
decl        = DeclAt        (decl, region)
            | Import        (ty, import*)
            | Export        (ty?,export*)
            | Const         (ty?,name,expr)
            | Typedef       (ty,name*)
            | Registers     (register*)
            | Pragma                          
            | Target        (arch*)
@

<<ast declaration>>=
arch        = Memsize       (int)
            | ByteorderBig
            | ByteorderLittle
            | FloatRepr     (string) -- "ieee754"
            | Charset       (string) -- "latin1"
            | WordSize      (int)    -- 32 (bits)
            | PointerSize   (int)    -- 32 (bits)

import      = (string?,name)
export      = (name, string?)

@
       
<<ast declaration>>=
register    = (invariant, hint?, ty, name, reg?)
proc        = (conv?, name, formal*, body*)

body        = BodyAt        (body, region)
            | DeclBody      (decl)
            | StmtBody      (stmt)
            | DataBody      (datum*)
            
memsize     = NoSize
            | DynSize
            | FixSize       (expr)
                       
datum       = DatumAt       (datum, region)
            | Label         (name)
            | Align         (align)
            | MemDecl       (ty, memsize, init?)

@ Escape sequence in the concrete syntax of strings and character
literals are removed during the translation to the abstract syntax. 
So [[InitStr]] and [[InitUStr]] do not contain escaped characters.

<<ast declaration>>=
init        = InitAt        (init, region)
            | InitExprs     (expr*)
            | InitStr       (string)
            | InitUStr      (string)

<<ast declaration>>=
ty          = TyAt          (ty, region)
            | BitsTy        (size)
            | AliasTy       (name)
@

To encode the [[invariant]] keyword a boolean value would suffice.
But this type is not provided by \asdl.

<<ast declaration>>=
invariant   = Invariant
            | Variant

formal      = (hint?, invariant, ty, name)
actual      = (hint?, expr)
cformal     = (hint?, name)

<<ast declaration>>=
flow        = FlowAt        (flow, region)
            | CutsTo        (name*)
            | UnwindsTo     (name*)
            | ReturnsTo     (name*)
            | Aborts    

lvalue      = LValueAt      (lvalue, region)
            | Var           (hint?,name)
            | Mem           (ty, expr, aligned?)
<<ast declaration>>=
altcont     = (expr, expr)

range       = Point         (expr)
            | Range         (expr,expr)

arm         = ArmAt         (arm, region)
            | Case          (range*,body*)
@

We like to represent guarded multiple assignments. The guards are paired
with the expressions defining the value to be assigned. Alternatively
we could have made the guard of an [[lvalue]] but this would have
complicated the already complicated analysis of lvalues further.
             
<<ast declaration>>=
guarded     = (expr? guard, expr value) 
@

The abstract syntax does not distinguish an empty list of statements
from an absent optional list of statements.  An [[if]] statement
without an [[else]] block looks on this level like an [[if]] with an
empty [[else]] block.

Comments as represented by the [[CommentStmt]] are never generated by
the parser.  They are used for code generation back ends that emit
{\PAL} code. 
 
<<ast declaration>>=
stmt        = StmtAt        (stmt, region)
            | IfStmt        (expr, body*, body*)
            | SwitchStmt    (range?, expr, arm*)
            | LabelStmt     (name)
            | ContStmt      (name, cformal*)
            | SpanStmt      (expr key, expr value, body*)
            | AssignStmt    (lvalue*, guarded*)
            | CallStmt      (lvalue*, conv?, expr, actual*, target*, flow*)
            | PrimStmt      (lvalue*, conv?, name, actual*, flow*)
            | GotoStmt      (expr, target*)
            | JumpStmt      (conv?, expr, actual*, target*)
            | CutStmt       (expr, actual*, flow*)
            | ReturnStmt    (conv?, altcont?, actual*)
            | EmptyStmt  
            | CommentStmt   (string)
@

Literal constants pose a problem becaus their (bit) width cannot be
resolved during scanning and parsing. Therefore we store strings and
scan them later, once we know the width.

<<ast declaration>>=
expr        = ExprAt        (expr, region)
            | Int           (string,ty?)
            | Float         (string,ty?)
            | Char          (string,ty?)
            | Fetch         (lvalue)
            | BinOp         (expr, op, expr)
            | UnOp          (op, expr)
            | PrimOp        (name, actual*)
@

Infix operators are abbreviations for primitive operations. The
parser could perform this translation right away. But we want to
unparse the abstract syntax back to concrete syntax and thus we keep
them. 


% ------------------------------------------------------------------  
\section{Pretty Printer}\label{sec:astpp}
% ------------------------------------------------------------------  

For debugging and regression testing we provide a module that pretty
prints the abstract syntax into the concrete syntax.  The
implementation uses an implementation of Philip Wadler's algebraic
pretty printer \cite{wadler99:_a_prettier_printer} from the [[Pp]]
module. 

% ------------------------------------------------------------------  
\subsection{Interface}
% ------------------------------------------------------------------  

The interface provides functions to transform a program in abstract
syntax to a [[Pp.doc]] format.  For error reporting it is useful to
obtain pretty printed fragments of a program.  The following list of
functions provides pretty printing for important non terminals in a
program.  Each function returns a [[Pp.doc]] value that can be turned
into a [[string]] with the help of the [[Pp]] module.

The [[emit]] function is specialized and more efficient in certain
cases. It is here to help John Dias emit large programs.

<<astpp.mli>>=
val decl       : bool -> Ast.decl  -> Pp.doc
val stmt       : Ast.stmt          -> Pp.doc
val program    : Ast.toplevel list -> Pp.doc

val emit       : out_channel -> width:int -> Ast.toplevel list -> unit
@


% ------------------------------------------------------------------  
\subsection{Implementation}
% ------------------------------------------------------------------  

The implementation builds an abstract representation of the pretty
printed concrete syntax in a purely functional way. The abstract
representation is than written to an open file.

<<astpp.ml>>=
module A = Ast
module P = Pp
module E = Error

let (^^)   = P.(^^)
let (^/)   = P.(^/)
let (~~) x = x
@

The module [[Pp]] provides the pretty printing primitives.  The
concatenation of two abstract pretty printed objects is denoted by the
infix operator [[^^]].  We define two more:  [[~~]] and [[~/]]; the
first is a prefix operator that does nothing; its only purpose is to
achieve a more consistent source code layout. In the following example
all nested code is also nested in the source code.

<<example>>=
let f (x,y,z) = 
    nest begin
    ~~ x
    ^/ y
    ^/ z
    end
@

The second operator [[^/]] joins two objects with a [[break]].  A
[[break]] is either represented as a space, or as a line break
followed by a number of spaces for indentation.  The exact outcome is
determined by the pretty printer.  It is easiest to think of
[[break]]s as spaces that might be turned into line breaks.

<<astpp.ml>>=
let nest       = P.nest 4 

@ The [[commablock]] is just a handy special case of the [[block]]
defined in [[Pp]]. 

<<astpp.ml>>=
let commablock f xs =
    nest begin
    ~~ P.list (P.text "," ^^ P.break) f xs
    end

@ To indent a group we provide [[angrp]] and [[fngrp]]; [[fngrp]] is a
nested [[fgrp]]. While inside an [[agrp]] all breaks are either turned
into spaces or newlines, each break inside a [[fgrp]] is considered
separately. Only breaks at the end of a line is turned into a newline
to make new room -- as many as possible breaks are printed as spaces.
    
<<astpp.ml>>=
let angrp x =
    P.agrp begin 
    ~~ nest begin
       ~~ x
       end
    end

let fngrp x =
    P.fgrp begin 
    ~~ nest begin
       ~~ x
       end
    end
@

Most of the names used below refer directly to the grammar or abstract
syntax.  Since the overall purpose of this is clear we don't comment
the code much.

<<astpp.ml>>=
let unzip = List.split
let zip   = List.combine


let id i        = P.text i
let int n       = P.text (string_of_int n)
let semi        = P.text ";"
@

Comments are not part of the abstract syntax and thus they are
only created for informational purposes in this module.  The argument
passed to [[comment]] must not contain only matching [[/*]] and [[*/]]

<<astpp.ml>>=
let comment x   = P.vgrp (P.text "// " ^^ P.text x)
@

Todo:  write functions that escape unprintable characters in literals.

<<astpp.ml>>=
let str s       = P.text ("\"" ^ String.escaped s ^ "\"")

<<astpp.ml>>=
let rec ty = function
    | A.TyAt(x,_)       -> ty x
    | A.BitsTy(n)       -> P.text "bits"  ^^ int n
    | A.AliasTy(name)   -> P.text name
@


<<astpp.ml>>=
let rec lvalue = function
    | A.LValueAt(x,_)   -> lvalue x
    | A.Var(None,x)     -> id x
    | A.Var(Some h,x)   -> str h ^/ id x
    | A.Mem(t,e,a)      -> 
        ~~ ty t 
        ^^ P.text "["
        ^^ expr e 
        ^^ begin match a with 
                | Some i -> P.break ^^ P.text "aligned" ^/ int i 
                | None   -> P.empty
           end 
        ^^ P.text "]"
@

A [[glvalue]] is an optionally guarded lvalue.

<<astpp.ml>>=
and glvalue = function
    | x, None   -> lvalue x
    | x, Some e -> P.agrp(lvalue x  ^/ P.text "when" ^/ expr e)
                        
and actual = function
    | ( Some hint, e) -> P.agrp (str hint ^/ expr e)
    | ( None     , e) -> expr e

and actuals xs = P.agrp (P.text "(" ^^ P.commalist actual xs ^^ P.text ")")

<<astpp.ml>>=
and expr = function
    | A.ExprAt(x,_)             -> expr x
    | A.Int( i, None)           -> P.text i
    | A.Int( i, Some t)         -> P.text i ^^ P.text "::" ^^ ty t
    | A.Float( f, None)         -> P.text f
    | A.Float( f, Some t)       -> P.text f ^^ P.text "::" ^^ ty t
    | A.Char( c, None)          -> P.text c 
    | A.Char( c, Some t)        -> P.text c ^^ P.text "::" ^^ ty t
    | A.Fetch(v)                -> lvalue v
    | A.BinOp(l,op,r)           -> P.agrp begin
                                 ~~ P.text "(" ^^ expr l
                                 ^^ nest begin
                                    ~~ P.text op
                                    ^^ (if op = "%" then P.break else P.empty)
                                    ^^ P.breakWith ""
                                    ^^ expr r
                                    end
                                 ^^ P.text ")"
                                 end

    | A.UnOp(op,e)              -> P.agrp (P.text op ^^ expr e)
    | A.PrimOp(n,xs)            -> P.agrp (P.text "%" ^^ id n ^^ actuals xs)


<<astpp.ml>>=
let memsize = function
    | A.NoSize        -> P.empty
    | A.DynSize       -> P.text "[]"
    | A.FixSize(e)    -> P.text "[" ^^ expr e ^^ P.text "]"

let rec init = function
    | A.InitAt(x,_) -> init x
    | A.InitExprs(es) -> 
            P.fgrp begin
            ~~ P.text "{"
            ^/ nest begin
               ~~ P.commalist expr es
               end
            ^/ P.text "}"
            end
    | A.InitStr(s) -> str s
    | A.InitUStr(s) -> 
            P.agrp begin
            ~~ P.text "unicode"
            ^/ P.text "("
            ^/ nest begin
               ~~ str s
               end
            ^/ P.text ")"
            end

let rec datum = function
    | A.DatumAt(x,_)        -> datum x
    | A.Label(n)            -> id n ^^ P.text ":"
    | A.Align(a)            -> P.agrp (P.text "align" ^/ int a ^^ semi)
    | A.MemDecl(t,m,Some i) -> P.agrp (ty t ^^ memsize m ^/ init i ^^ semi)
    | A.MemDecl(t,m,None)   -> P.agrp (ty t ^^ memsize m ^^ semi) 

<<astpp.ml>>=
let formal (h, v, t, n) =
    P.agrp begin
    ~~ (match h with Some hint -> str hint ^^ P.break | None -> P.empty)
    ^^ (if v = A.Invariant then P.text "invariant" ^^ P.break else P.empty)
    ^^ ty t
    ^/ id n
    end

let formals xs = P.agrp (P.text "(" ^^ P.commalist formal xs ^^ P.text ")")

<<astpp.ml>>=
let cformal (h, n) =
    P.agrp begin
    ~~ (match h with Some hint -> str hint ^^ P.break | None -> P.empty)
    ^^ id n
    end

let cformals xs = P.agrp (P.text "(" ^^ P.commalist cformal xs ^^ P.text ")")
    

<<astpp.ml>>=
let register is_global (v , hint, t, n, reg) = 
    angrp begin 
    ~~ (if v = A.Invariant then P.text "invariant" ^^ P.break else P.empty)
    ^^ (if is_global       then P.text "register"  ^^ P.break else P.empty)
    ^^ (match hint with Some h -> P.break ^^ str h | None -> P.empty)
    ^^ ty t
    ^/ id n
    ^^ (match reg with Some r -> P.break ^^ str r | None -> P.empty)
    ^^ semi
    end 

<<astpp.ml>>=
let altcont (e1,e2) =   
            P.agrp begin 
            ~~ P.text "<" 
            ^^ expr e1 
            ^^ P.text "/" 
            ^/ expr e2
            ^^ P.text ">"
            end

let targets = function
    | []    -> P.empty
    | ts    -> P.agrp (P.text "targets" ^/ nest (P.commalist id ts))
    
let rec flow f =
    let also s ns = P.agrp (P.text "also" ^/ P.text s ^/ P.text "to" 
                         ^/ nest (P.commalist id ns))
    in match f with
    | A.FlowAt(x,_)     -> flow x
    | A.CutsTo(ns)    when ns <> []     -> also "cuts"    ns
    | A.UnwindsTo(ns) when ns <> []     -> also "unwinds" ns
    | A.ReturnsTo(ns) when ns <> []     -> also "returns" ns
    | A.Aborts                          -> P.text "also aborts"
    | _                                 -> P.empty

let flows = function
    | []    -> P.empty
    | xs    -> nest (P.agrp (P.list P.break flow xs))

let conv = function
    | Some cc       -> P.agrp (P.text "foreign" ^/ str cc)
    | None          -> P.empty 

    
<<astpp.ml>>=
let export t ns =
    let export' = function
        | (x, Some y) -> P.agrp (id x ^/ P.text "as" ^/ str y)
        | (x, None  ) -> id x
    in
        P.agrp begin
        ~~ P.agrp begin 
           ~~ P.text "export" 
           ^^ ( match t with 
              | Some t -> P.break ^^ ty t
              | None   -> P.empty
              )
           end
           ^/ commablock export' ns
           ^^ semi
        end


let architecture = function
    | A.Memsize(i)      -> P.agrp (P.text "memsize" ^/ int i)
    | A.ByteorderBig    -> P.agrp (P.text "byteorder" ^/ P.text "big")
    | A.ByteorderLittle -> P.agrp (P.text "byteorder" ^/ P.text "little")
    | A.WordSize i      -> P.agrp (P.text "wordsize" ^/ int i)
    | A.PointerSize i   -> P.agrp (P.text "pointersize" ^/ int i)
    | A.FloatRepr s     -> P.agrp (P.text "float" ^/ str s)
    | A.Charset s       -> P.agrp (P.text "charset" ^/ str s)
    


let range = function
    | A.Point(e)        -> expr e
    | A.Range(e1,e2)    -> P.agrp(expr e1 ^/ P.text ".." ^/ expr e2)

<<astpp.ml>>=
let rec stmt = function
    | A.StmtAt(x,_)   -> stmt x
    
    | A.IfStmt ( e, ss1, ss2)    ->
        P.agrp begin
        ~~ P.agrp (P.text "if" ^/ expr e)
        ^/ P.block (body false) ss1
        ^^ begin match ss2 with
           | []     -> P.empty
           | ss     -> P.break ^^ P.text "else" ^/ P.block (body false) ss
           end
        end
    | A.LabelStmt(n)            -> 
        P.agrp begin
        ~~ id n ^^ P.text ":"
        end
        
    | A.ContStmt(n,cf)          ->
        P.agrp begin
        ~~ P.text "continuation"
        ^^ angrp begin
           ~~ P.break
           ^^ id n
           ^^ cformals cf
           ^^ P.text ":"
           end
        end

    | A.SpanStmt(e1,e2,ss)      -> 
        P.agrp begin
        ~~ P.agrp (P.text "span" ^/ expr e1 ^/ expr e2)
        ^/ P.block (body false) ss
        end
@

In the abstract syntax, guards in a guarded assignment belong to the
expression.  In the concrete syntax, the guard belongs to the lvalue.
Guards are thus re-combined with the left hand side of an assignment
before it is printed.
        
<<astpp.ml>>=
    | A.AssignStmt(lhs,rhs)          -> 
        let rec combine = function (* error tolerant *)
            | []   , []    -> []
            | x    , []    -> []
            | []   , x     -> []
            | x::xx, y::yy -> (x,y)::combine (xx,yy)
                                               in
        let guards, rhs = List.split rhs       in
        let lhs         = combine (lhs,guards) in
            P.agrp begin
            ~~ fngrp begin 
               ~~ P.commalist glvalue lhs 
               ^/ P.text "="
               end
            ^^ fngrp begin
               ~~ P.break
               ^^ P.commalist expr rhs
               ^^ semi
               end
            end

<<astpp.ml>>=
    | A.CallStmt(lhs, cc, e, args, ts, fs) -> 
        angrp begin
        ~~ ( if lhs <> [] 
             then fngrp begin 
                  ~~ P.commalist lvalue lhs 
                  ^/ P.text "="
                  ^^ P.break
                 end
             else P.empty
           )
        ^^ ( match cc with 
           | Some c -> P.agrp (P.text "foreign" ^/ str c ^^ P.break)
           | None   -> P.empty
           ) 
        ^^ angrp begin 
           ~~ expr e
           ^^ fngrp begin 
              ~~ P.break 
              ^^ P.text "(" 
              ^^ P.commalist actual args 
              ^^ P.text ")"
              end
           end
        ^^ (if ts <> [] then P.break ^^ targets ts else P.empty)
        ^^ (if fs <> [] then P.break ^^ flows fs else P.empty)
        ^^ semi
        end
<<astpp.ml>>=
    | A.PrimStmt(lhs, cc, n, args, fs)     -> 
        angrp begin
        ~~ ( if lhs <> [] then 
                  ~~ P.commalist lvalue lhs 
                  ^/ P.text "="
                  ^^ P.break
             else P.empty
           )
        ^^ ( match cc with 
           | Some c -> P.agrp (P.text "foreign" ^/ str c ^^ P.break)
           | None   -> P.empty
           ) 
        ^^ fngrp begin 
           ~~ P.text "%%" 
           ^^ id n
           ^^ P.break 
           ^^ P.text "(" 
           ^^ P.commalist actual args 
           ^^ P.text ")"
           end
        ^^ (if fs <> [] then P.break ^^ flows fs else P.empty)
        ^^ semi
        end
    
    | A.GotoStmt(e,ts)                      -> 
        angrp begin
        ~~ P.text "goto"
        ^/ expr e
        ^^ (if ts <> [] then P.break ^^ targets ts else P.empty)
        ^^ semi
        end
    | A.CutStmt(e, args, fs)                -> 
        angrp begin
        ~~ P.text "cut to"
        ^/ expr e 
        ^^ fngrp begin 
           ~~ P.break 
           ^^ P.text "(" 
           ^^ P.commalist actual args 
           ^^ P.text ")"
           end
        ^^ (if fs <> [] then P.break ^^ flows fs else P.empty)
        ^^ semi
        end
    | A.ReturnStmt(cc, alt, args)           -> 
        angrp begin
        ~~ ( match cc with 
           | Some c -> P.text "foreign" ^/ str c ^^ P.break
           | None   -> P.empty
           )
        ^^ P.text "return"
        ^^ ( match alt with
           | Some a -> P.break ^^ altcont a ^^ P.break
           | None   -> P.empty
           )
        ^^ fngrp (P.break ^^ P.text "(" ^^ P.commalist actual args ^^ P.text ")") 
        ^^ semi 
        end
    | A.JumpStmt(cc,e,args,ts)              -> 
        angrp begin
        ~~ ( match cc with 
           | Some c -> P.agrp (P.text "foreign" ^/ str c) ^^ P.break
           | None   -> P.empty
           )
        ^^ fngrp begin 
           ~~ (P.text "jump" ^/ expr e)
           ^^ ( if args <> [] then 
                    ~~ P.break 
                    ^^ P.text "(" 
                    ^^ P.commalist actual args 
                    ^^ P.text ")"
                 else 
                    P.empty
              )
           ^^ (if ts <> [] then P.break ^^ targets ts else P.empty)
           end
        ^^ semi
        end
    | A.EmptyStmt      -> semi
    | A.CommentStmt(s) -> comment s

    | A.SwitchStmt (r,e,arms) -> 
        P.agrp begin
        ~~ P.agrp begin 
           ~~ P.text "switch"
           ^^ ( match r with
              | Some r -> P.agrp begin 
                ~~ P.break 
                ^^ P.text "[" 
                ^^ range r 
                ^^ P.text "]"
                end
              | None   -> P.empty
              )
           ^/ expr e
           end
        ^/ P.agrp (P.block arm arms)
        end
        
and body is_global = function
    | A.BodyAt(x, _)    -> body is_global x
    | A.DeclBody(d)     -> decl is_global d
    | A.StmtBody(s)     -> stmt s
    | A.DataBody(dd)    -> 
            P.agrp begin
            ~~ P.text "stackdata"
            ^/ P.block datum dd
            end
    
and proc (cc,n,fs,ss) =  
    P.agrp begin 
    ~~ P.agrp begin
       ~~ begin match cc with 
          | Some c -> P.text "foreign" ^/ str c ^^ P.break
          | None   -> P.empty
          end
       ^^ id n
       ^^ formals fs
       end
    ^/ P.text "{"
    ^^ nest begin
       ~~ P.break
       ^^ P.list P.break (body false) ss
       end 
    ^/ P.text "}" 
    end

<<astpp.ml>>=
and decl is_global = function
    | A.DeclAt(x,_) -> decl is_global x
    | A.Import( t, ns) -> 
        let import' = function
        | (Some x, y) -> P.agrp (str x ^/ P.text "as" ^/ P.text y)
        | (None  , y) -> id y
        in
            P.agrp begin
            ~~ P.agrp (P.text "import" ^/ ty t)
            ^/ commablock import' ns
            ^^ semi
            end
    | A.Export( t, ns) -> export t ns
    | A.Const (t,n,e) ->
            P.agrp begin 
            ~~ P.text "const"
            ^^ ( match t with
               | Some t -> P.break ^^ ty t
               | None   -> P.empty
               )
            ^/ id n
            ^/ P.text "="
            ^/ expr e
            ^^ semi
            end
    | A.Registers( rs) ->
            P.vgrp begin
            ~~ P.list P.break (register is_global) rs
            end
    | A.Typedef (t,nn)  -> 
        angrp begin
        ~~ P.text "typedef"
        ^/ ty t
        ^/ P.text "="
        ^/ commablock id nn
        ^^ semi
        end 
    
    | A.Target (arch) -> 
            angrp begin
            ~~ P.text "target"
            ^/ P.list P.break architecture arch
            ^^ semi
            end
    | A.Pragma        -> comment "pragma"

<<astpp.ml>>=
and arm = function
    | A.ArmAt(x,_)          -> arm x
    | A.Case(ranges, stmts) ->
        P.agrp begin
        ~~ P.text "case"
        ^/ P.agrp (P.list (P.text "," ^^ P.break) range ranges)
        ^^ P.text ":"
        ^/ P.block (body false) stmts
        end 

and section  = function (* inside a section *)
    | A.SectionAt(x,_)  -> section x
    | A.Decl(d)         -> decl true d
    | A.Datum( d)       -> datum d
    | A.Procedure(p)    -> proc p
    | A.SSpan( e1, e2, ss) ->  
        P.agrp begin
        ~~ P.agrp (P.text "span" ^/ expr e1 ^/ expr e2)
        ^/ P.block section ss
        end
       
       
<<astpp.ml>>=
let rec toplevel = function
    | A.ToplevelAt(x, _)  -> toplevel x
    | A.Section(name, ss) -> 
            P.agrp begin 
            ~~ P.agrp (P.text "section" ^/ str name)
            ^/ P.block section ss
            end
    | A.TopDecl(d)        -> decl true d
    | A.TopProcedure(p)   -> proc p

let program ds = P.vgrp begin
                  ~~ P.list (P.break ^^ P.break) toplevel ds
                  ^^ P.break
                  end
                                            
let pp = program
@

The [[emit]] function is more imperative than [[pp]]. It pretty-print
every top-level element seperately and is therefore much faster. I also
believe, that this solves stack overflow problems when large programs
are emitted. The [[Astasm]] module was changes accordingly to use
[[emit]].

<<astpp.ml>>=
let emit fd ~width tl =
    List.iter (fun t -> ( P.ppToFile fd width (toplevel t)
                        ; output_string fd "\n\n"
                        )) tl
@
