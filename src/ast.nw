%
% $Id$
%

% ------------------------------------------------------------------  
\section{Abstract Syntax Definition}\label{sec:ast}
% ------------------------------------------------------------------  

\ifhtml\tableofcontents\fi

% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml


The abstract syntax for \C~is not directly encoded into \ocaml~data
types but specified as an \asdl~\cite{adsl97} definition.  The
\asdl~compiler generates suitable data types and additionally code to
serialize the abstract syntax.  This permits to exchange the abstract
syntax with applications written in languages other than \ocaml~more
easily. 

The abstract syntax is specified in [[ast.asdl]]; the resulting
modules are [[Ast]] and [[AstUtil]].
<<ast.asdl>>=
module ast {
    <<ast declaration>>
}
<<ast declaration>>=
name        = (string)
conv        = (string)  -- names for calling conventions
hint        = (string)  -- hints for register allocation
reg         = (string)  -- names for global registers
target      = (string)
size        = (int)     
align       = (int)     -- power of 2
aligned     = (int)     -- power of 2
op          = (string)
@ 

Every important node is wrapped by a node that includes a source
code position [[region]].  This is the character span in the input
character stream that covers the node.  The first character in the
stream has index 0.  The first number in a [[region]] denotes the
first character covered by the node, the second number the first
character \textit{after} the node.

<<>>=
region      = (int,int) -- (* Srcmap.reg *)

program     = (toplevel*)

toplevel    = ToplevelAt    (toplevel, region)
            | Section       (name, section*)
            | TopDecl       (decl)
            | TopProcedure  (proc)
@ 

<<>>=
section     = SectionAt     (section, region)
            | Decl          (decl)
            | Procedure     (proc)
            | Datum         (datum)
            | SSpan         (expr key, expr value, section*)
@
            
Extensions to the language are syntactically covered by [[pragma]]s.
Unknown extensions are represented by the [[Pragma]] value.

<<>>=
decl        = DeclAt        (decl, region)
            | Import        (ty, import*)
            | Export        (ty?,export*)
            | Const         (ty?,name,expr)
            | Typedef       (ty,name*)
            | Registers     (register*)
            | Pragma                          
            | Target        (arch*)
@

<<>>=
arch        = Memsize       (int)
            | ByteorderBig
            | ByteorderLittle

import      = (string?,name)
export      = (name, string?)

@
       
<<>>=
register    = (invariant, ty, name, reg?)
proc        = (conv?, name, formal*, body*)

body        = BodyAt        (body, region)
            | DeclBody      (decl)
            | StmtBody      (stmt)
            | DataBody      (datum*)
            
memsize     = NoSize
            | DynSize
            | FixSize       (expr)
                       
datum       = DatumAt       (datum, region)
            | Label         (name)
            | Align         (align)
            | MemDecl       (ty, memsize, init?)

@ Escape sequence in the concrete syntax of strings and character
literals are removed during the translation to the abstract syntax. 
So [[InitStr]] and [[InitUStr]] do not contain escaped characters.

<<>>=
init        = InitAt        (init, region)
            | InitExprs     (expr*)
            | InitStr       (string)
            | InitUStr      (string)

<<>>=
ty          = TyAt          (ty, region)
            | BitsTy        (size)
            | AliasTy       (name)
@ 

To encode the [[invariant]] keyword a boolean value would suffice.
But this type is not provided by \asdl.

<<>>=
invariant   = Invariant
            | Variant

formal      = (hint?, invariant, ty, name)
actual      = (hint?, expr)

<<>>=           
flow        = FlowAt        (flow, region)
            | CutsTo        (name*)
            | UnwindsTo     (name*)
            | ReturnsTo     (name*)
            | Aborts    

lvalue      = LValueAt      (lvalue, region)
            | Var           (hint?,name)
            | Mem           (ty, expr, aligned?)
<<>>=
altcont     = (expr, expr)

range       = Point         (expr)
            | Range         (expr,expr)

arm         = ArmAt         (arm, region)
            | Case          (range*,stmt*)
             
@ 

The abstract syntax does not distinguish an empty list
of statements from an absent optional list of statements. An [[if]]
statement without an [[else]] block looks on this level like an [[if]]
with an empty [[else]] block.
<<>>=
stmt        = StmtAt        (stmt, region)
            | IfStmt        (expr, stmt*, stmt*)
            | SwitchStmt    (range?, expr, arm*)
            | LabelStmt     (name)
            | ContStmt      (name, name*)
            | SpanStmt      (expr key, expr value, body*)
            | AssignStmt    (lvalue*, expr*)
            | CallStmt      (lvalue*, conv?, expr, actual*, target*, flow*)
            | PrimStmt      (lvalue*, conv?, name, actual*, flow*)
            | GotoStmt      (expr, target*)
            | JumpStmt      (conv?, expr, actual*, target*)
            | CutStmt       (expr, actual*, flow*)
            | ReturnStmt    (conv?, altcont?, actual*)
            | EmptyStmt  
<<>>=
expr        = ExprAt        (expr, region)
            | Int           (string,size?)
            | Float         (string,size?)
            | Char          (string,size?)
            | Fetch         (lvalue)
            | BinOp         (expr, op, expr)
            | UnOp          (op, expr)
            | PrimOp        (name, actual*)
@

Infix operators are abbreviations for primitive operations. The
parser could perform this translation right away. But we want to
unparse the abstract syntax back to concrete syntax and thus we keep
them. 

% ------------------------------------------------------------------  
\section{Pretty Printer}\label{sec:astpp}
% ------------------------------------------------------------------  

For debugging and regression testing we provide a module that pretty
prints the abstract syntax into the concrete syntax.  The
implementation uses an implementation of Philip Wadler's algebraic
pretty printer \cite{wadler99:_a_prettier_printer} from the [[Pp]]
module. 

% ------------------------------------------------------------------  
\subsection{Interface}
% ------------------------------------------------------------------  

The interface provides a function [[ppToFile]] to print a program in
abstract syntax to an open file.  The second parameter controls the
line width the output is formatted for. The function [[pp]] takes a
file name as argument and pretty prints the file to standard output.
In case [[pp]] is successful it returns [[Error.Ok()]], and
[[Error.Error]] otherwise.

<<astpp.mli>>=
val ppToFile   : out_channel -> int -> Ast.program -> unit
val pp         : string -> int -> unit Error.error
@ 

For error reporting it is useful to obtain pretty printed fragments
of a program.  The following list of functions provides pretty
printing for important non terminals in a program.  Each function
returns a [[Pp.doc]] value that can be turned into a [[string]] with
the help of the [[Pp]] module.

<<>>=
val decl       : bool -> Ast.decl  -> Pp.doc
val program    : Ast.toplevel list -> Pp.doc
@


% ------------------------------------------------------------------  
\subsection{Implementation}
% ------------------------------------------------------------------  

The implementation builds an abstract representation of the pretty
printed concrete syntax in a purely functional way. The abstract
representation is than written to an open file.

<<astpp.ml>>=
module A = Ast
module P = Pp
module E = Error

let (^^)   = P.(^^)
let (^/)   = P.(^/)
let (~~) x = x
@ 

The module [[Pp]] provides the pretty printing primitives.  The
concatenation of two abstract pretty printed objects is denoted by the
infix operator [[^^]].  We define two more:  [[~~]] and [[~/]]; the
first is a prefix operator that does nothing; its only purpose is to
achieve a more consistent source code layout. In the following example
all nested code is also nested in the source code.

<<example>>=
let f (x,y,z) = 
    nest begin
    ~~ x
    ^/ y
    ^/ z
    end
@

The second operator [[^/]] joins two objects with a [[break]].  A
[[break]] is either represented as a space, or as a line break
followed by a number of spaces for indentation.  The exact outcome is
determined by the pretty printer.  It is easiest to think of
[[break]]s as spaces that might be turned into line breaks.

<<astpp.ml>>=
let nest       = P.nest 4 

@ The [[commablock]] is just a handy special case of the [[block]]
defined in [[Pp]]. 

<<>>=
let commablock f xs =
    nest begin
    ~~ P.list (P.text "," ^^ P.break) f xs
    end

@ To indent a group we provide [[angrp]] and [[fngrp]]; [[fngrp]] is a
nested [[fgrp]]. While inside an [[agrp]] all breaks are either turned
into spaces or newlines, each break inside a [[fgrp]] is considered
separately. Only breaks at the end of a line is turned into a newline
to make new room -- as many as possible breaks are printed as spaces.
    
<<>>=
let angrp x =
    P.agrp begin 
    ~~ nest begin
       ~~ x
       end
    end

let fngrp x =
    P.fgrp begin 
    ~~ nest begin
       ~~ x
       end
    end
@

Most of the names used below refer directly to the grammar or abstract
syntax.  Since the overall purpose of this is clear we don't comment
the code much.

<<>>=
let unzip = List.split
let zip   = List.combine


let id i        = P.text i
let int n       = P.text (string_of_int n)
let intlit n    = P.text n
let float f     = P.text f
let semi        = P.text ";"
@ 

Comments are not part of the abstract syntax and thus they are
only created for informational purposes in this module.  The argument
passed to [[comment]] must not contain only matching [[/*]] and [[*/]]

<<>>=
let comment x   = P.text "/* " ^^ P.text x ^^ P.text " */"
@ 

Todo:  write functions that escape unprintable characters in literals.

<<>>=
let str s       = P.text ("\"" ^ String.escaped s ^ "\"")
let char c      = P.text ("'"  ^ String.escaped c   ^ "'" )

<<>>=
let rec ty = function
    | A.TyAt(x,_)       -> ty x
    | A.BitsTy(n)       -> P.text "bits"  ^^ int n
    | A.AliasTy(name)   -> P.text name
<<>>=        
let rec lvalue = function
    | A.LValueAt(x,_)   -> lvalue x
    | A.Var(None,x)     -> id x
    | A.Var(Some h,x)   -> str h ^/ id x
    | A.Mem(t,e,a)      -> 
        ~~ ty t 
        ^^ P.text "["
        ^^ expr e 
        ^^ begin match a with 
                | Some i -> P.break ^^ P.text "aligned" ^/ int i 
                | None   -> P.empty
           end 
        ^^ P.text "]"
                        
and actual = function
    | ( Some hint, e) -> P.agrp (str hint ^/ expr e)
    | ( None     , e) -> expr e

and actuals xs = P.agrp (P.text "(" ^^ P.commalist actual xs ^^ P.text ")")

<<>>=    
and expr = function
    | A.ExprAt(x,_)             -> expr x
    | A.Int( i, None)           -> intlit i
    | A.Int( i, Some size)      -> intlit i ^^ P.text ":" ^^ int size
    | A.Float( f, None)         -> float f
    | A.Float( f, Some size)    -> float f ^^ P.text ":" ^^ int size
    | A.Char( c, None)          -> char c 
    | A.Char( c, Some size)     -> char c ^^ P.text ":" ^^ int size
    | A.Fetch(v)                -> lvalue v
    | A.BinOp(l,op,r)           -> P.agrp begin
                                 ~~ P.text "(" ^^ expr l
                                 ^^ nest begin
                                    ~~ P.text op
                                    ^^ (if op = "%" then P.break else P.empty)
                                    ^^ P.breakWith ""
                                    ^^ expr r
                                    end
                                 ^^ P.text ")"
                                 end

    | A.UnOp(op,e)              -> P.agrp (P.text op ^^ expr e)
    | A.PrimOp(n,xs)            -> P.agrp (P.text "%" ^^ id n ^^ actuals xs)


<<>>=
let memsize = function
    | A.NoSize        -> P.empty
    | A.DynSize       -> P.text "[]"
    | A.FixSize(e)    -> P.text "[" ^^ expr e ^^ P.text "]"

let rec init = function
    | A.InitAt(x,_) -> init x
    | A.InitExprs(es) -> 
            P.fgrp begin
            ~~ P.text "{"
            ^/ nest begin
               ~~ P.commalist expr es
               end
            ^/ P.text "}"
            end
    | A.InitStr(s) -> str s
    | A.InitUStr(s) -> 
            P.agrp begin
            ~~ P.text "unicode"
            ^/ P.text "("
            ^/ nest begin
               ~~ str s
               end
            ^/ P.text ")"
            end

let rec datum = function
    | A.DatumAt(x,_)        -> datum x
    | A.Label(n)            -> id n ^^ P.text ":"
    | A.Align(a)            -> P.agrp (P.text "align" ^/ int a ^^ semi)
    | A.MemDecl(t,m,Some i) -> P.agrp (ty t ^^ memsize m ^/ init i ^^ semi)
    | A.MemDecl(t,m,None)   -> P.agrp (ty t ^^ memsize m ^^ semi) 

<<>>=
let formal (h, v, t, n) =
        P.agrp begin
        ~~ (match h with Some hint -> str hint ^^ P.break | None -> P.empty)
        ^^ (if v = A.Invariant then P.text "invariant" ^^ P.break else P.empty)
        ^^ ty t
        ^/ id n
        end

let formals xs = P.agrp (P.text "(" ^^ P.commalist formal xs ^^ P.text ")")

<<>>=                 
let register is_global (v , t, n, reg) = 
    angrp begin 
    ~~ (if v = A.Invariant then P.text "invariant" ^^ P.break else P.empty)
    ^^ (if is_global       then P.text "register"  ^^ P.break else P.empty)
    ^^ ty t
    ^/ id n
    ^^ (match reg with Some r -> P.break ^^ str r | None -> P.empty)
    ^^ semi
    end 

<<>>=
let altcont (e1,e2) =   
            P.agrp begin 
            ~~ P.text "<" 
            ^^ expr e1 
            ^^ P.text "/" 
            ^/ expr e2
            ^^ P.text ">"
            end

let targets = function
    | []    -> P.empty
    | ts    -> P.agrp (P.text "targets" ^/ nest (P.commalist id ts))
    
let rec flow f =
    let also s ns = P.agrp (P.text "also" ^/ P.text s ^/ P.text "to" 
                         ^/ nest (P.commalist id ns))
    in match f with
    | A.FlowAt(x,_)     -> flow x
    | A.CutsTo(ns)      -> also "cuts"    ns
    | A.UnwindsTo(ns)   -> also "unwinds" ns
    | A.ReturnsTo(ns)   -> also "returns" ns
    | A.Aborts          -> P.text "also aborts"

let flows = function
    | []    -> P.empty
    | xs    -> nest (P.agrp (P.list P.break flow xs))

let conv = function
    | Some cc       -> P.agrp (P.text "foreign" ^/ str cc)
    | None          -> P.empty 

    
<<>>=
let export t ns =
    let export' = function
        | (x, Some y) -> P.agrp (id x ^/ P.text "as" ^/ str y)
        | (x, None  ) -> id x
    in
        P.agrp begin
        ~~ P.agrp begin 
           ~~ P.text "export" 
           ^^ ( match t with 
              | Some t -> P.break ^^ ty t
              | None   -> P.empty
              )
           end
           ^/ commablock export' ns
           ^^ semi
        end


let architecture = function
    | A.Memsize(i)      -> P.agrp (P.text "memsize" ^/ int i)
    | A.ByteorderBig    -> P.agrp (P.text "byteorder" ^/ P.text "big")
    | A.ByteorderLittle -> P.agrp (P.text "byteorder" ^/ P.text "small")


let range = function
    | A.Point(e)        -> expr e
    | A.Range(e1,e2)    -> P.agrp(expr e1 ^/ P.text ".." ^/ expr e2)

<<>>=
let rec stmt = function
    | A.StmtAt(x,_)   -> stmt x
    
    | A.IfStmt ( e, ss1, ss2)    ->
        P.agrp begin
        ~~ P.agrp (P.text "if" ^/ expr e)
        ^/ P.block stmt ss1
        ^^ begin match ss2 with
           | []     -> P.empty
           | ss     -> P.break ^^ P.text "else" ^/ P.block stmt ss
           end
        end
    | A.LabelStmt(n)            -> 
        P.agrp begin
        ~~ id n ^^ P.text ":"
        end
        
    | A.ContStmt(n,ns)          ->
        P.agrp begin
        ~~ P.text "continuation"
        ^^ angrp begin
           ~~ P.break
           ^^ id n
           ^^ fngrp (P.break ^^ P.text "(" ^^ P.commalist id ns ^^ P.text ")")
           ^^ P.text ":"
           end
        end

    | A.SpanStmt(e1,e2,ss)      -> 
        P.agrp begin
        ~~ P.agrp (P.text "span" ^/ expr e1 ^/ expr e2)
        ^/ P.block (body false) ss
        end
    
    | A.AssignStmt(lhs,rhs)          -> 
        P.agrp begin
        ~~ fngrp begin 
           ~~ P.commalist lvalue lhs 
           ^/ P.text "="
           end
        ^^ fngrp begin
           ~~ P.break
           ^^ P.commalist expr rhs
           ^^ semi
           end
        end
<<>>=    
    | A.CallStmt(lhs, cc, e, args, ts, fs) -> 
        angrp begin
        ~~ ( if lhs <> [] 
             then fngrp begin 
                  ~~ P.commalist lvalue lhs 
                  ^/ P.text "="
                  ^^ P.break
                 end
             else P.empty
           )
        ^^ ( match cc with 
           | Some c -> P.agrp (P.text "foreign" ^/ str c ^^ P.break)
           | None   -> P.empty
           ) 
        ^^ angrp begin 
           ~~ expr e
           ^^ fngrp begin 
              ~~ P.break 
              ^^ P.text "(" 
              ^^ P.commalist actual args 
              ^^ P.text ")"
              end
           end
        ^^ (if ts <> [] then P.break ^^ targets ts else P.empty)
        ^^ (if fs <> [] then P.break ^^ flows fs else P.empty)
        ^^ semi
        end
<<>>=        
    | A.PrimStmt(lhs, cc, n, args, fs)     -> 
        angrp begin
        ~~ ( if lhs <> [] then 
                  ~~ P.commalist lvalue lhs 
                  ^/ P.text "="
                  ^^ P.break
             else P.empty
           )
        ^^ ( match cc with 
           | Some c -> P.agrp (P.text "foreign" ^/ str c ^^ P.break)
           | None   -> P.empty
           ) 
        ^^ fngrp begin 
           ~~ P.text "%%" 
           ^^ id n
           ^^ P.break 
           ^^ P.text "(" 
           ^^ P.commalist actual args 
           ^^ P.text ")"
           end
        ^^ (if fs <> [] then P.break ^^ flows fs else P.empty)
        ^^ semi
        end
    
    | A.GotoStmt(e,ts)                      -> 
        angrp begin
        ~~ P.text "goto"
        ^/ expr e
        ^^ (if ts <> [] then P.break ^^ targets ts else P.empty)
        ^^ semi
        end
    | A.CutStmt(e, args, fs)                -> 
        angrp begin
        ~~ P.text "cut to"
        ^/ expr e 
        ^^ fngrp begin 
           ~~ P.break 
           ^^ P.text "(" 
           ^^ P.commalist actual args 
           ^^ P.text ")"
           end
        ^^ (if fs <> [] then P.break ^^ flows fs else P.empty)
        ^^ semi
        end
    | A.ReturnStmt(cc, alt, args)           -> 
        angrp begin
        ~~ ( match cc with 
           | Some c -> P.text "foreign" ^/ str c ^^ P.break
           | None   -> P.empty
           )
        ^^ P.text "return"
        ^^ ( match alt with
           | Some a -> P.break ^^ altcont a ^^ P.break
           | None   -> P.empty
           )
        ^^ fngrp (P.break ^^ P.text "(" ^^ P.commalist actual args ^^ P.text ")") 
        ^^ semi 
        end
    | A.JumpStmt(cc,e,args,ts)              -> 
        angrp begin
        ~~ ( match cc with 
           | Some c -> P.agrp (P.text "foreign" ^/ str c) ^^ P.break
           | None   -> P.empty
           )
        ^^ fngrp begin 
           ~~ (P.text "jump" ^/ expr e)
           ^^ ( if args <> [] then 
                    ~~ P.break 
                    ^^ P.text "(" 
                    ^^ P.commalist actual args 
                    ^^ P.text ")"
                 else 
                    P.empty
              )
           ^^ (if ts <> [] then P.break ^^ targets ts else P.empty)
           end
        ^^ semi
        end
    | A.EmptyStmt -> semi
    | A.SwitchStmt (r,e,arms) -> 
        P.agrp begin
        ~~ P.agrp begin 
           ~~ P.text "switch"
           ^^ ( match r with
              | Some r -> P.agrp begin 
                ~~ P.break 
                ^^ P.text "[" 
                ^^ range r 
                ^^ P.text "]"
                end
              | None   -> P.empty
              )
           ^/ expr e
           end
        ^/ P.agrp (P.block arm arms)
        end
        
and body is_global = function
    | A.BodyAt(x, _)    -> body is_global x
    | A.DeclBody(d)     -> decl is_global d
    | A.StmtBody(s)     -> stmt s
    | A.DataBody(dd)    -> 
            P.agrp begin
            ~~ P.text "stackdata"
            ^/ P.block datum dd
            end
    
and proc (cc,n,fs,ss) =  
    P.agrp begin 
    ~~ P.agrp begin
       ~~ begin match cc with 
          | Some c -> P.text "foreign" ^/ str c ^^ P.break
          | None   -> P.empty
          end
       ^^ id n
       ^^ formals fs
       end
    ^/ P.text "{"
    ^^ nest begin
       ~~ P.break
       ^^ P.list P.break (body false) ss
       end 
    ^/ P.text "}" 
    end

<<>>=
and decl is_global = function
    | A.DeclAt(x,_) -> decl is_global x
    | A.Import( t, ns) -> 
        let import' = function
        | (Some x, y) -> P.agrp (str x ^/ P.text "as" ^/ str y)
        | (None  , y) -> id y
        in
            P.agrp begin
            ~~ P.agrp (P.text "import" ^/ ty t)
            ^/ commablock import' ns
            ^^ semi
            end
    | A.Export( t, ns) -> export t ns
    | A.Const (t,n,e) ->
            P.agrp begin 
            ~~ P.text "const"
            ^^ ( match t with
               | Some t -> P.break ^^ ty t
               | None   -> P.empty
               )
            ^/ id n
            ^/ P.text "="
            ^/ expr e
            ^^ semi
            end
    | A.Registers( rs) ->
            P.vgrp begin
            ~~ P.list P.break (register is_global) rs
            end
    | A.Typedef (t,nn)  -> 
        angrp begin
        ~~ P.text "typedef"
        ^/ ty t
        ^/ P.text "="
        ^/ commablock id nn
        ^^ semi
        end 
    
    | A.Target (arch) -> 
            angrp begin
            ~~ P.text "target"
            ^/ P.list P.break architecture arch
            ^^ semi
            end
    | A.Pragma        -> comment "pragma"

<<>>=
and section = function
    | A.SectionAt(x,_)  -> section x
    | A.Decl(d)         -> decl true d
    | A.Datum( d)       -> datum d
    | A.Procedure(p)    -> proc p
    | A.SSpan( e1, e2, ss) ->  
        P.agrp begin
        ~~ P.agrp (P.text "span" ^/ expr e1 ^/ expr e2)
        ^/ P.block section ss
        end
            
and arm = function
    | A.ArmAt(x,_)          -> arm x
    | A.Case(ranges, stmts) ->
        P.agrp begin
        ~~ P.text "case"
        ^/ P.agrp (P.list (P.text "," ^^ P.break) range ranges)
        ^^ P.text ":"
        ^/ P.block stmt stmts
        end 
<<>>=
let rec toplevel = function
    | A.ToplevelAt(x, _)  -> toplevel x
    | A.Section(name, ss) -> 
            P.agrp begin 
            ~~ P.agrp (P.text "section" ^/ str name)
            ^/ P.block section ss
            end
    | A.TopDecl(d)        -> decl true d
    | A.TopProcedure(p)   -> proc p

let program ds = P.vgrp begin
                  ~~ P.list (P.break ^^ P.break) toplevel ds
                  ^^ P.break
                  end
                                            
let ppToFile fd width prog = Pp.ppToFile fd width (program prog)
@

The function [[pp]] scans, parses, and pretty prints a file to
standard output.  The second argument controls the the line width the
output is formatted for.  This function implements the [[-pp]] flag of
the command line and is called from the [[Main]] module. 

<<>>=
let pp file width =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg     in
    let finally ()  = close_in fd                            in
    let lexbuf      = Lexing.from_channel fd                 in
    let map         = Srcmap.empty                           in
    let scanner     = Scan.scan map                          in
    let _           = Srcmap.sync map 0 (file,1,1)           in
    let pp ()       = let ast = Parse.program scanner lexbuf in
                         (E.Ok (ppToFile stdout width ast))
        in try pp () with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.Error
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.Error
              )
            | e  ->
              ( finally()
              ; raise e
              )
@
