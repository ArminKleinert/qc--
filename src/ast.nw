%
% $Id$
%

% ------------------------------------------------------------------  
\section{Abstract Syntax Definition}\label{sec:ast}
% ------------------------------------------------------------------  

\ifhtml\tableofcontents\fi

% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml


The abstract syntax for \C~is not directly encoded into \ocaml~data
types but specified as an \asdl~\cite{adsl97} definition.  The
\asdl~compiler generates suitable data types and additionally code to
serialize the abstract syntax.  This permits to exchange the abstract
syntax with applications written in languages other than \ocaml~more
easily. 

The abstract syntax is specified in [[ast.asdl]]; the resulting
modules are [[Ast]] and [[AstUtil]].

<<ast.asdl>>=
module ast {
    <<ast declaration>>
}

<<ast declaration>>=
name        = (string)
conv        = (string)  -- names for calling conventions
hint        = (string)  -- hints for register allocation
reg         = (string)  -- names for global registers
target      = (string)  -- labels
size        = (int)     -- power of 2 (bits8, float16, ..)
align       = (int)     -- power of 2
aligned     = (int)     -- power of 2
op          = (string)

@ Every important node is wrapped by a node that includes a source
code position [[region]].  This is the character span in the input
character stream that covers the node.  The first character in the
stream has index 0.  The first number in a [[region]] denotes the
first character covered by the node, the second number the first
character \textit{after} the node.

<<ast declaration>>=
region      = (int,int) -- (* Srcmap.reg *)

program     = (topdecl*)

topdecl     = TopDeclAt (topdecl, region)
            | Import  (ty, name*)
            | Export  (name*)
            | Const   (const*)
            | Section (name, section*)
            | Global  (register*)
            -- pragmas
            | Pragma                          -- just for testing

@ Extensions to the language are syntactically covered by [[pragma]]s. 
Extensions that are recognized by this implementation cover them in
the abstract syntax.  For testing purposes currently a meaningless
[[Pragma]] constructor is returned by the parser for recognized
pragmas. 

<<ast declaration>>=

const       = (name, expr)

register    = (invariant, ty, name, reg?)

section     = SectionAt(section, region)
            | SSpan (expr key, expr value, section*)
            | Datum (datum)
            | Procedure ( conv?
                        , name
                        , formal*
                        , decl*
                        , stmt*
                        )
memsize     = NoSize
            | DynSize
            | FixSize (expr)
                       
datum       = DatumAt (datum, region)
            | Label (name)
            | Align (align)
            | MemDecl (ty, memsize, init?)

@ Escape sequence in the concrete syntax of strings and character
literals are removed during the translation to the abstract syntax. 
So [[InitStr]] and [[InitUStr]] do not contain escaped characters.

<<ast declaration>>=
init        = InitAt (init, region)
            | InitExprs (expr*)
            | InitStr   (string)
            | InitUStr  (string)

ty          = TyAt (ty, region)
            | BitsTy  (size)
            | FloatTy (size)

@ To encode the [[invariant]] keyword a boolean value would suffice.
But this type is not provided by \asdl.

<<ast declaration>>=

invariant   = Invariant
            | Variant

formal      = (hint?, invariant, ty, name)
actual      = (hint?, expr)

decl        = DeclAt (decl, region)
            | Register  (invariant, ty, name)
            | Stackdata (datum*)
           
flow        = FlowAt (flow, region)
            | CutsTo    (name*)
            | UnwindsTo (name*)
            | ReturnsTo (name*)
            | Aborts    

lvalue      = LValueAt (lvalue, region)
            | Var (name)
            | Mem (ty, expr, aligned?)

assign      = (lvalue,expr)
altcont     = (expr, expr)

stmts       = (stmt*)
targets     = (target*)
flows       = (flow*)
lvalues     = (lvalue*)

@ The abstract syntax does not make a difference between an empty list
of statements and an absent optional list of statements. An [[if]]
statement without an [[else]] block looks on this level like an [[if]]
with an empty [[else]] block.

<<ast declaration>>=

stmt        = StmtAt (stmt, region)
            | IfStmt     (expr, stmts, stmts)
            | LabelStmt  (name)
            | ContStmt   (name, name*)
            | SpanStmt   (expr key, expr value, stmts)
            | AssignStmt (assign*)
            | CallStmt   (lvalue*, conv?, expr, actual*, targets, flows)
            | PrimStmt   (lvalue*, conv?, name, actual*, flows)
            | GotoStmt   (expr, targets)
            | JumpStmt   (conv?, expr, actual*, targets)
            | CutStmt    (name, actual*, flows)
            | ReturnStmt (conv?, altcont?, actual*)
            | EmptyStmt  

expr        = ExprAt (expr, region)
            | Int    (int,size?)
            | Float  (string,size?)
            | Char   (string,size?)
            | Fetch  (lvalue)
            | BinOp  (expr, op, expr)
            | UnOp   (op, expr)
            | PrimOp (name, actual*)

@ Infix operators are abbreviations for primitive operations. The
parser could perform this translation right away. But we want to
unparse the abstract syntax back to concrete syntax and thus we keep
them. 

% ------------------------------------------------------------------  
\section{Pretty Printer}\label{sec:astpp}
% ------------------------------------------------------------------  

For debugging and regression testing we provide a module that pretty
prints the abstract syntax into the concrete syntax.  The
implementation uses an implementation of Philip Wadler's algebraic
pretty printer \cite{wadler99:_a_prettier_printer} from the [[Pp]]
module. 

% ------------------------------------------------------------------  
\subsection{Interface}
% ------------------------------------------------------------------  

The interface provides a function [[ppToFile]] to print a program in
abstract syntax to an open file.  The second parameter controls the
line width the output is formatted for.

<<astpp.mli>>=
val ppToFile : out_channel -> int -> Ast.program -> unit

@ For error reporting it is useful to obtain pretty printed fragments
of a program.  The following list of functions provides pretty
printing for important non terminals in a program.  Each function
returns a [[Pp.doc]] value that can be turned into a [[string]] with
the help of the [[Pp]] module.

<<astpp.mli>>=
val ty : Ast.ty -> Pp.doc
val lvalue : Ast.lvalue -> Pp.doc
val actual : Ast.actual -> Pp.doc
val actuals : Ast.actual list -> Pp.doc
val expr : Ast.expr -> Pp.doc
val constant : string * Ast.expr -> Pp.doc
val memsize : Ast.memsize -> Pp.doc
val init : Ast.init -> Pp.doc
val datum : Ast.datum -> Pp.doc
val decl : Ast.decl -> Pp.doc
val flow : Ast.flow -> Pp.doc
val flows : Ast.flow list -> Pp.doc
val stmt : Ast.stmt -> Pp.doc
val section : Ast.section -> Pp.doc
val register : Ast.invariant * Ast.ty * string * string option -> Pp.doc
val topdecl : Ast.topdecl -> Pp.doc
val program : Ast.topdecl list -> Pp.doc
@


% ------------------------------------------------------------------  
\subsection{Implementation}
% ------------------------------------------------------------------  

The implementation builds an abstract representation of the pretty
printed concrete syntax in a purely functional way. The abstract
representation is than written to an open file.


<<astpp.ml>>=

open Pp     (* pretty printer from cllib *)
open Ast    (* abstract syntax *)


@ The module [[Pp]] provides the pretty printing primitives.  The
concatenation of two abstract pretty printed objects is denoted by the
infix operator [[^^]].  We define two more; the first is only to
achieve a more consistent source code layout.  The second joins two
objects with a [[break]].  A [[break]] is either represented as a
space, or as a line break followed by a number of spaces for
indentation.  The exact outcome is determined by the pretty printer. 
It is easiest to think of [[break]]s as spaces that might be turned
into line breaks.

<<astpp.ml>>=

let (~~) x     = x
let (^/) x y   = x ^^ break ^^ y 

@ To achieve a consistent nesting we re-define here the nesting operator.

<<astpp.ml>>=

let nestn      = nest      (* save old definition *)
let nest       = nest 4    (* define new nest with standard indentation *)


@ A list of objects which are seperated by some seperator is very
common.  The [[list]] function takes care to insert the separator only
bewteen objects.  It creates a [[sep]] separated list.  Individual
items are printed using [[f]].  For the common case where commas are
used for separating we also provide an extra definition.

<<astpp.ml>>=

let rec list sep f xs =
    let rec loop acc = function
        | []    -> acc
        | [x]   -> acc ^^ f x 
        | x::xs -> loop (acc ^^ f x ^^ sep) xs
    in
        loop empty xs 


let commalist f = list (text "," ^^ break) f

@ A [[block]] contains objects [[xs]] formatted by [[f]] and enclosed
by curly braces.  Its body will be indented in case it does not fit on
a single line.  The [[commablock]] is just a handy special case. 

<<astpp.ml>>=

let block f xs =   
    text "{"
    ^^ nest begin
       ~~ break
       ^^ list break f xs
       end 
    ^/ text "}"

let commablock f xs =
    nest begin
        ~~ break
        ^^ list (text "," ^^ break) f xs
    end

@ To indent a group we provide [[angrp]] and [[fngrp]]; [[fngrp]] is a
nested [[fgrp]]. While inside an [[agrp]] all breaks are either turned
into spaces or newlines, each break inside a [[fgrp]] is considered
separately. Only breaks at the end of a line is turned into a newline
to make new room -- as many as possible breaks are printed as spaces.
    
<<astpp.ml>>=

let angrp x =
    agrp begin 
       ~~ nest begin
          ~~ x
          end
       (* *)
    end

let fngrp x =
    fgrp begin 
       ~~ nest begin
          ~~ x
          end
       (* *)
    end

@ Most of the names used below refer directly to the grammar or
abstract syntax.  Since the overall purpose of this is clear we don't
comment the code much.

Why does the \ocaml~[[List]] module does not provide [[zip]] and
[[unzip]]? 

<<astpp.ml>>=

let unzip pairs =
    let rec loop ((left,right) as result) = function
        | []            -> result
        | (l,r)::rest   -> loop (l::left, r::right) rest
    in
        loop ([],[]) pairs


let id i        = text i
let int n       = text (string_of_int n)
let float f     = text f
let semi        = text ";"

let comment x   = text "/* " ^^ text x ^^ text " */"

@ The escape functions provided by \ocaml~do not exactly match the
escape rules of \C. We must replace them with our own.

<<astpp.ml>>=

let str s       = text ("\"" ^ String.escaped s ^ "\"")
let char c      = text ("'"  ^ String.escaped c   ^ "'" )

let rec ty = function
    | TyAt(x,_)       -> ty x
    | BitsTy(n)       -> text "bits"  ^^ int n
    | FloatTy(n)      -> text "float" ^^ int n
    
let rec lvalue = function
    | LValueAt(x,_)   -> lvalue x
    | Var(x)          -> id x
    | Mem(t,e,a)      -> 
        ~~ ty t 
        ^^ text "["
        ^^ expr e 
        ^^ begin match a with 
                | Some i -> break ^^ text "aligned" ^/ int i 
                | None   -> empty
           end 
        ^^ text "]"
                        
and actual = function
    | ( Some hint, e) -> agrp (str hint ^/ expr e)
    | ( None     , e) -> expr e

and actuals xs = agrp (text "(" ^^ commalist actual xs ^^ text ")")
    
and expr = function
    | ExprAt(x,_)             -> expr x
    | Int( i, None)           -> int i
    | Int( i, Some size)      -> int i ^^ text ":" ^^ int size
    | Float( f, None)         -> float f
    | Float( f, Some size)    -> float f ^^ text ":" ^^ int size
    | Char( c, None)          -> char c 
    | Char( c, Some size)     -> char c ^^ text ":" ^^ int size
    | Fetch(v)                -> lvalue v
    | BinOp(l,op,r)           -> agrp begin
                                     ~~ text "(" ^^ expr l
                                     ^^ nest begin
                                        ~~ text op
                                        ^^ breakWith ""
                                        ^^ expr r
                                        end
                                     ^^ text ")"
                                   end

    | UnOp(op,e)              -> agrp (str op ^^ expr e)
    | PrimOp(n,xs)            -> agrp (text "%" ^^ id n ^^ actuals xs)

let constant (name,e) =       agrp begin 
                                ~~ id name 
                                ^/ text "="
                                ^/ nest begin
                                    ~~ expr e
                                    ^^ semi
                                   end
                                end

let memsize = function
    | NoSize        -> empty
    | DynSize       -> text "[]"
    | FixSize(e)    -> text "[" ^^ expr e ^^ text "]"

let rec init = function
    | InitAt(x,_) -> init x
    | InitExprs(es) -> 
            fgrp begin
                ~~ text "{"
                ^/ nest begin
                    ~~ commalist expr es
                end
                ^/ text "}"
            end
    | InitStr(s) -> str s
    | InitUStr(s) -> 
            agrp begin
                ~~ text "unicode"
                ^/ text "("
                ^/ nest begin
                   ~~ str s
                   end
                ^/ text ")"
            end

let rec datum = function
    | DatumAt(x,_)        -> datum x
    | Label(n)            -> id n ^^ text ":"
    | Align(a)            -> agrp (text "align" ^/ int a ^^ semi)
    | MemDecl(t,m,Some i) -> agrp (ty t ^^ memsize m ^/ init i ^^ semi)
    | MemDecl(t,m,None)   -> agrp (ty t ^^ memsize m ^^ semi) 

let formal ( h, v, t, n) =
        agrp begin
            ~~ (match h with Some hint -> str hint ^^ break | None -> empty)
            ^^ (if v = Invariant then text "invariant" ^^ break else empty)
            ^^ ty t
            ^/ id n
        end

let formals xs = agrp (text "(" ^^ commalist formal xs ^^ text ")")

let rec decl = function
    | DeclAt(x,_)   -> decl x
    | Register( Invariant, t, n) ->   
            agrp begin
                ~~ text "invariant"
                ^/ ty t
                ^/ id n
                ^^ semi
            end

    | Register( Variant  , t, n) ->   
            agrp begin 
                ~~ ty t
                ^/ id n
                ^^ semi
            end
    
    | Stackdata( dd) ->                
            agrp begin
                ~~ text "stackdata"
                ^/ block datum dd
            end


let altcont (e1,e2) =   
            agrp begin 
                ~~ text "<" 
                ^^ expr e1 
                ^^ text "/" 
                ^/ expr e2
                ^^ text ">"
            end

let targets = function
    | []    -> empty
    | ts    -> agrp (text "targets" ^/ nest (commalist id ts))
    
let rec flow f =
    let also s ns = agrp (text "also" ^/ text s ^/ text "to" 
                         ^/ nest (commalist id ns))
    in match f with
    | FlowAt(x,_)     -> flow x
    | CutsTo(ns)      -> also "cuts"    ns
    | UnwindsTo(ns)   -> also "unwinds" ns
    | ReturnsTo(ns)   -> also "returns" ns
    | Aborts          -> text "also aborts"

let flows = function
    | []    -> empty
    | xs    -> nest (agrp (list break flow xs))


let conv = function
    | Some cc       -> agrp (text "foreign" ^/ str cc)
    | None          -> empty 

let dummy = text "<stmt>;"

let rec stmt = function
        
    | StmtAt(x,_)   -> stmt x
    | IfStmt ( e, ss1, ss2)    -> 
        agrp begin
            ~~ agrp (text "if" ^/ expr e)
            ^/ block stmt ss1
            ^^ begin match ss2 with
               | []     -> empty
               | ss     -> break ^^ text "else" ^/ block stmt ss
               end
        end
    | LabelStmt(n)            -> 
        agrp begin
            ~~ id n ^^ text ":"
        end
        
    | ContStmt(n,ns)          ->
        agrp begin
            ~~ text "continuation"
            ^^ angrp begin
               ~~ break
               ^^ id n
               ^^ fngrp (break ^^ text "(" ^^ commalist id ns ^^ text ")")
               ^^ text ":"
               end
            (* *)
        end

    | SpanStmt(e1,e2,ss)      -> 
        agrp begin
            ~~ agrp (text "span" ^/ expr e1 ^/ expr e2)
            ^/ block stmt ss
        end
    
    | AssignStmt(xs)          -> 
        let lhs,rhs = unzip xs in
        agrp begin
            fngrp begin 
            ~~ commalist lvalue lhs 
            ^/ text "="
            end
            ^^
            fngrp begin
            ~~ break
            ^^ commalist expr rhs
            ^^ semi
            end
        end
    
    | CallStmt( lhs, cc, e, args, ts, fs) -> 
        angrp begin
            ~~ ( if lhs <> [] 
                 then fngrp begin 
                      ~~ commalist lvalue lhs 
                      ^/ text "="
                      ^^ break
                     end
                 else empty
               )
            ^^ ( match cc with 
               | Some c -> agrp (text "foreign" ^/ str c ^^ break)
               | None   -> empty
               ) 
            ^^ angrp begin 
               ~~ expr e
               ^^ fngrp begin 
                  ~~ break 
                  ^^ text "(" 
                  ^^ commalist actual args 
                  ^^ text ")"
                  end
               end
            ^^ (if ts <> [] then break ^^ targets ts else empty)
            ^^ (if fs <> [] then break ^^ flows fs else empty)
            ^^ semi
        end
        
    | PrimStmt( lhs, cc, n, args, fs)     -> 
        angrp begin
            ~~ ( if lhs <> [] 
                 then fngrp begin 
                      ~~ commalist lvalue lhs 
                      ^/ text "="
                      ^^ break
                     end
                 else empty
               )
            ^^ ( match cc with 
               | Some c -> agrp (text "foreign" ^/ str c ^^ break)
               | None   -> empty
               ) 
            ^^ angrp begin 
               ~~ text "%%" 
               ^^ id n
               ^^ fngrp begin 
                  ~~ break 
                  ^^ text "(" 
                  ^^ commalist actual args 
                  ^^ text ")"
                  end
               end
            ^^ (if fs <> [] then break ^^ flows fs else empty)
            ^^ semi
        end
    | GotoStmt(e,ts)                      -> 
        agrp begin
            ~~ text "goto"
            ^/ expr e
            ^^ (if ts <> [] then break ^^ targets ts else empty)
            ^^ semi
        end
    | CutStmt(n, args, fs)                -> 
        angrp begin
            ~~ text "cut to"
            ^/ id n
            ^^ fngrp (break ^^ text "(" ^^ commalist actual args ^^ text ")")
            ^^ (if fs <> [] then break ^^ flows fs else empty)
            ^^ semi
        end
    | ReturnStmt(cc, alt, args)           -> 
        angrp begin
            ~~ ( match cc with 
               | Some c -> text "foreign" ^/ str c ^^ break
               | None   -> empty
               )
            ^^ text "return"
            ^^ ( match alt with
               | Some a -> break ^^ altcont a ^^ break
               | None   -> empty
               )
            ^^ fngrp (break ^^ text "(" ^^ commalist actual args ^^ text ")") 
            ^^ semi 
        end
    | JumpStmt(cc,e,args,ts)              -> 
        angrp begin
            ~~ ( match cc with 
               | Some c -> agrp (text "foreign" ^/ str c) ^^ break
               | None   -> empty
               )
            ^^ angrp (text "jump" ^/ expr e)
            ^^ ( if args <> [] 
                 then fngrp begin 
                            ~~ break 
                            ^^ text "(" 
                            ^^ commalist actual args 
                            ^^ text ")"
                            end
                 else empty
               )
            ^^ (if ts <> [] then break ^^ targets ts else empty)
            ^^ semi
        end
    | EmptyStmt                           -> text ";"

let rec section = function
    | SectionAt(x,_) -> section x
    | SSpan( e1, e2, ss) ->  
            agrp begin
                agrp (text "span" ^/ expr e1 ^/ expr e2)
                ^/ block section ss
            end
    | Datum( d) ->  
            datum d
    | Procedure(cc,n,fs, ds, ss)  ->  
            agrp begin 
                agrp begin
                    begin match cc with 
                    | Some c -> text "foreign" ^/ str c ^^ break
                    | None   -> empty
                    end
                    ^^ id n
                    ^^ formals fs
                end
                ^/ text "{"
                ^^ nest begin
                   ~~ break
                   ^^ list break decl ds
                   ^^ break ^^ break
                   ^^ list break stmt ss
                   end 
                ^/ text "}" 
            end
                 
let register ( v , t, n, reg) = 
    agrp begin 
        ~~ (if v = Invariant then text "invariant" ^^ break else empty)
        ^^ ty t
        ^/ id n
        ^^ (match reg with Some r -> break ^^ str r | None -> empty)
        ^^ semi
    end 

let rec topdecl = function
    | TopDeclAt(x,_) -> topdecl x
    | Import( t, ns) -> 
            agrp begin 
                agrp (text "import" ^/ ty t)
                ^/ commablock id ns
                ^^ semi
            end
    | Export( ns) ->
            agrp begin 
                ~~ text "export"
                ^/ commablock id ns
                ^^ semi
            end 
    | Const ( cs) ->
            agrp begin 
                ~~ text "const"
                ^/ block constant cs
            end
    | Section( n, ss) ->
            agrp begin 
                agrp (text "section" ^/ str n)
                ^/ block section ss
            end
                   
    | Global( rs) ->
            agrp begin 
                ~~ text "global"
                ^/ block register rs
            end
    | Pragma ->
            comment "<pragma>"

let program(ds) = vgrp begin
                        ~~ list (break ^^ break) topdecl ds
                        ^^ break
                    end
            
                                            
let ppToFile fd width prog = Pp.ppToFile fd width (program prog)
                        
@
