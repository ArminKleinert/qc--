
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution AST AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ################################################################## 
\section{Register}
% ################################################################## 

A [[Register.t]] describes a target-specific register-like location. 
Such a location includes hardware-registers, spill-locations for
hardware-register or temporaries. The destinguishing feature of a
register is its fixed address within its space: the address is an
integer rather than a general expression.

A [[t]] value includes the target-specific [[space]], its address
within that space, and the [[width]] of the addressed cell.  Other
details, like the width of of addressing expression or the aggregation
scheme of multiple cells is associated with the [[space]], but not
included in a [[t]] value.  They can, however, obtained from the
[[Target.t]] description of the target the register belongs to.

<<type t>>=
type t = Rtl.space * Base.std_int * Rtl.width
@

<<register.mli>>=
<<type t>>
module Set: Set.S with type elt = t
module Map: Map.S with type key = t
@

A register is a special case of a location.  We would like to have 
functions that converts between these two. Of course, a [[Rtl.loc]] is
more general and thus only values denoting a register can be
converted. Applying other values is a checked run-time error.

The space description supplied to [[to_loc]] must fit to the space of
the first argument, otherwise it is a checked run-time error.

<<not yet implemented>>=
val to_loc: t -> Rtl.spacedescr -> Rtl.loc   (* Invalid_argument *)
val of_loc: Rtl.loc -> t                     (* Invalid_argument *)
@

% ------------------------------------------------------------------ 
\section{Implementation}
% ------------------------------------------------------------------ 

<<register.ml>>=
module R  = Rtl
module RP = Rtl.Private

<<type t>>

module Compare = struct
    <<type t>>
    let compare = compare
end
module Set = Set.Make(Compare)
module Map = Map.Make(Compare)

let to_loc (sp,index,width) spec =
    let _     = if (width <> spec.R.cellwidth) then
                         invalid_arg "Register.to_loc"        in
    let agg   = spec.R.byteorder                              in
    let bits  = Bits.of_int index spec.R.addrwidth            in
    let addr  = Rtl.bits bits spec.R.addrwidth                in
        Rtl.cell Rtl.none sp spec.R.byteorder width addr

let of_loc loc = match Rtl.Convert.loc loc with
    | RP.Cell(sp,_,width,exp,_) -> 
        let exp   = Rtl.Revert.exp exp in
        let index = ( match Rtleval.compile Rtleval.empty exp with
                    | Error.Ok(bits) -> Bits.to_int bits
                    | Error.Error    -> invalid_arg "Register.of_loc"
                    )
        in
            (sp,index,width)
    | _                         -> invalid_arg "Register.of_loc"
@


