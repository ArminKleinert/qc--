% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution AST AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ################################################################## 
\section{Register}
% ################################################################## 

A [[Register.t]] describes a target-specific register-like location.
Such a location includes hardware-registers or temporaries, but not
spill locations.  The distinguishing feature of a register is a fixed
address within its space: the address is an integer rather than a
general expression.

A [[t]] value includes the target-specific [[space]], its address
within that space, and the [[width]] of the addressed cell.  Other
details, like the width of of addressing expression or the aggregation
scheme of multiple cells is associated with the [[space]], but not
included in a [[t]] value.  They can, however, obtained from the
[[Target.t]] description of the target the register belongs to.

<<type t>>=
type t = Rtl.space * Base.std_int * Rtl.width
@

<<register.mli>>=
<<type t>>
module Set: Set.S with type elt = t
module Map: Map.S with type key = t
@

A register is a special case of a [[Rtl.loc]] location.  We would like
to have functions that converts between these two.  Of course, a
[[Rtl.loc]] is more general and thus only values denoting a register can
be converted.  Applying other values is a checked run-time error.
\emph{ALERT! What is semantics of first argument to [[to_loc]]?? ---NR.}
The [[Rtl.space]] value that is part of a register by itself does not
include the aggregation and width of the index expression. Therefore
[[to_loc]] receives as its first argument a map, that provides a
complete description for a given space.

<<register.mli>>=
val to_loc: (Rtl.space -> Space.t) -> t -> Rtl.loc   
val of_loc: Rtl.loc -> t                     (* Invalid_argument *)
@

For debugging we sometimes want to print a register, or a set of
registers:

<<register.mli>>=
val print: t -> string         
val print_set: Set.t -> string
@


% ------------------------------------------------------------------ 
\section{Implementation}
% ------------------------------------------------------------------ 

<<register.ml>>=
module R    = Rtl
module S    = Space
module RP   = Rtl.Private

<<type t>>

module Compare = struct
    <<type t>>
    let compare = compare
end
module Set = Set.Make(Compare)
module Map = Map.Make(Compare)

let to_loc lookup (sp,index,width) =
    let spec  = lookup sp                                     in
    let agg   = spec.S.aggregation                            in
    let bits  = Bits.U.of_int index spec.S.indexwidth         in
    let addr  = Rtl.bits bits spec.S.indexwidth               in
        Rtl.cell Rtl.none sp spec.S.aggregation width addr

let of_loc loc = match Rtl.Convert.loc loc with
    | RP.Cell(sp,_,width,exp,_) -> 
        let exp   = Rtl.Revert.exp exp in
        let index = ( try Bits.U.to_int (Rtleval.compile exp) with
                    | Error.ErrorExn _ 
                    | Bits.Overflow   -> invalid_arg "Register.of_loc" 
                    )
        in
            (sp,index,width)
    | _                         -> invalid_arg "Register.of_loc"
@

\iffalse
Spill slots are maintained by an [[Automaton.t]] that hands out
[[Automaton.loc]] positions. We exploit the fact that we know that the
automaton at hand alwas issues locations that can be converted to
[[Rtl.loc]] locations.
\fi

<<register.ml causes cyclic dependencies with>>=
let spill_slot automaton (sp,index,width) =
    let loc:Automaton.loc = Automaton.ty automaton width None in
    let loc:Rtl.loc       = Automaton.to_loc loc              in 
        loc
@

% ------------------------------------------------------------------ 
\subsection{For Debugging Only}
% ------------------------------------------------------------------ 

<<register.ml>>=
let print (sp,index,width) = Printf.sprintf "$%c[%d](%d)" sp
    (Base.of_std_int index) width
let print_set set          = 
    String.concat " " (Set.fold (fun t acc -> (print t)::acc) set []) 
@
    

