% vim: ts=8 sw=4 et:

% ------------------------------------------------------------------ 
\section{Sparc Code Expander}
% ------------------------------------------------------------------ 

This module provides an [[expand]] function that re-writes an {\rtl}
into a sequence of {\rtl}s such that each is representable as a machine
instruction on the {\sparc}. Hence, the code expander establishes the
\emph{machine invariant} for the {\sparc}.

The code expander is implemented as a {\burg} rule set. All auxiliary
functions are into the [[head]] and [[tail]] section of the {\burg}
specification.

<<sparcexpander.mlb>>=
%head {: <<head>> :}
<<terminal types>>
%tail {: <<tail>> :}
%%
<<rules>>
@

% ------------------------------------------------------------------ 
\subsection{Utilities}
% ------------------------------------------------------------------ 

<<head>>=
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target2
module C  = Camlburg
module D  = Rtl.Convert      (* Convert Down to private repr. *)
module U  = Rtl.Revert       (* Convert Up    to abstract repr. *)
module W  = Rtlutil.Width 
module G  = Cfg3             (* for expanding all RTLs in a CFG *)
module GU = Cfgutil
@

We raise an error exception in case things go wrong. There is no need to
chatch the exception because all errors are fatal.

<<head>>=
exception Error of string
let error msg = raise (Error msg)
@

Many transformations return both a list of {\rtl}s and a location where
a certain value can be found. To avoid the constant pattern matching of
the returned values, we use a monadic programming style. A state monad
[[m]] holds the list of resulting {\rtl}s and a source for temporaries.
The functions [[return]] and [[>>=]] are the two standard monadic
functions \emph{unit} and \emph{bind}.

<<head>>=
type state = R.rtl list * Talloc.Multiple.t
type 'a m  = state -> ('a * state)

let return a  = fun s -> (a, s)
let (>>=) (m: 'a m) (f: 'a -> 'b m) = fun s -> let (a,s) = m s in f a s 
@

We save an {\rtl} to the state with [[exec]]. {\rtl}s are saved in
\emph{reverse exceution order}.

<<head>>=
let exec  rtl  = fun (rtls,tmp) -> ((), (rtl :: rtls,tmp)) 
let pair  x y  = x >>= fun x -> y >>= fun y -> return (x,y)
@

New tempoaries come as integer and floating point varieties. You have to
supply the desired with of the new temporary.

<<head>>=
let itmp w = fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 't' w, state)
let ftmp w = fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'u' w, state)
@

The expander develops expressions into locations and returns them. In an
right-hand-side context a location must be wrapped with a fetch
instruction to form an excpetion. The [[fetch]] function is handy,
because it takes care of the width of a location.

<<head>>=
let fetch   t = R.fetch t (W.loc t)
@

% ------------------------------------------------------------------ 
\subsection{Sparc Instructions}
% ------------------------------------------------------------------ 

<<head>>=
let const n width   = R.bits (Bits.of_int n width) width
let rd n            = R.cell R.none 'r' R.Identity 32 (const n 5)
let fd n            = R.cell R.none 'f' R.Identity 32 (const n 5)
let cd n            = R.cell R.none 'c' R.Identity 32 (const n 5)

let mem addr        = R.cell R.none 'm' R.LittleEndian 32 addr
let pc              = cd 4
let npc             = cd 5  
let zero            = R.fetch (rd 0) 32

let add x y         = R.app (R.opr "add" [32]) [x;y]
let sub x y         = R.app (R.opr "sub" [32]) [x;y]
let (<--) loc e     = R.store loc e (W.exp e)
let sx32 w n        = R.app (R.opr "sx" [w;32]) [n]
let zx32 w n        = R.app (R.opr "zx" [w;32]) [n]
@

Index and displacement are the two addressing modes for load and store
instructions. 

<<head>>=
let index r1 r2     = add (fetch r1) (fetch r2)         (* $r[r1] + $r[r2] *)
let disp r1 imm     = add (fetch r1)  imm               (* $r[r1] + simm13 *) 

(* addr = index r1 r2 | disp r1 imm *)

let ld addr r       = r         <--  fetch (mem addr)
let st r addr       = mem addr  <--  r
let ldf addr f      = f         <--  fetch (mem addr) 
let stf f addr      = mem addr  <--  f
let jmpl addr r     = R.par [npc <-- addr; r <-- fetch pc]
let jmp  addr       = jmpl addr (rd 0)
let or' r1 rc r2    = r2 <-- R.app (R.opr "or" [32]) [r1; rc] 

let mov  rc r       = r <-- rc              (* or' zero rc r *)
let movr r1 r2      = r2 <-- fetch r1       (* or' zero (fetch r1) r2 *)
let ret             = jmpl (disp (rd 7) (const 32 13)) (rd 0)
let fmovs f1 f2     = f2 <-- fetch f1     
let xnor r1 r2 r3   = 
    let xor = R.opr "xor" [32] in
    let com = R.opr "com" [32] in
    r3 <-- R.app xor [fetch r1; R.app com [fetch r2]]
@

Below are the 16 conditional branches. They are represented by fairly
complicated {\rtl}s whose guarding expressions look at the condition
codes. 

<<head>>=
let eq1    x y = R.app (R.opr "eq" [1])  [x;y]      (* bit operations *)
let ne1    x y = R.app (R.opr "ne" [1])  [x;y]      (* bit operations *)
let com1   x   = R.app (R.opr "com" [1]) [x] 
let fetch1 x   = R.fetch x 1     
let xor1   x y = R.app (R.opr "xor" [1]) [x;y]
let or1    x y = R.app (R.opr "or" [1]) [x;y]
let z          = R.fetch (R.slice 1 22 (cd 0)) 1    (* condition codes *)
let n          = R.fetch (R.slice 1 23 (cd 0)) 1
let v          = R.fetch (R.slice 1 21 (cd 0)) 1
let c          = R.fetch (R.slice 1 20 (cd 0)) 1
let z'         = R.slice 1 22 (cd 0)
let n'         = R.slice 1 23 (cd 0)
let v'         = R.slice 1 21 (cd 0)
let c'         = R.slice 1 20 (cd 0)
let zero1      = R.bits (Bits.of_int 0 1) 1

let branch guard target = R.guard guard (R.store (cd 5) target 32)

let ba      = branch (R.bool true)
let bn      = branch (R.bool false)
let bne     = branch (ne1 (com1 z) zero1)
let be      = branch (ne1 z zero1)
let bg      = branch (ne1 (com1 (or1 z (xor1 n v))) zero1)
let ble     = branch (ne1 (or1 z (xor1 n v)) zero1)
let bge     = branch (ne1 (com1 (xor1 n v)) zero1)
let bl      = branch (ne1 (xor1 n v) zero1)
let bgu     = branch (ne1 (com1 (or1 c z)) zero1)
let bleu    = branch (ne1 (or1 c z) zero1)
let bcc     = branch (ne1 (com1 c) zero1)
let bcs     = branch (ne1 c zero1)
let bpos    = branch (ne1 (com1 n) zero1)
let bneg    = branch (ne1 n zero1)
let bvc     = branch (ne1 (com1 v) zero1)
let bvs     = branch (ne1 v zero1)
@

You ain't seen nothing yet. Here comes the [[subcc]] instruction. We
need it to implement [[cmp]].

<<head>>=
let subcc r1 rc r2 =
    let binop32 o x y  = R.app (R.opr o [32]) [x;y] in
    let sub32           = binop32 "sub" in
    let lt32            = binop32 "lt"  in
    let ge32            = binop32 "ge"  in
    let eq32            = binop32 "eq"  in
    let ne32            = binop32 "ne"  in
    let bit31 y         = R.app (R.opr "bitExtract" [32;32;1]) 
                            [R.bits (Bits.of_int 31 32) 32;y] in
    let set   x         = R.store x (R.bits (Bits.of_int 1 1) 1) 1 in
    let reset x         = R.store x (R.bits (Bits.of_int 0 1) 1) 1 in
    let zero32          = R.bits (Bits.of_int 0 32) 32 in
    let and' x y        = R.app (R.opr "conjoin" []) [x;y] in 
    let r1'             = R.fetch r1 32 in    
    let unknown         = zero32 in
    let borrow32 x y z  = R.app (R.opr "borrow" [32]) [x;y;z] in
        R.par
        [ r2 <-- sub32 r1' rc
        ; R.guard   (lt32 r1' zero32) (set n')
        ; R.guard   (ge32 r1' zero32) (reset n')
        ; R.guard   (eq32 r1' zero32) (set z')
        ; R.guard   (ne32 r1' zero32) (reset z')
        ; R.guard   (and' (ne1 (bit31 r1') zero1) 
                          (ne1 (bit31 r1') (bit31 (sub32 r1' unknown))))
                    (set v')
        ; R.guard   (and' (ne1 (bit31 r1') zero1) 
                          (eq1 (bit31 r1') 
                               (bit31 (sub32 r1' unknown))))
                    (reset v')
        ; R.guard   (eq1 (bit31 r1') zero1) (reset v')
        ; c' <-- borrow32 r1' unknown  zero1
        ]

let cmp r rc = subcc r rc (rd 0)
@


The following offset addresses a memory cell relativ to the frame
pointer that is used to move data from floating-point registers to
integer registers and vice versa.

<<head>>=
let mtmp            = add (fetch (rd 30)) (const 8 32)
@

% ------------------------------------------------------------------ 
\subsection{Cost Functions}
% ------------------------------------------------------------------ 

Check that a signed bits [[b]] value fits into [[n]] bits.

<<head>>=
let is_imm n b =
    let rec power2 = function
        | 0 -> 1
        | n -> 2 * power2 (n-1)
    in    
        try 
            let i = Bits.to_int b 
            and c = power2 n in
            (- c) <= i || i <= (c-1)
        with
            Bits.Overflow -> false

let guard n = function
    | true  -> n
    | false -> C.inf_cost 
@

% ------------------------------------------------------------------ 
\subsection{Operator Classes}
% ------------------------------------------------------------------ 

Some operators can be treated alike. We define some class predicates for
them here.

<<head>>=
module StringSet = Set.Make(struct type t = string let compare = compare end)

let setof list = List.fold_right StringSet.add list StringSet.empty

let rrc op = StringSet.mem op 
    (setof ["add"; "and"; "sub"; "shl"; "shra"; "shrl"; "sub"; "xor"])
@

% ------------------------------------------------------------------ 
\subsection{Code Expansion Rules}
% ------------------------------------------------------------------ 

The following table summarizes the nonterminals from the rule set. 

\begin{tabular}{ll}
    Nonterminal & Type & Meaning \\ 
    \hline
    [[reg]]     & [[R.loc m]] 
                & integer computation that yields result in a register\\
    [[freg]]    & [[R.loc m]]
                & same as [[ireg]] for floating-point computations\\
    [[const]]   & [[R.exp]]
                & constant
    [[const13]] & [[R.exp m]]
                & constant that fits into 13 bits\\
    [[rc]]      & [[R.exp m]]
                & 13 bit constant or register\\ 
    [[stmt]]    & [[R.rtl m]]
                & side effect\\
    [[guard]]   & [[(R.loc -> R.rtl) m]]
                & guarding expression for a branch\\
\end{tabular}

In a {\burg} pattern variables hold either polymorphic nonterminal
values, or monomorphic terminal ({\ocaml}) values. Terminal types must
be declared:

<<terminal types>>=
%term k width opr exps agg ass index bool bits link late x symbol
@

\begin{quote}\it
    \begin{itemize}
    
    \item It is not clear what width constants in {\rtl}s that represent
    instructions should have. The recognizer assumes that constants are
    kept in 32 bits. --CL

    \item The recognizer does not know the [[sethi]] instruction and
    thus we cannot load large constants into registers.

    \end{itemize}
\end{quote}


<<rules>>=
const:      Bits(b:bits)        {: R.bits b (Bits.width b)  :}
const:      Link(symbol,width)  {: R.link symbol width      :}
@

If a constant fits into 13 bits we create a 13-bit wide value to pass
it. 

<<rules>>=
const13:    Bits(b:bits) [{: guard 0 (is_imm 13 b):}] 
            {: return (R.bits b (Bits.width b))  :}
@

An [[rc]] nonterminal captures either a small value, or a register. To
ensure that both have the same type, we return a monadic expression.

<<rules>>=
rc:         reg     {: reg >>= fun r -> return (fetch r) :}  
rc:         const13 {: const13                           :}
            
reg:        const13 [1]
            {: 
                const13 >>= fun k ->
                itmp 32 >>= fun t ->
                exec (or' zero k t) >>= fun () ->     (* set *)
                return t
            :}    
reg:        const [1] 
            {: 
                (* error "cannot load large constants" *)
                itmp 32 >>= fun t ->
                exec (t <-- const) >>= fun () ->
                return t
            :}
@

Memory cells addresses are of either form: $\$r[r_1] + \$r[r_2]$, or
$\$r[r_1] + c$. The [[addr]] nonterminal captures these addresses and
chain rules the conversions.

<<rules>>=
addr:       App2("add", reg, rc)
            {: 
                reg >>= fun r  ->
                rc  >>= fun rc ->
                return (add (fetch r) rc)
            :}

addr:       reg     {: reg     >>= fun r -> return (add zero (fetch r)) :}
addr:       const13 {: const13 >>= fun k -> return (add zero k) :}
addr:       const   {: error "cannot handle large constants" :}    


mem:        Cell('m', agg, width, addr, ass)
            {:
                addr >>= fun a ->
                return (R.cell (U.assertion ass) 'm' agg width a)
            :}    
            
stmt:       Store(mem, reg, width) [1]       
            {:
                mem  >>= fun m ->
                reg  >>= fun r ->
                return (m <-- fetch r)  (* st r addr *)
            :}    

stmt:       Store(mem, freg, width) [1]       
            {:
                mem  >>= fun m ->
                freg >>= fun f ->
                return (m <-- fetch f)  (* stf f addr *)
            :}    

reg:        Fetch(mem, width) [1]
            {:
                mem         >>= fun m ->
                itmp width  >>= fun t ->
                exec (t <-- fetch m) >>= fun () -> (* ld addr t *)
                return t
            :}    

freg:       Fetch(mem, width) [1]
            {:
                mem         >>= fun m ->
                ftmp width  >>= fun f ->
                exec (f <-- fetch m) >>= fun () -> (* ldf addr f *)
                return f
            :}    
@

Fetches from registers.

<<rules>>=
reg:        Fetch(reg, width)  {: reg :}
freg:       Fetch(freg, width) {: freg :}
@


Registers are categorized into interger, floating point, and control
registers. Note, that temporaries are treated like hardware registers.

<<rules>>=
reg:        Cell(s:char, agg, width, k:const, ass) 
            [{: guard 0 (s = 'r' || s = 't') :}]
            {:
                return (R.cell (U.assertion ass) s agg width k)
            :}    
            
freg:       Cell(s:char, agg, width, k:const, ass)
            [{: guard 0 (s = 'f' || s = 'u') :}]
            {:
                return (R.cell (U.assertion ass) s agg width k)
            :}    
            
creg:       Cell('c', agg, width, k:const, ass)
            {:
                return (R.cell (U.assertion ass) 'c' agg width k)
            :}    

@

Moves between registers. Data cannot be moved between integer and
floating-point registers directly but has to go trough memory. I would
like to use a fixed memory cell for this on the stack that is part of
the frame layout. The problem is, that I cannot know the offset for this
slot. A different possibility would be the introduction of temporaries
that stand for memory locations. But this would cause changes in the
register allocator. For the moment I assume that $\textit{fp}-8$ is
reserved.

<<rules>>=
stmt:       Store(reg, rc, width) [1]
            {: 
                reg >>= fun r  ->
                rc  >>= fun rc -> 
                return (r <-- rc)
            :}
            
stmt:       Store(f1:freg, f2:freg, width) [1]
            {:
                
                f1 >>= fun f1 ->
                f2 >>= fun f2 ->
                return (fmovs f2 f1)
            :}

stmt:       Store(creg, reg, width) [1]     --- ??
            {:
                creg >>= fun c ->
                reg  >>= fun r ->
                return (c <-- fetch r)
            :}

<<rules>>=
reg:        freg [10] -- penality
            {:
                freg    >>= fun f ->
                itmp 32 >>= fun t ->
                exec (mem mtmp <-- fetch f) >>= fun () ->
                exec (t <-- fetch (mem mtmp)) >>= fun () -> 
                return t
            :}

freg:       reg [10] -- penality
            {:
                reg     >>= fun r ->
                ftmp 32 >>= fun u ->
                exec (mem mtmp <-- fetch r)  >>= fun () ->
                exec (u <-- fetch (mem mtmp)) >>= fun () -> 
                return u
            :}
@

A guard is the conditional expression of a branch and return a
higher-oder function [[(R.loc -> R.rtl) m]].


<<rules>>=
guard:      True()  {: return ba :}
guard:      False() {: return bn :}

guard:      App2("eq", reg, rc) [1]
            {:  reg >>= fun reg -> rc >>= fun rc ->
                exec (cmp reg rc) >>= fun () -> return (be)
            :}
guard:      App2("ge", reg, rc) [1]
            {:  reg >>= fun reg -> rc >>= fun rc ->
                exec (cmp reg rc) >>= fun () -> return (bge)
            :}
guard:      App2("geu", rc, reg) [1] -- reversed args!
            {:  reg >>= fun reg -> rc >>= fun rc ->
                exec (cmp reg rc) >>= fun () -> return (bleu)
            :}
guard:      App2("gt", reg, rc) [1] 
            {:  reg >>= fun reg -> rc >>= fun rc ->
                exec (cmp reg rc) >>= fun () -> return (bg)
            :}
guard:      App2("gtu", reg, rc) [1] 
            {:  reg >>= fun reg -> rc >>= fun rc ->
                exec (cmp reg rc) >>= fun () -> return (bgu)
            :}
guard:      App2("le", reg, rc) [1] 
            {:  reg >>= fun reg -> rc >>= fun rc ->
                exec (cmp reg rc) >>= fun () -> return (ble)
            :}
guard:      App2("leu", reg, rc) [1] 
            {:  reg >>= fun reg -> rc >>= fun rc ->
                exec (cmp reg rc) >>= fun () -> return (bleu)
            :}
guard:      App2("lt", reg, rc) [1] 
            {:  reg >>= fun reg -> rc >>= fun rc ->
                exec (cmp reg rc) >>= fun () -> return (bl)
            :}
guard:      App2("ltu", rc, reg) [1] -- reversed arguments
            {:  reg >>= fun reg -> rc >>= fun rc ->
                exec (cmp reg rc) >>= fun () -> return (bgu)
            :}
guard:      App2("ne", reg, rc) [1] 
            {:  reg >>= fun reg -> rc >>= fun rc ->
                exec (cmp reg rc) >>= fun () -> return (bne)
            :}

rtl:        Branch(guard, reg) [1]
            {:
                guard >>= fun branch ->
                reg   >>= fun target ->
                exec (branch (fetch target)) 
            :}

rtl:        Simple(stmt)
            {:
                stmt >>= fun s ->
                exec (R.par [s]) 
            :}    

rtl:        Nop() {: exec (R.par []) :}        -- skip    
@

{\PAL}'s primitive operators show up in expressions and are mapped to
{\sparc} instructions.

<<rules>>=
            -- ["add"; "and"; "sub"; "shl"; "shra"; "shrl"; "sub"; "xor"]
reg:        App2(o:string, reg, rc) [{: guard 1 (rrc o) :}]
            {:
                reg >>= fun r -> rc >>= fun rc -> itmp 32 >>= fun t ->
                exec (t <-- R.app (R.opr o [32]) [fetch r; rc]) >>= fun ()->
                return t
            :}    

reg:        App1(o:string, reg) [{: guard 1 (List.mem o ["com"; "neg"]) :}]
            {:    
                reg >>= fun r -> itmp 32 >>= fun t ->
                exec 
                    ( match o with
                    | "com" -> xnor r (rd 0) t
                    | "neg" -> t <-- sub zero (fetch r)
                    | _     -> assert false
                    ) >>= fun () ->
                return t
            :}      
                    

reg:        App1(o:string, reg)     [2] {: error ("cannot handle "^o) :}
reg:        App2(o:string, reg, rc) [2] {: error ("cannot handle "^o) :}
reg:        App3(string, x:reg, y:reg, z:reg)  [2] {: error "app3" :}
@

% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

Because it is much easier in {\ocaml} than in {\burg}, we
decompose applications and complex {\rtl}s here.

<<tail>>=  
let const = function
    | RP.Bool(true)             -> conTrue  ()
    | RP.Bool(false)            -> conFalse ()
    | RP.Link(s,w)              -> conLink s w
    | RP.Late(s,w)              -> error "late compile time constant"
    | RP.Bits(b)                -> conBits(b)

let rec exp = function
    | RP.Const(k)               -> const (k)
    | RP.Fetch(l,w)             -> conFetch (loc l) w
    | RP.App((o,_),[x])         -> conApp1 o (exp x)
    | RP.App((o,_),[x;y])       -> conApp2 o (exp x) (exp y)
    | RP.App((o,_),[x;y;z])     -> conApp3 o (exp x) (exp y) (exp z)
    | RP.App(_,_)               -> error "too many arguments in application"

and loc = function
    | RP.Cell(char, aff, w, e, ass) -> conCell char aff w (exp e) ass 
    | RP.Var(s, i, w)           -> error "var found"
    | RP.Slice(w,i,loc)         -> error "cannot handle slice"
    
and stmt = function
    | RP.Store(l,e,w)           -> conStore (loc l) (exp e) w
    | RP.Kill(loc)              -> error "cannot handle kill"

<<tail>>=  
and rtl = function
    | RP.Rtl([(RP.Const(RP.Bool(true)),s)]) -> 
            conSimple (stmt s)
    | RP.Rtl([(e,RP.Store(loc,target,width))]) -> 
            conBranch (exp  e) (exp target)
    | RP.Rtl([]) -> 
            conNop ()
    | RP.Rtl(_) as rtl -> 
            ( List.iter prerr_endline
                [ "cannot expand this RTL:"
                ; RU.ToString.rtl (U.rtl rtl)
                ]
            ; assert false
            )        
@

The [[rtl]] function returns (the best) plan to rewrite a given {\rtl}.
When this plan is executed, it returns a monadic value that includes the
desired expanded {\rtl}s.

<<tail>>=
let expand tmps (r: R.rtl) = 
    let plan = rtl (D.rtl r) in
    try
        match plan.rtl.Camlburg.action () ([],tmps) with
            | (), (rtls,_) -> rtls
    with 
        Camlburg.Uncovered -> 
            ( List.iter prerr_endline
                [ "cannot expand this RTL:"
                ; RU.ToString.rtl r
                ]
            ; assert false
            )
@                        

% ------------------------------------------------------------------ 
\subsection{Expanding an entire {\cfg}}
% ------------------------------------------------------------------ 

{\rtl}s do not live in isolation but belong to a procedure's {\cfg}.
Since procedures are the basic units of compilation we want to expand
all the {\rtl}s of a procedure. This requires to re-write the {\cfg}.

Re-writing the {\cfg} mutates its structure and therefore we have to
obtain first all the nodes whose {\rtl}s we want to expand. We cannot
use the iterator provided by the {\cfg} module because it does not work
under mutation.

[[Cfg]] expands all {\rtl}s of a procedure and returns [[true]], if the 
structure of the procedure's {\cfg} had to be modified.

<<tail>>=
let cfg proc =
    let nodes       = GU.fold_bwd proc.Proc.cfg (fun n ns -> n::ns) []
    and tmps        = proc.Proc.temps   (* source for temporaries *)
    and insert n i  = G.gm_insert_assign_before i n
    and modified    = ref false in
    let expnd node =
        match expand tmps (G.rtl node) with
        | last :: preds ->
            ( ignore (List.fold_left insert node preds)
            ; G.set_rtl node (fun _ -> last)
            ; modified := (preds <> [])
            )
        | [] -> assert false 
    in    
        ( List.iter expnd nodes
        ; !modified
        )
@

% ------------------------------------------------------------------ 
\subsection{Exporting the Expander to Lua}
% ------------------------------------------------------------------ 

Code expansion is part of {\qcc}'s backend that is controlled by a Lua
interpreter. To make the expander accessible for Lua code, it is
exported as a Lua primitive [[Sparcexpand.expand]].

<<tail>>=
module Make (ProcT: Lua.Lib.TYPEVIEW with type 'a t = Proc.t): 
    Lua.Lib.TYPEFUL with type 'a combined = 'a ProcT.combined =
struct
    type 'a combined = 'a ProcT.combined
    module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
    struct
        <<export expander>>
        let init = C.register_module "Sparcexpand" builtins
    end (*M*)    
end (*Make*)            

<<export expander>>=
module V  = C.V

let ( **-> ) = V.( **-> )
let proc     = ProcT.makemap V.userdata V.projection
let pf t     = (V.pfunc t).V.embed    (* pure Lua function *)

let builtins =
    [ "expand" , pf (V.value **-> proc **-> V.result V.bool) (fun _ -> cfg)
    ]
@

