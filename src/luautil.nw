% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4 sts=4

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------ 
\section{Useful Lua functions}
% ------------------------------------------------------------------ 

This module adds Lua functions into the Lua table [[Util]]. 

\begin{itemize}
\item [[Util.dosearchfile(string,table)]]

The [[dosearchfile]] function obtains a search path from the environment
variable [[QCMMLUAPATH]] and searches if for a named file. If the file
name is absolute, it is immediately passed to [[dofile]]. Otherwise it is
searched in the directories from the search path from left to right.

Directory entries in the search path are separated by colons.  Two
directory names in the search path are special: [[*]] and the empty
path.  The star [[*]] stands for the [[table]] passed to
[[dosearchfile]] and the empty path for a system specific directory. If
the table is searched the file name is used as a key.  A matching entry
is passed to [[dostring]] and thus executed as a Lua program. If no file
can be found the error fallback is called and is expected to return a
string with Lua code.  

\end{itemize}

<<luautil.mli>>=
module MakeLib : Lua.Lib.BARECODE
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<luautil.ml>>=
module MakeLib (C: Lua.Lib.CORE) = struct
    module V = C.V
    let ( **-> ) = V.( **-> )

    <<dofile>>

    let init g =
      C.register_module "Util"
      [ "dosearchfile",  V.efunc (V.string **-> V.value **-> V.values) 
                         (dosearchfile g)
      ] g;              
      Lua.Lib.StringList.empty (* OK? *)
end
@

A search path is easier to handle in \ocaml~when it is represented as a
list of strings. The [[split]] function splits a colon-separated string
into a list. Put this into [[Strutil]]?

<<dofile>>=
let split path =
    let sep    = ':'                in    (* path separator *)
    let length = String.length path in
    let rec loop start =
        if start >= length then
            []
        else 
            let next = try String.index_from path start sep with
                       Not_found -> length
            in           
                String.sub path start (next-start) :: loop (next+1) 
    in
        loop 0 
@

Try to find the installation directory for the current executable by
searching the path. This is used to setup the default search location
for lua files.
<<dofile>>=
let locate_exe =
  let filename = Sys.argv.(0) in
  let rec find_in path =
    match path with
      dir :: rest ->
        if Sys.file_exists (Filename.concat dir filename)
        then dir else find_in rest
    | [] -> "/usr/local/bin" (* XXX fix XXX *)
  in
  let dirname = Filename.dirname filename in
  if dirname <> "" then dirname
  else find_in (split (Sys.getenv "PATH"))
@ 

The conversion of values between Lua and \ocaml~is a bit ugly. Maybe
some expert can clean this up. Another problem was to call [[dofile]]
and [[dostring]]. Is there a better way then [[apply]]?

<<dofile>>=
let error g msg      = C.fallback "error" g [V.String msg]
let lookup   g f     = try Luahash.find g.V.globals (V.String f)
                       with Not_found -> V.Nil
let dofile   g file  = C.apply (lookup g "dofile")   g  file
let dostring g str   = C.apply (lookup g "dostring") g  str

let defaultdir       = Filename.concat locate_exe "../lib/qc--"
let luapath          = "QCMMLUAPATH"
let defaultpath      = ".::*"                  (*XXX fix XXX*)

type script =
    | String of V.value list  (* string is script             *)
    | File   of V.value list  (* string is filename of script *)
@

The code below is ugly. The problem is that [[dofile]] and [[dostring]]
both take string arguments, but one is a file name, the other a program.
If we cannot find the named \emph{file} we take the name as key into a
table and eventually return the entry, which is a script, rather a the
file name of a script. This also makes error recovery problematic.
Currently the value returned by [[error]] is taken to be a Lua program,
rather a file name, but this decision is arbitrary.

<<dofile>>=
let dosearchfile g file value =
    let path = try Sys.getenv luapath with Not_found -> defaultpath in
    let rec search = function
        | [] -> String (error g ( "dosearchfile: can't find `"
                                ^ file
                                ^ "' in path `"
                                ^ path
                                ^ "'"
                                ))
        | "*" :: rem -> 
            ( match value with
              | V.Nil      -> search rem
              | V.Table(t) -> (try  String [(Luahash.find t (V.String file))] 
                               with Not_found -> search rem)
              | _  -> String (error g 
                    "dosearchfile: expected nil or table as second
                    argument")
            )  
        | dir :: rem -> 
            let d    = if dir = "" then defaultdir else dir in
            let p    = Filename.concat d file in
                if Sys.file_exists p then
                    File [(V.String p)]
                else search rem
    in
        if Filename.is_relative file then
            match search (split path) with
            | File f   -> dofile g f
            | String s -> dostring g s
        else
            dofile g [(V.String file)]
@    

