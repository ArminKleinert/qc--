% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4 sts=4

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------ 
\section{Useful Lua functions}
% ------------------------------------------------------------------ 

This module adds Lua functions into the Lua table [[Util]]. 

\begin{itemize}
\item [[Util.dosearchfile(string,table)]]

The [[dosearchfile]] function obtains a search path from the environment
variable [[QCMMLUAPATH]] and searches if for a named file. If the file
name is absolut, it is immediately passed to [[dofile]]. Otherwise it is
searched in the directories from the search path from left to right.

Directory entries in the search path are separated by colons.  Two
directory names in the search path are special: [[*]] and the empty
path.  The star [[*]] stands for the [[table]] passed to
[[dosearchfile]] and the empty path for a system specific directory. If
the table is searched the file name is used as a key.  A matching entry
is passed to [[dostring]] and thus exceuted as a Lua program. If no file
can be found the error fallback is called.  

\end{itemize}

<<luautil.mli>>=
module MakeLib : Lua.Lib.BARE
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<luautil.ml>>=
module MakeLib (C: Lua.Lib.CORE) = struct
    module V = C.V
    let ( **-> ) = V.( **-> )

    <<dofile>>

    let init g =
      C.register_module "Util"
      [ "dosearchfile",  V.efunc (V.string **-> V.value **-> V.values) 
                         (dosearchfile g)
      ; "checksuffix",   V.efunc (V.string **-> V.string **-> V.result V.bool)
                         Filename.check_suffix
      ; "chopsuffix",    V.efunc (V.string **-> V.result V.string)
                         Filename.chop_extension
      ] g;              
      Lua.Lib.StringList.empty (* OK? *)
end
@

A search path is easier to handle in \ocaml~when it is represented as a
list of strings. The [[split]] function splits a colon-separated string
into a list. Put this into [[Strutil]]?

<<dofile>>=
let split path =
    let sep    = ':'                in    (* path separator *)
    let length = String.length path in
    let rec loop start =
        if start >= length then
            []
        else 
            let next = try String.index_from path start sep with
                       Not_found -> length
            in           
                String.sub path start (next-start) :: loop (next+1) 
    in
        loop 0 
@

The conversion of values between Lua and \ocaml~is a bit ugly. Maybe
some expert can clean this up. Another problem was to call [[dofile]]
and [[dostring]]. Is there a better way then [[apply]]?

<<dofile>>=
let error g msg      = C.fallback "error" g [V.String msg]
let lookup   g f     = try Luahash.find g.V.globals (V.String f)
                       with Not_found -> V.Nil
let dofile   g file  = C.apply (lookup g "dofile")   g  [file]
let dostring g str   = C.apply (lookup g "dostring") g  [str]

let defaultdir       = "/usr/local/lib/qc--"    (*XXX fix XXX*)
let luapath          = "QCMMLUAPATH"
let defaultpath      = ":.:*"                   (*XXX fix XXX*)
@

The code for [[*]] has a problem with exceptions: a [[Not_found]]
escaping from the [[dostring]] function will be misread as coming from
the [[find]] and cause a new attempt to find [[file]].

<<dofile>>=
let dosearchfile g file value =
    let path = try Sys.getenv luapath with Not_found -> defaultpath in
    let rec search = function
        | [] -> 
            error g ("dosearchfile: can't find `"^file^"' in path `"^path^"'")
        | "*" :: rem -> 
            ( match value with
              | V.Nil      -> search rem
              | V.Table(t) -> 
                 (try let script = Luahash.find t (V.String file) in
                     dostring g script
                 with Not_found -> search rem)
              | _  -> 
                error g "dosearchfile: expected nil or table as second argument"
            )  
        | dir :: rem -> 
            let d    = if dir = "" then defaultdir else dir in
            let p    = Filename.concat dir file in
                if Sys.file_exists p then
                    dofile g (V.String p)
                else search rem
    in
        if Filename.is_relative file then
            search (split path)
        else
            dofile g (V.String file)
@    
