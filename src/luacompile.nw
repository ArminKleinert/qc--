
% ------------------------------------------------------------------ 
\section{Lua Compiler Configuration}
% ------------------------------------------------------------------ 

The Lua code in this module configures the backend of the compiler. It
is complementory to the \module{luadriver.nw} module, that evaluates
command line arguments and directs the compilation process. All Lua code
is assembled into one file [[Lua compiler configuration]] that is built
into the compiler binary.

% ------------------------------------------------------------------ 
\subsection{Compiler Debugging}
% ------------------------------------------------------------------ 

We have some functionality that once was useful but that we do not have
found worth to assign an officical command line flag to. All these find
a new home in our [[Debug]] module.

<<Lua compiler configuration>>=
Debug = Debug or {}

function Debug.prettyprint(file,out)
    local linewidth = 72
    local ast       = Driver.parse(file)
    local doc       = Driver.pretty(ast)
    fd              = (not out or out == "-") and Driver.stdout or open_out(out)
    Driver.print(doc,linewidth,fd)
    if fd ~= Driver.stdout then close_out(fd) end
end  
@

% ------------------------------------------------------------------ 
\subsection{Backplane and Backplane Stages}
% ------------------------------------------------------------------ 

The backplane provides primitives to construct stages which implement
back end phases in the compiler. For notational brevity, we introduce an
alias here. See \module{backplane.nw} for details.
<<Lua compiler configuration>>=
Stages = Stages or {}
function Stages.nullf () return nil end

function Stages.assert(prop)
  return NewBackplane.stage { name='assert ' .. prop, creates={prop},
                              fn = Stages.nullf}
end
@

% ------------------------------------------------------------------ 
\subsection{Stage Patching}
% ------------------------------------------------------------------ 

Some primitive functions that are registered need to be stages rather
than functions. We patch the binding in the Lua interpreter here.
<<Lua compiler configuration>>=
function Stages.make_stage(t, short, long, B)
  if not B then error("Stages.make_stages called without Backplane") end
  if type(t[short]) == 'function' then
    if type(long) == 'table' then
      t[short] = Stages.of_table(t[short], long, B)
    else
      t[short] = B.stage { name=long, fn = t[short] }
    end
  end
end

function Stages.of_table(fn, tbl, B)
  B = B or NewBackplane
  local stage = { fn = fn }
  <<add every key-value pair in [[tbl]] to [[stage]]>>
  return B.stage(stage)
end

Stages.make_stage( Stages
                 , 'replace_vfp'
                 , {name='replace VFP', uses='no late consts' }
                 , NewBackplane)

function Placevar.context(placer, targetname)
  return Stages.of_table(Placevar.contextfn(placer), 
                         { name="context-based variable placer for " .. targetname
                         , creates='no vars'
                         })
end
@ 
<<add every key-value pair in [[tbl]] to [[stage]]>>=
local k, v = next(tbl, nil)
while k do
  stage[k] = v
  k, v = next(tbl, k)
end
@

% ------------------------------------------------------------------ 
\subsection{Stack Layout}
% ------------------------------------------------------------------ 

A stack layout function must respect the backplane protocol: such a
function receives two values, where the second is a [[Proc.t]] value,
and returns boolean value.

The new layout supports the virtual frame pointer.
<<Lua compiler configuration>>=
Debug = Debug or {}
function Debug.showblocks(blocks, keys, prefix)
  local i = 1
  while keys[i] do
    local block = blocks[keys[i]]
    if type(block) == 'table' then
      Debug.showblocks(block, {'caller', 'callee'}, keys[i] .. '.')
    else
      write(format('block %17s is %d bytes at %s\n',
                   (prefix or '') .. keys[i], Block.size(block), Block.base(block)))
      local constraints = Block.constraints(block)
      local j = 1
      while constraints[j] do
        write(format('  where %s\n', constraints[j]))
        j = j + 1
      end
    end
    i = i + 1
  end
end
@ 


% ------------------------------------------------------------------ 
\paragraph{Stack Layout for the Dummy Target} 
% ------------------------------------------------------------------ 

\module{dummy.nw} module
that defines the dummy target.

<<Lua compiler configuration>>=
Dummy = {} or Dummy
Dummy.layout = { creates='no late consts' }

function Dummy.layout.fn(dummy, proc)
    local blocks       = Stack.blocks(proc)
    blocks.oldblocks.caller   = Block.overlap_low(32, blocks.oldblocks.caller)
    blocks.youngblocks.caller = Block.overlap_low(32, blocks.youngblocks.caller)
    local layout =
        { blocks.oldblocks.caller
        , blocks.stackdata
        , blocks.vfp
        , blocks.continuations
        , Block.relative(blocks.sp, "six words", 24, 16)
        , blocks.spills
        , blocks.youngblocks.caller
        , blocks.sp
        }
    if Debug.stack then
        write('****** cc name = ', Stack.ccname(proc), '\n')
        Debug.showblocks (blocks, { 'oldblocks'
                                  , 'stackdata'
                                  , 'vfp'
                                  , 'continuations'
                                  , 'spills'
                                  , 'youngblocks'
                                  , 'sp'
                                  })
    end
    local block = Block.cat(32, layout)
    Stack.freeze(proc, block)
    return 1
end
@
    
% ------------------------------------------------------------------ 
\paragraph{Stack Layout for the \mips}
% ------------------------------------------------------------------ 

<<Lua compiler configuration>>=
Mips = {} or Mips
Mips.layout = { creates='no late consts' }

function Mips.layout["C"](dummy, proc)
    local blocks       = Stack.blocks(proc)
    blocks.oldblocks.callee   = Block.overlap_low(32,blocks.oldblocks.callee)
    blocks.oldblocks.caller   = Block.overlap_low(32,blocks.oldblocks.caller)
    blocks.youngblocks.callee = Block.overlap_low(32,blocks.youngblocks.callee)
    blocks.youngblocks.caller = Block.overlap_low(32,blocks.youngblocks.caller)

  -- Are oldparams and newparams necessary?  Everything seems to work fine
    -- with them commented out... -RO

    -- blocks.oldparams   = Block.relative(blocks.vfp, "old parameters", 16, 4)
    -- blocks.newparams   = Block.relative(blocks.vfp, "new parameters", 16, 4)
    local layout =
        { blocks.oldblocks.caller
        , blocks.oldblocks.callee
        -- , blocks.oldparams     
        , blocks.vfp
        , blocks.spills
        , blocks.continuations
        , blocks.stackdata
        , blocks.youngblocks.caller
        -- , blocks.newparams     
        , blocks.sp
    , blocks.youngblocks.callee
        }
    if Debug.stack then
        write('****** cc name = ', Stack.ccname(proc), '\n')
        Debug.showblocks (blocks, { 'oldblocks'
                                  , 'stackdata'
                                  , 'vfp'
                                  , 'continuations'
                                  , 'spills'
                                  , 'youngblocks'
                                  , 'params'
                                  , 'sp'
                                  })
    end
    local block = Block.cat(32, layout)
    block = Block.adjust(block)
    Stack.freeze(proc, block)
    return 1
end

function Mips.layout["C'"](dummy, proc)
    local blocks       = Stack.blocks(proc)
    blocks.oldblocks   = Block.overlap_low(32, blocks.oldblocks)  
    blocks.youngblocks = Block.overlap_low(32, blocks.youngblocks)
    local layout =
        { blocks.oldblocks
        , blocks.vfp
        , blocks.spills
        , blocks.continuations
        , blocks.stackdata
        , blocks.youngblocks    
        , blocks.sp
        }
    if Debug.stack then
        write('****** cc name = ', Stack.ccname(proc), '\n')
        Debug.showblocks (blocks, { 'oldblocks'
                                  , 'stackdata'
                                  , 'vfp'
                                  , 'continuations'
                                  , 'spills'
                                  , 'youngblocks'
                                  , 'params'
                                  , 'sp'
                                  })
    end
    local block = Block.cat(32, layout)
    block = Block.adjust(block)
    Stack.freeze(proc, block)
    return 1
end
Mips.layout["c'"] = Mips.layout["C'"] 

function Mips.layout.fn(dummy,proc) 
    local cc = Stack.ccname(proc)
    if Mips.layout[cc] == nil then
        error("no layout for convention "..cc)
    else    
        return (Mips.layout[cc](dummy, proc))
    end    
end
@


@
% ------------------------------------------------------------------ 
\paragraph{Stack Layout for the Alpha}
% ------------------------------------------------------------------ 

The stack layout depends on the calling convention, we thus dispatch
on it.

<<Lua compiler configuration>>=
Alpha        = {} or Alpha
Alpha.layout = { creates='no late consts' } -- what is this for? -CL
@

The following layout assumes the stack pointer does not move,
i.e.~argument and result overflow blocks are allocated by the caller.

<<Lua compiler configuration>>=
function Alpha.layout["C"](dummy, proc)
    local blocks              = Stack.blocks(proc)
    blocks.oldblocks.callee   = Block.overlap_low(64,blocks.oldblocks.callee)
    blocks.oldblocks.caller   = Block.overlap_low(64,blocks.oldblocks.caller)
    blocks.youngblocks.callee = Block.overlap_low(64,blocks.youngblocks.callee)
    blocks.youngblocks.caller = Block.overlap_low(64,blocks.youngblocks.caller)
    local layout =
        { blocks.oldblocks.caller
        , blocks.oldblocks.callee
        , blocks.vfp
        , blocks.spills
        , blocks.continuations
        , blocks.stackdata
        , blocks.youngblocks.caller
        , blocks.sp
        , blocks.youngblocks.callee
        }
    if Debug.stack then
        write('****** cc name = ', Stack.ccname(proc), '\n')
        Debug.showblocks (blocks, { 'oldblocks'
                                  , 'stackdata'
                                  , 'vfp'
                                  , 'continuations'
                                  , 'spills'
                                  , 'youngblocks'
                                  , 'sp'
                                  })
    end
    
    local block = Block.cat(64, layout)
    block = Block.adjust(block) -- size is multiple of 16 byte
    Stack.freeze(proc, block)
    return 1
end
@



The [[cmm]] conventions are part of an experimental setup to test the
[[callspec]] interface to define calling conventions.

<<Lua compiler configuration>>=
Alpha.layout["cmm"]  = Alpha.layout["C"]    -- defaults
Alpha.layout["cmm0"] = Alpha.layout["C"]
Alpha.layout["cmm1"] = Alpha.layout["C"]
Alpha.layout["cmm2"] = Alpha.layout["C"]
Alpha.layout["cmm3"] = Alpha.layout["C"]

function Alpha.layout["cmm3"](dummy, proc)
    local blocks       = Stack.blocks(proc)
    blocks.oldblocks   = Block.overlap(64,"high", blocks.oldblocks)  
    blocks.youngblocks = Block.overlap(64,"high", blocks.youngblocks)
    local layout =
        { blocks.oldblocks
        , blocks.vfp
        , blocks.spills
        , blocks.continuations
        , blocks.stackdata
        , blocks.sp
        , blocks.youngblocks
        }
    
    if Debug.stack then
      write( '****** cc name = '
           , Stack.ccname(proc)
           , '/'
           , Stack.procname(proc)
           , '\n'
           )
      Debug.showblocks (blocks, {'oldblocks'
                                ,'vfp'
                                ,'stackdata'
                                ,'continuations'
                                ,'spills'
                                ,'sp'
                                ,'youngblocks'
                                })
    end

    local block = Block.cat(64, layout)
    if Debug.stack then
        local blocks = {frame = block}
        Debug.showblocks(blocks, {'frame'})
    end    
    block = Block.adjust(block) -- size is multiple of 16 byte
    Stack.freeze(proc, block)
    return 1
end

function Alpha.layout.fn(dummy,proc) 
    local cc = Stack.ccname(proc)
    if Alpha.layout[cc] == nil then
        error("no layout for convention "..cc)
    else    
        return (Alpha.layout[cc](dummy, proc))
    end    
end
@
  
% ------------------------------------------------------------------ 
\paragraph{Stack Layout for the $x$86} 
% ------------------------------------------------------------------ 

This code should probably move to the x86 module.

<<Lua compiler configuration>>=
X86 = X86 or {}
X86.layout = { creates='no late consts' }

function X86.layout.fn(dummy,proc) --- dispatch on cc name
  return X86.layout[Stack.ccname(proc)](dummy, proc)
end

function X86.layout["C"](dummy,proc) --- really for a C convention only
    local blocks = Stack.blocks(proc)
    blocks.ra = Block.relative(blocks.vfp, "return address", 4, 4)

    -- OVERLAP_HIGH CONSIDERED SUSPECT
    blocks.oldblocks.callee   = Block.overlap_high(32, blocks.oldblocks.callee)
    blocks.oldblocks.caller   = Block.overlap_low (32, blocks.oldblocks.caller)
    blocks.youngblocks.callee = Block.overlap_high(32, blocks.youngblocks.callee)
    blocks.youngblocks.caller = Block.overlap_low (32, blocks.youngblocks.caller)
    local layout = 
                { blocks.oldblocks.caller       -- <-- high addresses
                , blocks.oldblocks.callee
                , blocks.ra
                , blocks.vfp
                , blocks.stackdata
                , blocks.continuations
                , blocks.spills
                , blocks.youngblocks.caller
                , blocks.sp                     -- <-- low addresses 
                , blocks.youngblocks.callee
                }
    if Debug.stack then
      write('======= using stack layout for C/notail =======\n')
      write('****** cc name = ', Stack.ccname(proc), '\n')
      Debug.showblocks (blocks, {'oldblocks', 'ra', 'vfp',
                                 'stackdata', 'continuations', 'spills',
                                 'youngblocks', 'sp'})
    end
    local block = Block.cat(32, layout)
    if Debug.stack then
      Debug.showblocks({frame=block}, {'frame'})
    end
    Stack.freeze(proc,block)
    return 1
end    

X86.layout["notail"] = X86.layout["C"]

function X86.layout["C--"](dummy,proc)
    local blocks = Stack.blocks(proc)

    if Debug.stack then
      write('======= using stack layout for C-- with tail calls =======\n')
      local i = 1
      local keys = { }
      while blocks.oldblocks.callee[i] do keys[i] = i; i = i + 1 end
      write('oldblocks.callee (before ra is added):\n')
      Debug.showblocks(blocks.oldblocks.callee, keys)
      write('................\n')
    end

    blocks.ra = Block.relative(blocks.vfp, "return address", 4, 4)
    -- first old block is always the incoming parms
    blocks.oldblocks.callee[1] =
                    Block.cat(32, {blocks.oldblocks.callee[1], blocks.ra, blocks.vfp})
    blocks.oldblocks.caller    = Block.overlap_low (32, blocks.oldblocks.caller)
    blocks.oldblocks.callee    = Block.overlap_high(32, blocks.oldblocks.callee)
    blocks.youngblocks.caller  = Block.overlap_low (32, blocks.youngblocks.caller)
    blocks.youngblocks.callee  = Block.overlap_high(32, blocks.youngblocks.callee)
    local layout = 
                { blocks.oldblocks.caller       -- <-- high addresses
                -- On return, the ra must end up here, immediately followed by the sp
                , blocks.oldblocks.callee
                -- , blocks.ra  -- joined to incoming block
                -- , blocks.vfp
                , blocks.stackdata
                , blocks.continuations
                , blocks.spills
                , blocks.youngblocks.caller
                , blocks.sp                     -- <-- low addresses 
                , blocks.youngblocks.callee
                }
    if Debug.stack then
      Debug.showblocks (blocks, {'oldblocks', 'ra', 'vfp',
                                 'stackdata', 'continuations', 'spills',
                                 'youngblocks', 'sp'})
    end
    local block = Block.cat(32, layout)
    Stack.freeze(proc,block)
    return 1
end    
@

% ------------------------------------------------------------------ 
\paragraph{Stack Layout for the Ia64}
% ------------------------------------------------------------------ 

<<Lua compiler configuration>>=
Ia64 = Ia64 or {}
Ia64.layout = { creates='no late consts' }

function Ia64.layout.fn(dummy,proc) --- dispatch on cc name
  return Ia64.layout[Stack.ccname(proc)](dummy, proc)
end

function Ia64.layout["C"](dummy,proc) --- really for a C convention only
    local blocks = Stack.blocks(proc)
    blocks.oldblocks.callee   = Block.overlap_high(64, blocks.oldblocks.callee)
    blocks.oldblocks.caller   = Block.overlap_low (64, blocks.oldblocks.caller)
    blocks.youngblocks.callee = Block.overlap_high(64, blocks.youngblocks.callee)
    blocks.youngblocks.caller = Block.overlap_low (64, blocks.youngblocks.caller)
    local layout = 
                { blocks.oldblocks.caller       -- <-- high addresses
                , blocks.oldblocks.callee
                , blocks.vfp
                , blocks.stackdata
                , blocks.continuations
                , blocks.spills
                , blocks.youngblocks.caller
                , blocks.sp                     -- <-- low addresses 
                , blocks.youngblocks.callee
                }
    local block = Block.cat(64, layout)
    Stack.freeze(proc,block)
    return 1
end    
@

% ------------------------------------------------------------------ 
\paragraph{Stack Layout for the Interpreter}
% ------------------------------------------------------------------ 

<<Lua compiler configuration>>=
Interp = Interp or {}
function Interp.layout(dummy, proc)
    local blocks = Stack.blocks(proc)
    local layout =
        { blocks.continuations
        , blocks.stackdata
        , blocks.vfp
        , blocks.sp
        , blocks.spills
        , Block.overlap_low (32, blocks.oldblocks.caller)
        , Block.overlap_low (32, blocks.oldblocks.callee)
        , Block.overlap_high(32, blocks.youngblocks.caller)
        , Block.overlap_high(32, blocks.youngblocks.callee)
        }
    local block = Block.cat(32, layout)
    Stack.freeze(proc, block)
    return 1
end
@
 

% ------------------------------------------------------------------ 
\subsection{Graph-Coloring Register Allocator}
% ------------------------------------------------------------------ 

Defined in file \texttt{colorgraph.nw}.
<<Lua compiler configuration>>=
<<Lua startup code for [[Colorgraph]] module>>
@

% ------------------------------------------------------------------ 
\subsection{Register Allocators}
% ------------------------------------------------------------------ 

All register allocators are made available in the table [[Ralloc]].

<<Lua compiler configuration>>=
Ralloc           = Ralloc and error('Ralloc not empty') or {}
Ralloc.color     = NewColorGraph.color
Ralloc.dls       = DLS.dls
@
% ------------------------------------------------------------------ 
\subsection{Optimizer}
% ------------------------------------------------------------------ 

For the translation of a procedure all back-end related actions, like
register allocation or variable assignment, are controlled by an
optimizer. The optimizer has a sequence of stages the procedure passes
through.

So far, we just have one standard optimizer that receives the current
backend and an assembler.

<<Lua compiler configuration>>=
Opt = Opt and error('Opt not empty') or {}

function verbose(s, a, b, c, d, e, f, g, h)
      print(s,a,b,c,d,e,f,g,h)
end

function Opt.verb(stage) -- needs more work (want verbosity for each stage)
  if not stage or Options.verbose == 0 then
    return stage
  else
    return stage -- actually want timed, noisy version of stage announcing stage.name
  end
end  

function Opt.standard(backend, asm, B)
  if not B then error("Opt.standard called without backplane argument") end
  Stages.null = B.stage {name="empty stage", fn=Stages.nullf}
  local assemble  = Driver.proc_assembler(asm) 
	local emit_data = nil
  if backend.emit_data then
    emit_data = Opt.verb(B.stage { name = "emit_data", fn = backend.emit_data(asm)})
  end
  local x = B.seq
    { 
      Opt.verb(backend.intwiden)   or Stages.null
    , Opt.verb(backend.placevars)  or Stages.null
    , Opt.verb(backend.widen)      or Stages.null
    , Opt.verb(Optimize.simplify_exps) or Stages.null
    , Opt.verb(backend.preopt)     or Stages.null
    , Opt.verb(backend.pic)        or Stages.null
    , Opt.verb(backend.expand)     or Stages.null
    , Opt.verb(backend.improve)    or Stages.null
    , Opt.verb(backend.liveness)   or Stages.null
    , Opt.verb(backend.ralloc)     or Stages.null
    , Opt.verb(backend.freeze)     or Stages.null
    , Opt.verb(backend.rmvfp)      or Stages.null
    , Opt.verb(B.stage { name="assemble procedure", fn = assemble })
    , emit_data or Stages.null
    }
  return x
end

@
% ------------------------------------------------------------------ 
\subsection{Compiler}
% ------------------------------------------------------------------ 

The [[Compile.file]] function takes the file name for a {\PAL} source
file, a backend, and the name of the (assembly) file to produce and
compiles the file.

There is some inconsistency how we deal with files. The [[Driver.parse]]
function takes a file name, while an assembler expects a file
descriptor.
<<Lua compiler configuration>>=
Compile = Compile and error('Compile not empty') or {}

function Compile.file(backend, emitglobals, file, out)
    local fd  = (not out or out == "-") and Driver.stdout or open_out(out)
    local ast = Driver.parse(file)
    local asm = backend.asm(fd) 
    local opt = { apply  = Compile.run_optimizer
                , action = Opt.standard(backend, asm, NewBackplane) 
                , B = NewBackplane
                }
    Driver.compile(backend.target, opt, emitglobals, ast, asm)
    if backend.emit then backend.emit(asm) end
    if fd ~= Driver.stdout then close_out(fd) end -- close fd
end    
@ 
To run the optimizer, [[Compile.run_optimizer]] takes the table above
and a procedure, then runs the given [[self.action]] in the
optimization backplane.
<<Lua compiler configuration>>=
function Compile.run_optimizer(self,proc)
    local B = self.B or error("missing backplane")
    -- verbose('running Compile.run_optimizer with ', whichB(B), '\n')

    -- please keep the following until the bug is fixed
    if B == NewBackplane then -- demo for a bug in the backplane
        B.run(B.seq {Stages.assert('fish'),
                   B.stage {fn=Stages.nullf, uses='fish'}}, proc)
    end

    B.run(self.action, proc)
end    
@ 
The old front end.
<<Lua compiler configuration>>=
Compile.Old = Compile.Old or { } 

function Compile.Old.use()
  local k, backend = next(Backend, nil)
  while k do
    if type(backend) == 'table' and backend.compile == Compile.file then
      backend.compile = Compile.Old.file
    end
    k, backend = next(Backend, k)
  end
  Compile.file = Compile.Old.file
end

function Compile.Old.file(backend, emitglobals, file, out)
    local fd  = (not out or out == "-") and Driver.stdout or open_out(out)
    local ast = Driver.parse(file)
    
    local asm = backend.asm(fd) 
    local env = Driver.check(ast,asm) -- asm is stored in env
    local opt = { apply  = Compile.run_optimizer
                , action = Opt.standard(backend, asm, NewBackplane) 
                , B = NewBackplane
                }
    Driver.old_compile(opt, emitglobals, ast, backend.target, env)
    if backend.emit then backend.emit(asm) end
    if fd ~= Driver.stdout then close_out(fd) end -- close fd
end    
@

% ------------------------------------------------------------------ 
\subsection{Backends}
% ------------------------------------------------------------------ 

A backend value describes everything the compiler needs to know to
produce code for a particular target. Many values in the description of
a backend are primitives, and thus cannot be simply constructed in Lua.

The [[compile]] entry selects the function that actually compiles a
file. Thus, just setting [[backplane]] to the desired value will thus be
enough to setup the compiler.

<<Lua compiler configuration>>=
Backend = Backend and error('Backend not empty') or {}

-- make a backend for the new backplane
function Backend.make(b)
  return
    { target    = b.target    or error('target not specified')
    , widen     = b.widen     or nil
    , placevars = b.placevars or nil
    , expand    = b.expand    or nil
    , liveness  = b.liveness  or nil
    , ralloc    = b.ralloc    or nil
    , freeze    = b.freeze    or Dummy.layout
    , rmvfp     = b.rmvfp     or nil
    , asm       = b.asm       or Asm.cmm
    , emit      = b.emit      or Driver.assemble
    , emit_data = b.emit_data or nil
    , compile   = Compile.file
    }   
end

--
-- Dummy backends
--

Backend.dummy32l        = Backend.make  { target = Targets.dummy32l 
                                        , rmvfp  = NewBackplane.seq
						      { Stages.replace_vfp,
						        Optimize.remove_nops }
                                        }
Backend.dummy32b        = Backend.make  { target = Targets.dummy32b 
                                        , rmvfp  = NewBackplane.seq
						      { Stages.replace_vfp,
						        Optimize.remove_nops }
                                        }
Backend.dummy           = Backend.dummy32l  -- alias

--
-- Interpreter backends, for new and old backplane
--

Backend.interp          = Backend.make  { target = Targets.interp
                                        , asm    = Asm.interp32l 
                                        , freeze = Interp.layout
                                        }
Backend.debug_interp    = Backend.make  { target = Targets.interp
                                        , asm    = Asm.cmm
                                        , freeze = Interp.layout
                                        }
Backend.interp.compile = Compile.Old.file
Backend.debug_interp.compile = Compile.Old.file

--
-- Kevin's ia64 backend to test widening
--

Backend.wia64 =
  { target    = Targets.ia64
  , widen     = NewBackplane.seq
                   { Widen.op_count, Widen.dpwiden,
                     Stages.assert('proper widths') }
  , placevars = Placevar.context(Placevar.ia64, "ia64")
  , preopt    = Optimize.remove_nops
  , expand    = Expander.ia64
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.dls
  , freeze    = Ia64.layout
  , rmvfp     = NewBackplane.seq
                   { Stages.replace_vfp,
                     Optimize.remove_nops }
  , asm       = Asm.ia64
  , compile   = Compile.file
  }

--
-- Kevin's x86 backend for testing widening
--

Backend.widentest =
  { target    = Targets.x86
  , widen     = NewBackplane.seq
                   { Widen.op_count,
                     Widen.x86_floats, Widen.store_const(32),
                     Widen.dpwiden,
                     Widen.width_cost,
                     Widen.op_count,
                     Stages.assert('proper widths') }
  , placevars = Placevar.context(Placevar.x86, "x86")
  , preopt    = Optimize.remove_nops
  , expand    = Expander.x86
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.color
  , freeze    = X86.layout
  , rmvfp     = Stages.replace_vfp
  , asm       = Asm.x86
  , emit      = Driver.assemble
  , compile   = Compile.file
  }

Backend.widentest2 =
  { target    = Targets.x86
  , widen     = NewBackplane.seq
                   { Widen.op_count,
                     Widen.x86_floats, Widen.store_const(32),
                     Widen.badwiden,
                     Widen.width_cost,
                     Widen.op_count,
                     Stages.assert('proper widths') }
  , placevars = Placevar.context(Placevar.x86, "x86")
  , preopt    = Optimize.remove_nops
  , expand    = Expander.x86
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.color
  , freeze    = X86.layout
  , rmvfp     = Stages.replace_vfp
  , asm       = Asm.x86
  , emit      = Driver.assemble
  , compile   = Compile.file
  }

-- x86w is for widening x86 code

Backend.x86w =
  { target    = Targets.x86
  , intwiden  = NewBackplane.seq
                   { Widen.widenlocs,
                     Widen.dpwiden }
  , placevars = Placevar.context(Placevar.x86, "x86")
  , widen     = NewBackplane.seq
                   { Widen.x86_floats,
                     Widen.store_const(32),
                     Stages.assert('proper widths') }
  , preopt    = Optimize.remove_nops
--  , pic       = NewBackplane.seq { Pic.x86, Stages.assert('proper pic') }
  , expand    = Expander.x86
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.dls
  , freeze    = X86.layout
  , rmvfp     = NewBackplane.seq
		   { Stages.replace_vfp,
		     Optimize.remove_nops }
  , asm       = Asm.x86
  , emit      = Driver.assemble
  , emit_data = Runtime.emit_data
  , compile   = Compile.file
  }   

--
-- x86 backends
--

Backend.x86 =
  { target    = Targets.x86
  , intwiden  = nil
  , placevars = Placevar.context(Placevar.x86, "x86")
  , widen     = NewBackplane.seq
                   { Widen.x86_floats,
                     Widen.store_const(32),
                     Stages.assert('proper widths') }
  , preopt    = Optimize.remove_nops
--  , pic       = NewBackplane.seq { Pic.x86, Stages.assert('proper pic') }
  , expand    = Expander.x86
  , improve   = Optimize.validate
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.dls
  , freeze    = X86.layout
  , rmvfp     = NewBackplane.seq
		   { Stages.replace_vfp,
		     Optimize.remove_nops }
  , asm       = Asm.x86
  , emit      = Driver.assemble
  , emit_data = Runtime.emit_data
  , compile   = Compile.file
  }   

Optimize.improve =
  NewBackplane.seq { Optimize.remove_nops, Optimize.validate, Optimize.peephole, Optimize.validate }


--
-- MIPS (32 bit, little endian)
--

Backend.mips =     
  { target    = Targets.mips
  , widen     = Stages.assert('proper widths')
  , placevars = Placevar.context(Placevar.mips, "mips")
  , expand    = Expander.mips
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.dls
  , freeze    = Mips.layout
  , rmvfp     = NewBackplane.seq
		   { Stages.replace_vfp,
		     Optimize.remove_nops }
  , asm       = Asm.mips
  , emit      = Driver.assemble
  , emit_data = Runtime.emit_data
  , compile   = Compile.file
  }   

--
-- Alpha (64 bit, little endian)
--

Backend.alpha =     
  { target    = Targets.alpha
  , widen     = Stages.assert('proper widths')
  , placevars = Placevar.context(Placevar.x86, "x86") -- wrong!
  , expand    = Expander.alpha
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.dls
  , freeze    = Alpha.layout
  , rmvfp     = NewBackplane.seq
		   { Stages.replace_vfp,
		     Optimize.remove_nops }
  , asm       = Asm.alpha
  , emit      = Driver.assemble
  , emit_data = Runtime.emit_data
  , compile   = Compile.file
  }   

--
-- PPC Backend (32 bit, big endian)
--
Backend.ppc =
  { target    = Targets.ppc
  , placevars = Placevar.context(Placevar.ppc, "ppc")
  , widen     = Stages.assert('proper widths')
  , preopt    = Optimize.remove_nops
  , pic       = NewBackplane.seq { Pic.ppc, Stages.assert('proper pic') }
  , expand    = Expander.ppc
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.dls
  , freeze    = Dummy.layout
  , rmvfp     = NewBackplane.seq
		   { Stages.replace_vfp,
		     Optimize.remove_nops }
  , asm       = Asm.ppc
  , emit      = Driver.assemble
  , emit_data = Runtime.emit_data
  , compile   = Compile.file
  }   

--
-- Ia64 Backend (64 bit, little-endian)
--
Backend.ia64 =
  { target    = Targets.ia64
  , placevars = Placevar.context(Placevar.ia64, "ia64")
  , widen     = Stages.assert('proper widths')
  , preopt    = Optimize.remove_nops
  , expand    = Expander.ia64
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.dls
  , freeze    = Ia64.layout
  , rmvfp     = NewBackplane.seq
		   { Stages.replace_vfp,
		     Optimize.remove_nops }
  , asm       = Asm.ia64
  , emit      = Driver.assemble
  , emit_data = Runtime.emit_data
  , compile   = Compile.file
  }
@

% ------------------------------------------------------------------ 
\subsection{Calling Convention Automata}
% ------------------------------------------------------------------ 

We specify calling convention automata in Lua.  We define here some functions
that pretty much all backends will need in their CC specifications.
The actual automata are found in the source files implementing the backends
even though they all come together in [[qc--.lua]].

<<Lua compiler configuration>>=
<<calling convention utilities>>

<<x86 calling convention automata in Lua>>
<<Alpha calling convention automata in Lua>>
<<MIPS calling convention automata in Lua>>
<<PPC calling convention automata in Lua>>
<<IA64 calling convention automata in Lua>>
@ 
<<calling convention utilities>>=
Util = Util or {}
function Util.round_up_mult (multof, k)
  return multof * floor((k + (multof - 1)) / multof)
end
@ 
