
% ------------------------------------------------------------------ 
\section{The Fat Environment}
% ------------------------------------------------------------------ 

The meaning, or denotation, of names in a {\PAL} program are recorded
in one environment.  Because only one environment is used for all
different kinds of names it is called fat.  In particular the fat
environment holds informations about:

\begin{itemize}
\item Values, like constants, labels for goto and data, procedures.
\item Types, as they are declared by the [[typedef]] directive.
\item Target architecture, as declared by the [[target]] directive.
\item Source code positions, as recored by a [[Srcmap.map]].
\end{itemize}
  
% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

<<fatenv.mli>>=
type env

<<type declarations>>
<<function signatures>>
@

<<type declarations>>=
type scope      = Global | Local

type kind       = Proc
                | Code
                | Data
                | Stack
                    
type ty         = Types.ty
type value      = Const.value
type endianness = Big | Little

type denotation = Constant of value
                | Label    of kind
                | Import
                | Register
                | Continuation

type ventry     = scope * (denotation * ty) Error.error
type tentry     = scope * ty                Error.error

<<function signatures>>=                
val create          : Srcmap.map -> env

val bindv           : string -> ventry  -> env -> env
val bindt           : string -> tentry  -> env -> env
val bindvError      : string -> scope   -> env -> env
val bindtError      : string -> scope   -> env -> env
val findv           : string -> env     -> ventry
val findt           : string -> env     -> tentry
val findv'          : string -> env     -> (denotation * ty) Error.error
val findt'          : string -> env     -> ty Error.error
val srcmap          : env -> Srcmap.map
@

<<>>=
val bindMemsize     : int        -> env -> env
val bindEndianness  : endianness -> env -> env 
val findMemsize     : env -> int option
val findEndianness  : env -> endianness option   
@

The function [[errorfree]] checks whether a fat environment [[env]]
binds any [[Error.Error]] value.  In case it does, it return
[[Error.Error]] and [[Error.Ok()]] if the fat environment is
error-free.

<<>>=
val errorfree       : env -> unit Error.error
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<fatenv.ml>>=
module E = Error

module Comparable   = struct type t=string let compare=compare end
module StrMap       = Map.Make(Comparable)

<<type declarations>>

type tenv           = tentry StrMap.t
type venv           = ventry StrMap.t
type arch           = { memsize:      int option
                      ; endianness:   endianness option
                      }
<<>>=
type env            = { tenv   :      tenv
                      ; venv   :      venv
                      ; arch   :      arch
                      ; srcmap :      Srcmap.map
                      }    

let create map      = { tenv = StrMap.empty
                      ; venv = StrMap.empty
                      ; arch = { memsize    = None
                               ; endianness = None
                               }
                      ; srcmap = map
                      }
@

% ------------------------------------------------------------------ 
\subsubsection{Bindings for types and values}
% ------------------------------------------------------------------ 

In a {\PAL} program a declared name is visible in its entire scope,
even before the place of its declaration.  The re-declaration of
values and type is therefore not allowed.  The implementations of
[[bindv]] and [[bindt]] maintains this by comparing the scope on an
new name and a possibly existing name in the environment.  No name can
be added into the same scope where the same name is already declared.

When a name is re-declared we issue an error but the first declaration
is considered valid.  It would be better to re-bind it to error to
make the problem visible in the environment.  But the current error
reporting design does not allow to report an error and return a value
at the same time.

<<>>=
let bindv name (scope, _ as x) env =
    let add name x = {env with venv = StrMap.add name x env.venv} in
    try 
        let (scope',_) = StrMap.find name env.venv in
        if scope' = scope then
            E.error ("value already declared: "^name)
        else
            add name x
    with
        Not_found -> add name x
@

<<>>=
let bindt name (scope, _ as x) env =
    let add name x = {env with tenv = StrMap.add name x env.tenv} in
    try 
        let (scope',_) = StrMap.find name env.tenv in
        if scope' = scope then
            E.error ("type already declared: "^name)
        else
            add name x
    with
        Not_found -> add name x

<<>>=
let bindvError name scope env = bindv name (scope, E.Error) env
let bindtError name scope env = bindt name (scope, E.Error) env
@

The functions to lookup a value [[findv]] and a type [[findt]] raise
an [[E.Error]] exception in case the name can not be found.

<<>>=
let findv name env =
    try
        StrMap.find name env.venv
    with 
        Not_found -> E.error ("unknown value: "^name)

<<>>=
let findt name env =
    try
        StrMap.find name env.tenv
    with
        Not_found -> E.error ("unknown type: "^name)
<<>>=
let findv' name env = snd (findv name env)
let findt' name env = snd (findt name env)
@

% ------------------------------------------------------------------ 
\subsubsection{Sourcemap}
% ------------------------------------------------------------------ 

<<>>=
let srcmap env = env.srcmap
@

% ------------------------------------------------------------------ 
\subsubsection{Target architecture description}
% ------------------------------------------------------------------ 

The [[target]] directive in {\PAL} describes the target architecture
an program is intended for. The information can be distributed over
the program and can declare the same fact several times.  However, the
informations about the target architecture must be consistent. 

The implementation maintains a record of type [[arch]] for the target
informations where each information is captured by an [[option]] type. 
Once an information has been supplied the [[bind]] functions enforce
that only the same fact can be entered again.  They raise an
[[E.Error]] in case this is attempted because this would violate the
consistency constraint.
 
<<>>=
let bindMemsize n env =
    match env.arch.memsize with
    | Some n' when n' <> n -> E.error "Inconsistent memsize specification"
    | Some n' -> env
    | None -> { env with arch = { env.arch with memsize = Some n} }
@

<<>>=
let bindEndianness e env =
    match env.arch.endianness with
    | Some e' when e' <> e -> E.error "Inconsistent endianness specification"
    | Some e' -> env
    | None -> { env with arch = { env.arch with endianness = Some e} }
@

<<>>=
let findMemsize    env = env.arch.memsize
let findEndianness env = env.arch.endianness
@   
    
% ------------------------------------------------------------------ 
\subsubsection{Test for \texttt{Error}-bindings}
% ------------------------------------------------------------------ 

<<>>=
let errorfree env =
    let combine key (scope,x) y = E.Implode.pair (x,y)    in
    let free map = StrMap.fold combine env.venv (E.Ok())  in
        E.Implode.pair (free env.tenv, free env.venv)
@
