
% ------------------------------------------------------------------ 
\section{The Fat Environment}
% ------------------------------------------------------------------ 

The meaning, or denotation, of names in a {\PAL} program are recorded
in one environment.  Because only one environment is used for all
different kinds of names it is called fat.  In particular the fat
environment holds informations about:

\begin{itemize}
\item Values, like constants, labels for goto and data, procedures.
\item Types, as they are declared by the [[typedef]] directive.
\item Target architecture, as declared by the [[target]] directive.
\item Source code positions, as recored by a [[Srcmap.map]].
\end{itemize}
  
% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

A fat environment has type [[env]]. The same [[env]] will be used for
checking the static semantics and code generation. It therefore may
contain some informations that are only required in some parts of the
compiler, but not all.

<<fatenv.mli>>=
type env

<<type declarations>>
<<function signatures>>
@

{\PAL} knows two scopes and two kinds of names that are scoped: 
values and types declared at the top-level and section-level have
global scope, values and types declared inside procedures have local
scope.  A local name can shadow the same name in the global scope.

<<type declarations>>=
type scope      = Global | Local
@

Labels come in different kinds:  they denote procedures, goto-labels,
data-labels, and stack-labels. A procedure carries its local
environment after it has been computed.

<<>>=
type kind       = Proc  of env option
                | Code
                | Data
                | Stack
@

Most names in a fat environment are either types (of values), or
types.  Only for constant values their actual value is known; the type
of a value is always known, as is the type of a type-alias
([[typedef]]). 
                    
<<>>=
type ty         = Types.ty
type value      = Const.value

@
A value can denote different things: a label, a compile-time constant, a
register, or a continuation. For constants their value is recorded.

<<>>=
type denotation = Constant of value
                | Label    of kind
                | Import
                | Register
                | Continuation
@

Names for types and values constitute two different name spaces:  the
same name can denote a type and a value.  For both value and types a
binding provides the scope of the binding and its denotation.  If a
declaration is erroneous we still bind the declared name:  the
[[Error.error]] type allows to distinguish between good and bad
declarations. 

A name in {\PAL} must never be re-declared.  To detect an attempt to
re-declare the scope of an existing binding must be known, even when
the declaration of that binding was erroneous.  For this reason the
[[scope]] of a binding is not part of the [[Error.error]] type
constructor.

<<>>=
type ventry     = (denotation * ty) Error.error
type tentry     = ty                Error.error

type attr       = Srcmap.reg * scope
@ 

The fat environment records the [[target]] annotation from a {\PAL}
source code. The endianness is part of the [[target]] declaration.

<<>>=
type endianness = Big | Little


@

An [[env]] holds a source map that was obtained during the parsing
of a source code. It must be provided when the [[env]] is created such
that is available to all code that report error in the static semantics.

<<function signatures>>=                
val create          : Srcmap.map -> env
@

The following functions bind and find names of value and types in an
[[env]]:  [[bindv]] binds values, [[bindt]] binds types.  The
specialized function [[bindvError]] and [[bindtError]] bind names to
[[Error.Error]] in the value and type name space respectively.

Any attempt to re-declare a name in a scope is detected by the
[[bind*]] functions and reported. The possibly leagal first
declaration of a name is re-bound to [[Error]] to flag the problem in
the environment. The [[bind*]] functions never fail.

The function [[rebindv name x env]] re-binds [[name]] to [[x]].  Since
this is only intended to update the informations for an exsisting
[[name]], [[name]] must be bound in [[env]] as a value.  The scope and
source code location of the existing binding is re-used for the new
binding.

<<>>=
val bindv           : string -> attr  -> ventry  -> env -> env
val bindt           : string -> attr  -> tentry  -> env -> env
val rebindv         : string ->          ventry  -> env -> env
@

The [[find*]] functions lookup the meaning of a name in the value or
type name space.  The result includes the scope where a name was
bound.  In case the name is not bound an [[Error.ErrorExn]] is raised.
The primed functions omit the scope from the result.

<<>>=
val findv           : string -> env -> scope * ventry
val findt           : string -> env -> scope * tentry
val findv'          : string -> env -> ventry
val findt'          : string -> env -> tentry
@

The [[srcmap]] function returns the [[Srcmap.map]] value passed to
[[create]].

<<>>=
val srcmap          : env -> Srcmap.map
@

The [[target]] declarations are bound in an [[env]].  All [[target]]
declarations must be consistent in a {\PAL} program:  the
[[byteorder]] of a compilation unit must be the same at every
declaration of the byte order.  This is checked by the [[bind*]]
functions:  after a value was bound any attempt to bind a different
value is reported with an [[Error.ErrorExn]] exception.

When no target declaration was provided, the [[find*]] functions
return [[None]].

<<>>=
val bindMemsize     : Srcmap.reg -> int        -> env -> env
val bindEndianness  : Srcmap.reg -> endianness -> env -> env 
val findMemsize     : env -> int option Error.error
val findEndianness  : env -> endianness option Error.error  
@

The function [[errorfree]] checks whether a fat environment [[env]]
binds any [[Error.Error]] value.  In case it does, it return
[[Error.Error]] and [[Error.Ok()]] if the fat environment is
error-free.

<<>>=
val errorfree       : env -> unit Error.error
@

For some opetional declarations in {\PAL} defaults exist. The
[[setDefaults]] function enter the defaults into the environment in
the user has not provided a declaration.

<<>>=
val setDefaults     : env -> env
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<fatenv.ml>>=
module E = Error

module Comparable   = struct type t=string let compare=compare end
module StrMap       = Map.Make(Comparable)

<<>>=
type scope      = Global | Local
type attr       = Srcmap.reg * scope
type endianness = Big | Little
type ty         = Types.ty
type value      = Const.value

<<>>=
type kind       = Proc  of env option
                | Code
                | Data
                | Stack
<<>>=
and  denotation = Constant of value
                | Label    of kind
                | Import
                | Register
                | Continuation
<<>>=
and  ventry     = (denotation * ty) Error.error
and  tentry     = ty                Error.error

<<>>=
and  tenv           = (attr * tentry) StrMap.t
and  venv           = (attr * ventry) StrMap.t
and  target         = { memsize:      int        option E.error
                      ; endianness:   endianness option E.error
                      ; word:         Types.ty   option E.error
                      ; code:         Types.ty   option E.error
                      ; data:         Types.ty   option E.error
                      ; float:        string     option E.error
                      ; charset:      string     option E.error
                      }
<<>>=
and  env            = { tenv   :      tenv
                      ; venv   :      venv
                      ; target :      target
                      ; srcmap :      Srcmap.map
                      }    


let create map      = { tenv   = StrMap.empty
                      ; venv   = StrMap.empty
                      ; target = { memsize    = E.Ok(None)
                                 ; endianness = E.Ok(None)
                                 ; word       = E.Ok(None)
                                 ; code       = E.Ok(None)
                                 ; data       = E.Ok(None)
                                 ; float      = E.Ok(None)
                                 ; charset    = E.Ok(None)
                                 }
                      ; srcmap = map
                      }
@

% ------------------------------------------------------------------ 
\subsubsection{Sourcemap}
% ------------------------------------------------------------------ 

<<>>=
let srcmap env = env.srcmap
@

% ------------------------------------------------------------------ 
\subsubsection{Bindings for types and values}
% ------------------------------------------------------------------ 

In a {\PAL} program a declared name is visible in its entire scope,
even before the place of its declaration.  The re-declaration of
values and type is therefore not allowed.  The implementations of
[[bindv]] and [[bindt]] maintains this by comparing the scope on an
new name and a possibly existing name in the environment.  No name can
be added into the same scope where the same name is already declared.


A handy error printing function: [[r]] is a [[Srcmap.reg]] source code
position that is used to decribe the place where the error is located. 

<<>>=
let error r env msg = E.errorRegionPrt (srcmap env,r) msg 
@

When a name is re-declared we issue two error messages:  the first
describes the actual location [[reg]] where the problem is detected,
and the second the location of the declaration that clashes.  This one
is also re-bound to [[Error]] to flag the problem.

<<>>=
let bindv name (reg,scope as attr) x env =
    let add name x = {env with venv = StrMap.add name x env.venv} in
    try 
        let (reg',scope' as attr'),_ = StrMap.find name env.venv in
        if scope' = scope then
            ( error reg  env ("re-declaration of value "^name)
            ; error reg' env ("previously declared here")
            ; add name (attr',E.Error) (* re-bind orig. to Error *)
            )
        else
            add name (attr,x)
    with
        Not_found -> add name (attr,x)

<<>>=
let bindt name (reg,scope as attr) x env =
    let add name x = {env with tenv = StrMap.add name x env.tenv} in
    try 
        let (reg',scope' as attr'),_ = StrMap.find name env.tenv in
        if scope' = scope then
            ( error reg  env ("re-declaration of type "^name)
            ; error reg' env ("previously declared here")
            ; add name (attr',E.Error) (* re-bind orig. to Error *)
            )
        else
            add name (attr,x) 
    with
        Not_found -> add name (attr,x)
@

The following function [[rebindv name x env]] re-binds [[name]] to
[[x]]. Since this is only intended to update the informations for an
exsisting [[name]], [[name]] must be bound in [[env]] as a value. The
scope and source code location of the existing binding is re-used for
the new binding.

<<>>=
let rebindv name x env =
    try 
        let attr,_ = StrMap.find name env.venv in
            { env with venv = StrMap.add name (attr,x) env.venv }
    with
        Not_found -> assert false
@

The functions to lookup a value [[findv]] and a type [[findt]] raise
an [[E.Error]] exception in case the name can not be found.

<<>>=
let findv name env =
    try
        let (_,scope),x = StrMap.find name env.venv
        in 
            scope,x
    with 
        Not_found -> E.error ("unknown value: "^name)

<<>>=
let findt name env =
    try
        let (_,scope),x = StrMap.find name env.tenv
        in
            scope,x
    with
        Not_found -> E.error ("unknown type: "^name)
@

The following primed functions return just the entry for a name
without its attributes.  This is a special case of the functions above
and only for convenience.

<<>>=
let findv' name env = snd (findv name env)
let findt' name env = snd (findt name env)
@

% ------------------------------------------------------------------ 
\subsubsection{Target architecture description}
% ------------------------------------------------------------------ 

The [[target]] directive in {\PAL} describes the target architecture
an program is intended for. The information can be distributed over
the program and can declare the same fact several times.  However, the
informations about the target architecture must be consistent. 

The implementation maintains a record of type [[target]] for the target
informations where each information is captured by an [[option]] type. 
Once an information has been supplied the [[bind]] functions enforce
that only the same fact can be entered again.  When an inconsistent
update is attemped the target information is bound to [[Error]] and an
error message is issued.

The [[update]] function computes the value inside the target record
based on an existing value and a new one. In case the target record
was unset the new value is returned. Otherwise the new value must
match the existing one, or an inconsistency was found. In the latter
case [[Error]] is returned.

<<>>=
let update r env name old new' =
    let seq f x = E.sequence x f in
        seq old
        ( function
        | Some x as old when x = new' -> E.Ok(old) (* consistent   *)
        | Some x               -> 
            ( error r env ("inconsistent target specification for "^name)
            ; E.Error                              (* inconsitent *)
            )
        | None                        -> E.Ok(Some new') (* set *)
        ) 
    

<<>>=
let bindMemsize r n env =
    let memsize' = update r env "memsize" env.target.memsize n in
    let target'  = { env.target with memsize = memsize' }      in
        { env with  target = target' }

<<>>=
let bindEndianness r e env =
    let e'       = update r env "endianness" env.target.endianness e in
    let target'  = { env.target with endianness = e' }               in
        { env with target = target' }
        

<<>>=
let findMemsize    env = env.target.memsize
let findEndianness env = env.target.endianness
@   
    
% ------------------------------------------------------------------ 
\subsubsection{Test for \texttt{Error}-bindings}
% ------------------------------------------------------------------ 

This function looks for [[Error]] bindings in the fat environment. It
returns [[Error]] in case an [[Error]] binding is found, and [[Ok()]]
otherwise. 

<<>>=
let errorfree env =
    let combine key (attr,x) y = E.Implode.pair (x,y)    in
    let free map = StrMap.fold combine map (E.Ok())      in
        E.Implode.list 
        [ free env.tenv
        ; free env.venv
        ; E.Implode.singleton env.target.memsize
        ; E.Implode.singleton env.target.endianness
        ]
@

% ------------------------------------------------------------------ 
\subsubsection{Default-bindings}
% ------------------------------------------------------------------ 

The default [[target memsize]] is [[8]].  If the user has not
specified a memsize we set it explicitly because the static semantic
checks need it. 

<<>>=
let setDefaults env =
    match findMemsize env with
    | E.Ok(Some x) -> env
    | E.Ok(None)   -> bindMemsize Srcmap.null 8 env
    | E.Error      -> env
@
