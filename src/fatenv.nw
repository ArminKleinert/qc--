
% ------------------------------------------------------------------ 
\section{The Fat Environment}
% ------------------------------------------------------------------ 

The meaning, or denotation, of names in a {\PAL} program are recorded
in one environment.  Because only one environment is used for all
different kinds of names it is called fat.  In particular the fat
environment holds informations about:

\begin{itemize}
\item Values, like constants, labels for goto and data, procedures.
\item Types, as they are declared by the [[typedef]] directive.
\item Target architecture, as declared by the [[target]] directive.
\item Source code positions, as recored by a [[Srcmap.map]].
\end{itemize}
  
% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

A fat environment has type [[env]]. The same [[env]] will be used for
checking the static semantics and code generation. It therefore may
contain some informations that are only required in some parts of the
compiler, but not all.

<<fatenv.mli>>=
type env

<<type declarations>>
<<function signatures>>
@

{\PAL} knows two scopes and two kinds of names that are scoped: 
values and types declared at the top-level and section-level have
global scope, values and types declared inside procedures have local
scope.  A local name can shadow the same name in the global scope.

<<type declarations>>=
type scope      = Global | Local
@

Labels come in different kinds:  they denote procedures, goto-labels,
data-labels, and stack-labels.

<<>>=
type kind       = Proc
                | Code
                | Data
                | Stack
@

Most names in a fat environment are either types (of values), or
types.  Only for constant values their actual value is known; the type
of a value is always known, as is the type of a type-alias
([[typedef]]). 
                    
<<>>=
type ty         = Types.ty
type value      = Const.value

@
A value can denote different things: a label, a compile-time constant, a
register, or a continuation. For constants their value is recorded.

<<>>=
type denotation = Constant of value
                | Label    of kind
                | Import
                | Register
                | Continuation
@

Names for types and values constitute two different name spaces:  the
same name can denote a type and a value.  For both value and types a
binding provides the scope of the binding and its denotation.  If a
declaration is erroneous we still bind the declared name:  the
[[Error.error]] type allows to distinguish between good and bad
declarations. 

A name in {\PAL} must never be re-declared.  To detect an attempt to
re-declare the scope of an existing binding must be known, even when
the declaration of that binding was erroneous.  For this reason the
[[scope]] of a binding is not part of the [[Error.error]] type
constructor.

<<>>=
type ventry     = scope * (denotation * ty) Error.error
type tentry     = scope * ty                Error.error
@ 

The fat environment records the [[target]] annotation from a {\PAL}
source code. The endianness is part of the [[target]] declaration.

<<>>=
type endianness = Big | Little

@ An [[env]] holds a source map that was obtained during the parsing
of a source code. It must be provided when the [[env]] is created such
that is available to all code that report error in the static semantics.

<<function signatures>>=                
val create          : Srcmap.map -> env
@

The following functions bind and find names of value and types in an
[[env]]:  [[bindv]] binds values, [[bindt]] binds types.  The
specialized function [[bindvError]] and [[bindtError]] bind names to
[[Error.Error]] in the value and type name space respectively.

Any attempt to re-declare a name in a scope is detected by the
[[bind*]] functions reported with an [[Error.ErrorExn]] exception.

<<>>=
val bindv           : string -> ventry  -> env -> env
val bindt           : string -> tentry  -> env -> env
val bindvError      : string -> scope   -> env -> env
val bindtError      : string -> scope   -> env -> env
@

The [[find*]] functions lookup the meaning of a name in the value or
type name space.  The result includes the scope where a name was
bound.  In case the name is not bound an [[Error.ErrorExn]] is raised.

<<>>=
val findv           : string -> env     -> ventry
val findt           : string -> env     -> tentry
val findv'          : string -> env     -> (denotation * ty) Error.error
val findt'          : string -> env     -> ty Error.error
@

The [[srcmap]] function returns the [[Srcmap.map]] value passed to
[[create]].

<<>>=
val srcmap          : env -> Srcmap.map
@

The [[target]] declarations are bound in an [[env]].  All [[target]]
declarations must be consistent in a {\PAL} program:  the
[[byteorder]] of a compilation unit must be the same at every
declaration of the byte order.  This is checked by the [[bind*]]
functions:  after a value was bound any attempt to bind a different
value is reported with an [[Error.ErrorExn]] exception.

When no target declaration was provided, the [[find*]] functions
return [[None]].

<<>>=
val bindMemsize     : int        -> env -> env
val bindEndianness  : endianness -> env -> env 
val findMemsize     : env -> int option
val findEndianness  : env -> endianness option   
@

The function [[errorfree]] checks whether a fat environment [[env]]
binds any [[Error.Error]] value.  In case it does, it return
[[Error.Error]] and [[Error.Ok()]] if the fat environment is
error-free.

<<>>=
val errorfree       : env -> unit Error.error
@

For some opetional declarations in {\PAL} defaults exist. The
[[setDefaults]] function enter the defaults into the environment in
the user has not provided a declaration.

<<>>=
val setDefaults     : env -> env
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<fatenv.ml>>=
module E = Error

module Comparable   = struct type t=string let compare=compare end
module StrMap       = Map.Make(Comparable)

<<type declarations>>

type tenv           = tentry StrMap.t
type venv           = ventry StrMap.t
type arch           = { memsize:      int option
                      ; endianness:   endianness option
                      }
<<>>=
type env            = { tenv   :      tenv
                      ; venv   :      venv
                      ; arch   :      arch
                      ; srcmap :      Srcmap.map
                      }    

let create map      = { tenv = StrMap.empty
                      ; venv = StrMap.empty
                      ; arch = { memsize    = None
                               ; endianness = None
                               }
                      ; srcmap = map
                      }
@

% ------------------------------------------------------------------ 
\subsubsection{Bindings for types and values}
% ------------------------------------------------------------------ 

In a {\PAL} program a declared name is visible in its entire scope,
even before the place of its declaration.  The re-declaration of
values and type is therefore not allowed.  The implementations of
[[bindv]] and [[bindt]] maintains this by comparing the scope on an
new name and a possibly existing name in the environment.  No name can
be added into the same scope where the same name is already declared.

When a name is re-declared we issue an error but the first declaration
is considered valid.  It would be better to re-bind it to error to
make the problem visible in the environment.  But the current error
reporting design does not allow to report an error and return a value
at the same time.

<<>>=
let bindv name (scope, _ as x) env =
    let add name x = {env with venv = StrMap.add name x env.venv} in
    try 
        let (scope',) = StrMap.find name env.venv in
        if scope' = scope then
            E.error ("value already declared: "^name)
        else
            add name x
    with
        Not_found -> add name x
@

<<>>=
let bindt name (scope, _ as x) env =
    let add name x = {env with tenv = StrMap.add name x env.tenv} in
    try 
        let (scope',_) = StrMap.find name env.tenv in
        if scope' = scope then
            E.error ("type already declared: "^name)
        else
            add name x
    with
        Not_found -> add name x

<<>>=
let bindvError name scope env = bindv name (scope, E.Error) env
let bindtError name scope env = bindt name (scope, E.Error) env
@

The functions to lookup a value [[findv]] and a type [[findt]] raise
an [[E.Error]] exception in case the name can not be found.

<<>>=
let findv name env =
    try
        StrMap.find name env.venv
    with 
        Not_found -> E.error ("unknown value: "^name)

<<>>=
let findt name env =
    try
        StrMap.find name env.tenv
    with
        Not_found -> E.error ("unknown type: "^name)
<<>>=
let findv' name env = snd (findv name env)
let findt' name env = snd (findt name env)
@

% ------------------------------------------------------------------ 
\subsubsection{Sourcemap}
% ------------------------------------------------------------------ 

<<>>=
let srcmap env = env.srcmap
@

% ------------------------------------------------------------------ 
\subsubsection{Target architecture description}
% ------------------------------------------------------------------ 

The [[target]] directive in {\PAL} describes the target architecture
an program is intended for. The information can be distributed over
the program and can declare the same fact several times.  However, the
informations about the target architecture must be consistent. 

The implementation maintains a record of type [[arch]] for the target
informations where each information is captured by an [[option]] type. 
Once an information has been supplied the [[bind]] functions enforce
that only the same fact can be entered again.  They raise an
[[E.Error]] in case this is attempted because this would violate the
consistency constraint.
 
<<>>=
let bindMemsize n env =
    match env.arch.memsize with
    | Some n' when n' <> n -> E.error "Inconsistent memsize specification"
    | Some n' -> env
    | None -> { env with arch = { env.arch with memsize = Some n} }
@

<<>>=
let bindEndianness e env =
    match env.arch.endianness with
    | Some e' when e' <> e -> E.error "Inconsistent endianness specification"
    | Some e' -> env
    | None -> { env with arch = { env.arch with endianness = Some e} }
@

<<>>=
let findMemsize    env = env.arch.memsize
let findEndianness env = env.arch.endianness
@   
    
% ------------------------------------------------------------------ 
\subsubsection{Test for \texttt{Error}-bindings}
% ------------------------------------------------------------------ 

<<>>=
let errorfree env =
    let combine key (scope,x) y = E.Implode.pair (x,y)    in
    let free map = StrMap.fold combine env.venv (E.Ok())  in
        E.Implode.pair (free env.tenv, free env.venv)
@

% ------------------------------------------------------------------ 
\subsubsection{Default-bindings}
% ------------------------------------------------------------------ 

The default [[target memsize]] is [[8]].  If the user has not
specified a memsize we set it explicitly because the static semantic
checks need it. 

<<>>=
let setDefaults env =
    match findMemsize env with
    | Some x -> env
    | None   -> bindMemsize 8 env
@
