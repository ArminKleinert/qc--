
% ------------------------------------------------------------------ 
\section{Topological Sort}
% ------------------------------------------------------------------ 

Constants and types in {\PAL} can be declared recursively:  one
declaration may depend on several others.  This relationship must be
taken into account when constants and type declarations are evaluated
to find the meaning of each declared name.  On way is to find an order
such that a name's meaning is entered into an environment before any
other declaration that refers to it is processed.  Such an order is
called an \emph{topological order}.  The idea is to collect all
declarations of one kind, order them topologically, and process them. 
The [[Topsort]] module implements topological sorting for
declarations.

The topological sorting faces some problems when dealing with
erroneous programs: 

\begin{itemize}
\item Usage of undeclared names.
\item Circular dependencies among declarations.
\item Multiple declarations of the same name.
\end{itemize}

All these problems must be reported as checked compile-time errors.
But we don't want to do this during sorting declarations but after
they are sorted and while processing them. However, each of the problems
mentioned above prevent a proper sorting. In order to be able to do
still much as work as possible in the presence of these problems we
make some assumptions and decisions:

\begin{itemize}
\item An undeclared name depends on no other declaration.
\item A name declared multiple times depends on the union of
      dependencies of its individual declarations.
\item A circular definitions is broken up by removing one declaration.
      This permits to sort the remaining declarations. 
\end{itemize}

For a list of circular definitions no topological order exists.  This
case is reported as an exception with a list of declarations that are
part of a cycle.  The client of this module then has to redo the
sorting with these modules removed from the input.

This topological sort supports the case that one declration may
declare multiple names.  For example, a [[typedef]] can define
multiple names for the same type.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The [[Topsort]] module is parameterized over the declarations it can
sort.  In case of circular declarations a list of offending
declarations is reported with a [[Cycle]] exception.  In the normal
case a list of declaration is returned such that no declaration
depends on any later declaration in the list.  Or, stated positively,
all declarations only depend on their predecessors in the list.

<<signature S>>=
module type S = sig
    type decl
    exception Cycle of decl list
    val sort: decl list -> decl list (* raises Cycle *)
end
@

A declaration [[defines]] multiple names and may [[use]] several other
names in its body.  Aside from this, a declaration is abstract.

<<signature Sortable>>=
module type Sortable = sig
    type decl
    val defines : decl -> string list
    val uses    : decl -> string list
end
@

<<topsort.mli>>=
<<signature S>>
<<signature Sortable>>

module Make (S: Sortable) : (S with type decl = S.decl)
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation uses a modified \emph{depth first search} for
topological sorting as it is outlined by Paulsen in \emph{{\small ML}
for the working Programmer} \cite{paulson:91:ml}.

<<topsort.ml>>=
<<signature S>>
<<signature Sortable>>

module ID       = struct type t=string let compare=compare end
module IDMap    = Map.Make(ID)

module Make (S: Sortable) = struct
    type decl = S.decl
    exception Cycle of decl list 

    <<functions>>
end
@

Multiple definitions can define the same name; this is an error but it
should not affect the sorting. A map points to all declarations that
declare that name.

<<functions>>=
let declmap decls =
    let find key  map    = try IDMap.find key map with Not_found -> [] in
    let add  d map key   = IDMap.add key (d :: find key map) map       in
    let add' map d       = List.fold_left (add d) map (S.defines d)    in
        List.fold_left add' IDMap.empty decls
@
 
The [[succ]] function calculates all declarations a given declaration
depends on with the help of [[S.uses]] and the previously calculated
[[map]]:  [[S.uses]] returns the names used by [[x]] and the [[map]]
translates these to the declarations for these names.

<<>>=
let succ map x =
    let uses = S.uses x in
    let find map n = try IDMap.find n map with Not_found -> [] in
    List.concat (List.map (find map)  (S.uses x))
@

The map [[m]] contains for every name the declarations that define
this name. Correct {\PAL} programs will only use one definition to
define a name. 

<<>>=
let sort decls =
    let m             = declmap decls                               in
    let nv x (v,c)    = x::v ,c                                     in
    let rec sort todo path (visited, cycles) =
        match todo with
        | []    -> visited, cycles
        | x::xs ->
            let vc = if List.mem x path         then visited, x::cycles
                     else if List.mem x visited then visited, cycles
                     else nv x (sort (succ m x) (x::path) (visited,cycles))
                                                                    in
                sort xs path vc
                                                                    in
    match sort decls [] ([],[]) with
    | dd, [] -> List.rev dd
    | dd, cc -> raise (Cycle cc)
@



% ------------------------------------------------------------------ 
\subsection{Test}
% ------------------------------------------------------------------ 

The module [[Topsorttest]] provides a tiny example for declarations.
It was used during development.

<<topsorttest.ml>>=
module D = struct
    type decl = string list * string list
    
    let defines (x,_) = x
    let uses    (_,y) = y
end

module DSort = Topsort.Make(D)

(*   DEFINED               USED BY DEFINITION *)
let regular =
    [ ["wake"]            , ["shower"; "eat" ]
    ; ["shower"]          , ["dress"] 
    ; ["dress"]           , ["go"]
    ; ["eat"]             , ["wash-up"]
    ; ["wash-up"]         , ["go"]
    ; ["go"]              , []
    ]
<<>>=
let multi_lhs1 =
    [ ["wake"]            , ["shower"; "eat" ]
    ; ["shower"; "bath"]  , ["dress"] 
    ; ["dress"]           , ["go"]
    ; ["eat"; "drink"]    , ["wash-up"]
    ; ["wash-up"]         , ["go"]
    ; ["go"]              , []
    ]
<<>>=
let multi_lhs2 =
    [ ["wake"]            , ["shower"; "eat" ]
    ; ["shower"; "bath"]  , ["dress"] 
    ; ["bath"]            , ["dress"] 
    ; ["dress"]           , ["go"]
    ; ["eat"; "drink"]    , ["wash-up"]
    ; ["wash-up"]         , ["go"]
    ; ["go"]              , []
    ; ["go"]              , []
    ]
<<>>=
let undefs =
    [ ["wake"]            , ["shower"; "eat" ]
    ; ["shower"; "bath"]  , ["dress"] 
    ; ["bath"]            , ["dress"] 
    ; ["dress"]           , ["go"]
    ; ["eat"; "drink"]    , ["wash-up"]
    ; ["wash-up"]         , ["go"]
    ]
<<>>=
let cycle1 =
    [ ["wake"]            , ["shower"; "eat" ]
    ; ["shower"; "bath"]  , ["dress"] 
    ; ["bath"]            , ["dress"] 
    ; ["dress"]           , ["go";"wake"]
    ; ["eat"; "drink"]    , ["wash-up"]
    ; ["wash-up"]         , ["go"]
    ; ["go"]              , []
    ; ["go"]              , []
    ]
@
