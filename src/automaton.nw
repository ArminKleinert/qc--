% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Resource Allocation for {\PAL} Variables}
% ------------------------------------------------------------------ 

{\PAL} registers, global variables and formal parameters are
represented either as memory locations or hardware registers.  The
mapping between these {\PAL} objects and their hardware oriented
representations is controlled by this module. 

For passing parameter between procedures and continuations, a target
specific calling conventions describes which argument is passed into a
register, and which in memory.  Mark W.~Bailey and Jack W.~Davidson
have shown in \cite{bailey:davidson:95} that the process of choosing
registers and memory to pass values can be modeled with finite state
automata.  The automaton receives a stream of enriched {\PAL} types
and the automaton responds for each data type with a register-like
location that the parameter is passed in.

Memory used for parameter passing can be shared by all calls inside a
procedure because it is never used by two calls at the same time.  The
memory requirement of the most complicated call thus determines the
amount and alignment of memory that must be reserved for parameter
passing.  When each call results in an \emph{area} that describes its
memory requirement, an \emph{overlay} operation over two areas allows
to compute a new area that can hold both.

% ------------------------------------------------------------------ 
\section{Allocation of register-like Locations}
% ------------------------------------------------------------------ 

Register-like locations are maintained by automatons.  An automaton
encapsulates the ability to assign locations.  Every automaton has a
private collection of locations (e.g., registers) that it may use at
will, plus an ``overflow area.'' The overflow area is located in
memory, and it must be contiguous.

Automata are imperative; the type [[t]] encapsulates mutable state. 
This state is primarily the private internal state of the automaton,
but there is one part of state that is public.  When an automaton is
``frozen,'' it is no longer possible to get new locations from it, but
in exchange, one can get the size and alignment requirement (and also
the address) of its overflow area.

Although an \emph{automaton} is imperative, the \emph{specification}
of the automaton is not.  To create an automaton, one needs a
specification, plus the address to be used to point to the overflow
area.  \emph{Addresses always point to the lowest addressed byte, as
in the value returned from [[malloc]].} This address may contain
unbound compile-time constants (see \module{const}).

A mutable automaton [[t]] is made from a specification [[spec]].  When
run, the automaton returns abstract locations [[loc]].  The type
abbreviations for alignment, width, and size are only for
documentation purposes.

<<automaton.mli>>=
type spec  (* specification of an automaton (immutable) *)
type t     (* an automaton (mutable) *)
type loc   (* a location provided by an automaton *)

val dummy: spec    (* spec to create a dummy automaton *)
@

Supply an address of the overflow area, and get back an automaton in
its initial state.

<<automaton.mli>>=
val mk : spec -> address:Rtl.exp -> t           
@

To allocate a new resource slot, call [[ty]].  It returns a location
[[[loc]] and change the automaton's internal state.

<<automaton.mli>>=
val ty: t -> width:int -> hint:(string option) -> loc    
@

Location's as returned by an automaton can't be used directly because
they are abstract.  To use them to store and fetch data, use the
following two functions:

<<automaton.mli>>=
val fetch : loc -> width:int -> Rtl.exp
val store : loc -> Rtl.exp -> width:int -> Rtl.rtl
@

When all allocations are done [[freeze]] the automaton. In response
it returns the space allocated in the overflow [[area]]. 

<<automaton.mli>>=
val freeze : t -> Area.t
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<automaton.ml>>=
type spec = unit
type t    = unit
type loc  = unit

let dummy                = ()
let mk () loc            = ()
let ty () ~width ~hint   = ()

let fetch () ~width      = Impossible.unimp "Automaton.fetch"
let store () expr ~width = Impossible.unimp "Automaton.store"

let freeze ()            = Impossible.unimp "Alloc.Reg.freeze"
@

% ------------------------------------------------------------------ 
\subsubsection{Overlapping Areas}
% ------------------------------------------------------------------ 

<<overlapping areas implementation>>=
let overlap place areas = Impossible.unimp "Alloc.overlap"
@
