
\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Automaton for Calling Conventions}
% ------------------------------------------------------------------ 

Each target platform requires an implementation of its procedure
calling convention:  which arguments goes into registers and which are
passed on the stack.  Calling convetions also exists for returning
values and passing them to a continuation.  Mark W.~Bailey and Jack
W.~Davidson have shown in \cite{bailey:davidson:95} that the process of
choosing registers to pass values can be modeled with finite state
automata.  The automaton receives a stream of enriched {\PAL} types
and the automaton responds for each data type with a location that the
parameter is passed in.

% ------------------------------------------------------------------ 
\subsection{Interface to Automaton}
% ------------------------------------------------------------------ 

The interface for the calling convention automata serves two purposes: 
construction of automata and using them.  To keep {\qcc} as flexible
as possible, automata for calling conventions are at least in
principle constructed at run-time (of the compiler) and not
hard-wired.  Once an automaton is defined, it is used by the code
generator to find the locations parameters are passed to or from
procedures and continuations.  The difference between these two
aspects of the interface are expressed by using sub-modules for them
in the interface.

<<automaton.mli>>=
<<basic types>>
module Run   : sig <<signature run>>   end
module Build : sig <<signature build>> end
@

% ------------------------------------------------------------------ 
\subsubsection{Basic Types}
% ------------------------------------------------------------------ 

Pure {\PAL} data types like [[bits32]] are usually not descriptive
enough to find the location a parameter of that value is passed in. 
Calling conventions usually not only only rely on the size of a
parameter, but to some degree on its purpose, too.  A type from the
perspective of calling conventions is thus a tuple of a {\PAL} type
and a hint. 

<<basic types>>= 
type ty = Types.ty * string option
@

An automaton is used at a caller's side to find the locations 
values to be passed are stored in, and at the callee's side to find
the location incoming parameters are read from. The same situation
arises at a [[return]] and when [[cut]]'ing to a continuation. A
[[location]] thus includes two values: a function that returns a
location for a value to be stored, and an expression that yields the
value of a parameter.

<<>>=
type location = (Rtl.expr -> Rtl.effect)          (* write value *)
              * Rtl.expr                          (* read  parameter *)
@

Of course, there is the automaton itself.  An automaton maintains
an internal actual state that changes when the automaton is run.  

<<>>=
type t
@

% ------------------------------------------------------------------ 
\subsubsection{Running an Automaton}
% ------------------------------------------------------------------ 

This sub-module defines everything an automaton's client needs to
know.  Especially all details about a calling convention is left
abstract.

Running an automaton means to ask for the [[location]] of a [[ty]]. 
This advances an automaton to its [[next]] state.  The answers to the
question includes the desired [[location]] and the automaton in its
new (internal) state.  When the automaton lacks a transition from its
current state for the requested type, the [[Error.ErrorExn]] exception
is raised.

A [[ty]] value passed to [[next]] may include a hint for a hardware
register. Such a hardware register must have been announced to the
automaton when it was [[reset]]. The location in respond to the [[ty]]
value will be the hardware register that was previously announced.

<<signature run>>=
val next: t -> ty -> location * t (* Error.ErrorExn *)
@

The code generator not only needs to know where parameters are stored,
but also the overall size of the area (overflow) parameters are stored
in and its alignment.  This information is captured by the
[[overflow]] type and function.  The memory requirements for
overflowing parameters are determined by the \emph{state} of an
automaton and thus can be obtained from it.  In contrast, the
[[location]] for a parameter is determined by the \emph{transition}
between two states and thus it is returned by the [[next]] function.

<<>>=
type overflow   = { size:   int   (* overflow area in memsize units *)
                  ; align:  int   (* alignment in memsize units     *)
                  }
val overflow: t -> overflow
@

% ------------------------------------------------------------------ 
\subsubsection{Building an Automaton -- preliminary}
% ------------------------------------------------------------------ 

Creating an automaton for an existing calling conventions is not a
straight forward task.  This interface is rather low-level and does
not go beyond the automaton perspective.  An additional high-level
approach may be adequate that provides a domain specific notation that
ultimately can be converted into an automaton using this interface.

A state captures which locations have been used for parameter passing
and where the next parameter goes, depending on its type.  A state is
simply a number. 

<<signature build>>=
type state = int
@

Since conceptually an infinite number of parameters can be placed in
memory, a pure finite state automaton can not keep track of the
consumed locations.  We thus assume that an automaton contains
some form of counter that keeps track of parameters in memory in order
to use still a finite number of states.  The [[info]] type represents
this counter, and the [[info]] function returns this information for
an automaton:

<<>>=
type info       (* bogus. how t create info values? *)
val info: t -> info
@


To build an automaton, start with [[make]].  This function receives
the initial state of the automaton.

<<>>=
val make    : state -> t   
@

A \emph{transition} from one state to another describes which
locations to use for the type [[ty]] that guards this transition.  So
a transition between two states is labeled with two informations:  a
type [[ty]] and a location.  Locations in memory (opposed to those in
registers) depend on previous parameters placed into memory.  This
makes the location dependent on the counter [[info]] maintained by an
automaton.  A transition is thus added to an automaton by specifying
two states, a type, and an [[info]] dependent [[location]].
       
<<>>=
val add: t -> state -> ty -> (info -> location) -> state -> t
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<automaton.ml>>=
type ty       = Types.ty * string option
type location = (Rtl.expr -> Rtl.effect)
              * Rtl.expr

type t        = unit

module Run = struct
    let next () t = assert false
    
    type overflow = { size:  int
                    ; align: int
                    }

    let overflow () = assert false
end

module Build = struct
    type state = int
    type info  = unit

    let info () = assert false
    let make n  = assert false
    let add () s1 t f s2 = assert false
end
@
    
