% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Resource Allocation for {\PAL} Variables}
% ------------------------------------------------------------------ 

{\PAL} registers, global variables and formal parameters are
represented either as memory locations or hardware registers.  The
mapping between these {\PAL} objects and their hardware oriented
representations is controlled by this module. 

For passing parameter between procedures and continuations, a target
specific calling conventions describes which argument is passed into a
register, and which in memory.  Mark W.~Bailey and Jack W.~Davidson
have shown in \cite{bailey:davidson:95} that the process of choosing
registers and memory to pass values can be modeled with finite state
automata.  The automaton receives a stream of enriched {\PAL} types
and the automaton responds for each data type with a register-like
location that the parameter is passed in.

Memory used for parameter passing can be shared by all calls inside a
procedure because it is never used by two calls at the same time.  The
memory requirement of the most complicated call thus determines the
amount and alignment of memory that must be reserved for parameter
passing.  When each call results in an \emph{area} that describes its
memory requirement, an \emph{overlay} operation over two areas allows
to compute a new area that can hold both.

% ------------------------------------------------------------------ 
\section{Allocation of register-like Locations}
% ------------------------------------------------------------------ 

Register-like locations are maintained by automatons.  An automaton
encapsulates the ability to assign locations.  Every automaton has a
private collection of locations (e.g., registers) that it may use at
will, plus an ``overflow area.'' The overflow area is located in
memory, and it must be contiguous.

Automata are imperative; the type [[t]] encapsulates mutable state. 
This state is primarily the private internal state of the automaton,
but there is one part of state that is public.  When an automaton is
``frozen,'' it is no longer possible to get new locations from it, but
in exchange, one can get the size and alignment requirement (and also
the address) of its overflow area.

Although an \emph{automaton} is imperative, the \emph{specification}
of the automaton is not.  To create an automaton, one needs a
specification, plus the address to be used to point to the overflow
area.  \emph{Addresses always point to the lowest addressed byte, as
in the value returned from [[malloc]].} This address may contain
unbound compile-time constants (see \module{const}).

A mutable automaton [[t]] is made from a specification [[spec]].  When
run, the automaton returns abstract locations [[loc]].  The type
abbreviations for alignment, width, and size are only for
documentation purposes.

<<automaton.mli>>=
type spec  (* specification of an automaton (immutable) *)
type t     (* an automaton (mutable) *)
type loc   (* a location provided by an automaton *)

val dummy: spec    (* spec to create a dummy automaton *)
@

Supply an address of the overflow area, and get back an automaton in
its initial state.

<<automaton.mli>>=
val mk : spec -> address:Rtl.exp -> t           
@

To allocate a new resource slot, call [[ty]].  It returns a location
[[[loc]] and change the automaton's internal state.

<<automaton.mli>>=
val ty: t -> width:int -> hint:(string option) -> loc    
@

Location's as returned by an automaton can't be used directly because
they are abstract.  To use them to store and fetch data, use the
following two functions:

<<automaton.mli>>=
val fetch : loc -> width:int -> Rtl.exp
val store : loc -> Rtl.exp -> width:int -> Rtl.rtl
@

Because locations are abstract they can handle difficult cases where
a value is stored in part in a hardware register and in part in
memory.  Some complicated calling conventions may require such
difficult concepts of a location.  However, the very most cases are
much simpler and we like to represent those as [[Rtl.loc]] values,
which are also very general but can't deal with values split into
different memory spaces.  The following function allows to transform a
sufficiently simple [[loc]] value to a [[Rtl.loc]] value.  If a
conversion is not possible, [[Invalid_argument]] is raised as a
checked run-time error.

<<automaton.mli>>=
val to_loc : loc -> Rtl.loc
val of_loc : Rtl.loc -> loc
@

<<automaton.mli>>=
val freeze : t -> Area.t
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

Until we know better we assume that automata for different platforms
are probably quite different and a single implementation is unlikely
to support them all.  We resort to an object-oriented implementation
that allows to have several implementations for the same interface. 

All real work is done by objects of class [[location]] and
[[automaton]] that are used as representation for [[loc]] and [[t]]
respectively. The class types define their shape but we are free to
provide entirely different implementations.

<<automaton.ml>>=
class type location = object
    method fetch:   width:int -> Rtl.exp
    method store:   Rtl.exp -> width:int -> Rtl.rtl
    method to_loc:  Rtl.loc
end

class type automaton = object
    method ty:      width:int -> hint:(string option) -> location
    method freeze:  unit -> Area.t
end

type spec = Rtl.exp -> automaton
type t    = automaton
type loc  = location
@

Because the representations for [[t]] and [[loc]] are objects the
implementations for [[mk]], [[ty]] and so forth just pass their
arguments to the objects at hand.

<<automaton.ml>>=
let mk spec ~address  = spec address
let ty t ~width ~hint = t#ty width hint
let freeze t          = t#freeze ()

let fetch loc ~width      = loc#fetch ~width
let store loc expr ~width = loc#store expr ~width
let to_loc loc            = loc#to_loc
@

As a first implementation we provide an automaton that puts everything
in memory, using the [[Area]] building block. 

<<automaton.ml>>=
module Dummy = struct
    <<Dummy struct>>
end

let dummy = new Dummy.dummy 
let of_loc loc            = Dummy.of_rtl_loc loc
@

% ------------------------------------------------------------------ 
\subsection{Dummy Automaton}
% ------------------------------------------------------------------ 

The [[Dummy]] module makes some assumptions about the current
architecture and implements an automaton that provides
word size aligned locations in memory. 

\begin{quote}\it
    This needs a review. I'm not sure about alignments and widths. --CL
\end{quote}

<<Dummy struct>>=
let byteorder           = Rtl.BigEndian
let wordsize            = 32
let pointersize         = 32
let memsize             = 8
let memspace            = ('m':Rtl.space)
@

The [[dummyloc]] class represents an address in [[memspace]] that is
made of [[memsize]] cells, aggregated in [[byteorder]].  The width of
the data stored there is variant.

<<Dummy struct>>=
class dummyloc (loc:Rtl.loc): location =
object
    val _loc   = loc
    
    method store expr ~width = Rtl.store _loc expr width 
    method fetch ~width      = Rtl.fetch _loc width
    method to_loc            = _loc
end

let memloc addr = new dummyloc (Rtl.cell Rtl.none memspace byteorder memsize addr)
let of_rtl_loc loc = new dummyloc loc

class dummy (base:Rtl.exp): automaton =
object (self)
    val mutable _area   = Area.align (Area.mk base) wordsize
    val mutable _frozen = false
    
    method freeze ()       =
        let _ = _frozen <- true in
            Area.freeze _area 
    
    method ty ~width ~hint = 
        let _    = assert (_frozen = false)           in
        let _    = assert (width < wordsize)          in
        let _    = assert (width mod memsize = 0)     in
        (* assertions above *)
        let n    = width / memsize                    in (* how many cells*)
        let addr = Area.location _area                in
        let ()   = _area <- Area.alloc _area n        in (* allocate ..*)
        let ()   = _area <- Area.align _area wordsize in (* and align  *)
            memloc addr
end
@
