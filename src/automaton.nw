% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:
%
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% $Id$

%%Grades: A Central Later




% ------------------------------------------------------------------ 
\section{Automaton-Based Slot Allocation}
% ------------------------------------------------------------------ 

\emph{The predicates for [[choice]] and [[first_choice]] take [[width]]
and [[hint]] in different orders. Maybe we should define an extra type
alias. --CL}

This module supports Bailey-Davidson automata for allocating locations
for value-passing.
An automaton manages a set of hardware locations, which it uses to
satisfy allocation requests.
In the Bailey-Davidson framework, the set of locations is split into
two parts:
\begin{itemize}
\item
A finite set of locations, which may be managed arbitrarily
\item
An infinite set of locations, which must be allocated sequentially and
contiguously
\end{itemize}
We call the infinite set of locations the \emph{overflow block}.
@
The overflow block has a number of properties.
\begin{itemize}
\item
The overflow block has a \emph{maximum alignment}.
This alignment is the maximum possible alignment of any location in
the block, and it is a function of the calling convention.
\item
The overflow block has a \emph{direction of growth}.
\item
The overflow block has a \emph{number of bytes allocated}.
\end{itemize}
The maximum alignment and direction of growth are fixed when the
overflow block is created; the number of bytes allocated increases
monotonically during allocation.
@
The Bailey-Davidson automaton has two parts: a finite-state control
that manages the finite set of locations, and an infinite-state
control for the overflow block.
The infinite set of states is mapped to a finite set by considering
only the number of bytes allocated modulo the maximum alignment.
We use a value of type [[Memalloc.t]] to manage this part of the
automaton.
@
The interface exports abstract types, concrete types, and values.
<<automaton.mli>>=
<<abstract types>>
<<exposed types>>
<<exported values>>
@ 
\subsection{Standard hints}

We might use these hints:\\
\begin{tabular}{>{\ttfamily}ll}
signed& Signed integer\\
unsigned& Unsigned integer\\
address&  Address\\
float&    Floating-point value\\
\end{tabular}\\
A missing or empty hint is assumed to be [[unsigned]].
@
\subsection{Observer-Mutator interface}
An [[Automaton.t]] encapsulates mutable state.  
Allocating a location mutates its state.
After allocation is completed, an automaton is \emph{frozen},
and it can no longer be mutated.
A~frozen automaton gives us an overflow block, its state, and the set
of locations handed out.
The set implicitly includes every location in the overflow block; the
rest of the set is explicit.
<<abstract types>>=
type t
<<exposed types>>=
type result =
  { overflow    : Block.t
  ; regs_used   : Register.Set.t
  ; mems_used   : Rtl.loc list
  ; align_state : int   (* final alignment state of overflow block *)
  }
@ 
We allocate a location by identifying a value's type, which in {\PAL}
is a width and a hint.
<<exported values>>=
val allocate : t -> width:int -> hint:string -> loc
val freeze   : t -> result
@
In some conventions, a value must be split between two registers or
between registers and memory.
Accordingly, we need a special type of location.
<<exposed types>>=
type width = int
type hint  = string
type loc = { fetch : width -> Rtl.exp; store : Rtl.exp -> width -> Rtl.rtl }
<<exported values>>=
val fetch  : loc ->            width -> Rtl.exp
val store  : loc -> Rtl.exp -> width -> Rtl.rtl
@ 
Most locations are easy.
<<exported values>>=
val of_loc : Rtl.loc -> loc
@ 
It can be useful to treat a wide location as a narrow one.
This means inserting widening and narrowing operations on fetch and
store.
We provide three instances: signed narrow and widen, unsigned narrow
and widen, and floating narrow and widen.
If more instances are needed, there's a higher-order function lurking
in the implementation. 
<<exported values>>=
val narrows : w:int -> n:int -> loc -> loc
val narrowu : w:int -> n:int -> loc -> loc
val narrowf : w:int -> n:int -> loc -> loc
@ 
This is a compatibility interface, which will go away.
<<old compatibility interface as par of exported values>>=
val of_old : Automaton2.loc -> loc
val to_old : loc -> Automaton2.loc
@ 
\subsection{Constructor interface}
Most clients will simply use an automaton, but some will need to
create one.
For these a representation with two functions: an allocator, and
something that implements [[freeze]].
The allocator takes an additional alignment, which it uses if it has
to put the value in memory.
If called directly from [[val allocate]], the alignment is always~$1$,
but it may be changed by upstream implementations.
The [[freeze]] function accumulates information about locations handed
out, which information it passes to the right. 
At the very end is the overflow block.
<<exposed types>>=
type methods =
    { allocate : width: int -> alignment: int -> hint: string -> loc
    ; freeze   : Register.Set.t -> Rtl.loc list -> result
    } 
@ To get an instance of an automaton, we need to provide a start
address for the overflow block.
(I'M CONCERNED THAT WE USE A START ADDRESS HERE BUT TYPICALLY USE A
BASE ADDRESS ELSEWHERE.  THIS DIFFERENCE MAY CAUSE PROBLEMS FOR THINGS
THAT GROW DOWN.) 
<<exposed types>>=
type implementation = I of (start:Rtl.exp -> methods)
<<exported values>>=
val at : start:Rtl.exp -> stage -> t
val of_methods : methods -> t
@ 
The idea is that we build an implementation by a composition of
stages.
We provide stages that change alignment, adjust widths, hand out
locations, and so on.
In addition, we expect that a client might write its own stages.
<<exposed types>>=
type stage = S of (implementation -> implementation)
<<exported values>>=
val ( *> ) : stage -> stage -> stage
@ 
Because it's a nuisance to manage the threading of the [[start]]
parameter through the stages, we provide a function that builds
stages.
<<exported values>>=
val wrap  : (methods -> methods) -> stage
@ 
\paragraph{The overflow block, if any}
The final stage in any implementation is the overflow block.
To make an overflow block, you need a bunch of information about the
machine and a bunch of information about the convention.
<<exported values>>=
val overflow :
  memsize:int -> byteorder:Rtl.aggregation ->                     (* machine    *)
  growth:Memalloc.growth -> max_alignment:int ->                  (* convention *)
  stage
@ 
It is possible to have {no} overflow block.
In this case, it's up to clients to gather that only finitely many
requests are made and that the automaton satisfies all of them.
Such an automaton is useful for conventions in which only finitely 
many values can be passed,  such as the C~return
convention.
@ 
\paragraph{Selection and adjustment of width}
The [[widths]] stage can restrict the convention to satisfy only
requests naming a listed width.
<<exported values>>=
val widths : int list -> errormsg:(int -> string) -> stage
@
The [[widen f]] stage  alters a request for a
width~[[w]] so it has a width [[f w]], which must be at least as large as~[[w]].
The widening operation depends on the hint.
For a little-endian machine passing values in memory, widening an
unsigned integer or address is
equivalent to adding padding.
For a big-endian machine, it isn't.
It is an unchecked run-time error for [[f]] to return a result that is
less than its argument.
<<exported values>>=
val widen  : (int -> int) -> stage
@ We expect stages such as
[[Automaton.widen (Aux.round_up_to ~multiple_of:32)]] 
to be useful.
@
\paragraph{Adjustment of alignment}
If a value must be allocated in memory, it needs an alignment.
All alignments start out at~1, but we can provide a function that
maps a width to an alignment.
Danger Will Robinson!
The argument to the function is a width in \emph{bits}, but the
alignment is a size in \emph{bytes} (actually the unit is not the byte
but the cell size of target memory).
<<exported values>>=
val align_to : (int -> int) -> stage
@ 
\paragraph{Allocation of registers}
Although it may not be terribly useful, we provide a simple stage that
hands out registers sequentially.
To satisfy a request, the stage takes the first~$n$ registers, where
$n$~is chosen such that the number of bits in these registers is
exactly the number of bits in the request.
If there is no such~$n$, it barfs with an error message.
<<exported values>>=
val useregs : Register.t list -> errormsg:(int -> Register.t list -> string) -> stage
@ The [[useregs]] stage is stateful; a register handed out in response
to an earlier request cannot be used to satisfy a later request.
@
See the paper for this.
<<exported values>>=
val bitcounter    : int ref -> stage
val offsetregs : int ref -> Register.t list -> stage
@ 
And also see the paper for this:
<<exported values>>=
val argcounter : int ref -> stage
val argnoregs  : int ref -> Register.t list -> stage
@ 
And this is documented nowhere, not even in the paper.
<<exported values>>=
val postprocess : stage -> (result -> result) -> stage
@
\paragraph{Combination of multiple stages}
It can be useful to hand out different registers from different piles.
For example, we might want to use floating-point registers to satisfy
[["float"]] requests and integer registers to satisfy other requests.
The following combinator makes it possible to use different stages for
different requests.
Because the stages don't communicate, it is probably not too useful
for describing C~conventions (C~varargs hell), but it should be useful
for {\PAL} conventions.

The idea is that for an allocation, we use the first stage for which
the predicate is satisfied.
It is a checked run-time error if no predicate is satisfied.
<<automaton.mli>>=
val choice : ((string -> int -> bool) * stage) list -> stage
@ To help create predicates we provide the [[is_hint]] and
[[is_width]] functions.
<<automaton.mli>>=
val is_hint  : string -> (string -> int -> bool)
val is_width : int    -> (string -> int -> bool)
val is_any   :           (string -> int -> bool)
@ 
\paragraph{Using an automaton as a stage}

Although it is not necessary for calling conventions, we have found it
convenient to abuse the abstraction by using an automaton [[inner]] as
a stage in an [[outer]] automaton.
The idea is to use [[as_stage inner]] as a stage.
When this stage receives an allocation request, it passes the request
to the [[inner]] automaton.  
Thus [[as_stage inner]] behaves like an overflow block: it is the
final stage in its automaton, and it has no successor.
But when the [[outer]] automaton is frozen, it has no effect on the
[[inner]] automaton, which can continue to satisfy allocation
requests.
<<automaton.mli>>=
val as_stage : t -> stage
@


\paragraph{Exclusion and interference of registers}
For the MIPS calling convention, we need additional goodies.
One is that by convention, the use of some registers excludes the use
of other registers not otherwise connected.
(I~conjecture this rule exists to make it simpler to implement
varargs.) 

For each parameter, we want a \emph{placement} in a register.
The idea here is similar to that used in NR's work with Glenn and Mike
on register allocation for irregular architectures: some placements
can exclude others.
In this compiler, a placement is a register or aggregate of registers;
we can't support sub-register placements.
A~value of type [[Exclude.t]] is mutable state that keeps track of
which placements have been used.
A~client uses the [[use]] function to announce the use of a placement
and the [[available]] function to query the the availability of a
placement.
Using a placement may exclude some others, depending on the
information passed to the [[of_pairs]]
constructor. 
The first argument enables the abstraction to compute the natural
exclusion relation induced by the aliasing structure of the machine.
The second argument provides an exclusion relation that is pure
software convention.
If a pair [[rs, rs']] is passed, the use of \emph{any} placement
in~[[rs]] excludes \emph{all} the placements in [[rs']], and vice
versa.  That is, the exclusion relation is symmetric. To build an
asymmetric relation, use [[of_directed_pairs]]. Any register on the left
excludes all registers on the right---the opposite does not hold.

<<automaton.mli>>=
module Exclude : sig
  type pair = Register.t list * Register.t list
  type t  (* mutable *)
  val of_pairs           : (char -> Space.t) -> pair list -> t
  val of_directed_pairs  : (char -> Space.t) -> pair list -> t
  val use                : t -> Register.t -> unit
  val available          : t -> Register.t -> bool
end
@ As an example, the MIPS calling convention might use
<<example code based on MIPS R3000 calling convention>>=
let t = Exclude.of_pairs Mips.spaces [[r4; r5], f10; [r6; r7], f12]
@ This code says that using \emph{either} [[r4]] or [[r5]] excludes~[[f10]],
and symmetrically, using [[f10]] excludes \emph{both}
[[r4]]~and~[[r5]].
@
We can use this thing by providing a version of [[useregs]] that uses
shared state to keep track of which registers have been excluded.
Notice that an excluded register is \emph{not} the same as a ``used''
register in a result.
<<automaton.mli>>=
val sharedregs : 
  Exclude.t -> Register.t list -> errormsg:(int -> Register.t list -> string) -> stage
@
\paragraph{Other forms of history}
Most calling conventions keep track of little history beyond knowing
what locations have been used.
The MIPS convention is unusual in that the placement a second
parameter, if of floating-point type, may be placed in one of two
different available locations depending on the type of the first
parameter. 
My solution is to enable an automaton to ``become'' another on the
basis of the first allocation request.
Because these things can be chained, I~believe the solution may be
general.

The first time an allocation reaches this stage, we select the
first alternative satisfying the predicate.
Thereafter \emph{the whole automaton behaves as this alternative}.
If no choice is ever made, the automaton freezes as the first
alternative.
It is a checked run-time error if no predicate is satisfied.
<<automaton.mli>>=
val first_choice : ((hint -> width -> bool) * stage) list -> stage
@ 



QUESTION FOR MARK BAILEY: HAS HE CAREFULLY ANALYZED WHAT CLASS OF
AUTOMATA CAN BE SPECIFIED IN CCL?

@
\section{Implementation}

During a debugging session I reviewed the [[Exclude]] submodule and
believe it is correct. However, I did not review the handling of
[[cellcount]]. --CL

<<automaton.ml>>=
<<exposed types>>
type t = methods

let regstring (s, i, _) = Printf.sprintf "%c%d" s i 

module R  = Rtl
module RS = Register.Set
module RM = Register.Map
module RU = Rtlutil
module B  = Block
module M  = Memalloc
let imposs = Impossible.impossible
@ 
The big idea here is hooking up the end of the pipeline:
<<automaton.ml>>=
let ( *> ) (S f1) (S f2) = S (fun rhs -> f1 (f2 rhs))

let pipeline_end =
  I (fun ~start ->
  let block = Block.at ~base:start ~size:0 ~alignment:1 in
  { allocate = (fun ~width ~alignment ~hint ->
                Impossible.impossible
                  "fell off end of pipeline -- multiple return values from C?")
  ; freeze   =
      (fun regs mems -> 
        { overflow = block; regs_used = regs; mems_used = mems; align_state = 0 })
  })
@
All the work of the implementation is in the closures.
<<automaton.ml>>=
let at ~start (S s) = let I f = s pipeline_end in f ~start
let of_methods t = t
let allocate t ~width ~hint = t.allocate width 1 hint
let freeze t = t.freeze Register.Set.empty []

let fetch loc width      = loc.fetch width
let store loc expr width = loc.store expr width
let of_loc loc           = { fetch = R.fetch loc; store = R.store loc }
@ 
\subsection{Wrapping etc.}

There's substantial bookkeeping in passing the start address around.
We prefer to program in terms of [[methods]] rather than
implementation.
\nwaddbox{wrap        : (methods                   -> methods) -> stage}
\nwaddbox{swrap       : (methods -> ~start:Rtl.exp -> methods) -> stage}
\nwaddbox{wrap_choice : (('a*(methods->methods)) list -> methods -> methods) -> ('a * stage) list -> stage}
<<automaton.ml>>=
let wrap  f = S (fun (I next) -> I (fun ~start -> f (next ~start)))
let swrap f = S (fun (I next) -> I (fun ~start -> f (next ~start) ~start))
let wrap_choice f choices = S (fun (I next) ->
  let apply (I f) = f in
  let downchoice c ~start = fun meths -> apply (c (I (fun ~start -> meths))) ~start in
  I (fun ~start ->
      let choices = List.map (fun (p, (S c)) -> (p, downchoice c ~start)) choices in
      f choices (next ~start)))
@
The overflow block is slightly interesting.
<<automaton.ml>>=
type state = { mutable mem : M.t; mutable frozen : bool }
let overflow ~memsize ~byteorder ~growth ~max_alignment next =
  fun ~start ->
    let mem = M.at start growth in
    let state = { mem = mem; frozen = false } in
    <<functions [[allocate]] and [[freeze]] for the overflow block>>
    { allocate = allocate; freeze = freeze }
let overflow ~memsize ~byteorder ~growth ~max_alignment = 
 swrap (overflow ~memsize ~byteorder ~growth ~max_alignment) 
@ 
To allocate, we align and increment the memory block.
The address of the new location depends on the direction of stack growth.
<<functions [[allocate]] and [[freeze]] for the overflow block>>=
let allocate ~width ~alignment ~hint =
  if width mod memsize <> 0 then
    imposs (Printf.sprintf "width %d not multiple of memsize %d" width memsize);
  if max_alignment mod alignment <> 0 then
    imposs (Printf.sprintf
              "max alignment %d not multiple of alignment %d" max_alignment alignment);
  if state.frozen then
    imposs "Allocation from a frozen overflow block";
  let size = width / memsize in
  let mem  = state.mem in
  let mem  = M.align mem alignment in
  let mem' = M.allocate mem size in
  let addr = M.current (match growth with M.Up -> mem | M.Down -> mem') in
  state.mem <- mem';
  of_loc (R.mem (R.aligned alignment) 'm' byteorder width addr) in
@ 
To freeze, we have to adjust the block alignment if the stack grows down.
<<functions [[allocate]] and [[freeze]] for the overflow block>>=
let freeze regs mems =
  state.frozen <- true;
  let mem    = state.mem in
  let astate = M.num_allocated mem mod max_alignment in
  let mem = match growth with M.Up -> mem | M.Down -> M.align mem (M.alignment mem) in
  let block = M.freeze mem in
  { overflow = block; regs_used = regs; mems_used = mems; align_state = astate } in
@ 
<<automaton.ml>>=
let widths ws ~errormsg next =
  { allocate = (fun ~width ~alignment ~hint ->
                  if List.exists ((=) width) ws then
                    next.allocate width alignment hint
                  else
                    Impossible.impossible (errormsg width))
  ; freeze   = next.freeze
  } 
let widths ws ~errormsg = wrap (widths ws ~errormsg)
@   
Narrowing and widening.
<<automaton.ml>>=
let narrow nopname wopname ~w ~n loc =
  let widen  = R.opr wopname [n; w] in 
  let narrow = R.opr nopname [w; n] in 
  { fetch = (fun n   -> R.app narrow [loc.fetch w])
  ; store = (fun e n -> loc.store (R.app widen [e]) w)
  } 
let narrows = narrow "lobits" "sx"
let narrowu = narrow "lobits" "zx"
let narrowf = narrow "f2f_bogus" "f2f_bogus"
@ 
<<automaton.ml>>=
let narrower = function
  | "signed" -> narrows
  | "float"  -> narrowf
  | "unsigned" | "address" | "" -> narrowu
  | _ -> narrowu

let widen mk_w next = 
  { allocate = (fun ~width:n ~alignment ~hint ->
                  let w   = mk_w n in
                  let loc = next.allocate w alignment hint in
                  if w = n then loc else narrower hint ~n:n ~w loc)
  ; freeze   = next.freeze
  } 
let widen mk_w = wrap (widen mk_w)
<<automaton.ml>>=
let align_to mk_align next = 
  { allocate = (fun ~width:w ~alignment ~hint -> next.allocate w (mk_align w) hint)
  ; freeze   = next.freeze
  } 
let align_to mk_align = wrap (align_to mk_align)
<<automaton.ml>>=
type regstate = { mutable avail : Register.t list; mutable used : Register.Set.t }
let getreg state = match state.avail with
| [] -> raise (Failure "get register")
| r :: rs -> (state.avail <- rs; state.used <- RS.add r state.used; r)

let useregs regs ~errormsg next =
  let state = { avail = regs; used = RS.empty } in
  let alloc ~width ~alignment ~hint =
    try
      let (_, _, w) as r = getreg state in
(*let () = Verbose.say 2 ["useregs automaton got reg "; regstring r; "\n"] in*)
      if w = width then
        of_loc (R.reg r)
      else if w < width then
        Impossible.unimp "register aggregation"
      else
        Impossible.impossible (errormsg width state.avail)
    with Failure _ -> next.allocate width alignment hint in
  let freeze regs mems =
    <<prattle about registers used by [[useregs]]>>;
    next.freeze (RS.union state.used regs) mems in
  { freeze = freeze; allocate = alloc }
let useregs regs ~errormsg = wrap (useregs regs ~errormsg)
<<prattle about registers used by [[useregs]]>>=
let used = List.map regstring (RS.elements state.used) in
Verbose.say 2 ["useregs automaton uses regs: "; String.concat ", " used; "\n"]
@ 
Now I'll try to do it right, with proper aggregation.
Step one is to split locations
<<automaton.ml>>=
<<shift and mask functions>>
let splitloc bo locs = match locs with
| [l, w] -> l
| _ ->
    let rec little = function
      | []  -> Impossible.impossible "split empty list of locations"
      | [l, w] -> l
      | (loc, w) :: rest ->
          let loc' = little rest in
          let w'   = List.fold_left (fun n (_, w) -> n + w) 0 rest in
          { fetch = (fun ww ->
                       assert (ww = w + w');
                       orb ww (zx w ww (fetch loc w))
                              (shl ww (zx w' ww (fetch loc' w')) w))
          ; store = (fun v ww ->
                       assert (ww = w + w');
                       R.par [ store loc  (lobits ww  w v) w 
                             ; store loc' (lobits ww w' (shrl ww v w)) w'])
          } in
    match bo with
    | Rtl.LittleEndian -> little locs
    | Rtl.BigEndian    -> little (List.rev locs)
    | Rtl.Identity     -> Impossible.impossible "split without order"
<<shift and mask functions>>=
let const w k = R.bits (Bits.U.of_int k w) w
let zx n w v = R.app (R.opr "zx" [n; w]) [v]
let orb w x y = R.app (R.opr "or"  [w]) [x; y]
let shl  w x k = R.app (R.opr "shl"  [w]) [x; const w k]
let shrl w x k = R.app (R.opr "shrl" [w]) [x; const w k]
let lobits w n x = R.app (R.opr "lobits" [w; n]) [x]
@ 
<<automaton.ml>>=
let useregs' regs ~errormsg next =
  let state = { avail = regs; used = RS.empty } in
  let can_aggregate _ _ = false in (* not implemented yet *)
  let aggregate _ _ = Impossible.unimp "register aggregation" in
  let alloc ~width ~alignment ~hint =
    let regloc ((_, _, w) as r) = of_loc (R.reg r), w in
    let rec locs prev' w =
      if w = 0 then
        List.rev (List.map regloc prev')
      else if w > 0 then
        try
          let (_, _, w') as r = getreg state in
          let regs = 
            match prev' with
            | r' :: rs when can_aggregate r' r -> aggregate r' r :: rs
            | _ -> r :: prev' in
          locs regs (w - w')
        with Failure _ ->
          List.rev ((next.allocate w alignment hint, w) :: List.map regloc prev') 
      else 
        Impossible.impossible
          (errormsg width state.avail ^ 
           " (request should have been widened upstream of useregs?)") in
    splitloc Rtl.Identity (locs [] width) in
  let freeze regs mems =
    <<prattle about registers used by [[useregs]]>>;
    next.freeze (RS.union state.used regs) mems in
  { freeze = freeze; allocate = alloc }
let useregs' regs ~errormsg = wrap (useregs' regs ~errormsg)
@ 

@ 
The dataflow here is kind of interesting.  
For the [[allocate]] method, we have a fan-out and fan-in, with a fork
and join point, so it passes through exactly \emph{one} choice.
But for the [[freeze]] method, we thread the call straight through the
whole list, so it passes through \emph{all} choices.
<<automaton.ml>>=
let choice choices next =
    let add (p, stage) alternative =
      let follows_choice = { allocate = next.allocate; freeze = alternative.freeze } in
      let choice = stage follows_choice in
      let alloc ~width ~alignment ~hint =
        let alloc = if p hint width then choice.allocate else alternative.allocate in
        alloc width alignment hint in
      { allocate = alloc; freeze = choice.freeze } in
    List.fold_right add choices
      { allocate = (fun ~width -> Impossible.impossible "missing hint choice")
      ; freeze = next.freeze }
let hint_choice choices =
  choice (List.map (fun (hp, s) -> ((fun h w -> hp h), s)) choices)
let hint_choice = wrap_choice hint_choice
let choice      = wrap_choice choice

let is_hint  h' h w = h = h'
let is_width w' h w = w = w'
let is_any      h w = true
@ 
\paragraph{Register assignment by offset}
<<automaton.ml>>=
let somecounter of_width n next =
  { freeze = next.freeze
  ; allocate =
      (fun ~width ~alignment ~hint ->
         (n := !n + of_width width; next.allocate ~width ~alignment ~hint))
  } 
let bitcounter n = wrap (somecounter (fun w -> w) n)
let argcounter n = wrap (somecounter (fun w -> 1) n)
<<automaton.ml>>=
let rec drop_regs w regs =
  if w <= 0 then
    regs
  else
    match regs with
    | (s, n, w') :: rest -> drop_regs (w - w') rest
    | []                 -> []

let offsetregs n regs next =
  let state = { avail = regs; used = RS.empty } in
  let alloc ~width ~alignment ~hint =
    let offset = !n - width in
    state.avail <- drop_regs offset regs;
    try
      let (_, _, w) as r = getreg state in
      if w = width then
        of_loc (R.reg r)
      else if w < width then
        Impossible.unimp "register aggregation"
      else
        Impossible.unimp "auto-widening for register requests"
    with Failure _ -> next.allocate width alignment hint in
  let freeze regs mems =
    <<prattle about registers used by [[offsetregs]]>>;
    next.freeze (RS.union state.used regs) mems in
  { freeze = freeze; allocate = alloc }
let offsetregs n regs = wrap (offsetregs n regs)
<<prattle about registers used by [[offsetregs]]>>=
let used = List.map regstring (RS.elements state.used) in
Verbose.say 2 ["offsetregs automaton uses regs: "; String.concat ", " used; "\n"]
@ 
\paragraph{Register assignment by argument count}
<<automaton.ml>>=
let argnoregs n regs next =
  let state = { avail = regs; used = RS.empty } in
  let alloc ~width ~alignment ~hint =
    let argno = !n - 1 in
    let rec list_drop n l =
      if n = 0 then
        l
      else
        match l with [] -> [] | h :: t -> list_drop (n-1) t in
    state.avail <- list_drop argno regs;
    try
      let (_, _, w) as r = getreg state in
      if w = width then
        of_loc (R.reg r)
      else if w < width then
        Impossible.unimp "register aggregation"
      else
        narrowf w width (of_loc (R.reg r))
    with Failure _ -> next.allocate width alignment hint in
  let freeze regs mems =
    <<prattle about registers used by [[argnoregs]]>>;
    next.freeze (RS.union state.used regs) mems in
  { freeze = freeze; allocate = alloc }
let argnoregs n regs = wrap (argnoregs n regs)
<<prattle about registers used by [[argnoregs]]>>=
let used = List.map regstring (RS.elements state.used) in
Verbose.say 2 ["argnoregs automaton uses regs: "; String.concat ", " used; "\n"]
@ 
\paragraph{Using an automaton as a stage}

To us an automaton as a stage, we pass on an allocation request but
ignore a freeze request.
<<automaton.ml>>=
let as_stage inner next = 
  fun ~start ->
    let freeze regs mems =
      { regs_used = regs; mems_used = mems;
        overflow = Block.at start 0 0; align_state = 0; } in
    { allocate = inner.allocate; freeze = freeze }
let as_stage inner = swrap (as_stage inner)
@
\paragraph{Exclusion}
<<automaton.ml>>=
module Exclude = struct
  type pair = Register.t list * Register.t list
  type t = { mutable excluded : RS.t
           ;         excludes : RS.t RM.t
           ;         cellcount: Register.t -> int
           }
  <<exclusion functions>>
end
@ 
I'm still feeling my way with register aggregates, but I hope I can
store and test all components.
<<exclusion functions>>=
let reg_components limit (s, i, w) =
  assert (limit > 1);
  let w = w / limit in
  let rec from n =
    if n = limit then []
    else (s, i+n, w) :: from (n+1) in
  from 0
@ 
If we use something, we use everything it excludes, we use it, and we
use all its components.
<<exclusion functions>>=
let map_union map key set = try RS.union set (RM.find key map) with Not_found -> set

let use' t r = (* old, not used *)
  let excluded = map_union t.excludes r t.excluded in
  let excluded = RS.add r excluded in
  let excluded = match t.cellcount r with
  | 1 -> excluded
  | n -> List.fold_right RS.add (reg_components n r) excluded in
  t.excluded <- excluded
@ 

For [[use]] and [[exclude]] we take a fine-grained approach: compound
registers (like pairs) are always broken up and the individual registers
are marked as excluded. This does not interfere with the set of used
registers [[frozen]] reports, because the exclusion state is completely
private to [[Exclude]]. Caveat: currently the user can still specify
compounds for the [[excludes]] data structure. Im unsure whether
this is a good idea or not.

Within [[use]], the [[exclude]] function computes the set of all
registers excluded by a given register. If we use a compound register,
we mark its components as used, but not itself. Otherwise the
[[available]] function cannot tell that that a component was already in
use. 

<<exclusion functions>>=
let use t r =
    let rec exclude r = match t.cellcount r with
        | 1 -> map_union t.excludes r (RS.singleton r) 
        | n -> List.fold_right (fun r ex -> RS.union (exclude r) ex)
                               (reg_components n r)
                               RS.empty 
    in
       t.excluded <- RS.union t.excluded (exclude r)
@       

Something is available if it is not excluded and if none of its
components are excluded. Watch out: [[t.excluded]] may contain register
pairs because [[t.excludes]] may contain them! See the discussion above.

<<exclusion functions>>=
let rec available t r = match t.cellcount r with
    | 1 -> not (RS.mem r t.excluded)    
    | n -> List.for_all (available t) (reg_components n r)
@ 

To make the exclusion relation more useful, I could imagine to make it
a directed relation, i.e.~asymmetric. This is implemented in
[[of_diretced_pairs]].

<<exclusion functions>>=
let of_pairs spaces exclusions =
  let regset l = List.fold_right RS.add l RS.empty in
  let find map r = try RM.find map r with Not_found -> RS.empty in
  let addx rset r map = RM.add r (map_union map r rset) map in
  let add (rs, rs') map =
    let map = List.fold_right (addx (regset rs')) rs  map in
    let map = List.fold_right (addx (regset rs )) rs' map in
    map in
  let excludes = List.fold_right add exclusions RM.empty in
  let cellcount (s, _, w) = w / (spaces s).Space.cellwidth in
  { excluded = RS.empty; excludes = excludes; cellcount = cellcount }

let of_directed_pairs spaces exclusions =
  let regset l = List.fold_right RS.add l RS.empty in
  let find map r = try RM.find map r with Not_found -> RS.empty in
  let addx rset r map = RM.add r (map_union map r rset) map in
  let add (rs, rs') map =
    let map = List.fold_right (addx (regset rs')) rs  map in
    map in
  let excludes = List.fold_right add exclusions RM.empty in
  let cellcount (s, _, w) = w / (spaces s).Space.cellwidth in
  { excluded = RS.empty; excludes = excludes; cellcount = cellcount }
@ 
<<automaton.ml>>=
let first_choice choices next =
  let choices = List.map (fun (p, c) -> (p, c next)) choices in
  let myself = ref next in (* temporary *)
  let allocate ~width ~alignment ~hint = (!myself).allocate width alignment hint in
  let freeze regs mems = (!myself).freeze regs mems in
  let first_allocate ~width ~alignment ~hint =
    let choice =
      try snd (List.find (fun (p, _) -> p hint width) choices)
      with Not_found -> Impossible.impossible "missing choice" in
    myself := choice;
    allocate width alignment hint in
  let () = try
    myself := { allocate = first_allocate; freeze = (snd (List.hd choices)).freeze }
  with Failure _ -> Impossible.impossible "no first choice" in
  { allocate = allocate; freeze = freeze }
let first_choice = wrap_choice first_choice
@ 

The global [[getreg]] marks a register as used. We don't want this in
case it is just excluded but not used. Otherwise excluded, but unused
registers, would be reported in the result, which is used for liveness
analysis.  Therefore, we implement [[getreg]] and [[usereg]] locally:
[[getreg]] returns the next register; only if it is not excluded, we
mark it as used. 

<<automaton.ml>>=
let sharedregs ex regs ~errormsg next =
    let getreg state = match state.avail with
    | [] -> raise (Failure "get register")
    | r :: rs -> (state.avail <- rs; r) in
    let usereg state r = state.used <- RS.add r state.used in
    
  let state = { avail = regs; used = RS.empty } in
  let rec alloc ~width ~alignment ~hint =
    try
      let (_, _, w) as r = getreg state in
      if Exclude.available ex r then
        if w = width then
          begin
            usereg state r;
            Exclude.use ex r;
            of_loc (R.reg r)
          end
        else if w < width then
          Impossible.unimp "register aggregation"
        else
          Impossible.impossible (errormsg width state.avail)
      else
        alloc ~width ~alignment ~hint
    with Failure _ -> next.allocate width alignment hint in
  let freeze regs mems = next.freeze (RS.union state.used regs) mems in
  { freeze = freeze; allocate = alloc }
let sharedregs ex regs ~errormsg = wrap (sharedregs ex regs ~errormsg)
@ 
\subsection{Compatibility}
<<old compatibility interface as part of automaton.ml>>=
let of_old l = { fetch = (fun w -> Automaton2.fetch l w)
               ; store = (fun e w -> Automaton2.store l e w) }
class loc' l =
  object
    method store = store l
    method fetch = fetch l
  end

let to_old l = new loc' l
@ 
\paragraph{UNIT STUFF --- FIX ME}
<<automaton.mli>>=
val unit : stage
<<automaton.ml>>=
let unit = wrap (fun next -> next)
@ 
<<automaton.ml>>=
let postprocess (S stage) f = S (fun imp ->
  let I i = stage imp in
  I (fun ~start ->
      let m = i start in
      { allocate = m.allocate
      ; freeze = (fun rs ms -> f (m.freeze rs ms))
      } ))

