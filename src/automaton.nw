
\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Automaton for Calling Conventions}
% ------------------------------------------------------------------ 

Each target platform requires an implementation of its procedure
calling convention:  which arguments goes into registers and which are
passed on the stack.  Calling convetions also exists for returning
values and passing them to a continuation.  Mark W.~Bailey and Jack
W.~Davidson have shown in \cite{bailey:davidson:95} that the process of
choosing registers to pass values can be modeled with finite state
automata.  The automaton receives a stream of enriched {\PAL} types
and the automaton responds for each data type with a location that the
parameter is passed in.

% ------------------------------------------------------------------ 
\subsection{Interface to Automaton}
% ------------------------------------------------------------------ 

Calling conventions in the {\qcc} compiler are at least in prinicple
constructed at run-time of the compiler.  An interface thus must
provide methods to construct automata to represent calling
conventions, and means to use them.  For the moment however, we like
to hard-code some calling conventions in order to gain experience for
the design of an interface to construct automata at run-time. For the
time being, this interface only defines how an automaton is run but
not, how it is defined.


<<automaton.mli>>=
<<basic types>>
module Run   : sig <<signature run>>   end
module Build : sig <<signature build>> end
@

% ------------------------------------------------------------------ 
\subsubsection{Basic Types}
% ------------------------------------------------------------------ 

Pure {\PAL} data types like [[bits32]] are usually not descriptive
enough to find the location a parameter of that value is passed in. 
Calling conventions usually not rely on the size of a
parameter, but also to some degree on its purpose.  A type from the
perspective of calling conventions is thus a tuple of a {\PAL} type
and a hint. 

<<basic types>>= 
type ty = Types.ty * string option
@

An automaton is used at a caller's side to find the locations values
to be passed are stored in, and at the callee's side to find the
location incoming parameters are read from.  The same situation arises
at a [[return]] and when [[cut]]'ing to a continuation.  A
[[location]] thus includes two values:  a function that returns an
effect of storing a value to a location, and an expression that
fetches a value from that location.

<<>>=
type location = (Rtl.expr -> Rtl.effect)          (* write value *)
              * Rtl.expr                          (* read  parameter *)
@

Of course, there is the automaton itself.  An automaton maintains an
internal state that changes when the automaton is run. 

<<>>=
type t
@

% ------------------------------------------------------------------ 
\subsubsection{Running an Automaton}
% ------------------------------------------------------------------ 

This sub-module defines everything an automaton's client needs to
know.  Especially all details about a calling convention is left
abstract.

Running an automaton means to ask for the [[location]] of a [[ty]]. 
This advances an automaton to its [[next]] state.  The answers to the
question includes the desired [[location]] and the automaton in its
new (internal) state.  When the automaton lacks a transition from its
current state for the requested type, the [[Error.ErrorExn]] exception
is raised.

<<signature run>>=
val next: t -> ty -> location * t (* Error.ErrorExn *)
@

The code generator not only needs to know where parameters are stored,
but also the overall size of the area (overflow) parameters are stored
in and its alignment.  This information is captured by the
[[overflow]] type and function.  The memory requirements for
overflowing parameters are determined by the \emph{state} of an
automaton and thus can be obtained from it.  In contrast, the
[[location]] for a parameter is determined by the \emph{transition}
between two states and thus it is returned by the [[next]] function.

<<>>=
type overflow   = { size:   int   (* overflow area in memsize units *)
                  ; align:  int   (* alignment in memsize units     *)
                  }
val overflow: t -> overflow
@

% ------------------------------------------------------------------ 
\subsubsection{Building an Automaton}
% ------------------------------------------------------------------ 

An interface to build an automaton systematically is postponed. We
provide some hard-coded automata here.

<<signature build>>=
val cc:         t           (* calling convention *)
val globals:    t           (* global register placement *)
@

% ------------------------------------------------------------------ 
\subsection{Dummy Implementation}
% ------------------------------------------------------------------ 

The following implementation can only represent very simple calling
conventions that place every parameter into some memory location.  The
implementation does not model a finite automaton, but only counter
that keeps track of the memorory consumed for passing parameters. The
implementation depends on the target's size of pointers and words and
thus is by far too specific.

<<automaton.ml>>=
type ty         =  Types.ty * string option
type location   =  (Rtl.expr -> Rtl.effect)
                    * Rtl.expr

let memsize     = 8  (* assumption for now, must be obtained from Fenv *)
let pointer     = 32 (* ditto for pointer size *)
let word        = 32
let agg         = Rtl.BigEndian

<<type t>>

module Run = struct
    module T = Types
    <<module run>>
end

module Build = struct
    <<module build>>
end 
@

An ``automaton'' [[t]] is a counter [[offset]] and two funtions [[read]]
and [[write]]: 

<<type t>>=
type t        =     { offset:       int
                    ; read:         (int -> int -> Rtl.expr)
                    ; write:        (int -> int -> Rtl.expr -> Rtl.effect)
                    }
@

The functions [[read]] and [[write]] provide access to values stored
at some [[offset]] from a location only known to them.

\begin{itemize}
    \item [[read k w]] returns a [[w]] memsize value from offset [[k]].
    \item [[write k w]] returns a function, that writes a [[w]] memsize
          value to offset [[k]].
\end{itemize}

The two functions are sufficient to implement the [[next]] function,
that returns a [[location]] for a [[ty]]:  the parameter is placed at
the point the current offset points to and the offset is incremented
by the size of the type.
               
<<module run>>=
let next dfa (ty,hint) =
    let width = match ty with
        | T.Bits(n) when n mod memsize = 0 -> n 
        | _                                -> assert false in
    let words = width / memsize in
    let loc   = (dfa.write dfa.offset words, dfa.read dfa.offset words) in
    let dfa   = { dfa with offset = dfa.offset + words } in
        (loc, dfa)
@

The [[overflow]] function returns the amount of consumed memory. Since we
don't care about alignment of the [[offset]], we always have an alignment
of one. 

<<module run>>=
type overflow =     { size:  int
                    ; align: int
                    }

<<>>=
let overflow dfa = { size  = dfa.offset
                   ; align = 1
                   }
@

% ------------------------------------------------------------------ 
\subsection{Dummy Automata}
% ------------------------------------------------------------------ 

<<module build>>=
let offset k        = Rtl.Const(Rtl.Bits(Bits.of_int k word,word)) 
let add             = ("add",[word])                          
let sum x y         = Rtl.App (add,[x;y])                       

let regsp = Rtl.Cell( 'm'
                    , agg
                    , pointer
                    , Rtl.Const(Rtl.Link("sp ",pointer))
                    , -1
                    )

let globs = Rtl.Cell( 'm'
                    , agg
                    , pointer
                    , Rtl.Const(Rtl.Link("globals ",pointer))
                    , -1
                    )
                        
let sp loc          = Rtl.Fetch(loc,word)
let stack loc k w   = Rtl.Cell('m',agg,w,sum (sp loc) (offset k),-1)    
let read  loc k w   = Rtl.Fetch(stack loc k w, w)                 
let write loc k w   = fun e -> Rtl.Store(stack loc k w, e, w)    
@

The following automaton places parameters relative to some register
[[reg0]]. 

<<>>=
let cc = 
    { offset = 0
    ; read   = read  regsp
    ; write  = write regsp
    }
@

Here is an automaton that places global registers relative to some
link-time constanat named ``globals ''.

<<>>=
let globals = 
    { offset = 0
    ; read   = read  globs
    ; write  = write globs
    }    
