
\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Automaton for Calling Conventions}
% ------------------------------------------------------------------ 

Each target platform requires an implementation of its procedure
calling convention:  which arguments goes into registers and which are
passed on the stack.  Calling convetions also exists for returning
values and passing them to a continuation.  Mark W.~Bailey and Jack
W.~Davidson have shown in \cite{bailey:davidson:95} that the process of
choosing registers to pass values can be modeled with finite state
automata.  The automaton receives a stream of enriched {\PAL} types
and the automaton responds for each data type with a location that the
parameter is passed in.

% ------------------------------------------------------------------ 
\subsection{Interface to Automaton}
% ------------------------------------------------------------------ 

The interface for the calling convention automata serves two purposes: 
construction of automata and using them.  To keep {\qcc} as flexible
as possible, automata for calling conventions are at least in
principle constructed at run-time (of the compiler) and not
hard-wired.  Once an automaton is defined, it is used by the code
generator to find the locations parameters are passed to or from
procedures and continuations.  Building and running an automaton is
delegated to submodules.

<<automaton.mli>>=
<<basic types>>
module Run   : sig <<signature run>>   end
module Build : sig <<signature build>> end
@

% ------------------------------------------------------------------ 
\subsubsection{Basic Types}
% ------------------------------------------------------------------ 

Pure {\PAL} data types like [[bits32]] are usually not descriptive
enough to find the location a parameter of that value is passed in. 
Calling conventions usually not rely on the size of a
parameter, but also to some degree on its purpose.  A type from the
perspective of calling conventions is thus a tuple of a {\PAL} type
and a hint. 

<<basic types>>= 
type ty = Types.ty * string option
@

An automaton is used at a caller's side to find the locations values
to be passed are stored in, and at the callee's side to find the
location incoming parameters are read from.  The same situation arises
at a [[return]] and when [[cut]]'ing to a continuation.  A
[[location]] thus includes two values:  a function that returns an
effect of storing a value to a location, and an expression that
fetches a value from that location.

<<>>=
type location = (Rtl.expr -> Rtl.effect)          (* write value *)
              * Rtl.expr                          (* read  parameter *)
@

Of course, there is the automaton itself.  An automaton maintains an
internal state that changes when the automaton is run. 

<<>>=
type t
@

% ------------------------------------------------------------------ 
\subsubsection{Running an Automaton}
% ------------------------------------------------------------------ 

This sub-module defines everything an automaton's client needs to
know.  Especially all details about a calling convention is left
abstract.

Running an automaton means to ask for the [[location]] of a [[ty]]. 
This advances an automaton to its [[next]] state.  The answers to the
question includes the desired [[location]] and the automaton in its
new (internal) state.  When the automaton lacks a transition from its
current state for the requested type, the [[Error.ErrorExn]] exception
is raised.

<<signature run>>=
val next: t -> ty -> location * t (* Error.ErrorExn *)
@

The code generator not only needs to know where parameters are stored,
but also the overall size of the area (overflow) parameters are stored
in and its alignment.  This information is captured by the
[[overflow]] type and function.  The memory requirements for
overflowing parameters are determined by the \emph{state} of an
automaton and thus can be obtained from it.  In contrast, the
[[location]] for a parameter is determined by the \emph{transition}
between two states and thus it is returned by the [[next]] function.

<<>>=
type overflow   = { size:   int   (* overflow area in memsize units *)
                  ; align:  int   (* alignment in memsize units     *)
                  }
val overflow: t -> overflow
@

% ------------------------------------------------------------------ 
\subsubsection{Building an Automaton}
% ------------------------------------------------------------------ 

An interface to build an automaton systematically is postponed.

<<signature build>>=
(* empty *)
@

% ------------------------------------------------------------------ 
\subsection{Dummy Implementation}
% ------------------------------------------------------------------ 

<<automaton.ml>>=
type ty       =     Types.ty * string option
type location =     (Rtl.expr -> Rtl.effect)
                    * Rtl.expr

type t        =     { offset:       int
                    }

module Run = struct
    module T = Types
    <<module run>>
end

module Build = struct (* empty *) end

<<module run>>=
type overflow =     { size:  int
                    ; align: int
                    }

let memsize     = 8  (* assumption for now, must be obtained from Fenv *)
let pointer     = 32 (* ditto for pointer size *)
let word        = 32
let agg         = Rtl.BigEndian


(* inventing names on the rtl level, like "sp" is problematic; may clash
   with C-- variables *) 
<<>>=
let sp          = Rtl.Const(Rtl.Link("sp",pointer))       
let offset k    = Rtl.Const(Rtl.Bits(Bits.of_int k word,word)) 
let add         = ("add",[word])                          
let sum x y     = Rtl.App (add,[x;y])                       
let stack k w   = Rtl.Cell('m',agg,w,sum sp (offset k),-1)    
let read  k w   = Rtl.Fetch(stack k w, w)                 
let write k w   = fun e -> Rtl.Store(stack k w, e, w)    

<<>>=
let next dfa (ty,hint) =
    let width = match ty with
        | T.Bits(n) when n mod memsize = 0 -> n 
        | _                                -> assert false in
    let words = width / memsize in
    let loc   = (write dfa.offset words, read dfa.offset words) in
    let dfa'  = { dfa with offset = dfa.offset + words } in
        (loc, dfa')

<<>>=
let overflow dfa = { size  = dfa.offset
                   ; align = 1
                   }
@

