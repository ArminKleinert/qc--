% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Register Transfer Lists (\rtl)}
% ------------------------------------------------------------------ 

Register transfer lists capture the meaning of storing values into
memory or register locations.  They are used as part of the abstract
representation of {\PAL}.  The meaning of a register transfer list is
well defined and especially independent from any properties of a
target architecture because no hidden assumptions exist.  This
implementation uses {\asdl} to define the syntax of {\rtl}s.  For some
types defined here view are defined in module \module{views}.

<<rtl.asdl>>=
module rtl {
    <<module rtl>>
}
@

A [[space]] describes some kind of memory, like a set of registers or
main memory.  The number of [[spaces]] is a property of a target
architecture and thus can not be fixed here with a sum type.  The
[[char]] type provides a big enough cardinality and is nice to print
and remember.
 
[[register]] represents a named {\PAL} register and [[width]] a number
of bits which corresponds to the {\PAL} [[bits]]$k$ types.
  
<<module rtl>>=
space       = (int)    -- mapped to char using views
width       = (int)
@

<<rtl.view>>=
rtl.space <= {
    natural_type:   char
    wrapper:        Char.chr    (* int -> char *)
    unwrapper:      Char.code   (* char -> int *)
}
@

We want to represent assertions for specific properties but have not
yet found a representation. Since {\asdl} provides no abstract type we
abuse [[int]].

<<module rtl>>=
assertion   = (int)    -- stands for an abstract type
@

An operator for values at run-time is represented by its name and a
list of [[width]]s.  Each [[width]] corresponds to a $\forall$-bound
variable in the type scheme of the operator's type.  From the type
scheme and the [[width list]] a monomorphic type of the operator can
be deduced.

<<>>=
op          = (string, width*)
@

Expressions provide values to be stored in [[locations]] as well as
addresses local to a [[space]].  An expression can access constant
values and values fetched from memory.  A fetch from memory makes the
[[width]] number of fetched bits explicit.  A label denotes a {\PAL}
data- or goto-label and its type. 

<<>>=
bits        = (int,width)       -- view for Bits.bits
boolean     = (int)             -- view for bool
@

<<rtl.view>>=
rtl.bits <= {
    natural_type:   Bits.bits
    wrapper:        to_bits 
    unwrapper:      of_bits
}
rtl.boolean <= {
    natural_type:   bool
    wrapper:        to_bool
    unwrapper:      of_bool 
}    

module rtl <= implementation_prologue
%%
let of_bits b     = (Bits.to_int b, Bits.width b)
let to_bits (n,w) = Bits.of_int n w

let to_bool i     = i <> 0
let of_bool       = function true -> 1 | false -> 0
%%
@

<<module rtl>>=
const       = Bool      (boolean)
            | Bits      (bits, width)
            | Link      (string, width)         -- link time constant

expr        = Const     (const)               
            | Fetch     (location,width) 
            | App       (op, expr*)
@

A location describes a memory location or register on the target
architecture or a {\PAL} register. The code generation will remove all
{\PAL} registers and provide memory locations for them. A memory
[[cell]] lives in an address [[space]] at the address denoted by
[[expr]]. In order to fetch [[width]] bits at once several memory
units from the chosen [[space]] must be aggregated. For example, a 32
bit fetch must aggregate 4 8-bit values when the memory space is made
by 8-bit bytes. The aggregation is described by a value of the type
[[aggregation]]. 

<<>>=
location    = Cell      (space, aggregation, width, expr, assertion)
            | Var       ( string    name    -- name from C-- source
                        , int       index   -- for run-time API
                        , width
                        )
<<>>=
aggregation = BigEndian
            | LittleEndian
            | Identity
@

An [[effect]] is describes an assignment of a [[width]] bits value obtained
from an expression [[expr]], or a [[Kill]]. A killed location contains an
undefined value.

<<>>=
effect      = Store     (location, expr, width)
            | Kill      (location)
@

A guarded effect is pair of an expression and an effect. The effect takes
place, if and only if the expression evaluates to [[true]].      

<<>>=
guarded     = (expr,effect)
@

And finally, a \emph{register transfer list} is a list of guarded
effects. When a {\rtl} is evaluated, first all guarding expressions
are evaluated and then all effects of the guards that evaluated to
true become effective simultaneously.

<<>>=
rtl         = Rtl       (guarded*)
@
