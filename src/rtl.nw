% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Register Transfer Lists (\rtl)}
% ------------------------------------------------------------------ 

Register transfer lists capture the meaning of storing values into
memory or register locations.  They are used as part of the abstract
representation of {\PAL}.  The meaning of a register transfer list is
well defined and especially independent from any properties of a
target architecture because no hidden assumptions exist.  


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface is divided into two parts:  \emph{public} and
\emph{private}.  The public part provides constructor functions to
build {\rtl}s but hides their actual implementation.  The private part
reveals these and is intended only for parts of the back end that does
re-writing of {\rtl}s.  The private part includes function that
converts a public values into private values and thus makes their
details accessible.  Both parts make use of some common types which
are factored out.

<<rtl.mli>>=
<<COMMON>>

module Private: sig
    <<PRIVATE types>>
    <<PRIVATE values>>
end

<<PUBLIC>>
@

% ------------------------------------------------------------------ 
\subsubsection{The Private View}
% ------------------------------------------------------------------ 

The private view defines {\rtl}s in terms of data structures which are
defined here.  In addition, the common data types are also defined in
this section although they are not strictly private.

A [[space]] describes some kind of memory, like a set of registers or
main memory.  The number of [[spaces]] is a property of a target
architecture and thus can not be fixed here with a sum type.  The
[[char]] type provides a big enough cardinality and is nice to print
and remember.  A [[width]] is a number of bits which corresponds to
the {\PAL} [[bits]]$k$ types.
  
<<COMMON>>=
type space       = char         (* 'm'=memory, 'r'=register, 't'=temp,..*)
type width       = int          (* bits *)
@

We want to represent assertions for specific properties but have not
yet found a representation. Todo: replace all $-1$ values in the code
with [[Rtl.none]]. 

<<PRIVATE types>>=
type assertion   = int

<<PRIVATE values>>=
val  none:         assertion
@

An operator for values at run-time is represented by its name and a
list of [[width]]s.  Each [[width]] corresponds to a $\forall$-bound
variable in the type scheme of the operator's type.  From the type
scheme and the [[width list]] a monomorphic type of the operator can
be deduced.

<<COMMON>>=
type op          = string * width list
@

Expressions provide values to be stored in [[locations]] as well as
addresses local to a [[space]].  An expression can access constant
values and values fetched from memory.  A fetch from memory makes the
[[width]] number of fetched bits explicit.  A label denotes a {\PAL}
data- or goto-label and its type. 

<<PRIVATE types>>=
type const      = Bool      of bool
                | Bits      of Bits.bits * width
                | Link      of string * width         (* link time constant *)

type expr       = Const     of const               
                | Fetch     of location * width 
                | App       of op * expr list
@

A location describes a memory location or register on the target
architecture or a {\PAL} register. The code generation will remove all
{\PAL} registers and provide memory locations for them. A memory
[[cell]] lives in an address [[space]] at the address denoted by
[[expr]]. In order to fetch [[width]] bits at once several memory
units from the chosen [[space]] must be aggregated. For example, a 32
bit fetch must aggregate 4 8-bit values when the memory space is made
by 8-bit bytes. The aggregation is described by a value of the type
[[aggregation]]. 

<<PRIVATE types>>=
and  location  = Cell       of space 
                            *  aggregation
                            *  width
                            *  expr
                            *  assertion
                        
                | Var       of string    (* name from C-- source   *)
                            *  int       (* index for run-time API *)
                            *  width
<<COMMON>>=
type  aggregation           = BigEndian
                            | LittleEndian
                            | Identity
@

An [[effect]] is describes an assignment of a [[width]] bits value obtained
from an expression [[expr]], or a [[Kill]]. A killed location contains an
undefined value.

<<PRIVATE types>>=
type effect     = Store     of location * expr * width
                | Kill      of location
@

A guarded effect is pair of an expression and an effect. The effect takes
place, if and only if the expression evaluates to [[true]].      

<<PRIVATE types>>=
type guarded    = expr * effect
@

And finally, a \emph{register transfer list} is a list of guarded
effects. When a {\rtl} is evaluated, first all guarding expressions
are evaluated and then all effects of the guards that evaluated to
true become effective simultaneously.

<<PRIVATE types>>=
type rtl        = Rtl of guarded list
@


<<PRIVATE values>>=
val width:      expr -> int     (* width of expression *)
val assign:     location -> expr -> rtl
@

% ------------------------------------------------------------------ 
\subsubsection{Public View}
% ------------------------------------------------------------------ 

The public view provides constructor functions for {\rtl}s.  Using
them should be the \emph{only} way to create {\rtl}s when translating
from the abstract syntax tree.

Constants [[const]] are part of expressions.  A constant can be a
boolean value, a number of bits, or a link-time value, which has a
name.

<<PUBLIC>>=
type const
type expr
type location
type effect
type rtl

val truth     : const
val falsehood : const
val bits      : Bits.bits -> width -> const
val linkconst : string -> width -> const
@

An expression [[expr]] is either a constant, an expression fetched from a
location, or an application of value to an operand [[op]].

<<PUBLIC>>=
val const     : const -> expr
val fetch     : location -> width -> expr
val app       : op -> expr list -> expr
@

A [[location]] is either a \emph{cell} that belongs to some [[space]],
where it has an address [[expr]], or it represents a named {\PAL}
variable.

<<PUBLIC>>=
val cloc      : space -> aggregation -> width -> expr -> location
val vloc      : string -> int -> width -> location
@

An [[effect]] alters a [[location]]:  a [[store]] puts the value of
[[expr]] into a location, a [[kill]] invalidates a location's content.

<<PUBLIC>>=
val store     : location -> expr -> width -> effect
val kill      : location -> effect
@

A register transfer list {\rtl} is a list of guarded effects. The
guard [[expr]] must be a boolean expression. 

<<>>=
val guarded   : expr -> effect -> expr * effect
val rtl       : (expr * effect) list -> rtl
@

Code that builds or manipulates {\rtl}s tends to use the same
functionality over and over again. We try to define some useful values
here.

The [[width]] of an expression is only defined for value-expressions,
but not for conditions.  Applying [[width]] to a condition will result
in an assertion failure.

<<>>=
val width:      expr -> int     (* width of expression *)
val assign:     location -> expr -> rtl
@

The purpose of the private interface is to exploit the implementation
details by pattern matching, for example. Values created by the public
interface per se are not compatible with the private types. Conversion
functions provide access to these values. Each function is named after
the type it converts.

It is not possible to make the conversion functions part of
[[Private]] without putting the public interface at the same time into
a sub-module like [[Public]]:  there is no way to refer to a type
outside of [[Private]] from inside [[Private]] that is also declared
inside [[Private]]. 

<<PUBLIC>>=
val conv_const:      const    -> Private.const
val conv_expr:       expr     -> Private.expr
val conv_location:   location -> Private.location
val conv_effect:     effect   -> Private.effect
val conv_rtl:        rtl      -> Private.rtl
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The interface of [[Private]] defines only data types; we re-use the
definitions to obtain the implementation.  The same is true for common
data types. 

<<rtl.ml>>=
<<COMMON>>
module Private = struct
    <<Private>>
end

<<Public>>
@
% ------------------------------------------------------------------ 
\subsubsection{The Private View}
% ------------------------------------------------------------------ 

The implementation of the private view must repeat the type
definitions from the interface. 

<<Private>>=
<<PRIVATE types>>
@

The empty assertion is provided as a value [[none]].

<<>>=
let none: assertion = (-1)     
@

Below are simple, nonetheless frequently used functions values on
{\rtl}s.

<<>>=
let width = function
    | Const(Bool _)     -> assert false
    | Const(Bits (_,w)) -> w
    | Const(Link (_,w)) -> w
    | Fetch(_,w)        -> w
    | App _             -> assert false (* not implemented *)
    
let assign l r = Rtl [(Const(Bool true), Store(l, r, width r))]
@


% ------------------------------------------------------------------ 
\subsubsection{The Public View}
% ------------------------------------------------------------------ 

The implementation of the public view basically uses the [[Private]]
definitions such that they become compatible.  However, this fact is
hidden by the interface.

<<Public>>=
type const    = Private.const
type expr     = Private.expr
type location = Private.location
type effect   = Private.effect
type rtl      = Private.rtl
@


<<Public>>=
let truth                   = Private.Bool true
let falsehood               = Private.Bool false
let bits bits width         = Private.Bits(bits,width) 
let linkconst name width    = Private.Link(name,width)

(* expression *)
let const c                 = Private.Const(c)
let fetch loc width         = Private.Fetch(loc,width)
let app op exprs            = Private.App(op,exprs)

(* location *)
let cloc sp agg width expr  = Private.Cell(sp,agg,width,expr,Private.none)
let vloc name index width   = Private.Var(name,index,width)

(* effect *)
let store loc expr width    = Private.Store(loc,expr,width)
let kill  loc               = Private.Kill(loc)

(* rtl *)
let guarded expr effect     = expr, effect
let rtl guards              = Private.Rtl(guards)

(* utilities *)
let width  = Private.width
let assign = Private.assign
@

All conversion functions are the identity [[id]] because public and
private values have the same representation.

<<>>=
let id               = fun x -> x
let conv_const       = id
let conv_expr        = id
let conv_location    = id
let conv_effect      = id
let conv_rtl         = id
@

