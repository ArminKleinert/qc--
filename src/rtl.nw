% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{../config/macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Register-transfer Lists (\rtl)}
% ------------------------------------------------------------------ 

Register-transfer lists capture the meaning of storing values into
memory or register locations, or even the program counter.  They are
used as part of the abstract representation of {\PAL}.  The meaning of
a register-transfer list is well defined and especially independent
from any properties of a target architecture because no hidden
assumptions exist.


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface is divided into three parts:  \emph{public},
\emph{private}, and \emph{common}.  The public part provides
constructor functions to build {\rtl}s but hides their actual
implementation.  The private part reveals these and is intended only
for parts of the back end that does re-writing of {\rtl}s.  Both
private and public parts share \emph{common} types.  The public part
includes function that converts public values into private values and
thus makes their details accessible. 

<<rtl.mli>>=
<<COMMON>>

module Private: sig
    <<representation exposed in the private interface>>
end

<<types and functions exported at top level>>
module Convert: sig 
    <<CONV>>
end

module Revert: sig 
    <<REV>>
end

@

% ------------------------------------------------------------------ 
\subsubsection{Common Types}
% ------------------------------------------------------------------ 

All common types are types aliases that are mainly used to make the
signatures more readable.  A [[space]] describes some kind of memory,
like a set of registers or main memory.  The number of [[spaces]] is a
property of a target architecture and thus can not be fixed here with
a sum type.  The [[char]] type provides a big enough cardinality and
is nice to print and remember.  A [[width]] is a number of bits which
corresponds to the {\PAL} [[bits]]$k$ types. 
  
<<COMMON>>=
type space      = char  (* see module Space for details *)
type width      = int   (* width in bits                *)

type aggregation = 
    | BigEndian
    | LittleEndian
    | Identity
@

% ------------------------------------------------------------------ 
\subsubsection{Public View}
% ------------------------------------------------------------------ 

The public view provides constructor functions for {\rtl}s.  Using
them should be the \emph{only} way to create {\rtl}s when translating
from the abstract syntax tree.

A constant expression can be a boolean value, a number of bits, or a
link-time value, which has a name. A [[fetch]] creates an expression
that represents the value stored in a [[loc]]. Operators [[op]]
can be applied to values and return a value.

<<types and functions exported at top level>>=
type exp          (* denotes a compile-time or run-time value *)
type loc          (* mutable container of a bit vector *)
type rtl          (* effect of a computation *)
type opr          (* a pure function on values *)
type assertion    (* a claim about the run-time value of an address *)

val bool      : bool -> exp                    (* const *)
val bits      : Bits.bits -> width -> exp      (* const *)
val link      : string -> width -> exp         (* const *)
val fetch     : loc -> width -> exp
val app       : opr -> exp list -> exp

val opr       : string -> width list -> opr
@


A [[loc]] may be:
\begin{itemize}
\item A \emph{cell} that belongs to some [[space]], where it has an
      address [[exp]].  We always have an [[assertion]] that tells us
      facts about the possible run-time values of the address.  These
      assertions represent guarantees made by the front end. 

\item A named {\PAL} variable [[var]].

\item A \emph{slice} from a location at a known width and least-significant
      bit.
\end{itemize}

<<types and functions exported at top level>>=
val none     : assertion
val aligned  : int -> assertion
val cell     : assertion -> space -> aggregation -> width -> exp -> loc
val var      : string -> index:int -> width -> loc
val slice    : width -> lsb:int -> loc -> loc
@

A [[cell]] [[c]] of some [[space]], described by a [[spacedesc]] value
[[s]], is well-typed, if all of the following conditions are met:

\begin{enumerate}
\item The cell's aggregation equals [[s.byteorder]]
\item The cell's width equals [[s.cellwidth]]
\item The cell's address expression width equals [[s.addrwidth]]
\end{enumerate}

An effect alters one or more [[loc]]s.  A [[store]] puts the value of
[[exp]] into a location; a [[kill]] invalidates a location's content.
Effects are represented as {\rtl}s.

<<types and functions exported at top level>>=
val store     : loc -> exp -> width -> rtl
val kill      : loc -> rtl
@

A register-transfer list {\rtl} may be guarded; to execute a guarded
\rtl, if the guard is false, do nothing, otherwise perform the \rtl.
A guard must be a boolean expression.  The function [[guard]] takes a
boolean expression [[exp]] and an [[rtl]] and produces a guarded \rtl.

The function [[par]] composes \rtl s in parallel.
A parallel composition simultaneously performs the effects of all
RTLs; that is, it evaluates all guards and right-hand sides before
making any assignment.
It is an \emph{unchecked run-time error} to compose in parallel two or
more RTLs that assign to the same location; such a parallel
composition is not meaningful.

<<types and functions exported at top level>>=
val guard     : exp -> rtl -> rtl
val par       : rtl list -> rtl
@

For uniformity, the [[null]] {\rtl} is sometimes useful. It does nothing.

<<types and functions exported at top level>>=
val null      : rtl
@

% ------------------------------------------------------------------ 
\subsubsection{Conversion between Private and Public Views}
% ------------------------------------------------------------------ 

The purpose of the private interface is to exploit the implementation
details by pattern matching, for example. Values created by the public
interface per se are not compatible with the private types. Conversion
functions provide access to these values. Each function is named after
the type it converts.

It is not possible to make the conversion functions part of
[[Private]] without putting the public interface at the same time into
a sub-module like [[Public]]:  there is no way to refer to a type
outside of [[Private]] from inside [[Private]] that is also declared
inside [[Private]]. 

<<CONV>>=
val exp:        exp      -> Private.exp
val loc:        loc      -> Private.loc       
val rtl:        rtl      -> Private.rtl
val opr:        opr      -> Private.opr

<<REV>>=
val exp:        Private.exp      -> exp
val loc:        Private.loc      -> loc
val rtl:        Private.rtl      -> rtl
val opr:        Private.opr      -> opr
@


% ------------------------------------------------------------------ 
\subsubsection{The Private View}
% ------------------------------------------------------------------ 

The private view defines {\rtl}s in terms of data structures. Values
defined using the public functions can be converted to their private
representation to facilitate pattern matching over them.

We want to represent assertions for specific properties but have not
yet found a representation. Todo: replace all $-1$ values in the code
with [[Rtl.none]]. 

<<representation exposed in the private interface>>=
type aligned   = int     (* alignment guaranteed *)
type assertion = aligned (* may one day include alias info *)
@

An operator for values at run-time is represented by its name and a
list of [[width]]s.  Each [[width]] corresponds to a $\forall$-bound
variable in the type scheme of the operator's type.  From the type
scheme and the [[width list]] a monomorphic type of the operator can
be deduced.

<<representation exposed in the private interface>>=
type opr         = string * width list
@

Expressions provide values to be stored in [[loc]]s as well as
addresses local to a [[space]].  An expression can access constant
values and values fetched from memory.  A fetch from memory makes the
[[width]] number of fetched bits explicit.  A label denotes a {\PAL}
data- or goto-label and its type. 

The width of a [[Bits]] value is stored inside the value of type
[[Bits.bits]].
We hope this offers the advantage that mostly the width is static (see
the careful implementation of [[RTL.bits]]) and yet it can be easily
grabbed by an automatically generated recognizer.

<<representation exposed in the private interface>>=
type const      = Bool      of bool
                | Bits      of Bits.bits
                | Link      of string * width         (* link time constant *)

type exp        = Const     of const               
                | Fetch     of loc * width 
                | App       of opr * exp  list
@

A location describes a memory location or register on the target
architecture or a {\PAL} register. The code generation will remove all
{\PAL} registers and provide memory locations for them. A memory
[[cell]] lives in an address [[space]] at the address denoted by
[[exp]]. In order to fetch [[width]] bits at once several memory
units from the chosen [[space]] must be aggregated. For example, a 32
bit fetch must aggregate 4 8-bit values when the memory space is made
by 8-bit bytes. The aggregation is described by a value of the type
[[aggregation]]. 

<<representation exposed in the private interface>>=
and  loc       = Cell       of space 
                            *  aggregation
                            *  width
                            *  exp 
                            *  assertion
                        
                | Var       of string    (* name from C-- source   *)
                            *  int       (* index for run-time API *)
                            *  width

                | Slice     of width     (* number of bits in loc *)
                            *  int       (* index of least-significant bit of slice *)
                            *  loc  (* location from which slice is drawn *)
@ 
Bits are numbered with the least-significant bit as bit~0.

An [[effect]] is describes an assignment of a [[width]] bits value obtained
from an expression [[exp]], or a [[Kill]]. A killed location contains an
undefined value.

<<representation exposed in the private interface>>=
type effect     = Store     of loc * exp  * width
                | Kill      of loc
@

A guarded effect is pair of an expression and an effect. The effect takes
place, if and only if the expression evaluates to [[true]].      

<<representation exposed in the private interface>>=
type guarded    = exp  * effect
@

And finally, a \emph{register-transfer list} is a list of guarded
effects. When a {\rtl} is evaluated, first all guarding expressions
are evaluated and then all effects of the guards that evaluated to
true become effective simultaneously.

<<representation exposed in the private interface>>=
type rtl        = Rtl of guarded list
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The interface of [[Private]] defines only data types; we re-use the
definitions to obtain the implementation.  The same is true for common
data types. 

<<rtl.ml>>=
<<COMMON>>

module Private = struct
    <<Private>>
end

<<definitions of types and functions exported at top level>>              

module Convert = struct    
    <<Conv>>
end

module Revert = struct    
    <<Rev>>
end
@
% ------------------------------------------------------------------ 
\subsubsection{The Private View}
% ------------------------------------------------------------------ 

The implementation of the private view must repeat the type
definitions from the interface. 

<<Private>>=
<<representation exposed in the private interface>>
@
        
% ------------------------------------------------------------------ 
\subsubsection{The Public View}
% ------------------------------------------------------------------ 

The implementation of the public view basically uses the [[Private]]
definitions such that they become compatible.  However, this fact is
hidden by the interface.

<<definitions of types and functions exported at top level>>=
open Private    (* never do that *)
type exp       = Private.exp     
type loc       = Private.loc   
type rtl       = Private.rtl        
type opr       = Private.opr        
type assertion = Private.assertion  
@
<<definitions of types and functions exported at top level>>=
let aligned k = k
let none = aligned 1
@

Below are simple, nonetheless frequently used functions values on
{\rtl}s.

<<definitions of types and functions exported at top level>>=
let par rtls   = Rtl (List.concat (List.map (fun (Rtl x) -> x) rtls))
let slice width lsb loc = Slice (width, lsb, loc) 
@

The [[guard]] function combines every guard in the {\rtl} with the
given expression using Boolean conjunction.  We use a fairly
unsophisticated notion of conjunction; it doesn't even reassociate.
%
<<definitions of types and functions exported at top level>>=
let conjunction = ("conjoin", [])   (* logical and *)
let conjoin g g' = match g with
| Const(Bool true)  -> g'
| Const(Bool false) -> g
| _ -> match g' with      
       | Const(Bool true)  -> g
       | Const(Bool false) -> g'
       | _ -> App(conjunction, [g; g'])
@
<<definitions of types and functions exported at top level>>=
let guard expr (Rtl geffects) =
    let conjunct (guard,effect) = (conjoin expr guard, effect) in
    Rtl (List.map conjunct geffects)  
@


<<definitions of types and functions exported at top level>>=
let true'  = Const (Bool true)
let false' = Const (Bool false)
let bool p = if p then true' else false'
@ 

Note that the width used in a bit vector is the [[width]] argument,
\emph{not} the width buried inside the bit vector itself.  We do things
this way to support type-directed partial evaluation; the [[width]]
argument is normally static. 

\begin{quote}\it
    Literals are currently stored in 64 bit wide bit vectors
    ([[Bits.bits]]). There types, however, as noted in [[Rtl.rtl]]s
    might be smaller.  The reason is, that the types of literals are
    unknown during scanning and parsing. So every literal is first
    stored in maximal bit vector and gets its type assigned later. --CL
\end{quote}


<<definitions of types and functions exported at top level>>=
let bits (bvector, w) width = (assert (w >= width); Const (Bits(bvector,width)))
let link name width         = Const (Link(name,width))
let fetch loc width         = Fetch(loc,width)
let app op exprs            = App(op,exprs)
let opr name widths         = (name,widths)

(* location *)
let cell assertion sp agg width expr  = Cell(sp,agg,width,expr,assertion)
let var name index width   = Var(name,index,width)

(* effect *)
let rtl effect              = Rtl [(bool true, effect)]
let store loc expr width    = rtl (Store(loc,expr,width))
let kill  loc               = rtl (Kill(loc))
let null                    = Rtl []
@

All conversion functions are the identity [[id]] because public and
private values have the same representation.
% surprised you don't prefer  `let expr e = e' etc...  ---NR

<<Conv>>=
let id          = fun x -> x
let exp         = id
let loc         = id
let rtl         = id
let opr         = id


<<Rev>>=
let id          = fun x -> x
let exp         = id
let loc         = id
let rtl         = id
let opr         = id
@

