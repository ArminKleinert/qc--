% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Register Transfer Lists (\rtl)}
% ------------------------------------------------------------------ 

Register transfer lists capture the meaning of storing values into
memory or register locations.  They are used as part of the abstract
representation of {\PAL}.  The meaning of a register transfer list is
well defined and especially independent from any properties of a
target architecture because no hidden assumptions exist.  


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

A [[space]] describes some kind of memory, like a set of registers or
main memory.  The number of [[spaces]] is a property of a target
architecture and thus can not be fixed here with a sum type.  The
[[char]] type provides a big enough cardinality and is nice to print
and remember.

<<rtl.mli>>=
<<abstract types>>
<<concrete types>>
<<utilities>>
@

% ------------------------------------------------------------------ 
\subsubsection{The {\rtl} data type}
% ------------------------------------------------------------------ 

[[register]] represents a named {\PAL} register and [[width]] a number
of bits which corresponds to the {\PAL} [[bits]]$k$ types.
  
<<concrete types>>=
type space       = char         (* 'm'=memory, 'r'=register, 't'=temp,..*)
type width       = int          (* bits *)
@

We want to represent assertions for specific properties but have not
yet found a representation. Todo: replace all $-1$ values in the code
with [[Rtl.none]]. 

<<abstract types>>=
type assertion   = int
val  none:         assertion
@

An operator for values at run-time is represented by its name and a
list of [[width]]s.  Each [[width]] corresponds to a $\forall$-bound
variable in the type scheme of the operator's type.  From the type
scheme and the [[width list]] a monomorphic type of the operator can
be deduced.

<<concrete types>>=
type op          = string * width list
@

Expressions provide values to be stored in [[locations]] as well as
addresses local to a [[space]].  An expression can access constant
values and values fetched from memory.  A fetch from memory makes the
[[width]] number of fetched bits explicit.  A label denotes a {\PAL}
data- or goto-label and its type. 

<<>>=
type const      = Bool      of bool
                | Bits      of Bits.bits * width
                | Link      of string * width         (* link time constant *)

type expr       = Const     of const               
                | Fetch     of location * width 
                | App       of op * expr list
@

A location describes a memory location or register on the target
architecture or a {\PAL} register. The code generation will remove all
{\PAL} registers and provide memory locations for them. A memory
[[cell]] lives in an address [[space]] at the address denoted by
[[expr]]. In order to fetch [[width]] bits at once several memory
units from the chosen [[space]] must be aggregated. For example, a 32
bit fetch must aggregate 4 8-bit values when the memory space is made
by 8-bit bytes. The aggregation is described by a value of the type
[[aggregation]]. 

<<>>=
and  location  = Cell       of space 
                            *  aggregation
                            *  width
                            *  expr
                            *  assertion
                        
                | Var       of string    (* name from C-- source   *)
                            *  int       (* index for run-time API *)
                            *  width
<<>>=
and  aggregation            = BigEndian
                            | LittleEndian
                            | Identity
@

An [[effect]] is describes an assignment of a [[width]] bits value obtained
from an expression [[expr]], or a [[Kill]]. A killed location contains an
undefined value.

<<>>=
type effect     = Store     of location * expr * width
                | Kill      of location
@

A guarded effect is pair of an expression and an effect. The effect takes
place, if and only if the expression evaluates to [[true]].      

<<>>=
type guarded    = expr * effect
@

And finally, a \emph{register transfer list} is a list of guarded
effects. When a {\rtl} is evaluated, first all guarding expressions
are evaluated and then all effects of the guards that evaluated to
true become effective simultaneously.

<<>>=
type rtl        = Rtl of guarded list
@

% ------------------------------------------------------------------ 
\subsubsection{{\rtl} utilities}
% ------------------------------------------------------------------ 

Code that builds or manipulates {\rtl}s tends to use the same
functionality over and over again. We try to define some useful values
here.

<<utilities>>=
val truth:      expr            (* constant true *)
@

The [[width]] of an expression is only defined for value-expressions,
but not for conditions. Applying [[width]] to a condition is will
result in an assertion failure.

<<>>=
val width:      expr -> int     (* width of expression *)
@

<<>>=
val assign:     location -> expr -> rtl
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation consists provides the concrete types already
defined in the interface and defines representations for the abstract types.

<<rtl.ml>>=
<<abstract types implementation>>
<<concrete types>>
<<utilities implementation>>
@

<<abstract types implementation>>=
type assertion = int            (* dummy *)
let  none      = (-1)
@

% ------------------------------------------------------------------ 
\subsubsection{Utilities}
% ------------------------------------------------------------------ 

Below are the simple, nontheless frequently used functions and simple
values on {\rtl}s.

<<utilities implementation>>=
let truth      = Const(Bool(true))

let width = function
    | Const(Bool _)     -> assert false
    | Const(Bits (_,w)) -> w
    | Const(Link (_,w)) -> w
    | Fetch(_,w)        -> w
    | App _             -> assert false (* not implemented *)
    
let assign l r = Rtl [(truth, Store(l, r, width r))]
@



