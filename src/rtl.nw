% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Register-transfer Lists (\rtl)}
% ------------------------------------------------------------------ 

Register-transfer lists capture the meaning of storing values into
memory or register locations, or even the program counter.  They are
used as part of the abstract representation of {\PAL}.  The meaning of
a register-transfer list is well defined and especially independent
from any properties of a target architecture because no hidden
assumptions exist.


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface is divided into three parts:  \emph{public},
\emph{private}, and \emph{common}.  The public part provides
constructor functions to build {\rtl}s but hides their actual
implementation.  The private part reveals these and is intended only
for parts of the back end that does re-writing of {\rtl}s.  Both
private and public parts share \emph{common} types.  The public part
includes function that converts public values into private values and
thus makes their details accessible. 

<<rtl.mli>>=
<<COMMON>>

module Private: sig
    <<representation exposed in the private interface>>
end

<<types and functions exported at top level>>
module Convert: sig 
    <<CONV>>
end
@

% ------------------------------------------------------------------ 
\subsubsection{Common Types}
% ------------------------------------------------------------------ 

All common types are types aliases that are maily used to make the
signatures more readable.  A [[space]] describes some kind of memory,
like a set of registers or main memory.  The number of [[spaces]] is a
property of a target architecture and thus can not be fixed here with
a sum type.  The [[char]] type provides a big enough cardinality and
is nice to print and remember.  A [[width]] is a number of bits which
corresponds to the {\PAL} [[bits]]$k$ types.
  
<<COMMON>>=
type space      = char  (* conventional, but typically 'm'=memory, 'r'=register, .. *)
type width      = int   (* width in bits                *)
@


% ------------------------------------------------------------------ 
\subsubsection{Public View}
% ------------------------------------------------------------------ 

The public view provides constructor functions for {\rtl}s.  Using
them should be the \emph{only} way to create {\rtl}s when translating
from the abstract syntax tree.

A constant expression can be a boolean value, a number of bits, or a
link-time value, which has a name. A [[fetch]] creates an expression
that represents the value stored in a [[location]]. Operators [[op]]
can be applied to values and return a value.

<<types and functions exported at top level>>=
type expr         (* denotes a compile-time or run-time value *)
type location     (* mutable container of a bit vector *)
type rtl          (* effect of a computation *)
type op           (* a pure function on values *)
type assertion    (* a claim about the run-time value of an address *)

val bool      : bool -> expr                    (* const *)
val bits      : Bits.bits -> width -> expr      (* const *)
val link      : string -> width -> expr         (* const *)
val fetch     : location -> width -> expr
val app       : op -> expr list -> expr

val op        : string -> width list -> op
@


A [[location]] may be
\begin{itemize}
\item
A \emph{cell} that belongs to some [[space]],
where it has an address [[expr]].
We always have an [[assertion]] that tells us facts about the possible
run-time values of the address.
These assertions represent guarantees made by the front end.
\item
A named {\PAL} variable [[var]].
\item
 A \emph{slice} from a location at a known
width and least-significant bit.
\end{itemize}
%
<<types and functions exported at top level>>=
val none     : assertion
val aligned  : int -> assertion
val cell     : assertion -> space -> aggregation -> width -> expr -> location
val var      : string -> int -> width -> location
val slice    : width -> lsb:int -> location -> location
@

An effect alters one or more [[location]]s.  A [[store]] puts the value of
[[expr]] into a location; a [[kill]] invalidates a location's content.
Effects are represented as {\rtl}s.
%
<<types and functions exported at top level>>=
val store     : location -> expr -> width -> rtl
val kill      : location -> rtl
@

A register-transfer list {\rtl} may be guarded; to execute a guarded
\rtl, if the guard is false, do nothing, otherwise perform the \rtl.
A guard must be a boolean expression.  The function [[guard]] takes a
boolean expression [[expr]] and an [[rtl]] and produces a guarded \rtl.

The function [[par]] composes \rtl s in parallel.
A parallel composition simultaneously performs the effects of all
RTLs; that is, it evaluates all guards and right-hand sides before
making any assignment.
It is an \emph{unchecked run-time error} to compose in parallel two or
more RTLs that assign to the same location; such a parallel
composition is not meaningful.

<<>>=
val guard     : expr -> rtl -> rtl
val par       : rtl list -> rtl
@

<<>>=
@

The purpose of the private interface is to exploit the implementation
details by pattern matching, for example. Values created by the public
interface per se are not compatible with the private types. Conversion
functions provide access to these values. Each function is named after
the type it converts.

It is not possible to make the conversion functions part of
[[Private]] without putting the public interface at the same time into
a sub-module like [[Public]]:  there is no way to refer to a type
outside of [[Private]] from inside [[Private]] that is also declared
inside [[Private]]. 

<<CONV>>=
val expr:       expr     -> Private.expr
val location:   location -> Private.location
val rtl:        rtl      -> Private.rtl
val op:         op       -> Private.op
@

% ------------------------------------------------------------------ 
\subsubsection{The Private View}
% ------------------------------------------------------------------ 

The private view defines {\rtl}s in terms of data structures. Values
defined using the public functions can be converted to their private
representation to facilitate pattern matching over them.

We want to represent assertions for specific properties but have not
yet found a representation. Todo: replace all $-1$ values in the code
with [[Rtl.none]]. 

<<representation exposed in the private interface>>=
type aligned   = int (* alignment guaranteed *)
type assertion = aligned (* may one day include alias info *)
@

An operator for values at run-time is represented by its name and a
list of [[width]]s.  Each [[width]] corresponds to a $\forall$-bound
variable in the type scheme of the operator's type.  From the type
scheme and the [[width list]] a monomorphic type of the operator can
be deduced.

<<representation exposed in the private interface>>=
type op          = string * width list
@

Expressions provide values to be stored in [[locations]] as well as
addresses local to a [[space]].  An expression can access constant
values and values fetched from memory.  A fetch from memory makes the
[[width]] number of fetched bits explicit.  A label denotes a {\PAL}
data- or goto-label and its type. 

<<representation exposed in the private interface>>=
type const      = Bool      of bool
                | Bits      of Bits.bits * width
                | Link      of string * width         (* link time constant *)

type expr       = Const     of const               
                | Fetch     of location * width 
                | App       of op * expr list
@

A location describes a memory location or register on the target
architecture or a {\PAL} register. The code generation will remove all
{\PAL} registers and provide memory locations for them. A memory
[[cell]] lives in an address [[space]] at the address denoted by
[[expr]]. In order to fetch [[width]] bits at once several memory
units from the chosen [[space]] must be aggregated. For example, a 32
bit fetch must aggregate 4 8-bit values when the memory space is made
by 8-bit bytes. The aggregation is described by a value of the type
[[aggregation]]. 

<<representation exposed in the private interface>>=
and  location  = Cell       of space 
                            *  aggregation
                            *  width
                            *  expr
                            *  assertion
                        
                | Var       of string    (* name from C-- source   *)
                            *  int       (* index for run-time API *)
                            *  width

                | Slice     of width    (* number of bits in location *)
                            *  int      (* index of least-significant bit of slice *)
                            * location  (* location from which slice is drawn *)
@ Bits are numbered with the least-significant bit as bit~0.
@


<<COMMON>>=
type  aggregation           = BigEndian
                            | LittleEndian
                            | Identity
@

An [[effect]] is describes an assignment of a [[width]] bits value obtained
from an expression [[expr]], or a [[Kill]]. A killed location contains an
undefined value.

<<representation exposed in the private interface>>=
type effect     = Store     of location * expr * width
                | Kill      of location
@

A guarded effect is pair of an expression and an effect. The effect takes
place, if and only if the expression evaluates to [[true]].      

<<representation exposed in the private interface>>=
type guarded    = expr * effect
@

And finally, a \emph{register-transfer list} is a list of guarded
effects. When a {\rtl} is evaluated, first all guarding expressions
are evaluated and then all effects of the guards that evaluated to
true become effective simultaneously.

<<representation exposed in the private interface>>=
type rtl        = Rtl of guarded list
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The interface of [[Private]] defines only data types; we re-use the
definitions to obtain the implementation.  The same is true for common
data types. 

<<rtl.ml>>=
<<COMMON>>

module Private = struct
    <<Private>>
end

<<definitions of types and functions exported at top level>>              

module Convert = struct    
    <<Conv>>
end
@
% ------------------------------------------------------------------ 
\subsubsection{The Private View}
% ------------------------------------------------------------------ 

The implementation of the private view must repeat the type
definitions from the interface. 

<<Private>>=
<<representation exposed in the private interface>>
@


        
% ------------------------------------------------------------------ 
\subsubsection{The Public View}
% ------------------------------------------------------------------ 

The implementation of the public view basically uses the [[Private]]
definitions such that they become compatible.  However, this fact is
hidden by the interface.

<<definitions of types and functions exported at top level>>=
open Private
type expr      = Private.expr     
type location  = Private.location   
type rtl       = Private.rtl        
type op        = Private.op         
type assertion = Private.assertion  
@ 
<<>>=
let aligned k = k
let none = aligned 1
@

Below are simple, nonetheless frequently used functions values on
{\rtl}s.

<<>>=
let par rtls   = Rtl (List.concat (List.map (fun (Rtl x) -> x) rtls))
let slice width lsb loc = Slice (width, lsb, loc) 
@

The [[guard]] function combines every guard in the {\rtl} with the
given expression using Boolean conjunction.  We use a fairly
unsophisticated notion of conjunction; it doesn't even reassociate.
%
<<>>=
let conjunction = ("conjoin", [])   (* logical and *)
let conjoin g g' = match g with
| Const(Bool true)  -> g'
| Const(Bool false) -> g
| _ -> match g' with      
       | Const(Bool true)  -> g
       | Const(Bool false) -> g'
       | _ -> App(conjunction, [g; g'])
@ 
<<>>= 
let guard expr (Rtl geffects) =
    let conjunct (guard,effect) = (conjoin expr guard, effect) in
    Rtl (List.map conjunct geffects)  
@


<<>>=
let true'  = Const (Bool true)
let false' = Const (Bool false)
let bool p = if p then true' else false'

let bits bits width         =
  (assert (Bits.width bits = width); Const (Bits(bits,width)))
let link name width         = Const (Link(name,width))
let fetch loc width         = Fetch(loc,width)
let app op exprs            = App(op,exprs)
let op name widths          = (name,widths)

(* location *)
let cell assertion sp agg width expr  = Cell(sp,agg,width,expr,assertion)
let var name index width   = Var(name,index,width)

(* effect *)
let rtl effect              = Rtl [(bool true, effect)]
let store loc expr width    = rtl (Store(loc,expr,width))
let kill  loc               = rtl (Kill(loc))
@

All conversion functions are the identity [[id]] because public and
private values have the same representation.
% surprised you don't prefer  `let expr e = e' etc...  ---NR

<<Conv>>=
let id          = fun x -> x
let expr        = id
let location    = id
let rtl         = id
let op          = id
@

