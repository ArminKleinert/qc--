% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Register Transfer Lists (\rtl)}
% ------------------------------------------------------------------ 

Register transfer lists capture the meaning of storing values into
memory or register locations.  They are used as part of the abstract
representation of {\PAL}.  The meaning of a register transfer list is
well defined and especially independent from any properties of a
target architecture because no hidden assumptions exist.  


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface is divided into three parts:  \emph{public},
\emph{private}, and \emph{common}.  The public part provides
constructor functions to build {\rtl}s but hides their actual
implementation.  The private part reveals these and is intended only
for parts of the back end that does re-writing of {\rtl}s.  Both
private and public parts share \emph{common} types.  The public part
includes function that converts public values into private values and
thus makes their details accessible. 

<<rtl.mli>>=
<<COMMON>>

module Private: sig
    <<PRIVATE types>>
    <<PRIVATE values>>
end

<<PUBLIC>>
module Conv: sig 
    <<CONV>>
end
@

% ------------------------------------------------------------------ 
\subsubsection{Common Types}
% ------------------------------------------------------------------ 

All common types are types aliases that are maily used to make the
signatures more readable.  A [[space]] describes some kind of memory,
like a set of registers or main memory.  The number of [[spaces]] is a
property of a target architecture and thus can not be fixed here with
a sum type.  The [[char]] type provides a big enough cardinality and
is nice to print and remember.  A [[width]] is a number of bits which
corresponds to the {\PAL} [[bits]]$k$ types.
  
<<COMMON>>=
type space      = char  (* 'm'=memory, 'r'=register, .. *)
type width      = int   (* width in bits                *)
@


% ------------------------------------------------------------------ 
\subsubsection{Public View}
% ------------------------------------------------------------------ 

The public view provides constructor functions for {\rtl}s.  Using
them should be the \emph{only} way to create {\rtl}s when translating
from the abstract syntax tree.

A constant expression can be a boolean value, a number of bits, or a
link-time value, which has a name. A [[fetch]] creates an expression
that represents the value stored in a [[location]]. Operators [[op]]
can be applied to values and return a value.

<<PUBLIC>>=
type expr
type location
type rtl
type op

val bool      : bool -> expr                    (* const *)
val bits      : Bits.bits -> width -> expr      (* const *)
val link      : string -> width -> expr         (* const *)
val fetch     : location -> width -> expr
val app       : op -> expr list -> expr

val op        : string -> width list -> op
@


A [[location]] is either a \emph{cell} that belongs to some [[space]],
where it has an address [[expr]], or it represents a named {\PAL}
variable [[var']] ([[var]] is an {\ocaml} keyword).

<<PUBLIC>>=
val cell     : space -> aggregation -> width -> expr -> location
val var      : string -> int -> width -> location
@

An effect alters a [[location]]:  a [[store]] puts the value of
[[expr]] into a location, a [[kill]] invalidates a location's content.
Effects are represented as {\rtl}s.

<<PUBLIC>>=
val store     : location -> expr -> width -> rtl
val kill      : location -> rtl
@

A register transfer list {\rtl} is a list of guarded effects; each
guard must be a boolean expression.  The function [[guard]] takes a
boolean expression [[expr]] and an [[rtl]] and conjuncts every guard
in that rtl with the new expression.

<<>>=
val guard     : expr -> rtl -> rtl
val par       : rtl list -> rtl
@

Code that builds or manipulates {\rtl}s tends to use the same
functionality over and over again. We try to define some useful values
here.

The [[width]] of an expression is only defined for value-expressions,
but not for conditions.  Applying [[width]] to a condition will result
in an assertion failure.

<<>>=
val width:      expr -> int                 (* width of expression *)
val assign:     location -> expr -> rtl
val slice:      width -> expr -> location -> location
@

The purpose of the private interface is to exploit the implementation
details by pattern matching, for example. Values created by the public
interface per se are not compatible with the private types. Conversion
functions provide access to these values. Each function is named after
the type it converts.

It is not possible to make the conversion functions part of
[[Private]] without putting the public interface at the same time into
a sub-module like [[Public]]:  there is no way to refer to a type
outside of [[Private]] from inside [[Private]] that is also declared
inside [[Private]]. 

<<CONV>>=
val expr:       expr     -> Private.expr
val location:   location -> Private.location
val rtl:        rtl      -> Private.rtl
val op:         op       -> Private.op
@

% ------------------------------------------------------------------ 
\subsubsection{The Private View}
% ------------------------------------------------------------------ 

The private view defines {\rtl}s in terms of data structures. Values
defined using the public functions can be converted to their private
representation to facilitate pattern matching over them.

We want to represent assertions for specific properties but have not
yet found a representation. Todo: replace all $-1$ values in the code
with [[Rtl.none]]. 

<<PRIVATE types>>=
type assertion   = int

<<PRIVATE values>>=
val  none:         assertion
@

An operator for values at run-time is represented by its name and a
list of [[width]]s.  Each [[width]] corresponds to a $\forall$-bound
variable in the type scheme of the operator's type.  From the type
scheme and the [[width list]] a monomorphic type of the operator can
be deduced.

<<PRIVATE types>>=
type op          = string * width list
@

Expressions provide values to be stored in [[locations]] as well as
addresses local to a [[space]].  An expression can access constant
values and values fetched from memory.  A fetch from memory makes the
[[width]] number of fetched bits explicit.  A label denotes a {\PAL}
data- or goto-label and its type. 

<<PRIVATE types>>=
type const      = Bool      of bool
                | Bits      of Bits.bits * width
                | Link      of string * width         (* link time constant *)

type expr       = Const     of const               
                | Fetch     of location * width 
                | App       of op * expr list
@

A location describes a memory location or register on the target
architecture or a {\PAL} register. The code generation will remove all
{\PAL} registers and provide memory locations for them. A memory
[[cell]] lives in an address [[space]] at the address denoted by
[[expr]]. In order to fetch [[width]] bits at once several memory
units from the chosen [[space]] must be aggregated. For example, a 32
bit fetch must aggregate 4 8-bit values when the memory space is made
by 8-bit bytes. The aggregation is described by a value of the type
[[aggregation]]. 

<<PRIVATE types>>=
and  location  = Cell       of space 
                            *  aggregation
                            *  width
                            *  expr
                            *  assertion
                        
                | Var       of string    (* name from C-- source   *)
                            *  int       (* index for run-time API *)
                            *  width
<<COMMON>>=
type  aggregation           = BigEndian
                            | LittleEndian
                            | Identity
@

An [[effect]] is describes an assignment of a [[width]] bits value obtained
from an expression [[expr]], or a [[Kill]]. A killed location contains an
undefined value.

<<PRIVATE types>>=
type effect     = Store     of location * expr * width
                | Kill      of location
@

A guarded effect is pair of an expression and an effect. The effect takes
place, if and only if the expression evaluates to [[true]].      

<<PRIVATE types>>=
type guarded    = expr * effect
@

And finally, a \emph{register transfer list} is a list of guarded
effects. When a {\rtl} is evaluated, first all guarding expressions
are evaluated and then all effects of the guards that evaluated to
true become effective simultaneously.

<<PRIVATE types>>=
type rtl        = Rtl of guarded list
@


<<PRIVATE values>>=
val width:      expr -> int     (* width of expression *)
val assign:     location -> expr -> rtl
val par:        rtl list -> rtl
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The interface of [[Private]] defines only data types; we re-use the
definitions to obtain the implementation.  The same is true for common
data types. 

<<rtl.ml>>=
<<COMMON>>

module Private = struct
    <<Private>>
end

<<Public>>              

module Conv = struct    
    <<Conv>>
end
@
% ------------------------------------------------------------------ 
\subsubsection{The Private View}
% ------------------------------------------------------------------ 

The implementation of the private view must repeat the type
definitions from the interface. 

<<Private>>=
<<PRIVATE types>>
@

The empty assertion is provided as a value [[none]].

<<>>=
let none: assertion = (-1)     
@

Below are simple, nonetheless frequently used functions values on
{\rtl}s.

<<>>=
let width = function
    | Const(Bool _)     -> assert false
    | Const(Bits (_,w)) -> w
    | Const(Link (_,w)) -> w
    | Fetch(_,w)        -> w
    | App _             -> assert false (* not implemented *)
    
let assign l r = Rtl [(Const(Bool true), Store(l, r, width r))]
let par rtls   = Rtl (List.concat (List.map (fun (Rtl x) -> x) rtls))
let slice width lsb loc = assert false (* don't know how *)
@

The [[guard]] function combines every guard in the {\rtl} with the
given expression using a logical \emph{and}.  I don't know which
primitve to use to encode the general case.  I guess we haven't
decided yet how to represent boolean value at run-time.

<<>>=
let guard expr (Rtl geffects) =
    let true'  = Const(Bool true)  in
    let false' = Const(Bool false) in
    let conjunct (guard,effect as id) = match expr, guard with
        | Const(Bool true) , Const(Bool true)  -> id
        | Const(Bool _    ), Const(Bool false) -> id
        | Const(Bool false), Const(Bool _)     -> (false',effect)
        | x                , y                 -> assert false (* how ?? *)
    in
        Rtl (List.map conjunct geffects)  
@

        
% ------------------------------------------------------------------ 
\subsubsection{The Public View}
% ------------------------------------------------------------------ 

The implementation of the public view basically uses the [[Private]]
definitions such that they become compatible.  However, this fact is
hidden by the interface.

<<Public>>=
type expr     = Private.expr
type location = Private.location
type rtl      = Private.rtl
type op       = Private.op
@



<<Public>>=

let bool = function
    | true  -> Private.Const (Private.Bool true)
    | false -> Private.Const (Private.Bool false)

let bits bits width         = Private.Const (Private.Bits(bits,width)) 
let link name width         = Private.Const (Private.Link(name,width))
let fetch loc width         = Private.Fetch(loc,width)
let app op exprs            = Private.App(op,exprs)
let op name widths          = (name,widths)

(* location *)
let cell sp agg width expr  = Private.Cell(sp,agg,width,expr,Private.none)
let var  name index width   = Private.Var(name,index,width)

(* effect *)
let rtl effect              = Private.Rtl [(bool true, effect)]
let store loc expr width    = rtl (Private.Store(loc,expr,width))
let kill  loc               = rtl (Private.Kill(loc))

(* rtl *)
let par                     = Private.par
let slice                   = Private.slice
let guard                   = Private.guard



(* utilities *)
let width  = Private.width
let assign = Private.assign
@

All conversion functions are the identity [[id]] because public and
private values have the same representation.

<<Conv>>=
let id          = fun x -> x
let expr        = id
let location    = id
let rtl         = id
let op          = id
@

