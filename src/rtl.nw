% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Register Transfer Lists (\rtl)}
% ------------------------------------------------------------------ 

Register transfer lists capture the meaning of storing values into
memory or register locations.  They are used as part of the abstract
representation of {\PAL}.  The meaning of a register transfer list is
well defined and especially independent from any properties of a
target architecture because no hidden assumptions exist.  


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

A [[space]] describes some kind of memory, like a set of registers or
main memory.  The number of [[spaces]] is a property of a target
architecture and thus can not be fixed here with a sum type.  The
[[char]] type provides a big enough cardinality and is nice to print
and remember.

<<rtl.mli>>=
<<abstract types>>
<<concrete types>>
@

% ------------------------------------------------------------------ 
\subsubsection{The {\rtl} data type}
% ------------------------------------------------------------------ 

[[register]] represents a named {\PAL} register and [[width]] a number
of bits which corresponds to the {\PAL} [[bits]]$k$ types.
  
<<concrete types>>=
type space       = char         (* 'm'=memory, 'r'=register, 't'=temp,..*)
type width       = int          (* bits *)
@

We want to represent assertions for specific properties but have not
yet found a representation. Todo: replace all $-1$ values in the code
with [[Rtl.none]]. 

<<abstract types>>=
type assertion   = int
val  none:         assertion
@

An operator for values at run-time is represented by its name and a
list of [[width]]s.  Each [[width]] corresponds to a $\forall$-bound
variable in the type scheme of the operator's type.  From the type
scheme and the [[width list]] a monomorphic type of the operator can
be deduced.

<<concrete types>>=
type op          = string * width list
@

Expressions provide values to be stored in [[locations]] as well as
addresses local to a [[space]].  An expression can access constant
values and values fetched from memory.  A fetch from memory makes the
[[width]] number of fetched bits explicit.  A label denotes a {\PAL}
data- or goto-label and its type. 

<<>>=
type const      = Bool      of bool
                | Bits      of Bits.bits * width
                | Link      of string * width         (* link time constant *)

type expr       = Const     of const               
                | Fetch     of location * width 
                | App       of op * expr list
@

A location describes a memory location or register on the target
architecture or a {\PAL} register. The code generation will remove all
{\PAL} registers and provide memory locations for them. A memory
[[cell]] lives in an address [[space]] at the address denoted by
[[expr]]. In order to fetch [[width]] bits at once several memory
units from the chosen [[space]] must be aggregated. For example, a 32
bit fetch must aggregate 4 8-bit values when the memory space is made
by 8-bit bytes. The aggregation is described by a value of the type
[[aggregation]]. 

<<>>=
and  location  = Cell       of space 
                            *  aggregation
                            *  width
                            *  expr
                            *  assertion
                        
                | Var       of string    (* name from C-- source   *)
                            *  int       (* index for run-time API *)
                            *  width
<<>>=
and  aggregation            = BigEndian
                            | LittleEndian
                            | Identity
@

An [[effect]] is describes an assignment of a [[width]] bits value obtained
from an expression [[expr]], or a [[Kill]]. A killed location contains an
undefined value.

<<>>=
type effect     = Store     of location * expr * width
                | Kill      of location
@

A guarded effect is pair of an expression and an effect. The effect takes
place, if and only if the expression evaluates to [[true]].      

<<>>=
type guarded    = expr * effect
@

And finally, a \emph{register transfer list} is a list of guarded
effects. When a {\rtl} is evaluated, first all guarding expressions
are evaluated and then all effects of the guards that evaluated to
true become effective simultaneously.

<<>>=
type rtl        = Rtl of guarded list
@

% ------------------------------------------------------------------ 
\subsubsection{Constructors}
% ------------------------------------------------------------------ 

The [[Public]] sub-module provides constructor functions for {\rtl}s.
Using them should be the \emph{only} way to create {\rtl}s when
translating from the abstract syntax tree.

<<rtl.mli>>=
module Public : sig
    <<sig Public body>>
end
@

\begin{itemize}
\item Constants.

<<sig Public body>>=
val truth     : const
val falsehood : const
val bits      : Bits.bits -> width -> const
val linkconst : string -> width -> const
@

\item Expressions

<<>>=
val const     : const -> expr
val fetch     : location -> width -> expr
val app       : op -> expr list -> expr
@

\item Locations: cells and variables.

Currently all locations created by [[cloc]] contain the [[none]]
assertion. 

<<>>=
val cloc      : space -> aggregation -> width -> expr -> location
val vloc      : string -> int -> width -> location
@

\item Effects

<<>>=
val store     : location -> expr -> width -> effect
val kill      : location -> effect
@

\item {\rtl}s

<<>>=
val guarded   : expr -> effect -> expr * effect
val rtl       : guarded list -> rtl
@

\end{itemize}


Code that builds or manipulates {\rtl}s tends to use the same
functionality over and over again. We try to define some useful values
here.

The [[width]] of an expression is only defined for value-expressions,
but not for conditions.  Applying [[width]] to a condition will result
in an assertion failure.

<<>>=
val width:      expr -> int     (* width of expression *)
@

<<>>=
val assign:     location -> expr -> rtl
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation consists provides the concrete types already
defined in the interface and defines representations for the abstract types.

<<rtl.ml>>=
<<abstract types implementation>>
<<concrete types>>
@

<<abstract types implementation>>=
type assertion = int            (* dummy *)
let  none      = (-1)
@

% ------------------------------------------------------------------ 
\subsubsection{Constructors}
% ------------------------------------------------------------------ 

As far as possible, we would like to avoid constucting {\rtl} values
directly but use constructor functions instead.  This hopefully allows
to alter the implementation of {\rtl}s without touching client code. 
However, code in the back end of the compiler makes heavy use of
pattern matching to re-write {\rtl}s to target specific code and thus
needs to know the details of the implementation.  The ideal solution
can not be expressed in {\ocaml}:  two different views of the same
implementation where values created in one view are compatible with
the other.  A public view would leave data types abstract and provide
construction functions to create them.  A private view would give
access to all the details. 

The desired effect could be achieved without the compatibility: 
values created in one view are not compatible with the other. 
Conversion functions would be required that basically copy one
representation into the other.

\begin{quote}
\begin{verbatim}
module type PRIVATE = sig
    type t
    val one: t
end

module type PUBLIC = sig
    type t = int
    val one: t
end

module X = struct
    type t  = int
    let one = 1
end

module Public:  PUBLIC  = X
module Private: PRIVATE = X
\end{verbatim}
\end{quote}

In order to avoid the costly conversion we have chosen a simpler,
albeit less secure approach:  we have just one implementation that
offers construction functions in a sub-module [[Public]].  It is still
possible for a client to access and construct values directly, which
is discouraged, of course.

<<rtl.ml>>=
module Public = struct
    <<module Public body>>
end
@

<<module Public body>>=
(* constant *)
let truth                   = Bool true
let falsehood               = Bool false
let bits bits width         = Bits(bits,width) 
let linkconst name width    = Link(name,width)

(* expression *)
let const c                 = Const(c)
let fetch loc width         = Fetch(loc,width)
let app op exprs            = App(op,exprs)

(* location *)
let cloc sp agg width expr  = Cell(sp,agg,width,expr,none)
let vloc name index width   = Var(name,index,width)

(* effect *)
let store loc expr width    = Store(loc,expr,width)
let kill  loc               = Kill(loc)

(* rtl *)
let guarded expr effect     = expr, effect
let rtl guards              = Rtl(guards)
@

Below are the simple, nontheless frequently used functions and simple
values on {\rtl}s.

<<>>=
let width = function
    | Const(Bool _)     -> assert false
    | Const(Bits (_,w)) -> w
    | Const(Link (_,w)) -> w
    | Fetch(_,w)        -> w
    | App _             -> assert false (* not implemented *)
    
let assign l r = Rtl [(const truth, Store(l, r, width r))]
@



