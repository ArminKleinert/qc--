
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Target Platform Description}
% ------------------------------------------------------------------ 

{\qcc} is a cross compiler:  code can be generated for a target
platform different from the platform the compiler is executed on.  The
target platform can be chosen at run-time of the compiler. 
Consequently, targets must be described by an {\ocaml} value that can
be passed at run-time (rather than by a module, which can not). 

<<target2.mli>>=
<<type cc>>
<<type map>>
<<type t>>
val dummy: t        (* our only target for now *)
@

<<type t>>=
type t = { <<components of t>> }
@

A target is described by many small informations like pointer sizes
and one bigger chunk that describe calling conventions.  A single
platform can implement many calling conventions, which are identified
by names.  Calling conventions are not only selected at run-time, we
also intend to construct them at run-time.  For the time being,
however, we will rely on a fixed set of calling conventions.  

% ------------------------------------------------------------------ 
\subsection{Calling Convention}
% ------------------------------------------------------------------ 

A calling convention includes specifications for automata that
implement calling conventions.  In {\PAL} parameters are passed in
three different contexts:  into procedures, into continuations, and
out of both using [[return]].  Therefore, three different
specifications exist.

<<type cc>>=
type cc =      
    { sp:       Rtl.loc           (* stack pointer                             *)
    ; return:   Rtl.rtl           (* return machine instr passed to Cfg.return *)
    ; proc:     Automaton.spec    (* pass parameter to a procedure      *)
    ; cont:     Automaton.spec    (* pass parameter to a contunation    *)
    ; ret:      Automaton.spec    (* return values                      *)
    }
@

To obtain a calling convention, pass its name to the [[cc]] component
which will return the convention response.  It is a checked run-time
error to ask for an unknown calling convention.

<<components of t>>=
cc: string -> cc; (* raises Error.Exn if name is unknown *)
@

% ------------------------------------------------------------------ 
\subsection{Bits and Pieces}
% ------------------------------------------------------------------ 

Many of the following characteristics of a target are more or less
obvious.  A {\PAL} source can name hardware registers for variables. 
The [[register]] component provides the location for a given name.  We
could remember the width for type checking as well but ee are wearing
our assembler hats for now.

<<components of t>>=
byteorder:      Rtl.aggregation   ; (* big/little endian, id *)
wordsize:       int               ; (* bits *)
pointersize:    int               ; (* bits *)
memsize:        int               ; (* smallest addressable unit, typically 8 *)
float:          string            ; (* "ieee754" float representation    *)
charset:        string            ; (* "latin1"  character encoding      *)
globals:        Automaton.spec    ; (* Automaton to allocate global vars *)
register:       string -> Rtl.loc ; (* rtl for named hardware register   *)
                                    (*XXX Register.t instead? *)          
@

A target has many address spaces:  main memory, different register
sets, temporaries.  A [[Rtl.loc]] value describes a location within
such a space.  Each space is homogeneous in the sense that all its
cells have the same width.  When cells within one space are aggregated
a common aggregation scheme is used, described by a space-specific
[[Rtl.aggregation]] value.  The cells within a space are addressed by
an integer expression denoting their \emph{address}.  All address
expressions for a space share a common width.  For example, memory
might by addressed by 32-bit wide addresses, registers by 5-bit wide
addresses. 
                
The [[space]] function returns a description of a given space.  It is
a checked run-time error to ask for the description of an unknown
space.

<<components of t>>=
space:          Rtl.space -> Rtl.spacedescr;
@

\begin{quote}\it
    Target properties like [[pointersize]], or [[memsize]] are just
    properties of the [[m]] [[space]]. I like the more general idea
    of address spaces but I'm not sure whether we should get rid of the
    more specialized properties or should keep them as abbreviations.
    The hole problem stems from the fact that I only over time begin
    to understand what describes a target. --CL
\end{quote}

% ------------------------------------------------------------------ 
\subsection{RTLs for the Control-Flow Graph}
% ------------------------------------------------------------------ 

The nodes in the control-flow graph (module \module{cfg}) contain
target-specific {\rtl}s.  For example, a [[jump]] node takes an {\rtl}
and not an expression for the target.  The construction of these
{\rtl}s is target specific and so we provide [[embed]] functions that
allows to do it.  For debugging of the {\cfg} we also like to
re-construct the expressions from these {\rtl}s.  We provide matching
[[project]] functions to obtain the original expressions \emph{if the
supplied {\rtl}s} were constructed by the construction functions.  Any
attempt to do otherwise results in an unchecked run-time error. 

<<type map>>=
type 'a map =   { embed:    ('a -> Rtl.rtl)
                ; project:  (Rtl.rtl -> 'a)
                }
<<components of t>>=
goto:           Rtl.exp map ;
jump:           Rtl.exp map ;
cutto:          Rtl.exp map ;
call:           Rtl.exp map ;
branch:         (Rtl.exp * Rtl.exp) map;
@

% ------------------------------------------------------------------ 
\subsection{Temporaries, Register Allocation}
% ------------------------------------------------------------------ 

The register allocator (see \module{linscan}) needs target-specific
informations about hardware registers and temporaries. In particular:

<<components of t>>=
fits:           Rtl.space -> Register.t -> bool;
is_tmp:         Rtl.space -> bool;
allocatable:    Register.t list;
@

\begin{itemize}
\item [[fits sp r]] is true, if (hardware) register [[r]] can hold any 
      value from space [[sp]].

\item [[is_tmp sp]] is true, if [[sp]] denotes a {\rtl} space that
      holds temporaries.

\item [[allocatable]] is the list of registers that are available for 
      register allocation on this platform.
\end{itemize}

In general temporaries come in different widths, for example 8, 16,
and 32 bit.  These belong to different spaces and only the target
knows how they are related.  Therefore only the target can provide a
function that creates new temporaries.

<<components of t>>=
mk_tmp:         Register.t -> Register.t        (* Invalid_argument *)
@

The function [[mk_tmp r]] creates a new temporary for register [[r]].
A target typically supports temporaries only for certain registers
widths. If [[r]] is not supported this is a check run-time error and
[[Invalid_argument]] will be raised.

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation does not hold any surprises. We use module [[Map]]
to implement lookup tables for registers and calling conventions.

<<target2.ml>>=
module R       = Rtl
module StrMap  = Map.Make(struct type t=string let compare=compare end)
module CharMap = Map.Make(struct type t=char   let compare=compare end)

module MapUtil (M: Map.S) = struct
    let lookup map key =
        try  M.find key map 
        with Not_found -> Impossible.impossible ("Target.lookup key not found")

    let list2map assoc =
        let add map (key,value) = M.add key value map in
        List.fold_left add M.empty assoc  
end

module StrUtil  = MapUtil(StrMap)
module CharUtil = MapUtil(CharMap) 

<<type map>>
<<type cc>>
<<type t>>

module D = struct
    <<module D>>
end

let dummy = D.t
@

% ------------------------------------------------------------------ 
\subsection{Dummy Target}
% ------------------------------------------------------------------ 

<<module D>>=
let m = { embed   = (fun _ -> assert false)
        ; project = (fun _ -> assert false)
        }

let spaces = CharUtil.list2map
    [('m',{ R.cellwidth   = Dummy.wordsize
          ; R.byteorder   = Dummy.byteorder 
          ; R.addrwidth   = Dummy.pointersize
          })
          
    ;('t',{ R.cellwidth   = 32
          ; R.byteorder   = Rtl.Identity
          ; R.addrwidth   = 16
          })
    
    ;('u',{ R.cellwidth   = 16
          ; R.byteorder   = Rtl.Identity
          ; R.addrwidth   = 16
          })
    
    ;('v',{ R.cellwidth   = 8
          ; R.byteorder   = Rtl.Identity
          ; R.addrwidth   = 16
          })
    ]      
    

let tmp_counter = ref 0     

let new_tmp (sp,index,width) =
    incr tmp_counter;
    match width with
    | 8  -> ('v',!tmp_counter,width)
    | 16 -> ('u',!tmp_counter,width)
    | 32 -> ('t',!tmp_counter,width)
    | _  -> invalid_arg "unsupported register width in target2.nw"
    
let t = 
    { byteorder       = Dummy.byteorder         
    ; wordsize        = Dummy.wordsize
    ; pointersize     = Dummy.pointersize
    ; memsize         = Dummy.memsize
    ; float           = Dummy.float
    ; charset         = Dummy.charset
    ; globals         = Automaton.dummy
    ; register        = StrUtil.lookup StrMap.empty (* no registers *)
    ; goto            = m
    ; jump            = m
    ; cutto           = m
    ; call            = m
    ; branch          = m
    ; cc              = StrUtil.lookup StrMap.empty
    ; fits            = (fun sp (sp',index,width) -> sp = sp')
    ; is_tmp          = (fun sp -> sp = 't')
    ; allocatable     = [] (* need something more sensible *)
    ; space           = CharUtil.lookup spaces 
    ; mk_tmp          = new_tmp 
    }
@
        
