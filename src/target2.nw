
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Target Platform Description}
% ------------------------------------------------------------------ 

{\qcc} is a cross compiler:  code can be generated for a target
platform different from the platform the compiler is executed on.  The
target platform can be chosen at run-time of the compiler. 
Consequently, targets must be described by an {\ocaml} value that can
be passed at run-time (rather than by a module, which can not). 

<<target2.mli>>=
<<type cc>>
<<type map>>
<<type t>>
val dummy: t        (* our only target for now *)
@

<<type t>>=
type t = { <<components of t>> }
@

A target is described by many small informations like pointer sizes
and one bigger chunk that describe calling conventions.  A single
platform can implement many calling conventions, which are identified
by names.  Calling conventions are not only selected at run-time, we
also intend to construct them at run-time.  For the time being,
however, we will rely on a fixed set of calling conventions.  

A calling convention includes specifications for automata that
implement calling conventions.  In {\PAL} parameters are passed in
three different contexts:  into procedures, into continuations, and
out of both using [[return]].  Therefore, three different
specifications exist.

<<type cc>>=
type cc =      
    { sp:       Rtl.loc           (* stack pointer                             *)
    ; return:   Rtl.rtl           (* return machine instr passed to Cfg.return *)
    ; proc:     Automaton.spec    (* pass parameter to a procedure      *)
    ; cont:     Automaton.spec    (* pass parameter to a contunation    *)
    ; ret:      Automaton.spec    (* return values                      *)
    }
@

To obtain a calling convention, pass its name to the [[cc]] component
which will return the convention response.  It is a checked run-time
error to ask for an unknown calling convention.

<<components of t>>=
cc: string -> cc; (* raises Error.Exn if name is unknown *)
@

Many of the following characteristics of a target are more or less
obvious.  A {\PAL} source can name hardware registers for variables. 
The [[register]] component provides the location for a given name.  We
could remember the width for type checking as well but ee are wearing
our assembler hats for now.

<<components of t>>=
byteorder:      Rtl.aggregation   ; (* big/little endian, id *)
wordsize:       int               ; (* bits *)
pointersize:    int               ; (* bits *)
memsize:        int               ; (* smallest addressable unit, typically 8 *)
float:          string            ; (* "ieee754" float representation    *)
charset:        string            ; (* "latin1"  character encoding      *)
globals:        Automaton.spec    ; (* Automaton to allocate global vars *)
register:       string -> Rtl.loc ; (* rtl for named hardware register   *)
@

The nodes in the control-flow graph (module \module{cfg}) contain
target-specific {\rtl}s.  For example, a [[jump]] node takes an {\rtl}
and not an expression for the target.  The construction of these
{\rtl}s is target specific and so we provide [[embed]] functions that
allows to do it.  For debugging of the {\cfg} we also like to
re-construct the expressions from these {\rtl}s.  We provide matching
[[project]] functions to obtain the original expressions \emph{if the
supplied {\rtl}s} were constructed by the construction functions.  Any
attempt to do otherwise results in an unchecked run-time error. 

<<type map>>=
type 'a map =   { embed:    ('a -> Rtl.rtl)
                ; project:  (Rtl.rtl -> 'a)
                }
<<components of t>>=
goto:           Rtl.exp map ;
jump:           Rtl.exp map ;
cutto:          Rtl.exp map ;
call:           Rtl.exp map ;
branch:         (Rtl.exp * Rtl.exp) map;
@

The register allocator (see \module{linscan}) needs target-specific
informations about hardware registers and temporaries. In particular:

<<components of t>>=
fits:           Rtl.space -> Register.t -> bool;
is_tmp:         Rtl.space -> bool;
@

\begin{itemize}
\item [[fits sp r]] is true, if (hardware) register [[r]] can hold any 
      value from space [[sp]].

\item [[is_tmp sp]] is true, if [[sp]] denotes a {\rtl} space that
      holds temporaries.
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation does not hold any surprises. We use module [[Map]]
to implement lookup tables for registers and calling conventions.

<<target2.ml>>=
module StrMap = Map.Make(struct type t=string let compare=compare end)
<<type map>>
<<type cc>>
<<type t>>
<<dummy>>
@

<<dummy>>=
let lookup map key =
    try  StrMap.find key map 
    with Not_found -> Impossible.impossible ("Target.lookup "^key^" not found")

let list2map assoc =
    let add map (key,value) = StrMap.add key value map in
    List.fold_left add StrMap.empty assoc  

let m = { embed   = (fun _ -> assert false)
        ; project = (fun _ -> assert false)
        }
    
let dummy: t = 
    { byteorder       = Dummy.byteorder
    ; wordsize        = Dummy.wordsize
    ; pointersize     = Dummy.pointersize
    ; memsize         = Dummy.memsize
    ; float           = Dummy.float
    ; charset         = Dummy.charset
    ; globals         = Automaton.dummy
    ; register        = lookup StrMap.empty (* no registers *)
    ; goto            = m
    ; jump            = m
    ; cutto           = m
    ; call            = m
    ; branch          = m
    ; cc              = lookup StrMap.empty
    ; fits            = (fun sp (sp',index,width) -> sp = sp')
    ; is_tmp          = (fun sp -> sp = 't')
    }
@
        
