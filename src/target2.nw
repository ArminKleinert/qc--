
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Target Platform Description}
% ------------------------------------------------------------------ 

{\qcc} is a cross compiler:  code can be generated for a target
platform different from the platform the compiler is executed on.  The
target platform can be chosen at run-time of the compiler. 
Consequently, targets must be described by an {\ocaml} value that can
be passed at run-time (rather than by a module, which can not). 

<<target2.mli>>=
<<type cc>>
<<type map>>
<<type t>>
val dummy: t        (* our only target for now *)
@

<<type t>>=
type t = { <<components of t>> }
@

A target is described by many small informations like pointer sizes
and one bigger chunk that describe calling conventions.  A single
platform can implement many calling conventions, which are identified
by names.  Calling conventions are not only selected at run-time, we
also intend to construct them at run-time.  For the time being,
however, we will rely on a fixed set of calling conventions.  

% ------------------------------------------------------------------ 
\subsection{Calling Convention}
% ------------------------------------------------------------------ 

A calling convention includes specifications for automata that
implement calling conventions.  In {\PAL} parameters are passed in
three different contexts:  into procedures, into continuations, and
out of both using [[return]].  Therefore, three different
specifications exist.

<<type cc>>=
type cc =      
    { sp:       Rtl.loc         (* stack pointer                      *)
    ; return:   Rtl.rtl         (* return machine instr passed to Cfg.return *)
    ; proc:     Automaton.spec  (* pass parameter to a procedure      *)
    ; cont:     Automaton.spec  (* pass parameter to a contunation    *)
    ; ret:      Automaton.spec  (* return values                      *)
    }
@

To obtain a calling convention, pass its name to the [[cc]] component
which will return the convention response.  It is a checked run-time
error to ask for an unknown calling convention.

<<components of t>>=
cc: string -> cc; (* raises Error.Exn if name is unknown *)
@

% ------------------------------------------------------------------ 
\subsection{Bits and Pieces}
% ------------------------------------------------------------------ 

Many of the following characteristics of a target are more or less
obvious.  A {\PAL} source can name hardware registers for variables. 
The [[register]] component provides the location for a given name.  We
could remember the width for type checking as well but ee are wearing
our assembler hats for now.

<<components of t>>=
byteorder:      Rtl.aggregation   ; (* big/little endian, id *)
wordsize:       int               ; (* bits *)
pointersize:    int               ; (* bits *)
memsize:        int               ; (* smallest addressable unit, typically 8 *)
float:          string            ; (* "ieee754" float representation    *)
charset:        string            ; (* "latin1"  character encoding      *)
globals:        Automaton.spec    ; (* Automaton to allocate global vars *)
register:       string -> Rtl.loc ; (* rtl for named hardware register   *)
                                    (*XXX Register.t instead? *)          
@

A target has many address spaces:  main memory, different register
sets, temporaries.  A [[Rtl.loc]] value describes a location within
such a space.  Each space is homogeneous in the sense that all its
cells have the same width.  When cells within one space are aggregated
a common aggregation scheme is used, described by a space-specific
[[Rtl.aggregation]] value.  The cells within a space are addressed by
an integer expression denoting their \emph{address}.  All address
expressions for a space share a common width.  For example, memory
might by addressed by 32-bit wide addresses, registers by 5-bit wide
addresses. 
                
The [[space]] function returns a description of a given space.  It is
a checked run-time error to ask for the description of an unknown
space.

<<components of t>>=
space:          Rtl.space -> Rtl.spacedescr;
@

\begin{quote}\it
    Target properties like [[pointersize]], or [[memsize]] are just
    properties of the [[m]] [[space]]. I like the more general idea
    of address spaces but I'm not sure whether we should get rid of the
    more specialized properties or should keep them as abbreviations.
    The hole problem stems from the fact that I only over time begin
    to understand what describes a target. --CL
\end{quote}

% ------------------------------------------------------------------ 
\subsection{RTLs for the Control-Flow Graph}
% ------------------------------------------------------------------ 

The nodes in the control-flow graph (module \module{cfg}) contain
target-specific {\rtl}s.  For example, a [[jump]] node takes an {\rtl}
and not an expression for the target.  The construction of these
{\rtl}s is target specific and so we provide [[embed]] functions that
allows to do it.  For debugging of the {\cfg} we also like to
re-construct the expressions from these {\rtl}s.  We provide matching
[[project]] functions to obtain the original expressions \emph{if the
supplied {\rtl}s} were constructed by the construction functions.  Any
attempt to do otherwise results in an unchecked run-time error. 

<<type map>>=
type 'a map =   { embed:    ('a -> Rtl.rtl)
                ; project:  (Rtl.rtl -> 'a)
                }
<<components of t>>=
goto:           Rtl.exp map ;
jump:           Rtl.exp map ;
cutto:          Rtl.exp map ;
call:           Rtl.exp map ;
branch:         (Rtl.exp * Rtl.exp) map;
@

% ------------------------------------------------------------------ 
\subsection{Temporaries, Register Allocation}
% ------------------------------------------------------------------ 

The register allocator (see \module{linscan}) needs target-specific
informations about hardware registers and temporaries. In particular:

<<components of t>>=
fits:           Rtl.space -> Register.t -> bool;
is_tmp:         Rtl.space -> bool;
allocatable:    Register.t list;
@

\begin{itemize}
\item [[fits sp r]] is true, if (hardware) register [[r]] can hold any 
      value from space [[sp]].

\item [[is_tmp sp]] is true, if [[sp]] denotes a {\rtl} space that
      holds temporaries.

\item [[allocatable]] is the list of registers that are available for 
      register allocation on this platform.
\end{itemize}

In general temporaries come in different widths, for example 8, 16,
and 32 bit.  These belong to different spaces and only the target
knows how they are related.  Therefore only the target can provide a
function that creates new temporaries.

<<components of t>>=
mk_tmp:         Register.t -> Register.t;       (* Invalid_argument *)
@

The function [[mk_tmp r]] creates a new temporary for register [[r]].
A target typically supports temporaries only for certain registers
widths. If [[r]] is not supported this is a checked run-time error and
[[Invalid_argument]] will be raised.

The [[assign]] function creates an [[Rtl.rtl]] that transfers a value
from one register to another.  The source and destination must be
assignment compatible, otherwise it is a checked run-time error which
raises an [[Invalid_argument]] exception.  The first argument is a
lookup-function that provides information about the spaces the source
and destination registers live in.

<<components of t>>=
assign: (Rtl.space -> Rtl.spacedescr) -> src:Register.t -> dst:Register.t -> Rtl.rtl;
@

When the register allocator (see ~module{linscan}) must spill, it has
to create {\rtl}s that move values from registers to memory (spill)
and vice versa (reloads).  Here are two functions to create such
{\rtl}s:

<<components of t>>=
spill:  (Rtl.space -> Rtl.spacedescr) -> Register.t -> Rtl.loc ->Rtl.rtl list;
reload: (Rtl.space -> Rtl.spacedescr) -> Register.t -> Rtl.loc ->Rtl.rtl list;
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation does not hold any surprises. We use module [[Map]]
to implement lookup tables for registers and calling conventions.

<<target2.ml>>=
module R       = Rtl
module RP      = Rtl.Private
module StrMap  = Map.Make(struct type t=string let compare=compare end)
module CharMap = Map.Make(struct type t=char   let compare=compare end)

module MapUtil (M: Map.S) = struct
    let lookup map key =
        try  M.find key map 
        with Not_found -> Impossible.impossible ("Target.lookup key not found")

    let list2map assoc =
        let add map (key,value) = M.add key value map in
        List.fold_left add M.empty assoc  
end

module StrUtil  = MapUtil(StrMap)
module CharUtil = MapUtil(CharMap) 

<<type map>>
<<type cc>>
<<type t>>

module D = struct
    <<module D>>
end

let dummy = D.t
@

% ------------------------------------------------------------------ 
\subsection{Dummy Target}
% ------------------------------------------------------------------ 

\begin{center}
    \begin{tabular}{ll}
    \hline
    \multicolumn{2}{c}{Memory Space \emph{R}}\\
    \hline
    Cellwidth    & 32                    \\
    Byteorder    & indentity             \\
    Addresswidth & 5                     \\
    \hline
    Index        & Purpose               \\
    \hline
    0            & PC                    \\
    1            & SP                    \\
    2            & Return                \\
    \dots        & general purpose       \\
    \end{tabular}
\end{center}    


<<module D>>=
let m = { embed   = (fun _ -> assert false)
        ; project = (fun _ -> assert false)
        }


let const n width = Rtl.bits (Bits.of_int n width) width
let reg n         = Rtl.cell Rtl.none 'r' Rtl.Identity 5 (const n 5)
let assign loc e  = Rtl.store loc e (Rtlutil.width e)       
    
(* this is total nonsense - it's just for toying around *)

let goto_embed e     = assign (reg 0) e
let goto_project rtl = match R.Convert.rtl rtl with
    | RP.Rtl([(_,RP.Store(loc,exp,width))]) -> R.Revert.exp exp
    | _                                     -> assert false


let goto =
    { embed   = goto_embed
    ; project = goto_project
    }

let branch_embed (e,addr) = R.guard e (assign (reg 0) addr)
let branch_project rtl  = match R.Convert.rtl rtl with
    | RP.Rtl([(e,RP.Store(loc,addr,width))]) -> ( R.Revert.exp e
                                                , R.Revert.exp addr
                                                )
    | _                                      -> assert false

let branch =
    { embed   = branch_embed
    ; project = branch_project
    }


let cc =
    { sp      = reg 1
    ; return  = assign (reg 2) (R.fetch (reg 1) 32)
    ; proc    = Automaton.dummy
    ; cont    = Automaton.dummy
    ; ret     = Automaton.dummy
    }


let spaces = CharUtil.list2map
    [('r',{ R.cellwidth   = 32
          ; R.byteorder   = Rtl.Identity
          ; R.addrwidth   = 5
          }) 

    ;('m',{ R.cellwidth   = Dummy.wordsize
          ; R.byteorder   = Dummy.byteorder 
          ; R.addrwidth   = Dummy.pointersize
          })
          
    ;('t',{ R.cellwidth   = 32
          ; R.byteorder   = Rtl.Identity
          ; R.addrwidth   = 16
          })
    
    ;('u',{ R.cellwidth   = 16
          ; R.byteorder   = Rtl.Identity
          ; R.addrwidth   = 16
          })
    
    ;('v',{ R.cellwidth   = 8
          ; R.byteorder   = Rtl.Identity
          ; R.addrwidth   = 16
          })
    ]      
    

let tmp_counter = ref 0     

let new_tmp (sp,index,width) =
    incr tmp_counter;
    match width with
    | 8  -> ('v',!tmp_counter,width)
    | 16 -> ('u',!tmp_counter,width)
    | 32 -> ('t',!tmp_counter,width)
    | _  -> invalid_arg "unsupported register width in target2.nw"
@

The [[assign]] function converts both registers to [[Rtl.loc]] values and
then uses the [[Rtl]] framework to create an assignment.    

<<module D>>=
let assign lookup ~src:(src_sp,_,src_w as src) ~dst:(dst_sp,_,dst_w as dst) =
    if src_w <> dst_w then
        invalid_arg "Target2.assign source and destination width don't match"
    else
        let src_loc = Register.to_loc lookup src  in
        let dst_loc = Register.to_loc lookup dst  in
            Rtl.store dst_loc (Rtl.fetch src_loc src_w)  dst_w

let spill lookup ~reg:(sp,index,width as reg) ~loc =
    if Rtlutil.locwidth loc <> width then
        invalid_arg "Target2.spill size mismatch"
    else
        let reg_loc = Register.to_loc lookup reg in
        let rtl     = Rtl.store loc (Rtl.fetch reg_loc width) width in
            [rtl]

let reload lookup ~reg:(sp,index,width as reg) ~loc =
    if Rtlutil.locwidth loc <> width then
        invalid_arg "Register.spill size mismatch"
    else
        let reg_loc = Register.to_loc lookup reg  in
        let rtl     = Rtl.store reg_loc (Rtl.fetch loc width) width in
            [rtl]
    
let t = 
    { byteorder       = Dummy.byteorder         
    ; wordsize        = Dummy.wordsize
    ; pointersize     = Dummy.pointersize
    ; memsize         = Dummy.memsize
    ; float           = Dummy.float
    ; charset         = Dummy.charset
    ; globals         = Automaton.dummy
    ; register        = StrUtil.lookup StrMap.empty (* no registers *)
    ; goto            = goto
    ; jump            = goto
    ; cutto           = goto
    ; call            = goto
    ; branch          = branch
    ; cc              = StrUtil.lookup (StrUtil.list2map [("C--",cc)])
    ; fits            = (fun sp (sp',index,width) -> sp = sp')
    ; is_tmp          = (fun sp -> sp = 't')
    ; allocatable     = [] (* need something more sensible *)
    ; space           = CharUtil.lookup spaces 
    ; mk_tmp          = new_tmp 
    ; assign          = assign
    ; spill           = spill
    ; reload          = reload
    }
@
        
