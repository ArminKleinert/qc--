
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Target Platform Description}
% ------------------------------------------------------------------ 

{\qcc} is a cross compiler:  code can be generated for a target
platform different from the platform the compiler is executed on.  The
target platform can be chosen at run-time of the compiler. 
Consequently, targets must be described by an {\ocaml} value that can
be passed at run-time (rather than by a module, which can not). 

<<target2.mli>>=
<<type cc>>
<<type t>>
val dummy: t        (* our only target for now *)
@

<<type t>>=
type t = { <<components of t>> }
@

A target is described by many small informations like pointer sizes
and one bigger chunk that describe calling conventions.  A single
platform can implement many calling conventions, which are identified
by names.  Calling conventions are not only selected at run-time, we
also intend to construct them at run-time.  For the time being,
however, we will rely on a fixed set of calling conventions.  

A calling convention includes specifications for automata that
implement calling conventions.  In {\PAL} parameters are passed in
three different contexts:  into procedures, into continuations, and
out of both using [[return]].  Therefore, three different
specifications exist.

<<type cc>>=
type cc =      
    { sp:       Rtl.loc     (* stack pointer                             *)
    ; return:   Rtl.rtl     (* return machine instr passed to Cfg.return *)
    ; proc:     Automaton2.spec    (* call a proc                        *)
    ; cont:     Automaton2.spec    (* call a continuation                *)
    ; ret:      Automaton2.spec    (* return values                      *)
    }
@

To obtain a calling convention, pass its name to the [[cc]] component
which will return ithe concention response.  It is a checked run-time
error to ask for an unknown calling convention.

<<components of t>>=
cc: string -> cc; (* raises Error.Exn if name is unknown *)
@

Many of the following characteristics of a target are more or less
obvious.  A {\PAL} source can name hardware registers for variables. 
The [[register]] component provides the location for a given name.  We
could remember the width for type checking as well but ee are wearing
our assembler hats for now.

<<components of t>>=
byteorder:      Rtl.aggregation   ; (* big/little endian, id *)
wordsize:       int               ; (* bits *)
pointersize:    int               ; (* bits *)
memsize:        int               ; (* smallest addressable unit, typically 8 *)
float:          string            ; (* "ieee754" float representation    *)
charset:        string            ; (* "latin1"  character encoding      *)
globals:        Automaton2.spec   ; (* Automaton to allocate global vars *)
register:       string -> Rtl.loc ; (* rtl for named hardware register   *)
@

The nodes in the control-flow graph (module \module{cfg}) contain
target-specific {\rtl}s.  For example, a [[jump]] node takes an {\rtl}
and not an expression for the target.  The construction of these
{\rtl}s is target specific and so we provide functions that allows to
do it.

For debugging of the {\cfg} we also like to re-construct the
expressions from these {\rtl}s.  We provide matching functions to
obtain the original expressions \emph{if the supplied {\rtl}s} were
constructed by the construction functions}.  Any attempt to do
otherwise is considered an internal error.

<<components of t>>=
mkGoto:         Rtl.exp -> Rtl.rtl ;
matchGoto:      Rtl.rtl -> Rtl.exp ;
mkJump:         Rtl.exp -> Rtl.rtl ;
matchJump:      Rtl.rtl -> Rtl.exp ;
mkCutto:        Rtl.exp -> Rtl.rtl ;
matchCutto:     Rtl.rtl -> Rtl.exp ;
mkCall:         Rtl.exp -> Rtl.rtl ;
matchCall:      Rtl.rtl -> Rtl.exp ;
mkBranch:       Rtl.exp -> Rtl.rtl ;
matchBranch:    Rtl.rtl -> Rtl.exp ;
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation does not hold any surprises. We use module [[Map]]
to implement lookup tables for registers and calling conventions.

<<target2.ml>>=
module StrMap = Map.Make(struct type t=string let compare=compare end)

<<type cc>>
<<type t>>
<<dummy>>
@

<<dummy>>=
let lookup map key =
    try  StrMap.find key map 
    with Not_found -> Impossible.impossible ("Target.lookup "^key^" not found")


let list2map assoc =
    let add map (key,value) = StrMap.add key value map in
    List.fold_left add StrMap.empty assoc  

(*    
let dummy_cc = 
    { sp     = ??
    ; return = ??
    ; proc   = Automaton2.dummy
    ; cont   = Automaton2.dummy
    ; retn   = Automaton2.dummy
    }
*)

    
let dummy: t = 
    { byteorder       = Dummy.byteorder
    ; wordsize        = Dummy.wordsize
    ; pointersize     = Dummy.pointersize
    ; memsize         = Dummy.memsize
    ; float           = Dummy.float
    ; charset         = Dummy.charset
    ; globals         = Impossible.unimp "target.dummy"
    ; register        = lookup StrMap.empty (* no registers *)
    ; mkGoto          = (fun _ -> Impossible.unimp "target.dummy")
    ; matchGoto       = (fun _ -> Impossible.unimp "target.dummy")
    ; mkJump          = (fun _ -> Impossible.unimp "target.dummy")
    ; matchJump       = (fun _ -> Impossible.unimp "target.dummy")
    ; mkCutto         = (fun _ -> Impossible.unimp "target.dummy")
    ; matchCutto      = (fun _ -> Impossible.unimp "target.dummy")
    ; mkCall          = (fun _ -> Impossible.unimp "target.dummy")
    ; matchCall       = (fun _ -> Impossible.unimp "target.dummy")
    ; mkBranch        = (fun _ -> Impossible.unimp "target.dummy")
    ; matchBranch     = (fun _ -> Impossible.unimp "target.dummy")
    ; cc              = lookup StrMap.empty
    }
@
        
