% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Target Platform Description}
% ------------------------------------------------------------------ 

{\qcc} is a cross compiler:  code can be generated for a target
platform different from the platform the compiler is executed on.  The
target platform can be chosen at run-time of the compiler. 
Consequently, targets must be described by an {\ocaml} value that can
be passed at run-time (rather than by a module, which can not). 

<<target2.mli>>=
<<type cc>>
<<type map>>
<<type t>>
val space : t -> Rtl.space -> Space.t
@ The [[space]] function returns information about a particular space.
It is a checked run-time error to ask about a space not on the list
for the target.
@
<<type t>>=
type t = { <<components of t>> }
@

A target is described by many small informations like pointer sizes
and one bigger chunk that describe calling conventions.  A single
platform can implement many calling conventions, which are identified
by names.  Calling conventions are not only selected at run-time, we
also intend to construct them at run-time.  For the time being,
however, we will rely on a fixed set of calling conventions.  

% ------------------------------------------------------------------ 
\subsection{Calling Convention}
% ------------------------------------------------------------------ 

A calling convention includes specifications for automata that
implement calling conventions.  In {\PAL} parameters are passed in
three different contexts:  into procedures, into continuations, and
out of both using [[return]].  Therefore, three different
specifications exist.

<<type cc>>=
type cc =      
    { sp:       Rtl.loc         (* stack pointer                      *)
    ; return:   Rtl.rtl         (* return machine instr passed to Cfg.return *)
    ; proc:     Automaton.spec  (* pass parameter to a procedure      *)
    ; cont:     Automaton.spec  (* pass parameter to a contunation    *)
    ; ret:      Automaton.spec  (* return values                      *)
    }
@

To obtain a calling convention, pass its name to the [[cc]] component
which will return the convention response.  It is a checked run-time
error to ask for an unknown calling convention.

<<components of t>>=
cc: string -> cc; (* raises Error.Exn if name is unknown *)
@

% ------------------------------------------------------------------ 
\subsection{Bits and Pieces}
% ------------------------------------------------------------------ 

Many of the following characteristics of a target are more or less
obvious.  A {\PAL} source can name hardware registers for variables. 
The [[register]] component provides the location for a given name.  We
could remember the width for type checking as well but ee are wearing
our assembler hats for now.

<<components of t>>=
byteorder:      Rtl.aggregation   ; (* big/little endian, id *)
wordsize:       int               ; (* bits *)
pointersize:    int               ; (* bits *)
memsize:        int               ; (* smallest addressable unit, typically 8 *)
float:          string            ; (* "ieee754" float representation    *)
charset:        string            ; (* "latin1"  character encoding      *)
globals:        Automaton.spec    ; (* Automaton to allocate global vars *)
register:       string -> Rtl.loc ; (* rtl for named hardware register   *)
                                    (*XXX Register.t instead? *)          
@

A target has many address spaces:  main memory, different register
sets, temporaries.  A [[Rtl.loc]] value describes a location within
such a space.  Each space is homogeneous in the sense that all its
cells have the same width.  When cells within one space are aggregated
a common aggregation scheme is used, described by a space-specific
[[Rtl.aggregation]] value.  The cells within a space are addressed by
an integer expression denoting their \emph{address}.  All address
expressions for a space share a common width.  For example, memory
might by addressed by 32-bit wide addresses, registers by 5-bit wide
addresses. 
                
The [[spaces]] list enumerates all spaces used to compile for the
machine, including temporary spaces as well as the real hardware
spaces.
No space appears more than once on the list.
<<components of t>>=
spaces:          Space.t list;
@

\begin{quote}\it
    Target properties like [[pointersize]], or [[memsize]] are just
    properties of the [[m]] [[space]]. I like the more general idea
    of address spaces but I'm not sure whether we should get rid of the
    more specialized properties or should keep them as abbreviations.
    The whole problem stems from the fact that I only over time begin
    to understand what describes a target. --CL
\end{quote}

<<components of t>>=
data_section:   string;          (* ASM section for global regs *)
@

Code goes into the \emph{text} section, memory allocated for global
registers goes into the [[data_section]].

% ------------------------------------------------------------------ 
\subsection{RTLs for the Control-Flow Graph}
% ------------------------------------------------------------------ 

The nodes in the control-flow graph (module \module{cfg}) contain
target-specific {\rtl}s.  For example, a [[jump]] node takes an {\rtl}
and not an expression for the target.  The construction of these
{\rtl}s is target specific and so we provide [[embed]] functions that
allows to do it.  For debugging of the {\cfg} we also like to
re-construct the expressions from these {\rtl}s.  We provide matching
[[project]] functions to obtain the original expressions \emph{if the
supplied {\rtl}s} were constructed by the construction functions.  Any
attempt to do otherwise results in an unchecked run-time error. 

<<type map>>=
type 'a map =   { embed:    ('a -> Rtl.rtl)
                ; project:  (Rtl.rtl -> 'a)
                }
<<components of t>>=
goto:           Rtl.exp map ;
jump:           Rtl.exp map ;
cutto:          Rtl.exp map ;
call:           Rtl.exp map ;
branch:         (Rtl.exp * Rtl.exp) map;
@

% ------------------------------------------------------------------ 
\subsection{Temporaries, Register Allocation}
% ------------------------------------------------------------------ 

The register allocator (see \module{linscan}) needs target-specific
informations about hardware registers and temporaries. In particular:

<<components of t>>=
fits:           Rtl.space -> Register.t -> bool;
is_tmp:         Rtl.space -> bool;
allocatable:    Register.t list;
@

\begin{itemize}
\item [[fits sp r]] is true, if (hardware) register [[r]] can hold any 
      value from space [[sp]].

\item [[is_tmp sp]] is true, if [[sp]] denotes a {\rtl} space that
      holds temporaries.

\item [[allocatable]] is the list of registers that are available for 
      register allocation on this platform.
\end{itemize}

In general temporaries come in different widths, for example 8, 16,
and 32 bit.  These belong to different spaces and only the target
knows how they are related.  Therefore only the target can provide a
function that creates new temporaries.

<<components of t>>=
mk_tmp:         Register.t -> Register.t;       (* Invalid_argument *)
@

The function [[mk_tmp r]] creates a new temporary for register [[r]].
A target typically supports temporaries only for certain registers
widths. If [[r]] is not supported this is a checked run-time error and
[[Invalid_argument]] will be raised.

The [[assign]] function creates an [[Rtl.rtl]] that transfers a value
from one register to another.  The source and destination must be
assignment compatible, otherwise it is a checked run-time error which
raises an [[Invalid_argument]] exception.  The first argument is a
lookup-function that provides information about the spaces the source
and destination registers live in.

<<components of t>>=
assign: (Rtl.space -> Space.t) 
    -> src:Register.t -> dst:Register.t -> Rtl.rtl;
@

When the register allocator (see ~module{linscan}) must spill, it has
to create {\rtl}s that move values from registers to memory (spill)
and vice versa (reloads).  Here are two functions to create such
{\rtl}s:
<<components of t>>=
spill:  (Rtl.space -> Space.t) -> Register.t -> Rtl.loc -> Rtl.rtl list;
reload: (Rtl.space -> Space.t) -> Register.t -> Rtl.loc -> Rtl.rtl list;
@ The RTLs should be returned in \emph{execution order}, i.e., the
first element of the list is the first to be executed.
@

% ------------------------------------------------------------------ 
\subsection{Resource Allocation on the Stack}
% ------------------------------------------------------------------ 

Continuations, spill locations and other private data of a procedures
lives on the run-time stack. These locations are register-like and
issued by an [[Automaton.t]] value. The specification for that automaton
is provided by the target.

<<components of t>>=
stack_slots:    Automaton.spec
@

% ------------------------------------------------------------------ 
\subsection{Compatibility with Source Code}
% ------------------------------------------------------------------ 

A {\PAL} source code advertises some target properties that of course
must match the actual target. The expected properties are recorded in
the fat environment (\module{fenv}). The [[check]] function compares an
actual target with the expectations in an environment and 
raises an error exception in case of inconsistencies.

<<target2.mli>>=
val check: t -> Fenv.Clean.env -> unit  (* Error.ErrorExn *)
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation does not hold any surprises. We use module [[Map]]
to implement lookup tables for registers and calling conventions.

<<target2.ml>>=
module R       = Rtl
module S       = Space
module RP      = Rtl.Private
module F       = Fenv.Clean

<<type map>>
<<type cc>>
<<type t>>

@

The [[check]] function compares expectations about a target recorded in
an fat environment with an actual target.

<<target2.ml>>=
let check (t:t) (env:F.env) =
    let itoa i = string_of_int i in
    let msg property source target = 
        Error.error ( "missmatch of "^property
             ^ " in source (" ^source
             ^ ") and target ("^target^")") in
    match F.findEndianness env, t.byteorder with
    | F.Big,   R.LittleEndian -> msg "byteorder" "little" "big"
    | F.Little, R.BigEndian    -> msg "byteorder" "big"    "little"
    | _ -> if F.findWordsize env <> t.wordsize then
        msg "wordsize" (itoa (F.findWordsize env)) (itoa t.wordsize)
    else if F.findMemsize env <> t.memsize then
        msg "memsize" (itoa (F.findMemsize env)) (itoa t.memsize)
    else if F.findPointersize env <> t.pointersize then
        msg "pointer size" (itoa (F.findPointersize env)) (itoa t.pointersize)
    else if F.findFloat env <> t.float then
        msg "floating point standard" (F.findFloat env) t.float
    else if F.findCharset env <> t.charset then
        msg "charset" (F.findCharset env) t.charset
    else
        ()
@
<<target2.ml>>=
let space t s = List.find (fun x -> x.Space.space = s) t.spaces
@
        
