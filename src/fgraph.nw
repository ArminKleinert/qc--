% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Data Flow Graph}
% ------------------------------------------------------------------ 

The abstract syntax of a {\PAL} procedure is translated into a flow
graph.  The graph consists of labeled entry nodes which point to other
nodes, which may or may not be labeled.  Internally, we wish to
represent a graph as a map from labels to nodes.  Because {\asdl}
cannot support this representation, we use a list of pairs.

<<fgraph.asdl>>=
module fgraph (imports rtl) {
    <<module fgraph>>
}
@

We might consider using an {\asdl} view to define the internal
representation, but there is a circularity problem:  the definition of
the internal representation would have to precede the {\asdl}
definition of [[graph]], because [[graph]] would depend on it.  But it
would have to follow the {\asdl} definition of [[label]], because
[[label]] must be the key in the map.  Because {\asdl} insists on
generating a single lump of code containing the definitions of both
[[graph]] and [[label]], this problem can't be solved easily.

We take the easy way out and use the evil ``epilogue'' to define
[[Ir.graph]], the rightful internal representation of flow graphs. 
This is done in the \module{views} module.

<<module fgraph>>=
xgraph      = (entry*)          -- external use only; use graph inside compiler.
entry       = (label,node)
@

A [[label]] is either a name or a number.  Numbers will be typically
used for automatically generated labels where names come from source
file labels.  A list of labels is used for lists of goto-targets and
continuations; these are uniformly called [[targets]].

<<module fgraph>>=
label       = Name      (string)
            | Number    (int)

targets     = (label*)
@

A node represents {\PAL} on an abstract level. For every statement a
corresponding node exists. Procedures are represented by [[CopyIn]]
and [[CopyOut]] nodes which model parameter passing into and out of
procedures. 

<<>>=
node        = Branch    (rtl.expr, label, label)
            | Exit      
            | Assign    (rtl.rtl, node)
            | Goto      (rtl.expr, targets)
            | Jump      (rtl.expr, targets)
            | Entry     (cont*, node)
            | Call      (rtl.expr, cont)
            | CopyIn    (formal*,context,convention,node)
            | CopyOut   (actual*,context,convention,node)
          --| Label     (label,node) -- should make code generation easier
@

A [[context]] describes where parameters are passed: into a procedure, out
of a procedure, or into a continuation.

<<>>=
context     = ProcParameters
            | ProcResults
            | ContParameters
@

A formal parameter is a variable, an actual parameter an expression. Both
can be hinted and have a [[width]], i.e.~a type.

<<>>=
formal      = (variable, rtl.width, hint?)
actual      = (rtl.expr, rtl.width, hint?)
@

Continutations [[cont]] come in bundles. 
 
<<>>=
boolean     = (int)  -- view

<<fgraph.view>>=
fgraph.boolean <= {
    natural_type:   bool
    wrapper:        to_bool
    unwrapper:      of_bool 
}
@

<<module fgraph>>=
cont        = ( node    normal
              , label*  cuts
              , label*  unwinds
              , label*  returns
              , boolean aborts
              )
@

<<>>=
variable    = (string)
hint        = (string)
convention  = (string)
@

% ------------------------------------------------------------------ 
\subsubsection{View}
% ------------------------------------------------------------------ 

The flow graph is internally represented as a mapping from labels to
nodes.  This representation is never used directly when a flow graph
is built but only through an interface like [[Agraph]] (module
\module{agraph}) that provides an abstract view.  We have chosen to
use an imperative approach, i.e.~the graph is manipulated with side
effects. 

The {\ocaml} standard module [[Hashtbl]] provides what we need except
that there is no [[fold]] function to easily read out an entire map. 
Until we have a more complete implementation we cheat a little bit and
do not provide an export for the view.  This does not matter for the
moment since we can't use it anyway:  a bug in the {\asdl} compiler
creates incorrect code for the marshalling routines when {\asdl} views
are used.

<<fgraph.view>>=
module fgraph <= interface_epilogue
%%
type graph = (label,node) Hashtbl.t
val  intern_graph : xgraph -> graph
val  extern_graph : graph  -> xgraph
%%
    
module fgraph <= implementation_epilogue
%%
type graph = (label, node) Hashtbl.t

let intern_graph entries =
    let map = Hashtbl.create 1000 in (* initial size - grows as needed *)
    let enter (label,node) = Hashtbl.add map label node in
        ( List.iter enter entries
        ; map
        )

let extern_graph map = [] (* this is a lie *)
%%
@

