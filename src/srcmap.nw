
% l2h substitution C C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml


% ------------------------------------------------------------------  
\section{Source Code Locations}\label{srcmap}
% ------------------------------------------------------------------  

The scanner (Section \ref{sec:scanner}) operates on a character
stream.  An offset from the beginning of the stream marks a
\textit{position} inside the stream; the first character in the stream
has position 0.  The parser (Section \ref{sec:parser}) takes positions
reported by the scanner to mark nodes in the abstract syntax with
regions.  A region is a pair of two positions and defines the span a
node covers in the source code.

Positions are easy to manipulate by a program but less useful for a
programmer who likes to think in terms of line numbers and columns in
a file.  A \textit{source map} translates source code
\textit{positions} into source code \textit{locations} that are made
up from

\begin{itemize}
\item a file name,
\item a line number in that file (first line has number 1),
\item and a column (first column is 1).
\end{itemize}

To establish the connection between simple positions and complex
locations these two views must be \textit{synchronized}.  The result
of all synchronizations is a source map.  The views must synchronize
whenever advancing in the stream of characters is different from
moving to the next column in the postion's view.  This happens
typically at the following points in a source code:

\begin{itemize} 
\item Beginning of a new line.
\item Changing of the input file, when the input comes from multiple 
      files.
\item A tab character skips some columns.
\item Some directive like [[#line]] from the C pre-processor
      indicates a non-linearity in the source code. 
\end{itemize}


A synchronization establishes a connection between a source code
position and a (filename, line, column) location in a source map.  The
point of synchronization is called a synchronization point. In
principle synchronization points can be placed in any order into a
stream of characters. The following restriction usually does not harm
and helps to to build efficient source maps: In the order
synchronization points are established the affected source code
positions are increasing. This means, that never a position to the
left of an existing synchronization point is synchronized.

Building and using a source map involves only few operations:

\begin{itemize}
\item Create an initially empty source map.
\item Enter synchronization points into the map.
\item As a special case, enter a sync point for a new line.
\item Return the location of a given position.
\item For debugging, we also provide a [[dum]] function that 
      prints out the contents of a source map.
\end{itemize}

To make any position meaningful, position 0 should be a synchronization
point. 

% ------------------------------------------------------------------  
\subsection{Interface}
% ------------------------------------------------------------------  

<<srcmap.mli>>= 

type position       = int
type location       = string    (* file   *)
                    * int       (* line   *)
                    * int       (* column *)

type srcmap

val empty :         srcmap
val sync :          srcmap -> position -> location -> unit
val nl :            srcmap -> position -> unit
val location :      srcmap -> position -> location
val dump:           srcmap -> unit
@

% ------------------------------------------------------------------  
\subsection{Implementation}
% ------------------------------------------------------------------  

A single compilation unit can easily contain some thousand lines of
code and at least as many synchronization points. An implementation
should thus pay attention to memory requirements and run time
performance. 

<<srcmap.ml>>=
type position       = int
type location       = string    (* file   *)
                    * int       (* line   *)
                    * int       (* column *)

@ A [[syncpoint]] associates a [[position]] with a [[location]]. To
lower memory requirements a bit this could be also defined as a
quadruple. 

<<srcmap.ml>>=
type syncpoint      = position * location

@ We have chosen to use an array to implement a source map. Binary
search can be used to implement the lookup representation and is
compact in memory. When the array fills up the old array is copied
into a new one twice of the size of the old. 

Using an array also requires the restriction mentioned above:  sync
point positions must have an increasing order.  This could be dropped
when the array is sorted before it is first used for the lookup
operation.

Storing the file name for every sync point requires lots of memory. 
The number of different files referenced by all sync point is probably
small.  Storing every name only once thus can help to save memory. 
For this purpose a hash table is established.  A file name is never
stored directly in the array but looked up first in the hash table. 
The instance found there goes into the array.  Although it looks like
the one from the location it is a different one that is shared among
all sync points using this name.

<<srcmap.ml>>=
type srcmap =       { mutable points:       syncpoint array 
                    ; mutable top:          int
                    ; files :               (string, string) Hashtbl.t
                    }

@ The [[top]] component maintains the index of the first free position
in the [[points]] array.

In \ocaml every array cell must be initialized upon creation. We use
[[undefined]] for this. The initial size of the array is [[size]].

<<srcmap.ml>>=

let size        =  2
let undefined   =  (0, ("undefined", -1, -1))    

<<srcmap.ml>>= 
let empty =
    { points  = Array.create size undefined 
    ; top     = 0
    ; files   = Hashtbl.create 17
    }    

@ To prevent that the array fills up [[alloc]] makes sure there is at
least space for the next sync point.  In case the array is filled it
copies the existing array into a new one, twice as the size of the
old. 

<<srcmap.ml>>=

let alloc srcmap =
    let length = Array.length srcmap.points in
        if   srcmap.top < length then 
            ()
        else 
            let points' = Array.create length undefined in
                srcmap.points <- Array.append srcmap.points points'
            
@ Synchronizing means simply to enter the position and the
corresponding location into the array.  The file name in the location
is replaced by an instance that comes from the hash table and is
shared by many sync points.  We check also for the increasing order of
positions.

<<srcmap.ml>>=         

let sync srcmap position (file,line,col) =
    let _     = alloc srcmap in
    let file' = try  Hashtbl.find srcmap.files file
                with Not_found -> ( Hashtbl.add srcmap.files file file
                                  ; file
                                  ) 
    in
    let location' = (file', line, col) in
    let top   = srcmap.top   in
        ( assert ((position = 0) || (fst srcmap.points.(top-1) < position))
        ; srcmap.points.(top) <- (position,location')
        ; srcmap.top <- srcmap.top + 1
        )
        
@ Entering a sync point for a new line is so common that it deserves
its own function.  The sync point is actually at the position
following the newline character because we know that this will be at the
beginning of the next line; [[position]] must point to this first
character of the new line.  The new line is in the same file as the
last sync point.

<<srcmap.ml>>=

let nl srcmap position = 
    let (_,(file, line, _)) = srcmap.points.(srcmap.top-1) in
        sync srcmap position (file, line+1, 1)
        
@ Function [[cmp]] compares a [[position]] with a [[(position,location)]]
pair; the [[position]] is the one we like to find in the array.

<<srcmap.ml>>=
let cmp x (y,_) = compare x y

@ We want to find the element in the array with the position we are
looking for, or, if it is not there, the element to the left of it.
We expect that the array is not empty when it is used and secure this
by an assertion.  Only the first [[length]] entries are searched in
the array.

<<srcmap.ml>>=

let search x array length cmp =
    let rec loop left right =
        if left > right then
            array.(right)
        else
            let pivot = (left + right)/2 in
            let res   = cmp x array.(pivot) in
            
                if res = 0 then 
                    array.(pivot)
                else if res < 0 then
                    loop left (pivot-1)
                else
                    loop (pivot+1) right
    in
        ( assert (length > 0)
        ; loop 0 (length-1)
        )

@ To calculate the location of a position we have to find the sync
point to its left. We binary search this point in the map which gives
us a location. The actual location is possibly to the right of this
point: we simply have to add the missing columns to go there.

<<srcmap.ml>>=

let location map position =
    let pos,(file,line,col) = search position map.points map.top cmp in
    (file,line,position - pos + col)


@ To aid debugging we provide a function [[dump]] to write the
contents of a [[srcmap]] to stdout.

<<srcmap.ml>>=

let dump map =
    let point (pos,(file,line,col)) = 
        Printf.printf "%5d: %-32s %4d %3d\n" pos file line col
    in
        Array.iter point map.points

@




