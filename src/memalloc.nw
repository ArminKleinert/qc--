% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Automaton-Based Memory Allocation}
% ------------------------------------------------------------------ 

This module provides an applicative abstraction [[t]] to allocate a
memory block incrementally by a sequence of [[allocate]] and [[align]]
directives.  The abstraction is similar to a pointer that is advanced
and aligned to reserve memory. At any point the value of the  pointer
can be used as an address. After allocation is complete, the automaton
is [[frozen]] and the allocated block is returned. A [[t]] value should
not be used after it was frozen (allthough it is technically possible
and safe).
<<memalloc.mli>>=
type t          (* immutable *)

val at:         base:Rtl.exp -> t       (* provide base address *)
val relative:   anchor:Rtl.exp -> dbg:string -> t (* unknown addr relative to anchor *)
val allocate:   t -> size:int -> t      (* increase block *)
val align:      t -> int -> t           (* align cursor *)
val current:    t -> Rtl.exp            (* obtain cursor *)
val freeze:     t -> Block.t            (* return allocated block *)
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<memalloc.ml>>=
type t =
    { base:                 Rtl.exp     (* base of block      *)
    ; width:                int         (* width of exp       *)
    ; size:                 int         (* size of block      *)
    ; alignment:            int         (* alignment of block *)
    }

let at ~base = 
    { base      = base
    ; width     = Rtlutil.Width.exp base
    ; size      = 0
    ; alignment = 1
    }

let relative ~anchor ~dbg = 
  let w = Rtlutil.Width.exp anchor in
  at (Rtlutil.add w anchor (Rtl.late (Idgen.offset dbg) w))

let allocate t ~size = 
    assert (size >= 0);    
    { t with size = t.size + size }

let align    t n = (* align both size and base alignment *)
    assert (n > 0);
    { t with
      alignment = max t.alignment n
    ; size      = if t.size mod n = 0 
                  then t.size
                  else ((t.size / n) + 1) * n     (* next multiple of n *)
    }
let current t = Rtlutil.addk t.width t.base t.size

let freeze t = Block.at t.base t.size t.alignment
@
