% vim: ts=8 et sw=4
%
% $Id$
%

% ------------------------------------------------------------------ 
\section{Automaton-Graph}
% ------------------------------------------------------------------ 

The Quick {\PAL} compiler represents a calling convention as an
automaton [[Automaton.t]]. When a client supplies a \emph{type} to an
automaton it advances to a new state. A type is a pair of an integer and
a string, representing a width in bits and a so-called hint. The state
of an automaton comprises a set of register locations and the alignment
of a memory block. We are interested in a graph representation of the
reachable states: states form the nodes, and transitions the edges of
the graph. For any realistic calling convention the set of reachable
states in its automaton and the corresponding edges should be finite.
The module traverses this state graph and emits it for analysis.

Function [[print]] takes a function [[mk]], that creates an automaton in
its initial state a list of widths, and list of hints. It prints all
edges of the automaton to [[stdout]] in the Dot language.  The widths
and hints are used to construct requests: in every state of the
automaton, every combination of a width and a hint are explored to reach
a new state.

<<automatongraph.mli>>=
val print:  mk:(unit -> Automaton.t) 
                     -> widths:int list -> hints:string list 
                     -> unit
@

I now realize that the [[graph]] type defined in the implementation is
basically an isomorphism of the automaton defined in
\module{automaton.nw}. Given the graph, the underlying automaton can be
simulated.  After this realization I changed the type definition of
[[graph]] to make simulation easy. This should help to apply Bailey's
algorithm to find interesting paths.


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The basic idea is simple: we start from the initial state of an
automaton and explore all outgoing edges. An edge is labeled with a
type, which is a pair of a width and a hint. As long as we find new
edges we continue depth first. The graph should be finite because a
typical calling convention has only a limited set of registers and a
limited set of stack alignments. Once the graph is explored, we can
print it.

The state of an automaton can only be observed after is was
\emph{frozen}. This presents a small difficulty: to observe a given
state, we have to freeze it. But to follow a new edge we need an
unfrozen automaton, thus we have to re-construct the automaton's state
such that we can make the transition. To do that, we maintain a
\emph{path} of types that allows to reconstruct the state automaton,
starting from the initial state of an automaton. This in turn requires,
to create an automaton in its initial state when needed.


<<automatongraph.ml>>=
module A    = Automaton
let sprintf = Printf.sprintf
let printf  = Printf.printf
@

A type is a pair of a width and a hint. Types label the edges of the
graph. A path is a list of types and indirectly describes the state of
an automaton: starting from the initial state the types from the path
are fed into the automaton, which advances its state accordingly.

<<automatongraph.ml>>=
type ty =       int * string                    (* width, hint     *)
type path =     ty list                         (* leads to a node *)
@

A [[node]] is the observable state of an automaton. It is the ordered
list of allocated registers and the alignment of the next slot in the
overflow memory edge. To simplify node equality we represent allocated
registers as (ordered or normalized) list, rather than as a set.

<<automatongraph.ml>>=
type node    =  { regs:     Register.t list     (* ordered *)
                ; align:    int
                }
@

An [[edge]] is the node where an edge originates and a label that
identifies the edge.  The destination of the edge is uniquely defined in
the [[graph]], but is not part of the [[edge]] type.

<<automatongraph.ml>>=
type edge =     node * ty
@

The [[graph]] type records the node an edge reaches in a map [[edges]].
The map models the transition function $\mathit{node} \times
\mathit{type} \to \mathit{node}$. An [[edge]] is therefore only
meaningful in the context of a [[graph]] which provides the map. In
addition, the [[graph]] maintains a set of all nodes, and a [[start]]
node, corresponding to the start state of the automaton.

<<automatongraph.ml>>=
module NS = Set.Make (struct type t=node let compare=compare end)
module ES = Set.Make (struct type t=edge let compare=compare end)
module T  = Map.Make (struct type t=edge let compare=compare end)

type graph =    { nodes:    NS.t            (* all the nodes *)
                ; start:    node            (* start node    *)
                ; edges:    node T.t        (* transition: node*ty => node *)
                }

let graph node = { nodes = NS.add node NS.empty
                 ; start = node
                 ; edges = T.empty
                 }
@

Several other definitons of [[graph]] would have been possible. This
definition is close to the underlying automaton such that it is
easy to follow edges in the same way the automaton changes its state.

We have a membership predicate for edges and a function to [[add]]
edges. We maintain the following invariant: the origin of an edge is
already in the set of node when we call [[add]], we thus only have to
add the destination node.

<<automatongraph.ml>>=
let mem edge graph          = T.mem edge graph.edges
let add (n,t as edge) node graph =
    assert (NS.mem n graph.nodes);
    { graph with edges = T.add edge node graph.edges
               ; nodes = NS.add node graph.nodes }
@

For debugging, the [[ToString]] module provides us with function to
represent all our types as strings. Feel free to improve this. 

<<automatongraph.ml>>=
module ToString = struct
    let register (sp,i,_) = sprintf "$%c%i" sp i
    let ty (width,hint)   = sprintf "%d/%s" width hint
    let align n           = sprintf "%i:" n
    let node s            = String.concat "" 
                                ((align s.align)::List.map register s.regs)
    let edge src label dst= sprintf "%s --%s--> %s"
                                (node  src)
                                (ty    label)
                                (node  dst)
    let path p            = String.concat " "  (List.map ty p) 
    let paths ps          = String.concat "\n" (List.map path ps)
    let graph g = 
        let add_edge (src,label) dst strs = edge src label dst :: strs in
        let edges = T.fold add_edge g.edges [] in
            String.concat "\n" edges
end
@

Below is a rather ugly emitter for the AT\&T graph layouter Dot. This is
now the standard output format.

<<automatongraph.ml>>=
module ToDot = struct
    let register (sp,i,_) = sprintf "$%c%i" sp i
    let ty (width,hint)   = sprintf "%d/%s" width hint
    let node s            = sprintf "\"%i:%s\"" 
                                        s.align 
                                        (String.concat "" 
                                            (List.map register s.regs))
    let edge src label dst= printf "%s -> %s [label=\"%s\"]\n"
                                (node  src)
                                (node  dst)
                                (ty    label)
    
    let path p            = String.concat " "  (List.map ty p) 
    let paths ps          = List.iter (fun s -> printf "// %s\n" s)
                                                (List.map path ps)
    
    let graph g = 
        ( printf "digraph \"calling convention\" {\n"
        ; printf "size=\"6,9\"\n"
        ; let print_edge (src,label) dst () = edge src label dst  in
            T.fold print_edge g.edges () 
        ; printf "}\n"
        )
end
@

[[combine]] forms the product of two lists. We use it to compute all
possible edge labels from a list of widths and hints.

<<automatongraph.ml>>=
let combine xs ys =
    let pair x y = (x,y) in
        List.concat (List.map (fun w -> List.map (pair w) ys) xs)
@

[[goto]] takes function [[mk]] that creates an automaton in its initial
state and a [[path]] of types. It feeds [[path]] through the automaton,
observes its final state, and returns it as a [[node]].

<<automatongraph.ml>>=
let goto mk path =
    let t    = mk ()                        in
    let ()   = List.iter (fun (w,h) -> ignore (A.allocate t w h)) path in
    let res  = A.freeze t in
        { regs  = Register.Set.elements res.A.regs_used     (* ordered! *)
        ; align = res.A.align_state
        }
@

The heart of the algorithm are the two mutually recursive functions
[[dfs]] and [[follow]]. The depth-search function [[dfs]] explores a
[[graph]] in all direction, starting from one [[node]]. [[Follow]]
specifically explores a [[node]] by following a potentially new edge
labeled with [[ty]].

Both functions take common arguments [[mk]], [[dirs]], [[path]], and the
current [[graph]]. [[mk]] creates the automaton under investigation in
its initial state when applied to [[()]]. [[dirs]] is the list of all
labels for outgoing edges that are explored from the current node.
[[path]] allows to reconstruct the state of the current [[node]] by
passing it with [[mk]] to [[goto]].

From the current node, we follow an edge labeled with [[ty]]. If this
edge hasn't be seen before, it is added to the graph and we move to the
node at its end. From there we explore all outgoing edges recursively
depth first.

<<automatongraph.ml>>=
let rec follow (mk:unit->Automaton.t) (dirs: ty list) graph path node ty =
    let path  = path @ [ty]  in
    let node' = goto mk path in
    let edge  = (node,ty)    in
    if mem edge graph then
        graph
    else
        dfs mk dirs (add edge node' graph) path node'

and dfs mk dirs graph path node =   (* call this *)
    List.fold_left 
        (fun graph ty -> follow mk dirs graph path node ty) graph dirs
@


Finally, here is the function we export. The list [[dirs]] of all
potential edge labels is the product of all widths and hints. Function
[[mk]] creates an automaton in its initials state. The initial graph
contains the node corresponding to the initial state and is otherwise
empty.
  
<<automatongraph.ml>>=
<<interesting paths>>
let print ~mk ~widths ~hints = 
    let dump g  = print_endline (ToString.graph g) in
    let dirs    = combine widths hints in
    let init    = {regs=[]; align=0}   in
    let g       = graph init           in
    let g       = dfs mk dirs g [] {regs=[]; align=0} in
        ( ToDot.graph g
        ; printf "// Interesting paths:\n"
        ; ToDot.paths (interesting_paths g)
        )
@

% ------------------------------------------------------------------ 
\subsection{Interesting Paths}
% ------------------------------------------------------------------ 

To test a calling convention, we like to find interesting parameter
lists, which correspond to interesting paths in a [[graph]]. The goal is
to find enough paths such that for any node, each pair of incoming and
outgoing edge is covered by at leat one path. This criterion was
proposed by Bailey in his Ph.D.~thesis. The parameter list that
corresponds to a path is simply the list of edge labels. 

The alogithm by Bailey is a variant of a depth-first search: we move
along edges and collect their labels in a list called [[path]]. When we
come to a node, we build (reversed) parameter lists by taking our path
and prefixing it with each of the labels of the node's outgoing edges:
say, our current path is $w$ and the labels of the outgoing edges are
$a$, $b$, and $c$, so we build the parameter lists $aw$, $bw$ and $cw$.
Next we mark the edge on which we reached the node.  This implies that
we have generated parameter lists that cover our incoming edge and all
outgoing edges of the node we just reached.  We continue on all
\emph{unmarked} outgoing edges; we extend our path with the label of the
chosen edge, as we move along.  The algorithms carries two main results:
the set of visited edges, and the generated argument lists. The
functional implementation passes them around; a more imperative
algorithm could also use global state.  

[[next]] returns the [[node]] at the end of an edge.

<<interesting paths>>=
let next graph edge = T.find edge graph.edges
@

[[outgoing]] returns the labels (types) on outgoing edges of a given
[[node]].

<<interesting paths>>=
let outgoing graph node =
    let add_label (src, label) dst labels =
        if src = node then label :: labels else labels
    in    
        T.fold add_label graph.edges []
@

All paths and parameter lists are reversed, because we append results in
the front.

The [[explore]] function implements the depth-first algorithm explained
above. 
\begin{itemize}
\item [[visited]] is the set of visited (or marked) edges. We never
       follow a marked edge to reach new nodes.
\item [[path]] is the reversed list of types that lead from the start
      node of the graph to the current [[node]].
\item [[paths]] are constructed parameter lists. For efficiency, it is a
      list of path lists that is flattened later.
\item [[node]] is the node we just reached having followed [[path]].       
\item [[labels]] are the labels on outgoing edges of [[node]].
\end{itemize}

The [[follow]] function follows an edge to a new node. It
carries the visited edges and parameter lists constructed so far. If the
current edge is already marked, it is not followed, but the current
result is just returned. Otherwise the edge is marked, the current path
extened and the reached recursively explored.

<<interesting paths>>=
let rec explore graph (visited:ES.t) (path:path) (paths:path list list) node =
    let labels  = outgoing graph node in
    let paths  = (List.map (fun l -> l::path) labels) :: paths in
    let follow (node, ty as edge) visited paths =
        if ES.mem edge visited then
            (paths, visited)    (* do nothing, return result *)
        else
            explore 
                graph (ES.add edge visited) (ty::path) paths (next graph edge)
    in
        List.fold_left 
            (fun (paths,visited) edge -> follow edge visited paths)
            (paths,visited)
            (List.map (fun ty -> (node,ty)) labels)
@

The main function extracts the parameter lists, flattens and reverses
them.

<<interesting paths>>=
let interesting_paths graph = 
    let (paths,_) = explore graph ES.empty [] [] graph.start in
        List.map List.rev (List.concat paths)
@            
