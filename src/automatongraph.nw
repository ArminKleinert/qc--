
% ------------------------------------------------------------------ 
\section{Automaton-Graph}
% ------------------------------------------------------------------ 

The Quick {\PAL} compiler represents a calling convention as an
automaton [[Automaton.t]]. When a client supplies a \emph{type} to an
automaton it advances to a new state. A type is a pair of an integer and
a string, representing a width in bits and a so-called hint. The state
of an automaton comprises a set of register locations and the alignment
of a memory block. We are interested in a graph representation of the
reachable states: states form the nodes, and transitions the edges of
the graph. For any realistic calling convention the set of reachable
states in its automaton and the corresponding edges should be finite.
The module traverses this state graph and emits it for analysis.

Function [[print]] takes a function [[mk]], that creates an automaton in
its initial state a list of widths, and list of hints. It prints all
edges of the automaton to [[stdout]].  The widths and hints are used to
construct requests: in every state of the automaton, every combination
of a width and a hint are explored to reach a new state.

<<automatongraph.mli>>=
val print:  mk:(unit -> Automaton.t) 
                     -> widths:int list -> hints:string list 
                     -> unit
@



% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The basic idea is simple: we start from the initial state of an
automaton and explore all outgoing edges. An edge is labeled with a
type, which is a pair of a width and a hint. As long as we find new
edges we continue depth first. The graph should be finite because a
typical calling convention has only a limited set of registers and a
limited set of stack alignments. Once the graph is explored, we can
print it.

The state of an automaton can only be observed after is was
\emph{frozen}. This presents a small dificulty: to observe a given
state, we have to freeze it. But to follow a new edge we need an
unfrozen automaton, thus we have to re-construct the automaton's state
such that we can make the transition. To do that, we maintain a
\emph{path} of types that allows to reconstruct the state automaton,
starting from the initial state of an automaton. This in turn requires,
to create an automaton in its inital state when needed.


<<automatongraph.ml>>=
module A    = Automaton
let sprintf = Printf.sprintf
let printf  = Printf.printf
@

A type is a pair of a width and a hint. Types label the edges of the
graph. A path is a list of types and indirectly describes the state of
an automaton: starting from the initial state the types from the path
are fed into the automaton, which advances its state accordingly.

<<automatongraph.ml>>=
type ty =       int * string                    (* width, hint     *)
type path =     ty list                         (* leads to a node *)
@

A [[node]] is the observable state of an automaton. It is the ordered
list of allocated registers and the alignment of the next slot in the
overflow memory edge. To simplify node equality we represent allocated
registers as (ordered or normalized) list, rather than as a set.

<<automatongraph.ml>>=
type node    =  { regs:     Register.t list     (* ordered *)
                ; align:    int
                }
@

An [[edge]] is the node where an edge originates and a label that
identifies the edge.  The destination of the edge is uniquely defined in
the [[graph]], but is not part of the [[edge]] type.

<<automatongraph.ml>>=
type edge =     node * ty
@

The [[graph]] type records the node an edge reaches in a map [[edges]].
The map models the transition function $\mathit{node} \times
\mathit{type} \to \mathit{node}$. An [[edge]] is therefore only
meaningful in the context of a [[graph]] which provides the map. In
addition, the [[graph]] maintains a set of all nodes, and a [[start]]
node, corresponding to the start state of the automaton.

<<automatongraph.ml>>=
module NS = Set.Make (struct type t=node let compare=compare end)
module T  = Map.Make (struct type t=edge let compare=compare end)

type graph =    { nodes:    NS.t            (* all the nodes *)
                ; start:    node            (* start node    *)
                ; edges:    node T.t        (* transition: node*ty => node *)
                }

let graph node = { nodes = NS.add node NS.empty
                 ; start = node
                 ; edges = T.empty
                 }
@

Several other definitons of [[graph]] would have been possible. This
definition is close to the underlying automaton such that it is
easy to follow edges in the same way the automaton changes its state.

We have a membership predicate for edges and a function to [[add]]
edges. We maintain the following invariant: the origin of an edge is
already in the set of node when we call [[add]], we thus only have to
add the destination node.

<<automatongraph.ml>>=
let mem edge graph          = T.mem edge graph.edges
let add (n,t as edge) node graph =
    assert (NS.mem n graph.nodes);
    { graph with edges = T.add edge node graph.edges
               ; nodes = NS.add node graph.nodes }
@

For debugging, the [[ToString]] module provides us with function to
represent all our types as strings. Feel free to improve this. Another
idea would be a [[ToDOT]] module, that implements output for
\textit{dot}(1).

<<automatongraph.ml>>=
module ToString = struct
    let register (sp,i,_) = sprintf "$%c%i" sp i
    let ty (width,hint)   = sprintf "%d/%s" width hint
    let align n           = sprintf "%i:" n
    let node s            = String.concat "" 
                                ((align s.align)::List.map register s.regs)
    let edge src label dst= sprintf "%s --%s--> %s"
                                (node  src)
                                (ty    label)
                                (node  dst)
    let graph g = 
        let add_edge (src,label) dst strs = edge src label dst :: strs in
        let edges = T.fold add_edge g.edges [] in
            String.concat "\n" edges
end
@

[[combine]] forms the product of two lists. We use it to compute all
possible edge labels from a list of widths and hints.

<<automatongraph.ml>>=
let combine xs ys =
    let pair x y = (x,y) in
        List.concat (List.map (fun w -> List.map (pair w) ys) xs)
@

[[goto]] takes function [[mk]] that creates an automaton in its initial
state and a [[path]] of types. It feeds [[path]] through the automaton,
observes its final state, and returns it as a [[node]].

<<automatongraph.ml>>=
let goto mk path =
    let t    = mk ()                        in
    let ()   = List.iter (fun (w,h) -> ignore (A.allocate t w h)) path in
    let res  = A.freeze t in
        { regs  = Register.Set.elements res.A.regs_used     (* ordered! *)
        ; align = res.A.align_state
        }
@

The heart of the algorithm are the two mutually recursive functions
[[dfs]] and [[follow]]. The depth-search function [[dfs]] explores a
[[graph]] in all direction, starting from one [[node]]. [[Follow]]
specifically explores a [[node]] by following a potentially new edge
labeled with [[ty]].

Both functions take common arguments [[mk]], [[dirs]], [[path]], and the
current [[graph]]. [[mk]] creates the automaton under investigation in
its initial state when applied to [[()]]. [[dirs]] is the list of all
labels for outgoing edges that are explored from the current node.
[[path]] allows to reconstruct the state of the current [[node]] by
passing it with [[mk]] to [[goto]].

From the current node, we follow an edge labeled with [[ty]]. If this
edge hasn't be seen before, it is added to the graph and we move to the
node at its end. From there we explore all outgoing edges recursively
depth first.

<<automatongraph.ml>>=
let rec follow (mk:unit->Automaton.t) (dirs: ty list) graph path node ty =
    let path  = path @ [ty]  in
    let node' = goto mk path in
    let edge  = (node,ty)    in
    if mem edge graph then
        graph
    else
        dfs mk dirs (add edge node' graph) path node'

and dfs mk dirs graph path node =   (* call this *)
    List.fold_left 
        (fun graph ty -> follow mk dirs graph path node ty) graph dirs
@


Finally, here is the function we export. The list [[dirs]] of all
potential edge labels is the product of all widths and hints. Function
[[mk]] creates an automaton in its initials state. The initial graph
contains the node corresponding to the initial state and is otherwise
empty.
  
<<automatongraph.ml>>=
let print ~mk ~widths ~hints = 
    let dump g  = print_endline (ToString.graph g) in
    let dirs    = combine widths hints in
    let init    = {regs=[]; align=0}   in
    let g       = graph init           in
    let g       = dfs mk dirs g [] {regs=[]; align=0} in
        dump g
@

