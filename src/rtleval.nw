% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Evaluation of RTL-Expressions}
% ------------------------------------------------------------------ 

An {\rtl} expression can denote a compile-time, link-time, or run-time
expression. This module offers functions [[compile]] and [[link]] to
evaluate compile-time and link-time constants respectively. A
compile-time constant is evaluated to a [[Bits.bits]] value, a link-time
constant to an [[Symbol.reladdr]] value. 

\begin{quote}\it
    Should translation of run-time expression be integrated here, too?
    This would allow to do contant-folding. --CL
\end{quote}

<<rtleval.mli>>=
type symbol = Symbol.symbol 
type value  =
    | CompileTime of Bits.bits       (* compile-time *)
    | LinkTime    of Symbol.reladdr    (* link-time    *)
    
(* raise Error.ErrorExn in case of error *)
val link:     (Bits.bits -> Symbol.reladdr) -> Rtl.exp -> Symbol.reladdr 
val eval:     (Bits.bits -> Symbol.reladdr) -> Rtl.exp -> value   
val compile:  Rtl.exp -> Bits.bits                            
@

The evaluation of link-time expressions depends on the representation of
link-time values. To construct link-time values from constants we have
to provide a back-end dependent function. An alterative design provided
the provided these functions in a functor argument. To avoid
functorization of large parts of the compiler the design has become more
dynamic.


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation tries to evaluate an expression as a compile-time
expressions as far as possible. If this fails because it encounters a
link-time sub-expression the whole expression is promoted as a link-time
expression. The distinction between compile-time and link-time values is
done with two tags [[CT]] and [[LT]] respectively, that are attached to
values and list of values.

<<rtleval.ml>>=
module E  = Error
module R  = Rtl
module RP = Rtl.Private


type symbol = Symbol.symbol 
type value  =
    | CompileTime of Bits.bits       (* compile-time *)
    | LinkTime    of Symbol.reladdr    (* link-time    *)
    
<<Make>>
@

Compile-time and link-time expressions include different operators.
Their implementation and the corresponding [[apply]] function is defined
in two sub-modules, [[LinkTime]] and [[CompileTime]]. 

<<Make>>=
module LinkTime = struct
    let add = function
        | [x;y] -> x#add y
        | _     -> E.error "wrong number of arguments to link-time add"

    let sub = function
        | [x;y] -> x#sub y
        | _     -> E.error "wrong number of arguments to link-time sub"

    let rec apply (op,wl) exps =
        let f    = match op with
                   | "add" | "+" -> add
                   | "sub" | "-" -> sub
                   | x           -> E.error ("unknown link-time op "^x)
        in
            f exps
end
@

Since compile-time values in {\PAL} contain no boolean expression only
compile-time functions over [[Bits.bits]] are defined.

<<Make>>=
module CompileTime = struct
    let apply (op,_ as opr) exps =
        let args = List.map (fun e -> Rtlop.Impl.Bits e) exps in
        let f    = try Rtlop.Impl.lookup (Rtl.Revert.opr opr)
                   with Not_found -> E.error ("unknown operator "^op)
        in match f args with
            | Rtlop.Impl.Bits b -> b
            | _                 -> assert false
end
@

During the evaluation of an expression, results are either tagged as a
compile-time ([[CT]]) or link-time ([[LT]]) values.

<<Make>>=
type ('a, 'b) choice    = CT of 'a      (* compile-time *)
                        | LT of 'b      (* link-time    *)
@

Every compile-time value can be transformed into a link-time value
using [[link_time]]. This is done, when the evaluation detects that a
value is not a compile-time value.

<<Make>>=
let link_time (k:Bits.bits ->Symbol.reladdr) = function
    | LT x -> x
    | CT x -> k x     
@

A function application can either apply a compile-time or a link-time
function. It must be a link-time function if any of the arguments is a
link-time value. The [[lift]] function takes a list of value and returns
a list of compile-time values, if all values are compile-time values, or
a list of link-time values, if at least on value is a link-time value.

<<Make>>=
let lift (k:Bits.bits ->Symbol.reladdr) values = 
    let rec choose = function
        | (cts, [])                     -> CT (List.rev cts)
        | (cts, (CT x)  :: xs)          -> choose (x::cts, xs)
        | (cts, ((LT _) :: _ as xs))    -> 
            LT (List.map (fun v -> k v) (List.rev cts) 
              @ List.map (link_time k) xs)
    in
        choose ([], values) (*(Bits.bits list, Exp.t list) choice*)

let rec const = function
    | RP.Bool _      -> E.error "boolean in compile- or link-time expression"
    | RP.Late (x,w)  -> 
        E.error "late compile-time value in link-time expression"
    | RP.Bits b      -> CT(b)
    | RP.Link (l,w)  -> LT(l#reladdr)
@    

The [[exp]] function evaluates an expression. The point is the
translation of an application: lifting the list of arguments indicates
whether the result will be a link- or compile-time value and also which
[[apply]] function to call.
 
<<Make>>= 
and exp (k:Bits.bits->Symbol.reladdr) = function
    | RP.Const c           -> const c 
    | RP.Fetch (loc,width) -> E.error "register/memory access in constant"
    | RP.App(op,exps)      -> 
        match lift k (List.map (exp k) exps) with
        | CT args       -> CT (CompileTime.apply op args)
        | LT args       -> LT (LinkTime.apply    op args)

let link k e = match exp k (Rtl.Convert.exp e) with
    | LT x      -> x
    | CT x      -> k x

let compile e = 
    let k = fun x -> E.error "not a compile-time expression" in
    match exp k (Rtl.Convert.exp e) with
    | CT x      -> x
    | LT _      -> E.error "not a compile-time constant expression"

let eval k e =  match exp k (Rtl.Convert.exp e) with
    | CT x      -> CompileTime x
    | LT x      -> LinkTime x
@

