
\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Evaluation of RTL-Expressions}
% ------------------------------------------------------------------ 

An {\rtl} expression can denote a compile-time, link-time, or run-time
expression. This module offers functions [[compile]] and [[link]] to
evaluate compile-time and and link-time constants respectively. A
compile-time constant is evaluated to a [[Bits.bits]] value, a link-time
constant to an [[EXP.t]] value. 

\begin{quote}\it
    Should translation of run-time expression be integrated here, too?
    This would allow to do contant-folding. --CL
\end{quote}

The module type [[EXP]] provides a target and back-end dependent way of
constructing link-time expressions. All link-time expressions must be of
the native pointer type, otherwise it is an unchecked run-time error.

Since compile-time values are compile to [[Bits.bits]] value they can
not denote a boolean value. This is no restriction because there are no
compile-time boolean values in the {\PAL} language. Of course, no
compile-time constant expression must access memory or registers.
References to {\rtl} variables are currently also unsupported.

Checked compile-time errors are reported as [[Error.ErrorExn]]
exceptions.

<<module type EXP>>=    
module type EXP = sig                       (* fits to Asm2 *)   
    type t

    val sym:        string    -> t          (* symbol of native pointer type *)
    val const:      Bits.bits -> t          (* req: native pointer size *)
    val add:        t -> t -> t             (* t + t *)     
    val sub:        t -> t -> t             (* t - t *)     
end

<<module type S>>=
module type S = sig
    type t
    val link:           Rtl.exp -> t            (* Error.ErrorExn *)
    val compile:        Rtl.exp -> Bits.bits    (* Error.ErrorExn *)
end    
@

The evaluation of link-time expressions depends on the representation of
link-time values. It is provided as a functor argument. Some clients
like to evaluate compile-time {\rtl} expression but lack an [[EXP]]
module to supply the functor. For them we provide a dummy [[EXP]]
implementation [[Dummy]].

<<rtleval.mli>>=
<<module type EXP>>
<<module type S>>
module Dummy: EXP
module Make (Exp: EXP): S with type t = Exp.t
@


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation tries to evaluate an expression as a compile-time
expressions as far as possible. If this fails because it encounters a
link-time sub-expression the whole expression is promoted as a link-time
expression. The distinction between compile-time and link-time values is
done with two tags [[CT]] and [[LT]] respectively, that are attached to
values and list of values.

<<rtleval.ml>>=
<<module type EXP>>
<<module type S>>

module E  = Error
module R  = Rtl
module RP = Rtl.Private

module Dummy: EXP = struct
    type t      = unit
    let sym   _ = ()
    let const _ = ()
    let add _ _ = ()
    let sub _ _ = ()
end

module Make (Exp: EXP) = struct
    type t = Exp.t
    <<Make>>
end
@

Compile-time and link-time expressions include different operators.
Their implementation and the corresponding [[apply]] function is defined
in two sub-modules, [[LinkTime]] and [[CompileTime]]. 

<<Make>>=
module LinkTime = struct
    let add = function
        | [x;y] -> Exp.add x y
        | _     -> E.error "wrong number of arguments to link-time add"

    let sub = function
        | [x;y] -> Exp.sub x y
        | _     -> E.error "wrong number of arguments to link-time sub"

    let rec apply (op,wl) exps =
        let f    = match op with
                   | "add" | "+" -> add
                   | "sub" | "-" -> sub
                   | x           -> E.error ("unknown link-time op "^x)
        in
            f exps
end
@

Since compile-time values in {\PAL} contain no boolean expression only
compile-time functions over [[Bits.bits]] are defined.

<<Make>>=
module CompileTime = struct
    let apply (op,_ as opr) exps =
        let args = List.map (fun e -> Rtlop.Impl.Bits e) exps in
        let f    = try Rtlop.Impl.lookup (Rtl.Revert.opr opr)
                   with Not_found -> E.error ("unknown operator "^op)
        in match f args with
            | Rtlop.Impl.Bits b -> b
            | _                 -> assert false
end
@

During the evaluation of an expression, results are either tagged as a
compile-time ([[CT]]) or link-time ([[LT]]) values.

<<Make>>=
type ('a, 'b) choice    = CT of 'a      (* compile-time *)
                        | LT of 'b      (* link-time    *)

type value = (Bits.bits, Exp.t) choice
@

Every compile-time value can be transformed into a linke-time value
using [[link_time]]. This is done, when the evaluation detects that a
value is not a compile-time value.

<<Make>>=
let link_time (v:value) = match v with
    | LT x -> x
    | CT x -> Exp.const x     
@

A function application can either apply a compile-time or a link-time
function. It must be a link-time function if any of the arguments is a
link-time value. The [[lift]] function takes a list of value and returns
a list of compile-time values, if all values are compile-time values, or
a list of link-time values, if at least on value is a link-time value.

<<Make>>=
let lift (values: value list) = (* (Bits.bits list, Exp.t list) choice *)
    let rec choose = function
        | (cts, [])                     -> CT (List.rev cts)
        | (cts, (CT x)  :: xs)          -> choose (x::cts, xs)
        | (cts, ((LT _) :: _ as xs))    -> 
            LT (List.map Exp.const (List.rev cts) @ List.map link_time xs)
    in
        choose ([], values)

let const = function
    | RP.Bool _      -> E.error "boolean in compile- or link-time expression"
    | RP.Bits b      -> CT(b)
    | RP.Link (l,w)  -> LT(Exp.sym l)
@    

The [[exp]] function evaluates an expression. The point is the
translation of an application: lifting the list of arguments indicates
whether the result will be a link- or compile-time value and also which
[[apply]] function to call.
 
<<Make>>= 
let rec exp = function
    | RP.Const c           -> const c 
    | RP.Fetch (loc,width) -> E.error "register/memory access in constant"
    | RP.App(op,exps)      -> 
        match lift (List.map exp exps) with
        | CT args       -> CT (CompileTime.apply op args)
        | LT args       -> LT (LinkTime.apply    op args)

let link    e = link_time (exp (Rtl.Convert.exp e))
let compile e = match exp (Rtl.Convert.exp e) with
    | CT x      -> x
    | LT _      -> E.error "not a compile-time constant expression"
@

