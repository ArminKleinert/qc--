
\input{macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Evaluation of {\small RTL}s}
% ------------------------------------------------------------------ 

This modules allows to evaluate compile- and link-time
\rtl-expressions.  Expressions must not contain references to
\rtl-locations but may contain variables.  The meaning of these
variables is provided by a [[lookup]] function that is passed into the
evaluator.  A lookup on a variable must return a {\rtl}
\emph{constant} expression.  Only a minimal number of checks is
performed because it is assumed that expression have been type-checked
before.  Errors are reported in conformance with the policy outlined
in the \module{error} module.  In short, computing with bad values
lead to a bad value, detection of a new error leads to an exception.

In particular, any of the following conditions lead to
checked run-time error:

\begin{itemize}
\item Typing error
\item Use of an unknown primitive
\item Use of a link-time value in a compile-time expression
\item Use of an undefined variable.
\item Circular variable definitions.
\end{itemize}

The functions [[compile]] and [[link]] evaluate compile-time and
link-time expressions respectively.  The variants [[compile]] and
[[compile']] differ in that [[compile]] is intended for expressions
that evaluate to a [[Bits.bits]] value, where [[compile']] evaluates
expressions that also can have a boolean value. 

<<types and exceptions>>=
type 'a lookup = string -> 'a Error.error       (* look up constant(!) *)

type relexp  
  (* a relocatable expression, suitable for using as a link-time
     constant in an assembler---needs to be connected with Asm2.S *)
  = Rtl.exp (* a temporary expedient *)

<<rtleval.mli>>=
<<types and exceptions>>  
val empty    : Rtl.exp lookup (* empty lookup table *)
val compile  : Rtl.exp lookup -> Rtl.exp -> Bits.bits Error.error
val compile' : Rtl.exp lookup -> Rtl.exp -> Rtl.exp   Error.error
val link     : Rtl.exp lookup -> Rtl.exp -> relexp    Error.error
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<rtleval.ml>>=
module E  = Error
module R  = Rtl
module RP = Rtl.Private

<<types and exceptions>> (* from interface *)

module CompileTime = struct
    <<CompileTime>>
end

module LinkTime = struct
    <<LinkTime>>
end

let empty    = fun _ -> E.Error
let compile  = CompileTime.eval
let compile' = CompileTime.eval'
let link     = LinkTime.eval
@

% ------------------------------------------------------------------ 
\subsubsection{Compile-Time Expressions}
% ------------------------------------------------------------------ 

<<CompileTime>>=
module StrMap = Map.Make(struct type t=string let compare=compare end)


let zero = function (* damn lies *)
    | [RP.Bits(x);RP.Bits(y)] -> E.Ok(RP.Bits(Bits.zero (Bits.width x)))
    | _                       -> E.Error

let true' = function (* more damn lies *)
    | [RP.Bits(_);RP.Bits(_)] -> E.Ok(RP.Bool(true))
    | _                       -> E.Error

let ops =
    let ops = 
        [  "add"    , zero  
        ;  "+"      , zero  
        ;  "sub"    , zero  
        ;  "-"      , zero  
        ;  "mult"   , zero  
        ;  "shl"    , zero  
        ;  "shra"   , zero  
        ;  "shrl"   , zero  
        ;  "<<"     , zero  
        ;  ">>"     , zero  
        ;  "*"      , zero  
        ;  "eq"     , true' 
        ;  "=="     , true' 
        ;  "<="     , true' 
        ;  ">="     , true' 
        ;  ">"      , true' 
        ;  "<"      , true' 
        ;  "!="     , true' 
        ]
    in
        List.fold_left 
                (fun map (key,f) -> StrMap.add key f map)
                StrMap.empty 
                ops

let rec app lookup (op,wl) exps =
    let f    = try E.Ok(StrMap.find op ops) 
               with Not_found -> E.error ("unknown operator "^op)  in
    let args = Error.Raise.list (List.map (exp lookup) exps)       in    
        Error.seqPair (f,args) (fun (f,args) -> f args)
@

The [[lookup x]] function is allowed to return an expression which
must be evaluated.  In order to detect circular bindings a new
[[lookup']] function is created that excludes a binding for [[x]].
        
<<CompileTime>>=
and fetch lookup = function
    | RP.Var(x,index,w)   -> 
        let lookup' x' = if x = x' then E.error ("circular defintion of "^x) 
                         else lookup x' in
            E.sequence (lookup x) (fun x -> exp lookup' (Rtl.Convert.exp x))
    | RP.Cell _           -> E.error "memory or register access"
    | RP.Slice _          -> E.error "slices not supported"

and exp lookup = function
    | RP.Const c          -> E.Ok(c)
    | RP.Fetch(loc,width) -> fetch lookup loc 
    | RP.App(opr,exps)    -> app lookup opr exps

let eval' lookup e =
    match exp lookup (R.Convert.exp e) with
    | E.Error 
    | E.Ok(RP.Link _) -> E.error "not a compile-time value"
    | E.Ok(x)         -> E.Ok(Rtl.Revert.exp (RP.Const x))    

let eval  lookup e =
    match exp lookup (R.Convert.exp e) with
    | E.Error as x         -> x          
    | E.Ok(RP.Link _)      -> E.error "not a compile-time value"
    | E.Ok(RP.Bool _)      -> E.error "boolean value, expected bits value"
    | E.Ok(RP.Bits b)      -> E.Ok(b)
@

 
% ------------------------------------------------------------------ 
\subsubsection{Link-Time Expressions}
% ------------------------------------------------------------------ 

<<LinkTime>>=
let eval lookup exp = Error.Ok(exp) (* damn lie *)
@
