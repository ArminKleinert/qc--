% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{../config/macros.tex}

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Evaluation of RTL-Expressions}
% ------------------------------------------------------------------ 

An {\rtl} expression can denote a compile-time, link-time, or run-time
expression. This module offers functions [[compile]] and [[link]] to
evaluate compile-time and link-time constants respectively. A
compile-time constant is evaluated to a [[Bits.bits]] value, a link-time
constant to an [[EXP.t]] value. 

\begin{quote}\it
    Should translation of run-time expression be integrated here, too?
    This would allow to do contant-folding. --CL
\end{quote}

The module type [[RELADDR]] provides a target and back-end dependent way of
constructing link-time expressions. All link-time expressions must be of
the native pointer type, otherwise it is an unchecked run-time error.
denote a boolean value. This is no restriction because there are no
compile-time boolean values in the {\PAL} language. Of course, no
compile-time constant expression must access memory or registers.
References to {\rtl} variables are currently also unsupported.

Checked compile-time errors are reported as [[Error.ErrorExn]]
exceptions.

<<module type S>>=
module type S = sig
    type symbol = Asm3.symbol 
    type value  =
        | CompileTime of Bits.bits       (* compile-time *)
        | LinkTime    of Asm3.reladdr    (* link-time    *)
        
    (* raise Error.ErrorExn in case of error *)
    val link:     Rtl.exp -> Asm3.reladdr 
    val eval:     Rtl.exp -> value   
    val compile:  Rtl.exp -> Bits.bits                            
end    
@

The evaluation of link-time expressions depends on the representation of
link-time values. It is provided as a functor argument. Some clients
like to evaluate compile-time {\rtl} expression but lack an [[EXP]]
module to supply the functor. For them we provide a dummy [[EXP]]
implementation [[Dummy]].

<<rtleval.mli>>=
<<module type S>>
module Dummy: Asm3.RELADDR
module Make (Exp: Asm3.RELADDR): S 
@


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation tries to evaluate an expression as a compile-time
expressions as far as possible. If this fails because it encounters a
link-time sub-expression the whole expression is promoted as a link-time
expression. The distinction between compile-time and link-time values is
done with two tags [[CT]] and [[LT]] respectively, that are attached to
values and list of values.

<<rtleval.ml>>=
<<module type S>>

module E  = Error
module R  = Rtl
module RP = Rtl.Private

module Dummy: Asm3.RELADDR = struct
    class const (bits:Bits.bits):Asm3.reladdr = 
        object method ast = assert false 
    end
    class sym (symbol:Asm3.symbol):Asm3.reladdr = object 
        method ast = assert false 
    end
    class add (x:Asm3.reladdr) (y:Asm3.reladdr):Asm3.reladdr = object 
        method ast = assert false 
    end    
    class sub (x:Asm3.reladdr) (y:Asm3.reladdr):Asm3.reladdr = object 
        method ast = assert false 
    end
end    

module Make (R: Asm3.RELADDR) = struct
    type symbol = Asm3.symbol 
    type value  =
        | CompileTime of Bits.bits       (* compile-time *)
        | LinkTime    of Asm3.reladdr    (* link-time    *)
        
    <<Make>>
end
@

Compile-time and link-time expressions include different operators.
Their implementation and the corresponding [[apply]] function is defined
in two sub-modules, [[LinkTime]] and [[CompileTime]]. 

<<Make>>=
module LinkTime = struct
    let add = function
        | [x;y] -> new R.add x y
        | _     -> E.error "wrong number of arguments to link-time add"

    let sub = function
        | [x;y] -> new R.sub x y
        | _     -> E.error "wrong number of arguments to link-time sub"

    let rec apply (op,wl) exps =
        let f    = match op with
                   | "add" | "+" -> add
                   | "sub" | "-" -> sub
                   | x           -> E.error ("unknown link-time op "^x)
        in
            f exps
end
@

Since compile-time values in {\PAL} contain no boolean expression only
compile-time functions over [[Bits.bits]] are defined.

<<Make>>=
module CompileTime = struct
    let apply (op,_ as opr) exps =
        let args = List.map (fun e -> Rtlop.Impl.Bits e) exps in
        let f    = try Rtlop.Impl.lookup (Rtl.Revert.opr opr)
                   with Not_found -> E.error ("unknown operator "^op)
        in match f args with
            | Rtlop.Impl.Bits b -> b
            | _                 -> assert false
end
@

During the evaluation of an expression, results are either tagged as a
compile-time ([[CT]]) or link-time ([[LT]]) values.

<<Make>>=
type ('a, 'b) choice    = CT of 'a      (* compile-time *)
                        | LT of 'b      (* link-time    *)
@

Every compile-time value can be transformed into a linke-time value
using [[link_time]]. This is done, when the evaluation detects that a
value is not a compile-time value.

<<Make>>=
let link_time v = match v with
    | LT x -> x
    | CT x -> new R.const x     
@

A function application can either apply a compile-time or a link-time
function. It must be a link-time function if any of the arguments is a
link-time value. The [[lift]] function takes a list of value and returns
a list of compile-time values, if all values are compile-time values, or
a list of link-time values, if at least on value is a link-time value.

<<Make>>=
let lift values = (* (Bits.bits list, Exp.t list) choice *)
    let rec choose = function
        | (cts, [])                     -> CT (List.rev cts)
        | (cts, (CT x)  :: xs)          -> choose (x::cts, xs)
        | (cts, ((LT _) :: _ as xs))    -> 
            LT (List.map (fun v -> new R.const v) (List.rev cts) 
              @ List.map link_time xs)
    in
        choose ([], values)

let rec const = function
    | RP.Bool _      -> E.error "boolean in compile- or link-time expression"
    | RP.Late (x,w)  -> 
        E.error "late compile-time value in link-time expression"
    | RP.Bits b      -> CT(b)
    | RP.Link (l,w)  -> LT(new R.sym l)
@    

The [[exp]] function evaluates an expression. The point is the
translation of an application: lifting the list of arguments indicates
whether the result will be a link- or compile-time value and also which
[[apply]] function to call.
 
<<Make>>= 
and exp = function
    | RP.Const c           -> const c 
    | RP.Fetch (loc,width) -> E.error "register/memory access in constant"
    | RP.App(op,exps)      -> 
        match lift (List.map exp exps) with
        | CT args       -> CT (CompileTime.apply op args)
        | LT args       -> LT (LinkTime.apply    op args)

let link e = match exp (Rtl.Convert.exp e) with
    | LT x      -> x
    | CT x      -> new R.const x

let compile e = match exp (Rtl.Convert.exp e) with
    | CT x      -> x
    | LT _      -> E.error "not a compile-time constant expression"

let eval e =  match exp (Rtl.Convert.exp e) with
    | CT x      -> CompileTime x
    | LT x      -> LinkTime x
@

