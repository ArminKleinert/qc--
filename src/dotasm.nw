
% ------------------------------------------------------------------ 
\section{Assembler Interface to DOT}
% ------------------------------------------------------------------ 

This module implements an assembler that emits every procedure as a
graph in \textsc{dot} format.

<<dotasm.mli>>=
val asm: unit -> Asm3.assembler
@                      

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

Most assembler directives do nothing. We are only interested in the
control-flow-graphs that are part of an instruction. 

<<dotasm.ml>>=
module Asm = Asm3

exception Unsupported of string
let unsupported msg = raise (Unsupported msg)

<<Make>>
let asm () = new asm ()
@


% ------------------------------------------------------------------ 
\subsubsection{Classes for symbols, instructions, and addresses}
% ------------------------------------------------------------------ 

<<Make>>=
class addr: Symbol.reladdr = object
    method ast   = unsupported "Dotasm.addr#ast"
    method add x = new addr
    method sub x = new addr
end

class symbol (n:string) : Symbol.symbol = object
    method text    = n
    method reladdr = new addr
end
@

% ------------------------------------------------------------------ 
\subsubsection{Name Mangling}
% ------------------------------------------------------------------ 

We have to make sure that emitted names conform to {\small dot}'s
syntax. The [[spec]] below allows to create a name mangler that ensures
this.

<<Make>>=
let spec =
    let reserved = [] in
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '_'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '_' 
        in    
            { Mangle.preprocess = (fun x -> x)  
            ; Mangle.replace    = replace
            ; Mangle.reserved   = reserved
            ; Mangle.avoid      = (fun x -> x ^ "_")
            }
@


% ------------------------------------------------------------------ 
\subsubsection{The assembler class}
% ------------------------------------------------------------------ 

<<Make>>=
class asm () : Asm.assembler =
object (this)
    val mutable _section = "this can't happen"

    (* etc *)
    method reladdr (k:Bits.bits) = new addr

    (* declarations *)
    method import s = new symbol s
    method export s = new symbol s
    method local  s = new symbol s

    (* sections *)
    method section s = _section <- s
    method current   = _section

    (* definitions *)
    method label s   = ()
    method const s b = ()

    (* locations *)

    method org n    = ()
    method align n  = ()
    method addloc n = ()

    (* instructions *)
    method cfg_instr (cfg:Cfg3.cfg) (s:Symbol.symbol) =
        let mangle  = Mangle.mk spec in
        print_endline (Cfgutil.cfg2dot true (mangle s#text) cfg)

    method zeroes n = ()
    method value v = ()
    method addr  a = ()
    method comment s = ()
    method emit = ()
end


