% vim: ts=8 sw=4 et: 
% Daddy, why are we hiding from the police? They use Emacs, son, we use Vi.
% 
% $Id$

% ------------------------------------------------------------------ 
\section{Control-Flow Graph}
% ------------------------------------------------------------------ 

The executable part of a procedure is represented as a control-flow
graph (\cfg). The graph is polymorphic over instructions that are
embedded into its nodes. The most important specialization is when
{\rtl}s are used as instruction representation.

<<cfg4.mli>>=
module type S = sig
    <<interface>>
end
<<interface>>
@

<<interface>>=
type 'i cfg        (* 'i = instruction represenstation *)
type 'i node       (* node inside a cfg *)
type 'i conts      (* continuation bundle *)

type locs       = Register.Set.t    (* locations for liveness analysis *)
type property   = Cfgprop.t         (* mutable data inside node *)

type rtlcfg     = Rtl.rtl cfg       (* important special case *)
type rtlnode    = Rtl.rtl node      (* important special case *)
@

% ------------------------------------------------------------------ 
\subsection{Functions}
% ------------------------------------------------------------------ 

The [[mk]] function that creates a {\cfg} receives an instruction
denoting a no-op instruction.

<<interface>>=
val mk:         nop:'i -> 'i cfg   (* create empty cfg *)
val lookup:     'i cfg -> string -> 'i node        (* lookup label *)
@

Every {\cfg} has two special nodes: [[entry]] and [[exit]]. They cannot
be removed.

<<interface>>=
val entry:      'i cfg -> 'i node   
val exit:       'i cfg -> 'i node
@

The nodes in a {\cfg} can be enumerated with integers $0, \dots, n$. An
enumeration is destroyed by functions that mutate the structure of the
{\cfg}. Such functions' names are prefixed by [[gm]]. The number of a
node can be observed with [[number]].

<<interface>>=
val gm_enumerate:   'i cfg -> unit     (* post: enumerated cfg *)
@

Traversal of a {\cfg} requires it to be enumerated. All traversal is
relative to the enumeration. See module \module{Cfgutil} for convenience
functions. The [[scan]] function take a snapshot of an enumeration and
thus allows the client to change the {\cfg} structure; however, these
changes will \emph{not} be taken into account during the active
traversal.

<<interface>>=
val first:      'i cfg -> 'i node (* wrt numbering *)
val last:       'i cfg -> 'i node (* wrt numbering *)
val scan_fwd:   'i cfg -> first:int -> limit:int 
                       -> ('i node -> 'a -> 'a) -> 'a -> 'a 
val scan_bwd:   'i cfg -> first:int -> limit:int 
                       -> ('i node -> 'a -> 'a) -> 'a -> 'a
val next:       'i node -> 'i node option
val prev:       'i node -> 'i node option
@

We have just one node type, but specific functions to create them. This
helps to minimize errors with the right number of successors. Except for
[[label]] nodes, nodes created with functions below must have exactly
one predecessor.

<<interface>>=
val gm_label:   'i cfg -> string -> Reladdr.symbol -> succ:'i node -> 'i node 
val gm_assign:  'i cfg -> 'i -> succ:'i node -> 'i node
val gm_return:  'i cfg -> 'i -> int * int -> 'i node
val gm_goto:    'i cfg -> 'i -> 'i node list -> 'i node
val gm_jump:    'i cfg -> 'i -> string list -> 'i node
val gm_cutto:   'i cfg -> 'i -> 'i conts -> 'i node
val gm_call:    'i cfg -> 'i -> 'i conts -> succ:'i node -> 'i node
val gm_branch:  'i cfg -> 'i -> ifso:'i node -> ifnot:'i node -> 'i node
@

A continuation bundle is basically a vector of nodes.

<<interface>>=
val conts: cuts:'i node list -> unwinds:'i node list -> 
           returns:'i node list -> aborts: bool -> 'i conts 
@

Nodes have observable properties.

<<interface>>=
val cfg:        'i node -> 'i cfg       (* cfg this node belongs to *)
val instr:      'i node -> 'i           (* embedded instruction *)
val symbol:     'i node -> Reladdr.symbol option (* labels have symbols *)
val succ:       'i node -> 'i node list (* wrt. cf *)
val pred:       'i node -> 'i node list (* wrt. cf *)
val property:   'i node -> property
val number:     'i node -> int          (* pre: enumerated cfg *)
val defs:       rtlnode -> locs         (* locs defined by node *)
val uses:       rtlnode -> locs         (* locs used by node    *)
val kills:      rtlnode -> locs         (* locs killed by node  *)
@

The instruction inside a node can be updated using [[upd_instr]]. The
function doing the replacement is handed the existing instruction.

<<interface>>=
val upd_instr:   'i node -> ('i -> 'i) -> unit
@

Several code expansion steps require to modify an existing {\cfg}. All
these functions invalidate an existing enumeration. Beware that 

<<interface>>=
val gm_delete_assign:           'i node (* must be assign node! *) -> unit
val gm_redirect_all:    src:'i node -> olddst:'i node -> newdst:'i node -> unit
val gm_insert_assign_after:     'i node -> 'i  -> 'i node (* after assign! *)
val gm_insert_assign_before:    'i -> 'i node -> 'i node (* any node   *)
val gm_insert_assign_between:   'i -> src:'i node -> dst:'i node -> 'i node
val gm_insert_dataflow_between: defs:locs -> uses:locs -> kills:locs ->
                                src:'i node -> dst:'i node -> unit
@

An {\cfg} can be translated back into a procedure. This is mostly a
debugging feature to visualize a {\cfg}. 

<<interface>>=
val ast:    ('i -> Ast.stmt) -> 'i cfg -> name:string -> Ast.proc
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation consists of two layers: a low-level implementation
with objects, and a higher level that implements the interface from a
above directly. The consequence is, that [[nodes]] internally are
objects with different behavior. However, these behavioral differences
are hidden from the user.

The polymorphic nature of nodes comes at a prize: we can only use
polymorphic data structures to store notes and cannot build more
efficient ones using functors.

<<cfg4.ml>>=
module type S = sig
    <<interface>>
end    

module Property = Cfgprop
module A        = Ast
    
type locs       = Register.Set.t    (* locations for liveness analysis *)
type property   = Cfgprop.t         (* mutable data inside node *)

module OO = struct
    <<OO>>  (* low level object-oriented implementation *)
end

<<FP>>      (* high level functional implementation *)
@

% ------------------------------------------------------------------ 
\subsection{Type Classes for OO Implementation}
% ------------------------------------------------------------------ 

We define three different class types: [[cfg]] for the {\cfg}, [[node]]
for nodes, and [[labl]] for label, where [[labl]] is a sub-type of
[[node]]. 

<<OO>>=
class type ['i] cfg = object
    method nop:         'i                  (* the nop instruction *)
    method entry:       'i node             (* entry node of this *)
    method exit:        'i node             (* exit node of this *)
    method lookup:      string -> 'i node   (* find labeled node *)
    method label:       string -> Reladdr.symbol -> 'i node -> 'i node
                                            (* insert label before node *)
    
    method add:         'i node -> unit     (* add node to this; 
                                               est: enumerated = false *)
    method delete:      'i node -> unit     (* remove node *)
    method enumerate:   unit                (* enumerate all node in this *)
    method enumerated:  bool                (* true, iff nodes are enumerated *)
    method enumeration: 'i node array       (* req: enumerated *)
    method get_id:      unit -> int         (* unique *)
    method test:        unit                (* test integrity of this *)
    method ast:         ('i -> Ast.stmt) -> Ast.stmt list 
    method nodes:       'i node list        (* for debugging *)
    method anon:        string * Reladdr.symbol (* anon name/symbol pair *)
end
@

<<OO>>=
and ['i] node = object
    method cfg:         'i cfg          (* cfg this belongs to *)
    method instr:       'i              (* embedded instruction *)
    method symbol:      Reladdr.symbol option 
                                        (* symbols of this *)
    method id:          int             (* int of this *)
    method number:      int             (* number of this; req:cfg enumerated *)
    method succ:        'i node list    (* cf successors of this *)
    method pred:        'i node list    (* cf predecessors of this *)
    method property:    property        (* property of this *)

    method link_pred:   'i node -> unit (* add    in-edge from to pred node *)
    method unlink_pred: 'i node -> unit (* remove in-edge from to pred node *) 
    method unlink:      unit            (* unlink this from all other nodes *)
    method upd_succ:    ('i node -> 'i node) -> unit 
                                        (* redirect succs of this *)
    method upd_instr:   'i -> unit      (* set instr to new value *)
    method set_number:  int -> unit     (* defines number *)

    method defs:        locs            (* defined by this *)
    method uses:        locs            (* used by this    *)
    method kills:       locs            (* killed by this  *)
    
    method insert_assign_before:        'i -> 'i node (* returns new node *)
    method insert_assign_after :        'i -> 'i node (* returns new node *)  
    method insert_assign_on_edges_from: 'i -> before:'i node -> 'i node 

    method comment:     string          (* included into ast *)
    method ast:         ('i -> Ast.stmt) -> Ast.stmt
    method linorder:    'i node option * 'i node list (* default/other succs *)

    (* for debugging only *)
    method test:        unit            (* test integrity of this *)
end
@

<<OO>>=
class type ['i] labl = object
    inherit ['i] node 
    method set_succ:    'i node -> unit       (* set succ for this *)
    method set_symbol:  Reladdr.symbol -> unit
end

<<OO>>=
type 'i conts = { cuts    : 'i node list
                ; unwinds : 'i node list
                ; returns : 'i node list
                ; aborts  : bool
                }
@

% ------------------------------------------------------------------ 
\subsection{Node-related Utilities}
% ------------------------------------------------------------------ 

Edges in a {\cfg} cannot be simply added or removed, but only
redirected. This ensures that no edge gets lost. Redirection of edges is
specified by a client supplied function that maps the target of an edge
to a new node: [[node -> node]]. Whenever an edge is re-mapped, it must
be unlinked from the old destination and linked with the new
destination.  We create a function that does this by side-effect from
the client supplied [[map]]:

<<OO>>=
let upd (this:'i node) (map:'i node->'i node) = fun n -> 
    let n' = map n in
        if n' <> n then         (* edge gets redirected *)
            ( n  #unlink_pred this
            ; n' #link_pred   this
            ; n'
            )
        else
            n

let stmt x = A.StmtBody x
let decl x = A.DeclBody x
let data x = A.DataBody x

let compare x y = compare x#id y#id
@

The function [[nodup]] removes adjacent duplicates (according to the
comparison function [[cmp]]) from a list.  

<<OO>>=
let rec nodup cmp = function
    | x::(y::_ as tail) -> if cmp x y = 0 
                           then nodup cmp tail
                           else x :: nodup cmp tail
    | x                 -> x
@

The [[uniq]] function returns a duplicate-free list of nodes from a
list of nodes.  We use this function to compute duplicate-free list of
successors and predecessors.

<<OO>>=
let uniq nodes = nodup compare (List.sort compare nodes)   
@


% ------------------------------------------------------------------ 
\subsection{Graph Implementation}
% ------------------------------------------------------------------ 

A [[graph]] is an implementation of the [[cfg]] class type. Its main
purpose is to provide a container for all nodes and to manage named
labels.  The problem at hand is, that labels can be used before they are
defined. In that case a label node is created, but is successor is
unknown. It is patched in by the method that defines labels. 

<<OO>>=
class symbol (s:string) : Reladdr.symbol =
object
    method text = s
end

class ['i] graph nop:  ['i] cfg =
object (this)
    val         _nop            = (nop: 'i)
    val         _labels         = (Hashtbl.create 47: 
                                        (string,'i labl) Hashtbl.t)
                                    
    val mutable _nodes          = ([]: 'i node list) 
    val mutable _id             = 0
    val mutable _enumeration    = (None: 'i node array option)
    val mutable _entry          = (None: 'i node option)
    val mutable _exit           = (None: 'i node option)

    initializer
        let bot = new exit  (this:>'i cfg)     in
        let top = new entry (this:>'i cfg) bot in
            ( _entry <- Some top
            ; _exit  <- Some bot 
            ; _nodes <- top :: _nodes
            ; _nodes <- bot :: _nodes
            )

    method nop = _nop
    <<graph methods>>
end
@

Return the entry or exit node; both always exists.

<<graph methods>>=
method entry =
    match _entry with
    | None      -> assert false
    | Some node -> node

method exit =
    match _exit with
    | None      -> assert false
    | Some node -> node
@

Look up a label node node by its name. If it does not exist, create a
label, add it under its name and return it. Note that the returned node
is a [[labl]], a sub-type of [[node]], and thus has methods to update
the successor.
       
<<graph methods>>=    
method private lookup_label name =
    try Hashtbl.find _labels name
    with Not_found -> 
        let d = new label (this :> 'i cfg) in
            ( Hashtbl.add _labels name d 
            ; this#add (d :> 'i node)
            ; d (* this is a LABEL, subtype of NODE *)
            )
@

Lookup a label node by its name and return it as a [[node]]. A new node
is created if no such label is defined.

<<graph methods>>=
method lookup name = 
    (this#lookup_label name :> 'i node)
@

Add a label node in front of a node, i.e. the label node's successor is
the [[node]] passed into the method. 
   
<<graph methods>>=       
method label name symbol node =
    assert (List.mem node _nodes);      
    let label = this#lookup_label name in
        ( label#set_succ   node
        ; label#set_symbol symbol
        ; (label :> 'i node)
        )

method anon = 
    let l = Idgen.label "anon" in
        (l, new symbol l)
@

Add a node to [[this]] {\cfg}. Any enumeration is destroyed.

<<graph methods>>=       
method add node =
    ( _enumeration <- None
    ; _nodes <- node :: _nodes
    )
@

An enumeration numbers nodes increasingly, starting with 0, and creates
an array of nodes. The order is determined by the [[linorder]] method of
each node. This method returns a pair of an optional immediate successor
and a list of so-called delayed successors. The enumeration process
always respects the immediate successor of a node and continues with a
delayed successor when no immediate successor is available.

<<graph methods>>=
method enumerate =
    let rec loop (i:int) (acc: 'i node list) visited todo = match todo with
            | []                               -> acc
            | n::nn when List.mem n visited -> loop i acc visited nn
            | n::nn -> 
                let visited = n :: visited in
                let acc     = n::acc in     (* reverse order *)
                let i       = i+1 in
                let ()      = n#set_number i in
                    ( match n#linorder with
                    | Some x, [] -> loop i acc visited (x::nn) 
                    | Some x, tt -> loop i acc visited (x::nn@tt) (*XXX*)
                    | None  , [] -> loop i acc visited nn
                    | None  , tt -> loop i acc visited (nn@tt)    (*XXX*) 
                    ) in
        let entry = match _entry with None -> assert false | Some n -> n  in          
        let nodes = loop 0 [] [] [entry] in
        let nodes = List.rev nodes in
             _enumeration <- Some (Array.of_list nodes)
@

The [[enumerated]] predicate is true, if and only if a valid enumeration
exists. Structural changes to the {\cfg} destroy its enumeration. The
[[enumeration]] method returns an enumeration as an array of nodes.

<<graph methods>>=
method enumerated = 
    _enumeration <> None 

method enumeration =
    match _enumeration with
    | None       -> assert false
    | Some nodes -> nodes
@

Nodes have unique identities. The [[id]] method returns such a unique
identity.

<<graph methods>>=
method get_id () =
    ( _id <- _id + 1
    ; _id
    )
@

[[Delete]] removes a node from a {\cfg} by removing it from the set of
nodes and sending it a method that makes sure it unlinks itself from
adjacent nodes.

<<graph methods>>=
method delete node =
    ( _nodes <- List.filter (fun n -> n <> node) _nodes
    ; _enumeration <- None
    ; node#unlink
    )
@

[[Nodes]] returns the list of all nodes.

<<graph methods>>=
method nodes = _nodes
@

The [[test]] methods checks the integrity of a {\cfg}. Most work is done
at the individual nodes.

<<graph methods>>=
method test =
    ( assert (_entry <> None)
    ; assert (_exit  <> None)
    ; List.iter (fun n -> n#test) _nodes
    )
@

[[Ast]] returns an {\AST} representation of this {\cfg}.

<<graph methods>>=
method ast i2ast =
    let this = (this :> 'i cfg) in
        ( if not this#enumerated then this#enumerate else ()
        ; let f node result = (* A.CommentStmt(node#comment) :: *)
                              node#ast i2ast :: result in
            Array.fold_right f this#enumeration []
        )
@
% ------------------------------------------------------------------ 
\subsection{Virtual Node Implementation}
% ------------------------------------------------------------------ 

Each node is implemented as a separate class, but all nodes are derived
from a virtual class [[vnode]] which implements common behavior.

<<OO>>=
and  virtual ['i] vnode cfg instr =
object (this)
    val mutable _pred   = []
    val mutable _instr  = (instr: 'i)
    val         _cfg    = cfg
    val mutable _id     = (cfg#get_id ())
    val mutable _num    = -1 
    val mutable _prop   = (Property.empty ())       (* default properties *)
    
    initializer
        _cfg#add (this :> 'i node)

    method cfg      = _cfg
    method instr    = _instr
    method symbol   = None   (* overridden in label node *)
    method pred     = _pred
    method succ     = ([]: 'i node list)   (* make virtual? *)
    method id       = _id
    
    method number   = 
        assert (_cfg#enumerated); 
        _num

    method upd_succ map =
        ()

    method unlink =
        assert false    (* not defined in the general case! *)

    method link_pred node = 
        if not (List.mem node _pred) then 
            _pred <- node :: _pred
        
    method unlink_pred node =
        assert (List.mem node _pred);
        _pred <- List.filter (fun n -> n <> node) _pred

    method upd_instr (i:'i) = _instr <- i
    method defs         = Register.Set.empty (* I.defs _instr *)
    method uses         = Register.Set.empty (* I.uses _instr *)
    method kills        = Register.Set.empty
    method set_number i = _num <- i
    method property     = _prop
    
    method insert_assign_before (instr:'i) =
        let this        = (this :> 'i node) in
        let assign      = new assign _cfg instr (_cfg#exit) in 
        let redirect n  = if n = this then assign else n in
            ( List.iter  (fun n -> n#upd_succ redirect) _pred
            ; assign#upd_succ (fun n -> this)
            ; assign (* the new node *)
            )

    method insert_assign_after (instr:'i) = 
        invalid_arg "add_assign_after method for non-assignment node"

    method insert_assign_on_edges_from (instr:'i) ~(before:'i node) =
        let ()          = assert (List.mem before _pred) in
        let this        = (this :> 'i node) in
        let assign      = new assign _cfg instr this in
        let redirect n  = if n = this then assign else n in
            ( before#upd_succ redirect
            ; assign
            )
    
    (* comment about node kind *)
    method comment = 
        let this = (this :> 'i node) in
        let live = (this#property).Property.liveout in 
            Printf.sprintf 
                "num: %02d id: %d live: %s pred: %s succ: %s "
                _num
                _id
                (Register.print_set live) 
                (String.concat "," 
                    (List.map (fun n -> string_of_int n#id) this#pred))
                (String.concat "," 
                    (List.map (fun n -> string_of_int n#id) this#succ))

    method ast i2ast = i2ast _instr
    method virtual linorder: 'i node option * 'i node list

    (* this node must be in the predecessor list of each successor
     * if this node has more than two predecessors it must be labeled
     *    this is not enforced by this module but a dynamic property we
     *    like the client to maintain 
     *)

    method test =
        let this = (this :> 'i node) in
        let succ = this#succ in
        let pred = this#pred in
            ( assert (* check link structure *)
                (List.fold_left (fun r n -> r && (List.mem this n#pred)) 
                                true 
                                succ)
            )
end (* of vnode class *)
@

Nodes that deal with continuations share some structure that we factor
out into the [[vcut]] virtual class, which is itself a sub-class of
[[vnode]].

<<OO>>=
and virtual ['i] vcut cfg instr (conts: 'i conts) =
object (this)
    inherit ['i] vnode cfg instr as super

    val mutable _cuts    = conts.cuts
    val mutable _unwinds = conts.unwinds
    val mutable _returns = conts.returns
    val _aborts          = conts.aborts

    initializer
        let succ = List.concat [_cuts;_unwinds;_returns] in
            List.iter (fun n -> n#link_pred (this:>'i node)) succ

    method virtual succ     : 'i node list
    method virtual upd_succ : ('i node -> 'i node) -> unit
end
@

% ------------------------------------------------------------------ 
\subsection{Label}
% ------------------------------------------------------------------ 

Unlike other nodes can a [[label]] node exist without a successor. It
has a method to update the successor later. This is used to create a
label that is referenced in the {\cfg} before it is defined. 

<<OO>>=
and ['i] label cfg: ['i] labl =
object(this)
    inherit ['i] vnode cfg (cfg#nop) as super

    val mutable _succ   = (None: 'i node option) 
    val mutable _symbol = (None: Reladdr.symbol option)
    
    method symbol =
        ( assert (_symbol <> None) 
        ; _symbol
        )

    method set_succ node =
        ( assert (_succ = None)
        ; _succ <- Some node
        ; node#link_pred (this :> 'i node)
        )
    
    method set_symbol symbol =
        ( assert (_symbol = None)
        ; _symbol <- Some symbol
        )
    
    method succ =
        match _succ with
            | None   -> assert false (* must not happen *)
            | Some n -> [n]
    
    method upd_succ map =
        let map = upd (this :> 'i node) map in
        match _succ with
            | None   -> ()
            | Some n -> _succ <- Some (map n)
        
    method linorder = 
        ( match _succ with
          | None -> assert false (* must not happen *)
          | x    -> x
        , []
        )
    method ast i2ast = 
        let this    = (this :> 'i node) in
            match _symbol with
            | None   -> assert false (* undefined label! *)
            | Some s -> A.LabelStmt (s#text)
    
    method test =
        let this = (this :> 'i labl) in
            ( super#test
            ; assert (List.length this#pred <= 1 || _symbol <> None)
            )
end
@

% ------------------------------------------------------------------ 
\subsection{Entry Node}
% ------------------------------------------------------------------ 

<<OO>>=
and ['i] entry cfg exit: ['i] node =
object(this)
    inherit ['i] vnode cfg cfg#nop as super

    val mutable _succ = (exit:'i node)

    initializer 
        _succ # link_pred (this :> 'i node)

    method linorder = (Some _succ, [])

    method insert_assign_after (instr: 'i) =
        let this   = (this :> 'i node) in
        let assign = new assign _cfg instr (_succ) in
            ( _succ#unlink_pred this
            ; _succ <- assign
            ; _succ#link_pred this
            ; assign
            )
    
    method succ = [_succ]
    method upd_succ map = 
        let map = upd (this :> 'i node) map in
        _succ <- map _succ
end
@

% ------------------------------------------------------------------ 
\subsection{Exit Node}
% ------------------------------------------------------------------ 

<<OO>>=
and ['i] exit cfg: ['i] node =
object(this)
    inherit ['i] vnode cfg cfg#nop as super

    method linorder = (None, [])
end
@

% ------------------------------------------------------------------ 
\subsection{Assign Node}
% ------------------------------------------------------------------ 

<<OO>>=
and ['i] assign cfg instr succ : ['i] node =
object (this)
    inherit ['i] vnode cfg instr as super

    val mutable _succ = succ

    initializer 
        succ # link_pred (this :> 'i node)

    method succ = [_succ]

    method upd_succ map = 
        let map = upd (this :> 'i node) map in
        _succ <- map _succ

    method insert_assign_after (instr: 'i) =
        let this   = (this :> 'i node) in
        let assign = new assign _cfg instr (_succ) in
            ( _succ#unlink_pred this
            ; _succ <- assign
            ; _succ#link_pred this
            ; assign
            )
    
    method unlink =
        let this = (this :> 'i node) in
        let pred = match _pred with 
            | [x] -> x 
            | _   -> ( Printf.printf "problem: %s" this#comment
                     ; assert false 
                     )
        in
            ( pred#upd_succ (fun n -> if n = this then _succ else n)
            ; _succ#unlink_pred this
            ; _succ#link_pred pred
            )
        
    method linorder   = (Some _succ,[])
end
@

% ------------------------------------------------------------------ 
\subsection{Return Node}
% ------------------------------------------------------------------ 

<<OO>>=
class ['i] return cfg instr (x,y) : ['i] node  =
object (this)  
    inherit ['i] vnode cfg instr as super

    val         _x    = (x:int)
    val         _y    = (y:int)
    val mutable _exit = cfg#exit

    initializer 
        _exit # link_pred (this :> 'i node)
    
    method succ = [_exit]
    
    method upd_succ map =
        let map = upd (this :> 'i node) map in
        _exit <- map _exit

    method comment  = super#comment ^ " return"    
    method linorder = (None, [_exit])
end
@

% ------------------------------------------------------------------ 
\subsection{Goto Node}
% ------------------------------------------------------------------ 

<<OO>>=
class ['i] goto cfg instr targets : ['i] node =
object (this)
    inherit ['i] vnode cfg instr as super

    val mutable _targets = targets

    initializer
        List.iter (fun n -> n#link_pred (this :> 'i node)) _targets;
        assert (_targets <> [])

    method succ = uniq _targets      
    
    method upd_succ map =
        let map = upd (this :> 'i node) map in
        _targets <- List.map map _targets 

    method linorder = (None, _targets)
end
@

% ------------------------------------------------------------------ 
\subsection{Jump Node}
% ------------------------------------------------------------------ 

<<OO>>=
class ['i] jump cfg instr (targets:string list) : ['i] node =
object (this)
    inherit ['i] vnode cfg instr as super

    val mutable _targets = targets      
    val mutable _exit    = cfg#exit     (* artifical edge to exit *)
    
    initializer
        _exit#link_pred (this :> 'i node)

    method succ     = [_exit]   
    method linorder = (None, [_exit])
    
    method upd_succ map =
        let map = upd (this :> 'i node) map in
            _exit    <- map _exit
end
@

% ------------------------------------------------------------------ 
\subsection{Call Node}
% ------------------------------------------------------------------ 

<<OO>>=
class ['i] call cfg instr conts ~succ : ['i] node =
object (this)
    inherit ['i] vcut cfg instr conts as super

    val mutable _succ = (succ: 'i node)

    initializer 
        succ # link_pred (this :> 'i node)

    method succ =
        uniq (List.concat [ [_succ]; _cuts; _unwinds; _returns])

    method upd_succ map = 
        let map = upd (this :> 'i node) map in
        ( _cuts     <- List.map map _cuts
        ; _unwinds  <- List.map map _unwinds
        ; _returns  <- List.map map _returns
        ; _succ     <- map _succ
        ) 
    
    method linorder = 
        ( Some _succ
        , uniq(List.concat[_cuts;_unwinds;_returns])
        )
end
@

% ------------------------------------------------------------------ 
\subsection{Cutto Node}
% ------------------------------------------------------------------ 

<<OO>>=

class ['i] cutto cfg instr conts : ['i] node =
object (this)
    inherit ['i] vcut cfg instr conts as super

    val mutable _exit = (cfg#exit: 'i node)       (* artifical edge to exit *)

    initializer
        _exit # link_pred (this :> 'i node)

    method succ =
        uniq (List.concat [ [_exit]; _cuts; _unwinds; _returns])

    method upd_succ map = 
        let map = upd (this :> 'i node) map in
        ( _cuts     <- List.map map _cuts
        ; _unwinds  <- List.map map _unwinds
        ; _returns  <- List.map map _returns
        ; _exit     <- map _exit
        ) 
    
    method linorder = 
        ( None
        , uniq(List.concat[_cuts;_unwinds;_returns;[_exit]])
        )
end
@

% ------------------------------------------------------------------ 
\subsection{Branch Node}
% ------------------------------------------------------------------ 

<<OO>>=
class ['i] branch cfg instr (ifso:'i node) (ifnot:'i node) : ['i] node =
object (this)
    inherit ['i] vnode cfg instr  as super

    val mutable _ifso  = ifso
    val mutable _ifnot = ifnot

    initializer
        ( _ifso  # link_pred (this :> 'i node)
        ; _ifnot # link_pred (this :> 'i node)
        )

    method succ =
        uniq [_ifso;_ifnot]

    method upd_succ map =
        let map = upd (this :> 'i node) map in
        ( _ifso  <- map _ifso
        ; _ifnot <- map _ifnot
        )
    
    method linorder = 
        ( Some _ifnot
        , [_ifso]
        )
end
@

% ------------------------------------------------------------------ 
\subsection{Dataflow Node}
% ------------------------------------------------------------------ 

Dataflow nodes are synthetic nodes to inform the data-flow analysis
about data flow that otherwise would be missed.

<<OO>>=
class ['i] dataflow cfg (succ:'i node) 
    (defs:locs) (uses:locs) (kills:locs) : ['i] node =
object (this)
    inherit ['i] vnode cfg cfg#nop as super

    val mutable _succ = succ
    val _defs         = defs
    val _uses         = uses
    val _kills       = kills

    initializer
        _succ # link_pred (this :> 'i node)

    method succ =
        [_succ]

    method upd_succ map =
        let map = upd (this :> 'i node) map in
        _succ <- map _succ

    method defs   = _defs
    method uses   = _uses
    method kills  = _kills
   
    method linorder = ( Some _succ , [])
end
@


% ------------------------------------------------------------------ 
\subsection{High-Level Implementation}
% ------------------------------------------------------------------ 

The high-level implementation delegates most of the work to the
object-oriented implementation. This applies both to types and values: 

<<FP>>=
type 'i cfg        = 'i OO.cfg             (* class type cfg  *)
type 'i node       = 'i OO.node            (* class type node *)
type 'i conts      = 'i OO.conts           (* continuation bundle *)
type rtlcfg        = Rtl.rtl cfg       (* important special case *)
type rtlnode       = Rtl.rtl node      (* important special case *)
@

Constructors for continuation bundles, graphs, and nodes:

<<FP>>=
let conts ~cuts ~unwinds ~returns ~aborts =
    { OO.cuts    = cuts
    ; OO.unwinds = unwinds
    ; OO.returns = returns
    ; OO.aborts  = aborts
    }

let mk ~nop:n   = new OO.graph n 
let gm_return   = new OO.return
let gm_goto     = new OO.goto
let gm_jump     = new OO.jump
let gm_cutto    = new OO.cutto
let gm_call     = new OO.call
let gm_branch cfg rtl ~ifso ~ifnot = new OO.branch cfg rtl ifso ifnot
let gm_assign cfg rtl ~succ = new OO.assign cfg rtl succ

@

Graph observations.

<<FP>>=

let lookup cfg (label:string) = cfg#lookup label
let entry cfg                 = cfg#entry
let exit cfg                  = cfg#exit

let gm_label cfg (label:string) (sym:Reladdr.symbol) ~(succ:'i node) =
    cfg#label label sym succ 

let first cfg = 
    assert (cfg#enumerated);
    assert ((Array.length (cfg#enumeration)) >= 2);
    let enum = cfg#enumeration in
        enum.(0)

let last  cfg = 
    assert (cfg#enumerated);
    assert ((Array.length (cfg#enumeration)) >= 2);
    let enum = cfg#enumeration    in
    let len  = Array.length enum in
        enum.(len-1)
@

Iterators work only on enumerated graphs. They are stable under
modification in the sense that an enumeration snapshot is taken for the
iteration and thus any changes to the graph structure is \emph{not}
taken into account while the iteration is active.

<<FP>>=
let scan_fwd (cfg:'i cfg) ~(first:int) ~(limit:int) f zero = 
    assert (cfg#enumerated);
    assert (first >= 1);
    assert (limit <= ((Array.length (cfg#enumeration)) + 1));
    let enum = cfg#enumeration in
    let rec loop n result =     (* n is one-based *)
        if n = limit then 
            result
        else
            loop (n+1) (f enum.(n-1) result)
    in
        loop first zero


let scan_bwd (cfg:'i cfg) ~(first:int) ~(limit:int) f zero = 
    assert (cfg#enumerated);
    assert (first >= 1);
    assert (limit <= ((Array.length (cfg#enumeration)) + 1));
    let enum = cfg#enumeration in
    let rec loop n result =     (* n is one-based *)
        if n < first then 
            result
        else
            loop (n-1) (f enum.(n-1) result)
    in
        loop (limit-1) zero

let next (node:'i node) = 
    assert (node#cfg#enumerated);
    let n    = node#number     in   (* 1 ... |G|   *)
    let cfg  = node#cfg        in
    let enum = cfg#enumeration in   (* 0 ..  |G|-1 *)
        if n < (Array.length enum) then
            Some enum.(n)
        else
            None
    
let prev (node:'i node) = 
    assert (node#cfg#enumerated);
    let n    = node#number     in   (* 1 ... |G|   *)
    let cfg  = node#cfg        in
    let enum = cfg#enumeration in   (* 0 ..  |G|-1 *)
        if 1 < n then
            Some enum.(n-2)
        else
            None
@


Node observation functions just delegate the work to the object
representing the node.

<<FP>>=
let cfg         (node:'i node) = node#cfg
let instr       (node:'i node) = node#instr
let symbol      (node:'i node) = node#symbol
let succ        (node:'i node) = node#succ
let pred        (node:'i node) = node#pred
let property    (node:'i node) = node#property
let number      (node:'i node) = node#number

let kills (node:Rtl.rtl node) = Register.Set.empty
let defs  (node:Rtl.rtl node) = 
    let _,write = Rtlutil.ReadWrite.sets (instr node) in write
let uses  (node:Rtl.rtl node) = 
    let read,_  = Rtlutil.ReadWrite.sets (instr node) in read
@

[[Upd_instr]] updates the instruction embedded into a node but does not
change the structure of an {\rtl}.

<<FP>>=
let upd_instr (node:'i node) (map:'i -> 'i) = node#upd_instr (map node#instr)
@

Graph mutators change the structure of a {\cfg} and invalidate any
enumeration. However, they still can be used with [[scan_fwd]] and
[[scan_bwd]] because these take snapshots of an enumeration first.

<<FP>>=
let gm_redirect_all ~src ~olddst ~newdst =
    src#upd_succ (fun n -> if n = olddst then newdst else n)

let gm_insert_assign_before (instr:'i) (node:'i node) =
    node#insert_assign_before instr

let gm_insert_assign_after (node:'i node) (instr:'i) =
    node#insert_assign_after instr

let gm_insert_assign_between (instr:'i ) ~(src:'i node) ~(dst:'i node) =
    dst#insert_assign_on_edges_from instr src

let gm_insert_dataflow_between ~defs ~uses ~kills ~src ~dst =
    let cfg  = src#cfg          in
    let exit = cfg#exit         in
    (*** debugging 
    let _    =
        ( Printf.printf "src: %d %s\n" src#id src#comment
        ; Printf.printf "dst: %d %s\n" dst#id dst#comment
        ) in
     ***)    
    let node = new OO.dataflow cfg exit defs uses kills in
        ( src#upd_succ (fun n -> if n = dst then node else n)
        ; node#upd_succ (fun n -> dst)
        )

let gm_delete_assign (node:'i node) =
    let cfg = node#cfg in
        cfg#delete node

let gm_enumerate (cfg:'i cfg) = 
    if cfg#enumerated then      (* risky if out #enumerated lies *)
        ()
    else    
        cfg#enumerate

let ast i2ast (cfg:'i cfg) ~(name:string) = 
    cfg#test;   (* check integrity *)    
    ( None
    , name
    , []
    , List.map (fun s -> Ast.StmtBody s) (cfg#ast i2ast)
    )

@








