% vim: ts=8 sw=4 et: 
% Daddy, why are we hiding from the police? They use Emacs, son, we use Vi.
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% 
% $Id$

% ------------------------------------------------------------------ 
\section{Control-Flow Graph}
% ------------------------------------------------------------------ 

\emph{See the documents in the directory [[doc/]] for design problems
here.}

The executable part of a procedure is represented as a control-flow
graph (\cfg). The graph is polymorphic over instructions that are
embedded into its nodes. The most important specialization is when
{\rtl}s are used as instruction representation.

<<cfg4.mli>>=
module type S = sig
    <<interface>>
end
<<interface>>
@

<<interface>>=
type cfg        (* 'i = instruction represenstation *)
type node       (* node inside a cfg *)
type conts      (* continuation bundle *)

type locs       = Register.Set.t    (* locations for liveness analysis *)
type property   = Cfgprop.t         (* mutable data inside node *)
@

% ------------------------------------------------------------------ 
\subsection{Problems}
% ------------------------------------------------------------------ 

Add observations of problems here.

\begin{itemize}

\item The {\cfg} aims to be polymorphic over the instructions embedded
      into nodes. Any change of the instruction representation still
      requires an isomoprhic copy of the {\cfg} and thus the polymorphic
      type is not any better than a functorized representation. Only an
      existential for the instruction representation would allow a
      gradual update of instructions without having to copy the {\cfg}.
      See also the problem below about the target dependency that also
      destroys polymorphism. For the moment I will give up polymorphism.

\item {\rtl}s for control-flow nodes represent neither machine
      instructions, nor are they target independent. Maybe it would be
      better to not assign {\rtl}s to these nodes. See also the
      discussion in \module{targets.nw}.

\item Symbols and {\rtl}s that are part of nodes are passed to node
      constructor functions. This makes it difficult to create certain
      nodes as part of a {\cfg} re-write step. I rather would keep
      symbols outside of this module. I now believe that the
      construction of a {\cfg} should not require machine-specific
      knowledge. All machine specific knowledge should come in during
      code-expansion or later. For the time being, I will pass the
      current target into the {\cfg} consructor. The target allows only
      {\rtl}-based instructions and thus when an instruction 

\item John Dias wants to traverse and mutate the {\cfg} at the same time.
      This is in general unsafe. How can we support it anyway?

\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Functions}
% ------------------------------------------------------------------ 

The [[mk]] function that creates a {\cfg} receives an instruction
denoting a no-op instruction.

<<interface>>=
val mk:         target:Target2.t -> nop:Rtl.rtl -> cfg   (* empty cfg *)
val lookup:     cfg -> string -> node        (* lookup label *)
@

Every {\cfg} has two special nodes: [[entry]] and [[exit]]. They cannot
be removed.

<<interface>>=
val entry:      cfg -> node   
val exit:       cfg -> node
@

The nodes in a {\cfg} can be enumerated with integers $0, \dots, n$. An
enumeration is destroyed by functions that mutate the structure of the
{\cfg}. Such functions' names are prefixed by [[gm]]. The number of a
node can be observed with [[number]].

<<interface>>=
val gm_enumerate:   cfg -> unit     (* post: enumerated cfg *)
@

Traversal of a {\cfg} requires it to be enumerated. All traversal is
relative to the enumeration. See module \module{Cfgutil} for convenience
functions. The [[scan]] function take a snapshot of an enumeration and
thus allows the client to change the {\cfg} structure; however, these
changes will \emph{not} be taken into account during the active
traversal.

<<interface>>=
val first:      cfg -> node (* wrt numbering *)
val last:       cfg -> node (* wrt numbering *)
val scan_fwd:   cfg -> first:int -> limit:int 
                       -> (node -> 'a -> 'a) -> 'a -> 'a 
val scan_bwd:   cfg -> first:int -> limit:int 
                       -> (node -> 'a -> 'a) -> 'a -> 'a
val next:       node -> node option
val prev:       node -> node option
@

We have just one node type, but specific functions to create them. This
helps to minimize errors with the right number of successors. Except for
[[label]] nodes, nodes created with functions below must have exactly
one predecessor.

<<interface>>=
val gm_label:   cfg -> string -> Symbol.t -> succ:node -> node 
val gm_assign:  cfg -> Rtl.rtl -> succ:node -> node
val gm_return:  cfg -> Rtl.rtl -> int * int -> node
val gm_goto:    cfg -> Rtl.rtl -> node list -> node
val gm_jump:    cfg -> Rtl.rtl -> string list -> node
val gm_cutto:   cfg -> Rtl.rtl -> conts -> node
val gm_call:    cfg -> Rtl.rtl -> conts 
                               -> spans:( Bits.t 
                                        * (Symbol.t option * Bits.t)
                                        ) list 
                               -> succ:node 
                               -> node
val gm_branch:  cfg -> Rtl.rtl -> ifso:node -> ifnot:node -> node
@

A continuation bundle is basically a vector of nodes.

<<interface>>=
val conts: cuts:node list -> unwinds:node list -> 
           returns:node list -> aborts: bool -> conts 
@

Nodes have observable properties.

<<interface>>=
val cfg:        node -> cfg       (* cfg this node belongs to *)
val instr:      node -> Rtl.rtl           (* embedded instruction *)
val symbol:     node -> Symbol.t option (* labels have symbols *)
val succ:       node -> node list (* wrt. cf *)
val pred:       node -> node list (* wrt. cf *)
val property:   node -> property
val number:     node -> int          (* pre: enumerated cfg *)
val defs:       node -> locs         (* locs defined by node *)
val uses:       node -> locs         (* locs used by node    *)
val kills:      node -> locs         (* locs killed by node  *)

val node_info_string: node -> string
val is_call:    node -> bool         (* identify call nodes *)
@

The instruction inside a node can be updated using [[upd_instr]]. The
function doing the replacement is handed the existing instruction.

<<interface>>=
val upd_instr:   node -> (Rtl.rtl -> Rtl.rtl) -> unit
@

Several code expansion steps require to modify an existing {\cfg}. All
these functions invalidate an existing enumeration. Beware that 

<<interface>>=
val gm_delete_assign:           node (* must be assign node! *) -> unit
val gm_redirect_all:    src:node -> olddst:node -> newdst:node -> unit
val gm_insert_assign_after:     node -> Rtl.rtl -> node (* after assign! *)
val gm_insert_assign_before:    Rtl.rtl -> node -> node (* any node   *)
val gm_insert_assign_between:   Rtl.rtl -> src:node -> dst:node -> node
val gm_insert_dataflow_between: defs:locs -> uses:locs -> kills:locs ->
                                src:node -> dst:node -> unit
@

An {\cfg} can be translated back into a procedure. This is mostly a
debugging feature to visualize a {\cfg}. 

<<interface>>=
val ast:    (Rtl.rtl -> Ast.stmt) -> cfg -> name:string -> Ast.proc
val interp: cfg -> out_channel -> unit
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation consists of two layers: a low-level implementation
with objects, and a higher level that implements the interface from a
above directly. The consequence is, that [[nodes]] internally are
objects with different behavior. However, these behavioral differences
are hidden from the user.

The polymorphic nature of nodes comes at a prize: we can only use
polymorphic data structures to store notes and cannot build more
efficient ones using functors.

<<cfg4.ml>>=
module type S = sig
    <<interface>>
end    

module Property = Cfgprop
module A        = Ast
    
type locs       = Register.Set.t    (* locations for liveness analysis *)
type property   = Cfgprop.t         (* mutable data inside node *)

module OO = struct
    let fprintf = Printf.fprintf
    let  printf = Printf.printf
    let sprintf = Printf.sprintf

    <<OO>>  (* low level object-oriented implementation *)
end

<<FP>>      (* high level functional implementation *)
@

% ------------------------------------------------------------------ 
\subsection{Type Classes for OO Implementation}
% ------------------------------------------------------------------ 

We define three different class types: [[cfg]] for the {\cfg}, [[node]]
for nodes, and [[labl]] for label, where [[labl]] is a sub-type of
[[node]]. 

<<OO>>=
class type  cfg = object
    method nop:         Rtl.rtl                  (* the nop instruction *)
    method target:      Target2.t           (* current target *)
    method entry:       node             (* entry node of this *)
    method exit:        node             (* exit node of this *)
    method lookup:      string -> node   (* find labeled node *)
    method label:       string -> Symbol.t -> node -> node
                                            (* insert label before node *)
    
    method add:         node -> unit     (* add node to this; 
                                               est: enumerated = false *)
    method delete:      node -> unit     (* remove node *)
    method enumerate:   unit                (* enumerate all node in this *)
    method enumerated:  bool                (* true, iff nodes are enumerated *)
    method enumeration: node array       (* req: enumerated *)
    method get_id:      unit -> int         (* unique *)
    method test:        unit                (* test integrity of this *)
    method ast:         (Rtl.rtl -> Ast.stmt) -> Ast.stmt list 
    method nodes:       node list        (* for debugging *)
    method anon:        string * Symbol.t (* anon name/symbol pair *)
    method interp:      out_channel -> unit
end
@

<<OO>>=
and  node = object
    method cfg:         cfg          (* cfg this belongs to *)
    method instr:       Rtl.rtl
    method symbol:      Symbol.t option 
                                        (* symbols of this *)
    method id:          int             (* int of this *)
    method number:      int             (* number of this; req:cfg enumerated *)
    method succ:        node list    (* cf successors of this *)
    method pred:        node list    (* cf predecessors of this *)
    method property:    property        (* property of this *)

    method link_pred:   node -> unit (* add    in-edge from to pred node *)
    method unlink_pred: node -> unit (* remove in-edge from to pred node *) 
    method unlink:      unit            (* unlink this from all other nodes *)
    method upd_succ:    (node -> node) -> unit 
                                        (* redirect succs of this *)
    method upd_instr:   Rtl.rtl -> unit      (* set instr to new value *)
    method set_number:  int -> unit     (* defines number *)

    method defs:        locs            (* defined by this *)
    method uses:        locs            (* used by this    *)
    method kills:       locs            (* killed by this  *)
    
    method insert_assign_before:        Rtl.rtl -> node (* returns new node *)
    method insert_assign_after :        Rtl.rtl -> node (* returns new node *)  
    method insert_assign_on_edges_from: Rtl.rtl -> before:node -> node 

    method node_info_string:     string          (* included into ast *)
    method is_call:     bool         (* identify call nodes *)
    method ast:         (Rtl.rtl -> Ast.stmt) -> Ast.stmt
    method linorder:    node option * node list (* default/other succs *)

    (* for debugging only *)
    method test:        unit            (* test integrity of this *)

    (* emit code for Reuben's interpreter *)
    method interp:      out_channel -> unit
end
@

<<OO>>=
class type  labl = object
    inherit  node 
    method set_succ:    node -> unit       (* set succ for this *)
    method set_symbol:  Symbol.t -> unit
end

<<OO>>=
type conts    = { cuts    : node list
                ; unwinds : node list
                ; returns : node list
                ; aborts  : bool
                }
@

% ------------------------------------------------------------------ 
\subsection{Node-related Utilities}
% ------------------------------------------------------------------ 

Edges in a {\cfg} cannot be simply added or removed, but only
redirected. This ensures that no edge gets lost. Redirection of edges is
specified by a client supplied function that maps the target of an edge
to a new node: [[node -> node]]. Whenever an edge is re-mapped, it must
be unlinked from the old destination and linked with the new
destination.  We create a function that does this by side-effect from
the client supplied [[map]]:

<<OO>>=
let upd (this:node) (map:node->node) = fun n -> 
    let n' = map n in
        if n' <> n then         (* edge gets redirected *)
            ( n  #unlink_pred this
            ; n' #link_pred   this
            ; n'
            )
        else
            n

let stmt x = A.StmtBody x
let decl x = A.DeclBody x
let data x = A.DataBody x

let compare x y = compare x#id y#id
@

The function [[nodup]] removes adjacent duplicates (according to the
comparison function [[cmp]]) from a list.  

<<OO>>=
let rec nodup cmp = function
    | x::(y::_ as tail) -> if cmp x y = 0 
                           then nodup cmp tail
                           else x :: nodup cmp tail
    | x                 -> x
@

The [[uniq]] function returns a duplicate-free list of nodes from a
list of nodes.  We use this function to compute duplicate-free list of
successors and predecessors.

<<OO>>=
let uniq nodes = nodup compare (List.sort compare nodes)   
@


% ------------------------------------------------------------------ 
\subsection{Graph Implementation}
% ------------------------------------------------------------------ 

A [[graph]] is an implementation of the [[cfg]] class type. Its main
purpose is to provide a container for all nodes and to manage named
labels.  The problem at hand is, that labels can be used before they are
defined. In that case a label node is created, but is successor is
unknown. It is patched in by the method that defines labels. 


Some algorithm below needs to create new labels and hence new symbols.
Symbols as usually issued by an assembler. Since this context is not
available, here is a new source for symbols. This is a very bad hack
because symbols are assembler specific and in particular, are
responsible for name mangling. 

<<OO>>=
class symbol (s:string) : Symbol.t =
object
    method text = s
end

class  graph target nop:   cfg =
object (this)
    val         _nop            = (nop: 'i)
    val         _target         = target
    val         _labels         = (Hashtbl.create 47: 
                                        (string,labl) Hashtbl.t)
                                    
    val mutable _nodes          = ([]: node list) 
    val mutable _id             = 0
    val mutable _enumeration    = (None: node array option)
    val mutable _entry          = (None: node option)
    val mutable _exit           = (None: node option)

    initializer
        let bot = new exit  (this:>cfg)     in
        let top = new entry (this:>cfg) bot in
            ( _entry <- Some top
            ; _exit  <- Some bot 
            ; _nodes <- top :: _nodes
            ; _nodes <- bot :: _nodes
            )

    method nop    = _nop
    method target = _target
    <<graph methods>>
end
@

Return the entry or exit node; both always exists.

<<graph methods>>=
method entry =
    match _entry with
    | None      -> assert false
    | Some node -> node

method exit =
    match _exit with
    | None      -> assert false
    | Some node -> node
@

Look up a label node node by its name. If it does not exist, create a
label, add it under its name and return it. Note that the returned node
is a [[labl]], a sub-type of [[node]], and thus has methods to update
the successor.
       
<<graph methods>>=    
method private lookup_label name =
    try Hashtbl.find _labels name
    with Not_found -> 
        let d = new label (this :> cfg) in
            ( Hashtbl.add _labels name d 
            ; this#add (d :> node)
            ; d (* this is a LABEL, subtype of NODE *)
            )
@

Lookup a label node by its name and return it as a [[node]]. A new node
is created if no such label is defined.

<<graph methods>>=
method lookup name = 
    (this#lookup_label name :> node)
@

Add a label node in front of a node, i.e. the label node's successor is
the [[node]] passed into the method. 
   
To avoid trouble with control-flow that falls into a label, we create a
label and an explicit [[goto]] to it as the direct successor that is
returned. The construction of the [[goto]] node is complicated because
it relies on target specific informations. See the section about
problems above.

<<graph methods>>=       
method label name symbol node =
    assert (List.mem node _nodes); 
    let target = this#target in
    let label  = this#lookup_label name in
    let label' = (label :> node) in
    let e      = Rtl.link symbol target.Target2.pointersize in
    let rtl    = target.Target2.goto.Target2.embed e in
    let goto   = new goto (this :> cfg) rtl [label'] in
        ( label#set_succ   node
        ; label#set_symbol symbol
        ; goto
        )

method anon = 
    let l = Idgen.label "anon" in
        (l, new symbol l)
@

Add a node to [[this]] {\cfg}. Any enumeration is destroyed.

<<graph methods>>=       
method add node =
    ( _enumeration <- None
    ; _nodes <- node :: _nodes
    )
@

An enumeration numbers nodes increasingly, starting with 0, and creates
an array of nodes. The order is determined by the [[linorder]] method of
each node. This method returns a pair of an optional immediate successor
and a list of so-called delayed successors. The enumeration process
always respects the immediate successor of a node and continues with a
delayed successor when no immediate successor is available.

<<graph methods>>=
method enumerate =
    let rec loop (i:int) (acc: node list) visited todo = match todo with
            | []                               -> acc
            | n::nn when List.mem n visited -> loop i acc visited nn
            | n::nn -> 
                let visited = n :: visited in
                let acc     = n::acc in     (* reverse order *)
                let i       = i+1 in
                let ()      = n#set_number i in
                    ( match n#linorder with
                    | Some x, [] -> loop i acc visited (x::nn) 
                    | Some x, tt -> loop i acc visited (x::nn@tt) (*XXX*)
                    | None  , [] -> loop i acc visited nn
                    | None  , tt -> loop i acc visited (nn@tt)    (*XXX*) 
                    ) in
        let entry = match _entry with None -> assert false | Some n -> n  in          
        let nodes = loop 0 [] [] [entry] in
        let nodes = List.rev nodes in
             _enumeration <- Some (Array.of_list nodes)
@

The [[enumerated]] predicate is true, if and only if a valid enumeration
exists. Structural changes to the {\cfg} destroy its enumeration. The
[[enumeration]] method returns an enumeration as an array of nodes.

<<graph methods>>=
method enumerated = 
    _enumeration <> None 

method enumeration =
    match _enumeration with
    | None       -> assert false
    | Some nodes -> nodes
@

Nodes have unique identities. The [[id]] method returns such a unique
identity.

<<graph methods>>=
method get_id () =
    ( _id <- _id + 1
    ; _id
    )
@

[[Delete]] removes a node from a {\cfg} by removing it from the set of
nodes and sending it a method that makes sure it unlinks itself from
adjacent nodes.

<<graph methods>>=
method delete node =
    ( _nodes <- List.filter (fun n -> n <> node) _nodes
    ; _enumeration <- None
    ; node#unlink
    )
@

[[Nodes]] returns the list of all nodes.

<<graph methods>>=
method nodes = _nodes
@

The [[test]] methods checks the integrity of a {\cfg}. Most work is done
at the individual nodes.

<<graph methods>>=
method test =
    ( assert (_entry <> None)
    ; assert (_exit  <> None)
    ; List.iter (fun n -> n#test) _nodes
    )
@

[[Ast]] returns an {\AST} representation of this {\cfg}.

<<graph methods>>=
method ast i2ast =
    let this = (this :> cfg) in
        ( if not this#enumerated then this#enumerate else ()
        ; let f node result = (* A.CommentStmt(node#node_info_string) :: *)
                              node#ast i2ast :: result in
            Array.fold_right f this#enumeration []
        )

method interp fd =
    let this = (this :> cfg) in
        ( if not this#enumerated then this#enumerate else ()
        ; Array.iter (fun node -> node#interp fd) this#enumeration 
        )
    

@
% ------------------------------------------------------------------ 
\subsection{Virtual Node Implementation}
% ------------------------------------------------------------------ 

Each node is implemented as a separate class, but all nodes are derived
from a virtual class [[vnode]] which implements common behavior.

<<OO>>=
and  virtual  vnode cfg instr =
object (this)
    val mutable _pred   = []
    val mutable _instr  = (instr: 'i)
    val         _cfg    = cfg
    val mutable _id     = (cfg#get_id ())
    val mutable _num    = -1 
    val mutable _prop   = (Property.empty ())       (* default properties *)
    
    initializer
        _cfg#add (this :> node)

    method cfg      = _cfg
    method instr    = _instr
    method symbol   = None   (* overridden in label node *)
    method pred     = _pred
    method succ     = ([]: node list)   (* make virtual? *)
    method id       = _id
    
    method number   = 
        assert (_cfg#enumerated); 
        _num

    method upd_succ map =
        ()

    method unlink =
        assert false    (* not defined in the general case! *)

    method link_pred node = 
        if not (List.mem node _pred) then 
            _pred <- node :: _pred
        
    method unlink_pred node =
        assert (List.mem node _pred);
        _pred <- List.filter (fun n -> n <> node) _pred

    method upd_instr (i:'i) = _instr <- i
    method defs         = Register.Set.empty (* I.defs _instr *)
    method uses         = Register.Set.empty (* I.uses _instr *)
    method kills        = Register.Set.empty
    method set_number i = _num <- i
    method property     = _prop
    
    method insert_assign_before (instr:'i) =
        let this        = (this :> node) in
        let assign      = new assign _cfg instr (_cfg#exit) in 
        let redirect n  = if n = this then assign else n in
            ( List.iter  (fun n -> n#upd_succ redirect) _pred
            ; assign#upd_succ (fun n -> this)
            ; assign (* the new node *)
            )

    method insert_assign_after (instr:'i) = 
        invalid_arg "add_assign_after method for non-assignment node"

    method insert_assign_on_edges_from (instr:'i) ~(before:node) =
        let ()          = assert (List.mem before _pred) in
        let this        = (this :> node) in
        let assign      = new assign _cfg instr this in
        let redirect n  = if n = this then assign else n in
            ( before#upd_succ redirect
            ; assign
            )
    
    (* comment about node kind *)
    method node_info_string = 
        let this = (this :> node) in
        let live = (this#property).Property.liveout in 
            Printf.sprintf 
                "num: %02d id: %d live: %s pred: %s succ: %s "
                _num
                _id
                (Register.print_set live) 
                (String.concat "," 
                    (List.map (fun n -> string_of_int n#id) this#pred))
                (String.concat "," 
                    (List.map (fun n -> string_of_int n#id) this#succ))

    method is_call = false

    method ast i2ast = i2ast _instr
    method virtual linorder: node option * node list

    (* this node must be in the predecessor list of each successor
     * if this node has more than two predecessors it must be labeled
     *    this is not enforced by this module but a dynamic property we
     *    like the client to maintain 
     *)

    method test =
        let this = (this :> node) in
        let succ = this#succ in
        let pred = this#pred in
            ( assert (* check link structure *)
                (List.fold_left (fun r n -> r && (List.mem this n#pred)) 
                                true 
                                succ)
            )

    method virtual interp: out_channel -> unit

end (* of vnode class *)
@

Nodes that deal with continuations share some structure that we factor
out into the [[vcut]] virtual class, which is itself a sub-class of
[[vnode]].

<<OO>>=
and virtual  vcut cfg instr (conts: conts) =
object (this)
    inherit  vnode cfg instr as super

    val mutable _cuts    = conts.cuts
    val mutable _unwinds = conts.unwinds
    val mutable _returns = conts.returns
    val _aborts          = conts.aborts

    initializer
        let succ = List.concat [_cuts;_unwinds;_returns] in
            List.iter (fun n -> n#link_pred (this:>node)) succ

    method virtual succ     : node list
    method virtual upd_succ : (node -> node) -> unit
end
@

% ------------------------------------------------------------------ 
\subsection{Label}
% ------------------------------------------------------------------ 

Unlike other nodes can a [[label]] node exist without a successor. It
has a method to update the successor later. This is used to create a
label that is referenced in the {\cfg} before it is defined. 

<<OO>>=
and  label cfg:  labl =
object(this)
    inherit  vnode cfg (cfg#nop) as super

    val mutable _succ   = (None: node option) 
    val mutable _symbol = (None: Symbol.t option)
    
    method symbol =
        ( assert (_symbol <> None) 
        ; _symbol
        )

    method set_succ node =
        ( assert (_succ = None)
        ; _succ <- Some node
        ; node#link_pred (this :> node)
        )
    
    method set_symbol symbol =
        ( assert (_symbol = None)
        ; _symbol <- Some symbol
        )
    
    method succ =
        match _succ with
            | None   -> assert false (* must not happen *)
            | Some n -> [n]
    
    method upd_succ map =
        let map = upd (this :> node) map in
        match _succ with
            | None   -> ()
            | Some n -> _succ <- Some (map n)
        
    method linorder = 
        ( match _succ with
          | None -> assert false (* must not happen *)
          | x    -> x
        , []
        )
    method ast i2ast = 
        let this    = (this :> node) in
            match _symbol with
            | None   -> assert false (* undefined label! *)
            | Some s -> A.LabelStmt (s#text)
    
    method test =
        let this = (this :> labl) in
            ( super#test
            ; assert (List.length this#pred <= 1 || _symbol <> None)
            )  
 
    method interp fd =
        match _symbol with
        | None   -> assert false
        | Some s -> 
            fprintf fd "CMM.define_label('%s') -- %s \n" 
                s#text
                "could be a continuation node"
end
@

% ------------------------------------------------------------------ 
\subsection{Entry Node}
% ------------------------------------------------------------------ 

<<OO>>=
and  entry cfg exit:  node =
object(this)
    inherit  vnode cfg cfg#nop as super

    val mutable _succ = (exit:node)

    initializer 
        _succ # link_pred (this :> node)

    method linorder = (Some _succ, [])

    method insert_assign_after (instr: Rtl.rtl) =
        let this   = (this :> node) in
        let assign = new assign _cfg instr (_succ) in
            ( _succ#unlink_pred this
            ; _succ <- assign
            ; _succ#link_pred this
            ; assign
            )
    
    method succ = [_succ]
    method upd_succ map = 
        let map = upd (this :> node) map in
        _succ <- map _succ
    method interp fd = () (* do nothing *)    
end
@

% ------------------------------------------------------------------ 
\subsection{Exit Node}
% ------------------------------------------------------------------ 

<<OO>>=
and  exit cfg:  node =
object(this)
    inherit  vnode cfg cfg#nop as super

    method linorder = (None, [])
    method interp fd = () (* nothing *)
end
@

% ------------------------------------------------------------------ 
\subsection{Assign Node}
% ------------------------------------------------------------------ 

<<OO>>=
and  assign cfg instr succ :  node =
object (this)
    inherit  vnode cfg instr as super

    val mutable _succ = succ

    initializer 
        succ # link_pred (this :> node)

    method succ = [_succ]

    method upd_succ map = 
        let map = upd (this :> node) map in
        _succ <- map _succ

    method insert_assign_after (instr: 'i) =
        let this   = (this :> node) in
        let assign = new assign _cfg instr (_succ) in
            ( _succ#unlink_pred this
            ; _succ <- assign
            ; _succ#link_pred this
            ; assign
            )
    
    method unlink =
        let this = (this :> node) in
        let pred = match _pred with 
            | [x] -> x 
            | _   -> ( Printf.printf "problem: %s" this#node_info_string
                     ; assert false 
                     )
        in
            ( pred#upd_succ (fun n -> if n = this then _succ else n)
            ; _succ#unlink_pred this
            ; _succ#link_pred pred
            )
        
    method linorder   = (Some _succ,[])
    method interp fd =
        Rtltolua.rtl fd _instr
end
@

% ------------------------------------------------------------------ 
\subsection{Return Node}
% ------------------------------------------------------------------ 

<<OO>>=
and  return cfg instr (x,y) :  node  =
object (this)  
    inherit  vnode cfg instr as super

    val         _x    = (x:int)
    val         _y    = (y:int)
    val mutable _exit = cfg#exit

    initializer 
        _exit # link_pred (this :> node)
    
    method succ = [_exit]
    
    method upd_succ map =
        let map = upd (this :> node) map in
        _exit <- map _exit

    method node_info_string  = super#node_info_string ^ " return"    
    method linorder = (None, [_exit])
    method interp fd =
        fprintf fd "CMM.cmm_return(%d,%d)\n" _x _y
end
@

% ------------------------------------------------------------------ 
\subsection{Goto Node}
% ------------------------------------------------------------------ 


<<OO>>=
and  goto cfg instr targets :  node =
object (this)
    inherit  vnode cfg instr as super

    val mutable _targets = targets

    initializer
        List.iter (fun n -> n#link_pred (this :> node)) _targets;
        assert (_targets <> [])

    method succ = uniq _targets      
    
    method upd_succ map =
        let map = upd (this :> node) map in
        _targets <- List.map map _targets 

    method linorder = (None, _targets)
    method interp fd =
        let e = Interp.target.Target2.goto.Target2.project _instr in
        ( Rtltolua.rtl fd _instr
        ; fprintf fd "CMM.goto()\n"
        )
        
end
@

% ------------------------------------------------------------------ 
\subsection{Jump Node}
% ------------------------------------------------------------------ 

<<OO>>=
class  jump cfg instr (targets:string list) :  node =
object (this)
    inherit  vnode cfg instr as super

    val mutable _targets = targets      
    val mutable _exit    = cfg#exit     (* artifical edge to exit *)
    
    initializer
        _exit#link_pred (this :> node)

    method succ     = [_exit]   
    method linorder = (None, [_exit])
    
    method upd_succ map =
        let map = upd (this :> node) map in
            _exit    <- map _exit
            
    method interp fd =
        let e = Interp.target.Target2.jump.Target2.project _instr in
        ( Rtltolua.exp fd e
        ; fprintf fd "CMM.cmm_tail_call()\n"
        )
end
@

% ------------------------------------------------------------------ 
\subsection{Call Node}
% ------------------------------------------------------------------ 

<<OO>>=
class  call cfg instr conts ~spans ~succ : node =
object (this)
    inherit  vcut cfg instr conts as super

    val mutable _succ = (succ: node)

    initializer 
        succ # link_pred (this :> node)

    method succ =
        uniq (List.concat [ [_succ]; _cuts; _unwinds; _returns])

    method upd_succ map = 
        let map = upd (this :> node) map in
        ( _cuts     <- List.map map _cuts
        ; _unwinds  <- List.map map _unwinds
        ; _returns  <- List.map map _returns
        ; _succ     <- map _succ
        ) 
    
    method linorder = 
        ( Some _succ
        , uniq(List.concat[_cuts;_unwinds;_returns])
        )
        
    method interp fd =
        let e       = Interp.target.Target2.call.Target2.project _instr in
        let open_span = function
            | token, (Some s, offset) -> 
                fprintf fd "CMM.begin_span(%d,'%s') -- offset: %d\n"
                    (Bits.S.to_int token)
                    (s#text)
                    (Bits.S.to_int offset)
            | token, (None  , offset) ->
                Impossible.impossible 
                    "cannot handle link-time constant in call#interp"
        in
        let close_span (token,_) =
                fprintf fd "CMM.end_span(%d)\n" (Bits.S.to_int token)
        in
        
        (* We expect all continuation nodes to have a symbol. Is this
           correct? Believe this to be correct --CL *)
        let label n = match n#symbol with
            | Some s -> sprintf "'%s'" (s#text)
            | None   -> Impossible.impossible 
                            "call#interp: continuation without label" in
            
        ( List.iter open_span (List.rev spans) 
        ; Rtltolua.exp fd e    (* was: rtl fd _instr -- why?? *)
        ; fprintf fd "CMM.call({%s}, {%s}, {%s}, %s) -- %s \n"
            (String.concat "," (List.map label _cuts))    
            (String.concat "," (List.map label _unwinds)) 
            (String.concat "," (List.map label _returns)) 
            (if _aborts then "1" else "0")
            "cuts, unwinds, returns, aborts"
        ; List.iter close_span spans
        )   

    method is_call = true
end
@

% ------------------------------------------------------------------ 
\subsection{Cutto Node}
% ------------------------------------------------------------------ 

<<OO>>=

class  cutto cfg instr conts :  node =
object (this)
    inherit  vcut cfg instr conts as super

    val mutable _exit = (cfg#exit: node)       (* artifical edge to exit *)

    initializer
        _exit # link_pred (this :> node)

    method succ =
        uniq (List.concat [ [_exit]; _cuts; _unwinds; _returns])

    method upd_succ map = 
        let map = upd (this :> node) map in
        ( _cuts     <- List.map map _cuts
        ; _unwinds  <- List.map map _unwinds
        ; _returns  <- List.map map _returns
        ; _exit     <- map _exit
        ) 
    
    method linorder = 
        ( None
        , uniq(List.concat[_cuts;_unwinds;_returns;[_exit]])
        )

    (* I don't understand what is returned by project so cannot
       generate the right code. No explanation in Target2.nw. Have to
       talk to JD who probably made the change.  *)

    method interp fd =
        let e       = Impossible.unimp "cutto_project" in (*Interp.target.Target2.cutto.Target2.project _instr in*)
        ( Rtltolua.rtl fd _instr    (* Rtltolua.exp fd e somehow?? *)
        ; fprintf fd "CMM.cut()\n"
        )
        
end
@

% ------------------------------------------------------------------ 
\subsection{Branch Node}
% ------------------------------------------------------------------ 

<<OO>>=
class  branch cfg instr (ifso:node) (ifnot:node) :  node =
object (this)
    inherit  vnode cfg instr  as super

    val mutable _ifso  = ifso
    val mutable _ifnot = ifnot

    initializer
        ( _ifso  # link_pred (this :> node)
        ; _ifnot # link_pred (this :> node)
        )

    method succ =
        uniq [_ifso;_ifnot]

    method upd_succ map =
        let map = upd (this :> node) map in
        ( _ifso  <- map _ifso
        ; _ifnot <- map _ifnot
        )
    
    method linorder = 
        ( Some _ifnot
        , [_ifso]
        )
    
    method interp fd =
        let (g,e) = Interp.target.Target2.branch.Target2.project _instr in
        let s     = match Rtl.Dn.exp e with
                    | Rtl.Private.Const(Rtl.Private.Link(s,_)) -> s
                    | _ -> assert false in
        ( Rtltolua.exp fd g
        ; fprintf fd "CMM.cbrancht('%s')\n" s#text
        )

end
@

% ------------------------------------------------------------------ 
\subsection{Dataflow Node}
% ------------------------------------------------------------------ 

Dataflow nodes are synthetic nodes to inform the data-flow analysis
about data flow that otherwise would be missed.

<<OO>>=
class  dataflow cfg (succ:node) 
    (defs:locs) (uses:locs) (kills:locs) :  node =
object (this)
    inherit  vnode cfg cfg#nop as super

    val mutable _succ = succ
    val _defs         = defs
    val _uses         = uses
    val _kills       = kills

    initializer
        _succ # link_pred (this :> node)

    method succ =
        [_succ]

    method upd_succ map =
        let map = upd (this :> node) map in
        _succ <- map _succ

    method defs   = _defs
    method uses   = _uses
    method kills  = _kills
   
    method linorder = ( Some _succ , [])
    method interp fd =    
        fprintf fd "-- data flow node\n"
end
@


% ------------------------------------------------------------------ 
\subsection{High-Level Implementation}
% ------------------------------------------------------------------ 

The high-level implementation delegates most of the work to the
object-oriented implementation. This applies both to types and values: 

<<FP>>=
type cfg        = OO.cfg             (* class type cfg  *)
type node       = OO.node            (* class type node *)
type conts      = OO.conts           (* continuation bundle *)
@

Constructors for continuation bundles, graphs, and nodes:

<<FP>>=
let conts ~cuts ~unwinds ~returns ~aborts =
    { OO.cuts    = cuts
    ; OO.unwinds = unwinds
    ; OO.returns = returns
    ; OO.aborts  = aborts
    }

let mk ~target ~nop = new OO.graph target nop 
let gm_return       = new OO.return
let gm_goto         = new OO.goto
let gm_jump         = new OO.jump
let gm_cutto        = new OO.cutto
let gm_call         = new OO.call
let gm_branch cfg rtl ~ifso ~ifnot = new OO.branch cfg rtl ifso ifnot
let gm_assign cfg rtl ~succ = new OO.assign cfg rtl succ

@

Graph observations.

<<FP>>=

let lookup cfg (label:string) = cfg#lookup label
let entry cfg                 = cfg#entry
let exit cfg                  = cfg#exit

let gm_label cfg (label:string) (sym:Symbol.t) ~(succ:node) =
    cfg#label label sym succ 

let first cfg = 
    assert (cfg#enumerated);
    assert ((Array.length (cfg#enumeration)) >= 2);
    let enum = cfg#enumeration in
        enum.(0)

let last  cfg = 
    assert (cfg#enumerated);
    assert ((Array.length (cfg#enumeration)) >= 2);
    let enum = cfg#enumeration    in
    let len  = Array.length enum in
        enum.(len-1)
@

Iterators work only on enumerated graphs. They are stable under
modification in the sense that an enumeration snapshot is taken for the
iteration and thus any changes to the graph structure is \emph{not}
taken into account while the iteration is active.

<<FP>>=
let scan_fwd (cfg:cfg) ~(first:int) ~(limit:int) f zero = 
    assert (cfg#enumerated);
    assert (first >= 1);
    assert (limit <= ((Array.length (cfg#enumeration)) + 1));
    let enum = cfg#enumeration in
    let rec loop n result =     (* n is one-based *)
        if n = limit then 
            result
        else
            loop (n+1) (f enum.(n-1) result)
    in
        loop first zero


let scan_bwd (cfg:cfg) ~(first:int) ~(limit:int) f zero = 
    assert (cfg#enumerated);
    assert (first >= 1);
    assert (limit <= ((Array.length (cfg#enumeration)) + 1));
    let enum = cfg#enumeration in
    let rec loop n result =     (* n is one-based *)
        if n < first then 
            result
        else
            loop (n-1) (f enum.(n-1) result)
    in
        loop (limit-1) zero

let next (node:node) = 
    assert (node#cfg#enumerated);
    let n    = node#number     in   (* 1 ... |G|   *)
    let cfg  = node#cfg        in
    let enum = cfg#enumeration in   (* 0 ..  |G|-1 *)
        if n < (Array.length enum) then
            Some enum.(n)
        else
            None
    
let prev (node:node) = 
    assert (node#cfg#enumerated);
    let n    = node#number     in   (* 1 ... |G|   *)
    let cfg  = node#cfg        in
    let enum = cfg#enumeration in   (* 0 ..  |G|-1 *)
        if 1 < n then
            Some enum.(n-2)
        else
            None
@


Node observation functions just delegate the work to the object
representing the node.

<<FP>>=
let cfg         (node:node) = node#cfg
let instr       (node:node) = node#instr
let symbol      (node:node) = node#symbol
let succ        (node:node) = node#succ
let pred        (node:node) = node#pred
let property    (node:node) = node#property
let number      (node:node) = node#number

let node_info_string (node: node) = node#node_info_string
let is_call          (node: node) = node#is_call

let kills (node:node) = Register.Set.empty
let defs  (node:node) = 
    let _,write = Rtlutil.ReadWrite.sets (instr node) in write
let uses  (node:node) = 
    let read,_  = Rtlutil.ReadWrite.sets (instr node) in read
@

[[Upd_instr]] updates the instruction embedded into a node but does not
change the structure of an {\rtl}.

<<FP>>=
let upd_instr (node:node) (map:Rtl.rtl -> Rtl.rtl) = node#upd_instr (map node#instr)
@

Graph mutators change the structure of a {\cfg} and invalidate any
enumeration. However, they still can be used with [[scan_fwd]] and
[[scan_bwd]] because these take snapshots of an enumeration first.

<<FP>>=
let gm_redirect_all ~src ~olddst ~newdst =
    src#upd_succ (fun n -> if n = olddst then newdst else n)

let gm_insert_assign_before (instr:'i) (node:node) =
    node#insert_assign_before instr

let gm_insert_assign_after (node:node) (instr:'i) =
    node#insert_assign_after instr

let gm_insert_assign_between (instr:'i ) ~(src:node) ~(dst:node) =
    dst#insert_assign_on_edges_from instr src

let gm_insert_dataflow_between ~defs ~uses ~kills ~src ~dst =
    let cfg  = src#cfg          in
    let exit = cfg#exit         in
    (*** debugging 
    let _    =
        ( Printf.printf "src: %d %s\n" src#id src#node_info_string
        ; Printf.printf "dst: %d %s\n" dst#id dst#node_info_string
        ) in
     ***)    
    let node = new OO.dataflow cfg exit defs uses kills in
        ( src#upd_succ (fun n -> if n = dst then node else n)
        ; node#upd_succ (fun n -> dst)
        )

let gm_delete_assign (node:node) =
    let cfg = node#cfg in
        cfg#delete node

let gm_enumerate (cfg:cfg) = 
    if cfg#enumerated then      (* risky if out #enumerated lies *)
        ()
    else    
        cfg#enumerate

let ast i2ast (cfg:cfg) ~(name:string) = 
    cfg#test;   (* check integrity *)    
    ( None
    , name
    , []
    , List.map (fun s -> Ast.StmtBody s) (cfg#ast i2ast)
    )


let interp cfg fd = cfg#interp fd
@








