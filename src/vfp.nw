% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vi users, do your worst on this line!

\section{Virtual frame pointer}

This file contains some notes about a virtual frame pointer.
One day it may contain a substitution algorithm.

The problem we're trying to solve is how to deal with a stack pointer
that moves around.
\begin{itemize}
\item
In the presence of tail calls, a stack pointer may have at least three
values: the value on entry, the value on exit, and the value between
prolog and epilog.
\item
Depending on calling convention, the stack pointer may be moved by a
callee.
\item
On some targets, it may be pleasant to use push or pop instructions to
save or restore nonvolatile registers.
\end{itemize}
If the stack pointer moves, it is difficult to use it to address the
activation record.  This note suggests a solution by means of a
\emph{virtual frame pointer}.

A virtual frame pointer is an immutable run-time value used to address
locations on the stack.
For simplicity, we say that the value of the virtual frame pointer is
the value the stack pointer had at procedure entry.

To use a virtual frame pointer effectively, we require certain
conventions:
\begin{itemize}
\item
All addressing expressions referring to data on the stack are written
in the form $\mathtt{Fetch}(\vfp)+k$, where $k$~is a (possibly late) compile-time
constant.\footnote
{From here on, we omit the \texttt{Fetch}.}
In particular, an addressing expression returned by the block
abstraction is of
the form \mbox{$\vfp+k$}.
The stack pointer is never used in an addressing expression.
\item
The \vfp\ is immutable, so it never appears in an lvalue context.
\item
We normally set $\sp$ by an assignment of the form
\mbox{$\sp \gets \vfp + k$}, but we might also adjust the stack pointer by an
assignment of the form 
\mbox{$\sp \gets \sp + k$}.
\end{itemize}

At procedure entry, the calling convention dictates where the stack
pointer is relative to the overflow incoming parameters (and possibly
return address).
This is probably at the extreme young end of the stack (high or low
depending on the direction of stack growth).
In any case, the calling convention should provide not only the block
and the locations of parameters but the location of the stack pointer.
This location is, of course, where the virtual frame pointer points.

To enter the procedure, we need to allocate its activation record and
to move all the parameters, the return 
address, and the callee-saves registers into their ``private''
locations, where they reside for the duration of the procedure.
\begin{enumerate}
\item
Find the extreme young end of the stack frame and call that
location~$y$.
Invent a fresh, late compile-time constant $n$~to stand for the frame
size, and write the equation $y=\vfp-n$.
\item
Emit the instruction $\sp \gets \vfp-n$.
\item
Emit a big shuffle as a single RTL.
This shuffle does all the moves noted above.
It's the code expander's job to eliminate redundant moves and do the
remaining moves in the right order.
It's the job of 
the code that chooses stack slots for variables and callee-saves
registers to maximize the number of redundant moves.
\end{enumerate}
This prolog is very simple, but it may be hard to discover push
instructions.
On a machine that favors push instructions (such as the $x$86), 
we might want a somewhat different prolog.

The epilog works similarly, by issuing a big shuffle for the
nonvolatile registers and the return value.

After the stack is frozen, we can compute for each node~$n$ the equation
\mbox{$\vfp = \sp+k_n$}, where  $k_n$~may be different at each node.
This equation holds on any edge flowing into~$n$:
consistency is required at each join point.
We compute $k_n$ as a forward dataflow problem.
We know that $\vfp$~is immutable, and that on entry $\vfp=\sp$.
We can therefore start at the entry node and propagate information
forward.
\begin{itemize}
\item
If we encounter a node that doesn't touch \sp, nothing happens.
\item
If we know $\vfp=\sp+k$ and we
 encounter a node with \mbox{$\sp \gets \sp+k'$}, 
then after that node \mbox{$\vfp=\sp+(k-k')$}.
\item
If we know $\vfp=\sp+k$ and we
 encounter a node with \mbox{$\sp \gets \vfp+k'$}, 
then after that node $\vfp=\sp-k'$.
\item
If we encounter any other sort of node, the compiler is broken, and we
halt with an assertion failure.
\end{itemize}
We also need to check the equations for consistency at each join point
in the control-flow graph.

After we have $\vfp=\sp+k_n$ on entry to each node, we can substitute
appropriately for $\vfp$ and simplify.
One hopes this step creates no additional work in the code expander.
(In real life, we can probably combine the substitution and the
computation. The code will appear in this file.) 


Other notes:
\begin{itemize} 
\item 
It is OK to add a possibly redundant assignment to \sp\ on an edge
flowing out of a call site.
If the call does change the stack pointer, it will be reset as needed.
If the call does not change the stack pointer, the redundant
assignment can be optimized away.
\end{itemize}
<<vfp.mli>>=
val mk     : Rtl.width       -> Rtl.exp
val is_vfp : Rtl.Private.loc -> bool
type x
val mkx : unit -> x
module type ARG = sig
  module G : Cfg.S
  val jx : G.X.jx -> x
end
module type S = sig
  module G : Cfg.S
  val replace_with : sp:Rtl.loc -> Rtl.rtl G.cfg -> unit
    (* useful to partially apply *)
end
module Make (Arg : ARG) : S with module G = Arg.G
@ 
<<vfp.ml>>=
module RP = Rtl.Private
let mk w = Rtl.fetch (Rtl.reg ('V', 0, w)) w
let is_vfp = function
  | RP.Reg ('V', 0, _) -> true
  | _ -> false
@ 
<<vfp.ml>>=
let unknown = max_int
type x = { mutable vfp_minus_sp : int } (* max_int represents unknown *)
let mkx () = { vfp_minus_sp = max_int }
module type ARG = sig
  module G : Cfg.S
  val jx : G.X.jx -> x
end
module type S = sig
  module G : Cfg.S
  val replace_with : sp:Rtl.loc -> Rtl.rtl G.cfg -> unit
    (* useful to partially apply *)
end
@ 
We replace $\vfp$ by $\sp+k$ using the identity
$\vfp = \sp + (\vfp - \sp)$.
<<vfp.ml>>=
module R  = Rtl
module RU = Rtlutil
module Down = Rtl.Dn
module Up   = Rtl.Up
module Make (Arg : ARG) = struct
  module G = Arg.G
  let jx node = (Arg.jx (G.jx node))
  module D  = Dataflow.Make (G)
  let replace_with ~sp =
    let w = RU.Width.loc sp in
    let vfp = mk w in
    let spval = R.fetch sp w in
    let sp = Down.loc sp in
    let sp_plus = RU.addk w spval in
    let sp_plus k = Down.exp (sp_plus k) in
    <<supporting functions>> in
    let info node =
      let k = (jx node).vfp_minus_sp in
      sp_plus k, k in
    let merge node (vfp, k) =
      let x = jx node in
      if x.vfp_minus_sp = k then false
      else if x.vfp_minus_sp = unknown then (x.vfp_minus_sp <- k; true)
      else if G.kind node = G.Exit then false (* accept inconsistency at exit *)
      else Impossible.impossible "inconsistent stack-pointer location" in
    let init = Down.exp spval, 0 in
    let propagate node (vfp, k) =
      match G.to_instr node with
      | None -> (vfp, k)
      | Some i ->
          <<definition of [[simp]], which is verbose>> in
          let down = Down.rtl i in
          let rtl =
            if RU.Exists.Loc.rtl is_vfp down then
              let simp = if G.kind node = G.StackAdjust then simp else Simplify.rtl in
              simp (replace_vfp vfp i)
            else
              i in
          G.update_instr (fun _ -> rtl) node;
          let vfp, k =
            match G.kind node with
            | G.CutTo -> Down.exp (R.late "this can't happen (vfp)" w), unknown
            | _       -> note_sp_changes (Down.rtl rtl) vfp k in
          vfp, k in
    let fwd = D.fwd_iteration { D.split_info = info; D.merge_split_info = merge
                              ; D.init_info = init; D.propagate = propagate } in
    fun g -> ignore (fwd g)
end
<<definition of [[simp]], which is verbose>>=
let simp rtl =
  let str = Rtlutil.ToReadableString.rtl in
  let rtl' = Simplify.Unsafe.rtl rtl in
  Debug.eprintf "vfp"
    "Simplified stack adjustment from %s to %s\n" (str rtl) (str rtl');
  rtl' 
<<vfp.ml>>=
let () = Debug.register "vfp" "stack adjustments for virtual frame pointer"
@ 
<<supporting functions>>=
let replace_vfp value =
  let is_vfp = function
    | RP.Fetch (RP.Reg ('V', 0, _), _) -> true
    | _ -> false in
  RU.Subst.exp ~guard:is_vfp ~map:(fun _ -> value) in
@ 
All we ever have to cope with is $\sp \gets \sp \pm k'$.
We have
{\newcommand\post[1]{\bar{#1}}%
\begin{eqnarray}
\vfp &=& \sp + k\\
\post\sp &=& \sp + k'\\
\vfp &=& \post\sp + \post k\\
\end{eqnarray}
We solve for $\post k = k - k'$.
<<supporting functions>>=
let rec note_sp_changes rtl vfp k =
  if RU.Exists.Loc.rtl ((=) sp) rtl then
    let k' = find_k'_added_to_sp rtl in
    let post_k = k - k' in
    sp_plus post_k, post_k
  else
    vfp, k
and find_k'_added_to_sp (RP.Rtl ges) =
  let rec find found k' = function
    | [] -> k' (* could be zero if only assignment is guarded *)
    | (RP.Const (RP.Bool b), RP.Store (sp', e, w)) :: ges when sp = sp' ->
        if not b then
          find found k' ges
        else if found then
          Impossible.impossible "multiple assignments to stack pointer"
        else
          (match e with
          | RP.App (("add", [_]), [RP.Fetch(sp', _); RP.Const (RP.Bits k')])
            when sp' = sp -> find true (Bits.S.to_int k') ges
          | RP.App (("add", [_]), [RP.Const (RP.Bits k'); RP.Fetch(sp', _)])
            when sp' = sp -> find true (Bits.S.to_int k') ges
          | RP.App (("sub", [_]), [RP.Fetch(sp', _); RP.Const (RP.Bits k')])
            when sp' = sp -> find true (- (Bits.S.to_int k')) ges
          | RP.Fetch (sp', _)
            when sp' = sp -> find true 0 ges
		  |	_ -> Printf.printf "illegal sp assignment: sp := %s\n" (RU.ToReadableString.exp (Up.exp e)) ; 0)
(* RRO temp
          | _ -> Impossible.impossible ("sp assigned other than sp + k: " ^
                                        RU.ToReadableString.exp (Up.exp e)))
*)
    | (g, RP.Store (sp', e, w)) :: ges when sp = sp' ->
        Impossible.impossible ("assigned sp with nontrivial guard " ^
                               Rtlutil.ToReadableString.exp (Rtl.Up.exp g))
    | (g, RP.Kill sp') :: ges when sp = sp' -> 
        Impossible.impossible "killed sp"
    | _ :: ges -> find found k' ges in
  find false 0 ges
@ 
