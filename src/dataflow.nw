% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Support for forward dataflow problems}

To implement forward iteration of a dataflow problem:
\begin{itemize}
\item
To follow a join, continue with the join's successor, then mark the
join as followed.
If there is a join left to be followed, follow it.
\item
To continue with a node, 
\begin{itemize}
\item
If the node is a join, then take the current information and merge it
into the information stored at the node.
\begin{itemize}
\item
If the join is marked as followed, do nothing more with that node.
\item
If the join is not marked as followed, enqueue
it to be followed.
\end{itemize}
\item
If the node is not a join, propagate the dataflow over the node, and
continue with each of the node's successors.
\end{itemize}
\item
To run an iteration, start with the initial information and continue
with the entry node.
This should follow everything in the to-be-followed
queue until done.
\end{itemize}

<<dataflow.mli>>=
module Make (G : Cfg.S) : sig
  type ('i, 'a) problem =
    { split_info       : 'i G.node -> 'a
    ; merge_split_info : 'i G.node -> 'a -> bool  (* did anything change? *)
    ; init_info       : 'a
    ; propagate       : 'i G.node -> 'a -> 'a
    } 
  val fwd_iteration : ('i, 'a) problem -> 'i G.cfg -> bool
  val bwd_iteration : ('i, 'a) problem -> 'i G.cfg -> bool
  val rev_postorder_dfs  : 'i G.cfg -> ('i G.node -> 'a -> 'a) -> 'a -> 'a
  val rev_postorder_dfs' : 'i G.cfg -> ('i G.node -> 'a -> 'a) -> 'a -> 'a
end
<<dataflow.ml>>=
module Make (G : Cfg.S) = struct
  type ('i, 'a) problem =
    { split_info       : 'i G.node -> 'a
    ; merge_split_info : 'i G.node -> 'a -> bool  (* did anything change? *)
    ; init_info       : 'a
    ; propagate       : 'i G.node -> 'a -> 'a
    } 
  <<supporting functions>>

  <<iteration functions>>
end
@ 
<<iteration functions>>=
let fwd_iteration {split_info=join_info; merge_split_info= merge_join_info;
                   init_info= init_info; propagate= propagate} g =
  let changed = ref false in
  let merge_join_info n i = if merge_join_info n i then changed := true in
  <<forward solver functions>> in
  follow_all (continue (G.entry g) init_info emptyqueue emptyset) emptyset;
  !changed

<<forward solver functions>>=
let rec continue node info to_follow followed =
  if G.is_join node then
    let join = node in
    let to_follow =
      if member join followed || G.kind join = G.Exit then to_follow
      else enqueue join to_follow in
    begin
      merge_join_info join info;
      to_follow
    end
  else
    let info = propagate node info in
    List.fold_left (fun to_f s -> continue s info to_f followed)
                   to_follow (G.succs node)  in

let rec follow join to_follow followed =
  let to_follow = continue (G.succ join) (join_info join) to_follow followed in
  follow_all to_follow (add join followed)
and follow_all to_follow followed =
  dequeue to_follow
    (fun j js ->
      if member j followed then follow_all js followed else follow j js followed)
    (fun () -> ())
@ 
<<iteration functions>>=
let bwd_iteration {split_info=fork_info; merge_split_info= merge_fork_info;
                   init_info= init_info; propagate= propagate} g =
  let changed = ref false in
  let merge_fork_info n i = if merge_fork_info n i then changed := true in
  <<backward solver functions>> in
  follow_all (continue (G.exit g) init_info emptyqueue emptyset) emptyset;
  !changed

<<backward solver functions>>=
let rec continue node info to_follow followed =
  if G.is_fork node then
    let fork = node in
    let to_follow =
      if member fork followed then to_follow else enqueue fork to_follow in
    begin
      merge_fork_info fork info;
      to_follow
    end
  else
    let info = propagate node info in
    List.fold_left (fun to_f s -> continue s info to_f followed)
                   to_follow (G.preds node)  in

let rec follow fork to_follow followed =
  let to_follow = continue (G.pred fork) (fork_info fork) to_follow followed in
  follow_all to_follow (add fork followed)
and follow_all to_follow followed =
  dequeue to_follow
    (fun j js ->
      if member j followed then follow_all js followed else follow j js followed)
    (fun () -> ())

@ 
<<supporting functions>>=
let emptyqueue = [], []
let enqueue x (l, r) = (l, x :: r)
let dequeue (l, r) succ fail =
  match l with
  | x :: xs -> succ x (xs, r)
  | [] -> match List.rev r with
    | x :: xs -> succ x (xs, [])
    | [] -> fail ()
@ 
<<supporting functions>>=
module SS = Strutil.Set
let emptyset = SS.empty
let add n s = SS.add (G.label n) s
let member n s = SS.mem (G.label n) s



@ 
John Dias writes: I believe this code you will give you exactly the behavior you
desire - it's the so-called reverse postorder dfs from Omri's thesis. I
don't think the code is transparent, so feel free to ask about it. I
think the most subtle part is that the "reverse" comes from consing the
list together.
<<old stuff from John Dias>>=
method enumerate =
    let rec rev_postorder_dfs node (acc: node list) cont =
        let rec handleList node lst cont acc =
            match lst with
            | [] -> cont (node::acc)
            | n::rst -> rev_postorder_dfs n acc (handleList node rst cont) in
        if node#been_visited
        then cont acc
        else
            let () = node#visit in
            handleList node (node#succ) cont acc in
    let entry = match _entry with None -> assert false | Some n -> n  in       
   
    let nodes = rev_postorder_dfs entry [] (fun l -> l) in
    let () = List.iter (fun n -> n#unvisit) nodes in
    let _ = List.fold_left (fun num node -> node#set_number num; num + 1) 1 nodes in
    let node_array = Array.of_list nodes in
    let () = _unsafe_enumeration <- Some node_array in
         _enumeration <- Some node_array
@ 
Here's a higher-order version that visits things catamorphically in
the same order.  We have no visiting flags, so that part is
unimplemented.  For the rest, I've done some tidying of argument
lists.  I won't pretend to understand how it works, but it typechecks.
<<supporting functions>>=
let visit g cons nil =
  let been_visited   node = assert false in
  let mark_visited   node = assert false in
  let unmark_visited node = assert false in
  let rec rev_postorder_dfs node kont acc =
    let rec handle_succs lst kont acc =
      match lst with
      | []     -> kont (cons node acc)
      | n::rst -> rev_postorder_dfs n (handle_succs rst kont) acc in
    if been_visited node then
      kont acc
    else
      (mark_visited node;
       handle_succs (G.succs node) kont acc) in
  let entry = G.entry g in
  let answer = rev_postorder_dfs entry (fun x -> x) nil in
  let () = G.iter_nodes unmark_visited g in
  answer
@ 
How do we prove each node is visited exactly once?
Aside from the entry point, we reach a node only if we can reach one
of its predecessors.
We can therefore prove by induction on distance from the entry that if
a node is reachable from the entry without touching a join point, that
node is visited exactly once.
We can furthermore prove that each join point, plus the entry, is
visited exactly once.

We do a depth-first graph traversal, and at each node we build up a
continuation that 
adding each join point to the
visited 
<<supporting functions>>=
let been_visited node v = G.is_join node && member node v 
let add node v = if G.is_join node then add node v else v 

let rev_postorder_dfs g cons nil =
  let rec dfs_visit nodes visited kont =
    match nodes with
    | [] -> kont nil
    | node :: nodes ->
        if been_visited node visited then
          dfs_visit nodes visited kont 
        else
          dfs_visit (G.succs node @ nodes) (add node visited)
            (fun acc -> kont (cons node acc)) in
  dfs_visit [G.entry g] emptyset (fun x -> x)
@ 
Here's a version that's longer but avoids the unholy append.
<<supporting functions>>=
let rev_postorder_dfs' g cons nil =
  let rec dfs_visit nodes nodess visited kont =
    match nodes with
    | node :: nodes ->
        if been_visited node visited then
          dfs_visit nodes nodess visited kont 
        else
          dfs_visit (G.succs node) (nodes :: nodess) (add node visited)
            (fun acc -> kont (cons node acc))
    | [] ->
        match nodess with
        | [] -> kont nil
        | nodes :: nodess -> dfs_visit nodes nodess visited kont in
  dfs_visit [G.entry g] [] emptyset (fun x -> x)
@ 
Here's simple preorder DFS.
<<supporting functions>>=
let nr_preorder_dfs g cons nil =
  let rec dfs_visit nodes visited acc =
    match nodes with
    | [] -> acc
    | node :: nodes ->
        if been_visited node visited then
          dfs_visit nodes visited acc
        else
          dfs_visit (G.succs node @ nodes) (add node visited) (cons node acc) in
  dfs_visit [G.entry g] emptyset nil
@ 
Here's simple postorder DFS.
<<supporting functions>>=
let nr_postorder_dfs g cons nil =
  let rec dfs_visit nodes visited =
    match nodes with
    | [] -> nil
    | node :: nodes ->
        if been_visited node visited then
          dfs_visit nodes visited
        else
          cons node (dfs_visit (G.succs node @ nodes) (add node visited)) in
  dfs_visit [G.entry g] emptyset 
@ 
And now, reverse postorder DFS.
<<supporting functions>>=
let nr_rev_postorder_dfs g cons nil =
  let rec dfs_visit nodes visited =
    match nodes with
    | [] -> (fun acc -> acc)
    | node :: nodes ->
        if been_visited node visited then
          dfs_visit nodes visited
        else
          let rest = dfs_visit (G.succs node @ nodes) (add node visited) in
          (fun acc -> rest (cons node acc)) in
  dfs_visit [G.entry g] emptyset nil
@ 
@ 
Here's simple preorder BFS.
<<supporting functions>>=
let nr_preorder_bfs g cons nil =
  let rec visit nodes visited acc =
    match nodes with
    | [] -> acc
    | node :: nodes ->
        if been_visited node visited then
          visit nodes visited acc
        else
          visit (nodes @ G.succs node) (add node visited) (cons node acc) in
  visit [G.entry g] emptyset nil
@ 
Now we try a solver.
This is a backwards thing, I wot.
@
<<dataflow.ml>>=
module Test = struct
  module G = struct
    type  'i cfg  = G of ('i node * 'i node list) list
    and 'i node = string * 'i cfg ref
    let edges g = match g with G l -> l
    let label (lbl, g) = lbl
    let succs ((_, g) as n) = snd (List.find (fun (h, ts) -> (h = n)) (edges (!g)))
    let entry (g:'i cfg) = (fst (List.hd (edges g)) : 'i node)
    let is_join n = true
    let iter_nodes f g = List.iter (fun (n, _) -> f n) (edges g)
    let dotedges g =
      let outedges ((n, _), succs) =
        List.map (fun (n', _) -> ["  "; n; " -> "; n'; "\n"]) succs in
      String.concat "" (List.concat (List.concat (List.map outedges (edges g))))
    let of_edges es =
      let g = ref (G []) in
      let couple n = (n, g) in
      g := G (List.map (fun (n, es) -> (couple n, List.map couple es)) es);
      !g
      
  end
  <<supporting functions>>
  let dotgraph g (name, visitor) =
    let add_label (n, _) labels =
      ["  "; n; " [label=\""; string_of_int (List.length labels + 1); "\"]\n"]
      :: labels in
    let labels = String.concat "" (List.concat (visitor g add_label [])) in
    let header = String.concat "" ["  head[label=\""; name; "\" shape=box]\n";
                                   "  head -> "; G.label (G.entry g); "\n"] in
    List.iter print_string
      ["digraph "; name; " {\n"; labels; header; G.dotedges g; "}\n\n"]

  let edges = ["A", ["B"]; "B", ["C"; "D"]; "C", ["E"]; "D", ["E"]; "E", ["F"];
               "F", []]
  let emit_dot () =
    List.iter (dotgraph (G.of_edges edges))
      [ "rev_postorder_dfs", rev_postorder_dfs
      ; "rev_postorder_dfs_prime", rev_postorder_dfs'
      ; "nr_preorder_dfs", nr_preorder_dfs
      ; "nr_postorder_dfs", nr_postorder_dfs
      ; "nr_rev_postorder_dfs", nr_rev_postorder_dfs
      ; "nr_preorder_bfs", nr_preorder_bfs
      ] 
end
<<dataflow.mli>>=
module Test : sig
  val emit_dot : unit -> unit
end
