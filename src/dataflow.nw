% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Support for forward dataflow problems}

This documentation is written long after the event, so one may be
suspicious of errors. 

We want to solve both forward and backward problems, so we talk about
a ``split,'' which will be a join point in one direction and a merge
point in the other.
A~value of type [[('i, 'a)]] problem is a dataflow problem over nodes
with instructions represented by~[['i]] and the dataflow information
represented by~[['a]].
All problems incrementally build up information at each split node until we
reach a fixed point.
This means each split node holds suitable mutable state of type~[['a]].

Each dataflow problem has these parts:
\begin{itemize}
\item
[[init_info]]: Initial (bottom) value of dataflow information.
\item
[[propagate]]: Push the dataflow information through a non-split node.
\item
[[split_info]]: Extract the dataflow information from a split node.
\item 
[[merge_split_info]]:
Using the dataflow equations, merge a new dataflow value with the
value already stored at the split node (e.g., by taking the least
upper bound).
Return a Boolean indicating whether this operation changed the
(mutable) value at the split node.
\end{itemize}

Given a problem, [[fwd_iteration]] runs one forward iteration and
returns a Boolean indicating whether anything changed.
It can be repeated until it reaches a fixed point.
@
\section{Implementation}

<<dataflow.mli>>=
module Make (G : Cfg.S) : sig
  type ('i, 'a) problem =
    { split_info       : 'i G.node -> 'a
    ; merge_split_info : 'i G.node -> 'a -> bool  (* did anything change? *)
    ; init_info       : 'a
    ; propagate       : 'i G.node -> 'a -> 'a
    } 
  val fwd_iteration : ('i, 'a) problem -> 'i G.cfg -> bool
(*val bwd_iteration : ('i, 'a) problem -> 'i G.cfg -> bool*)
end
<<dataflow.ml>>=
module Make (G : Cfg.S) = struct
  type ('i, 'a) problem =
    { split_info       : 'i G.node -> 'a
    ; merge_split_info : 'i G.node -> 'a -> bool  (* did anything change? *)
    ; init_info       : 'a
    ; propagate       : 'i G.node -> 'a -> 'a
    } 
  <<iteration functions>>
end
@ 
Revised to use the new flow-graph traversal.
We go from each head to the next join.
<<iteration functions>>=
let fwd_iteration {split_info=join_info; merge_split_info= merge_join_info;
                   init_info= init_info; propagate= propagate} g =
  let changed = ref false in
  let merge_join_info n i = if merge_join_info n i then changed := true in
  let heads = G.postorder_dfs (fun n hs -> if G.is_head n then n :: hs else hs) [] g in
  <<forward solver functions>> in
  List.iter follow heads;
  !changed

<<forward solver functions>>=
let rec follow head =
  let info = if G.is_join head then join_info head else init_info in
  continue info (G.succ head)
and continue info node =
  if G.is_join node then
    merge_join_info node info
  else
    let info = propagate node info in
    List.iter (continue info) (G.succs node) 
@
<<dataflow.ml>>=
module Test = struct
  module G = struct
    type  'i cfg  = G of ('i node * 'i node list) list
    and 'i node = string * 'i cfg ref
    let edges g = match g with G l -> l
    let label (lbl, g) = lbl
    let succs ((_, g) as n) = snd (List.find (fun (h, ts) -> (h = n)) (edges (!g)))
    let entry (g:'i cfg) = (fst (List.hd (edges g)) : 'i node)
    let is_join n = true
    let iter_nodes f g = List.iter (fun (n, _) -> f n) (edges g)
    let dotedges g =
      let outedges ((n, _), succs) =
        List.map (fun (n', _) -> ["  "; n; " -> "; n'; "\n"]) succs in
      String.concat "" (List.concat (List.concat (List.map outedges (edges g))))
    let of_edges es =
      let g = ref (G []) in
      let couple n = (n, g) in
      g := G (List.map (fun (n, es) -> (couple n, List.map couple es)) es);
      !g
      
  end
  let dotgraph g (name, visitor) =
    let add_label (n, _) labels =
      ["  "; n; " [label=\""; string_of_int (List.length labels + 1); "\"]\n"]
      :: labels in
    let labels = String.concat "" (List.concat (visitor g add_label [])) in
    let header = String.concat ""
        ["  head[label=\""; name; "\" shape=box]\n";
         "  head -> "; G.label (G.entry g); " [style=invis]\n"] in
    List.iter print_string
      ["digraph "; name; " {\n"; labels; header; G.dotedges g; "}\n\n"]

  let edges = ["A", ["B"]; "B", ["C"; "D"]; "C", ["E"]; "D", ["DX"];
               "DX", ["E"]; "E", ["F"]; "F", []]
  let emit_dot () =
    List.iter (dotgraph (G.of_edges edges))
      [ "unnumbered", (fun _ _ l -> l)
(*
      ; "rev_postorder_dfs", rev_postorder_dfs
      ; "rev_postorder_dfs_prime", rev_postorder_dfs'
      ; "fwd_postorder_dfs", fwd_postorder_dfs
      ; "bwd_postorder_dfs", bwd_postorder_dfs 
      ; "fwd_postorder_dfs_cps", fwd_postorder_dfs_cps
      ; "bwd_postorder_dfs_cps", bwd_postorder_dfs_cps 
      ; "son_of_diasson_of_dias_postorder_dfs", son_of_dias_postorder_dfs
      ; "nr_preorder_dfs", nr_preorder_dfs
      ; "nr_preorder_bfs", nr_preorder_bfs
*)
      ] 
end
<<dataflow.mli>>=
module Test : sig
  val emit_dot : unit -> unit
end
