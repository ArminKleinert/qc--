% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Support for forward dataflow problems}

To implement forward iteration of a dataflow problem:
\begin{itemize}
\item
To follow a join, continue with the join's successor, then mark the
join as followed.
If there is a join left to be followed, follow it.
\item
To continue with a node, 
\begin{itemize}
\item
If the node is a join, then take the current information and merge it
into the information stored at the node.
\begin{itemize}
\item
If the join is marked as followed, do nothing more with that node.
\item
If the join is not marked as followed, enqueue
it to be followed.
\end{itemize}
\item
If the node is not a join, propagate the dataflow over the node, and
continue with each of the node's successors.
\end{itemize}
\item
To run an iteration, start with the initial information and continue
with the entry node.
This should follow everything in the to-be-followed
queue until done.
\end{itemize}

<<dataflow.mli>>=
module Make (G : Cfg.S) : sig
  module G : Cfg.S
  type ('i, 'a) problem =
    { split_info       : 'i G.node -> 'a
    ; merge_split_info : 'i G.node -> 'a -> bool  (* did anything change? *)
    ; init_info       : 'a
    ; propagate       : 'i G.node -> 'a -> 'a
    } 
  val fwd_iteration : ('i, 'a) problem -> 'i G.cfg -> bool
  val bwd_iteration : ('i, 'a) problem -> 'i G.cfg -> bool
end with module G = G
<<dataflow.ml>>=
module Make (G : Cfg.S) = struct

  module G = G
  type ('i, 'a) problem =
    { split_info       : 'i G.node -> 'a
    ; merge_split_info : 'i G.node -> 'a -> bool  (* did anything change? *)
    ; init_info       : 'a
    ; propagate       : 'i G.node -> 'a -> 'a
    } 
  <<supporting functions>>

  <<iteration functions>>
end
@ 
<<iteration functions>>=
let fwd_iteration {split_info=join_info; merge_split_info= merge_join_info;
                   init_info= init_info; propagate= propagate} g =
  let changed = ref false in
  let merge_join_info n i = if merge_join_info n i then changed := true in
  <<forward solver functions>> in
  follow_all (continue (G.entry g) init_info emptyqueue emptyset) emptyset;
  !changed

<<forward solver functions>>=
let rec continue node info to_follow followed =
  if G.is_join node then
    let join = node in
    let to_follow =
      if member join followed || G.kind join == G.Exit then to_follow
      else enqueue join to_follow in
    begin
      merge_join_info join info;
      to_follow
    end
  else
    let info = propagate node info in
    List.fold_left (fun to_f s -> continue s info to_f followed)
                   to_follow (G.succs node)  in

let rec follow join to_follow followed =
  let to_follow = continue (G.succ join) (join_info join) to_follow followed in
  follow_all to_follow (add join followed)
and follow_all to_follow followed =
  dequeue to_follow
    (fun j js ->
      if member j followed then follow_all js followed else follow j js followed)
    (fun () -> ())
@ 
<<iteration functions>>=
let bwd_iteration {split_info=fork_info; merge_split_info= merge_fork_info;
                   init_info= init_info; propagate= propagate} g =
  let changed = ref false in
  let merge_fork_info n i = if merge_fork_info n i then changed := true in
  <<backward solver functions>> in
  follow_all (continue (G.exit g) init_info emptyqueue emptyset) emptyset;
  !changed

<<backward solver functions>>=
let rec continue node info to_follow followed =
  if G.is_fork node then
    let fork = node in
    let to_follow =
      if member fork followed then to_follow else enqueue fork to_follow in
    begin
      merge_fork_info fork info;
      to_follow
    end
  else
    let info = propagate node info in
    List.fold_left (fun to_f s -> continue s info to_f followed)
                   to_follow (G.preds node)  in

let rec follow fork to_follow followed =
  let to_follow = continue (G.pred fork) (fork_info fork) to_follow followed in
  follow_all to_follow (add fork followed)
and follow_all to_follow followed =
  dequeue to_follow
    (fun j js ->
      if member j followed then follow_all js followed else follow j js followed)
    (fun () -> ())

@ 
<<supporting functions>>=
let emptyqueue = [], []
let enqueue x (l, r) = (l, x :: r)
let dequeue (l, r) succ fail =
  match l with
  | x :: xs -> succ x (xs, r)
  | [] -> match List.rev r with
    | x :: xs -> succ x (xs, [])
    | [] -> fail ()
@ 
<<supporting functions>>=
module SS = Strutil.Set
let emptyset = SS.empty
let add n s = SS.add (G.label n) s
let member n s = SS.mem (G.label n) s



