% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=2 sw=2 et: 
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% 
% $Id$

% ------------------------------------------------------------------ 
\section{Applicative Control-Flow Graph, Based on Huet's Zipper}
% ------------------------------------------------------------------ 


\citet{huet:zipper} describes a generalization of a tree that enables
a program to focus on a single node while enabling the context (e.g.,
parents) to be represented by an explicit, reified value (as opposed
to being captured in an implicit continuation).
We investigate this idea for a control-flow graph.

Every graph has a single entry and zero or more exits.
(For example, the graph for a procedure has no exits, the graph
for an expanded instruction has one exit, and the graph for an
expanded conditional branch has two exits.)
Exits are numbered from~$0$.
A~[[graph]] is a set of basic blocks, one of which is distinguished as the
entry block.
Every other block is tagged by a
unique id, which may correspond to a string label.\footnote
{Maintaining a mapping between strings and unique ids is not the
  responsibility of this module.}
A~[[zgraph]] is a graph with the \emph{focus} on one particular node.
This will support at least the following kinds of operations:
\begin{itemize}
\item
When the focus is on the entry node, add a new node to the graph just
before the entry node.
This operation is the primary means of building graphs.
\item
Replace the node at the focus, plugging in a new graph in its place.
\end{itemize}
Here are some basic types and operations:
<<zipcfg.mli>>=
type uid
type label = uid * string

type graph
type zgraph

val empty   : graph
val entry   : graph -> zgraph           (* focus on entry node *)
val exit    : int -> graph -> zgraph    (* focus on exit node *)
val focus   : uid -> graph -> zgraph    (* focus on node with uid *)
val unfocus : zgraph -> graph           (* lose focus *)
@ 
Subgraph replacement:
we replace the node at the focus with a graph.
The number of exits in the replacement graph must be equal to the
number of successors of the focus node; otherwise it is a checked run-time
error. 
After replacement, the focus looks at the successor of the replacement
graph's entry node.
<<zipcfg.mli>>=
val replace_focus : zgraph -> graph -> zgraph
@ 
We can insert a single-entry, single-exit subgraph either before or
after the current focus.
If before, the focus must be on a [[middle]] or [[last]] node.
If after, the focus must be on a [[first]] or [[middle]] node.
The focus does not move.
<<zipcfg.mli>>=
val splice_before : zgraph -> graph -> zgraph
val splice_after  : zgraph -> graph -> zgraph
@ 
Stitch two graphs together:
<<zipcfg.mli>>=
val followed_by : graph -> int -> graph -> graph
  (* followed_by g n g' = connect Exit n of g to entry of g' *)
@ 
Building a graph.
The entry plays a dual role here; every constructor effectively
requires the focus be on the entry node and inserts a new node
following the entry node.
After insertion, the entry node remains the focus.

%%  When we add a node that can flow through to its successor, we insert
%%  the node before the focus.
%%  But when we add a node that cannot flow to its successor, we add it to
%%  an unfocused graph.
%%  In either case,  the new node becomes the new focus.
<<zipcfg.mli>>=
type regs  = Register.Set.t  (* sets of regs for dataflow *)
type xregs = Register.SetX.t (* sets of regs for dataflow *)
type contedge = { kills:regs; defs:regs; node:label }


val uid : unit -> uid
type machine = { goto    : label -> Rtl.rtl;
                 cbranch : Rtl.exp * label -> Rtl.rtl;
                 bnegate : Rtl.rtl -> Rtl.rtl;
                 call    : Rtl.exp -> Rtl.rtl;
                 forbidden : Rtl.rtl;
               }

val label        : machine -> label -> zgraph -> zgraph  (* spans? *)
val instruction  : Rtl.rtl -> zgraph -> zgraph
val stack_adjust : Rtl.rtl -> zgraph -> zgraph
val assertion    : Rtl.rtl -> zgraph -> zgraph
val branch       : machine -> target:label -> zgraph -> zgraph
val jump         : Rtl.rtl -> uses:regs -> targets:string list -> zgraph -> zgraph
val cbranch      : machine -> Rtl.exp -> ifso:label -> ifnot:label -> zgraph -> zgraph
val mbranch      : Rtl.rtl -> targets:label list -> zgraph -> zgraph
val call         : machine -> Rtl.exp -> altrets:contedge list -> 
                     unwinds_to:contedge list -> cuts_to:contedge list ->
                     aborts:bool -> uses:regs -> defs:regs -> kills:regs ->
                     reads:string list option -> writes:string list option ->
                     spans:Spans.t option -> zgraph -> zgraph
val cut_to       : Rtl.rtl -> cuts_to:contedge list -> aborts:bool ->
                     uses:regs -> zgraph -> zgraph
val return       : Rtl.rtl -> exit:int -> uses:regs -> zgraph -> zgraph
val forbidden    : machine -> zgraph -> zgraph
  (* control should not reach; causes checked RTE *)
@ 
Sometimes we need to make the current focus (which must be the entry)
a branch target to be used later.
Calling [[make_target gz]] returns a new graph and a unique identifier
to which the entry flows in.
<<zipcfg.mli>>=
val make_target : machine -> zgraph -> label * zgraph
@ 
Mutation---ugh!
<<zipcfg.mli>>=
val set_spans : zgraph -> Spans.t -> unit  (* set spans at focus *)
@ 
\subsection{Implementation}
<<zipcfg.ml>>=
module R = Rtl
module T = Target

let impossf fmt = Printf.kprintf Impossible.impossible fmt
let unimpf  fmt = Printf.kprintf Impossible.unimp      fmt
let ( **> ) f x = f x

type uid = int
type label = uid * string
type machine = { goto    : label -> Rtl.rtl;
                 cbranch : Rtl.exp * label -> Rtl.rtl;
                 bnegate : Rtl.rtl -> Rtl.rtl;
                 call    : Rtl.exp -> Rtl.rtl;
                 forbidden : Rtl.rtl;
               }

let uid =
  let n = Reinit.ref 1 in
  fun () -> let u = !n in (n := u + 1; u)
let entry_uid = 0

let address uid = R.codesym (Printf.kprintf Symbol.unmangled ".Lz%d" uid) 99
   (* disastrous lies --- maybe need to Idgen a label for each uid, then query the graph? but then what about cycles? *) 

type regs  = Register.Set.t  (* sets of regs for dataflow *)
type xregs = Register.SetX.t (* sets of regs for dataflow *)
type contedge = { kills:regs; defs:regs; node:label }
@ 
\paragraph{Nodes and basic blocks}
<<zipcfg.ml>>=
type user = User of bool  (* is label a user label? *)
type first
  = Entry
  | Label of label * user * Spans.t option ref  (* user labels can't be deleted *)

type middle
  = Instruction  of Rtl.rtl
  | Stack_adjust of Rtl.rtl
  | Assertion    of Rtl.rtl
@ 
Unclear whether a jump should get an exit number or what it should
mean (think about inlining).

In a complete graph for a procedure, the [[Exit]] node should not
appear, but it is useful in a subgraph (e.g., replacement for a node).
<<zipcfg.ml>>=
type 'a edgelist = 'a list (* could be array *)
<<node types>>
type exit_num = int

type last
  = Exit    of exit_num  
  | Branch  of Rtl.rtl * label
  | Cbranch of Rtl.rtl * label * label    (* true, false *)
  | Mbranch of Rtl.rtl * label edgelist (* possible successors *)
  | Call    of call  
  | Cut     of Rtl.rtl * contedge edgelist * regs  (* out edges, registers used *)
  | Return  of exit_num * Rtl.rtl * regs
  | Jump    of exit_num * Rtl.rtl * regs * string list
                   (* exit num, inst, registers used, targets *)
  | Forbidden of Rtl.rtl (* cause a run-time error *)
@ 
Now the zipper:
A [[head]] is a [[first]] followed by zero or more [[middle]]s.
A [[tail]] is  zero or more [[middle]]s followed by a [[last]].
<<zipcfg.ml>>=
type head = First of first | Head of head * middle
type tail = Last  of last  | Tail of middle * tail

type zblock
  = Start  of first * tail           (* focus on first *)
  | Middle of head * middle * tail   (* focus on middle *)
  | End    of head * last            (* focus on last *)
@ An alternative would be to make [[type zblock = head * tail]], with
focus on the first element of the tail.  Not sure if that is flexible
enough, however.

Another alternative is to inline the definitions of [[first]] and
[[last]] into [[head]] and [[tail]], doing away with a level of
indirection.
But this would probably make it harder for clients to reason about
nodes in isolation.
@
Without zipper:
<<zipcfg.ml>>=
type block = first * tail
<<node types>>=
type call = {         cal_i          : Rtl.rtl
            ;         cal_contedges  : contedge edgelist
            ;         cal_spans      : Spans.t option
            ; mutable cal_uses       : regs
            ;         cal_altrets    : int
            ;         cal_unwinds_to : int
            ;         cal_cuts_to    : int
            ;         cal_reads      : string list option
            ;         cal_writes     : string list option
            }
@ 
@
\paragraph{Block manipulations}
Convert block between forms.
<<zipcfg.ml>>=
let goto_start =
  let rec revapp head tail = match head with
  | First f -> f, tail
  | Head (h, m) -> revapp h (Tail (m, tail)) in
  function
  | Start  (f, t)    -> f, t
  | Middle (h, m, t) -> revapp h (Tail (m, t))
  | End    (h, l)    -> revapp h (Last l)

let goto_end =
  let rec revapp head tail = match tail with
  | Last l -> head, l
  | Tail (m, t) -> revapp (Head (head, m)) t in
  function
  | Start  (f, t)    -> revapp (First f) t
  | Middle (h, m, t) -> revapp (Head (h, m)) t
  | End    (h, l)    -> h, l

let zip = goto_start
let unzip (n, ns) = Start (n, ns)

let goto_start : zblock -> first * tail = goto_start
let goto_end   : zblock -> head  *last  = goto_end
let zip   : zblock -> block  = zip
let unzip : block  -> zblock = unzip
@ 
\paragraph{Graph}
For the graph, we want to be able to look up a block efficiently by
its unique id.  
For the time being, we use a list:
<<zipcfg.ml>>=
module type BLOCKS = sig
  type t
  val empty  : t
  val insert : block -> t -> t
  val find   : t -> uid -> block 
  val focus  : t -> uid -> block * t
  val union  : t -> t -> t

  val fold   : (block -> 'a -> 'a) -> t -> 'a -> 'a
  val focusopt : (block -> 'a option) -> t -> 'a * t
end

module Blocks : BLOCKS = struct
  type t = block list
  let id = function (Entry,_) -> entry_uid | (Label ((u, _), _, _),_) -> u
  let empty = []
  let insert b bs = b :: bs
  let find blocks u = List.find (fun b -> id b = u) blocks
  let focusopt p blocks =
    let rec f prev' next = match next with
    | [] -> raise Not_found
    | b :: bs ->
        match p b with
        | Some x -> x, List.rev_append prev' bs
        | None -> f (b::prev') bs in
    f [] blocks
  let focus blocks u = 
    let rec f prev' next = match next with
    | [] -> raise Not_found
    | b :: bs ->
        if id b = u then b, List.rev_append prev' bs
        else f (b::prev') bs in
    f [] blocks
  let union = (@)
  let fold = List.fold_right
end
@ 
<<zipcfg.ml>>=  
type graph  = Blocks.t
type zgraph = zblock * Blocks.t
@ 
<<zipcfg.ml>>=
let empty = Blocks.insert (Entry, Last (Exit 0)) Blocks.empty

let focus uid blocks =
  let (b, bs) = Blocks.focus blocks uid in
  unzip b, bs
let entry blocks = focus entry_uid blocks
let exit n =
  let is_exit b = match goto_end (unzip b) with
  | head, (Exit n' as l) when n' = n -> Some (End (head, l))
  | _ -> None in
  Blocks.focusopt is_exit 
  

let unfocus (bz, bs) = Blocks.insert (zip bz) bs
<<zipcfg.ml>>=
let consm middle g = match g with
| (Start (Entry, tail), blocks) -> (Start (Entry, Tail (middle, tail)), blocks)
| _ -> impossf "focus not on entry node"

let instruction  rtl g = consm (Instruction  rtl) g
let assertion    rtl g = consm (Assertion    rtl) g
let stack_adjust rtl g = consm (Stack_adjust rtl) g

let unreachable = function
  | Last (Branch _ | Forbidden _) -> ()
  | _ -> Printf.eprintf "warning: unreachable code?\n"

let consl last g = match g with
| (Start (Entry, tail), blocks) ->
    unreachable tail;
    (Start (Entry, Last last), blocks)
| _ -> impossf "focus not on entry node"

let branch machine =
  let goto = machine.goto in fun ~target -> consl (Branch (goto target, target))
let jump rtl ~uses ~targets  = consl (Jump (0, rtl, uses, targets))
let cbranch machine =
  let f = machine.cbranch in
  fun exp ~ifso ~ifnot ->
    let rtl = f (exp, ifso) in
    consl (Cbranch (rtl, ifso, ifnot))
let mbranch rtl ~targets     = consl (Mbranch (rtl, targets))
let return  rtl ~exit ~uses  = consl (Return (exit, rtl, uses))
let cut_to  rtl ~cuts_to ~aborts ~uses = consl (Cut (rtl, cuts_to, uses))
let forbidden machine = consl (Forbidden machine.forbidden)
@ 
<<zipcfg.ml>>=
let label' user tgt =
  let goto = tgt.goto in
  fun lbl g -> match g with
  | (Start (Entry, tail), blocks) -> 
      Start (Entry, Last (Branch (goto lbl, lbl))),
      Blocks.insert (Label (lbl, user, ref None), tail) blocks
  | _ -> impossf "focus not on entry node"
let label        = label' (User true)
let privatelabel = label' (User false)
@ 
<<zipcfg.ml>>=
let entry_to_tail block =
  match goto_start block with
  | Entry, t -> t
  | _ -> impossf "unexpected non-entry"

let exit_to_head block =
  match goto_end block with
  | h, Exit _ -> h
  | _ -> impossf "unexpected non-exit"
<<zipcfg.ml>>=
let check_single_exit g =
  let check block found = match goto_end (unzip block) with
  | _, Exit 0 when not found -> true
  | _, Exit _ -> impossf "multiple exits found where single exit expected"
  | _ -> found in
  if not (Blocks.fold check g false) then
    impossf "graph does not have an exit"
@ 
<<zipcfg.ml>>=
let splice_before (focus, blocks) g =
  (* first extend the head with the entry of g, then 
     if we have not reached the exit of g,
     make the exit of g the new head *)
  check_single_exit g;
  let splice head after_head =
    let gentry, gblocks = entry g in
    match gentry with
    | Start (Entry, gnodes) ->
        let rec extend head gnodes = match gnodes with
        | Tail (mid, gnodes) -> extend (Head (head, mid)) gnodes
        | Last (Exit n) ->
            assert (n = 0);
            after_head head, Blocks.union blocks gblocks
        | Last last ->
            let blocks = Blocks.insert (zip (End (head, last))) blocks in
            let gexit, gblocks = exit 0 gblocks in
            after_head (exit_to_head gexit), Blocks.union blocks gblocks in
        extend head gnodes
    | _ -> impossf "ill-formed entry node" in
  match focus with
  | Start _ -> impossf "splicing before a first node"
  | Middle (head, mid, tail) -> splice head (fun head -> Middle (head, mid, tail))
  | End (head, last) -> splice head (fun head -> End (head, last))
<<zipcfg.ml>>=
let splice_after (focus, blocks) g =
  check_single_exit g;
  (* first extend the tail with the exit of g, then 
     if we have not reached the entry of g,
     make the entry of g the new tail *)
  let splice tail before_tail =
    let gexit, gblocks = exit 0 g in
    match goto_end gexit with
    | gnodes, Exit 0 ->
        let rec extend tail gnodes = match gnodes with
        | Head (gnodes, mid) -> extend (Tail (mid, tail)) gnodes
        | First Entry -> before_tail tail, Blocks.union blocks gblocks
        | First first ->
            let blocks = Blocks.insert (zip (Start (first, tail))) blocks in
            let gentry, gblocks = entry gblocks in
            before_tail (entry_to_tail gentry), Blocks.union blocks gblocks in
        extend tail gnodes
    | _ -> impossf "ill-formed exit node" in
  match focus with
  | Start (first, tail) -> splice tail (fun tail -> Start (first, tail))
  | Middle (head, mid, tail) -> splice tail (fun tail -> Middle (head, mid, tail))
  | End (tail, last) -> impossf "splicing after a last node"
<<zipcfg.ml>>=
let make_target machine ((b, bs) as gz) = match b with
| Start (Label (u, _, _), tail) -> u, gz
| Start (Entry, Last (Branch (_, u))) -> u, gz
| Start (Entry, _) ->
    let lbl = (uid (), Idgen.label "branch target") in
    let gz = branch machine ~target:lbl **> privatelabel machine lbl **> gz in
    lbl, gz
| _ -> impossf "focus not on entry"
@ 
<<zipcfg.ml>>=
let call machine exp ~altrets ~unwinds_to ~cuts_to ~aborts
               ~uses ~defs ~kills ~reads ~writes ~spans succ =
  let new_cedge lbl = { kills = kills; defs = defs; node = lbl } in
  let lbl = (uid (), Idgen.label "call successor") in
  let edgelist = new_cedge lbl :: List.flatten [altrets; unwinds_to; cuts_to] in
  let call = 
    { cal_i = machine.call exp; cal_contedges = edgelist; cal_spans = spans;
      cal_uses = uses; cal_altrets = List.length altrets;
      cal_unwinds_to = List.length unwinds_to; cal_cuts_to = List.length cuts_to;
      cal_reads = reads; cal_writes = writes; } in
  let succ = privatelabel machine lbl succ in
  match succ with
  | (Start (Entry, Last (Branch (_, lbl'))), blocks) when lbl' =*= lbl -> 
      Start (Entry, Last (Call call)), blocks
  | _ -> impossf "internal error in call constructor"
@ 
<<zipcfg.ml>>=
let set_spans (bz, blocks) spans = match bz with
| Start (Label (l, u, r), _) -> r := Some spans
| _ -> impossf "setting spans on non-label"
@ 
<<zipcfg.ml>>=
let followed_by g n g' = unimpf "graph stitching"
let replace_focus gz g = unimpf "node replacement"
@ 
