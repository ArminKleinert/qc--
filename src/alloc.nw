% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Resource Allocation}
% ------------------------------------------------------------------ 

{\PAL} registers, formal parameters, initialized and uninitialized
data are represented as memory locations or hardware registers.  The
mapping between the {\PAL} objects and their hardware oriented
representations is controlled by this module.  

The difference between a register-like location, like a parameter or a
{\PAL} register, and initialized data is the set of operations that
are avialable for each of them.  A register is a fixed location of a
defined width where data of that width can be stored in, or fetched
from.  Data are much less structured:  labels represent addresses in a
memory block but address arithmetic can be used to obtain new
addresses from a label.  The new address then can be used aribitrarily
to store and fetch data of any width.  Thus, memory can be used to
hold register-like locations, but the converse is not true.

For passing parameter between procedures and continuations, a target
specific calling conventions describes which argument is passed into a
register, and which in memory.  Mark W.~Bailey and Jack W.~Davidson
have shown in \cite{bailey:davidson:95} that the process of choosing
registers and memory to pass values can be modeled with finite state
automata.  The automaton receives a stream of enriched {\PAL} types
and the automaton responds for each data type with a register-like
location that the parameter is passed in.

Memory used for parameter passing can be shared by all calls inside a
procedure because it is never used by two calls at the same time.  The
memory requirement of the most complicated call thus determines the
amount and alignment of memory that must be reserved for parameter
passing.  When each call results in an \emph{area} that describes its
memory requirement, an \emph{overlay} operation over two areas allows
to compute a new area that can hold both.

<<shared types>>=
type align = int (* in memsize *)
type width = int (* in bits    *)
type size  = int (* in memsize *)

type area = 
    { address : Rtl.exp (* address of memory block *) (*XXX Rtl.loc? *)
    ; align   : align   (* at run time, must have address mod align = 0 *)
    ; size    : int
    }

<<alloc.mli>>=
<<shared types>>    
module Mem : sig <<sig Mem>> end (* memory locations *)
module Reg : sig <<sig Reg>> end (* rgeister-like locations *)
<<overlapping areas>>
@

% ------------------------------------------------------------------ 
\section{Allocation of register-like Locations}
% ------------------------------------------------------------------ 

Register-like locations are maintained by automatons.  An automaton
encapsulates the ability to assign locations.  Every automaton has a
private collection of locations (e.g., registers) that it may use at
will, plus an ``overflow area.'' The overflow area is located in
memory, and it must be contiguous.

Automata are imperative; the type [[t]] encapsulates mutable state. 
This state is primarily the private internal state of the automaton,
but there is one part of state that is public.  When an automaton is
``frozen,'' it is no longer possible to get new locations from it, but
in exchange, one can get the size and alignment requirement (and also
the address) of its overflow area.

Although an \emph{automaton} is imperative, the \emph{specification}
of the automaton is not.  To create an automaton, one needs a
specification, plus the address to be used to point to the overflow
area.  \emph{Addresses always point to the lowest addressed byte, as
in the value returned from [[malloc]].} This address may contain
unbound compile-time constants (see \module{const}).

A mutable automaton [[t]] is made from a specification [[spec]].  When
run, the automaton returns abstract locations [[loc]].  The type
abbreviations for alignment, width, and size are only for
documentation purposes.

<<sig Reg>>=
type spec  (* specification of an automaton (immutable) *)
type t     (* an automaton (mutable) *)
type loc   (* a location provided by an automaton *)

val dummy: spec    (* spec to create a dummy automaton *)
@

Supply an address of the overflow area, and get back an automaton in
its initial state.

<<sig Reg>>=
val mk : spec -> Rtl.exp -> t           (*XXX*) (* Rtl.exp ??? *)
@

To allocate a new resource slot, call [[ty]] or [[block]]. Both return
a location [[[loc]] and change the automaton's internal state.

<<sig Reg>>=
val ty    : t -> width -> string option -> loc    
val block : t -> width -> align         -> loc    
@

Location's as returned by an automaton can't be used directly because
they are abstract. To use them to store and fetch data, use the
following two functions:

<<sig Reg>>=
val fetch : loc -> width -> Rtl.exp
val store : loc -> Rtl.exp -> width -> Rtl.rtl
@

When all allocations are done [[freeze]] the automaton. In response
it returns the space allocated in the overflow [[area]]. 

<<sig Reg>>=
val freeze : t -> area
@

% ------------------------------------------------------------------ 
\subsection{Allocating Memory}
% ------------------------------------------------------------------ 

A \emph{continuous} memory block is represented by a (mutable)
abstract type [[t]].  A value of such a type represents the memory
block's size, base-address, and the base address' alignment. 

An empty block is created by applying [[mk]] a $\mathit{base}$
address.  The alignment of the new block is 1\footnote{the unit for
alignment is the target specific \emph{memsize}, usually one byte}. 
At any given time the [[location]] function returns $\mathit{base} +
\mathit{size}$.  A call to [[allocate]] increases the size of the
memory block [[t]] by the supplied number of \emph{memsize} objects. 
A call to [[allign n t]] also increases the size of the block such
that after the call $\mathit{base}+\mathit{size}$ is $t$-aligned.
 
After allocation is complete a block can be frozen to obtain its
definitve size and alignment.  It is a checked run-time error to
allocate or align a frozen memory block, or to ask for its current
[[location]].

<<sig Mem>>=
type t       (* momory block *)   
val mk       : Rtl.exp -> t             (*XXX*) (* Rtl.exp ???*)
val align    : int -> t -> t            (* inceases  size *)
val alloc    : int -> t -> t            (* increases size *)
val location : t -> Rtl.loc
val freeze   : t -> area
@

% ------------------------------------------------------------------ 
\subsection{Overlapping Memory Areas}
% ------------------------------------------------------------------ 

It's possible that several overflow areas, with disjoint lifetimes,
can be overlapped in a single location in memory.  The result is a new
[[area]] with more constraints in general.  The [[placement]] value
determines whether the overlapping areas share a common low or high
end. 

<<shared types>>=
type placement = EqualHighEnds | EqualLowEnds

<<overlapping areas>>=
val overlap : placement -> area list -> area
  (* Overlap several areas into a larger area, forcing constraints on
     compile-time constants.  May make calls to Const.make_equal, but
     otherwise has no side effects.  It is a checked run-time error to
     overlap areas at the high end unless the size of every area is a
     multiple of its alignment.  N.B. may raise Const.Cannot_solve. *)
@


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<alloc.ml>>=
<<shared types>>

module Reg = struct <<struct Reg>> end
module Mem = struct <<struct Mem>> end

<<overlapping areas implementation>>
@


% ------------------------------------------------------------------
\subsubsection{Continuous Memory Locations}
% ------------------------------------------------------------------ 
                                                                      
<<struct Mem>>=
type t = unit
let mk base = ()
let align    i () = ()
let alloc    n () = ()
let location ()   = Impossible.unimp "Alloc.Mem.location"
let freeze   ()   = Impossible.unimp "Alloc.Mem.freeze"
@                                                                      

% ------------------------------------------------------------------ 
\subsubsection{Register Locations}
% ------------------------------------------------------------------ 

<<struct Reg>>=
type spec = unit
type t    = unit
type loc  = unit

let dummy                = ()
let mk () loc            = ()
let ty () width hint     = ()
let block () width align = ()

let fetch () width       = Impossible.unimp "Alloc.Reg.fetch"
let store () expr width  = Impossible.unimp "Alloc.Reg.store"

let freeze ()            = Impossible.unimp "Alloc.Reg.freeze"
@

% ------------------------------------------------------------------ 
\subsubsection{Overlapping Areas}
% ------------------------------------------------------------------ 

<<overlapping areas implementation>>=
let overlap place areas = Impossible.unimp "Alloc.overlap"
@
