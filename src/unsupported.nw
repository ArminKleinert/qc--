% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Announcing unsupported constructs}

This is a central place at which to announce all the things that a
back end does not support.
The virtue is that each comes with a lengthy explanation of what to do
to fix the problem.
<<unsupported.mli>>=
exception Unsupported
val explain : int -> int list -> unit

  (* Each function below always raises Unsupported *)

val widen_float : int -> 'a
val stack_width : have:int -> want:int -> 'a
val calling_convention : string -> 'a
@ 
<<unsupported.ml>>=
exception Unsupported
type state = { mutable n : int; mutable explanations : (int list -> string list) list }
let state = { n = 0; explanations = [] }

let getn f =
  state.n <- state.n + 1;
  let n = state.n in
  state.explanations <- f :: state.explanations;
  n

let fail msg code args =
  let args = String.concat ", " (List.map string_of_int (code :: args)) in
  Printf.eprintf "%s\n" msg;
  Printf.eprintf "For a longer explanation run\n  %s -e 'Unsupported.explain(%s)'\n"
        (Sys.argv.(0)) args;
  raise Unsupported
<<unsupported.ml>>=
let explain n ns =
  let rec ex m l = match l with
  | [] -> Printf.printf "There is no explanation numbered %d\n" n
  | x :: xs ->
      if m = n then
        List.iter (Printf.printf "%s\n") (x ns)
      else
        ex (m-1) xs
  in ex state.n state.explanations

<<unsupported.ml>>=
let exs ss = (fun _ -> ss)
let ex0 f = function
  |	[] -> f()
  |	_  ->
      ["For this explanation code, Unsupported.explain expects exactly one argument"]
let ex1 f = function
  | [n] -> f n
  | _ ->
      ["For this explanation code, Unsupported.explain expects exactly two arguments"]
let ex2 f = function
  | [n; m] -> f n m
  | _ ->
    ["For this explanation code, Unsupported.explain expects exactly three arguments"]
@ 
<<unsupported.ml>>=
let s = Printf.sprintf
let nosupport s = "This back end does not support " ^ s
<<unsupported.ml>>=
let widen_n = getn (ex1 (fun n ->
    [ s "On this target, floating-point operations can be at most %d bits wide." n;
      "Narrower operations can be widened using one of the stages in the Widen";
      s "module, but anything wider than %d bits is unsupported." n;
    ]))

let widen_float d =
  fail (nosupport (s "%d-bit floating-point computation" d)) widen_n [d]
<<unsupported.ml>>=
let stack_width_n = getn (ex2 (fun h w ->
  [ s "Your code tried to pass a %d-bit argument to an operator that takes its" h;
    s "arguments on the machine stack, but on this target, only %d-bit values can" w;
    "go on the machine stack.";
    "(This message could be triggered if you tried to use software rounding modes";
    "instead of hardware rounding modes in a floating-point instruction on the";
    s "Pentium, or if you tried to use something other than %d-bit floats.)" w;
  ]))
let stack_width ~have ~want =
  fail (nosupport (s "%d-bit value on the machine stack" have))
       stack_width_n [have; want]
<<unsupported.ml>>=
let calling_convention_n = getn (ex0 (fun _ ->
  [ "Your code tried to make a procedure call, return, or cut to using an"
  ; "unsupported calling convention.  Please verify the correct spelling of the"
  ; "calling convention or supply a definition of this calling convention."
  ]))
let calling_convention name =
  fail (nosupport (s "the '%s' calling convention" name))
       calling_convention_n []
