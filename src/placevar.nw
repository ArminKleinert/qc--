% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
%%Grades: D Peripheral Later

\section{Placing variables into suitable temporary locations}
<<placevar.mli>>=
val fortran  : 'a -> Proc.t      -> bool
val fortran' : 'a -> Ast2ir.proc -> bool
@ 
Boilerplate for linking to Lua.
<<placevar.ml>>=
module G = Cfg4
module RP = Rtl.Private
module TM = Proc.VarMap
@
\subsection{Fortran-style variable placer}
The key datastructure is [[tMap]], which maps the index of a variable
to the temporary cell that the variable will occupy.
Function [[walkRtl]] at once builds up the map and replaces each
variable with its temporary location.
<<placevar.ml>>=
let fortran _
	({Proc.cfg = cfg; Proc.target = target; Proc.temps = temps} as proc) =
	<<walk RTL>>
	let updateNode node tMap = 
		let newRtl, tMap' = walkRtl (G.instr node) tMap in
		let _ = G.upd_instr node (fun _ -> newRtl) in
			tMap' in
	let tMap = Cfgutil.fold_fwd cfg updateNode TM.empty in
	let () = proc.Proc.varMap <- tMap in
        let is_not_empty = TM.fold (fun _ _ _ -> true) tMap false in (* ugh *)
        is_not_empty
@ 
<<placevar.ml>>=
let fortran' _ ({Proc.cfg = g; Proc.target = target; Proc.temps = temps} as proc) =
  let module G = Cfgx.M in
  <<walk RTL>>
  let updateNode node tMap =
    match G.to_instr node with
    | None -> tMap
    | Some rtl ->
        let newRtl, tMap' = walkRtl rtl tMap in
  	G.update_instr (fun _ -> newRtl) node;
  	tMap' in
  let tMap = G.fold_nodes updateNode TM.empty g in
  let is_not_empty = TM.fold (fun _ _ _ -> true) tMap false in (* ugh *)
  proc.Proc.varMap <- tMap;
  is_not_empty
@
We use the Fortran convention for placing variables: anything named
with I~through~N is an INteger, and anything else is floating point.
Anything other than 32~bits is shoved into a 32-bit temporary.
This makes no sense to me, and I don't see how it can possibly do
anything useful.
<<walk RTL>>=
(* NOTE: using space 't' is hopeful, but ultimately bogus. *)
let new_tmp name w =
  let first = try Char.lowercase (name.[0])
              with Invalid_argument _ -> Impossible.impossible "empty name" in
    match name, w with
    |   n, _  when String.length n = 0 -> Impossible.impossible "empty name"
    |   n, 32 when 'i' <= first && first <= 'n'
               -> Talloc.Multiple.loc temps 't' w
    |   n, 32  -> Talloc.Multiple.loc temps 'u' w 
    |   n, 64 when 'i' <= first && first <= 'n'
               -> Talloc.Multiple.loc temps 't' 32
    |   n, 64  -> Talloc.Multiple.loc temps 'u' 32
    |   n, 16  -> Talloc.Multiple.loc temps 't' 32
    |   n, 8   -> Talloc.Multiple.loc temps 't' 32
	(*
    |   n, 8   -> Talloc.Multiple.loc temps 'v' w
	*)
    |  _       -> Impossible.impossible 
                    (Printf.sprintf "asked for temporay %s (%d wide)" name w)
in
@ 
Old diagnostics?
<<walk RTL>>=
let print_var (s, i, w) = 
    Verbose.say 18 ["VAR: "
                   ; s 
                   ; " " 
                   ; string_of_int i 
                   ; " " 
                   ; string_of_int w 
                   ; "\n" 
                   ] 
in
@    
A standard recursive tree walk.
The interesting case is [[RP.Var]] in [[walkLoc]].
<<walk RTL>>=
let rec walkLoc loc tMap = match loc with
	| RP.Mem (sp, ag, w, e, ass) ->
		let e', tMap' = walkExp e tMap in
		RP.Mem (sp, ag, w, e', ass), tMap'
        | RP.Reg (sp, i, w) as r -> r, tMap
	| RP.Var (s, i, w) ->
		(try TM.find i tMap, tMap
		 with Not_found ->
			let t = Rtl.Dn.loc (new_tmp s w) in
			(t, TM.add i t tMap))
	| RP.Slice (w, i, l) ->
		let l', tMap' = walkLoc l tMap in
		RP.Slice (w, i, l'), tMap'

and walkExp exp tMap = match exp with
	| RP.Const _ -> exp, tMap
	| RP.Fetch (l, w) ->
		let l', tMap' = walkLoc l tMap in
		RP.Fetch (l', w), tMap'
	| RP.App (op, exps) ->
		let (exps', tMap') =
			List.fold_right (fun e (rst, tMap) ->
                                let e', tMap' = walkExp e tMap
								in e'::rst, tMap')
                            exps ([], tMap) in
		RP.App(op, exps'), tMap'
	
and walkEffect effect tMap = match effect with
	| RP.Store (l, e, w) ->
		let l', tMap' = walkLoc l tMap in
		let e', tMap'' = walkExp e tMap' in
		RP.Store (l', e', w), tMap''
	| RP.Kill l ->
		let l', tMap' = walkLoc l tMap in
		RP.Kill l', tMap' in

let walkGuard (exp, effect) tMap =
	let (exp', tMap') = walkExp exp tMap in
	let (effect', tMap'') = walkEffect effect tMap in
	(exp', effect'), tMap'' in

let walkRtl r tMap = match Rtl.Dn.rtl r with
	| RP.Rtl gs ->
		let (gs', tMap') =
			List.fold_right (fun g (rst, tMap) ->
								let g', tMap' = walkGuard g tMap
                                in g'::rst, tMap')
                            gs ([], tMap) in
		Rtl.Up.rtl (RP.Rtl gs'), tMap' in
@
