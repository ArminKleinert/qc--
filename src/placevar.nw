% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
%%Grades: D Peripheral Later

\section{Placing variables into suitable temporary locations}
<<placevar.mli>>=
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.action)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Proc.t and type 'a
                                             combined = 'a BackplaneT.combined)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a BackplaneT.combined

@ 
Boilerplate for linking to Lua.
<<placevar.ml>>=
module Make (BackplaneT : Lua.Lib.TYPEVIEW with type 'a t = 'a Backplane.action)
            (ProcT : Lua.Lib.TYPEVIEW with type 'a t = Proc.t and type 'a
combined = 'a BackplaneT.combined)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a BackplaneT.combined =
  struct
    type 'a combined = 'a BackplaneT.combined
    module M (Interp : Lua.Lib.CORE with type 'a V.userdata' = 'a BackplaneT.combined) = struct
      module V = Interp.V
      module G = Cfg4
    
      let proc = ProcT.makemap V.userdata V.projection
      let ( **-> ) = V.( **-> )
      <<builtins>>

      let init g =
        Interp.register_module "Placevar"
          [ "fortran", V.efunc (V.value **-> proc **-> V.result V.bool) fortran
          ] g;
        Lua.Lib.StringList.empty (* FIX -- proper stage *)
    end
  end
@
\subsection{Fortran-style variable placer}
The key datastructure is [[tMap]], which maps the index of a variable
to the temporary cell that the variable will occupy.
Function [[walkRtl]] at once builds up the map and replaces each
variable with its temporary location.
<<builtins>>=
module RP = Rtl.Private
module TM = Map.Make(struct type t = int let compare = compare end)

let fortran _ {Proc.cfg = cfg; Proc.target = target; Proc.temps = temps} =
	<<walk RTL>>
	let updateNode node tMap = 
		let newRtl, tMap' = walkRtl (G.instr node) tMap in
		let _ = G.upd_instr node (fun _ -> newRtl) in
			tMap' in
	let tMap = Cfgutil.fold_fwd cfg updateNode TM.empty in
        let is_not_empty = TM.fold (fun _ _ _ -> true) tMap false in (* ugh *)
        is_not_empty
@
We use the Fortran convention for placing variables: anything named
with I~through~N is an INteger, and anything else is floating point.
Anything other than 32~bits is shoved into a 32-bit temporary.
This makes no sense to me, and I don't see how it can possibly do
anything useful.
<<walk RTL>>=
(* NOTE: using space 't' is hopeful, but ultimately bogus. *)
let new_tmp name w =
  let first = try Char.lowercase (name.[0])
              with Invalid_argument _ -> Impossible.impossible "empty name" in
    match name, w with
    |   n, _  when String.length n = 0 -> Impossible.impossible "empty name"
    |   n, 32 when 'i' <= first && first <= 'n'
               -> Talloc.Multiple.loc temps 't' w
    |   n, 32  -> Talloc.Multiple.loc temps 'u' w 
    |   n, 64 when 'i' <= first && first <= 'n'
               -> Talloc.Multiple.loc temps 't' 32
    |   n, 64  -> Talloc.Multiple.loc temps 'u' 32
    |   n, 16  -> Talloc.Multiple.loc temps 't' 32
    |   n, 8   -> Talloc.Multiple.loc temps 't' 32
	(*
    |   n, 8   -> Talloc.Multiple.loc temps 'v' w
	*)
    |  _       -> Impossible.impossible 
                    (Printf.sprintf "asked for temporay %s (%d wide)" name w)
in
@ 
Old diagnostics?
<<walk RTL>>=
let print_var (s, i, w) = 
    Verbose.say 18 ["VAR: "
                   ; s 
                   ; " " 
                   ; string_of_int i 
                   ; " " 
                   ; string_of_int w 
                   ; "\n" 
                   ] 
in
@    
A standard recursive tree walk.
The interesting case is [[RP.Var]] in [[walkLoc]].
<<walk RTL>>=
let rec walkLoc loc tMap = match loc with
	| RP.Mem (sp, ag, w, e, ass) ->
		let e', tMap' = walkExp e tMap in
		RP.Mem (sp, ag, w, e', ass), tMap'
        | RP.Reg (sp, i, w) as r -> r, tMap
	| RP.Var (s, i, w) ->
		(try TM.find i tMap, tMap
		 with Not_found ->
			let t = Rtl.Convert.loc (new_tmp s w) in
			(t, TM.add i t tMap))
	| RP.Slice (w, i, l) ->
		let l', tMap' = walkLoc l tMap in
		RP.Slice (w, i, l'), tMap'

and walkExp exp tMap = match exp with
	| RP.Const _ -> exp, tMap
	| RP.Fetch (l, w) ->
		let l', tMap' = walkLoc l tMap in
		RP.Fetch (l', w), tMap'
	| RP.App (op, exps) ->
		let (exps', tMap') =
			List.fold_right (fun e (rst, tMap) ->
                                let e', tMap' = walkExp e tMap
								in e'::rst, tMap')
                            exps ([], tMap) in
		RP.App(op, exps'), tMap'
	
and walkEffect effect tMap = match effect with
	| RP.Store (l, e, w) ->
		let l', tMap' = walkLoc l tMap in
		let e', tMap'' = walkExp e tMap' in
		RP.Store (l', e', w), tMap''
	| RP.Kill l ->
		let l', tMap' = walkLoc l tMap in
		RP.Kill l', tMap' in

let walkGuard (exp, effect) tMap =
	let (exp', tMap') = walkExp exp tMap in
	let (effect', tMap'') = walkEffect effect tMap in
	(exp', effect'), tMap'' in

let walkRtl r tMap = match Rtl.Convert.rtl r with
	| RP.Rtl gs ->
		let (gs', tMap') =
			List.fold_right (fun g (rst, tMap) ->
								let g', tMap' = walkGuard g tMap
                                in g'::rst, tMap')
                            gs ([], tMap) in
		Rtl.Revert.rtl (RP.Rtl gs'), tMap' in
@
