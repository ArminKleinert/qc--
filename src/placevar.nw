% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
%%Grades: D Peripheral Later

\section{Placing variables into suitable temporary locations}
<<placevar.mli>>=
val fortran'  : 'a -> Ast2ir.proc -> bool
val context   : (Ast2ir.proc -> Automaton.t) -> 'e -> Ast2ir.proc -> bool
@ 
Boilerplate for linking to Lua.
<<placevar.ml>>=
module R  = Rtl
module RU = Rtlutil
module A  = Automaton
module RP = Rtl.Private
module TM = Proc.VarMap

<<replace var>>
@
\subsection{Fortran-style variable placer}
The key datastructure is [[tMap]], which maps the index of a variable
to the temporary cell that the variable will occupy.
Function [[replace_var]] at once builds up the map and replaces each
variable with its temporary location.
<<placevar.ml>>=
let fortran' _ ({Proc.cfg = g; Proc.target = target; Proc.temps = temps} as proc) =
  let module G = Cfgx.M in
  <<fortran replace var>>
  let updateNode node tMap =
    match G.to_instr node with
    | None     -> tMap
    | Some rtl -> let rtl', tMap' = replace_var place_var rtl tMap in
                  G.update_instr (fun _ -> rtl') node;
                  tMap' in
  let tMap = G.fold_nodes updateNode TM.empty g in
  let is_not_empty = TM.fold (fun _ _ _ -> true) tMap false in (* ugh *)
  proc.Proc.varMap <- tMap;
  is_not_empty
@
We use the Fortran convention for placing variables: anything named
with I~through~N is an INteger, and anything else is floating point.
Anything other than 32~bits is shoved into a 32-bit temporary.
This makes no sense to me, and I don't see how it can possibly do
anything useful.
<<fortran replace var>>=
(* NOTE: using space 't' is hopeful, but ultimately bogus. *)
let new_tmp name w =
  let first = try Char.lowercase (name.[0])
              with Invalid_argument _ -> Impossible.impossible "empty name" in
    match name, w with
    |   n, _  when String.length n = 0 -> Impossible.impossible "empty name"
    |   n, 32 when 'i' <= first && first <= 'n'
               -> Talloc.Multiple.loc temps 't' w
    |   n, 32  -> Printf.eprintf "name:%s\n" name;Talloc.Multiple.loc temps 'u' w 
    |   n, 64 when 'i' <= first && first <= 'n'
               -> Talloc.Multiple.loc temps 't' 64
    |   n, 64  -> Talloc.Multiple.loc temps 'u' 64
    |   n, 16  -> Talloc.Multiple.loc temps 't' 32
    |   n, 8   -> Talloc.Multiple.loc temps 't' 32
  (*
    |   n, 8   -> Talloc.Multiple.loc temps 'v' w
  *)
    |  _       -> Impossible.impossible 
                    (Printf.sprintf "asked for temporay %s (%d wide)" name w) in
let place_var (s, i, w) tMap = 
  try TM.find i tMap, tMap
  with Not_found -> let t = Rtl.Dn.loc (new_tmp s w) in
                    (t, TM.add i t tMap) in
@ 
Old diagnostics?
<<walk RTL>>=
let print_var (s, i, w) = 
    Verbose.say 18 ["VAR: "
                   ; s 
                   ; " " 
                   ; string_of_int i 
                   ; " " 
                   ; string_of_int w 
                   ; "\n" 
                   ] in
@    
We use a higer-order function to allow different variable placers to replace a variable
and take advantage of the rtl-walk with variable map threading.
<<replace var>>=
let replace_var freplace r tMap =
  <<walk RTL>>
  walkRtl r tMap
@


A standard recursive tree walk.
The interesting case is [[RP.Var]] in [[walkLoc]]; we apply the function.
<<walk RTL>>=
(* THIS IS A BOGUS CHEAT *)
let rec walkLoc loc tMap = match loc with
  | RP.Mem (sp, ag, w, e, ass) -> let e', tMap' = walkExp e tMap in
                                  RP.Mem (sp, ag, w, e', ass), tMap'
  | RP.Reg (sp, i, w) as r     -> r, tMap
  | RP.Var (s, i, w)           -> freplace (s, i, w) tMap
  | RP.Slice (w, i, l) -> let l', tMap' = walkLoc l tMap in
                          RP.Slice (w, i, l'), tMap'

and walkExp exp tMap = match exp with
  | RP.Const _          -> exp, tMap
  | RP.Fetch (l, w)     -> let l', tMap' = walkLoc l tMap in
                           RP.Fetch (l', w), tMap'
  | RP.App   (op, exps) ->
    let (exps', tMap') =
      List.fold_right (fun e (rst, tMap) -> let e', tMap' = walkExp e tMap in
                                            e'::rst, tMap')
                      exps ([], tMap) in
    RP.App(op, exps'), tMap'
  
and walkEffect effect tMap = match effect with
  | RP.Store (l, e, w) ->
    let l', tMap'  = walkLoc l tMap in
    let e', tMap'' = walkExp e tMap' in
    RP.Store (l', e', w), tMap''
  | RP.Kill l ->
    let l', tMap' = walkLoc l tMap in
    RP.Kill l', tMap' in

let walkGuard (exp, effect) tMap =
  let (exp', tMap')     = walkExp exp tMap in
  let (effect', tMap'') = walkEffect effect tMap' in
  (exp', effect'), tMap'' in

let walkRtl r tMap = match Rtl.Dn.rtl r with
  | RP.Rtl gs ->
    let (gs', tMap') =
      List.fold_right (fun g (rst, tMap) -> let g', tMap' = walkGuard g tMap in
                                            g'::rst, tMap')
                      gs ([], tMap) in
    Rtl.Up.rtl (RP.Rtl gs'), tMap' in
@
\subsection{Variable Placement by Execution Estimate}
This variable placer bases its decisions on how often a variable is used in each
context.
We use a table of operator contexts to find the context in which a variable is used
in each instruction.
We weight each context of a variable by the number of times the instruction is
executed.
We place the variable in the context in which it is used most often in the procedure.
<<placevar.ml>>=
module G = Cfgx.M
module IntMod  = struct type t = int            let compare = compare end
module NodeMod = struct type t = Rtl.rtl G.node
                        let compare = (fun n1 n2 -> compare (G.num n1) (G.num n2))
                 end
module IM = Map.Make (IntMod)
module NM = Map.Make (NodeMod)
module SM = Strutil.Map
<<define context count structures>>
let context autmtn _ ({Proc.cfg = g; Proc.target = target} as proc) =
  let autmtn = autmtn proc in
  <<initialize context count structures>>
  <<get operator contexts>>
  <<estimate exec\_counts for graph nodes>>
  <<count uses in each context>>
  <<choose a context for each variable>>
  <<replace variables with temps>>
  <<use verbose 4 to print varmap>>
  proc.Proc.varMap <- tMap;
  TM.fold (fun _ _ _ -> true) tMap false (* ugh *)
@
For each variable, we keep track of how many times it is used in each context.
We use mutable state to store the counts for each variable, and we keep the records
in an array indexed by the variable number.
<<define context count structures>>=
type counts = { mutable intc   : float
              ; mutable floatc : float
              ; mutable addrc  : float
              ; mutable boolc  : float
              }
@
<<initialize context count structures>>=
let new_count _ = { intc = 0.0; floatc = 0.0; addrc = 0.0; boolc = 0.0}  in
let var_counts = Array.init proc.Proc.vars new_count                     in
let inc_int   i f = let record = var_counts.(i)                          in
                    record.intc <- record.intc +. f                      in
let inc_float i f = let record = var_counts.(i)                          in
                    record.floatc <- record.floatc +. f                  in
let inc_addr  i f = let record = var_counts.(i)                          in
                    record.addrc <- record.addrc +. f                    in
let inc_bool  i f = Error.warningPrt "variable found in boolean context" in
@
A call to [[Context.standard]] returns a list of (operator, parameter list, result)
triples, where the argument list and result tell us in what context the arguments and 
results are expected by the operator.
To speed lookup, we use a map to hold this information.
<<get operator contexts>>=
let ops =
  List.fold_left (fun map (op, parms, res) -> SM.add op (parms, res) map)
                 SM.empty (Context.standard inc_int inc_float inc_addr inc_bool) in
let ctxt_parms  op = try Some (fst (SM.find op ops)) with Not_found -> None in
let ctxt_result op = try Some (snd (SM.find op ops)) with Not_found -> None in
@
For now, we don't estimate execution counts; we assume each node is executed once.
<<estimate exec\_counts for graph nodes>>=
let exec_counts      = G.fold_nodes (fun n map -> NM.add n 1.0 map) NM.empty g  in
let get_exec_count n = try NM.find n exec_counts
                       with Not_found -> Impossible.impossible "node not counted" in 
@
We use the execution counts and the table of operator contexts to estimate how many
times each variable is used in each context.
The function [[count]] calls [[count_rtl]] to walk the rtl's and count uses.
<<count uses in each context>>=
let count node =
  <<define counting functions>>
  match G.to_instr node with
  | None   -> ()
  | Some i -> count_rtl i in
let () = G.iter_nodes count g in
@
The function [[count_rtl]] walks an rtl in a top-down fashion, looking for the use of
an operator.
If an operator is found and its argument or result is a variable, we increment the
number of times the variable has been used in its current context (as determined by the
operator).
Counting arguments to an operator is easy (see [[count_exp]]), but counting the result
of the operator requires a special case in [[count_effect]].
<<define counting functions>>=
let rec count_loc loc ctxt = match loc with
  | RP.Mem   (_, _, _, e, _) -> count_exp e (Some inc_addr)
  | RP.Slice (_, _, l)       -> count_loc l ctxt
  | RP.Reg    _              -> ()
  | RP.Var   (_, i, _)       ->
    (match ctxt with
     | None   -> ()
     | Some c -> c i (get_exec_count node))

and count_exp exp ctxt = match exp with
  | RP.Const _        -> ()
  | RP.Fetch (l, _)   -> count_loc l ctxt
  | RP.App ((op, _), exps) ->
    let ctxts = match ctxt_parms op with
                | None    -> List.map (fun s -> None)   exps
                | Some cs -> List.map (fun c -> Some c) cs   in
    List.iter2 count_exp exps ctxts in

let count_effect effect = match effect with
  | RP.Store (l, (RP.App ((op, _), _) as e), _) ->
      (count_exp e None ; count_loc l (ctxt_result op))
  | RP.Store (l, e, _) -> (count_exp e None ; count_loc l None)
  | RP.Kill   l        -> count_loc l None in

let count_guard (exp, effect) = (count_effect effect ; count_exp exp None) in

let rec count_rtl r = match Rtl.Dn.rtl r with
  | RP.Rtl gs -> List.iter count_guard gs in
@
For each variable, we choose the context with the most votes.
The default context is "int".
<<choose a context for each variable>>=
let ctxt_map =
  let elect i =
    let cnts = var_counts.(i) in
    let icnt = cnts.intc      in
    let fcnt = cnts.floatc    in
    let acnt = cnts.addrc     in
    let (cnt,ctxt) = if icnt >= fcnt then (icnt,"int") else (fcnt, "float") in
    if cnt >= acnt then ctxt else "addr" in
  Array.init proc.Proc.vars elect in
@
To replace a variable, we use the automaton to allocate a new fetch of the variable,
and we extract the location.
<<context replace var>>=
let place_var (s, i, w) tMap =
  try TM.find i tMap, tMap
  with Not_found ->
    match Rtl.Dn.exp ((A.allocate autmtn w ctxt_map.(i)).A.fetch w) with
		| RP.Fetch (l,_) -> (l, TM.add i l tMap)
		| _              -> Impossible.impossible "Fetch returned non-fetch rtl" in
@
We fold over the nodes, replacing variables with each variable with a temp for the
proper context.
We include the functions that replace variables as nested functions in [[updateNode]] so
they will have access to the entire rtl.
<<replace variables with temps>>=
let updateNode node tMap =
  match G.to_instr node with
  | None     -> tMap
  | Some rtl ->
    <<context replace var>>
    let rtl', tMap' = replace_var place_var rtl tMap in
    G.update_instr (fun _ -> rtl') node;
    tMap' in
let tMap = G.fold_nodes updateNode TM.empty g in
@
We may want to print the variable map.
<<use verbose 4 to print varmap>>=
let () =
  let map = TM.fold (fun i l rst -> Printf.sprintf "  %d -> %s"
                                      i (RU.ToReadableString.loc (R.Up.loc l)) :: rst)
                    tMap [] in
  Verbose.say 4 (["Varmap: Var i -> Loc\n"] @ map) in
@
