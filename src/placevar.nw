% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
%%Grades: D Peripheral Later

\section{Placing variables into suitable temporary locations}
<<placevar.mli>>=
val fortran'  : 'a -> Ast2ir.proc -> bool
val context   : (Ast2ir.proc -> Automaton.t) -> 'e -> Ast2ir.proc -> bool
@ 
Boilerplate for linking to Lua.
<<placevar.ml>>=
module R  = Rtl
module RU = Rtlutil
module A  = Automaton
module RP = Rtl.Private
module TM = Proc.VarMap

<<replace var>>
@
\subsection{Fortran-style variable placer}
The key datastructure is [[tMap]], which maps the index of a variable
to the temporary cell that the variable will occupy.
Function [[replace_var]] at once builds up the map and replaces each
variable with its temporary location.
<<placevar.ml>>=
let fortran' _ ({Proc.cfg = g; Proc.target = target; Proc.temps = temps} as proc) =
  let module G = Cfgx.M in
  let tMap = Array.init proc.Proc.vars (fun _ -> None) in
  <<fortran replace var>>
  let updateNode node =
    match G.to_instr node with
    | None     -> ()
    | Some rtl -> let rtl' = replace_var store_var fetch_var rtl in
                  G.update_instr (fun _ -> rtl') node  in
  let () = G.iter_nodes updateNode g in
  (*let is_not_empty = TM.fold (fun _ _ _ -> true) tMap false in (* ugh *)
  proc.Proc.varMap <- tMap;
  is_not_empty
	*)
	true
@
We use the Fortran convention for placing variables: anything named
with I~through~N is an INteger, and anything else is floating point.
Anything other than 32~bits is shoved into a 32-bit temporary.
This makes no sense to me, and I don't see how it can possibly do
anything useful.
<<fortran replace var>>=
(* NOTE: using space 't' is hopeful, but ultimately bogus. *)
let new_tmp name w =
  let first = try Char.lowercase (name.[0])
              with Invalid_argument _ -> Impossible.impossible "empty name" in
    match name, w with
    |   n, _  when String.length n = 0 -> Impossible.impossible "empty name"
    |   n, 32 when 'i' <= first && first <= 'n'
               -> Talloc.Multiple.loc temps 't' w
    |   n, 32  -> Printf.eprintf "name:%s\n" name;Talloc.Multiple.loc temps 'u' w 
    |   n, 64 when 'i' <= first && first <= 'n'
               -> Talloc.Multiple.loc temps 't' 64
    |   n, 64  -> Talloc.Multiple.loc temps 'u' 64
    |   n, 16  -> Talloc.Multiple.loc temps 't' 32
    |   n, 8   -> Talloc.Multiple.loc temps 't' 32
  (*
    |   n, 8   -> Talloc.Multiple.loc temps 'v' w
  *)
    |  _       -> Impossible.impossible 
                    (Printf.sprintf "asked for temporay %s (%d wide)" name w) in
let get_placer s i w =
  match tMap.(i) with
  | Some a -> a
  | None   -> let tmp = new_tmp s w in
              let alloc = { A.fetch = (fun   w -> R.fetch tmp w)
								          ; A.store = (fun e w -> R.store tmp e w)
													} in
              (tMap.(i) <- Some alloc; alloc) in
let store_var exp (s, i, w) = (get_placer s i w).A.store (R.Up.exp exp) w in
let fetch_var     (s, i, w) = (get_placer s i w).A.fetch                w in
@ 
Old diagnostics?
<<walk RTL>>=
let print_var (s, i, w) = 
    Verbose.say 18 ["VAR: "
                   ; s 
                   ; " " 
                   ; string_of_int i 
                   ; " " 
                   ; string_of_int w 
                   ; "\n" 
                   ] in
@    

We use a higer-order function to allow different variable placers to replace a variable
and take advantage of the rtl-walk.
<<replace var>>=
let replace_var store_var fetch_var r =
  <<walk RTL>>
  walkRtl r
@
A standard recursive tree walk.
The interesting case is [[RP.Fetch]] in [[walkExp]]; we apply the function.
<<walk RTL>>=
let id x = x in
let rec walkLoc loc =
  match loc with
  | RP.Mem   (sp, ag, w, e, ass) -> RP.Mem (sp, ag, w, walkExp e, ass)
  | RP.Reg   (sp, i, w) as r     -> r
  | RP.Var   (s, i, w)           -> Impossible.unimp "slice of variable"
  | RP.Slice (w, i, l)           -> RP.Slice (w, i, walkLoc l)

and walkExp exp = match exp with
  | RP.Const _                   -> exp
  | RP.Fetch (RP.Var (s,i,w), _) -> R.Dn.exp (fetch_var (s,i,w))
  | RP.Fetch (l, w)              -> RP.Fetch (walkLoc l, w)
  | RP.App   (op, exps)          -> RP.App(op, List.map walkExp exps)
and upExp e = R.Up.exp (walkExp e)
and upLoc l = R.Up.loc (walkLoc l)
  
and walkEffect effect = match effect with
  | RP.Store (RP.Var (s,i,w), e, _) -> store_var (walkExp e) (s,i,w)
  | RP.Store (l, e, w)        -> R.store (upLoc l) (upExp e) w
  | RP.Kill  (RP.Var _)       -> Impossible.unimp "Killing variables is unimplemented"
  | RP.Kill  l                -> R.kill (upLoc l) in

let walkGuard (exp, effect) = R.guard (upExp exp) (walkEffect effect) in

let walkRtl r = match Rtl.Dn.rtl r with
  | RP.Rtl gs -> R.par (List.map walkGuard gs) in
@
\subsection{Variable Placement by Execution Estimate}
This variable placer bases its decisions on how often a variable is used in each
context.
We use a table of operator contexts to find the context in which a variable is used
in each instruction.
We weight each context of a variable by the number of times the instruction is
executed.
We place the variable in the context in which it is used most often in the procedure.
<<placevar.ml>>=
module G = Cfgx.M
module IntMod  = struct type t = int            let compare = compare end
module NodeMod = struct type t = Rtl.rtl G.node
                        let compare = (fun n1 n2 -> compare (G.num n1) (G.num n2))
                 end
module IM = Map.Make (IntMod)
module NM = Map.Make (NodeMod)
module SM = Strutil.Map
@
The first argument to the variable placer is a function that takes a [[proc.t]] and
returns an automaton.
The automaton provides locations for variables.
The automaton must return unsplit locations.
In the variable placer, we rely on this guarantee; for an automaton used in calling
conventions, we have no such guarantees.
<<placevar.ml>>=
<<define context count structures>>
let context autmtn _ ({Proc.cfg = g; Proc.target = target} as proc) =
  let autmtn = autmtn proc in
  <<initialize context count structures>>
  <<get operator contexts>>
  <<estimate exec\_counts for graph nodes>>
  <<count uses in each context>>
  <<choose a context for each variable>>
  <<replace variables with temps>>
  <<add the allocation automaton's overflow block to the proc.t>>
  (*proc.Proc.varMap <- tMap;*)
  (*TM.fold (fun _ _ _ -> true) tMap false (* ugh *)*)
	true
@
For each variable, we keep track of how many times it is used in each context.
We use mutable state to store the counts for each variable, and we keep the records
in an array indexed by the variable number.
<<define context count structures>>=
type counts = { mutable intc   : float
              ; mutable floatc : float
              ; mutable addrc  : float
              ; mutable boolc  : float
              }
@
<<initialize context count structures>>=
let new_count _ = { intc = 0.0; floatc = 0.0; addrc = 0.0; boolc = 0.0}  in
let var_counts = Array.init proc.Proc.vars new_count                     in
let inc_int   i f = let record = var_counts.(i)                          in
                    record.intc <- record.intc +. f                      in
let inc_float i f = let record = var_counts.(i)                          in
                    record.floatc <- record.floatc +. f                  in
let inc_addr  i f = let record = var_counts.(i)                          in
                    record.addrc <- record.addrc +. f                    in
let inc_bool  i f = Error.warningPrt "variable found in boolean context" in
@
A call to [[Context.standard]] returns a list of (operator, parameter list, result)
triples, where the argument list and result tell us in what context the arguments and 
results are expected by the operator.
To speed lookup, we use a map to hold this information.
<<get operator contexts>>=
let ops =
  List.fold_left (fun map (op, parms, res) -> SM.add op (parms, res) map)
                 SM.empty (Context.standard inc_int inc_float inc_addr inc_bool) in
let ctxt_parms  op = try Some (fst (SM.find op ops)) with Not_found -> None in
let ctxt_result op = try Some (snd (SM.find op ops)) with Not_found -> None in
@
For now, we don't estimate execution counts; we assume each node is executed once.
<<estimate exec\_counts for graph nodes>>=
let exec_counts      = G.fold_nodes (fun n map -> NM.add n 1.0 map) NM.empty g  in
let get_exec_count n = try NM.find n exec_counts
                       with Not_found -> Impossible.impossible "node not counted" in 
@
We use the execution counts and the table of operator contexts to estimate how many
times each variable is used in each context.
The function [[count]] calls [[count_rtl]] to walk the rtl's and count uses.
<<count uses in each context>>=
let count node =
  <<define counting functions>>
  match G.to_instr node with
  | None   -> ()
  | Some i -> count_rtl i in
let () = G.iter_nodes count g in
@
The function [[count_rtl]] walks an rtl in a top-down fashion, looking for the use of
an operator.
If an operator is found and its argument or result is a variable, we increment the
number of times the variable has been used in its current context (as determined by the
operator).
Counting arguments to an operator is easy (see [[count_exp]]), but counting the result
of the operator requires a special case in [[count_effect]].
<<define counting functions>>=
let rec count_loc loc ctxt = match loc with
  | RP.Mem   (_, _, _, e, _) -> count_exp e (Some inc_addr)
  | RP.Slice (_, _, l)       -> count_loc l ctxt
  | RP.Reg    _              -> ()
  | RP.Var   (_, i, _)       ->
    (match ctxt with
     | None   -> ()
     | Some c -> c i (get_exec_count node))

and count_exp exp ctxt = match exp with
  | RP.Const _        -> ()
  | RP.Fetch (l, _)   -> count_loc l ctxt
  | RP.App ((op, _), exps) ->
    let ctxts = match ctxt_parms op with
                | None    -> List.map (fun s -> None)   exps
                | Some cs -> List.map (fun c -> Some c) cs   in
    List.iter2 count_exp exps ctxts in

let count_effect effect = match effect with
  | RP.Store (l, (RP.App ((op, _), _) as e), _) ->
      (count_exp e None ; count_loc l (ctxt_result op))
  | RP.Store (l, e, _) -> (count_exp e None ; count_loc l None)
  | RP.Kill   l        -> count_loc l None in

let count_guard (exp, effect) = (count_effect effect ; count_exp exp None) in

let rec count_rtl r = match Rtl.Dn.rtl r with
  | RP.Rtl gs -> List.iter count_guard gs in
@
For each variable, we choose the context with the most votes.
The default context is "int".
<<choose a context for each variable>>=
let ctxt_map =
  let elect i =
    let cnts = var_counts.(i) in
    let icnt = cnts.intc      in
    let fcnt = cnts.floatc    in
    let acnt = cnts.addrc     in
    let (cnt,ctxt) = if icnt >= fcnt then (icnt,"int") else (fcnt, "float") in
    if cnt >= acnt then ctxt else "addr" in
  Array.init proc.Proc.vars elect in
@
To replace a variable, we use the automaton to allocate a new fetch of the variable,
and we extract the location.
For variable placement, we can rely on the format of the rtl returned by the automaton.
For calling conventions, it would not be safe to rely on the form of the rtl.
<<context replace var>>=
let get_placer i w =
  match tMap.(i) with
  | Some a -> a
  | None   -> let alloc = A.allocate autmtn w ctxt_map.(i) in
              (tMap.(i) <- Some alloc; alloc) in
let store_var exp (_, i, w) = (get_placer i w).A.store (R.Up.exp exp) w in
let fetch_var     (s, i, w) = (get_placer i w).A.fetch     w in
@
We fold over the nodes, replacing variables with each variable with a temp for the
proper context.
We include the functions that replace variables as nested functions in [[updateNode]] so
they will have access to the entire rtl.
<<replace variables with temps>>=
let tMap = Array.init proc.Proc.vars (fun _ -> None) in
let updateNode node =
  match G.to_instr node with
  | None     -> ()
  | Some rtl ->
    <<context replace var>>
    G.update_instr (fun _ -> replace_var store_var fetch_var rtl) node in
let () = G.iter_nodes updateNode g in
@
<<add the allocation automaton's overflow block to the proc.t>>=
(*
let res = freeze autmtn in
*)
@
