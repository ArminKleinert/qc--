% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
%%Grades: D Peripheral Later

\section{Placing variables into suitable temporary locations}
The [[mk_automaton]] function generates an automaton for placing variables,
given a warning function and a function that returns temporaries.
The [[context]] variable placer gives an automaton stage the opportunity to put
a variable into a temporary; if the opportunity is not used (i.e. the stage
passes the buck to its successor), the variable goes into the private block on
the stack.
<<placevar.mli>>=
val mk_automaton : warn:(width:int -> alignment:int -> hint:string -> unit) ->
                   vfp:Rtl.exp ->
                   memsize:int ->
                   byteorder:Rtl.aggregation ->
                   (temps:(Rtl.space -> Automaton.stage) -> Automaton.stage) ->
                   (Ast2ir.proc -> Automaton.t)
val context   : (Ast2ir.proc -> Automaton.t) -> 'e -> Ast2ir.proc -> bool
@ 
The [[fortran]] variable placer is deprecated.
<<placevar.mli>>=
val fortran'  : 'a -> Ast2ir.proc -> bool
@
Boilerplate for linking to Lua.
<<placevar.ml>>=
module R  = Rtl
module RT = Runtimedata
module RU = Rtlutil
module A  = Automaton
module RP = Rtl.Private

<<replace var>>
@
\subsection{Fortran-style variable placer}
The key datastructure is [[tMap]], which maps the index of a variable
to the temporary cell that the variable will occupy.
Function [[replace_var]] at once builds up the map and replaces each
variable with its temporary location.
<<placevar.ml>>=
let fortran' _ ({Proc.cfg = g; Proc.temps = temps; Proc.varMap = tMap} as proc) =
  let module G = Cfgx.M in
  let changed = ref false in
  <<fortran replace var>>
  let updateNode node =
    match G.to_instr node with
    | None     -> ()
    | Some rtl -> let rtl' = replace_var store_var fetch_var rtl in
                  G.update_instr (fun _ -> rtl') node  in
  let () = G.iter_nodes updateNode g in
  <<add variable placements to spans>>
  !changed
@
We use the Fortran convention for placing variables: anything named
with I~through~N is an INteger, and anything else is floating point.
Anything other than 32~bits is shoved into a 32-bit temporary.
This makes no sense to me, and I don't see how it can possibly do
anything useful.
<<fortran replace var>>=
(* NOTE: using space 't' is hopeful, but ultimately bogus. *)
let new_tmp name w =
  let first = try Char.lowercase (name.[0])
              with Invalid_argument _ -> Impossible.impossible "empty name" in
    match name, w with
    |   n, _  when String.length n = 0 -> Impossible.impossible "empty name"
    |   n, 32 when 'i' <= first && first <= 'n'
               -> Talloc.Multiple.loc temps 't' w
    |   n, 32  -> Printf.eprintf "name:%s\n" name;Talloc.Multiple.loc temps 'u' w 
    |   n, 64 when 'i' <= first && first <= 'n'
               -> Talloc.Multiple.loc temps 't' 64
    |   n, 64  -> Talloc.Multiple.loc temps 'u' 64
    |   n, 16  -> Talloc.Multiple.loc temps 't' 32
    |   n, 8   -> Talloc.Multiple.loc temps 't' 32
  (*
    |   n, 8   -> Talloc.Multiple.loc temps 'v' w
  *)
    |  _       -> Impossible.impossible 
                    (Printf.sprintf "asked for temporay %s (%d wide)" name w) in
let get_placer s i w =
  match tMap.(i) with
  | Some a -> a
  | None   -> let tmp = new_tmp s w in
              let alloc = { A.fetch  = (fun   w -> R.fetch tmp w)
                          ; A.store  = (fun e w -> R.store tmp e w)
                          ; A.simple = (fun ()  -> tmp)
                          } in
              (changed := true;
               tMap.(i) <- Some alloc;
               alloc) in
let store_var exp (s, i, w) = (get_placer s i w).A.store (R.Up.exp exp) w in
let fetch_var     (s, i, w) = (get_placer s i w).A.fetch                w in
@ 
Old diagnostics?
<<walk RTL>>=
let print_var (s, i, w) = 
    Verbose.say 18 ["VAR: "
                   ; s 
                   ; " " 
                   ; string_of_int i 
                   ; " " 
                   ; string_of_int w 
                   ; "\n" 
                   ] in
@    

We use a higer-order function to allow different variable placers to replace a variable
and take advantage of the rtl-walk.
<<replace var>>=
let replace_var store_var fetch_var r =
  <<walk RTL>>
  walkRtl r
@
A standard recursive tree walk.
The interesting case is [[RP.Fetch]] in [[walkExp]]; we apply the function.
<<walk RTL>>=
let id x = x in
let rec walkLoc loc =
  match loc with
  | RP.Mem   (sp, ag, w, e, ass) -> RP.Mem (sp, ag, w, walkExp e, ass)
  | RP.Reg   (sp, i, w) as r     -> r
  | RP.Var   (s, i, w)           -> Impossible.unimp "slice of variable"
  | RP.Slice (w, i, l)           -> RP.Slice (w, i, walkLoc l)

and walkExp exp = match exp with
  | RP.Const _                   -> exp
  | RP.Fetch (RP.Var (s,i,w), _) -> R.Dn.exp (fetch_var (s,i,w))
  | RP.Fetch (l, w)              -> RP.Fetch (walkLoc l, w)
  | RP.App   (op, exps)          -> RP.App(op, List.map walkExp exps)
and upExp e = R.Up.exp (walkExp e)
and upLoc l = R.Up.loc (walkLoc l)
  
and walkEffect effect = match effect with
  | RP.Store (RP.Var (s,i,w), e, _) -> store_var (walkExp e) (s,i,w)
  | RP.Store (l, e, w)        -> R.store (upLoc l) (upExp e) w
  | RP.Kill  (RP.Var _)       -> Impossible.unimp "Killing variables is unimplemented"
  | RP.Kill  l                -> R.kill (upLoc l) in

let walkGuard (exp, effect) = R.guard (upExp exp) (walkEffect effect) in

let walkRtl r = match Rtl.Dn.rtl r with
  | RP.Rtl gs -> R.par (List.map walkGuard gs) in
@
\subsection{Variable Placement by Execution Estimate}
This variable placer bases its decisions on how often a variable is used in each
context.
We use a table of operator contexts to find the context in which a variable is used
in each instruction.
We weight each context of a variable by the number of times the instruction is
executed.
We place the variable in the context in which it is used most often in the procedure.
<<placevar.ml>>=
module G = Cfgx.M
module IntMod  = struct type t = int            let compare = compare end
module NodeMod = struct type t = Rtl.rtl G.node
                        let compare = (fun n1 n2 -> compare (G.num n1) (G.num n2))
                 end
module IM = Map.Make (IntMod)
module NM = Map.Make (NodeMod)
module SM = Strutil.Map
@
The first argument to the variable placer is a function that takes a [[proc.t]] and
returns an automaton.
The automaton provides locations for variables.
The automaton must return unsplit locations.
In the variable placer, we rely on this guarantee; for an automaton used in calling
conventions, we have no such guarantees.
<<placevar.ml>>=
<<define context count structures>>
let context autmtn _ ({ Proc.cfg = g; Proc.target = tgt; Proc.formals = formals
                      ; Proc.varMap = tMap} as proc) =
  let changed = ref false in
  let autmtn  = autmtn proc in
  <<initialize context count structures>>
  <<get operator contexts>>
  <<estimate exec\_counts for graph nodes>>
  <<count uses in each context>>
  <<choose a context for each variable>>
  <<replace variables with temps>>
  <<freeze [[autmtn]] and make sure its overflow block is empty>>
  <<add variable placements to spans>>
  !changed
@
For each variable, we keep track of how many times it is used in each context.
We use mutable state to store the counts for each variable, and we keep the records
in an array indexed by the variable number.
<<define context count structures>>=
type counts = { mutable intc   : float
              ; mutable floatc : float
              ; mutable addrc  : float
              ; mutable boolc  : float
              }
@
<<initialize context count structures>>=
let new_count _ = { intc = 0.0; floatc = 0.0; addrc = 0.0; boolc = 0.0}        in
let var_counts = Array.init proc.Proc.vars new_count                           in
let inc_int   i f = let record = var_counts.(i)                                in
                    record.intc <- record.intc +. f                            in
let inc_float i f = let record = var_counts.(i)                                in
                    record.floatc <- record.floatc +. f                        in
let inc_addr  i f = let record = var_counts.(i)                                in
                    record.addrc <- record.addrc +. f                          in
let inc_bool  i f = Error.warningPrt "variable found in boolean context"       in
let inc_rm    i f = Error.warningPrt "variable found in rounding mode context" in
@
A call to [[Context.standard]] returns a list of (operator, parameter list, result)
triples, where the argument list and result tell us in what context the arguments and 
results are expected by the operator.
To speed lookup, we use a map to hold this information.
<<get operator contexts>>=
let ops =
  List.fold_left (fun map (op, parms, res) -> SM.add op (parms, res) map)
                 SM.empty (Context.standard inc_int inc_float inc_rm inc_addr inc_bool) in
let ctxt_parms  op = try Some (fst (SM.find op ops)) with Not_found -> None in
let ctxt_result op = try Some (snd (SM.find op ops)) with Not_found -> None in
@
For now, we don't estimate execution counts; we assume each node is executed once.
<<estimate exec\_counts for graph nodes>>=
let exec_counts      = G.fold_nodes (fun n map -> NM.add n 1.0 map) NM.empty g  in
let get_exec_count n = try NM.find n exec_counts
                       with Not_found -> Impossible.impossible "node not counted" in 
@
We use the execution counts and the table of operator contexts to estimate how many
times each variable is used in each context.
The function [[count]] calls [[count_rtl]] to walk the rtl's and count uses.
<<count uses in each context>>=
let count node =
  <<define counting functions>>
  match G.to_instr node with
  | None   -> ()
  | Some i -> count_rtl i in
let () = G.iter_nodes count g in
@
The function [[count_rtl]] walks an rtl in a top-down fashion, looking for the use of
an operator.
If an operator is found and its argument or result is a variable, we increment the
number of times the variable has been used in its current context (as determined by the
operator).
Counting arguments to an operator is easy (see [[count_exp]]), but counting the result
of the operator requires a special case in [[count_effect]].
<<define counting functions>>=
let rec count_loc loc ctxt = match loc with
  | RP.Mem   (_, _, _, e, _) -> count_exp e (Some inc_addr)
  | RP.Slice (_, _, l)       -> count_loc l ctxt
  | RP.Reg    _              -> ()
  | RP.Var   (_, i, _)       ->
    (match ctxt with
     | None   -> ()
     | Some c -> c i (get_exec_count node))

and count_exp exp ctxt = match exp with
  | RP.Const _        -> ()
  | RP.Fetch (l, _)   -> count_loc l ctxt
  | RP.App ((op, _), exps) ->
    let ctxts = match ctxt_parms op with
                | None    -> List.map (fun s -> None)   exps
                | Some cs -> List.map (fun c -> Some c) cs   in
    List.iter2 count_exp exps ctxts in

let count_effect effect = match effect with
  | RP.Store (l, (RP.App ((op, _), _) as e), _) ->
      (count_exp e None ; count_loc l (ctxt_result op))
  | RP.Store (l, e, _) -> (count_exp e None ; count_loc l None)
  | RP.Kill   l        -> count_loc l None in

let count_guard (exp, effect) = (count_effect effect ; count_exp exp None) in

let rec count_rtl r = match Rtl.Dn.rtl r with
  | RP.Rtl gs -> List.iter count_guard gs in
@
For each variable, we choose the context with the most votes.
The default context is "int".
<<choose a context for each variable>>=
let default_hint = "int" in
let ctxt_map =
  let elect i =
    let cnts = var_counts.(i) in
    let icnt = cnts.intc      in
    let fcnt = cnts.floatc    in
    let acnt = cnts.addrc     in
    let (cnt,ctxt) = if icnt >= fcnt then (icnt,"int") else (fcnt, "float") in
    if cnt >= acnt then ctxt else "address" in
  Array.init proc.Proc.vars elect in
@
To replace a variable, we use the automaton to allocate a new fetch of the variable,
and we extract the location.
The automaton relies on a hint to return an appropriate location.
If the variable is a formal argument with a hint, we use that hint and issue a warning
if it is different from the elected hint.
The function [[choose_hint]] is responsible for detecting and handling formal
arguments.
We do not issue a warning if the elected hint is the default, with zero votes.
<<context replace var>>=
let formal_arr = Array.make proc.Proc.vars None in
let () = List.iter (fun (i,v) -> formal_arr.(i) <- Some v) formals in
let choose_hint i elected_hint = 
  let space_name = function "signed" | "unsigned" | "" -> "int"
                          | n                          -> n     in
  match formal_arr.(i) with
  | Some (Some ("address" as h), _, _, n) when elected_hint = "int" ->
    if tgt.Target.distinct_addr_sp then
      Impossible.unimp "Var placer does not distinguish addr and int spaces"
    else h
  | Some (Some h, _, _, n) when space_name h <> elected_hint ->
    let votes = var_counts.(i) in
    begin
      (if elected_hint <> default_hint || votes.intc <> 0.0 then
        let error_str =
          ( Printf.sprintf 
              "Hint \"%s\" on formal parameter %s differs from inferred hint \"%s\":\n"
              h n elected_hint
          ^ Printf.sprintf "  {int: %f, float: %f, addr: %f}"
                           votes.intc votes.floatc votes.addrc) in
        Error.warningPrt error_str);
      h
    end
  | _ -> elected_hint in
  
let get_placer i w =
  match tMap.(i) with
  | Some a -> a
  | None   -> let hint = choose_hint i ctxt_map.(i) in
              let alloc = A.allocate autmtn w hint in
              (changed := true;
               tMap.(i) <- Some alloc;
               alloc) in
let store_var exp (s, i, w) = (get_placer i w).A.store (R.Up.exp exp) w in
let fetch_var     (s, i, w) = (get_placer i w).A.fetch                w in
@
We fold over the nodes, replacing variables with each variable with a temp for the
proper context.
We include the functions that replace variables as nested functions in [[updateNode]] so
they will have access to the entire rtl.
<<replace variables with temps>>=
let updateNode node =
  match G.to_instr node with
  | None     -> ()
  | Some rtl ->
    <<context replace var>>
    G.update_instr (fun _ -> replace_var store_var fetch_var rtl) node in
let () = G.iter_nodes updateNode g in
<<verbosely dump [[tMap]]>>
@ 
<<verbosely dump [[tMap]]>>=
let () =
  if Verbose.verbosity > 5 then
    let loc = function
      | None -> "<??none??>"
      | Some l -> RU.ToReadableString.exp (l.A.fetch 99) in
    Verbose.say 6 ["Varmap: Var i -> Loc\n"];
    Array.iteri
      (fun i l -> Verbose.say 6 [Printf.sprintf "  %d -> %s\n" i (loc l)]) tMap in
@
<<freeze [[autmtn]] and make sure its overflow block is empty>>=
let aresult = A.freeze autmtn in
let _ = if Block.size aresult.A.overflow <> 0 then
          Impossible.impossible "nonempty overflow from placing variables" in
@
<<placevar.ml>>=
let ( *> ) = A.( *> )

let from_temps proc space = (* stage to allocate a temporary location *)
  let allocator = Talloc.Multiple.loc proc.Proc.temps space in
  let alloc ~width:w ~alignment:a ~hint:h = A.of_loc (allocator w) in
  A.wrap (fun methods -> {A.allocate = alloc; A.freeze = methods.A.freeze})

let mk_automaton ~warn ~vfp ~memsize ~byteorder mk_stage proc =
  let warn methods =
    let alloc ~width:w ~alignment:a ~hint:h =
      warn ~width:w ~alignment:a ~hint:h;
      methods.A.allocate w a h in
    {A.allocate = alloc; A.freeze = methods.A.freeze} in
  Block.srelative vfp "variables placed in memory" (A.at ~memsize ~byteorder)
  ( A.wrap warn *> mk_stage ~temps:(from_temps proc) *> A.as_stage proc.Proc.priv )
@
After we have placed the variables, we record their locations in the spans.
<<add variable placements to spans>>=
let fold_arri f a z = 
  let l = Array.length a in
  let rec do_fold i z =
    if i < l then do_fold (i+1) (f i (Array.get a i) z)
    else z in
  do_fold 0 z in
let var_spans =
  let vars =
    fold_arri (fun i loc rst -> match loc with None   -> rst
                                             | Some l -> (i,l) :: rst) tMap [] in
  RT.var_asst_to_spans proc vars in
let newspans =
  List.map (fun (l,spans as p) -> if l = proc.Proc.symbol#original_text
                                  then p
                                  else (l, var_spans@spans))
           proc.Proc.spans in
proc.Proc.spans <- newspans;
@
