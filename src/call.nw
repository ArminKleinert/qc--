% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et sts=4
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

%%Grades: C Peripheral Soon

\section{Calling conventions}

\subsection{Discussion}

Here's what needs to be done at various sorts of places in the code.
\begin{itemize}
\item
\emph{Outgoing parameters at a call site}
\begin{enumerate}
\item
Run convention feeding widths/hints and get locations plus block.
(Stack layout must fit block into frame in the right place.)
\item
Provide binding of where stack pointer must be just before the call
instruction. 
\item
Emit conditional assignment to the stack pointer.
The move is required if it will enlarge the stack, and to compute the
condition we must know the direction of stack growth.
For example, if the stack is to point at~$L$ and the stack is growing
down, we emit the conditional assignment 
$\sp>L \rightarrow \sp \gets L$. 
Although the condition mentions the contents of a run-time location
($\sp$), it should be possible to evaluate the condition once late
compile-time constants are known.
It may
help the simplifier to write the condition as as $\sp-L>0$. 
\item
Emit shuffle for putting actuals into locations.
\item
Take locations defined by shuffle and retain them so we can create a
dataflow node asserting that these locations are used by the call.
(Will go on the call's \emph{outgoing} edges for reasons I've
forgotten.) 
\item
Unconditionally set the stack pointer to where it must be.
In the example above, this means $\sp \gets L$.
\end{enumerate}
\item
\emph{Normal return from a call site.}
\begin{enumerate}
\item
Run convention feeding widths/hints and get locations plus block.
(Stack layout must fit block into frame in the right place.)
\item
Provide binding of where stack pointer will be left just after return.
\item
Emit conditional assignment to the stack pointer.
\item
Emit shuffle for putting result locations into LHS variables.
\item
Take locations read during the shuffle and retain them so we can
assert (on the edge out of the call) that these locations are defined
by the call.
\item
Emit assertion node asserting location of stack pointer where left by
callee. 
\end{enumerate}
\item
\emph{Alternate return to a continuation}.
Each continuation will have one entry point for each calling
convention for which it is used as an alternate return continuation.
On this entry point:
\begin{enumerate}
\item
Dataflow node asserting definition of locations in which incoming parameters
are delivered.
\item
Shuffle to move actuals from the conventional locations into their
variables.
\item
Flow into the code following the continuation label.
\end{enumerate}
\item
\emph{Unwind to a continuation}.
If unwound to, a continuation will have an entry point unwinding calls.
On this entry point:
\begin{enumerate}
\item
Dataflow node asserting definition of the variables that are the
continuation's formal parameters.
\item
No shuffling code is needed; it is up to the {\PAL} run-time system to
put parameters in their conventional locations.
\item
Flow into the code following the continuation label.
\end{enumerate}
\item
\emph{Cut to a continuation}.
If cut to, a continuation will have an entry point that goes into the
PC/SP pair that represents the continuation.
On this entry point:
\begin{enumerate}
\item
Run convention feeding widths/hints and get locations plus block.
(Stack layout must fit block into frame in the right place.)
\item
Provide binding of where stack pointer must be just before the call
instruction.  (????? senseless?????)
\item
Emit shuffle for putting actuals into locations.
\item
Take locations defined by shuffle and retain them so we can create a
dataflow node asserting that these locations are used by the call.
(Will go on the call's \emph{outgoing} edges for reasons I've
forgotten.) 
\item
Set stack pointer to where it must be.
MORE TO COME.
\end{enumerate}
\end{itemize}
@
\subsection{Interface}
<<call.mli>>=
<<exported type definitions>>
@ 
<<exported type definitions>>=
type hint  = string
type width = int
type types = (hint * width) list

type answer =
  { 
(* locs     : Automaton2.loc list *)  (* where passed values reside *)
    overflow : Block.t              (* includes all locs for values passed in mem *)
(*    ; sploc    : Rtl.exp              (* where sp is required when values are passed *) *)
  ; insp     : Rtl.rtl              (* assign sp := conventional location;
                                       used in assertions entries from calls, cuts *)
  ; regs     : Register.Set.t       (* set of locations defined (used) by partner *)
  ; pre_sp   : Rtl.rtl              (* conditional SP adjustment pre-shuffle *)
  ; shuffle  : Rtl.rtl              (* shuffle parms where they go *)
  ; post_sp  : Rtl.rtl              (* unconditional SP adjustment post-shuffle *)
  }
@ 
<<exported type definitions>>=
type 'a answer' = 'a list -> answer
type outgoing = types -> Rtl.exp       answer'
type incoming = types -> Automaton.loc answer'

type t = (* part of a calling convention *)
  (* we get 4 dual pairs *)
  { call_actuals    : outgoing
  ; prolog          : incoming   (* arg = procedure formals *)
  ; epilog          : outgoing   (* arg = results returned *)
  ; call_results    : incoming   (* normal return cont *)
  ; cut_to_actuals  : Rtl.exp -> outgoing  
       (* exp is continuation val; used to address overflow block *)
  ; also_cuts_to    : incoming
  ; return_actuals  : outgoing
  ; also_returns_to : incoming

  ; stack_growth : Memalloc.growth
(*    ; sp : Rtl.loc                      (* stack pointer *)  *)
  ; sp_align        : int             (* alignment of stack pointer at call/cut *)
  ; ra : Rtl.loc                      (* where return address is on entry *)
  ; nvregs : Register.Set.t           (* registers preserved across calls *)
  ; volregs: Register.Set.t           (* registers not preserved across calls *)
  ; saved_nvr : Talloc.Multiple.t -> Register.t -> Rtl.loc (* where to save a NVR *)
  ; cutto  :  Mflow.cut_args Target2.map    (* newpc * newsp map*)
  ; saved_ra  : Talloc.Multiple.t -> Rtl.loc (* where to save the return address *)
  ; return : int -> int -> ra:Rtl.exp -> Rtl.rtl    (* alternate return *)
(*  ; alt_return_table : node list -> node *)
  ; stack_layout : unit
  } 

@ 
We have the beginnings of an implementation that computes incoming and
outgoing stuff.  The [[relative_to]] parameter is pure hell and not obvious
to the amateur.  The [[postsp]] parameter is a bit tricky too.
<<call.mli>>=
val outgoing : growth:Memalloc.growth -> sp:Rtl.loc -> spec:(Rtl.exp -> Automaton.t) ->
     autosp:(Automaton.result -> Rtl.exp) ->
     postsp:(Rtl.exp -> Rtl.exp) -> relative_to:Rtl.exp -> outgoing
val incoming : growth:Memalloc.growth -> sp:Rtl.loc -> spec:(Rtl.exp -> Automaton.t) ->
     autosp:(Automaton.result -> Rtl.exp) ->
     postsp:(Rtl.exp -> Rtl.exp) -> relative_to:Rtl.exp -> incoming
@ 
\subsection{Implementation}

A consummation most devoutly to be wished.
<<call.ml>>=
module A  = Automaton
module R  = Rtl
module RS = Register.Set
module RU = Rtlutil
<<exported type definitions>>
@ 
<<call.ml>>=
let ignore r s = s

let too_small growth sp target =
  let w = RU.Width.loc sp in
  let ( >* ) x y = R.app (R.opr "gt" [w]) [x; y] in
  let ( <* ) x y = R.app (R.opr "lt" [w]) [x; y] in
  match growth with
  | Memalloc.Down -> RU.fetch sp >* target
  | Memalloc.Up   -> RU.fetch sp <* target

let outgoing ~growth ~sp ~spec ~autosp ~postsp ~relative_to types actuals =
    let a = spec relative_to in
    let crank effects' (h, w) actual =
      let l = A.allocate a w h in
      A.store l actual w :: effects' in
    let shuffle = R.par (List.rev (List.fold_left2 crank [] types actuals)) in
    let a = A.freeze a in
    let autosp = autosp a in
    let postsp = postsp autosp in
    let setsp  = RU.store sp postsp in
    let no r s = s in
    { overflow = a.A.overflow
    ; insp     = RU.store sp autosp
    ; regs     = RU.ReadWriteKill.fold ~read:RS.add ~write:no ~kill:no shuffle RS.empty
    ; shuffle  = shuffle
    ; post_sp  = setsp
    ; pre_sp   = R.guard (too_small growth sp postsp) setsp
    }

let incoming ~growth ~sp ~spec ~autosp ~postsp ~relative_to types formals =
    let a = spec relative_to in
    let crank effects' (h, w) formal =
      let l = A.allocate a w h in
      A.store formal (A.fetch l w) w :: effects' in
    let shuffle = R.par (List.rev (List.fold_left2 crank [] types formals)) in
    let a = A.freeze a in
    let autosp = autosp a in
    let postsp = postsp autosp in
    let setsp  = RU.store sp postsp in
    let no r s = s in
    { overflow = a.A.overflow
    ; insp     = RU.store sp autosp
    ; regs     = RU.ReadWriteKill.fold ~write:RS.add ~read:no ~kill:no shuffle RS.empty
    ; shuffle  = shuffle
    ; post_sp  = setsp
    ; pre_sp   = R.guard (too_small growth sp postsp) setsp
    }
@ 

