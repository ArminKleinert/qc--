% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et sts=4
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

%%Grades: C Peripheral Soon

\section{Calling conventions}

\subsection{Discussion}

Here's what needs to be done at various sorts of places in the code.
\begin{itemize}
\item
\emph{Outgoing parameters at a call site}
\begin{enumerate}
\item
Run convention feeding widths/hints and get locations plus block.
(Stack layout must fit block into frame in the right place.)
\item
Provide binding of where stack pointer must be just before the call
instruction. 
\item
Emit conditional assignment to the stack pointer.
The move is required if it will enlarge the stack, and to compute the
condition we must know the direction of stack growth.
For example, if the stack is to point at~$L$ and the stack is growing
down, we emit the conditional assignment 
$\sp>L \rightarrow \sp \gets L$. 
Although the condition mentions the contents of a run-time location
($\sp$), it should be possible to evaluate the condition once late
compile-time constants are known.
It may
help the simplifier to write the condition as as $\sp-L>0$. 
\item
Emit shuffle for putting actuals into locations.
\item
Take locations defined by shuffle and retain them so we can create a
dataflow node asserting that these locations are used by the call.
(Will go on the call's \emph{outgoing} edges for reasons I've
forgotten.) 
\item
Unconditionally set the stack pointer to where it must be.
In the example above, this means $\sp \gets L$.
\end{enumerate}
\item
\emph{Normal return from a call site.}
\begin{enumerate}
\item
Run convention feeding widths/hints and get locations plus block.
(Stack layout must fit block into frame in the right place.)
\item
Provide binding of where stack pointer will be left just after return.
\item
Emit conditional assignment to the stack pointer.
\item
Emit shuffle for putting result locations into LHS variables.
\item
Take locations read during the shuffle and retain them so we can
assert (on the edge out of the call) that these locations are defined
by the call.
\item
Emit assertion node asserting location of stack pointer where left by
callee. 
\end{enumerate}
\item
\emph{Alternate return to a continuation}.
Each continuation will have one entry point for each calling
convention for which it is used as an alternate return continuation.
On this entry point:
\begin{enumerate}
\item
Dataflow node asserting definition of locations in which incoming parameters
are delivered.
\item
Shuffle to move actuals from the conventional locations into their
variables.
\item
Flow into the code following the continuation label.
\end{enumerate}
\item
\emph{Unwind to a continuation}.
If unwound to, a continuation will have an entry point unwinding calls.
On this entry point:
\begin{enumerate}
\item
Dataflow node asserting definition of the variables that are the
continuation's formal parameters.
\item
No shuffling code is needed; it is up to the {\PAL} run-time system to
put parameters in their conventional locations.
\item
Flow into the code following the continuation label.
\end{enumerate}
\item
\emph{Cut to a continuation}.
If cut to, a continuation will have an entry point that goes into the
PC/SP pair that represents the continuation.
On this entry point:
\begin{enumerate}
\item
Run convention feeding widths/hints and get locations plus block.
(Stack layout must fit block into frame in the right place.)
\item
Provide binding of where stack pointer must be just before the call
instruction.  (????? senseless?????)
\item
Emit shuffle for putting actuals into locations.
\item
Take locations defined by shuffle and retain them so we can create a
dataflow node asserting that these locations are used by the call.
(Will go on the call's \emph{outgoing} edges for reasons I've
forgotten.) 
\item
Set stack pointer to where it must be.
MORE TO COME.
\end{enumerate}
\end{itemize}
@
\subsection{Interface}
<<call.mli>>=
<<exported type definitions>>
@ 
<<exported type definitions>>=
type hint  = string
type width = int
type types = (hint * width) list

type 'insp answer =
  { 
(* locs     : Automaton2.loc list *)  (* where passed values reside *)
    overflow : Block.t              (* includes all locs for values passed in mem *)
(*    ; sploc    : Rtl.exp              (* where sp is required when values are passed *) *)
  ; insp     : 'insp                (* assign sp := conventional location;
                                       used in assertions entries from calls, cuts *)
  ; regs     : Register.Set.t       (* set of locations defined (used) by partner *)
  ; pre_sp   : Rtl.rtl              (* conditional SP adjustment pre-shuffle *)
  ; shuffle  : Rtl.rtl              (* shuffle parms where they go *)
  ; post_sp  : Rtl.rtl              (* unconditional SP adjustment post-shuffle *)
  }
@ 
<<exported type definitions>>=
type outgoing = types -> Rtl.exp       list -> unit    answer
type incoming = types -> Automaton.loc list -> Rtl.rtl answer
type ('inc, 'out) pair' = { in' : 'inc ; out : 'out }
type pair     = (incoming, outgoing)              pair'
type cut_pair = (incoming, (Rtl.exp -> outgoing)) pair'

type t = (* part of a calling convention *)
  (* we get 3 dual pairs *)
  { name          : string   (* canonical name of this cc *)
  ; jump_ok       : bool     (* does it support tail calls? *)
  ; call_parms    : pair
  ; results       : pair
  ; cut_parms     : cut_pair
       (* exp is continuation val; used to address overflow block *)
                  
  ; stable_sp_loc : Rtl.exp
       (* address where sp points after prolog, sits between calls,
          and should be set to on arrival at a continuation *)

  ; stack_growth  : Memalloc.growth
  ; sp_align      : int             (* alignment of stack pointer at call/cut *)
  ; ra            : Rtl.loc                      (* where return address is on entry *)
  ; pre_nvregs    : Register.Set.t           (* registers preserved across calls *)
  ; volregs       : Register.Set.t           (* registers not preserved across calls *)
  ; saved_nvr     : Talloc.Multiple.t -> Register.t -> Rtl.loc (* where to save NVR *)
  ; saved_ra      : Talloc.Multiple.t -> Rtl.loc (* where to save the return address *)
  ; return        : int -> int -> ra:Rtl.exp -> Rtl.rtl    (* alternate return *)
(*  ; alt_return_table : node list -> node *)
  (* these next two encapsulate knowledge of which reg. is sp *)
  ; replace_vfp   : Rtl.rtl Cfgx.M.cfg -> unit
  ; cutto         : Mflow.cut_args Target2.map    (* newpc * newsp map*)
  } 
@ N.B. the [[pre_nvregs]] are all possible nonvolatile registers.
The actual nonvolatile registers are those [[pre_nvregs]] that are not
used for parameters.
@
We have the beginnings of an implementation that computes incoming and
outgoing stuff.  The [[relative_to]] parameter is pure hell and not obvious
to the amateur.  The [[postsp]] parameter is a bit tricky too.
<<call.mli>>=
val outgoing :
     growth:Memalloc.growth -> sp:Rtl.loc -> mkauto:valpass ->
     autosp:(Automaton.result -> Rtl.exp) ->
     postsp:(Rtl.exp -> Rtl.exp) -> outgoing
val incoming : 
     growth:Memalloc.growth -> sp:Rtl.loc -> mkauto:valpass ->
     autosp:(Automaton.result -> Rtl.exp) ->
     postsp:(Rtl.exp -> Rtl.exp) -> incoming
<<exported type definitions>>=
type valpass = unit -> Automaton.implementation
@ 
\subsection{Implementation}

A consummation most devoutly to be wished.
<<call.ml>>=
module A  = Automaton
module R  = Rtl
module RS = Register.Set
module RU = Rtlutil
<<exported type definitions>>
@ 
<<call.ml>>=
let ignore r s = s

let too_small growth sp target =
  let w = RU.Width.loc sp in
  let ( >* ) x y = R.app (R.opr "gt" [w]) [x; y] in
  let ( <* ) x y = R.app (R.opr "lt" [w]) [x; y] in
  match growth with
  | Memalloc.Down -> RU.fetch sp >* target
  | Memalloc.Up   -> RU.fetch sp <* target

let ne sp target = R.app (R.opr "ne" [RU.Width.loc sp]) [RU.fetch sp; target]

let outgoing ~growth ~sp ~mkauto ~autosp ~postsp types actuals =
    let a = A.mk (mkauto ()) in
    let crank effects' (h, w) actual =
      let l = A.allocate a w h in
      A.store l actual w :: effects' in
    let shuffle = R.par (List.rev (List.fold_left2 crank [] types actuals)) in
    let a = A.freeze a in
    let autosp = autosp a in
    let postsp = postsp autosp in
    let setsp  = RU.store sp postsp in
    let no r s = s in
    { overflow = a.A.overflow
    ; insp     = ()
    ; regs     = a.A.regs_used
    ; shuffle  = shuffle
    ; post_sp  = R.guard (ne sp postsp)               setsp
    ; pre_sp   = R.guard (too_small growth sp postsp) setsp
    }

let incoming ~growth ~sp ~mkauto ~autosp ~postsp types formals =
    let a = A.mk (mkauto()) in
    let crank effects' (h, w) formal =
      let l = A.allocate a w h in
      A.store formal (A.fetch l w) w :: effects' in
    let shuffle = R.par (List.rev (List.fold_left2 crank [] types formals)) in
    let a = A.freeze a in
    let autosp = autosp a in
    let postsp = postsp autosp in
    let setsp  = RU.store sp postsp in
    let no r s = s in
    { overflow = a.A.overflow
    ; insp     = RU.store sp autosp
    ; regs     = a.A.regs_used
    ; shuffle  = shuffle
    ; post_sp  = R.guard (ne sp postsp)               setsp
    ; pre_sp   = R.guard (too_small growth sp postsp) setsp
    }
@ 

