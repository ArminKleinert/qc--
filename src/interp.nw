% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% ------------------------------------------------------------------ 
\section{The Interpreter Target}
% ------------------------------------------------------------------ 

This module defines a back end for the {\PAL} interpreter in directory
[[../interp]]. 

<<interp.mli>>=
val target':    Ast2ir.tgt
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<interp.ml>>=
let arch        = "interp"
let byte_order  = Rtl.LittleEndian       (* byte order *)
let wordsize    = 32
let pointersize = wordsize
@

The interpreter at the moment knows only the memory space [[m]].  We use
in {\rtl}s the [[C]] space to encode jumps, gotos, and the like.
However, these {\rtl}s never reach the interpreter but are recognized
and translated to control-flow instructions the interpreter knows.

<<interp.ml>>=
module AN     = Automaton
module SS32   = Space.Standard32
module T      = Target
module D      = Rtl.Dn  (* Down *)
module U      = Rtl.Up  (* Up   *)
module R      = Rtl
module RP     = Rtl.Private
module RU     = Rtlutil
module C      = Call
module RS     = Register.Set

let downrtl = R.Dn.rtl
let uploc   = R.Up.loc
let upexp   = R.Up.exp

module Spaces = struct
    let m   = SS32.m   byte_order    [8; 16; 32]
    let c   = Space.checked
                { Space.space          = 'c'
                ; Space.doc            = "control registers"
                ; Space.cellwidth      = wordsize
                ; Space.indexwidth     = 2 
                ; Space.indexlimit     = Some 4 (* pc, sp, ap, ra *)
                ; Space.aggregation    = Rtl.Identity
                ; Space.widths         = [32]
                ; Space.classification = Space.Reg
                } 
    let a   = Space.checked
                { Space.space          = 'A'
                ; Space.doc            = "argument passing area"
                ; Space.cellwidth      = 1  (* hack *)
                ; Space.indexwidth     = wordsize
                ; Space.indexlimit     = None
                ; Space.aggregation    = byte_order
                ; Space.widths         = [8;16;32]
                ; Space.classification = Space.Mem
                }
    let g   = Space.checked
                { Space.space          = 'G'
                ; Space.doc            = "global register variables"
                ; Space.cellwidth      = 1  (* hack *)
                ; Space.indexwidth     = wordsize
                ; Space.indexlimit     = None
                ; Space.aggregation    = byte_order
                ; Space.widths         = [8;16;32]
                ; Space.classification = Space.Mem
                }
    let d   = Space.checked
                { Space.space          = 'd'
                ; Space.doc            = "FP rounding mode"
                ; Space.cellwidth      = 2  
                ; Space.indexwidth     = 1
                ; Space.indexlimit     = Some 2
                ; Space.aggregation    = Rtl.Identity
                ; Space.widths         = [2]
                ; Space.classification = Space.Reg
                }
end
@

% ------------------------------------------------------------------ 
\subsection{Registers}
% ------------------------------------------------------------------ 

<<interp.ml>>=
let pc:Rtl.loc            = Rtl.reg ('c',0, wordsize)  (* pc pointer     *)
let sp:Rtl.loc            = Rtl.reg ('c',1, wordsize)  (* stack pointer  *)
let ap:Rtl.loc            = Rtl.reg ('c',2, wordsize)  (* arg pointer    *)
let ra:Rtl.loc            = Rtl.reg ('c',3, wordsize)  (* return address *)

let arg_reg  x            = ('A', x, 1)
let glb_reg  x            = ('G', x, 1)
let argument x            = R.reg (arg_reg x)          (* arguments *) 
let global   x            = R.reg (glb_reg x)          (* globals   *) 

let fp_mode               = Rtl.reg('d',0,2)           (* FP rounding mode *) 
let spval                 = Rtl.fetch sp wordsize
let vfp                   = Vfp.mk wordsize          
let std_sp_location       = vfp
let std_sp_location       = RU.add pointersize 
                             vfp (R.late "minus frame size" pointersize)
@
                
% ------------------------------------------------------------------ 
\subsection{Control Flow and Instructions}
% ------------------------------------------------------------------ 

Module [[Flow]]  provides us with {\rtl}s that encode control transfer.
They are part of the [[target]] value that describes this target
completely. \emph{The encoding of control transfers and other special
instructions is shared with the recognizer.}

<<interp.ml>>=
module Flow = struct
    <<module Flow>>
end
@ 
THESE REGISTER ASSIGNMENTS MISUSE THE STANDARD [['c']] SPACE.
ANOTHER SPACE SHOULD BE CHOSEN.
<<module Flow>>=
let ewidth                = RU.Width.exp 
let lwidth                = RU.Width.loc 
@

We are now defining instructions that model instructions in the
interpreter. First, we define some helper functions that allow to define
these instructions more easily.

<<module Flow>>=
let fetch loc     = R.fetch loc wordsize        
let store loc e   = R.store loc e wordsize        
let add           = RU.add  wordsize
let addk          = RU.addk wordsize
let sub           = R.opr "sub" [wordsize]
let add1 loc      = addk (fetch loc) 1
let sub1 loc      = R.app sub [ fetch loc
                            ; R.bits (Bits.S.of_int 1 wordsize) wordsize]
let inc loc       = R.store loc (add1 loc) wordsize
let dec loc       = R.store loc (sub1 loc) wordsize
let error         = Impossible.impossible
@

For most control-flow related {\rtl}s, [[Target.t]] demands we provide
embedding and projection functions. \emph{As far as I can tell the
projections are never used and we could simplify [[Target.t]].}

<<module Flow>>=
let bnegate _ = Impossible.unimp "bnegate not implemented"
let goto = 
    { T.embed   = (fun e -> store pc e)
    ; T.project = (fun r -> match D.rtl r with
                  | RP.Rtl [(_, RP.Store(_, e, _))] -> U.exp e
                  | _ -> error "projected non-goto"
                  )
    }
    
let cutto =
    { T.embed   = (fun {Mflow.new_pc=newpc; Mflow.new_sp= newsp} ->
                        let assign loc e =
                            Rtl.store loc e (Rtlutil.Width.exp e) in
                        Rtl.par [assign sp newsp; assign pc newpc])
     ; T.project = (fun r -> match downrtl r with
                      | RP.Rtl [ (_, RP.Store(_, nsp, _))
                               ; (_, RP.Store(_ , npc, _))] ->
                        {Mflow.new_sp=upexp nsp; Mflow.new_pc= upexp npc}
                      | _ -> Impossible.impossible "projected non-cutto")
     }
let call = 
    { T.embed   = (fun e -> R.par [store ra (fetch pc); store pc e])
    ; T.project = (fun r -> match D.rtl r with
                  | RP.Rtl [_;(_,RP.Store(_,e,_))] -> U.exp e
                  | _ -> error "projected non-call"
                  )
    }              

let branch =
    { T.embed   = (fun (c, l) -> R.guard c (goto.T.embed l))
    ; T.project = (fun r      -> match D.rtl r with
                  | RP.Rtl [(c, (RP.Store(_,e,_)))] -> (U.exp c, U.exp e)
                  | _ -> error "projected non-branch"
                  )
    }              

let jump   = goto                   (* must be different from goto!  *)
let cutto  = cutto
let return = store pc (fetch ra)    (* no embed/project needed *)
@

We use helper functions [[store_space]] and [[fetch_space]] to store or
fetch a value in a register-like space, given a function [[spc]] that takes
an index and returns a register location.

<<module Flow>>=
let store_space spc i e = R.store (spc i) e (ewidth e)
let fetch_space spc i w = R.fetch (spc i) w
@

% ------------------------------------------------------------------ 
\subsection{Automata for Calling Conventions and Globals}
% ------------------------------------------------------------------ 

Our automata hand out \rtl-based locations. We simply need to wrap them
such that they become [[Automaton.loc]] locations. [[loc_of]] takes an
{\rtl} location and returns an [[Automaton.loc]] location.

<<interp.ml>>=
let loc_of (l:Rtl.loc): AN.loc  =
    { AN.fetch = (Rtl.fetch l)
    ; AN.store = (Rtl.store l)
    }
@

The interpreter hands out registers for globals and arguments, assuming
that we have an endless supply for each. We have just one automaton
[[seq]] that does this. It is parameterized over a function [[reg]]
that supplies the register.
<<interp.ml>>=
let seq (reg: int -> Register.t) next =
    let index = ref (-1)                  in
    let regs  = ref ([]: Register.t list) in
    let allocate ~width ~alignment ~hint =
        ( index := !index + 1
        ; regs  := (reg !index) :: !regs
        ; loc_of (Rtl.reg (reg !index))
        ) in
    let freeze rs mems =
        next.AN.freeze (RS.union (RS.of_list (!regs)) rs) mems in
    { AN.allocate = allocate
    ; AN.freeze   = freeze
    }
let seq reg = AN.wrap (seq reg)

let params      = seq arg_reg               (* for parameters  *)
let globls base = AN.at base (seq glb_reg)  (* for global regs *)
@

% ------------------------------------------------------------------ 
\subsection{Calling Conventions}
% ------------------------------------------------------------------ 

Allmost every aspects of the calling convention is irrelevant because the
interpreter does not work like a CPU. 

I have to admit, that I don't know what I am doing here.

<<transformations>>=
let call_actuals  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out call parms" AN.at params) 
    ~autosp:(fun r  -> Block.base r.AN.overflow)
    ~postsp:(fun _ sp -> sp) in  

let prolog  =
  let autosp = (fun _ -> vfp) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in call parms" AN.at params)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a) in

let call_results  =
  let autosp = (fun r -> Block.base r.AN.overflow) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" AN.at params)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a) in

let epilog  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" AN.at params)
    ~autosp:(fun r -> Block.base r.AN.overflow)
    ~postsp:(fun _ _ -> vfp) in

let also_cuts_to =
  let autosp = (fun r -> std_sp_location) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in cont parms" AN.at params)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a) in

let cut_actuals base  =
   C.outgoing ~growth ~sp ~mkauto:(fun () -> AN.at base params)
     ~autosp:(fun r -> spval)
     ~postsp:(fun _ _ -> spval) in


<<interp.ml>>=
let cc' = (* new style *)
    let growth = Memalloc.Down            in (* irrelevant *) 
    <<transformations>>
    { C.name             = "interp"
    ; C.overflow_alloc  = { C.parameter_deallocator = C.Callee
                          ; C.result_allocator      = C.Caller
                          }
    ; C.call_parms       = { C.in' = prolog;       C.out = call_actuals}
    ; C.cut_parms        = { C.in' = also_cuts_to; C.out = cut_actuals}
    ; C.results          = { C.in' = call_results; C.out = epilog}
 
    ; C.stack_growth     = growth
    ; C.stable_sp_loc    = std_sp_location
    ; C.replace_vfp      = Cfgx.Vfp.replace_with ~sp
    ; C.sp_align         = 1             
    ; C.pre_nvregs       = Register.Set.empty
    ; C.volregs          = Register.Set.empty
    ; C.saved_nvr        = (fun _ _ -> Impossible.impossible "saved regs")
    ; C.cutto            = Flow.cutto
    ; C.return           = (fun k n ~ra -> Flow.return)
    ; C.ra_on_entry      = (fun _     -> R.fetch ra wordsize)
    ; C.where_to_save_ra = (fun _ t   -> ra)
    ; C.ra_on_exit       = (fun t b _ -> ra)
    ; C.sp_on_jump       = (fun _ _ -> Rtl.null)
    }
@



% ------------------------------------------------------------------ 
\subsection{Target Value}
% ------------------------------------------------------------------ 

The [[target]] value is the essential information for the rest of the
compiler.

<<interp.ml>>=
let target' = (* new style *)
      { T.name = arch
      ; T.cc =           (fun _ -> cc') 
      ; T.byteorder         = byte_order
      ; T.wordsize          = wordsize
      ; T.pointersize       = wordsize
      ; T.vfp               = Vfp.mk wordsize
      ; T.alignment         = 1
      ; T.memsize           = 8
      ; T.float             = "ieee754"
      ; T.charset           = "latin1" 
      ; T.globals           = globls
      ; T.rounding_mode     = fp_mode
      ; T.named_locs        = Strutil.assoc2map 
                                ["IEEE 754 rounding mode", fp_mode
                                ]

      ; T.spaces            = [ Spaces.m ; Spaces.c ;  Spaces.a ; Spaces.g ]
      ; T.data_section      = "data"
      ; T.bnegate           = Flow.bnegate
      ; T.goto              = Flow.goto
      ; T.jump              = Flow.jump
      ; T.call              = Flow.call 
      ; T.branch            = Flow.branch
      ; T.spill             = (fun _ -> assert false)
      ; T.reload            = (fun _ -> assert false)
      }
@

