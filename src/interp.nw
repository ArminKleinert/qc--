% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% ------------------------------------------------------------------ 
\section{The Interpreter Target}
% ------------------------------------------------------------------ 

This module defines a back end for the {\PAL} interpreter in directory
[[../interp]]. 

<<interp.mli>>=
val target:     Target2.t
val target':    Ast2ir.tgt
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<interp.ml>>=
let arch        = "interp"
let byte_order  = Rtl.LittleEndian       (* byte order *)
let wordsize    = 32
let pointersize = wordsize
@

The interpreter at the moment knows only the memory space [[m]].  We use
in {\rtl}s the [[C]] space to encode jumps, gotos, and the like.
However, these {\rtl}s never reach the interpreter but are recognized
and translated to control-flow instructions the interpreter knows.

<<interp.ml>>=
module A      = Automaton2
module AN     = Automaton
module SS32   = Space.Standard32
module T      = Target2
module D      = Rtl.Dn  (* Down *)
module U      = Rtl.Up  (* Up   *)
module R      = Rtl
module RP     = Rtl.Private
module RU     = Rtlutil
module C      = Call
module RS     = Register.Set

let downrtl = R.Dn.rtl
let uploc   = R.Up.loc
let upexp   = R.Up.exp

module Spaces = struct
    let m   = SS32.m   byte_order    [8; 16; 32]
    let c   = Space.checked
                { Space.space          = 'c'
                ; Space.doc            = "control registers"
                ; Space.cellwidth      = wordsize
                ; Space.indexwidth     = 2 
                ; Space.indexlimit     = Some 4 (* pc, sp, ap, ra *)
                ; Space.aggregation    = Rtl.Identity
                ; Space.widths         = [32]
                ; Space.classification = Space.Reg
                } 
    let a   = Space.checked
                { Space.space          = 'A'
                ; Space.doc            = "argument passing area"
                ; Space.cellwidth      = 1  (* hack *)
                ; Space.indexwidth     = wordsize
                ; Space.indexlimit     = None
                ; Space.aggregation    = byte_order
                ; Space.widths         = [8;16;32]
                ; Space.classification = Space.Mem
                }
    let g   = Space.checked
                { Space.space          = 'G'
                ; Space.doc            = "global register variables"
                ; Space.cellwidth      = 1  (* hack *)
                ; Space.indexwidth     = wordsize
                ; Space.indexlimit     = None
                ; Space.aggregation    = byte_order
                ; Space.widths         = [8;16;32]
                ; Space.classification = Space.Mem
                }
    let d   = Space.checked
                { Space.space          = 'd'
                ; Space.doc            = "FP rounding mode"
                ; Space.cellwidth      = 2  
                ; Space.indexwidth     = 1
                ; Space.indexlimit     = Some 2
                ; Space.aggregation    = Rtl.Identity
                ; Space.widths         = [2]
                ; Space.classification = Space.Reg
                }
                
    (* these are never used, but Ast2IR expects to find a temp space *)
    let r = Space.Standard32.r 32 Rtl.Identity [32]
    let t = Space.Standard32.t    Rtl.Identity [32]
end
@

% ------------------------------------------------------------------ 
\subsection{Registers}
% ------------------------------------------------------------------ 

<<interp.ml>>=
let pc:Rtl.loc            = Rtl.reg ('c',0, wordsize)  (* pc pointer     *)
let sp:Rtl.loc            = Rtl.reg ('c',1, wordsize)  (* stack pointer  *)
let ap:Rtl.loc            = Rtl.reg ('c',2, wordsize)  (* arg pointer    *)
let ra:Rtl.loc            = Rtl.reg ('c',3, wordsize)  (* return address *)

let arg_reg  x            = ('A', x, 1)
let glb_reg  x            = ('G', x, 1)
let argument x            = R.reg (arg_reg x)          (* arguments *) 
let global   x            = R.reg (glb_reg x)          (* globals   *) 

let fp_mode               = Rtl.reg('d',0,2)           (* FP rounding mode *) 
let spval                 = Rtl.fetch sp wordsize
let vfp                   = Vfp.mk wordsize          
let std_sp_location       = RU.add pointersize 
                            vfp (R.late "minus frame size" pointersize)
@
                
% ------------------------------------------------------------------ 
\subsection{Control Flow and Instructions}
% ------------------------------------------------------------------ 

Module [[Flow]]  provides us with {\rtl}s that encode control transfer.
They are part of the [[target]] value that describes this target
completely. \emph{The encoding of control transfers and other special
instructions is shared with the recognizer.}

<<interp.ml>>=
module Flow = struct
    <<module Flow>>
end
@ 
THESE REGISTER ASSIGNMENTS MISUSE THE STANDARD [['c']] SPACE.
ANOTHER SPACE SHOULD BE CHOSEN.
<<module Flow>>=
let ewidth                = RU.Width.exp 
let lwidth                = RU.Width.loc 
@

We are now defining instructions that model instructions in the
interpreter. First, we define some helper functions that allow to define
these instructions more easily.

<<module Flow>>=
let fetch loc     = R.fetch loc wordsize        
let store loc e   = R.store loc e wordsize        
let add           = RU.add  wordsize
let addk          = RU.addk wordsize
let sub           = R.opr "sub" [wordsize]
let add1 loc      = addk (fetch loc) 1
let sub1 loc      = R.app sub [ fetch loc
                            ; R.bits (Bits.S.of_int 1 wordsize) wordsize]
let inc loc       = R.store loc (add1 loc) wordsize
let dec loc       = R.store loc (sub1 loc) wordsize
let error         = Impossible.impossible
@

For most control-flow related {\rtl}s, [[Target2.t]] demands we provide
embedding and projection functions. \emph{As far as I can tell the
projections are never used and we could simplify [[Target2.t]].}

<<module Flow>>=
let bnegate _ = Impossible.unimp "bnegate not implemented"
let goto = 
    { T.embed   = (fun e -> store pc e)
    ; T.project = (fun r -> match D.rtl r with
                  | RP.Rtl [(_, RP.Store(_, e, _))] -> U.exp e
                  | _ -> error "projected non-goto"
                  )
    }
    
let cutto =
    { T.embed   = (fun {Mflow.new_pc=newpc; Mflow.new_sp= newsp} ->
                        let assign loc e =
                            Rtl.store loc e (Rtlutil.Width.exp e) in
                        Rtl.par [assign sp newsp; assign pc newpc])
     ; T.project = (fun r -> match downrtl r with
                      | RP.Rtl [ (_, RP.Store(_, nsp, _))
                               ; (_, RP.Store(_ , npc, _))] ->
                        {Mflow.new_sp=upexp nsp; Mflow.new_pc= upexp npc}
                      | _ -> Impossible.impossible "projected non-cutto")
     }
let call = 
    { T.embed   = (fun e -> R.par [store ra (fetch pc); store pc e])
    ; T.project = (fun r -> match D.rtl r with
                  | RP.Rtl [_;(_,RP.Store(_,e,_))] -> U.exp e
                  | _ -> error "projected non-call"
                  )
    }              

let branch =
    { T.embed   = (fun (c, l) -> R.guard c (goto.T.embed l))
    ; T.project = (fun r      -> match D.rtl r with
                  | RP.Rtl [(c, (RP.Store(_,e,_)))] -> (U.exp c, U.exp e)
                  | _ -> error "projected non-branch"
                  )
    }              

let jump   = goto                   (* must be different from goto!  *)
let cutto  = cutto
let return = store pc (fetch ra)    (* no embed/project needed *)
@

What do the two instructions below? I realize then have to do with 
fetching and storing values in the global and local register sets.
Please explain the [[sp]] paramter. --CL

<<module Flow>>=
let store_space sp i e = R.store (sp i) e (ewidth e)
let fetch_space sp i w = R.fetch (sp i) w
@

% ------------------------------------------------------------------ 
\subsection{Automata}
% ------------------------------------------------------------------ 

<<interp.ml>>=

class argument_location (index:int): Automaton2.location =
object
    method store expr width = Flow.store_space argument index expr
    method fetch width      = Flow.fetch_space argument index width
end

class arguments (base:Rtl.exp): Automaton2.automaton =
object (this)
    val mutable _block  = Block.at base (*size*) 0 (*align*) 1  
    val mutable _frozen = false

    val mutable _index  = -1
    
    method freeze () =
        let _ = _frozen <- true in
        { A.overflow = _block; A.sp_value = base } 
        (* sp value meaningless to interp *)
    
    method allocate width hint = 
        let ()      = assert (_frozen = false) in          
        match hint with 
        | Some x -> Impossible.impossible ("unknown hardware register "^x) 
        | None   -> ( _index <- _index + 1
                    ; new argument_location _index
                    )
end

class global_location (index:int) (width:int): Automaton2.location =
    let var = 
        let s = Printf.sprintf "global_%d" index in 
        R.var s index width
in object
    method store expr width = Flow.store_space global index expr
    method fetch width      = Flow.fetch_space global index width
end


class globals (base:Rtl.exp): Automaton2.automaton =
object (this)
    val mutable _block  = Block.at base (*size*) 0 (*align*) 1  
    val mutable _frozen = false
    val mutable _index  = -1

    method freeze () =
        let _ = _frozen <- true in
        { A.overflow = _block; A.sp_value = base } 
        (* sp value meaningless to interp *)
    
    method allocate width hint = 
        let ()      = assert (_frozen = false) in          
        match hint with 
        | Some "IEEE 754 rounding mode" -> Automaton2.of_loc fp_mode
        | Some x -> Impossible.impossible ("unknown hardware register "^x) 
        | None   -> ( _index <- _index + 1
                    ; new global_location _index width 
                    )
end
@

% ------------------------------------------------------------------ 
\subsection{Automata for Calling Conventions and Globals}
% ------------------------------------------------------------------ 

Our automata hand out \rtl-based locations. We simply need to wrap them
such that they become [[Automaton.loc]] locations. [[loc_of]] takes an
{\rtl} location and returns an [[Automaton.loc]] location.

<<interp.ml>>=
let loc_of (l:Rtl.loc): AN.loc  =
    { AN.fetch = (Rtl.fetch l)
    ; AN.store = (Rtl.store l)
    }
@

The interpreter hands out registers for globals and arguments, assuming
that we have an endless supply for each. We have just one automaton
[[seq]] that does this. It is parameterized over a function [[reg]]
that supplies the register.
<<interp.ml>>=
let seq (reg: int -> Register.t) next =
    let index = ref (-1)                  in
    let regs  = ref ([]: Register.t list) in
    let allocate ~width ~alignment ~hint =
        ( index := !index + 1
        ; regs  := (reg !index) :: !regs
        ; loc_of (Rtl.reg (reg !index))
        ) in
    let freeze rs mems =
        next.AN.freeze (RS.union (RS.of_list (!regs)) rs) mems in
    { AN.allocate = allocate
    ; AN.freeze   = freeze
    }
let seq reg =
  (AN.wrap (seq reg)) (AN.no_overflow 1 "exhausted infinite register supply!")

let params      = seq arg_reg               (* for parameters  *)
let globls base = AN.at base (seq glb_reg)  (* for global regs *)
@

% ------------------------------------------------------------------ 
\subsection{Calling Conventions}
% ------------------------------------------------------------------ 

Allmost every aspects of the calling convention is irrelevant because the
interpreter does not work like a CPU. 

<<interp.ml>>=
let cc = (* old style *)
    { T.sp           = sp
    ; T.return       = Flow.return
    ; T.proc         = new arguments
    ; T.cont         = new arguments
    ; T.ret          = new arguments
    ; T.allocatable  = []
    ; T.cutto        = Flow.cutto
    ; T.stack_slots  = new globals 
    }
@

I have to admit, that I don't know what I am doing here.

<<transformations>>=
let call_actuals  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out call parms" AN.at params) 
    ~autosp:(fun r  -> Block.base r.AN.overflow)
    ~postsp:(fun sp -> sp) in  

let prolog  =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> AN.at vfp params)
    ~autosp:(fun _ -> vfp)
    ~postsp:(fun _ -> std_sp_location) in

let call_results  =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" AN.at params)
    ~autosp:(fun r -> Block.base r.AN.overflow)
    ~postsp:(fun _ -> std_sp_location) in

let epilog  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" AN.at params)
    ~autosp:(fun r -> Block.base r.AN.overflow)
    ~postsp:(fun _ -> vfp) in

let also_cuts_to =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in cont parms" AN.at params)
    ~autosp:(fun r -> std_sp_location)
    ~postsp:(fun _ -> std_sp_location) in

let cut_actuals base  =
   C.outgoing ~growth ~sp ~mkauto:(fun () -> AN.at base params)
     ~autosp:(fun r -> spval)
     ~postsp:(fun _ -> spval) in


<<interp.ml>>=
let cc' = (* new style *)
    let growth = Memalloc.Down            in (* irrelevant *) 
    <<transformations>>
    { C.name            = "interp"
    ; C.jump_ok         = true
    ; C.call_parms      = { C.in' = prolog;       C.out = call_actuals}
    ; C.cut_parms       = { C.in' = also_cuts_to; C.out = cut_actuals}
    ; C.results         = { C.in' = call_results; C.out = epilog}

    ; C.stack_growth    = growth
    ; C.stable_sp_loc   = std_sp_location
    ; C.replace_vfp     = Cfgx.Vfp.replace_with ~sp
    ; C.sp_align        = 1             
    ; C.pre_nvregs      = Register.Set.empty
    ; C.volregs         = Register.Set.empty
    ; C.saved_nvr       = (fun _ _ -> Impossible.impossible "saved regs")
    ; C.cutto           = Flow.cutto
    ; C.return          = (fun k n ~ra -> Flow.return)
    ; C.ra_on_entry      = (fun _ -> R.fetch ra wordsize)
    ; C.where_to_save_ra = (fun _ t -> Talloc.Multiple.loc t 't' wordsize)
    ; C.ra_on_exit       = (fun t b -> t)
    }
@



% ------------------------------------------------------------------ 
\subsection{Target Value}
% ------------------------------------------------------------------ 

The [[target]] value is the essential information for the rest of the
compiler.

<<interp.ml>>=
let target = (* old style *)
    { T.name = arch
      ; T.cc = (fun _ -> cc) 
      ; T.byteorder    = byte_order
      ; T.wordsize     = wordsize
      ; T.pointersize  = wordsize
      ; T.vfp          = Vfp.mk wordsize
      ; T.alignment    = 1
      ; T.memsize      = 8
      ; T.float        = "ieee754"
      ; T.charset      = "latin1" 
      ; T.globals      = new globals
      ; T.is_rounding_mode = (fun loc -> loc = fp_mode)
      ; T.spaces       = [ Spaces.m ; Spaces.c ;  Spaces.a ; Spaces.g ]
      ; T.data_section = "data"
      ; T.bnegate      = Flow.bnegate
      ; T.goto         = Flow.goto
      ; T.jump         = Flow.jump
      ; T.call         = Flow.call 
      ; T.branch       = Flow.branch
      ; T.spill        = (fun _ -> assert false)
      ; T.reload       = (fun _ -> assert false)
      }

let target' = (* new style *)
      { T.name = arch
      ; T.cc =           (fun _ -> cc') 
      ; T.byteorder    = byte_order
      ; T.wordsize     = wordsize
      ; T.pointersize  = wordsize
      ; T.vfp          = Vfp.mk wordsize
      ; T.alignment    = 1
      ; T.memsize      = 8
      ; T.float        = "ieee754"
      ; T.charset      = "latin1" 
      ; T.globals      = globls
      ; T.is_rounding_mode = (fun loc -> loc = fp_mode)
      ; T.spaces       = [ Spaces.m ; Spaces.c ;  Spaces.a ; Spaces.g ;
                           Spaces.r ; Spaces.t (* bogus *) ]
      ; T.data_section = "data"
      ; T.bnegate      = Flow.bnegate
      ; T.goto         = Flow.goto
      ; T.jump         = Flow.jump
      ; T.call         = Flow.call 
      ; T.branch       = Flow.branch
      ; T.spill        = (fun _ -> assert false)
      ; T.reload       = (fun _ -> assert false)
      }
@

