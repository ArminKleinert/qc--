% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% ------------------------------------------------------------------ 
\section{The Interpreter Target}
% ------------------------------------------------------------------ 

This module defines a back end for the {\PAL} interpreter in directory
[[../interp]]. 

<<interp.mli>>=
val target: Target2.t
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<interp.ml>>=
let arch        = "interp"
let byte_order  = Rtl.LittleEndian       (* byte order *)
let wordsize    = 32
@

The interpreter at the moment knows only the memory space [[m]].  We use
in {\rtl}s the [[C]] space to encode jumps, gotos, and the like.
However, these {\rtl}s never reach the interpreter but are recognized
and translated to control-flow instructions the interpreter knows.

<<interp.ml>>=
module A      = Automaton2
module SS32   = Space.Standard32
module T      = Target2
module D      = Rtl.Convert (* Down *)
module U      = Rtl.Revert  (* Up   *)
module R      = Rtl
module RP     = Rtl.Private
module RU     = Rtlutil

module Spaces = struct
    let m   = SS32.m   byte_order    [8; 16; 32]
    let c   = Space.checked
                { Space.space          = 'c'
                ; Space.doc            = "control registers"
                ; Space.cellwidth      = wordsize
                ; Space.indexwidth     = 2 
                ; Space.indexlimit     = Some 4 (* pc, sp, ap, ra *)
                ; Space.aggregation    = Rtl.Identity
                ; Space.widths         = [32]
                ; Space.classification = Space.Reg
                } 
    let a   = Space.checked
                { Space.space          = 'A'
                ; Space.doc            = "argument passing area"
                ; Space.cellwidth      = 1  (* hack *)
                ; Space.indexwidth     = wordsize
                ; Space.indexlimit     = None
                ; Space.aggregation    = byte_order
                ; Space.widths         = [8;16;32]
                ; Space.classification = Space.Mem
                }
    let g   = Space.checked
                { Space.space          = 'G'
                ; Space.doc            = "global register variables"
                ; Space.cellwidth      = 1  (* hack *)
                ; Space.indexwidth     = wordsize
                ; Space.indexlimit     = None
                ; Space.aggregation    = byte_order
                ; Space.widths         = [8;16;32]
                ; Space.classification = Space.Mem
                }
end
@

Module [[Flow]]  provides us with {\rtl}s that encode control transfer.
They are part of the [[target]] value that describes this target
completely. \emph{The encoding of control transfers and other special
instructions is shared with the recognizer.}

<<interp.ml>>=
module Flow = struct
    <<module Flow>>
end
@ 
THESE REGISTER ASSIGNMENTS MISUSE THE STANDARD [['c']] SPACE.
ANOTHER SPACE SHOULD BE CHOSEN.
<<module Flow>>=
let ewidth                = RU.Width.exp 
let lwidth                = RU.Width.loc 

let pc:Rtl.loc            = Rtl.reg ('c',0, wordsize)  (* pc pointer     *)
let sp:Rtl.loc            = Rtl.reg ('c',1, wordsize)  (* stack pointer  *)
let ap:Rtl.loc            = Rtl.reg ('c',2, wordsize)  (* arg pointer    *)
let ra:Rtl.loc            = Rtl.reg ('c',3, wordsize)  (* return address *)
@

We are now defining instructions that model instructions in the
interpreter. First, we define some helper functions that allow to define
these instructions more easily.

<<module Flow>>=
let fetch loc   = R.fetch loc wordsize        
let store loc e = R.store loc e wordsize        
let add         = RU.add  wordsize
let addk        = RU.addk wordsize
let sub         = R.opr "sub" [wordsize]
let add1 loc    = addk (fetch loc) 1
let sub1 loc    = R.app sub [ fetch loc
                            ; R.bits (Bits.S.of_int 1 wordsize) wordsize]
let inc loc     = R.store loc (add1 loc) wordsize
let dec loc     = R.store loc (sub1 loc) wordsize
let error       = Impossible.impossible
@

For most control-flow related {\rtl}s [[Target2.t]] demands we provide
embedding and projection functions. \emph{As far as I can tell the
projections are never used and we could simplify [[Target2.t]].}

<<module Flow>>=
let goto = 
    { T.embed   = (fun e -> store pc e)
    ; T.project = (fun r -> match D.rtl r with
                  | RP.Rtl [(_, RP.Store(_, e, _))] -> U.exp e
                  | _ -> error "projected non-goto"
                  )
    }
    
let cutto =
    { T.embed   = (fun (sp,newsp,newpc) -> 
                       let assign loc e  =
                           Rtl.store loc e (Rtlutil.Width.exp e) in
                       Rtl.par [assign sp newsp; assign pc newpc])
    ; T.project = (fun r -> match D.rtl r with
                  | RP.Rtl [ (_, RP.Store(sp, nsp, _))
                           ; (_, RP.Store(_ , npc, _))] ->
                       (U.loc sp, U.exp nsp, U.exp npc)
                  | _ -> error "projected non-cutto")
    }

let call = 
    { T.embed   = (fun e -> R.par [store ra (fetch pc); store pc e])
    ; T.project = (fun r -> match D.rtl r with
                  | RP.Rtl [_;(_,RP.Store(_,e,_))] -> U.exp e
                  | _ -> error "projected non-call"
                  )
    }              

let branch =
    { T.embed   = (fun (c, l) -> R.guard c (goto.T.embed l))
    ; T.project = (fun r      -> match D.rtl r with
                  | RP.Rtl [(c, (RP.Store(_,e,_)))] -> (U.exp c, U.exp e)
                  | _ -> error "projected non-branch"
                  )
    }              

let jump   = goto                   (* must be different from goto!  *)
let cutto  = cutto
let return = store pc (fetch ra)    (* no embed/project needed *)
@

We are defining two instructions [[push_arg]] and [[pop_arg]] to
describe the corresponding instructions in the interpreter. The
description is quite inaccurate \emph{and need to be improved.}

\begin{itemize}
\item The instructions in the interpreter take arguments of any width.
      This is not properly reflected in the {\rtl}s defined here. Maybe
      we should use operators.
\item The [[pop_arg]] instruction is not an effect but just an
      expression. The reason is, that the [[Automaton2.location#fetch]]
      method requires to return an expression.
\end{itemize}

<<module Flow>>=
let argument x  = R.reg ('A', x, 1)
let global   x  = R.reg ('G', x, 1)

(* the following RTLs are not type correct *)
(* x is an expression *)
(*
let store_arg i e = R.par [R.store (argument (fetch ap)) e (ewidth e); inc ap] 
let fetch_arg i w = R.fetch (argument (fetch ap)) w
*)

let store_arg i e  = R.store (argument i) e (ewidth e)
let fetch_arg i w  = R.fetch (argument i) w
@

% ------------------------------------------------------------------ 
\subsection{Automata}
% ------------------------------------------------------------------ 

<<interp.ml>>=
class argument_location (index:int): Automaton2.location =
object
    method store expr width = Flow.store_arg index expr
    method fetch width      = Flow.fetch_arg index width
    method to_loc           = assert false
end

class arguments (base:Rtl.exp): Automaton2.automaton =
object (this)
    val mutable _block  = Block.at base (*size*) 0 (*align*) 1  
    val mutable _frozen = false

    (* *)
    val mutable _index  = -1
    (* *)
    
    method freeze () =
        let _ = _frozen <- true in
        { A.overflow = _block; A.sp_value = base } (* sp value meaningless to interp *)
    
    method allocate width hint = 
        let ()      = assert (_frozen = false) in          
        match hint with 
        | Some x -> Impossible.impossible ("unknown hardware register "^x) 
        | None   -> ( _index <- _index + 1
                    ; new argument_location _index
                    )
end

class global_location (index:int) (width:int): Automaton2.location =
    let var = 
        let s = Printf.sprintf "global_%d" index in 
        R.var s index width
in object
    method store expr width = R.store var expr width
    method fetch width      = R.fetch var width
    method to_loc           = var
end

class globals (base:Rtl.exp): Automaton2.automaton =
object (this)
    val mutable _block  = Block.at base (*size*) 0 (*align*) 1  
    val mutable _frozen = false
    val mutable _index  = 0
    
    method freeze () =
        let _ = _frozen <- true in
        { A.overflow = _block; A.sp_value = base } (* sp value meaningless to interp *)
    
    method allocate width hint = 
        let ()      = assert (_frozen = false) in          
        match hint with 
        | Some x -> Impossible.impossible ("unknown hardware register "^x) 
        | None   -> ( _index <- _index + 1
                    ; new global_location _index width
                    )
end
@

% ------------------------------------------------------------------ 
\subsection{Target Value}
% ------------------------------------------------------------------ 

The [[target]] value is the essential information for the rest of the
compiler.

<<interp.ml>>=
let downrtl = R.Convert.rtl
let uploc   = R.Revert.loc
let upexp   = R.Revert.exp
let target =
    { T.name = arch
      ; T.cc = (fun _ -> 
               { T.sp     = Flow.sp
               ; T.return = Flow.return
               ; T.proc   = new arguments
               ; T.cont   = new arguments
               ; T.ret    = new arguments
               ; T.allocatable = []
               ; T.cutto  = 
                 { T.embed   =
                   (fun (newpc, newsp) ->
                     let assign loc e =
                       Rtl.store loc e (Rtlutil.Width.exp e) in
                       Rtl.par [assign Flow.sp newsp; assign Flow.pc newpc])
                 ; T.project = (fun r -> match downrtl r with
                                  | RP.Rtl [ (_, RP.Store(_, nsp, _))
                                           ; (_, RP.Store(_ , npc, _))] ->
                                    (upexp nsp, upexp npc)
                                  | _ -> Impossible.impossible "projected non-cutto")
                 }
               ; T.stack_slots  = new globals (* bogus *)
               }) 
      ; T.byteorder    = byte_order
      ; T.wordsize     = wordsize
      ; T.pointersize  = wordsize
      ; T.vfp          = Vfp.mk wordsize
      ; T.alignment    = 1
      ; T.memsize      = 8
      ; T.float        = "ieee754"
      ; T.charset      = "latin1" 
      ; T.globals      = new globals
      ; T.spaces       = [ Spaces.m ; Spaces.c ;  Spaces.a ; Spaces.g ]
      ; T.data_section = "data"
      ; T.goto         = Flow.goto
      ; T.jump         = Flow.jump
      ; T.call         = Flow.call 
      ; T.branch       = Flow.branch
      ; T.spill        = (fun _ -> assert false)
      ; T.reload       = (fun _ -> assert false)
      }
@
