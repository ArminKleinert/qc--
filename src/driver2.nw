% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sts=4 sw=4 et

% ------------------------------------------------------------------ 
\section{Driver}
% ------------------------------------------------------------------ 

This module presents the compiler as a compositional collection of
abstract values and functions. These functions and values are exported
as primitives to a Lua interpreter, giving the user a way to customize
the compiler.

The [[Caml]] module offers access to the different phases and values in
the compiler. 

<<driver2.mli>>=
module Caml: sig    (* in case of error Error.ErrorExn is raised! *)
    type asm        (* assembler                          *)
    type ast        (* abstract syntax                    *)
    type env        (* environment/symbol table           *)
    type doc        (* printable document                 *)
    type target     (* target architecture                *)
    type proc       (* procedure representation in back-end, includes
                       cfg, calling convention *)
    type optimize  = proc -> unit

    val dummy:      target                  (* our only target right now *)
    val cmmasm:     out_channel -> asm      (* C-- emitting assembler *)
    val dotasm:     out_channel -> asm      (* DOT emitting assembler *)
    val asdlasm:    out_channel -> asm      (* ASDL emitting assembler *)
    
    val version:    unit -> unit            (* print version to stdout   *)
    val scan:       file:string -> unit     (* for debugging the scanner *)
    val parse:      file:string -> ast      (* parse file                *)
    val pretty:     ast -> doc              (* pretty print *)

    val emit_asdl:  ast -> unit             (* emit AST in ASDL format *)
    val check:      ast -> asm -> env       (* check semantics of AST  *)

    val compile:    optimize -> ast -> target -> env -> asm
                    (* calls optimize *)
                
    val assemble:   asm -> unit
    val print:      doc -> width:int -> unit (* print doc to stdout *)
end
@

In case of an error, all functions raise [[Error.ErrorExn]]. An error
message is typically printed to [[stderr]] before the exception is
raised.

\begin{itemize}
\item [[dummy]]: represents our only target architecture.
\item [[version]]: print a version information to [[stdout]]. This is
      intentionally not a string such it is harder to abuse.
\item [[scan]]: scans a file and prints all tokens together with their
      source code position. Only useful to debug the scanner.
\item [[parse]]: returns the abstract syntax of a {\PAL} file.
\item [[emit_asdl]]: writes the {\AST} in {\small ASDL} syntax to
      [[stdout]].
\item [[check]]: checks the static semantics of a file and returns 
      an environment [[env]] value upon success. 
\item [[compile]]: compiles an {\AST} to assembly code. The function
      calls the Lua function [[optimize]] for every function and passed
      the functions control-flow graph [[cfg]] and its [[stack]] to it.
\item [[assemble]]: emits an assembler program.
\item [[print]]: prints a [[doc]] value to [[stdout]], formatting the
      output for a line width of [[width]] characters.       
\end{itemize}

The compiler is controlled by a Lua interpreter that is build in the
\module{main2} module. It takes several user-defined types to extend it.
This module provides new Lua types like [[asm]] and [[ast]] for the
interpreter, and a library that uses them. 

<<driver2.mli>>=
module Export : sig
    module AsmT     : Lua.USERDATA
    module AstT     : Lua.USERDATA
    module EnvT     : Lua.USERDATA
    module ProcT    : Lua.USERDATA with type 'a t = Proc.t
    module TargetT  : Lua.USERDATA with type 'a t = Target2.t
    module DocT     : Lua.USERDATA

    module MakeLib  
      (AsmV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AsmT.t)
      (AstV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AstT.t 
                                  and  type 'a combined = 'a AsmV.combined)
      (EnvV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a EnvT.t 
                                  and  type 'a combined = 'a AsmV.combined)
      (ProcV   : Lua.Lib.TYPEVIEW with type 'a t        = 'a ProcT.t
                                  and  type 'a combined = 'a AsmV.combined)
      (TargetV : Lua.Lib.TYPEVIEW with type 'a t        = 'a TargetT.t 
                                  and  type 'a combined = 'a AsmV.combined)
      (DocV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a DocT.t 
                                  and  type 'a combined = 'a AsmV.combined)
      (InOutV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a Luaiolib.T.t    
                                  and  type 'a combined = 'a AsmV.combined)
        : Lua.Lib.TYPEFUL with type 'a combined = 'a AsmV.combined 
end
@


% ------------------------------------------------------------------ 
\subsection{Caml Implementation}
% ------------------------------------------------------------------ 

<<driver2.ml>>=
module Caml = struct
    <<Caml>>
end
@

<<Caml>>=
module Personality = struct
    let target = Targets.dummy
end

module E   = Error
module L   = Live.Make(Cfg3)
module Asm = Astasm.Make(Personality)
module IR  = Ast3ir
module F   = Fenv.Clean

<<Caml>>=
type asm        = Asm3.assembler
type ast        = Srcmap.map * Ast.program
type env        = Fenv.Clean.env
type doc        = Pp.doc
type proc       = Proc.t
type target     = Target2.t
type optimize   = proc -> unit 

<<Caml>>=

let dummy   = Targets.dummy

<<Caml>>=
let version () =
    ( This.name     stdout 
    ; output_string stdout " "
    ; This.version  stdout 
    ; output_string stdout 
        "\n(c) 2000, 2001 President and Fellows of Harvard University\n" 
    ; output_string stdout 
        "See also http://www.cminusminus.org/\n"
    )

<<Caml>>=
let scan file =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.mk ()                          in
    let scanner     = Scan.scan map                         in
    let location lb = Srcmap.location map (Lexing.lexeme_start lb) in
    let rec loop lb =
        match scanner lb with
            | Parse.EOF -> ()
            | tok       ->
                let (file,line,col) = location lb           in
                let tok             = Scan.tok2str tok      in
                    ( Printf.printf "%-16s %3d %2d %s\n" file line col tok
                    ; loop lb
                    )
    in
        ( Srcmap.sync map 0 (file,1,1)
        ; loop lexbuf
        ; finally ()
        )

<<Caml>>=
let parse (file:string) = 
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.mk ()                          in
    let scanner     = Scan.scan map                         in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; (map, Parse.program scanner lexbuf) 
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.error "parse error - compilation aborted"
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.error "parse error - compilation aborted"
              )
            | e ->
              ( finally()
              ; raise e
              )

<<Caml>>=
let emit_asdl (map,ast:ast) =
        AstUtil.sexp_wr_program ast stdout
@

Assemblers are objects. We therefore need function to create them, Here
are our current assemblers.

<<Caml>>=
let cmmasm  (c:out_channel) = Asm.asm     c 
let dotasm  (c:out_channel) = Dotasm.asm  c
let asdlasm (c:out_channel) = Asdlasm.asm c
@

The user specifies in the source code some target properties. They must
be consistent with the actual target. We check this in
[[consistency_check]].

<<Caml>>=
let consistency_check env (t:Target2.t) =
    let int i = string_of_int i in
    let msg property source target = 
        let m = Printf.sprintf 
                "mismatch of %s between source (%s) and target (%s)"
                property source target 
        in Error.error (m)
    in match F.findEndianness env, t.Target2.byteorder with
    | F.Big,    Rtl.LittleEndian -> msg "byteorder" "little" "big"
    | F.Little, Rtl.BigEndian    -> msg "byteorder" "big"    "little"
    | _ -> if F.findWordsize env <> t.Target2.wordsize then
        msg "wordsize" (int (F.findWordsize env)) (int t.Target2.wordsize)
    else if F.findMemsize env <> t.Target2.memsize then
        msg "memsize" (int (F.findMemsize env)) (int t.Target2.memsize)
    else if F.findPointersize env <> t.Target2.pointersize then
        msg "pointer size" (int (F.findPointersize env)) 
            (int t.Target2.pointersize)
    else if F.findFloat env <> t.Target2.float then
        msg "floating point standard" (F.findFloat env) t.Target2.float
    else if F.findCharset env <> t.Target2.charset then
        msg "charset" (F.findCharset env) t.Target2.charset
    else
        ()
@


<<Caml>>=
let check (map,ast:ast) (asm:asm) =
    let env      = Fenv.Dirty.empty map asm          in
    let env      = Fenv.Dirty.push env (Fenv.Dirty.emptyscope) in
    let env      = Elab.Env.global   env ast         in
    let env      = Elab.Check.global env ast         in
    let env      = Elab.Env.setDefaults env          in
    let ()       = if Fenv.Dirty.errorFlag env then 
                      Error.error "compilation aborted because of errors." 
    in
        Fenv.clean env

<<Caml>>=
let compile (opt:optimize) (map,ast:ast) (target:target) (env:env)  =
    let ()     = consistency_check env target in   
        IR.translate env target opt ast 

let pretty (map,ast:ast) =
    Astpp.program ast

<<Caml>>=
let assemble (asm:asm) = asm#emit

<<Caml>>=
let print (doc:doc) (width:int) =
    Pp.ppToFile stdout width doc
@

% ------------------------------------------------------------------ 
\subsection{Export to Lua}
% ------------------------------------------------------------------ 

<<driver2.ml>>=
module Export = struct
    <<Export>>
end

<<Export>>=
module AsmT = struct
    type 'a t       = Caml.asm
    let tname       = "asm"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<asm>" 
end
module AstT = struct
    type 'a t       = Caml.ast
    let tname       = "ast"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<ast>" 
  end
module EnvT = struct
    type 'a t       = Caml.env
    let tname       = "env"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<env>" 
end
module ProcT = struct
    type 'a t       = Caml.proc
    let tname       = "proc"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> ("<proc "^t.Proc.symbol#text^">") 
end
module TargetT = struct
    type 'a t       = Caml.target
    let tname       = "target"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<target " ^ t.Target2.name ^ ">" 
end
module DocT = struct
    type 'a t       = Caml.doc
    let tname       = "doc"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<doc>" 
end

<<MakeLib>>
@

<<MakeLib>>=
module MakeLib
  (AsmV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AsmT.t)
  (AstV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AstT.t 
                              and  type 'a combined = 'a AsmV.combined)
  (EnvV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a EnvT.t 
                              and  type 'a combined = 'a AsmV.combined)
  (ProcV   : Lua.Lib.TYPEVIEW with type 'a t        = 'a ProcT.t
                              and  type 'a combined = 'a AsmV.combined)
  (TargetV : Lua.Lib.TYPEVIEW with type 'a t        = 'a TargetT.t 
                              and  type 'a combined = 'a AsmV.combined)
  (DocV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a DocT.t 
                              and  type 'a combined = 'a AsmV.combined)
  (InOutV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a Luaiolib.T.t    
                              and  type 'a combined = 'a AsmV.combined)
    
    : Lua.Lib.TYPEFUL with type 'a combined = 'a AsmV.combined =

struct
  type 'a combined = 'a AsmV.combined
  module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
    struct
      module V = C.V
      let ( **-> ) = V.( **-> )
      <<bind exports to tables: builtins, targets>> 
      let init = C.register_module "Driver"  builtins 
    end (*M*)
end (*MakeLib*)
@ 

All exported functions go into the Lua namespace [[Driver]].
@ 


Here we finally bind the [[Caml]] values to names in the Lua
interpreter. The [[compile]] function receives a lua value such that it
can call Lua functions while it is active.

<<bind exports to tables: builtins, targets>>=
let pf t   = (V.pfunc t).V.embed 
let func t = (V.func t).V.embed 

module Map = struct
    let ast       = AstV.makemap    V.userdata V.projection
    let asm       = AsmV.makemap    V.userdata V.projection
    let env       = EnvV.makemap    V.userdata V.projection
    let proc      = ProcV.makemap   V.userdata V.projection
    let doc       = DocV.makemap    V.userdata V.projection
    let target    = TargetV.makemap V.userdata V.projection
    let optimize  = V.func (proc **-> V.runit)
    let channel   = InOutV.makemap  V.userdata V.projection
    let inchan    = Luaiolib.in'    channel    V.projection
    let outchan   = Luaiolib.out    channel    V.projection
end

let builtins =
  [ "assemble"  , pf (Map.asm     **-> V.runit)            Caml.assemble
  ; "check"     , pf (Map.ast     **-> Map.asm 
                                  **-> V.result Map.env)   Caml.check
  ; "emit_asdl" , pf (Map.ast     **-> V.runit)            Caml.emit_asdl
  ; "parse"     , pf (V.string    **-> V.result Map.ast)   Caml.parse
  ; "print"     , pf (Map.doc     **-> V.int **-> V.runit) Caml.print
  ; "pretty"    , pf (Map.ast     **-> V.result Map.doc)   Caml.pretty
  ; "scan"      , pf (V.string    **-> V.runit)            Caml.scan
  ; "version"   , pf (V.unit      **-> V.runit)            Caml.version
  ; "cmmasm"    , pf (Map.outchan **-> V.result Map.asm)   Caml.cmmasm     
  ; "astasm"    , pf (Map.outchan **-> V.result Map.asm)   Caml.cmmasm (*alias*)
  ; "dotasm"    , pf (Map.outchan **-> V.result Map.asm)   Caml.dotasm
  ; "asdlasm"   , pf (Map.outchan **-> V.result Map.asm)   Caml.asdlasm
  ; "stdin"     , Map.inchan.V.embed    stdin   (* hack, for now *)
  ; "stdout"    , Map.outchan.V.embed   stdout  (* hack, for now *)
  ; "compile"   , func (Map.optimize  **-> Map.ast  
                                      **-> Map.target 
                                      **-> Map.env 
                                      **-> V.result Map.asm)
                  (fun g opt -> Caml.compile (opt g))
  ] 
@  
