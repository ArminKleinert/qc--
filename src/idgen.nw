
\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Name Generator}
% ------------------------------------------------------------------ 

For labels, temporary variables similar objects generated by the
compiler we need an infinite supply of unique names.  This objects
provides a generator for such names:  every invocation generates a new
name.  To aid debugging, a string can be supplied that becomes part of
the generated name.

The names generated by this module need not respect the syntax for
symbols of an assembly language.  Names that are used for assembly
symbols are mangled to ensure they conform to the assembler at hand. 
See module \module{mangle} for the connection between {\PAL} and
assembly names.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface provides two functions [[id] and [[id']]. The latter
permits to supply a string that becomes part of the generated name.
Supplying the same name twice will result in different generated
names: every invocation yields a unique name.

<<idgen.mli>>=
val id:     unit   -> string
val id':    string -> string
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation must maintain state in order to generate unique
names. We use a counter to create unique strings.

<<idgen.ml>>=
let count = ref 0
@

Names returned by [[id']] use the supplied name as a prefix, followed
by a unique number.  In order to avoid generating pure numbers when an
empty string is supplied, an empty string is treated like an
underscore.

<<>>=
let id' s =
    ( incr count
    ; Printf.sprintf "%s%d" (if s = "" then "_" else s) !count
    )
@

The more anonymous names generated by [[id]] just use [[L]] as a prefix.

<<>>=
let id () = id' "L"
@

    

