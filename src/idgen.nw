
\input{macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h substitution alpha alpha
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Name Generator}
% ------------------------------------------------------------------ 

For labels, temporary variables similar objects generated by the
compiler we need an infinite supply of unique names.  In order to
avoid collisions with existing names in a {\PAL} program these names
are constructed in way that is impossible at the {\PAL} source level. 
This module provides a generator for such names:  every invocation
generates a new name.  To aid debugging, a string can be supplied that
becomes part of the generated name.

The names generated by this module need not respect the syntax for
symbols of an assembly language.  Names that are used for assembly
symbols are mangled to ensure they conform to the assembler at hand. 
See module \module{mangle} for the connection between {\PAL} and
assembly names.


\begin{quote}
Here is my current picture about names in the compiler: 

\begin{itemize}
\item Global names in a {\PAL} program are used in the flow graph and
      {\rtl} representation.  They are known to be unique and thus
      there is no need to re-name them.

\item Local names in a {\PAL} program are replaced during translation
      to the intermediate representation by generated names that can't
      clash with global names.  The standard trick is to include
      characters that can not be used at the {\PAL} source level.
      
\item The translation into intermediate representation must introduce
      some global names. They are constructed in a way that they can
      not clash with any of the names mentioned above.

\item Ultimately everything is translated to assembly language. During
      this step all names are $\alpha$-converted\footnote{This term is
      used in the lambda calculus for re-naming variables while
      respecting their bindings} such that they respect the syntax of
      the given assembler. 
\end{itemize}

\end{quote}

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface provides two functions [[id] and [[id']].  The latter
permits to supply a string that becomes part of the generated name. 
The supplied name \emph{must} be a legal {\PAL} name.  Supplying the
same name twice will result in different generated names:  every
invocation yields a unique name.

<<idgen.mli>>=
val id:     unit   -> string
val id':    string -> string
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation must maintain state in order to generate unique
names. We use a counter to create unique strings. {\PAL} names must
not include a colon ``[[:]]'' character; we include such a character
into the generated names to avoid name clashes with existing names.

<<idgen.ml>>=
let count = ref 0
@

Names returned by [[id']] use the supplied name as a prefix, followed
by a unique number. 

<<idgen.ml>>=
let id' s =
    ( incr count
    ; Printf.sprintf "%s:%d" s !count
    )
@

The more anonymous names generated by [[id]] just use [[L]] as a prefix.

<<idgen.ml>>=
let id () = id' "L"
@

    

