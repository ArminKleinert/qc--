% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et: 
% Daddy, why are we hiding from the police? They use Emacs, son, we use Vi.
% Cheese it!  The cops!!!
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% 
% $Id$

% inc: \usepackage{nchicago}

% ------------------------------------------------------------------ 
\section{Control-Flow Graph Revisions}
% ------------------------------------------------------------------ 

Here are some possible revisions to the flow graph.
\begin{itemize}
\item
Make predecessor and successor fields mutable.
This change gives a client substantially greater freedom to choose the
order in which nodes are constructed.
\item
Introduce the idea of \emph{layout}.
A graph \emph{has layout} if the physical order of instructions and
labels is known.
A graph must have layout before it is passed to an assembler.

Except for branch nodes as specified below, if a node has a unique
successor, then the node precedes its successor in the physical layout.
\item
Restrict types of nodes in the hopes of simplifying algorithms.
The grossest classification is by numbers of predecessors and
successors. 
\begin{itemize}
\item
A \emph{join point} has arbitrarily many precedessors and exactly one
successor. 
It is associated with a list of \emph{labels} but no code.
A join point is the only node with multiple predecessors.
\remark{Question for Glenn: how to represent the successor list?  How
much space do you allocate for successors whan you don't yet know how
many there will be?}
\item
An \emph{straight-line code} node has exactly one predecessor and one
successor. 
It models computation without interesting control flow.
\item
A \emph{branch node} performs a goto but is intended to implement no
other useful computation.
It has a unique predecessor and a unique successor.
Its successor must be a join point.
If the graph has layout, the branch node also has a layout successor,
which may be different from its control-flow successor.
The RTL of a branch node is an unconditional assignment to the program
counter. 
\item
A \emph{jump} node is a lot like a branch except its successor is the
exit node
\item
A \emph{conditional branch} has a unique predecessor and two
successors, which are labeled true and false.
Each successor must be a join point.
It contains an RTL that normally satisfies the following properties:
\begin{itemize}
\item
It contains a single effect, which is a guarded assignment to the
program counter.
\item
The value assigned to the program counter is a label (link-time
constant) associated with the join point that is the true successor.
\end{itemize}
If the second property is not satisfied, we say the node is
\emph{dirty}.
The node must be clean before it can be passed to an assembler.

If the graph has layout, the layout successor of a branch node must
be its false successor.

It is legitimate at any time to perform the following changes as one
atomic operation:
\begin{itemize}
\item
Swap the true and false successors
\item
Negate the condition on the guard
\item
Replace the label in the assignment with the new true successor.
\end{itemize}
The [[bnegate]] operation in the postexpander interface is useful here.
\item
A node with multiple successors is a \emph{multiway branch}.
It has a unique predecessor.
There are several kinds of multiway branch.
\begin{itemize}
\item
Call
\item
Computed goto
\item
\emph{Cut to}.
Normally has a single successor (the exit) but may have multiple
successors. 
\end{itemize}
\item
THERE ARE NO DATAFLOW NODES.  INSTEAD, A NODE MAY CONTRIBUTE DEFS,
AND KILLS TO EACH OUTEDGE, AND A NON-JOIN NODE MAY CONTRIBUTE
USES TO ITS UNIQUE INEDGE.
\item
The entry node has a successor but no predecessor
\item
The exit node has a predecessor but no successor (or perhaps it should
be a join point)?
\item
An \emph{illegal} node has no predecessors and no successors.
It is used to initialize mutable successor and predecessor fields.
\end{itemize}
\item
An infinite loop must contain an artificial edge so it can reach the
exit.

\end{itemize}
@ 

\section{Goals}

This section lists our goals for the control-flow graph.  
It is cribbed from a similar section in the documentation for Machine
SUIF. 
\begin{itemize}
\item
\emph {Analysis.}
Many compiler analyses assume a flow graph as a basic data
structure. 
Such analyses include
liveness analysis, reaching definitions,
and dead-code identification.
We provide the ability to traverse and observe the nodes and edges in
the flow graph.
\item
\emph{Transformation.}
We also want to support control-flow transformation, e.g., by merging
instructions, moving code out of loops, various forms of redundancy
elimination, and so on.
Davidson-style code expansion may also involve rewriting Boolean
operations into control flow.
\item
\emph {Simple ordering.}
To be able to emit a program, 
we provide minimal support for mapping the flow graph onto an ordered
list of code, data, and labels.
While we wouldn't mind supporting automated code layout and
code-layout optimizations, it is not a high priority.
Furthermore, and following Machine SUIF, we make it possible to
manipulate a flow graph that has no layout in memory---we require only
that a layout be established before code is emitted.
\item
\emph{Minimize burden on clients.}
We minimize the number of checked and unchecked run-time errors a
client can commit.
This policy may make the flow graph more complex and more expensive,
but we believe it is better that this abstraction do as much of the
hard work as possible.
\end{itemize}


\section{The Control-Flow Graph}

Quick~{\PAL} uses a control-flow graph to represent a procedure.
The flow-graph abstraction is inspired by \citeN{knoop:basic-block},
who described the basic-block control-flow graph as a ``living
dinosaur.''
Accordingly, our flow graph does not use basic blocks; each node
represents at most one instruction.

This abstraction actually represents \emph{two} graphs: a control-flow
graph and a physical-layout graph.
A~\emph{control-flow edge} indicates the possibility that control may flow
from one node to another during the dynamic execution of a program.
A~\emph{layout edge} indicates that the code for one node
appears before the code for another node in the image (assembly or binary)
that is written to the output.\footnote
{N.B.~The code for a third node may intervene.}
When we refer to an unqualified edge, predecessor, or successor, we
always refer to the control-flow graph, not to the layout graph.

We classify a node according to the number of predecessors and
successors it may have, and also according to the \emph{payload} it
may carry.
\begin{itemize}
\item
A \emph{join point} has arbitrarily many precedessors and exactly one
successor. 
Its payload is one or more \emph{labels} but no code.
A join point is the only node with multiple predecessors.
The layout successor a join point is its control-flow successor.

\item
An \emph{ordinary instruction} has one predecessor and one successor.
Its payload is one instruction.
Its layout successor is its control-flow successor.
\item
An \emph{assertion} is just like an ordinary instruction, except that it generates
no code.
Instead, it simply asserts that the effect of the instruction has
taken place.
Its purpose is to sit on an interprocedural control-flow edge, so we
have a way of recording what a callee did to a stack pointer, for
example. 
\item
A \emph{control-flow} instruction has one predecessor and one or more
successors. 
Every successor must be a join point.
There are a variety of control-flow instructions with different
numbers of successors and different constraints on layout.
\begin{itemize}
\item
A \emph{branch node} performs a goto but is intended to implement no
other useful computation.
It has a unique predecessor and a unique successor.
Its layout successor may be different from its control-flow successor.
The standard RTL of a branch node is an unconditional assignment to the program
counter. 
\item
A \emph{jump} node is a lot like a branch except its successor is the
exit node, which is considered a join point \emph{ex officio}. 
\item
A \emph{conditional branch} has two
successors, which are labeled true and false.
It contains an RTL that normally satisfies the following properties:
\begin{itemize}
\item
It contains a single effect, which is a guarded assignment to the
program counter.
\item
The value assigned to the program counter is a label (link-time
constant) associated with the join point that is the true successor.
\end{itemize}
If the second property is not satisfied, we say the node is
\emph{dirty}.\footnote{We can and should prevent the node from ever
becoming dirty.}
The node must be clean before it can be passed to an assembler.

If the graph has layout, the layout successor of a branch node must
be its false successor.

It is legitimate at any time to perform the following changes as one
atomic operation:
\begin{itemize}
\item
Swap the true and false successors
\item
Negate the condition on the guard
\item
Replace the label in the assignment with the new true successor.
\end{itemize}
The [[bnegate]] operation in the postexpander interface is useful here.
\item
A computed goto with multiple successors is a \emph{multiway branch}.
Its layout successor is unconstrained.
\item 
A \emph{call} node has many successors, which are listed in this
order:
alternate return continuations, normal return, unwind continuations,
cut-to continuations. 
Its layout successor must implement the alternate return
continuations, if any, and the successor after that must be the normal
return continuations.
(If there are no alternate return continuations, the direct successor
implements the normal return continution.)
\item
A \emph{cut to} node
normally has a single successor (the exit) but may have multiple
successors. 
Its layout successor is unconstrained. 
\end{itemize}
\item
The entry node has a successor but no predecessor
\item
The exit node has one or more predecessors but no successor.
It is therefore considered a kind of join point.
\item
An \emph{illegal} node has no predecessors and no successors.
It is used to initialize mutable successor and predecessor fields.
\item
An \emph{impossible} node has two successors.
Its ordinary successor is its layout successor.
Its impossible successor is always the exit node.
(It exists to facilitate solution of backward dataflow problems, such
as liveness.)
An infinite loop must contain an impossible node so it can reach the
exit.
\end{itemize}

\section{Invariants}

The control-flow graph maintains several invariants:
\begin{itemize}
\item
 The Golden Invariant: Each successor of a fork is a join point.
\end{itemize}

\section{Interface}

TO TRY: REMOVE THE GRAPH PARAMETER FROM AS MANY NODE-CREATION ROUTINES AS POSSIBLE.
A SUCCESSOR ALREADY PROVIDES THE GRAPH!!
<<cfg.mli>>=
<<exported signatures>>
<<exported signatures>>=
module type X = sig
  type jx  (* extension at join point *)
  type fx  (* extension at fork point *)
  type nx  (* extension at all nodes (including fork/join) *)
  val jx : unit -> jx
  val fx : unit -> fx
  val nx : unit -> nx
end

module type S = sig
  module X : X

  type label = string

  type 'i cfg
  type 'i t = 'i cfg
  type 'i node
  type regs = Register.Set.t (* sets of regs for dataflow *)
  type 'i contedge = { kills:regs; defs:regs; node:'i node }
  type kind = (* all the kinds of nodes *)
    | Join | Instruction | Branch | Cbranch | Mbranch
    | Jump  | Call | Return | CutTo
    | Entry | Exit | Assertion | Illegal | Impossible
  <<graph and node observers>>
  <<graph and node constructors>>  
  <<graph and node mutators>>
end
@ 
<<cfg.mli>>=
module Make (X:X) : S with module X = X
@
\subsection{Interface summary}
Details are given below, but here are the observers:
<<graph and node observers>>=
@  
Here are the mutators:
<<graph and node mutators>>=
@  
Here are the constructors:
<<graph and node constructors>>=
@
\subsection{Observers}

\paragraph{Observing nodes}
We can ask about the kind of a node, and we can compare nodes for equality.
<<graph and node observers>>=
val kind       : 'i node -> kind
val eq         : 'i node -> 'i node -> bool
@ 
We can also ask particular predicates that relate to the kind.
<<graph and node observers>>=
val is_join    : 'i node -> bool
val is_fork    : 'i node -> bool
@ 
We can ask for a label, or for all the labels, on a join node.
<<graph and node observers>>=
val label      : 'i node -> label      (* defined on any join node except exit *)
val labels     : 'i node -> label list (* defined on any join node except exit *)
@ 
We can ask for the instruction, if any.
<<graph and node observers>>=
val to_instr   : 'i node -> 'i option
@ 
We can ask about the unique predecessor of a non-join node.
It is a checked run-time error to call this function on a join,
exit, entry, or illegal node.
Similarly, we can ask about the unique successor of a non-fork node.
<<graph and node observers>>=
val pred       : 'i node -> 'i node  (* defined on non-join, non-exit *)
val succ       : 'i node -> 'i node  (* defined on non-fork *)
@
We can ask about the true and false successor of a conditional branch.
It is a checked run-time error to call these functions on anything
other than a conditional branch.
<<graph and node observers>>=
val tsucc      : 'i node -> 'i node  (* defined on conditional branch *)
val fsucc      : 'i node -> 'i node  (* defined on conditional branch *)
@
We can ask for any successor by number, for any kind of node.
Successors are numbered from zero, the true successor precedes the
false successor (0~and~1), and the numbering for calls is
complicated. 
Function [[succ_n]] raises [[Invalid_argument]] if [[n]]~is
negative or too large.  
<<graph and node observers>>=
val succ_n     : 'i node -> int -> 'i node  (* defined on any node *)
@
For any kind of node, we can ask for all its successors and
predecessors.
<<graph and node observers>>=
val preds      : 'i node -> 'i node list  (* defined on any node *)
val succs      : 'i node -> 'i node list  (* defined on any node *)
@
We can ask about the kinds of control-flow instructions.
<<graph and node observers>>=
val is_cti     : 'i node -> bool  (* is any control-flow 'i node *)
val is_br      : 'i node -> bool  (* is direct branch *)
val is_cbr     : 'i node -> bool  (* is conditional branch *)
val is_mbr     : 'i node -> bool  (* is multiway branch *)
val is_call    : 'i node -> bool
val is_cut     : 'i node -> bool
@ 
We can get an extension suitable for the kind of node.
<<graph and node observers>>=
val jx         : 'i node -> X.jx  (* defined only on join nodes *)
val fx         : 'i node -> X.fx  (* defined only on fork nodes *)
val nx         : 'i node -> X.nx  (* defined only on non-fork, non-join *)
@ 
\paragraph{Observing the graph}
We can get the entry and exit nodes.
<<graph and node observers>>=
val entry      : 'i cfg -> 'i node
val exit       : 'i cfg -> 'i node
@ 
We can observe all the nodes.
We do so by providing higher-order functions.
These functions work by enumerating  \emph{basic blocks}.
A basic
block is a sequence of nodes beginning in a \emph{head node} (a join
point or the entry 
node) and ending in a control-transfer node or the exit node.
The basic blocks are enumerated in no particular order.
Within a basic block, we enumerate nodes in order.
If the client mutates the graph, we make no guarantees about what
nodes may be visited.
<<graph and node observers>>=
val iter_nodes : ('i node -> unit)           -> 'i cfg -> unit
val iter_heads : ('i node -> unit)           -> 'i cfg -> unit
val fold_nodes : ('i node -> 'a -> 'a) -> 'a -> 'i cfg -> 'a
val fold_heads : ('i node -> 'a -> 'a) -> 'a -> 'i cfg -> 'a
@ 
\paragraph{Observing data flow}
As noted above a node can contribute defs, uses, and kills to each
outedge, and a non-join node may contribute uses to each inedge.
The access to this information is carefully crafted to support
liveness analysis and to provide for efficient implementation in the
common case where there is no dataflow.

The [[union_over_outedges]] function is written in continuation-passing
style.  The [[noflow]] continuation is used in the common case when an
edge bears no dataflow information; the [[flow]] continuation is used
in the general case.  Clients must guarantee that
[[noflow n = flow {node=n; defs=empty; kills=empty}]].
In the common case, [[union_over_edges]] simply applies [[noflow]] to
its unique successor.

Calling [[add_inedge_uses n l]] returns the union of~[[l]] with any
uses on the inedge to~[[n]].
It is defined on \emph{all} nodes, because there are no uses on the
inedges of a join point.
In the common case, it returns its second argument.
<<graph and node observers>>=
val union_over_outedges : 
  'i node -> noflow:('i node -> regs) -> flow:('i contedge -> regs) -> regs
val add_inedge_uses  : 'i node -> regs -> regs
@ 
\subsection{Mutators}
We can change the graph by any of the following operations:
<<graph and node mutators>>=
@ 
\paragraph{Transactions}
In case we ever want to debug, mutations should be logged as
transactions.
This way we can replay them later...
<<graph and node mutators>>=
val start_transaction : 'i cfg -> string -> unit
val end_transaction   : 'i cfg -> unit
@ 
\paragraph{Altering successors}
We alter edges either by setting successors or by splicing in graphs.
These functions do whatever it takes to maintain invariants, which
means they may insert conditional branches or join points.
Function [[set_succ_n]] raises [[Invalid_argument]] if [[n]]~is
negative or too large.  
<<graph and node mutators>>=
val set_succ      : 'i node -> succ:'i node -> unit  (* defined on non-fork *)
val set_tsucc     : 'i node -> succ:'i node -> unit  (* defined on conditional branch *)
val set_fsucc     : 'i node -> succ:'i node -> unit  (* defined on conditional branch *)
val set_succ_n    : 'i node -> int -> succ:'i node -> unit  (* defined on any node *)
@ 
The special function [[invert_cbr]] swaps the true and false
successors of a conditional branch.
It also updates the instruction payload appropriately.
It is a checked run-time error to use [[invert_cbr]] on any
instruction other than a conditional branch.
<<graph and node mutators>>=
val invert_cbr    : 'i node -> unit              (* defined on conditional branch *)
@
\paragraph{Splicing in new subgraphs}
Although setting one or more successors is general enough to implement
any graph mutation, we provide
some convenient functions for splicing in a single-entry, single-exit
subgraph.
Such a subgraph is represented by its [[entry]], which must have
exactly one predecessor, and its [[exit]], which must have exactly one
successor.
It is permissible that the [[entry]] and [[exit]] be the same node.
<<graph and node mutators>>=
val splice_before : entry:'i node -> exit:'i node -> 'i node -> unit (* node is not join *)
val splice_after  : entry:'i node -> exit:'i node -> 'i node -> unit (* node is not fork *)
@
It is permissible to delete any node with one predecessor and one
successor.
It is never legal to delete a join point.
<<graph and node mutators>>=
val delete        : 'i node -> unit    (* must have unique pred and succ *)
@
\paragraph{Altering instructions}
If a node carries an instruction payload, this function
updates the instruction.
If a node carries no instruction payload, this function silently does
nothing. 
Changing a branch or conditional-branch instruction automatically
changes its successors; changing a computed goto, call, cut to, or
jump does not.
<<graph and node mutators>>=
val update_instr  : ('i -> 'i) -> 'i node -> unit
@ 
\subsection{Constructors}
We can make a fresh graph.
Because the graph can insert join points at will, the client must
provide a supply of private labels.
The supply takes as argument a string~[[s]] and returns a unique label
that begins with~[[s]].
Because the graph must be able to insert conditional branches at will,
it is up  to the client to supply the appropriate function on
instructions.
Undoubtedly we will have to add some information about branch negation
as well. 
Perhaps ultimately we will use an analog of the embedding/projection
pairs specified in the [[Target]] module.
<<graph and node constructors>>=
type       label_supply        = string -> string
type 'i instruction_info = { goto   : (label, 'i) Ep.map
                           ; branch : (Rtl.exp * label, 'i) Ep.map
                           }
val mk   : 'i instruction_info -> label_supply -> 'i cfg
@ 
We can clone the graph, simultaneously changing the representation of
instructions. 
N.B. the result is a ``shallow'' copy, not a ``deep'' one.
The cloned graph may share mutable state with the original, typically
in the extension fields.
%%% ==> don't remove blank line following decl
<<graph and node constructors>>=
val copy : 'j instruction_info -> ('i -> 'j) -> 'i cfg -> 'j cfg

@
We can make a variety of individual nodes.
These functions all mutate the graph, but we classify them as constructors anyway.
<<graph and node constructors>>=
val node_labeled : 'i cfg -> label -> 'i node
@ This function returns a join point bearing the given label.
If no such join point exists, one is created.
This function is the only way to create a join point explicitly
(though one may be created implicitly if two successors are set to the
same point).
@
In most cases, when we create a node we supply its successors.
The simple instruction is, well, simple.
<<graph and node constructors>>=
val instruction  : 'i cfg -> 'i -> succ:'i node -> 'i node
val assertion    : 'i cfg -> 'i -> succ:'i node -> 'i node
@ 
\paragraph{Control-flow nodes}
The graph knows how to make an unconditional branch and a conditional
branch. 
Otherwise, it's up to the client to supply the instruction that does
the transfer.
<<graph and node constructors>>=
val branch       : 'i cfg -> target:'i node -> 'i node
val jump         : 'i cfg -> 'i -> uses:regs -> targets:string list -> 'i node
val cbranch      : 'i cfg -> Rtl.exp -> ifso:'i node -> ifnot:'i node -> 'i node
val mbranch      : 'i cfg -> 'i -> targets:'i node list -> 'i node
val call         : 'i cfg -> 'i -> altrets:'i contedge list -> succ:'i node ->
                     unwinds_to:'i contedge list -> cuts_to:'i contedge list ->
                     aborts:bool -> uses:regs -> defs:regs -> kills:regs -> 
                     spans:(Bits.bits * Rtl.exp) list -> 'i node
val cut_to       : 'i cfg -> 'i -> cuts_to:'i contedge list -> aborts:bool ->
                     uses:regs -> 'i node
val return       : 'i cfg -> 'i -> uses:regs -> 'i node
@ N.B. So that a [[call]] can be composed in sequence just like an
[[instruction]], the ordinary return from a call is called [[succ]].
The [[spans]] argument to a [[call]] requires that the properties be
link-time constant expressions, but this requirement is not enforced
by the static type of the expression.
@
The weird nodes.
<<graph and node constructors>>=
val impossible   : 'i cfg -> succ:'i node -> 'i node
val illegal      : 'i cfg -> 'i node  (* a node that must never be reached *)
@
\section{Implementation}
<<cfg.ml>>=
<<exported signatures>>
module Make (X:X) : S with module X = X = struct
  module RS = Register.Set
  module SM = Strutil.Map
  module X  = X

  type regs = Register.Set.t (* sets of regs for dataflow *)
  type label = string
  type label_supply = string -> label
  type 'i instruction_info = { goto   : (label, 'i) Ep.map
                             ; branch : (Rtl.exp * label, 'i) Ep.map}

  type kind = (* all the kinds of nodes *)
    | Join | Instruction | Branch | Cbranch | Mbranch
    | Jump  | Call | Return | CutTo
    | Entry | Exit | Assertion | Illegal | Impossible
  <<node type>>
  and  'i contedge = { kills:regs; defs:regs; node:'i node }
  and  'i cfg = { mutable entry     : 'i node
                ; mutable exit      : 'i node (*mutable for bootstrapping cfg*)
                ; mutable ill       : 'i node (*mutable for bootstrapping cfg*)
                ;         inst_info : 'i instruction_info
                ; mutable label_map : 'i node SM.t
                ;         mk_label  : label_supply
                }
  type 'i t = 'i cfg

  <<graph utilities>>
  <<graph and node observers implementation>>
  <<set successors>>

  <<simple node constructors>>
  <<node constructors with interesting control flow edges>>
  <<graph construction and copying>>

  <<graph and node mutators implementation>>
end
@

\subsection{Node Type}
Abbreviations:
\begin{quote} 
\noindent
\begin{tabular}{>{\ttfamily}ll}
ent& Entry\\
exi& Exit\\
joi& Join\\
ins& Instruction\\
ass& Assertion\\
bra& Branch\\
cbr& Conditional branch\\
mbr& Multiway branch (computed goto)\\
cal& Call\\
cut& Cut to\\
ret& Return\\
jum& Jump\\
imp& Impossible\\
ill& Illegal\\
\end{tabular}
\end{quote}

Suffixes:
\begin{quote} 
\noindent
\begin{tabular}{>{\ttfamily}ll}
i    & Instruction
labels & Multiple Labels
spans & Spans
contedges & Control-Flow Edges
cfg  & Control-Flow Graph
pred & Single Predecessor
preds& Multiple Predecessors
succ & Single Successor
succs& Multiple Successors
lpred & Layout Predecessor
lsucc & Layout Successor
jx    & Join Extension
fx    & Fork Extension
nx    & Non-Branch/Fork Extension
\end{tabular}
\end{quote}


<<node type>>=
type ('i, 'n)     ent = { mutable ent_succ   : 'n 
                        ;         ent_nx     : X.nx
                        }
type ('i, 'n, 'c) exi = { mutable exi_cfg    : 'c
                        ; mutable exi_labels : label list
                        ; mutable exi_preds  : 'n list
                        ; mutable exi_lpred  : 'n
                        ;         exi_jx     : X.jx
                        }
type ('i, 'n, 'c) joi = { mutable joi_labels : label list
                        ; mutable joi_cfg    : 'c
                        ; mutable joi_preds  : 'n list
                        ; mutable joi_succ   : 'n
                        ; mutable joi_lpred  : 'n
                        ;         joi_jx     : X.jx
                        }
type ('i, 'n)     ins = { mutable ins_i      : 'i
                        ; mutable ins_pred   : 'n
                        ; mutable ins_succ   : 'n
                        ;         ins_nx     : X.nx
                        }
type ('i, 'n)     ass = { mutable ass_i      : 'i
                        ; mutable ass_pred   : 'n
                        ; mutable ass_succ   : 'n
                        ;         ass_nx     : X.nx
                        }
type ('i, 'n)     bra = { mutable bra_i      : 'i
                        ; mutable bra_pred   : 'n
                        ; mutable bra_succ   : 'n
                        ; mutable bra_lsucc  : 'n
                        ;         bra_nx     : X.nx
                        }
type ('i, 'n)     cbr = { mutable cbr_i      : 'i
                        ; mutable cbr_pred   : 'n
                        ; mutable cbr_true   : 'n
                        ; mutable cbr_false  : 'n
                        ;         cbr_fx     : X.fx
                        }
type ('i, 'n)     mbr = { mutable mbr_i      : 'i
                        ; mutable mbr_pred   : 'n
                        ; mutable mbr_succs  : 'n array
                        ; mutable mbr_lsucc  : 'n
                        ;         mbr_fx     : X.fx
                        }
@

Note that the different types of successor edges are not maintained because
they are not distinguished in the flow-graph interface.
If a call also aborts, the called procedure can let control flow to any
non-local continuations.
In this case, the exit node is a successor of the call node.

<<node type>>=
type ('i, 'n, 'e) cal = { mutable cal_i         : 'i
                        ;         cal_spans     : (Bits.bits * Rtl.exp) list
                        ; mutable cal_pred      : 'n
                        ; mutable cal_contedges : 'e array
                        ;         cal_fx        : X.fx
                        ; mutable cal_uses      : regs
                        }
type ('i, 'n, 'e) cut = { mutable cut_i         : 'i
                        ; mutable cut_pred      : 'n
                        ; mutable cut_lsucc     : 'n
                        ; mutable cut_contedges : 'e array
                        ;         cut_fx        : X.fx
                        ; mutable cut_uses      : regs
                        }
type ('i, 'n)     jum = { mutable jum_i         : 'i
                        ; mutable jum_pred      : 'n
                        ; mutable jum_succ      : 'n
                        ; mutable jum_lsucc     : 'n
                        ;         jum_nx        : X.nx
                        ; mutable jum_uses      : regs
                        }
type ('i, 'n)     ret = { mutable ret_i         : 'i
                        ; mutable ret_pred      : 'n
                        ; mutable ret_succ      : 'n
                        ; mutable ret_lsucc     : 'n
                        ;         ret_nx        : X.nx
                        ; mutable ret_uses      : regs
                        }
type ('i, 'n)     imp = { mutable imp_pred      : 'n
                        ; mutable imp_succ      : 'n
                        ; mutable imp_exit_succ : 'n
                        ;         imp_fx        : X.fx
                        }
type ('i, 'n, 'c) ill = {         ill_nx        : X.nx
                        ; mutable ill_cfg       : 'c
                        }


type 'i node =
  | Boot
  | Ent of ('i, 'i node)              ent  
  | Exi of ('i, 'i node, 'i cfg)      exi  
  | Joi of ('i, 'i node, 'i cfg)      joi  
  | Ins of ('i, 'i node)              ins  
  | Ass of ('i, 'i node)              ass  
  | Bra of ('i, 'i node)              bra  
  | Cbr of ('i, 'i node)              cbr  
  | Mbr of ('i, 'i node)              mbr  
  | Cal of ('i, 'i node, 'i contedge) cal  
  | Cut of ('i, 'i node, 'i contedge) cut  
  | Ret of ('i, 'i node)              ret  
  | Jum of ('i, 'i node)              jum  
  | Imp of ('i, 'i node)              imp  
  | Ill of ('i, 'i node, 'i cfg)      ill  
@

<<graph and node observers implementation>>=
let kind node = match node with
  | Joi _ -> Join
  | Ins _ -> Instruction
  | Bra _ -> Branch
  | Cbr _ -> Cbranch
  | Mbr _ -> Mbranch
  | Jum _ -> Jump
  | Cal _ -> Call
  | Ret _ -> Return
  | Cut _ -> CutTo
  | Ent _ -> Entry
  | Exi _ -> Exit
  | Ass _ -> Assertion
  | Ill _ -> Illegal
  | Imp _ -> Impossible
  | Boot  -> undef "kind" "boot"

let is_join node = match node with
  | Joi _ | Exi _ -> true
  | _             -> false
let is_fork node = match node with
  | Cbr _ | Mbr _ | Cal _ | Cut _ | Imp _ -> true
  | _                                     -> false

let label node = match node with
  | Joi j -> (try List.hd j.joi_labels
              with Failure _ -> imposs "no labels at join")
  | Exi e -> ( log "label called on exit node"
             ; try List.hd e.exi_labels
               with Failure _ -> imposs "no labels at exit"
             )
  | _     ->  undef "label" "non-join"

let labels node = match node with
  | Joi j -> j.joi_labels
  | Exi e -> ( log "labels called on exit" ; e.exi_labels)
  | _     -> undef "labels" "non-join"

let to_instr node = match node with
  | Ins i -> Some i.ins_i
  | Ass a -> Some a.ass_i
  | Bra b -> Some b.bra_i
  | Cbr c -> Some c.cbr_i
  | Mbr m -> Some m.mbr_i
  | Cal c -> Some c.cal_i
  | Cut c -> Some c.cut_i
  | Jum j -> Some j.jum_i
  | Ret r -> Some r.ret_i
  | Ent _ -> None
  | Exi _ -> None
  | Joi _ -> None
  | Imp _ -> None
  | Ill _ -> None
  | Boot  -> undef "to_instr" "boot"

let pred node = match node with
  | Ins i -> i.ins_pred
  | Ass a -> a.ass_pred
  | Bra b -> b.bra_pred
  | Cbr c -> c.cbr_pred
  | Mbr m -> m.mbr_pred
  | Cal c -> c.cal_pred
  | Cut c -> c.cut_pred
  | Jum j -> j.jum_pred
  | Ret r -> r.ret_pred
  | Imp i -> i.imp_pred
  | Ent _ -> undef "pred" "entry"
  | Joi _ -> undef "pred" "join"
  | Exi _ -> undef "pred" "exit"
  | Ill _ -> undef "pred" "illegal"
  | Boot  -> undef "pred" "boot"

let tsucc node = match node with
  | Cbr c -> c.cbr_true
  | _     -> undef "tsucc" "non-cond-branch"
let fsucc node = match node with
  | Cbr c -> c.cbr_false
  | _     -> undef "fsucc" "non-cond-branch"


let succ_n node n =
  let fail ()    = raise (Invalid_argument "succ_n: illegal index") in
  let single s n = if n = 0 then s else fail ()                     in
  let mult a n   = try a.(n) with Invalid_argument _ -> fail ()     in
  match node with
  | Joi j -> single j.joi_succ n
  | Ins i -> single i.ins_succ n
  | Ass a -> single a.ass_succ n
  | Bra b -> single b.bra_succ n
  | Jum j -> single j.jum_succ n
  | Ret r -> single r.ret_succ n
  | Ent e -> single e.ent_succ n
  | Mbr m -> mult m.mbr_succs n
  | Cal c -> mult (ce_getnodes c.cal_contedges) n
  | Cut c -> mult (ce_getnodes c.cut_contedges) n
  | Cbr c ->
    if n = 0 then c.cbr_true
    else if n = 1 then c.cbr_false
    else fail ()
  | Imp i -> 
    if n = 0 then i.imp_succ
    else if n = 1 then i.imp_exit_succ
    else fail ()
  | Exi _ -> undef "succ_n" "exit"
  | Ill _ -> undef "succ_n" "illegal"
  | Boot  -> undef "succ_n" "boot"

let succ node = match node with
  | Ins i -> i.ins_succ
  | Ass a -> a.ass_succ
  | Joi j -> j.joi_succ
  | Bra b -> b.bra_succ
  | Jum j -> j.jum_succ
  | Ret r -> r.ret_succ
  | Ent e -> e.ent_succ
  | Mbr _ -> undef "succ" "multi branch"
  | Cbr _ -> undef "succ" "cond branch"
  | Cal _ -> undef "succ" "call"
  | Imp _ -> undef "succ" "impossible"
  | Cut _ -> undef "succ" "cut"
  | Exi _ -> undef "succ" "exit"
  | Ill _ -> undef "succ" "illegal"
  | Boot  -> undef "succ" "boot"

let get_cfg start_node =
  let rec search n badlist =
    if List.exists (eq n) badlist then
      imposs "cycle in cfg with no join node"
    else match n with
        | Exi e -> e.exi_cfg
        | Joi j -> j.joi_cfg
        | Ill i -> i.ill_cfg
        | n     -> search (succ_n n 0) (n::badlist) in (* relies on golden invariant *)
  search start_node []
@

We avoid showing duplicates to the client.
Duplicates are useful in the case when a multiway branch has multiple
branches to the same successor.
Without duplicates, it would be unpleasant to update the succ/pred list when
changing a branch.

<<graph and node observers implementation>>=
let preds node = match node with
  | Ins i -> [i.ins_pred]
  | Ass a -> [a.ass_pred]
  | Bra b -> [b.bra_pred]
  | Cbr c -> [c.cbr_pred]
  | Mbr m -> [m.mbr_pred]
  | Cal c -> [c.cal_pred]
  | Cut c -> [c.cut_pred]
  | Jum j -> [j.jum_pred]
  | Ret r -> [r.ret_pred]
  | Imp i -> [i.imp_pred]
  | Joi j -> uniq j.joi_preds
  | Exi e -> uniq e.exi_preds
  | Ent _ -> []
  | Ill _ -> []
  | Boot  -> undef "preds" "boot"

let succs node = match node with
  | Joi j -> [j.joi_succ]
  | Ins i -> [i.ins_succ]
  | Ass a -> [a.ass_succ]
  | Bra b -> [b.bra_succ]
  | Jum j -> [j.jum_succ]
  | Ret r -> [r.ret_succ]
  | Ent e -> [e.ent_succ]
  | Cbr c -> uniq [c.cbr_true; c.cbr_false]
  | Imp i -> uniq [i.imp_succ; i.imp_exit_succ]
  | Mbr m -> uniq (Array.to_list m.mbr_succs)
  | Cal c -> uniq (Array.to_list (ce_getnodes c.cal_contedges))
  | Cut c -> uniq (Array.to_list (ce_getnodes c.cut_contedges))
  | Exi _ -> []
  | Ill _ -> []
  | Boot  -> undef "succs" "boot"
@

The jump and return nodes are not interesting forms of control flow with
regards to a procedure's control-flow graph.

<<graph and node observers implementation>>=
let is_cti node = match node with
  | Bra _ | Cbr _ | Mbr _ | Cal _ | Cut _ -> true
  | _                                     -> false
let is_br node = match node with
  | Bra _ -> true
  | _     -> false
let is_cbr node = match node with
  | Cbr _ -> true
  | _     -> false
let is_mbr node = match node with
  | Mbr _ -> true
  | _     -> false
let is_call node = match node with
  | Cal _ -> true
  | _     -> false
let is_cut node = match node with
  | Cut _ -> true
  | _     -> false

let jx node = match node with
  | Joi j -> j.joi_jx
  | Exi e -> e.exi_jx 
  | _     -> undef "jx" "non-join"

let fx node = match node with
  | Cbr c -> c.cbr_fx
  | Mbr m -> m.mbr_fx
  | Cal c -> c.cal_fx 
  | Cut c -> c.cut_fx
  | Imp i -> i.imp_fx
  | _     -> undef "fx" "non-fork"

let nx node = match node with
  | Ins i -> i.ins_nx
  | Ass a -> a.ass_nx
  | Bra b -> b.bra_nx
  | Jum j -> j.jum_nx
  | Ret r -> r.ret_nx
  | Ent e -> e.ent_nx
  | Ill i -> i.ill_nx
  | _     -> undef "nx" "fork and join"

let entry cfg = cfg.entry
let exit  cfg = cfg.exit

let fold_over_preds f n zero = List.fold_right f (preds n) zero
let fold_over_succs f n zero = List.fold_right f (succs n) zero

let fold_heads f zero cfg = List.fold_right f (heads cfg) zero
let fold_nodes f zero cfg =
  let rec fold_bb f node zero =
    if is_join node then zero
    else fold_over_succs (fold_bb f) node (f node zero) in
  fold_heads (fun head zero -> fold_bb f (succ head) (f head zero))
             (f cfg.exit zero) cfg

let iter_nodes f = fold_nodes (fun n () -> f n) ()
let iter_heads f = fold_heads (fun n () -> f n) ()

(* should this fn be defined on exi and ill?
   when there are cont edges, do we still need to cover the regular edges?*)
let union_over_outedges node ~noflow ~flow =
  let union_contedges ce =
    Array.fold_left (fun r s -> RS.union r (flow s)) RS.empty ce in
  match node with
  | Cal c -> union_contedges c.cal_contedges
  | Cut c -> union_contedges c.cut_contedges
  | Cbr c -> RS.union (noflow c.cbr_true) (noflow c.cbr_true)
  | Imp i -> RS.union (noflow i.imp_succ) (noflow i.imp_exit_succ)
  | Mbr m ->
    Array.fold_right (fun s -> RS.union (noflow s)) m.mbr_succs RS.empty
  | Ins i -> noflow i.ins_succ
  | Ass a -> noflow a.ass_succ
  | Bra b -> noflow b.bra_succ
  | Jum j -> noflow j.jum_succ
  | Ret r -> noflow r.ret_succ
  | Ent e -> noflow e.ent_succ
  | Joi j -> noflow j.joi_succ
  | Exi e -> RS.empty
  | Ill i -> RS.empty
  | Boot  -> imposs "union_over_outedges undefined on boot nodes"
  
let add_inedge_uses node regs = match node with
  | Cal c -> RS.union regs c.cal_uses
  | Cut c -> RS.union regs c.cut_uses
  | Jum j -> RS.union regs j.jum_uses
  | Ret r -> RS.union regs r.ret_uses
  | _     -> regs
@ 
The only graph mutation occurs via the set successors functions. 
The rest of the CFG implementation also uses these mutators.
<<set successors>>=
let node_labeled cfg label =
  try SM.find label cfg.label_map
  with Not_found ->
    let join = Joi { joi_labels = [label]
                   ; joi_cfg    = cfg
                   ; joi_preds  = []
                   ; joi_succ   = cfg.ill
                   ; joi_lpred  = cfg.ill
                   ; joi_jx     = X.jx ()
                   } in
    let () = cfg.label_map <- SM.add label join cfg.label_map in
    join
@
The successor of a branch node must be a join point.
[[join_leading_to]] inserts such a join point, if necessary.
The proper successor (a join point) is then returned.
<<set successors>>=
let rec join_leading_to ~succ =
  if is_join succ then succ
  else let p = pred succ in (* p must not be a fork b/c succ is not a join *)
       if is_join p then p
       else let cfg  = get_cfg succ in
            let join = node_labeled cfg (cfg.mk_label "join") in
            let () = if not (is_ill p) then set_succ p ~succ:join in
            let () = set_succ join ~succ:succ in  (* maybe use set_succ here? *)
            join
@
This black magic was on NR's whiteboard, but it still needs to be
explained :-)
<<set successors>>=
and set_succ' ~single ~ce_mult ~mult ~cbr ~node ~old_succ ~succ =
  if not (is_join succ) && not (is_ill succ) && not (is_ill (pred succ)) then
    set_succ' ~single ~ce_mult ~mult ~cbr ~node ~old_succ ~succ:(join_leading_to succ)
  else
    begin
      ( (<<modify the $n$th successor of [[node]] because [[node]] is no longer a predecessor>>)
      ; (if not (is_ill succ)
         then <<modify [[succ]] because [[node]] has become a predecessor>>
        )
      ; (<<update [[node]]'s $n$th successor field to point to [[succ]]>>)
      )
    end
@
<<update [[node]]'s $n$th successor field to point to [[succ]]>>=
match node with
| Joi j -> j.joi_succ <- single succ
| Ins i -> i.ins_succ <- single succ
| Ass a -> a.ass_succ <- single succ
| Jum j -> j.jum_succ <- single succ
| Ret r -> r.ret_succ <- single succ
| Ent e -> e.ent_succ <- single succ
| Mbr m -> ignore (mult m.mbr_succs        (fun _ -> succ))
| Cal c -> ignore (ce_mult c.cal_contedges (fun s -> {s with node = succ}))
| Cut c -> ignore (ce_mult c.cut_contedges (fun s -> {s with node = succ}))
| Bra b ->
  let succ = join_leading_to succ in
  ( b.bra_i <- (get_cfg node).inst_info.goto.Ep.embed (label succ)
  ; b.bra_succ <- single succ
  )
| Cbr c -> 
  let succ = join_leading_to succ in
  let cfg = get_cfg node in
  (if cbr () then
     c.cbr_true  <- succ
   else
     c.cbr_false <- succ
  );
  let (cond, _) = cfg.inst_info.branch.Ep.project c.cbr_i in
  c.cbr_i <- cfg.inst_info.branch.Ep.embed (cond, label c.cbr_true)

| Imp i ->
  let succ = join_leading_to succ in
  if cbr () then i.imp_succ <- succ
  else if is_exi succ then i.imp_exit_succ <- succ
  else imposs "exit_succ must be an exit node"
| Exi _ -> undef "set_succ" "exit"
| Ill _ -> undef "set_succ" "illegal"
| Boot  -> undef "set_succ" "boot"
@ 


<<modify the $n$th successor of [[node]] because [[node]] is no longer a predecessor>>=
let rec rem_1_list lst = match lst with
  | [] -> imposs "remove_pred: predecessor to be removed not found"
  | n::rst when eq n node -> rst
  | n::rst -> n :: rem_1_list rst in
let rem_1_list l =
  try rem_1_list l
  with _ ->
    imposs ("Error removing node from list with " ^ string_of_int (List.length l) ^ " nodes") in
match old_succ with
| Joi j -> j.joi_preds <- rem_1_list j.joi_preds
| Exi e -> e.exi_preds <- rem_1_list e.exi_preds
| Ins i -> i.ins_pred  <- (get_cfg old_succ).ill
| Bra b -> b.bra_pred  <- (get_cfg old_succ).ill
| Cbr c -> c.cbr_pred  <- (get_cfg old_succ).ill
| Mbr m -> m.mbr_pred  <- (get_cfg old_succ).ill
| Jum j -> j.jum_pred  <- (get_cfg old_succ).ill
| Cal c -> c.cal_pred  <- (get_cfg old_succ).ill
| Ret r -> r.ret_pred  <- (get_cfg old_succ).ill
| Cut c -> c.cut_pred  <- (get_cfg old_succ).ill
| Ass a -> a.ass_pred  <- (get_cfg old_succ).ill
| Imp i -> i.imp_pred  <- (get_cfg old_succ).ill
| Ill _ -> ()
| Ent _ -> imposs "entry node was a successor"
| Boot  -> imposs "boot nodes should not live to remove_pred"
@
<<modify [[succ]] because [[node]] has become a predecessor>>=
let join_pred cur_preds = match cur_preds with
  | [Ill _] -> [node]
  | _       -> node::cur_preds in
match succ with
| Ins i -> i.ins_pred  <- node
| Ass a -> a.ass_pred  <- node
| Bra b -> b.bra_pred  <- node
| Jum j -> j.jum_pred  <- node
| Ret r -> r.ret_pred  <- node
| Imp i -> i.imp_pred  <- node
| Cbr c -> c.cbr_pred  <- node
| Mbr m -> m.mbr_pred  <- node
| Cal c -> c.cal_pred  <- node
| Cut c -> c.cut_pred  <- node
| Exi e -> e.exi_preds <- join_pred e.exi_preds
| Joi j -> j.joi_preds <- join_pred j.joi_preds
| Ent e -> imposs "something tried to become a predecessor of the entry node"
| Ill i -> imposs "client can make a pointer dangle, but believed to be handled above"
| Boot  -> undef "add_pred" "boot"
@

<<set successors>>=
and set_succ_n node n ~succ:succ =
  set_succ'
    ~single:(if n = 0 then (fun s -> s) else (fun s -> invalid_arg "successor index"))
    ~ce_mult: (fun a f -> let s = a.(n) in a.(n) <- f s; s)
    ~mult:  (fun a f -> let s = a.(n) in a.(n) <- f s; s)
    ~cbr:   (if n = 0 then (fun () -> true) else if n = 1 then (fun () -> false)
             else fun () -> invalid_arg "successor index")
    ~node ~old_succ:(succ_n node n) ~succ
and set_succ node ~succ:the_succ =
  set_succ'
    ~single: (fun s -> s)
    ~ce_mult:   (fun a f -> undef "set_succ" "multiple node not o/w specified")
    ~mult:   (fun a f -> undef "set_succ" "multiple node not o/w specified")
    ~cbr:    (fun () ->  undef "set_succ" "fork")
    ~node ~old_succ:(succ node) ~succ:the_succ
@

<<set successors>>=
let set_tsucc node ~succ = match node with
  | Cbr _ -> set_succ_n node 0 ~succ
  | _     -> undef "set_tsucc" "non-cond-branch"
let set_fsucc node ~succ = match node with
  | Cbr _ -> set_succ_n node 1 ~succ
  | _     -> undef "set_fsucc" "non-cond-branch"
@


For a node with a single predecessor, [[add_node]] will set that predecessor to
[[pred]].
For nodes with multiple predecessors, [[add_node]] will add [[pred]] to the
list (unless the list consists of a single illegal node, in which case [[pred]]
becomes the only predecessor).

<<graph and node mutators implementation>>=
let start_transaction cfg name = ()
let end_transaction cfg = ()

let invert_cbr node = match node with
  | Cbr c ->
    let cfg = get_cfg node in
    let new_true = c.cbr_false in
    ( set_fsucc node ~succ:c.cbr_true
    ; set_tsucc node ~succ:new_true
    )
  | _     -> undef "invert_cbr" "non-cond-branch"

let splice_before ~entry ~exit node =
  (set_succ (pred node) ~succ:entry ; set_succ exit ~succ:node)

let splice_after ~entry ~exit node =
  (set_succ node ~succ:entry ; set_succ exit ~succ:(succ node))

(* what should this do on Bra? *)
let delete node = set_succ (pred node) ~succ:(succ node)

let update_instr upd node = match node with
  | Ins i -> i.ins_i <- upd i.ins_i
  | Ass a -> a.ass_i <- upd a.ass_i
  | Bra b -> b.bra_i <- upd b.bra_i
  | Jum j -> j.jum_i <- upd j.jum_i
  | Ret r -> r.ret_i <- upd r.ret_i
  | Mbr m -> m.mbr_i <- upd m.mbr_i
  | Cal c -> c.cal_i <- upd c.cal_i
  | Cut c -> c.cut_i <- upd c.cut_i
  | Cbr c -> c.cbr_i <- upd c.cbr_i
  | Joi j -> ()
  | Ent e -> ()
  | Exi _ -> ()
  | Imp i -> ()
  | Ill _ -> ()
  | Boot  -> imposs "update_instr undefined on boot nodes"
@


<<graph construction and copying>>=
let mk i_info label_supply =
  let entry = { ent_succ = Boot
              ; ent_nx   = X.nx ()
              } in
  let cfg = { entry     = Ent entry
            ; exit      = Boot
            ; ill       = Boot
            ; inst_info = i_info
            ; label_map = SM.empty
            ; mk_label  = label_supply
            } in
  let ill = illegal cfg in
  let exit  = Exi { exi_cfg  = cfg
                  ; exi_labels = [label_supply "exit"]
                  ; exi_preds = []
                  ; exi_lpred = ill
                  ; exi_jx   = X.jx ()
                  } in
  let ()  = cfg.ill        <- ill in
  let ()  = entry.ent_succ <- ill in
  let ()  = cfg.exit       <- exit in
  cfg

let copy info transform cfg =
  let new_cfg = { entry     = Boot
                ; exit      = Boot
                ; ill       = Boot
                ; inst_info = info
                ; label_map = SM.empty
                ; mk_label  = cfg.mk_label
                } in
  let ()  = new_cfg.ill <- illegal new_cfg in
  let convert node succ =
    let lookup join = assert false in
    (*
      try SM.find (label join) new_cfg.label_map
      with Not_found -> 
      *)

    (*
      try  (SM.find (label join) new_cfg.label_map, map)
      with Not_found _ ->
        let join' = node_labeled new_cfg (label join) in
        match join' with
        | Joi j' -> j'.joi_labels <- j.joi_labels
        | _      -> imposs "error in copying join point"

      in
      *)
    let ce_lookup ce =
      let n' = lookup ce.node in
      {ce with node = n'} in
    let update_contedges contedges =
      Array.map ce_lookup contedges in
    match node with
    | Ins i -> instruction new_cfg (transform i.ins_i) ~succ
    | Ass a -> assertion   new_cfg (transform a.ass_i) ~succ
    | Bra b -> branch      new_cfg ~target:(lookup b.bra_succ)
    | Jum j -> jump        new_cfg (transform j.jum_i) ~uses:j.jum_uses
                                   ~targets:[]
    | Cbr c ->
      let (cond, _) = cfg.inst_info.branch.Ep.project c.cbr_i in
      cbranch new_cfg cond ~ifso:(lookup c.cbr_true)
                           ~ifnot:(lookup c.cbr_false)
    | Ret r -> return      new_cfg (transform r.ret_i) ~uses:r.ret_uses
    | Imp i -> impossible  new_cfg ~succ
    | Ill i -> illegal     new_cfg
    | Mbr m ->
      mbranch new_cfg (transform m.mbr_i)
       ~targets:(Array.fold_right (fun t rst -> lookup t :: rst)
                                  m.mbr_succs [])
    | Cal c -> (* We can't extract the input to the call constructor *)
      let ce_lst          = update_contedges c.cal_contedges in
      Cal { cal_i         = transform c.cal_i
          ; cal_spans     = c.cal_spans
          ; cal_pred      = illegal new_cfg
          ; cal_contedges = ce_lst
          ; cal_fx        = X.fx ()
          ; cal_uses      = c.cal_uses
          }
    | Cut c ->
      let cuts_to = Array.to_list (update_contedges c.cut_contedges) in
      cut_to new_cfg (transform c.cut_i) ~cuts_to ~aborts:false ~uses:c.cut_uses
    | Joi j -> lookup j
    | Exi e -> Exi { e with exi_cfg   = new_cfg
                   ;        exi_preds = []
                   ;        exi_lpred = illegal new_cfg
                   ;        exi_jx    = X.jx ()
                   }
    | Ent e -> Ent { ent_succ = succ
                   ; ent_nx   = X.nx ()
                   }
    | Boot  -> undef "copy" "boot" in
    new_cfg
@

<<node constructors with interesting control flow edges>>=
let join_leading_to_ce ce = {ce with node = join_leading_to ce.node}

let call cfg i ~altrets ~succ ~unwinds_to ~cuts_to ~aborts ~uses ~defs ~kills
               ~spans =
  let () = if List.length altrets > 0
           then Impossible.unimp "alternate returns not yet supported" in
  let altrets     = List.map join_leading_to_ce altrets in
  let unwinds_to  = List.map join_leading_to_ce unwinds_to in
  let cuts_to     = List.map join_leading_to_ce cuts_to in
  let altrets     = List.map join_leading_to_ce altrets in
  let new_cedge n = {kills = kills; defs = defs; node = n} in
  let succ        = [new_cedge succ] in
  let abort       = if aborts then [new_cedge cfg.exit] else [] in
  let edgelist    = List.flatten [altrets; succ; unwinds_to; cuts_to; abort] in
  let illedge     = fun {kills=k; defs=d; node=n} -> {kills=k; defs=d; node=cfg.ill} in
  let cal =
    Cal { cal_i         = i
        ; cal_spans     = spans
        ; cal_pred      = cfg.ill
        ; cal_contedges = Array.of_list (List.map illedge edgelist)
        ; cal_fx        = X.fx ()
        ; cal_uses      = uses
        } in
  let ()  = Aux.foldri (fun i n () -> set_succ_n cal i ~succ:n.node)
                       edgelist () in
  cal

let cut_to cfg i ~cuts_to ~aborts ~uses =
  let cuts_to     = List.map join_leading_to_ce cuts_to in
  let new_cedge n = {kills = RS.empty; defs = RS.empty; node = n} in
  let aborts      = if aborts then [new_cedge cfg.exit] else [] in
    (* UNKNOWN WHETHER EDGE TO EXIT MUST KILL NVR'S.  LET US HOPE NOT. *)
  let edgelist    = List.flatten [cuts_to; aborts] in
  let illedge     = fun {kills=k; defs=d; node=n} -> {kills=k; defs=d; node=cfg.ill} in
  let cut = Cut { cut_i         = i
                ; cut_pred      = cfg.ill
                ; cut_lsucc     = cfg.ill
                ; cut_contedges = Array.of_list (List.map illedge edgelist)
                ; cut_fx        = X.fx ()
                ; cut_uses      = uses
                } in
  let ()  = Aux.foldri (fun i n () -> set_succ_n cut i ~succ:n.node) edgelist () in
  cut
@

<<simple node constructors>>=
let instruction cfg i ~succ =
  let ins = Ins { ins_i    = i
                ; ins_pred = cfg.ill 
                ; ins_succ = cfg.ill
                ; ins_nx   = X.nx ()
                } in
  let ()  = set_succ ins ~succ:succ in
  ins

let assertion cfg i ~succ =
  let ass = Ass { ass_i    = i
                ; ass_pred = cfg.ill 
                ; ass_succ = cfg.ill
                ; ass_nx   = X.nx ()
                } in
  let ()  = set_succ ass ~succ:succ in
  ass

let branch cfg ~target =
  let succ = join_leading_to ~succ:target in
  let bra = Bra { bra_i     = cfg.inst_info.goto.Ep.embed (label succ)
                ; bra_pred  = cfg.ill
                ; bra_succ  = cfg.ill
                ; bra_lsucc = succ
                ; bra_nx    = X.nx ()
                } in
  let ()  = set_succ bra ~succ:succ in
  bra

(* SHOULD WE ASSERT THAT THESE TARGETS ARE JOIN POINTS? *)
let jump cfg i ~uses ~targets =
  let jum = Jum { jum_i     = i
                ; jum_pred  = cfg.ill
                ; jum_succ  = cfg.ill
                ; jum_lsucc = cfg.ill
                ; jum_nx    = X.nx ()
                ; jum_uses  = uses
                } in
  let ()  = set_succ jum ~succ:cfg.exit in
  jum

let cbranch cfg cond ~ifso ~ifnot =
  let so_succ  = join_leading_to ~succ:ifso in
  let not_succ = join_leading_to ~succ:ifnot in
  let cbr = Cbr { cbr_i     = cfg.inst_info.branch.Ep.embed
                                    (cond, (label so_succ))
                ; cbr_pred  = cfg.ill
                ; cbr_true  = cfg.ill
                ; cbr_false = cfg.ill
                ; cbr_fx    = X.fx ()
                } in
  let ()  = set_tsucc cbr ~succ:so_succ  in
  let ()  = set_fsucc cbr ~succ:not_succ in
  cbr

let mbranch cfg i ~targets =
  let targets = List.map (fun succ -> join_leading_to ~succ) targets in
  let succs   = Array.make (List.length targets) cfg.ill in
  let mbr     = Mbr { mbr_i     = i
                    ; mbr_pred  = cfg.ill
                    ; mbr_succs = succs
                    ; mbr_lsucc = cfg.ill
                    ; mbr_fx    = X.fx ()
                    } in
  let () = Aux.foldri (fun i n () -> set_succ_n mbr i ~succ:n) targets () in
  mbr

let return cfg i ~uses =
  let ret = Ret { ret_i     = i
                ; ret_pred  = cfg.ill
                ; ret_succ  = cfg.ill
                ; ret_lsucc = cfg.ill
                ; ret_nx    = X.nx ()
                ; ret_uses  = uses
                } in
  let ()  = set_succ ret ~succ:cfg.exit in
  ret

let impossible cfg ~succ =
  let succ = join_leading_to succ in
  let imp  = Imp { imp_pred      = cfg.ill
                 ; imp_succ      = cfg.ill
                 ; imp_exit_succ = cfg.ill
                 ; imp_fx        = X.fx ()
                 } in
  let ()   = set_succ   imp   ~succ:succ     in
  let ()   = set_succ_n imp 1 ~succ:cfg.exit in
  imp

let illegal cfg = Ill { ill_nx  = X.nx ()
                      ; ill_cfg = cfg
                      }
@
Node equality is the most important utility of all.
We cannot safely compare nodes with [[==]], because the node type is
an algebraic data type, and the Caml implementation is free to
consider two nodes unequal even if they are both obtained by, e.g.,
[[Ins r]].
On the other hand, we cannot use~[[=]] because it is structural
equality, and it is not guaranteed to terminate when applied to a
structure with cycles.
We therefore roll our own, using [[==]] only on the mutable record
types, where we know it is safe.
<<graph utilities>>=
let eq node node' = match node, node' with
  | Joi r, Joi r' -> r == r'
  | Ins r, Ins r' -> r == r'
  | Bra r, Bra r' -> r == r'
  | Cbr r, Cbr r' -> r == r'
  | Mbr r, Mbr r' -> r == r'
  | Jum r, Jum r' -> r == r'
  | Cal r, Cal r' -> r == r'
  | Ret r, Ret r' -> r == r'
  | Cut r, Cut r' -> r == r'
  | Ent r, Ent r' -> r == r'
  | Exi r, Exi r' -> r == r'
  | Ass r, Ass r' -> r == r'
  | Ill r, Ill r' -> r == r'
  | Imp r, Imp r' -> r == r'
  | Boot,  Boot   -> true
  | _,     _      -> false
@ 
<<graph utilities>>=
let imposs = Impossible.impossible
let undef f n = imposs (Printf.sprintf "%s: undefined on %s nodes" f n)
let log m = ()
let uniq lst =
  List.fold_left (fun rst n1 -> if List.exists (eq n1) rst
                                then rst else n1::rst)
                 [] lst

let is_ill node = match node with
  | Ill _ -> true
  | _     -> false

let is_exi node = match node with
  | Exi _ -> true
  | _     -> false

let ce_getnodes ce = Array.map (fun ce -> ce.node) ce
@

We merge two join points by combining the information in the second
([[keep]]) node.
We also mutate the first join point ([[j1]]) to share the fields of
the second join point.

<<graph utilities>>=
let merge_joins j1 j2 succ lpred = match j1, j2 with
  | Joi j1, Joi j2 ->
    { joi_labels = j1.joi_labels @ j2.joi_labels
    ; joi_cfg    = j1.joi_cfg
    ; joi_preds  = j1.joi_preds  @ j2.joi_preds
    ; joi_succ   = j2.joi_succ
    ; joi_lpred  = j2.joi_lpred
    ; joi_jx     = j2.joi_jx
    }
  | _                -> undef "merge_joins" "non-join"
@

Creation of illegal nodes is common.

<<graph utilities>>=
let heads cfg = cfg.entry :: SM.fold (fun _ h rst -> h::rst) cfg.label_map []
@


Missing stuff:
\begin{itemize}
\item
 impossible edges on infinite loops
\item
 unclear what users can do with assertions
\item
 unclear what users can do with spans
\end{itemize}

