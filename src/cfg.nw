% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et: 
% Daddy, why are we hiding from the police? They use Emacs, son, we use Vi.
% Cheese it!  The cops!!!
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% 
% $Id$

% inc: \usepackage{nchicago}

% ------------------------------------------------------------------ 
\section{Control-Flow Graph Revisions}
% ------------------------------------------------------------------ 

Here are some possible revisions to the flow graph.
\begin{itemize}
\item
Make predecessor and successor fields mutable.
This change gives a client substantially greater freedom to choose the
order in which nodes are constructed.
\item
Introduce the idea of \emph{layout}.
A graph \emph{has layout} if the physical order of instructions and
labels is known.
A graph must have layout before it is passed to an assembler.

Except for branch nodes as specified below, if a node has a unique
successor, then the node precedes its successor in the physical layout.
\item
Restrict types of nodes in the hopes of simplifying algorithms.
The grossest classification is by numbers of predecessors and
successors. 
\begin{itemize}
\item
A \emph{join point} has arbitrarily many precedessors and exactly one
successor. 
It is associated with a list of \emph{labels} but no code.
A join point is the only node with multiple predecessors.
\remark{Question for Glenn: how to represent the successor list?  How
much space do you allocate for successors whan you don't yet know how
many there will be?}
\item
An \emph{straight-line code} node has exactly one predecessor and one
successor. 
It models computation without interesting control flow.
\item
A \emph{branch node} performs a goto but is intended to implement no
other useful computation.
It has a unique predecessor and a unique successor.
Its successor must be a join point.
If the graph has layout, the branch node also has a layout successor,
which may be different from its control-flow successor.
The RTL of a branch node is an unconditional assignment to the program
counter. 
\item
A \emph{jump} node is a lot like a branch except its successor is the
exit node
\item
A \emph{conditional branch} has a unique predecessor and two
successors, which are labeled true and false.
Each successor must be a join point.
It contains an RTL that normally satisfies the following properties:
\begin{itemize}
\item
It contains a single effect, which is a guarded assignment to the
program counter.
\item
The value assigned to the program counter is a label (link-time
constant) associated with the join point that is the true successor.
\end{itemize}
If the second property is not satisfied, we say the node is
\emph{dirty}.
The node must be clean before it can be passed to an assembler.

If the graph has layout, the layout successor of a branch node must
be its false successor.

It is legitimate at any time to perform the following changes as one
atomic operation:
\begin{itemize}
\item
Swap the true and false successors
\item
Negate the condition on the guard
\item
Replace the label in the assignment with the new true successor.
\end{itemize}
The [[bnegate]] operation in the postexpander interface is useful here.
\item
A node with multiple successors is a \emph{multiway branch}.
It has a unique predecessor.
There are several kinds of multiway branch.
\begin{itemize}
\item
Call
\item
Computed goto
\item
\emph{Cut to}.
Normally has a single successor (the exit) but may have multiple
successors. 
\end{itemize}
\item
THERE ARE NO DATAFLOW NODES.  INSTEAD, A NODE MAY CONTRIBUTE DEFS,
AND KILLS TO EACH OUTEDGE, AND A NON-JOIN NODE MAY CONTRIBUTE
USES TO ITS UNIQUE INEDGE.
\item
The entry node has a successor but no predecessor
\item
The exit node has a predecessor but no successor (or perhaps it should
be a join point)?
\item
An \emph{illegal} node has no predecessors and no successors.
It is used to initialize mutable successor and predecessor fields.
\end{itemize}
\item
An infinite loop must contain an artificial edge so it can reach the
exit.

\end{itemize}
@ 

\section{Goals}

This section lists our goals for the control-flow graph.  
It is cribbed from a similar section in the documentation for Machine
SUIF. 
\begin{itemize}
\item
\emph {Analysis.}
Many compiler analyses assume a flow graph as a basic data
structure. 
Such analyses include
liveness analysis, reaching definitions,
and dead-code identification.
We provide the ability to traverse and observe the nodes and edges in
the flow graph.
\item
\emph{Transformation.}
We also want to support control-flow transformation, e.g., by merging
instructions, moving code out of loops, various forms of redundancy
elimination, and so on.
Davidson-style code expansion may also involve rewriting Boolean
operations into control flow.
\item
\emph {Simple ordering.}
To be able to emit a program, 
we provide minimal support for mapping the flow graph onto an ordered
list of code, data, and labels.
While we wouldn't mind supporting automated code layout and
code-layout optimizations, it is not a high priority.
Furthermore, and following Machine SUIF, we make it possible to
manipulate a flow graph that has no layout in memory---we require only
that a layout be established before code is emitted.
\item
\emph{Minimize burden on clients.}
We minimize the number of checked and unchecked run-time errors a
client can commit.
This policy may make the flow graph more complex and more expensive,
but we believe it is better that this abstraction do as much of the
hard work as possible.
\end{itemize}


\section{The Control-Flow Graph}

Quick~{\PAL} uses a control-flow graph to represent a procedure.
The flow-graph abstraction is inspired by \citeN{knoop:basic-block},
who described the basic-block control-flow graph as a ``living
dinosaur.''
Accordingly, our flow graph does not use basic blocks; each node
represents at most one instruction.

This abstraction actually represents \emph{two} graphs: a control-flow
graph and a physical-layout graph.
A~\emph{control-flow edge} indicates the possibility that control may flow
from one node to another during the dynamic execution of a program.
A~\emph{layout edge} indicates that the code for one node
appears before the code for another node in the image (assembly or binary)
that is written to the output.\footnote
{N.B.~The code for a third node may intervene.}
When we refer to an unqualified edge, predecessor, or successor, we
always refer to the control-flow graph, not to the layout graph.

We classify a node according to the number of predecessors and
successors it may have, and also according to the \emph{payload} it
may carry.
\begin{itemize}
\item
A \emph{join point} has arbitrarily many precedessors and exactly one
successor. 
Its payload is one or more \emph{labels} but no code.
A join point is the only node with multiple predecessors.
The layout successor a join point is its control-flow successor.

The graph maintains the following invariant: the sucessor of a join
point is never a join point.
The graph transparently merges join points as needed to maintain this
invariant, so it is safe for a graph-creation client to hang on to an
old join point. 
A graph-analysis client, however, should be cautioned about comparing
to an old join point if the graph has changed.
\item
An \emph{ordinary instruction} has one predecessor and one successor.
Its payload is one instruction.
Its layout successor is its control-flow successor.
\item
An \emph{assertion} is just like an ordinary instruction, except that it generates
no code.
Instead, it simply asserts that the effect of the instruction has
taken place.
Its purpose is to sit on an interprocedural control-flow edge, so we
have a way of recording what a callee did to a stack pointer, for
example. 
\item
A \emph{control-flow} instruction has one predecessor and one or more
successors. 
Every successor must be a join point.
There are a variety of control-flow instructions with different
numbers of successors and different constraints on layout.
\begin{itemize}
\item
A \emph{branch node} performs a goto but is intended to implement no
other useful computation.
It has a unique predecessor and a unique successor.
Its layout successor may be different from its control-flow successor.
The standard RTL of a branch node is an unconditional assignment to the program
counter. 
\item
A \emph{jump} node is a lot like a branch except its successor is the
exit node, which is considered a join point \emph{ex officio}. 
\item
A \emph{conditional branch} has two
successors, which are labeled true and false.
It contains an RTL that normally satisfies the following properties:
\begin{itemize}
\item
It contains a single effect, which is a guarded assignment to the
program counter.
\item
The value assigned to the program counter is a label (link-time
constant) associated with the join point that is the true successor.
\end{itemize}
If the second property is not satisfied, we say the node is
\emph{dirty}.\footnote{We can and should prevent the node from ever
becoming dirty.}
The node must be clean before it can be passed to an assembler.

If the graph has layout, the layout successor of a branch node must
be its false successor.

It is legitimate at any time to perform the following changes as one
atomic operation:
\begin{itemize}
\item
Swap the true and false successors
\item
Negate the condition on the guard
\item
Replace the label in the assignment with the new true successor.
\end{itemize}
The [[bnegate]] operation in the postexpander interface is useful here.
\item
A computed goto with multiple successors is a \emph{multiway branch}.
Its layout successor is unconstrained.
\item 
A \emph{call} node has many successors, which are listed in this
order:
alternate return continuations, normal return, unwind continuations,
cut-to continuations. 
Its layout successor must implement the alternate return
continuations, if any, and the successor after that must be the normal
return continuations.
(If there are no alternate return continuations, the direct successor
implements the normal return continution.)
\item
A \emph{cut to} node
normally has a single successor (the exit) but may have multiple
successors. 
Its layout successor is unconstrained. 
\end{itemize}
\item
The entry node has a successor but no predecessor
\item
The exit node has one or more predecessors but no successor.
It is therefore considered a kind of join point.
\item
An \emph{illegal} node has no predecessors and no successors.
It is used to initialize mutable successor and predecessor fields.
\item
An \emph{impossible} node has two successors.
Its ordinary successor is its layout successor.
Its impossible successor is always the exit node.
(It exists to facilitate solution of backward dataflow problems, such
as liveness.)
An infinite loop must contain an impossible node so it can reach the
exit.
\end{itemize}

\section{Interface}

TO TRY: REMOVE THE GRAPH PARAMETER FROM AS MANY NODE-CREATION ROUTINES AS POSSIBLE.
A SUCCESSOR ALREADY PROVIDES THE GRAPH!!
<<cfg.mli>>=
<<exported signatures>>
<<exported signatures>>=
module type X = sig
  type jx  (* extension at join point *)
  type fx  (* extension at fork point *)
  type nx  (* extension at all nodes (including fork/join) *)
  val jx : unit -> jx
  val fx : unit -> fx
  val nx : unit -> nx
end

module type S = sig
  module X : X

  type label = string

  type 'i cfg
  type 'i node
  type regs = Register.Set.t (* sets of regs for dataflow *)
  type 'i contedge = { kills:regs; defs:regs; node:'i node }
  type kind = (* all the kinds of nodes *)
    | Boot' | Join | Instruction | Branch | Cbranch | Mbranch
    | Jump  | Call | Return | CutTo
    | Entry | Exit | Assertion | Illegal | Impossible
  <<graph and node observers>>
  <<graph and node constructors>>  
  <<graph and node mutators>>
end
@ 
<<cfg.mli>>=
module Make (X:X) : S with module X = X
@
\subsection{Interface summary}
Details are given below, but here are the observers:
<<graph and node observers>>=
@  
Here are the mutators:
<<graph and node mutators>>=
@  
Here are the constructors:
<<graph and node constructors>>=
@
\subsection{Observers}

\paragraph{Observing nodes}
We can ask about the kind of a node.
<<graph and node observers>>=
val kind       : 'i node -> kind
@ 
We can also ask particular predicates that relate to the kind.
<<graph and node observers>>=
val is_join    : 'i node -> bool
val is_fork    : 'i node -> bool
@ 
We can ask for a label, or for all the labels, on a join node.
<<graph and node observers>>=
val label      : 'i node -> label      (* defined on any join node except exit *)
val labels     : 'i node -> label list (* defined on any join node except exit *)
@ 
We can ask for the instruction, if any.
<<graph and node observers>>=
val to_instr   : 'i node -> 'i option
@ 
We can ask about the unique predecessor of a non-join node.
It is a checked run-time error to call this function on a join,
exit, entry, or illegal node.
Similarly, we can ask about the unique successor of a non-fork node.
<<graph and node observers>>=
val pred       : 'i node -> 'i node  (* defined on non-join, non-exit *)
val succ       : 'i node -> 'i node  (* defined on non-fork *)
@
We can ask about the true and false successor of a conditional branch.
It is a checked run-time error to call these functions on anything
other than a conditional branch.
<<graph and node observers>>=
val tsucc      : 'i node -> 'i node  (* defined on conditional branch *)
val fsucc      : 'i node -> 'i node  (* defined on conditional branch *)
@
We can ask for any successor by number, for any kind of node.
Successors are numbered from zero, the true successor precedes the
false successor (0~and~1), and the numbering for calls is
complicated. 
Function [[succ_n]] raises [[Invalid_argument]] if [[n]]~is
negative or too large.  
<<graph and node observers>>=
val succ_n     : 'i node -> int -> 'i node  (* defined on any node *)
@
For any kind of node, we can ask for all its successors and
predecessors.
<<graph and node observers>>=
val preds      : 'i node -> 'i node list  (* defined on any node *)
val succs      : 'i node -> 'i node list  (* defined on any node *)
@
We can ask about the kinds of control-flow instructions.
<<graph and node observers>>=
val is_cti     : 'i node -> bool  (* is any control-flow 'i node *)
val is_br      : 'i node -> bool  (* is direct branch *)
val is_cbr     : 'i node -> bool  (* is conditional branch *)
val is_mbr     : 'i node -> bool  (* is multiway branch *)
val is_call    : 'i node -> bool
val is_cut     : 'i node -> bool
@ 
We can get an extension suitable for the kind of node.
<<graph and node observers>>=
val jx         : 'i node -> X.jx  (* defined only on join nodes *)
val fx         : 'i node -> X.fx  (* defined only on fork nodes *)
val nx         : 'i node -> X.nx  (* defined only on non-fork, non-join *)
@ 
\paragraph{Observing the graph}
We can get the entry and exit nodes.
<<graph and node observers>>=
val entry      : 'i cfg -> 'i node
val exit       : 'i cfg -> 'i node
@ 
We can observe all the nodes.
We do so by providing higher-order functions.
These functions work by enumerating  \emph{basic blocks}.
A basic
block is a sequence of nodes beginning in a \emph{head node} (a join
point or the entry 
node) and ending in a control-transfer node or the exit node.
The basic blocks are enumerated in no particular order.
Within a basic block, we enumerate nodes in order.
If the client mutates the graph, we make no guarantees about what
nodes may be visited.
<<graph and node observers>>=
val iter_nodes : ('i node -> unit)           -> 'i cfg -> unit
val iter_heads : ('i node -> unit)           -> 'i cfg -> unit
val fold_nodes : ('i node -> 'a -> 'a) -> 'a -> 'i cfg -> 'a
val fold_heads : ('i node -> 'a -> 'a) -> 'a -> 'i cfg -> 'a
@ 
\paragraph{Observing data flow}
As noted above a node can contribute defs, uses, and kills to each
outedge, and a non-join node may contribute uses to each inedge.
The access to this information is carefully crafted to support
liveness analysis and to provide for efficient implementation in the
common case where there is no dataflow.

The [[union_over_outedges]] function is written in continuation-passing
style.  The [[noflow]] continuation is used in the common case when an
edge bears no dataflow information; the [[flow]] continuation is used
in the general case.  Clients must guarantee that
[[noflow n = flow {node=n; defs=empty; kills=empty}]].
In the common case, [[union_over_edges]] simply applies [[noflow]] to
its unique successor.

Calling [[add_inedge_uses n l]] returns the union of~[[l]] with any
uses on the inedge to~[[n]].
It is defined on \emph{all} nodes, because there are no uses on the
inedges of a join point.
In the common case, it returns its second argument.
<<graph and node observers>>=
val union_over_outedges : 
  'i node -> noflow:('i node -> regs) -> flow:('i contedge -> regs) -> regs
val add_inedge_uses  : 'i node -> regs -> regs
@ 
\subsection{Mutators}
We can change the graph by any of the following operations:
<<graph and node mutators>>=
@ 
\paragraph{Transactions}
In case we ever want to debug, mutations should be logged as
transactions.
This way we can replay them later...
<<graph and node mutators>>=
val start_transaction : 'i cfg -> string -> unit
val end_transaction   : 'i cfg -> unit
@ 
\paragraph{Altering successors}
We alter edges either by setting successors or by splicing in graphs.
These functions do whatever it takes to maintain invariants, which
means they may insert conditional branches or join points.
Function [[set_succ_n]] raises [[Invalid_argument]] if [[n]]~is
negative or too large.  
<<graph and node mutators>>=
val set_succ      : 'i node -> succ:'i node -> unit  (* defined on non-fork *)
val set_tsucc     : 'i node -> succ:'i node -> unit  (* defined on conditional branch *)
val set_fsucc     : 'i node -> succ:'i node -> unit  (* defined on conditional branch *)
val set_succ_n    : 'i node -> int -> succ:'i node -> unit  (* defined on any node *)
@ 
The special function [[invert_cbr]] swaps the true and false
successors of a conditional branch.
It also updates the instruction payload appropriately.
It is a checked run-time error to use [[invert_cbr]] on any
instruction other than a conditional branch.
<<graph and node mutators>>=
val invert_cbr    : 'i node -> unit              (* defined on conditional branch *)
@
\paragraph{Splicing in new subgraphs}
Although setting one or more successors is general enough to implement
any graph mutation, we provide
some convenient functions for splicing in a single-entry, single-exit
subgraph.
Such a subgraph is represented by its [[entry]], which must have
exactly one predecessor, and its [[exit]], which must have exactly one
successor.
It is permissible that the [[entry]] and [[exit]] be the same node.
<<graph and node mutators>>=
val splice_before : entry:'i node -> exit:'i node -> 'i node -> unit (* node is not join *)
val splice_after  : entry:'i node -> exit:'i node -> 'i node -> unit (* node is not fork *)
@
It is permissible to delete any node with one predecessor and one
successor.
It is never legal to delete a join point.
<<graph and node mutators>>=
val delete        : 'i node -> unit    (* must have unique pred and succ *)
@
\paragraph{Altering instructions}
If a node carries an instruction payload, this function
updates the instruction.
If a node carries no instruction payload, this function silently does
nothing. 
Changing a branch or conditional-branch instruction automatically
changes its successors; changing a computed goto, call, cut to, or
jump does not.
<<graph and node mutators>>=
val update_instr  : ('i -> 'i) -> 'i node -> unit
@ 
\subsection{Constructors}
We can make a fresh graph.
Because the graph can insert join points at will, the client must
provide a supply of private labels.
The supply takes as argument a string~[[s]] and returns a unique label
that begins with~[[s]].
Because the graph must be able to insert conditional branches at will,
it is up  to the client to supply the appropriate function on
instructions.
Undoubtedly we will have to add some information about branch negation
as well. 
Perhaps ultimately we will use an analog of the embedding/projection
pairs specified in the [[Target]] module.
<<graph and node constructors>>=
type       label_supply        = string -> string
type 'i instruction_info = { goto   : (label, 'i) Target2.map'
                           ; branch : (Rtl.exp * label, 'i) Target2.map'
                           }
val mk   : 'i instruction_info -> label_supply -> 'i cfg
@ 
We can clone the graph, simultaneously changing the representation of
instructions. 
N.B. the result is a ``shallow'' copy, not a ``deep'' one.
The cloned graph may share mutable state with the original, typically
in the extension fields.
%%% ==> don't remove blank line following decl
<<graph and node constructors>>=
val copy : 'j instruction_info -> ('i -> 'j) -> 'i cfg -> 'j cfg

@
We can make a variety of individual nodes.
These functions all mutate the graph, but we classify them as constructors anyway.
<<graph and node constructors>>=
val node_labeled : 'i cfg -> label -> 'i node
@ This function returns a join point bearing the given label.
If no such join point exists, one is created.
This function is the only way to create a join point explicitly
(though one may be created implicitly if two successors are set to the
same point).
@
In most cases, when we create a node we supply its successors.
The simple instruction is, well, simple.
<<graph and node constructors>>=
val instruction  : 'i cfg -> 'i -> succ:'i node -> 'i node
val assertion    : 'i cfg -> 'i -> succ:'i node -> 'i node
@ 
\paragraph{Control-flow nodes}
The graph knows how to make an unconditional branch and a conditional
branch. 
Otherwise, it's up to the client to supply the instruction that does
the transfer.
<<graph and node constructors>>=
val branch       : 'i cfg -> target:'i node -> 'i node
val jump         : 'i cfg -> 'i -> uses:regs -> targets:string list -> 'i node
val cbranch      : 'i cfg -> Rtl.exp -> ifso:'i node -> ifnot:'i node -> 'i node
val mbranch      : 'i cfg -> 'i -> targets:'i node list -> 'i node
val call         : 'i cfg -> 'i -> altrets:'i contedge list -> succ:'i node ->
                     unwinds_to:'i contedge list -> cuts_to:'i contedge list ->
                     aborts:bool -> uses:regs -> defs:regs -> kills:regs -> 
                     spans:(Bits.bits * Rtl.exp) list -> 'i node
val cut_to       : 'i cfg -> 'i -> cuts_to:'i contedge list -> aborts:bool ->
                     uses:regs -> 'i node
val return       : 'i cfg -> 'i -> uses:regs -> 'i node
@ N.B. So that a [[call]] can be composed in sequence just like an
[[instruction]], the ordinary return from a call is called [[succ]].
The [[spans]] argument to a [[call]] requires that the properties be
link-time constant expressions, but this requirement is not enforced
by the static type of the expression.
@
The weird nodes.
<<graph and node constructors>>=
val impossible   : 'i cfg -> succ:'i node -> 'i node
val illegal      : 'i cfg -> 'i node  (* a node that must never be reached *)
@
\section{Implementation}
<<cfg.ml>>=
<<exported signatures>>
module Make (X:X) : S with module X = X = struct
  module RS = Register.Set
  module SM = Strutil.Map
  module T  = Target2
  module X  = X

  type regs = Register.Set.t (* sets of regs for dataflow *)
  type label = string
  type label_supply = string -> label
  type 'i instruction_info = { goto   : (label, 'i) Target2.map'
                             ; branch : (Rtl.exp * label, 'i) Target2.map'}

  type kind = (* all the kinds of nodes *)
    | Boot' | Join | Instruction | Branch | Cbranch | Mbranch
    | Jump  | Call | Return | CutTo
    | Entry | Exit | Assertion | Illegal | Impossible
  <<node type>>
  and  'i contedge = { kills:regs; defs:regs; node:'i node }
  and  'i cfg = {         entry     : 'i node
                ; mutable exit      : 'i node
                ; mutable heads     : 'i node list
                ;         inst_info : 'i instruction_info
                ; mutable label_map : 'i node SM.t
                ;         mk_label  : label_supply
                }

  <<graph and node observers implementation>>
  <<graph utilities>>
  <<set successors>>
  <<graph and node constructors implementation>>  
  <<graph and node mutators implementation>>
end
@

\subsection{Node Type}
Abbreviations:
\begin{quote} 
\noindent
\begin{tabular}{>{\ttfamily}ll}
ent& Entry\\
exi& Exit\\
joi& Join\\
ins& Instruction\\
ass& Assertion\\
bra& Branch\\
cbr& Conditional branch\\
mbr& Multiway branch (computed goto)\\
cal& Call\\
cut& Cut to\\
ret& Return\\
jum& Jump\\
imp& Impossible\\
ill& Illegal\\
\end{tabular}
\end{quote}


<<node type>>=
type ('i, 'n) ent = { mutable ent_succ   : 'n 
                    ;         ent_nx     : X.nx
                    }
type ('i, 'n, 'c) exi = { mutable exi_cfg    : 'c
                        ; mutable exi_pred   : 'n list (* trouble ?? also a join point *)
                        ; mutable exi_lpred  : 'n      (* layout predecessor *)
                        ;         exi_jx     : X.jx
                        }
type ('i, 'n, 'c) joi = { mutable joi_labels : label list
                        ; mutable joi_cfg    : 'c
                        ; mutable joi_pred   : 'n list (* set ??? *)
                        ; mutable joi_succ   : 'n
                        ; mutable joi_lpred  : 'n  (* layout predecessor *)
                        ; mutable joi_jx     : X.jx
                        }
type ('i, 'n) ins = { mutable ins_i      : 'i
                    ; mutable ins_pred   : 'n
                    ; mutable ins_succ   : 'n
                    ;         ins_nx     : X.nx
                    }
type ('i, 'n) ass = { mutable ass_i      : 'i
                    ; mutable ass_pred   : 'n
                    ; mutable ass_succ   : 'n
                    ;         ass_nx     : X.nx
                    }
type ('i, 'n) bra = { mutable bra_i      : 'i
                    ; mutable bra_pred   : 'n
                    ; mutable bra_succ   : 'n
                    ; mutable bra_lsucc  : 'n
                    ;         bra_nx     : X.nx
                    }
type ('i, 'n) cbr = { mutable cbr_i      : 'i
                    ; mutable cbr_pred   : 'n
                    ; mutable cbr_true   : 'n
                    ; mutable cbr_false  : 'n
                    ;         cbr_fx     : X.fx
                    }
type ('i, 'n) mbr = { mutable mbr_i      : 'i
                    ; mutable mbr_pred   : 'n
                    ; mutable mbr_succ   : 'n array
                    ; mutable mbr_lsucc  : 'n
                    ;         mbr_fx     : X.fx
                    }
type ('i, 'n, 'e) cal = { mutable cal_i         : 'i
                        ;         cal_spans     : (Bits.bits * Rtl.exp) list
                        ; mutable cal_pred      : 'n
                        ; mutable cal_succ      : 'n array
                        ; mutable cal_contedges : 'e list
                        ;         cal_fx        : X.fx
                        ; mutable cal_uses      : regs
                        }
type ('i, 'n, 'e) cut = { mutable cut_i         : 'i
                        ; mutable cut_pred      : 'n
                        ; mutable cut_succ      : 'n array
                        ; mutable cut_contedges : 'e list
                        ;         cut_fx        : X.fx
                        ; mutable cut_uses      : regs
                        }
type ('i, 'n) jum = { mutable jum_i      : 'i
                    ; mutable jum_pred   : 'n
                    ; mutable jum_succ   : 'n
                    ;         jum_nx     : X.nx
                    ; mutable jum_uses   : regs
                    }
type ('i, 'n) ret = { mutable ret_i      : 'i
                    ; mutable ret_pred   : 'n
                    ; mutable ret_succ   : 'n
                    ;         ret_nx     : X.nx
                    ; mutable ret_uses   : regs
                    }
type ('i, 'n) imp = { mutable imp_pred   : 'n
                    ; mutable imp_succ   : 'n
                    ; mutable imp_lsucc  : 'n
                    ;         imp_nx     : X.nx
                    }
type ('i, 'n, 'c) ill = {         ill_nx     : X.nx
                        ; mutable ill_cfg    : 'c
                        }


type 'i node =
  | Boot
  | Ent of ('i, 'i node) ent  
  | Exi of ('i, 'i node, 'i cfg) exi  
  | Joi of ('i, 'i node, 'i cfg) joi  
  | Ins of ('i, 'i node) ins  
  | Ass of ('i, 'i node) ass  
  | Bra of ('i, 'i node) bra  
  | Cbr of ('i, 'i node) cbr  
  | Mbr of ('i, 'i node) mbr  
  | Cal of ('i, 'i node, 'i contedge) cal  
  | Cut of ('i, 'i node, 'i contedge) cut  
  | Ret of ('i, 'i node) ret  
  | Jum of ('i, 'i node) jum  
  | Imp of ('i, 'i node) imp  
  | Ill of ('i, 'i node, 'i cfg) ill  
@

<<graph and node observers implementation>>=
let imposs = Impossible.impossible
let undef f n = imposs (Printf.sprintf "%s: undefined on %s nodes" f n)

let kind node = match node with
  | Joi _ -> Join
  | Ins _ -> Instruction
  | Bra _ -> Branch
  | Cbr _ -> Cbranch
  | Mbr _ -> Mbranch
  | Jum _ -> Jump
  | Cal _ -> Call
  | Ret _ -> Return
  | Cut _ -> CutTo
  | Ent _ -> Entry
  | Exi _ -> Exit
  | Ass _ -> Assertion
  | Ill _ -> Illegal
  | Imp _ -> Impossible
  | Boot  -> Boot'

let is_join node = match node with
  | Joi _ | Exi _ -> true
  | _             -> false
let is_fork node = match node with
  | Cbr _ | Mbr _ | Cal _ | Cut _ -> true
  | _                             -> false

let is_ill node = match node with
  | Ill _ -> true
  | _     -> false

let label node = match node with
  | Joi { joi_labels = l } -> (try List.hd l
                               with Failure _ -> imposs "no labels at join")
  | Boot                   -> "boot"
  | _                      ->  undef "label" "non-join"

let labels node = match node with
  | Joi j -> j.joi_labels
  | _     -> undef "labels" "non-join"

(* Should Ass return the instr? *)
let to_instr node = match node with
  | Ins i -> Some i.ins_i
  | Ass a -> Some a.ass_i
  | Bra b -> Some b.bra_i
  | Cbr c -> Some c.cbr_i
  | Mbr m -> Some m.mbr_i
  | Cal c -> Some c.cal_i
  | Cut c -> Some c.cut_i
  | Jum j -> Some j.jum_i
  | Ret r -> Some r.ret_i
  | Ent _ -> None
  | Exi _ -> None
  | Joi _ -> None
  | Imp _ -> None
  | Ill _ -> None
  | Boot  -> undef "to_instr" "boot"

let pred node = match node with
  | Ins i -> i.ins_pred
  | Ass a -> a.ass_pred
  | Bra b -> b.bra_pred
  | Cbr c -> c.cbr_pred
  | Mbr m -> m.mbr_pred
  | Cal c -> c.cal_pred
  | Cut c -> c.cut_pred
  | Jum j -> j.jum_pred
  | Ret r -> r.ret_pred
  | Imp i -> i.imp_pred
  | Ent _ -> undef "pred" "entry"
  | Joi _ -> undef "pred" "join"
  | Exi _ -> undef "pred" "exit"
  | Ill _ -> undef "pred" "illegal"
  | Boot  -> undef "pred" "boot"

let tsucc node = match node with
  | Cbr c -> c.cbr_true
  | _     -> undef "tsucc" "non-cond-branch"
let fsucc node = match node with
  | Cbr c -> c.cbr_false
  | _     -> undef "fsucc" "non-cond-branch"

let succ_n node n =
  let fail ()    = raise (Invalid_argument "succ_n: illegal index") in
  let single s n = if n = 0 then s else fail ()                     in
  let mult a n   = try a.(n) with Invalid_argument _ -> fail ()     in
  match node, n with
  | Joi j, _ -> single j.joi_succ n
  | Ins i, _ -> single i.ins_succ n
  | Ass a, _ -> single a.ass_succ n
  | Bra b, _ -> single b.bra_succ n
  | Jum j, _ -> single j.jum_succ n
  | Ret r, _ -> single r.ret_succ n
  | Imp i, _ -> single i.imp_succ n
  | Ent e, _ -> single e.ent_succ n
  | Mbr m, _ -> mult m.mbr_succ n
  | Cal c, _ -> mult c.cal_succ n
  | Cut c, _ -> mult c.cut_succ n
  | Cbr c, 0 -> c.cbr_true
  | Cbr c, 1 -> c.cbr_false
  | Cbr _, _ -> fail ()
  | Exi _, _ -> undef "succ_n" "exit"
  | Ill _, _ -> undef "succ_n" "illegal"
  | Boot , _ -> undef "succ_n" "boot"

let succ node = match node with
  | Mbr _ -> undef "succ" "multi branch"
  | Cbr _ -> undef "succ" "cond branch"
  | Cal _ -> undef "succ" "call"
  | Cut _ -> undef "succ" "cut"
  | Exi _ -> undef "succ" "exit"
  | Ill _ -> undef "succ" "illegal"
  | Boot  -> undef "succ" "boot"
  | _     -> succ_n node 0

let preds node = match node with
  | Ins i -> [i.ins_pred]
  | Ass a -> [a.ass_pred]
  | Bra b -> [b.bra_pred]
  | Cbr c -> [c.cbr_pred]
  | Mbr m -> [m.mbr_pred]
  | Cal c -> [c.cal_pred]
  | Cut c -> [c.cut_pred]
  | Jum j -> [j.jum_pred]
  | Ret r -> [r.ret_pred]
  | Imp i -> [i.imp_pred]
  | Joi j -> j.joi_pred
  | Exi e -> e.exi_pred
  | Ent _ -> []
  | Ill _ -> []
  | Boot  -> undef "preds" "boot"

let succs node = match node with
  | Joi j -> [j.joi_succ]
  | Ins i -> [i.ins_succ]
  | Ass a -> [a.ass_succ]
  | Bra b -> [b.bra_succ]
  | Jum j -> [j.jum_succ]
  | Ret r -> [r.ret_succ]
  | Imp i -> [i.imp_succ]
  | Ent e -> [e.ent_succ]
  | Cbr c -> [c.cbr_true; c.cbr_false]
  | Mbr m -> Array.to_list m.mbr_succ
  | Cal c -> Array.to_list c.cal_succ
  | Cut c -> Array.to_list c.cut_succ
  | Exi _ -> []
  | Ill _ -> []
  | Boot  -> undef "succs" "boot"

(* Should jump and return count as control flow? Succ is exit - prob not *)
let is_cti node = match node with
  | Bra _ | Cbr _ | Mbr _ | Cal _ | Cut _ -> true
  | _                                     -> false
let is_br node = match node with
  | Bra _ -> true
  | _     -> false
let is_cbr node = match node with
  | Cbr _ -> true
  | _     -> false
let is_mbr node = match node with
  | Mbr _ -> true
  | _     -> false
let is_call node = match node with
  | Cal _ -> true
  | _     -> false
let is_cut node = match node with
  | Cut _ -> true
  | _     -> false

let jx node = match node with
  | Joi j -> j.joi_jx
  | Exi e -> e.exi_jx 
  | _     -> undef "jx" "non-join"
let fx node = match node with
  | Cbr c -> c.cbr_fx
  | Mbr m -> m.mbr_fx
  | Cal c -> c.cal_fx 
  | Cut c -> c.cut_fx
  | _     -> undef "fx" "non-fork"

let nx node = match node with
  | Ins i -> i.ins_nx
  | Ass a -> a.ass_nx
  | Bra b -> b.bra_nx
  | Jum j -> j.jum_nx
  | Ret r -> r.ret_nx
  | Imp i -> i.imp_nx
  | Ent e -> e.ent_nx
  | Ill i -> i.ill_nx
  | _     -> undef "nx" "fork and join"

let entry cfg = cfg.entry
let exit  cfg = cfg.exit

let fold_heads f zero cfg = List.fold_left (fun a b -> f b a) zero cfg.heads
let fold_nodes f =
  let rec fold_bb node zero = match node with
    | Exi _ | _ when is_cti node -> f node zero
    | _                          -> fold_bb (succ node) (f node zero) in
  fold_heads fold_bb

let iter_nodes f = fold_nodes (fun n () -> f n) ()
let iter_heads f = fold_heads (fun n () -> f n) ()

(* should this fn be defined on exi and ill?
   when there are cont edges, do we still need to cover the regular edges?*)
let union_over_outedges node ~noflow ~flow =
  let union_both succ contedges =
    Array.fold_right (fun s -> RS.union (noflow s)) succ
      (List.fold_left (fun r s -> RS.union r (flow s)) RS.empty contedges) in
  match node with
  | Cal c -> union_both c.cal_succ c.cal_contedges
  | Cut c -> union_both c.cut_succ c.cut_contedges
  | Cbr c -> RS.union (noflow c.cbr_true) (noflow c.cbr_true)
  | Mbr m -> Array.fold_right (fun s -> RS.union (noflow s)) m.mbr_succ RS.empty
  | Ins i -> noflow i.ins_succ
  | Ass a -> noflow a.ass_succ
  | Bra b -> noflow b.bra_succ
  | Jum j -> noflow j.jum_succ
  | Ret r -> noflow r.ret_succ
  | Imp i -> noflow i.imp_succ
  | Ent e -> noflow e.ent_succ
  | Joi j -> noflow j.joi_succ
  | Exi e -> RS.empty
  | Ill i -> RS.empty
  | Boot  -> imposs "union_over_outedges undefined on boot nodes"
  
let add_inedge_uses node regs = match node with
  | Cal c -> RS.union regs c.cal_uses
  | Cut c -> RS.union regs c.cut_uses
  | Jum j -> RS.union regs j.jum_uses
  | Ret r -> RS.union regs r.ret_uses
  | _     -> regs
@ 

The only graph mutation occurs via the set successors functions. 
The rest of the CFG implementation also uses these mutators.

<<set successors>>=
let node_labeled cfg label =
  try SM.find label cfg.label_map
  with Not_found ->
    let join = Joi { joi_labels = []
                   ; joi_cfg    = cfg
                   ; joi_pred   = []
                   ; joi_succ   = ill cfg
                   ; joi_lpred  = ill cfg
                   ; joi_jx     = X.jx ()
                   } in
    let () = cfg.heads <- join::cfg.heads in
    let () = cfg.label_map <- SM.add label join cfg.label_map in
    join
@

The successor of a branch node must be a join point.
[[verify_join]] inserts such a join point, if necessary.
The proper successor (a join point) is then returned.

<<set successors>>=
<<add pred>>
let rec verify_join ~succ =
  if is_join succ then succ
  else let p = pred succ in
       if is_join p then p
       else let cfg  = get_cfg succ in
            let join = node_labeled cfg (cfg.mk_label "join") in
            let () = if not (is_ill p) then set_succ_n p 0 ~succ:join in
            let () = set_succ_n join 0 succ in
            join

and set_succ_n node n ~succ =
  <<remove pred>> in
  let () = remove_pred (succ_n node n) ~pred:node in
  <<setup successor>> in
  let inval () = raise (Invalid_argument "set_succ_n: illegal index") in
  let mult a n succ =
    if n >= 0 && n < Array.length a then Array.set a n (setup_succ node succ)
    else inval () in
  let single n succ =
    if n = 0 then setup_succ node succ else inval () in
  match node, n with
  | Joi j, n -> j.joi_succ <- single n succ
  | Ins i, n -> i.ins_succ <- single n succ
  | Ass a, n -> a.ass_succ <- single n succ
  | Jum j, n -> j.jum_succ <- single n succ
  | Ret r, n -> r.ret_succ <- single n succ
  | Imp i, n -> i.imp_succ <- single n succ
  | Ent e, n -> e.ent_succ <- single n succ
  | Mbr m, n -> let succ = verify_join succ in
                mult m.mbr_succ n succ
  | Cal c, n -> mult c.cal_succ n succ
  | Cut c, n -> mult c.cut_succ n succ
  | Bra b, n ->
    let succ = verify_join succ in
    ( b.bra_i <- (get_cfg node).inst_info.goto.T.embed (label succ)
    ; b.bra_succ <- single n succ
    )
  | Cbr c, 0 ->
    let succ = verify_join succ in
    let cfg = get_cfg node in
    let (cond, _) = cfg.inst_info.branch.T.project c.cbr_i in
    ( c.cbr_i <- cfg.inst_info.branch.T.embed (cond, (label succ))
    ; c.cbr_true <- setup_succ node succ
    )
  | Cbr c, 1 ->
    let succ = verify_join succ in
     c.cbr_false <- setup_succ node succ
  | Cbr _, _ -> raise (Invalid_argument "invalid index passed to set_succ_n")
  | Exi _, _ -> undef "set_succ" "exit"
  | Ill _, _ -> undef "set_succ" "illegal"
  | Boot , _ -> undef "set_succ" "boot"

let join_leading_to = verify_join
let rec set_succ' single mult cbr node ~succ =
  if not (is_join succ) && not (is_ill (pred succ)) then
    set_succ' single mult cbr node ~succ:(join_leading_to succ)
  else
    begin
      (<<modify the $n$th successor of [[node]] because [[node]] is no longer a predecessor>>);
      (<<modify [[succ]] because [[node]] has become a predecessor>>);
      (<<update [[node]]'s $n$th successor field to point to [[succ]]>>)
    end

<<update [[node]]'s $n$th successor field to point to [[succ]]>>=
match node with
| Joi j -> j.joi_succ <- single succ
| Ins i -> i.ins_succ <- single succ
| Ass a -> a.ass_succ <- single succ
| Jum j -> j.jum_succ <- single succ
| Ret r -> r.ret_succ <- single succ
| Imp i -> i.imp_succ <- single succ
| Ent e -> e.ent_succ <- single succ
| Mbr m -> ignore (mult m.mbr_succ (fun _ -> join_leading_to succ))
| Cal c -> ignore (mult c.cal_succ (fun _ -> succ))
| Cut c -> ignore (mult c.cut_succ (fun _ -> succ))
| Bra b ->
  let succ = verify_join succ in
  ( b.bra_i <- (get_cfg node).inst_info.goto.T.embed (label succ)
  ; b.bra_succ <- single succ
  )
| Cbr c -> 
  let succ = verify_join succ in
  let cfg = get_cfg node in
  (if cbr () then
     c.cbr_true  <- succ
   else
     c.cbr_false <- succ
  );
  let (cond, _) = cfg.inst_info.branch.T.project c.cbr_i in
  c.cbr_i <- cfg.inst_info.branch.T.embed (cond, label c.cbr_true)

| Exi _ -> undef "set_succ" "exit"
| Ill _ -> undef "set_succ" "illegal"
| Boot  -> undef "set_succ" "boot"
@ 
<<modify the $n$th successor of [[node]] because [[node]] is no longer a predecessor>>=
assert false
<<modify [[succ]] because [[node]] has become a predecessor>>=
assert false
<<set_successors>>=
let new_set_succ_n n =
  set_succ' (if n = 0 then (fun s -> s) else (fun s -> invalid "successor index"))
            (fun a f -> let s = a.(n) in a.(n) <- f s; s)
            (if n = 0 then (fun () -> true) else if n = 1 then (fun () -> false)
             else fun () -> invalid "successor index")
let new_set_succ =
  set_succ' (fun s -> s)
            (fun a f -> undef "set_succ" "multiple node not o/w specified")
            (fun () ->  undef "set_succ" "cbr")

<<set successors>>=
let set_succ node ~succ = match node with
  | Ins _ -> set_succ_n node 0 ~succ
  | Ass _ -> set_succ_n node 0 ~succ 
  | Bra _ -> set_succ_n node 0 ~succ 
  | Jum _ -> set_succ_n node 0 ~succ 
  | Ret _ -> set_succ_n node 0 ~succ 
  | Imp _ -> set_succ_n node 0 ~succ 
  | Ent _ -> set_succ_n node 0 ~succ 
  | Joi _ -> set_succ_n node 0 ~succ 
  | Cal _ -> undef "set_succ" "fork"
  | Cut _ -> undef "set_succ" "fork"
  | Cbr _ -> undef "set_succ" "fork"
  | Mbr _ -> undef "set_succ" "fork"
  | Exi _ -> undef "set_succ" "exit"
  | Ill _ -> undef "set_succ" "illegal"
  | Boot  -> undef "set_succ" "boot"
 
let set_tsucc node ~succ = match node with
  | Cbr _ -> set_succ_n node 0 ~succ
  | _     -> undef "set_tsucc" "non-cond-branch"
let set_fsucc node ~succ = match node with
  | Cbr _ -> set_succ_n node 1 ~succ
  | _     -> undef "set_fsucc" "non-cond-branch"
@

For a node with a single predecessor, [[add_node]] will set that predecessor to
[[pred]].
For nodes with multiple predecessors, [[add_node]] will add [[pred]] to the
list (unless the list consists of a single illegal node, in which case [[pred]]
becomes the only predecessor).

<<add pred>>=
let add_pred node ~pred =
  let join_pred cur_preds = match cur_preds with
    | [Ill _] -> [pred]
    | _       -> pred::cur_preds in
  match node with
  | Ins i -> i.ins_pred <- pred
  | Ass a -> a.ass_pred <- pred
  | Bra b -> b.bra_pred <- pred
  | Jum j -> j.jum_pred <- pred
  | Ret r -> r.ret_pred <- pred
  | Imp i -> i.imp_pred <- pred
  | Cbr c -> c.cbr_pred <- pred
  | Mbr m -> m.mbr_pred <- pred
  | Cal c -> c.cal_pred <- pred
  | Cut c -> c.cut_pred <- pred
  | Exi e -> e.exi_pred <- join_pred e.exi_pred
  | Joi j -> j.joi_pred <- join_pred j.joi_pred
  | Ent e -> undef "add_pred" "entry"
  | Ill i -> undef "add_pred" "illegal"
  | Boot  -> undef "add_pred" "boot"

let pred_succ cfg set_succ_f node ~succ =
  ( if not (is_ill succ) && not (is_join succ) then add_pred succ (ill cfg)
  ; if not (is_ill node) then set_succ_f node ~succ:succ
  )
@

<<remove pred>>=
let remove_pred node ~pred =
  let rec rem_1_list lst = match lst with
                           | [] -> imposs "remove_pred: pred not found"
                           | n::rst when n = pred -> rst
                           | n::rst -> n :: rem_1_list rst in
  match node with
  | Joi j -> j.joi_pred <- rem_1_list j.joi_pred
  | Exi e -> e.exi_pred <- rem_1_list e.exi_pred
  | Ins i -> i.ins_pred <- ill (get_cfg node)
  | Bra b -> b.bra_pred <- ill (get_cfg node)
  | Cbr c -> c.cbr_pred <- ill (get_cfg node)
  | Mbr m -> m.mbr_pred <- ill (get_cfg node)
  | Jum j -> j.jum_pred <- ill (get_cfg node)
  | Cal c -> c.cal_pred <- ill (get_cfg node)
  | Ret r -> r.ret_pred <- ill (get_cfg node)
  | Cut c -> c.cut_pred <- ill (get_cfg node)
  | Ass a -> a.ass_pred <- ill (get_cfg node)
  | Imp i -> i.imp_pred <- ill (get_cfg node)
  | Ill _ -> ()
  | Ent e -> undef "remove_pred" "entry"
  | Boot  -> imposs "boot nodes should not live to remove_pred"
@

<<setup successor>>=
(* what if the node is a join?
   how are we making a label here? *)
let setup_succ node ~succ =
  match succ with
  | Exi _ | Joi _ -> (add_pred succ ~pred:node ; succ)
  | Ent _ -> imposs "entry nodes have no predecessors"
  | Boot  -> imposs "boot nodes should not live long and prosper"
  | Ill _ -> succ
  | _     ->
    let p = pred succ in
      if is_ill p then (add_pred succ ~pred:node ; succ)
      else match is_join p, is_join node with
           | true,  _     -> (add_pred p ~pred:node ; p)
           | false, true  -> ( set_succ_n p 0 ~succ:node
                             ; add_pred succ ~pred:node
                             ; succ
                             )
           | false, false ->
             let cfg = get_cfg node in
             let join  = node_labeled cfg (cfg.mk_label "join") in
             let ()    = set_succ_n p 0 ~succ:join in
             let ()    = add_pred succ ~pred:(ill cfg) in
             let ()    = set_succ_n join 0 ~succ:succ in
             let ()    = add_pred join ~pred:node in
             join
@

<<graph and node mutators implementation>>=
let start_transaction cfg name = ()
let end_transaction cfg = ()

let invert_cbr node = match node with
  | Cbr c ->
    let cfg = get_cfg node in
    let new_true = c.cbr_false in
    ( pred_succ cfg set_fsucc node ~succ:c.cbr_true
    ; pred_succ cfg set_tsucc node ~succ:new_true
    )
  | _     -> undef "invert_cbr" "non-cond-branch"

let splice_between ~entry ~exit ~pred ~succ =
  let cfg = get_cfg exit in
  let () = pred_succ cfg set_succ pred ~succ:entry in
  let () = pred_succ cfg set_succ exit ~succ:succ  in
  ()

let splice_before ~entry ~exit node =
  if is_join node then imposs "splice_before not defined on join nodes"
  else splice_between ~entry:entry ~exit:exit ~pred:(pred node) ~succ:node

let splice_after ~entry ~exit node =
  if is_fork node then imposs "splice_after not defined on fork nodes"
  else splice_between ~entry:entry ~exit:exit ~pred:node ~succ:(succ node)

(* what should this do on Bra? *)
let delete node =
  let cfg = get_cfg node in
  match node with
  | Ins i -> pred_succ cfg set_succ i.ins_pred ~succ:i.ins_succ
  | Ass a -> pred_succ cfg set_succ a.ass_pred ~succ:a.ass_succ
  | Bra b -> pred_succ cfg set_succ b.bra_pred ~succ:b.bra_succ
  | Jum j -> pred_succ cfg set_succ j.jum_pred ~succ:j.jum_succ
  | Ret r -> pred_succ cfg set_succ r.ret_pred ~succ:r.ret_succ
  | Imp i -> pred_succ cfg set_succ i.imp_pred ~succ:i.imp_succ
  | _     -> imposs "delete undefined on nodes with multiple succ or pred"

let update_instr upd node = match node with
  | Ins i -> i.ins_i <- upd i.ins_i
  | Ass a -> a.ass_i <- upd a.ass_i
  | Bra b -> b.bra_i <- upd b.bra_i
  | Jum j -> j.jum_i <- upd j.jum_i
  | Ret r -> r.ret_i <- upd r.ret_i
  | Mbr m -> m.mbr_i <- upd m.mbr_i
  | Cal c -> c.cal_i <- upd c.cal_i
  | Cut c -> c.cut_i <- upd c.cut_i
  | Cbr c -> c.cbr_i <- upd c.cbr_i
  | Joi j -> ()
  | Ent e -> ()
  | Exi _ -> ()
  | Imp i -> ()
  | Ill _ -> ()
  | Boot  -> imposs "update_instr undefined on boot nodes"
@

<<graph and node constructors implementation>>=
let mk i_info label_supply =
  let entry = { ent_succ = Boot
              ; ent_nx   = X.nx ()
              } in
  let cfg = { entry     = Ent entry
            ; exit      = Boot
            ; heads     = [ Ent entry ]
            ; inst_info = i_info
            ; label_map = SM.empty
            ; mk_label  = label_supply
            } in
  let exit  = Exi { exi_cfg  = cfg
                  ; exi_pred = []
                  ; exi_lpred = ill cfg 
                  ; exi_jx   = X.jx ()
                  } in
  let ill = ill cfg in
  let ()  = entry.ent_succ <- ill in
  let ()  = cfg.exit <- exit in
  cfg

(* using assoc lists - Map type cannot be parameterized *)
let copy info transform cfg = Impossible.unimp "copy"
(*
  let rec convert node map =
    try (map, List.assq node map)
    with Not_found ->
      let new_node n = match n with
        | Ins i -> Ins {i with ins_i    = transform i.ins_i
                       ;       ins_pred = Boot
                       ;       ins_succ = Boot
                       }
        | Ass a -> Ass { a with  ass_i    = transform a.ass_i
                       ;         ass_pred = Boot
                       ;         ass_succ = Boot
                       }
        | Bra b -> Bra { b with bra_i     = transform a.bra_i
                       ;        bra_pred  = Boot
                       ;        bra_succ  = Boot
                       ;        bra_lsucc = Boot
                       }
        | Cbr c -> Cbr { c with cbr_i     = transform c.cbr_i
                       ;        cbr_pred  = Boot
                       ;        cbr_true  = Boot
                       ;        cbr_false = Boot
                       }
        | Mbr m -> Mbr { m with mbr_i     = transform m.mbr_i
                       ;        mbr_pred  = Boot
                       ;        mbr_succ  = Array.empty
                       ;        mbr_lsucc = Boot
                       }
        | Jum j -> Jum { j with jum_i     = transform i
                       ;        jum_pred  = Boot
                       ;        jum_succ  = Boot
                       }
        | Cal c -> Cal { c with cal_i = transform c.cal_i
                       ; cal_pred      = ill cfg
                       ; cal_succ      = Array.of_list succs
                       ; cal_contedges = new_cedges @ altrets @ unwinds_to @ cuts_to
                       }
        | Ret r ->
        | Cut c ->
        | Joi j ->
        | Exi e ->
        | Ent e ->
        | Ill i ->
        | Imp i ->
        | Boot  -> Boot
        
      let conv_list lst map =
        List.fold_right (fun n (map, s) -> let (map',n') = convert n map in
                                           (map', n'::s))
                        lst (map,[]) in
      let (map, succs) = conv_list (succs node) map in
      let new_node = assert false in
      new_node in
  let (map,_) = convert cfg.entry [] in
  let cfg' = { entry =   List.assq cfg.entry map
             ; exit  =   List.assq cfg.exit  map
             ; heads = [ List.assq cfg.entry map ]
             ; inst_info = info
             ; label_map = SM.empty
             ; mk_label  = cfg.mk_label
             } in
  cfg'
*)

let instruction cfg i ~succ =
  let ins = Ins { ins_i    = i
                ; ins_pred = ill cfg
                ; ins_succ = succ
                ; ins_nx   = X.nx ()
                } in
  let ()  = set_succ ins ~succ:succ in
  ins

let assertion cfg i ~succ =
  let ass = Ass { ass_i    = i
                ; ass_pred = ill cfg
                ; ass_succ = succ
                ; ass_nx   = X.nx ()
                } in
  let ()  = set_succ ass ~succ:succ in
  ass

let branch cfg ~target =
  let succ = verify_join ~succ:target in
  let bra = Bra { bra_i     = cfg.inst_info.goto.T.embed (label succ)
                ; bra_pred  = ill cfg
                ; bra_succ  = succ
                ; bra_lsucc = succ
                ; bra_nx    = X.nx ()
                } in
  let ()  = set_succ bra ~succ:succ in
  bra

(* What should I do with the targets? *)
let jump cfg i ~uses ~targets =
  let jum = Jum { jum_i     = i
                ; jum_pred  = ill cfg
                ; jum_succ  = cfg.exit
                ; jum_nx    = X.nx ()
                ; jum_uses  = uses
                } in
  let ()  = set_succ jum ~succ:cfg.exit in
  jum

let cbranch cfg cond ~ifso ~ifnot =
  let so_succ  = verify_join ~succ:ifso in
  let not_succ = verify_join ~succ:ifnot in
  let cbr = Cbr { cbr_i     = cfg.inst_info.branch.T.embed (cond, (label so_succ))
                ; cbr_pred  = ill cfg
                ; cbr_true  = so_succ
                ; cbr_false = not_succ
                ; cbr_fx    = X.fx ()
                } in
  let ()  = set_tsucc cbr ~succ:so_succ  in
  let ()  = set_fsucc cbr ~succ:not_succ in
  cbr

let mbranch cfg i ~targets =
  let succs  = List.map (fun n -> verify_join ~succ:n) targets in
  let mbr = Mbr { mbr_i     = i
                ; mbr_pred  = ill cfg
                ; mbr_succ  = Array.of_list succs
                ; mbr_lsucc = ill cfg
                ; mbr_fx    = X.fx ()
                } in
  let ()  = List.iter (fun n -> set_succ mbr ~succ:n) succs in
  mbr

let ce_get_nodes l = List.map (fun {node = n} -> n) l

(* ever used? spans
   aborts: i'm just adding exit as a successor - should there be an
            impossible node on that edge?
   defs and kills? do they only apply to the succ?
             if aborts is right, should we bother with the exit node?
   *)
let call cfg i ~altrets ~succ ~unwinds_to ~cuts_to ~aborts ~uses ~defs ~kills
         ~spans =
  let succs = (ce_get_nodes altrets) @ [succ] @ (ce_get_nodes unwinds_to)
            @ (ce_get_nodes cuts_to) @ if aborts then [cfg.exit] else [] in
  let new_cedges =
    List.map (fun n -> {kills = kills; defs = defs; node = n}) [succ] in
  let cal =
    Cal { cal_i         = i
        ; cal_spans     = spans
        ; cal_pred      = ill cfg
        ; cal_succ      = Array.of_list succs
        ; cal_contedges = new_cedges @ altrets @ unwinds_to @ cuts_to
        ; cal_fx        = X.fx ()
        ; cal_uses      = uses
        } in
  let ()  = List.iter (fun n -> set_succ cal ~succ:n) succs in
  cal

(* should there be an imposs node on the edge to the exit? *)
let cut_to cfg i ~cuts_to ~aborts ~uses =
  let succs =
    match cuts_to with
    | [] -> [cfg.exit]
    | _  -> (ce_get_nodes cuts_to) @ if aborts then [cfg.exit] else [] in
  let cut = Cut { cut_i         = i
                ; cut_pred      = ill cfg
                ; cut_succ      = Array.of_list succs
                ; cut_contedges = cuts_to
                ; cut_fx        = X.fx ()
                ; cut_uses      = uses
                } in
  let ()  = List.iter (fun n -> set_succ cut ~succ:n) succs in
  cut


let return cfg i ~uses =
  let ret = Ret { ret_i    = i
                ; ret_pred = ill cfg
                ; ret_succ = cfg.exit
                ; ret_nx   = X.nx ()
                ; ret_uses = uses
                } in
  let ()  = set_succ ret ~succ:cfg.exit in
  ret

let impossible cfg ~succ =
  let imp = Imp { imp_pred  = ill cfg
                ; imp_succ  = succ
                ; imp_lsucc = ill cfg
                ; imp_nx    = X.nx ()
                } in
  let ()  = set_succ imp ~succ:succ in
  imp

let illegal cfg = ill cfg
@

<<graph utilities>>=
let get_cfg start_node =
  let rec search n =
    if n = start_node then imposs "cycle in cfg with no join node"
    else match n with
        | Exi e -> e.exi_cfg
        | Joi j -> j.joi_cfg
        | Ill i -> i.ill_cfg
        | x     -> search (succ_n x 0) in
  search start_node
@

We merge two join points by combining the information in the second
([[keep]]) node.
We also mutate the first join point ([[j1]]) to share the fields of
the second join point.

<<graph utilities>>=
let merge_joins j1 j2 succ lpred = match j1, j2 with
  | Joi j1, Joi j2 ->
    { joi_labels = j1.joi_labels @ j2.joi_labels
    ; joi_cfg    = j1.joi_cfg
    ; joi_pred   = j1.joi_pred   @ j2.joi_pred
    ; joi_succ   = j2.joi_succ
    ; joi_lpred  = j2.joi_lpred
    ; joi_jx     = j2.joi_jx
    }
  | _                -> undef "merge_joins" "non-join"
@

Creation of illegal nodes is common.

<<graph utilities>>=
let ill cfg = Ill { ill_nx  = X.nx ()
                  ; ill_cfg = cfg
                  }
@


Missing stuff:
\begin{itemize}
\item
 impossible edges on infinite loops
\item
unclear what users can do with assertions
\item
remove a node from the succ list of the pred when [[set_succ]] is called
- in [[pred_succ]]
\end{itemize}

