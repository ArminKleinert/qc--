% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Support for forward dataflow problems}


A dataflow pass is based on a single dataflow fact of type~[['a]].
Values of type~[['a]] should form a lattice.
The dataflow engine uses the lattice structure to compute a least
solution to a set of dataflow equations.
The engine works by starting at the bottom and iterating to a fixed
point, so we require the
bottom element, a join (least upper bound) operation, and a comparison
to find out if a value has changed (grown).
<<exported types>>=
type 'a fact = 'a Dataflowp.fact = {
  fact_name : string;                     (* documentation *)
  init_info : 'a;                         (* lattice bottom element *)
  add_info  : 'a -> 'a -> 'a;             (* lattice join (least upper bound) *)
  changed   : old:'a -> new':'a -> bool;  (* is new one bigger? *)
  prop      : 'a Unique.Prop.t;           (* access to mutable state by uid *)
}
@ Finally, we require a way to store dataflow facts in global mutable
state, associated with unique IDs.  This capability is provided by the
[[prop]] field.
@
The computation of a fact is the basis of a dataflow pass.
A~computation takes not one but two type parameters:
\begin{itemize}
\item
Type parameter [['i]] is an input, from which it should be possible to
derived a dataflow fact of interest.
For example, [['i]] might be equal to a fact, or it might be a tuple
of which one element is a fact.
\item
Type parameter [['o]] is an output.
\end{itemize}
<<exported types>>=
type 'a edge_fact_setter = (Zipcfg.uid -> 'a -> unit) -> unit
type 'a answer = Dataflow of 'a | Rewrite of Zipcfg.graph
type txlimit = int

type ('i, 'om, 'ol) computation =
 { name       : string;
   middle_out : txlimit -> 'i -> Zipcfg.Rep.middle -> 'om;
   last_outs  : txlimit -> 'i -> Zipcfg.Rep.last -> 'ol;
 } 
@ 
From these elements we build several kinds of passes:
\begin{itemize}
\item
A pure analysis computes a fact, using that fact as input and
output.
\item
A~pure transformation computes no facts but only changes the graph.
\item
A fully general pass both computes a fact and rewrites the graph.
\end{itemize}
<<exported types>>=
type 'a analysis = 'a fact * ('a, 'a, 'a edge_fact_setter) computation
type 'a pass     = 'a fact * ('a, 'a answer, 'a edge_fact_setter answer) computation
type 'a transformation = ('a, Zipcfg.graph option, Zipcfg.graph option) computation
@ 
We want to be able to import things from a no-limit world.
<<declarations of exported values>>=
val limit_fun  : ('a -> 'b -> 'c option) -> (txlimit -> 'a -> 'b -> 'c option)
val limit_anal : 'a Dataflowf.analysis       -> 'a analysis
val limit_tx   : 'a Dataflowf.transformation -> 'a transformation
@ Still to come: composition operators.
@
WE NEED TO TRACK THINGS TO DISCOVER WHETHER THE GRAPH HAS CHANGED AS A
RESULT OF RUNNING A PASS.
@
<<dataflowft.mli>>=
<<exported types>>
<<declarations of exported values>>
@ 
\paragraph{Analyses (the dataflow engine)}
The analysis function sets properties on unique IDs.
<<declarations of exported values>>=
val forward_anal : 'a analysis -> entry_fact:'a -> Zipcfg.graph -> unit
@ The rewrite pass sets properties and also rewrites the graph.
The Boolean result tells if the graph changed.
<<declarations of exported values>>=
val forward_rewrite : 'a pass -> entry_fact:'a -> Zipcfg.graph -> Zipcfg.graph * bool
@ If the graph is already solved, we can take a short cut.
<<declarations of exported values>>=
val forward_rewrite_solved :
  'a pass -> entry_fact:'a -> Zipcfg.graph -> Zipcfg.graph * bool
@ 
\paragraph{Composition operators}
Here we will make new passes from old ones.

We can make an analysis pass, or we can 
 combine a related analysis and transformation into a full pass.
<<declarations of exported values>>=
val anal : 'a analysis -> 'a pass
val a_t  : 'a analysis -> 'a transformation -> 'a pass
@ 
Diagnostic help:
<<declarations of exported values>>=
val debug : ('a -> string) -> 'a pass -> 'a pass
@
\section{Implementation}

<<dataflowft.ml>>=
module G  = Zipcfg
module GR = Zipcfg.Rep
module P  = Unique.Prop
module RS = Rtlutil.ToString
module UA = Unique.Array
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let unimpf  fmt = Printf.kprintf Impossible.unimp      fmt

<<exported types>>
<<utilities>>
<<definitions of exported functions>>
@ 
In a backward problem, we compute \emph{in} facts from \emph{out}
facts.
The analysis gives us [[last_in]], [[middle_in]], and [[first_in]],
each of which computes an \emph{in} fact for one kind of node.
We provide [[head_in]], which computes the \emph{in} fact for a first
node followed by zero or more middle nodes.

We don't compute and return the \emph{in} fact for block; instead, we
use [[P.set]] to attach that fact to the block's unique~ID.
We iterate until no more facts have changed.
<<definitions of exported functions>>=
let forward_anal (fact, comp) ~entry_fact graph =
  let changed = ref false in
  let update u a =
    let old_a = P.get fact.prop u in
    let new_a = fact.add_info a old_a in
    if fact.changed ~old:old_a ~new':new_a then
      begin
        Debug.eprintf "dataflow" "Dataflow fact changed at unknown uid\n";
        P.set fact.prop u new_a;
        changed := true
      end in
  let set_successor_facts b =
    let rec forward in' t = match t with
    | GR.Tail (m, t) -> forward (comp.middle_out 0 in' m) t
    | GR.Last l -> comp.last_outs 0 in' l update in
    let f, t = b in
    let blockname = match f with GR.Entry -> "<entry>" | GR.Label ((_, l), _, _) -> l in
    Debug.eprintf "dataflow" "Setting successor fact of block %s\n" blockname;
    forward (P.get fact.prop (GR.fid f)) t in

  (* get blocks, initialize, and iterate to fixed point *)
  let blocks = G.postorder_dfs graph in
  let init () = 
    List.iter (fun b -> P.set fact.prop (GR.id b) fact.init_info) blocks;
    P.set fact.prop GR.entry_uid entry_fact in
  let rec iterate n =
    let () = changed := false in
    let () = List.iter set_successor_facts blocks in
    if !changed then
      if n < 1000 then iterate (n + 1)
      else impossf "%s didn't converge in %n iterations" comp.name n
    else
      Debug.eprintf comp.name "%s converged in %d iterations\n" comp.name n in
  Debug.eprintf comp.name "starting forward dataflow %s\n" comp.name;
  init();
  iterate 1
@ 
In the general case we solve a graph in the context of a larger subgraph.
To do this, we need a locally modified computation that allows an
``exit fact'' to flow out of the exit node.
<<utilities>>=
let comp_with_exit comp exit_fact_ref =
  let last_outs txlimit in' l = match l with
  | GR.Exit -> Dataflow (fun set -> exit_fact_ref := in')
  | _ -> comp.last_outs txlimit in' l in
  { comp with last_outs = last_outs } 
@ 
Given this function, we can now solve a graph simply by doing a
backward analysis on the modified computation.
<<definitions of exported functions>>=
let rec solve_graph fact comp txlim graph in_fact =
  let exit_fact_ref = ref fact.init_info in
  let txlim =
    general_forward fact (comp_with_exit comp exit_fact_ref) txlim in_fact graph in
  txlim, !exit_fact_ref
and general_forward fact comp txlim entry_fact graph =
  let changed = ref false in
  let update u a =
    let old_a = P.get fact.prop u in
    let new_a = fact.add_info a old_a in
    if fact.changed ~old:old_a ~new':new_a then
      begin
        Debug.eprintf "dataflow" "Dataflow fact changed at unknown uid\n";
        P.set fact.prop u new_a;
        changed := true
      end in
  let set_successor_facts txlim b =
    let rec set_tail_facts txlim in' t = match t with
      | GR.Tail (m, t) ->
          (Debug.eprintf "dataflow" "Solving middle node %s\n"
             (Rtlutil.ToString.rtl (GR.mid_instr m));
           match comp.middle_out txlim in' m with
           | Dataflow a -> set_tail_facts txlim a t
           | Rewrite g -> 
               let txlim, g = solve_graph fact comp (txlim-1) g in' in
               set_tail_facts txlim g t)
      | GR.Last l -> 
          match comp.last_outs txlim in' l with
          | Dataflow setter -> (setter update; txlim)
          | Rewrite g -> fst (solve_graph fact comp (txlim-1) g in') in
    let f, t = b in
    let in' = match f with
    | GR.Entry -> entry_fact
    | GR.Label ((u, _), _, _) -> P.get fact.prop u in
    set_tail_facts txlim in' t in
  let blocks = G.postorder_dfs graph in
  let init () = List.iter (fun b -> P.set fact.prop (GR.id b) fact.init_info) blocks in
  let rec iterate n =
    let () = changed := false in
    let txlim = List.fold_left set_successor_facts txlim blocks in
    if !changed then
      if n < 1000 then iterate (n + 1)
      else impossf "%s didn't converge in %n iterations" comp.name n
    else
      (Debug.eprintf comp.name "%s converged in %d iterations\n" comp.name n;
       txlim) in
  Debug.eprintf comp.name "starting forward dataflow %s\n" comp.name;
  init();
  iterate 1
@
We solve and rewrite in two passes: the first pass iterates to a fixed
point to reach a dataflow solution, and the second pass uses that
solution to rewrite the graph.

The key job is done by [[propagate]], which propagates a fact of type~[['a]]
between a head and tail.
The tail is in final form; the head is still to be rewritten.
<<definitions of exported functions>>=
let rec solve_and_rewrite fact comp txlim graph in_fact changed =
  let _ = solve_graph fact comp txlim graph in_fact in                   (* pass 1 *)
  let exit_ref = ref fact.init_info in
  let txlim, g, c =
    forward_rewrite fact (comp_with_exit comp exit_ref) txlim graph in_fact changed in
  txlim, !exit_ref, (g,c)
and forward_rewrite (fact : 'a fact) comp txlim graph entry_fact changed =
  let rec rewrite_blocks txlim rewritten fresh changed : txlimit * G.graph * bool =
    match fresh with
    | [] -> txlim, G.of_block_list rewritten, changed
    | b :: bs ->
        let rec rewrite_next_block txlim =
          let f, t = b in
          let in' = match f with
          | GR.Entry -> entry_fact
          | GR.Label ((u, _), _, _) -> P.get fact.prop u in
          propagate txlim (GR.First f) in' t rewritten changed
        and propagate :
             txlimit -> GR.head -> 'a -> GR.tail -> GR.block list -> bool ->
               txlimit * G.graph * bool =
          fun txlim h in' t rewritten changed -> match t with
          | GR.Tail (m, t) -> (
              Debug.eprintf "dataflow" "Rewriting middle node %s\n"
                (Rtlutil.ToString.rtl (GR.mid_instr m));
              match comp.middle_out txlim in' m with
              | Dataflow a -> propagate txlim (GR.Head (h, m)) a t rewritten changed
              | Rewrite g ->
                  Debug.eprintf "dataflow" "Rewriting middle node...\n";
                  let txlim, a, (g, _) =
                    solve_and_rewrite fact comp (txlim-1) g in' changed in
                  Debug.eprintf "dataflow" "Rewrite of middle node completed\n";
                  let g, h = G.splice_head h g in
                  propagate txlim h a t (add_blocks (G.to_blocks g) rewritten) true)
          | GR.Last l ->
              match comp.last_outs txlim in' l with
              | Dataflow set ->
                  set (check_property_match fact);
                  let b = GR.zip (GR.End (h, l)) in
                  rewrite_blocks txlim (b :: rewritten) bs changed
              | Rewrite g ->
                  (* could test here that [[exits g = exits (GR.Entry, GR.Last l)]] *)
                  if Debug.on "rewrite-last" then begin
                    Printf.eprintf "Last node %s rewritten to:\n"
                      (RS.rtl (GR.last_instr l));
                    Cfgutil.print_cfg g
                  end;
                  let txlim, a, (g, _) =
                    solve_and_rewrite fact comp (txlim-1) g in' changed in
                  let g = G.to_blocks (G.splice_head_only h g) in
                  rewrite_blocks txlim (add_blocks g rewritten) bs true in
        rewrite_next_block txlim in
  rewrite_blocks txlim [] (G.postorder_dfs graph) changed

let forward_rewrite_solved (fact, comp) ~entry_fact g =
  let txlim = Tx.remaining () in
  let txlim', g, changed = forward_rewrite fact comp txlim g entry_fact false in
  Tx.decrement ~name:comp.name ~from:txlim ~to':txlim';
  g, changed

let forward_rewrite (fact, comp) ~entry_fact g =
  let txlim = Tx.remaining () in
  let txlim', _, gc = solve_and_rewrite fact comp txlim g entry_fact false in
  Tx.decrement ~name:comp.name ~from:txlim ~to':txlim';
  gc
<<utilities>>=
let eqfact fact a a' = (* poor man's approximation of equality *)
  not (fact.changed a a' or fact.changed a' a)
let check_property_match fact u a =
  let old_a = P.get fact.prop u in
  let new_a = fact.add_info a old_a in
  if not (eqfact fact old_a new_a) then
    impossf "property '%s' changed after supposedly reaching fixed point"
            fact.fact_name
@
<<utilities>>=
module UM = Unique.Map
let rec revapp h t = match t with
| GR.Last l -> h, l
| GR.Tail (m, t) -> revapp (GR.Head (h, m)) t

let must_be_empty g =
  if not (UM.is_empty g) then
    impossf "entry connects to exit, but there are more blocks"

let add_blocks map list =
  let add _ b bs = b :: bs in
  UM.fold add map list
@ 
<<utilities>>=
let ( << ) f g = fun x -> f (g x)
<<definitions of exported functions>>=
let debug s (f, comp) =
  let pr = Printf.eprintf in
  let fact dir node a = pr "%s %s for %s = %s\n" f.fact_name dir node (s a) in
  let setter dir node run_sets set =
    run_sets (fun u a -> pr "%s %s for %s = %s\n" f.fact_name dir node (s a); set u a) in
  let rewr node g = pr "%s rewrites %s to <not-shown>\n" comp.name node in
  let wrap f nodestring wrap_answer txlim in' node =
    fact "in " (nodestring node) in';
    wrap_answer (nodestring node) (f txlim in' node)
  and wrap_fact n answer =
    let () = match answer with
    | Dataflow a -> fact "out" n a
    | Rewrite g  -> rewr n g in
    answer
  and wrap_setter n answer =
    match answer with
    | Dataflow set -> Dataflow (setter "out" n set)
    | Rewrite g  -> (rewr n g; Rewrite g) in
  let middle_out = wrap comp.middle_out (RS.rtl << GR.mid_instr) wrap_fact in
  let last_outs = wrap comp.last_outs (RS.rtl << GR.last_instr) wrap_setter in
  f, { comp with last_outs = last_outs; middle_out = middle_out; }
@ 
<<definitions of exported functions>>=
let limit_fun f txlim i n = if txlim > 0 then f i n else None
let limit_anal (fact, comp) =
  let module D = Dataflowf in
  fact,
  { name = comp.D.name;
    middle_out = (fun _ -> comp.D.middle_out);
    last_outs = (fun _ -> comp.D.last_outs);
  }
let limit_tx tx =
  let module D = Dataflowf in
  { name = tx.D.name;
    middle_out = limit_fun tx.D.middle_out;
    last_outs = limit_fun tx.D.last_outs;
  }
<<definitions of exported functions>>=
let anal (fact, comp) =
  let wrap f txlim in' node = Dataflow (f txlim in' node) in
  fact,
  { name = comp.name;
    last_outs = wrap comp.last_outs; middle_out = wrap comp.middle_out; }
<<definitions of exported functions>>=
let a_t (fact, comp) tx =
 let last_outs txlim in' l =
   match tx.last_outs txlim in' l with
   | Some g -> Rewrite g
   | None   -> Dataflow (comp.last_outs txlim in' l) in
 let middle_out txlim in' m =
   match tx.middle_out txlim in' m with
   | Some g -> Rewrite g
   | None   -> Dataflow (comp.middle_out txlim in' m) in
 fact, 
 { name = Printf.sprintf "%s and %s" comp.name tx.name;
   last_outs = last_outs; middle_out = middle_out;
 }
