% vim: ts=8 sw=4 et:

% ------------------------------------------------------------------ 
\section{The Dummy Target}
% ------------------------------------------------------------------ 

This target describes a purely fictional target. We use it for
debugging. The target is functorized, such that we can invent new
targets easily. 

\emph{The Implementation uses the [[Space.Standard32]] module to define
control-flow {\rtl}s. We therefore assume therefore pointer and words
are 32 bit wide. Is it safe to pass in other values? --CL}


<<dummy.mli>>=
module type ARCH = sig
    val arch:           string (* name of this architecture *)
    val byte_order:     Rtl.aggregation
    val wordsize:       int
    val pointersize:    int
    val memsize:        int
end

module Make(A: ARCH): sig
    val target: Target2.t
end    
@

We provide ready-made 32 bit targets.

<<dummy.mli>>=
val dummy32l:   Target2.t       (* 32 bit, little endian *)
val dummy32b:   Target2.t       (* 32 bit, big endian    *)
@


% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<dummy.ml>>=
module AT       = Automaton2
module R        = Rtl
module RP       = Rtl.Private
module RU       = Rtlutil
module Up       = Rtl.Up
module Dn       = Rtl.Dn
module SS32     = Space.Standard32
module T        = Target2

module type ARCH = sig
    val arch:           string (* name of this architecture *)
    val byte_order:     Rtl.aggregation
    val wordsize:       int
    val pointersize:    int
    val memsize:        int
end

module Make(A: ARCH) = struct
    let id = Rtl.Identity
    let wordsize    = 32
    let pointersize = 32

    <<module Spaces>>

    let {SS32.cc = eflags} = SS32.locations Spaces.c
    let locations   = SS32.locations Spaces.c
    let pc          = locations.SS32.pc
    let cc          = locations.SS32.cc
    let npc         = locations.SS32.npc
    let fp_mode     = locations.SS32.fp_mode
    let fp_fcmp     = locations.SS32.fp_fcmp
    
    let t = (* for generic automata, will go away *)
        { Automaton2.Sample.byteorder = A.byte_order
        ; Automaton2.Sample.pointersize = A.pointersize
        ; Automaton2.Sample.wordsize = A.wordsize
        ; Automaton2.Sample.memsize = A.memsize
        ; Automaton2.Sample.registers =
            [ "IEEE 754 rounding mode", fp_mode
            ; "IEEE 754 comparison results", fp_fcmp
            ]
        }
 
    <<module Flow>>
    <<module Spill>>
    <<calling conventions>>

    let target =
        { T.name = A.arch
          ; T.cc           = (fun _ -> cc)  
          ; T.byteorder    = A.byte_order
          ; T.wordsize     = A.wordsize
          ; T.pointersize  = A.pointersize
          ; T.vfp          = Vfp.mk A.wordsize
          ; T.alignment    = 1
          ; T.memsize      = 8
          ; T.float        = "ieee754"
          ; T.charset      = "latin1" 
          ; T.globals      = Automaton2.Sample.global t
          ; T.is_rounding_mode = (fun loc -> loc = fp_mode)
          ; T.spaces       = [ Spaces.m 
                             ; Spaces.c 
                             ; Spaces.r 
                             ; Spaces.f
                             ; Spaces.t
                             ; Spaces.u
                             ]
          ; T.data_section = "data"
          ; T.bnegate      = Flow.bnegate eflags
          ; T.goto         = Flow.goto
          ; T.jump         = Flow.jump
          ; T.call         = Flow.call 
          ; T.branch       = Flow.branch
          ; T.spill        = Spill.spill
          ; T.reload       = Spill.reload
      }
end

module Dummy32l = Make(struct
    let arch        = "dummy32l"
    let byte_order  = Rtl.LittleEndian
    let wordsize    = 32
    let pointersize = 32
    let memsize     = 8
end)

module Dummy32b = Make(struct
    let arch        = "dummy32b"
    let byte_order  = Rtl.BigEndian
    let wordsize    = 32
    let pointersize = 32
    let memsize     = 8
end)

let dummy32l = Dummy32l.target
let dummy32b = Dummy32b.target
@

% ------------------------------------------------------------------ 
\subsection{Spaces}
% ------------------------------------------------------------------ 

<<module Spaces>>=
module Spaces = struct
    let m   = SS32.m A.byte_order [8; 16; 32]
    let c   = SS32.c 2  id [32]
    let r   = SS32.r 32 id [32]
    let f   = SS32.f 32 id [32]
    let t   = SS32.t    id [32]
    let u   = SS32.u    id [32]
end                 
@

% ------------------------------------------------------------------ 
\subsection{Control Flow}
% ------------------------------------------------------------------ 

<<module Flow>>=

let reg n       = R.reg ('r',n,A.wordsize)
let sp          = reg 32                    (* stack pointer  *)
let ra          = reg 30                    (* return address *)

let fetch l     = R.fetch l   A.wordsize
let store l e   = R.store l e A.wordsize
let assign      = store
let return      = store pc (fetch ra)

module Flow = Mflow.MakeStandard
    (struct
        let pc_lhs      = pc
        let pc_rhs      = pc
        let ra_reg      = R.reg ('r', 30, A.wordsize)
        let ra_offset   = 4 (* just guessing *)
    end)


let cutto =                 
    { T.embed   = (fun { Mflow.new_pc=newpc
                       ; Mflow.new_sp=newsp
                       } ->
                       Rtl.par [assign (reg 31) newsp; assign pc newpc])
    ; T.project = (fun r -> match Dn.rtl r with
                    | RP.Rtl [ (_, RP.Store(_, nsp, _)) 
                             ; (_, RP.Store(_, npc, _))] -> 
                                { Mflow.new_sp =Up.exp nsp
                                ; Mflow.new_pc= Up.exp npc
                                }  
                    | _ -> Impossible.impossible "projected non-cutto")
    }
@

% ------------------------------------------------------------------ 
\subsection{Spills and Reloads}
% ------------------------------------------------------------------ 

\emph{What is the [[lookup]] parameter for? We should expunge it.}

<<module Spill>>=
module Spill = struct
    let assign lookup ~src:(src_sp,_,src_w as src) 
                      ~dst:(dst_sp,_,dst_w as dst) =
        if src_w <> dst_w then
            invalid_arg 
                "Dummy.assign source and destination width don't match"
        else
            let src_loc = Rtl.reg src  in
            let dst_loc = Rtl.reg dst  in
                Rtl.store dst_loc (Rtl.fetch src_loc src_w)  dst_w

    let spill lookup (_,_,w as reg) loc = 
        let rtl = Rtl.store loc (Rtl.fetch (Rtl.reg reg) w) w 
        in [rtl]
    
    let reload lookup (_,_,w as reg) loc =
        let rtl = Rtl.store (Rtl.reg reg) (Rtl.fetch loc w) w
        in [rtl]
end
@        

% ------------------------------------------------------------------ 
\subsection{Calling Conventions}
% ------------------------------------------------------------------ 

<<calling conventions>>=
let cc =
    { T.sp              = sp
    ; T.return          = return
    ; T.proc            = Automaton2.Sample.stack t
    ; T.cont            = Automaton2.Sample.stack t
    ; T.ret             = Automaton2.Sample.stack t
    ; T.stack_slots     = Automaton2.Sample.stack t 
    ; T.cutto           = cutto
    ; T.allocatable = List.concat 
          [ List.map (fun n -> ('r', n, A.wordsize))
            [0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23]
          ; List.map (fun n -> ('r', n, A.wordsize))
            [0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23]
          ]  
                       
    }
 
@
