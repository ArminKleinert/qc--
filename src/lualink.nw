% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% vim: ts=8 sw=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Linking the Lua Interpreter}\label{sect:lua-link}
% ------------------------------------------------------------------ 

The compiler is controlled by an embedded Lua interpreter. Types and
values of the compiler are made available as Lua primitives and allow
the user to control the compiler. We build here an interpreter with our
extensions.

<<lualink.mli>>=
module I : Lua.INTERP
@

<<lualink.ml>>=
module G = Cfgx.M

<<Linking QC-- Types>>

module Reloc        = Sledlib.MkReloc (struct type symbol = Symbol.t end)
module Backplane = Backplane.M

module T1 = Lua.Lib.Combine.T5
                (DocType)                   (* T1.TV1 *)
                (Luaiolib.T)                (* T1.TV2 *)
                (AsmType)                   (* T1.TV3 *)
                (AstType)                   (* T1.TV4 *)
                (Colorgraph.GCT)         (* T1.TV5 *)

module T    = Lua.Lib.Combine.T9            (* types *)
                (T1)                        (* T.TV1 *)
                (Backplane.T)            (* T.TV2 *)
                (EnvType)                   (* T.TV3 *)
                (ProcType)                  (* T.TV4 *)
                (TargetType)                (* T.TV5 *)
                (BlockType)                 (* T.TV6 *)
                (AutomatonType)             (* T.TV7 *)
                (CCStageType)               (* T.TV8 *)
                (CounterenvType)            (* T.TV9 *)

module T1' = Lua.Lib.Lift (T1) (T.TV1)

module DocTV             = T1'.TV1
module LuaioTV           = T1'.TV2
module AsmTV             = T1'.TV3
module AstTV             = T1'.TV4
module ColorgraphTV   = T1'.TV5

module BackplaneTV    = T.TV2
module EnvTV             = T.TV3
module ProcTV         = T.TV4
module TargetTV          = T.TV5
module BlockTV           = T.TV6
module AutomatonTV       = T.TV7
module CCStageTV         = T.TV8
module CounterenvTV      = T.TV9

module WT = Lua.Lib.WithType (T)

module C = 
  Lua.Lib.Combine.C8                   (* up to 10 libraries *)
    (Luaiolib.Make (LuaioTV))
    (WT (Luastrlib.M))
    (WT (Luamathlib.M))
    (MakeLib 
        (AsmTV) (AstTV) (EnvTV) (ProcTV) (TargetTV) (DocTV) (LuaioTV)
        (BlockTV) (AutomatonTV) (CCStageTV) (CounterenvTV))
    (Colorgraph.Make (BackplaneTV) (ColorgraphTV) (ProcTV))
    (Dls.Make (BackplaneTV) (ProcTV))
    (WT (Luautil.MakeLib))
    (Backplane.MakeLua  (BackplaneTV) (ProcTV))

module I = 
  Lua.MakeInterp                            (* our interpreter *)
    (Lua.Parser.MakeStandard)
    (Lua.MakeEval (T) (C))
@


% ------------------------------------------------------------------ 
\subsection{Export to Lua}
% ------------------------------------------------------------------ 

<<Linking QC-- Types>>=
module Personality = struct
    type proc = Ast2ir.proc
    let target      = Dummy.dummy32b'
    let memsize     = 8
    let wordsize    = 32
    let pointersize = wordsize
    let byteorder   = Rtl.BigEndian
    let charset     = "latin1"
    let float       = "ieee754"

    let cfg2ast proc =
      Cfgutil.cfg2ast Rtlutil.ToAST.rtl proc.Proc.cfg proc.Proc.symbol#mangled_text
end
@

The assemblers for the {\AST} and the interpreter are polymorphic. We
have to supply a target description that defines the sizes of words and
so forth.

<<Linking QC-- Types>>=
module AstAsm = Astasm.Make(Personality)

module AsmType = struct
    type 'a t       = 'a Asm.assembler
    let tname       = "asm"
    let eq _        = fun x y -> x =*= y
    let to_string _ = fun t -> "<asm>" 
end
module AstType = struct
    type 'a t       = Srcmap.map * Ast.program
    let tname       = "ast"
    let eq _        = fun x y -> x =*= y
    let to_string _ = fun t -> "<ast>" 
  end
module EnvType = struct
    type 'a t       = 'a Fenv.Clean.env'
    let tname       = "env"
    let eq _        = fun x y -> x =*= y
    let to_string _ = fun t -> "<env>"
end
module ProcType : Lua.Lib.USERTYPE with type 'a t = Ast2ir.proc = 
struct
    type 'a t       = Ast2ir.proc
    let tname       = "proc"
    let eq _        = fun x y -> x =*= y
    let to_string _ = fun t -> ("<proc "^t.Proc.symbol#mangled_text^">") 
end
module TargetType = struct
    type 'a t       = Ast2ir.tgt
    let tname       = "target"
    let eq _        = fun x y -> x =*= y
    let to_string _ = fun t -> "<target " ^ t.Target.name ^ ">" 
end
module DocType = struct
    type 'a t       = Pp.doc
    let tname       = "doc"
    let eq _        = fun x y -> x =*= y
    let to_string _ = fun t -> "<doc>" 
end
module BlockType = struct
    type 'a t       = Block.t
    let tname       = "block"
    let eq _        = fun x y -> x =*= y
    let to_string   = fun _ t -> "<block>"
end
module AutomatonType = struct
    type 'a t       = Automaton.t
    let tname       = "automaton"
    let eq _        = fun x y -> false
    let to_string   = fun _ t -> "<automaton>"
end
module CCStageType = struct
    type 'a t       = Automaton.stage
    let tname       = "ccstage"
    let eq _        = fun x y -> false
    let to_string   = fun _ t -> "<cconv. stage>"
end
module CounterenvType = struct
    type 'a t       = Automaton.counterenv
    let tname       = "counterenv"
    let eq _        = fun x y -> false
    let to_string   = fun _ t -> "<counterenv>"
end

module MakeLib
  (AsmV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AsmType.t)
  (AstV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AstType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (EnvV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a EnvType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (ProcV   : Lua.Lib.TYPEVIEW with type 'a t        = 'a ProcType.t
                              and  type 'a combined = 'a AsmV.combined)
  (TargetV : Lua.Lib.TYPEVIEW with type 'a t        = 'a TargetType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (DocV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a DocType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (InOutV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a Luaiolib.T.t    
                              and  type 'a combined = 'a AsmV.combined)
  (BlockV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a BlockType.t    
                              and  type 'a combined = 'a AsmV.combined)
  (AutomatonV  : Lua.Lib.TYPEVIEW with type 'a t    = 'a AutomatonType.t    
                              and  type 'a combined = 'a AsmV.combined)
  (CCStageV : Lua.Lib.TYPEVIEW with type 'a t       = 'a CCStageType.t
                              and  type 'a combined = 'a AsmV.combined)
  (CounterenvV : Lua.Lib.TYPEVIEW with type 'a t    = 'a CounterenvType.t
                              and  type 'a combined = 'a AsmV.combined)

    : Lua.Lib.USERCODE with type 'a userdata' = 'a AsmV.combined =

struct
  type 'a userdata' = 'a AsmV.combined
  module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a userdata') =
    struct
      module V = C.V
      let ( **-> ) = V.( **-> )
      let ( --> )  = V.( --> )
      let ( **->> ) x y = x **-> V.result y 
      let ( *****->> ) = V.dots_arrow
      let ( <|> ) = V.( <|> )
      let ( <@ ) = V.( <@ )
      <<export goodies to Lua>>
    end (*M*)
end (*MakeLib*)
@ 
HOW ARE THE DIFFERENT ASSEMBLERS [[asm]], [[vasm]], [[new_asm]] SUPPOSED TO
BE USED?  SOME DOCUMENTATION WOULD BE WELCOME. --CL
<<export goodies to Lua>>=
module Map = struct
    let compose ~lo ~hi =
       { V.embed   = (fun x -> hi.V.embed (lo.V.embed x))
       ; V.project = (fun x -> lo.V.project (hi.V.project x))
       ; V.is      = (fun x -> hi.V.is x && lo.V.is (hi.V.project x))
       } 
    let error t =
      { V.embed = (function Error.Error -> V.Nil | Error.Ok v -> t.V.embed v);
        V.project = (function V.Nil -> Error.Error | v -> Error.Ok (t.V.project v));
        V.is = (function V.Nil -> true | v -> t.V.is v);
      }
        
    let ast       = AstV.makemap  V.userdata V.projection
    let proc      = ProcV.makemap V.userdata V.projection
    let vasm      = AsmV.makemap  V.userdata V.projection
      (* embeds and projects a V.value assembler *)
    let asm' proc =
      compose { V.embed   = Asm.map proc.V.project
              ; V.project = Asm.map proc.V.embed 
              ; V.is      = (fun _ -> true) } (* here's a hopeful notion *)
        vasm
    let asm = asm' proc
    let venv = EnvV.makemap    V.userdata V.projection
    let env' proc =
      compose { V.embed   = Fenv.Clean.map proc.V.project
              ; V.project = Fenv.Clean.map proc.V.embed 
              ; V.is      = (fun _ -> true) } (* and more hope *)
      venv
    let env = env' proc

    let doc           = DocV.makemap       V.userdata V.projection
    let target        = TargetV.makemap V.userdata V.projection
    let optimize proc = V.closure (proc **->> V.unit)
    let channel       = InOutV.makemap     V.userdata V.projection
    let inchan        = Luaiolib.in'       channel    V.projection
    let outchan       = Luaiolib.out       channel    V.projection
    let stage proc    = V.func (V.value **-> proc **->> V.bool)
    let block         = BlockV.makemap     V.userdata V.projection
    let placement     = V.enum "placement" ["high", Block.High; "low", Block.Low]
    let automaton     = AutomatonV.makemap V.userdata V.projection

    let ccstage       = CCStageV.makemap    V.userdata V.projection
    let counterenv    = CounterenvV.makemap V.userdata V.projection
end
@ 
We also need to import Lua projection/embedding pairs defined in other modules.
<<export goodies to Lua>>=
module RL = Register.RT(C)
@ 
Here we finally bind the exported values to names in the Lua
interpreter. The [[compile]] function receives a lua value such that it
can call Lua functions while it is active.
<<export goodies to Lua>>=
let init g = 
  let backplane_stage = V.efunc (V.value **-> Map.proc **->> V.bool) in
  <<register modules to [[g]] in alphabetical order>>
  V.at_init g [ <<lua initialization>> ]

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Asm"
  [ "cmm" , V.efunc (Map.outchan **->> Map.asm) AstAsm.asm     
  ; "dot" , V.efunc (Map.outchan **->> Map.asm) (Dotasm.asm ~compress:true ~live:false)
  ; "big_dot" , V.efunc (Map.outchan **->> Map.asm) 
                            (Dotasm.asm ~compress:false ~live:true)
  ; "ppc",   V.efunc (Map.outchan **->> Map.asm) (Ppcasm.make Cfgutil.emit)
  ; "x86" ,  V.efunc (Map.outchan **->> Map.asm) (X86asm.make Cfgutil.emit)
  ; "mips",  V.efunc (Map.outchan **->> Map.asm) (Mipsasm.make Cfgutil.emit)
  ; "alpha", V.efunc (Map.outchan **->> Map.asm) (Alphaasm.make Cfgutil.emit)
  ; "ia64",  V.efunc (Map.outchan **->> Map.asm) (Ia64asm.make Cfgutil.emit)
  ; "sparc", V.efunc (Map.outchan **->> Map.asm) (Sparcasm.make Cfgutil.emit)
  ; "interp32l" , V.efunc (Map.outchan **->> Map.asm) 
            (Interpasm.asm' ~byteorder:Rtl.LittleEndian ~memsize:8 ~ptrsize:32)
  ; "interp32b" , V.efunc (Map.outchan **->> Map.asm) 
            (Interpasm.asm' ~byteorder:Rtl.BigEndian ~memsize:8 ~ptrsize:32)
  ] g;
@ 
\paragraph{Calling-convention automata}
[[listpair : 'a map -> 'b map -> ('a * 'b) list map]]
<<embedding/projection pairs for calling conventions>>=
let listpair a b =
  let values = V.list V.value in
  { V.embed =
      (fun ps -> values.V.embed
          (List.fold_right (fun (x, y) t -> a.V.embed x :: b.V.embed y :: t) ps []))
  ; V.project = (fun l ->
      let rec cut = function
        | x :: y :: ps -> (a.V.project x, b.V.project y) :: cut ps
        | [] -> []
        | [x] -> V.projection l "list of pairs" in
      cut (values.V.project l))
  ; V.is = (fun l -> values.V.is l && (List.length (values.V.project l) mod 2 = 0))
  } in

<<embedding/projection pairs for calling conventions>>=
let stringtab what tbl =
  let nameof x =     fst (List.find (fun (_, x') -> x' =*= x) tbl) in
  let valof  n = try snd (List.find (fun (n', _) -> n' =$= n) tbl)
                 with Not_found -> V.projection (V.String n) what in
  let exists n = List.exists (fun (n', _) -> n' =$= n) tbl in
  { V.embed   = (fun x -> V.String (nameof x))
  ; V.project = (fun v -> valof (V.string.V.project v))
  ; V.is      = (fun v -> V.string.V.is v && exists (V.string.V.project v))
  } in

let byteorder = stringtab "byteorder"
  ["little", Rtl.LittleEndian; "big", Rtl.BigEndian; "identity", Rtl.Identity] in
let growth    = stringtab "memory growth"
  ["up", Memalloc.Up; "down", Memalloc.Down] in
@ 
A stage can be a list of stages, up to nesting depth five.
<<embedding/projection pairs for calling conventions>>=
let stage stages =
  (V.list stages <@ (fun l -> List.fold_right A.( *> ) l A.unit)) <|> stages in
let stage = stage (stage (stage (stage (stage (stage Map.ccstage))))) in
@
And a choice predicate can be a list of choice predicates, to slightly
less depth. 
<<embedding/projection pairs for calling conventions>>=
let choicep =
  (V.int    <@ A.is_width) <|>
  (V.string <@ A.is_hint ) <|>
  (V.func (V.int **-> V.string **-> Map.counterenv **->> V.bool)) in

let all_preds l w h ce = List.for_all (fun p -> p w h ce) l in
let choice_pred preds = (V.list preds <@ all_preds) <|> preds in
let choice_pred = choice_pred (choice_pred (choice_pred (choice_pred choicep))) in
@
For information on how we represent registers in Lua, see \module{register.nw}.
<<register modules to [[g]] in alphabetical order>>=
let module A = Automaton in
<<embedding/projection pairs for calling conventions>>
let register_cc t name tbl = 
  let getfield f = stage.V.project (V.Table.find tbl (V.String f)) in
  Call.register_cc t name ~call:(getfield "call")
     ~results:(getfield "results") ~cutto:(getfield "cutto") in

let wideni n how =
  A.widen (
    match how with
    | "multiple" -> Aux.round_up_to ~multiple_of:n
    | "exact"    -> (fun m -> if m <= n then n
                              else Unsupported.automaton_widen ~have:m ~want:n)
    | s -> V.projection (V.String s) "widening (should be 'multiple' or 'exact')") in

let reserve =
  V.default false (V.enum "register reservation" ["reserve", true; "normal", false]) in

let regty = RL.map in
let counterty = V.string in
let counterpred = (V.int <@ (=)) <|> (V.func (V.int **->> V.bool)) in
let align_fun = (V.int <@ (fun n w -> n)) <|> (V.func (V.int **->> V.int)) in

C.register_module "Automaton"
  [ (* first the stage constructors ... *)
    "align_to"    , V.efunc (align_fun                    **->> stage) A.align_to
  ; "argcounter"  , V.efunc (counterty                    **->> stage) A.argcounter
  ; "bitcounter"  , V.efunc (counterty                    **->> stage) A.bitcounter
  ; "choice"      , V.efunc (listpair choice_pred stage   **->> stage) A.choice
  ; "first_choice", V.efunc (listpair choice_pred stage   **->> stage) A.first_choice
  ; "overflow"    , V.efunc (V.table **->> stage)
                    (fun ovfl ->
                        let field p f = p.V.project (V.Table.find ovfl (V.String f)) in
                        A.overflow
                          ~growth:       (field growth    "growth")
                          ~max_alignment:(field V.int     "max_alignment"))
  ; "pad"         , V.efunc (counterty **->> stage) A.pad
  ; "regs_by_args", V.efunc (counterty **-> V.list regty **-> reserve **->> stage)
                    A.regs_by_args
  ; "regs_by_bits", V.efunc (counterty **-> V.list regty **-> reserve **->> stage)
                    A.regs_by_bits
  ; "unit"        , stage.V.embed                                     A.unit
  ; "useregs"     , V.efunc (V.list regty **-> reserve **->> stage)   A.useregs
  ; "widen"       , V.choose
                    [ V.alt (V.int **-> V.default "exact" V.string **->> stage) wideni
                    ; V.alt ((V.int --> V.int)                     **->> stage) A.widen
                    ]
  ; "widths"      , V.efunc (V.list V.int **->> stage) A.widths

    (* the prewritten utils ... *)
  ; "is_any"      , choicep.V.embed A.is_any
  ; "counter_is"  , V.efunc (counterty **-> counterpred **->> choicep) A.counter_is
                            
  ; "debug"       ,
       V.efunc (counterty **->
                V.func (V.int **-> V.string **-> V.int **-> V.int **->> V.unit) **->>
                stage) A.debug
    (* registration, although it shouldn't necessarily be in here *)
  ; "register_cc" , V.efunc (Map.target **-> V.string **-> V.table **->> V.unit)
                    register_cc
  ] g;
<<register modules to [[g]] in alphabetical order>>=
let block = Map.block in
C.register_module "Block" 
  [ "size",         V.efunc (block **->> V.int)     Block.Lua.size
  ; "alignment",    V.efunc (block **->> V.int)     Block.Lua.alignment
  ; "adjust",       V.efunc (block **->> block)     Block.Lua.adjust
  ; "cat",          V.efunc (V.int **-> V.list block **->> block) Block.Lua.cat
  ; "overlap",      V.efunc (V.int **-> Map.placement **-> V.list block **->> block)
                            Block.Lua.overlap 
  ; "overlap_low",  V.efunc (V.int **-> V.list block **->> block)
                            (fun n bs -> Block.Lua.overlap n Block.Low  bs)
  ; "overlap_high", V.efunc (V.int **-> V.list block **->> block)
                            (fun n bs -> try Block.Lua.overlap n Block.High bs
                                with Block.OverlapHigh -> 
                                    C.error "can't overlap blocks at high end") 
  ; "relative",     V.efunc (block **-> V.string **-> V.int **-> V.int **->> block)
                            Block.Lua.relative
  ; "base",         V.efunc (block **->> V.string)          Block.Lua.base
  ; "constraints",  V.efunc (block **->> (V.list V.string)) Block.Lua.constraints
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Boot" 
   [ "qc--.lua",   V.String                            This.boot
   ; "version",    V.efunc (Map.outchan **->> V.unit)  This.version
   ; "manual",     V.String                            This.manual 
   ; "byteorder",  V.String                            This.byteorder
   ; "arch_os",    V.String                            This.arch_os
   ; "install_dir",V.String                            This.install_dir
   ] g;                        
@

We create a [[Caml]] module for functions that come straight out of
{\ocaml} libraries. Unlike the other modules, this has two levels, like
in [[Caml.Filename.check_suffix]].

We make the extension functions from [[Filename]] more forgiving of
files without dots.
<<register modules to [[g]] in alphabetical order>>=
let extension s =
  try
    let without = Filename.chop_extension s in
    String.sub s (String.length without) (String.length s - String.length without)
  with Invalid_argument _ -> "" in
let chop s = try Filename.chop_extension s with Invalid_argument _ -> s in
C.register_module "Caml"
    ["Filename" , V.Table (V.Table.of_list 
        [ "check_suffix",    V.efunc (V.string **-> V.string **->> V.bool)
                                Filename.check_suffix
        ; "chop_extension",  V.efunc (V.string **->> V.string) chop
        ; "extension",       V.efunc (V.string **->> V.string) extension
        ; "concat",          V.efunc (V.string **-> V.string **->> V.string)
                                Filename.concat
        ; "basename",        V.efunc (V.string **->> V.string) Filename.basename
        ])
    ] g;
@
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Cfg" 
    ["Tx" , V.Table (V.Table.of_list 
        [ "set_limit",       V.efunc (V.int **->> V.unit)    G.Tx.set_limit
        ; "used",            V.efunc (V.unit **->> V.int)    G.Tx.used
        ; "last",            V.efunc (V.unit **->> V.string) G.Tx.last
        ])
    ] g;
@
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Dataflow" 
   [ "emit_dot",   V.efunc (V.unit **->> V.unit)  Dataflow.Test.emit_dot
   ] g;                        
@ 
<<register modules to [[g]] in alphabetical order>>=
let new_ok target (map,ast) asm =
  match Nelab.program ~swap:false (Mvalidate.rtl target) map asm (Nast.program ast) with
  | Error.Error -> false
  | Error.Ok (env, _) -> not (Fenv.Dirty.errorFlag env) in
C.register_module "Driver" 
  [ "assemble"  , V.efunc (Map.vasm **->> V.unit)   (fun asm -> asm#emit)
  ; "proc_assembler", V.efunc (Map.vasm **->> (Map.stage V.value)) 
                    (fun asm v p -> asm#cfg_instr p ; true)
  ; "new_ok"    , V.efunc (Map.target **-> Map.ast **-> Map.asm **->> V.bool)  
                          new_ok
  ; "emit_asdl" , V.efunc (Map.ast **->> V.unit)               Driver.emit_asdl
  ; "parse"     , V.efunc (V.string**->> Map.ast)              Driver.parse
  ; "print"     , V.efunc (Map.doc **-> V.int **-> Map.outchan **->> V.unit)
                    Driver.print
  ; "pretty"    , V.efunc (Map.ast **->> Map.doc) Driver.pretty
  ; "scan"      , V.efunc (V.string**->> V.unit)  Driver.scan
  ; "version"   , V.efunc (V.unit  **->> V.unit)  Driver.version
  ; "stdin"     , Map.inchan.V.embed              stdin (* hack *)
  ; "stdout"    , Map.outchan.V.embed             stdout(* hack *)
  ; "compile"  , V.efunc (Map.target **-> Map.optimize Map.proc **-> V.bool **->
                           Map.ast **-> Map.asm **-> V.bool **-> V.bool **->> V.unit) 
                          Driver.compile
  ; "reinit"    , V.efunc (V.unit  **->> V.unit)  Reinit.reset
  ] g;
<<register modules to [[g]] in alphabetical order>>=
let dump f =
  let mktuplelist t = 
    let field f = V.Table.find t (V.String f) in
    let ty      = V.string.V.project (field "type") in
    let widths  = (V.list V.int).V.project (field "widths") in
    List.map (fun w -> (w, ty)) widths in
  let luafun target ccname types = f target ccname 
                                    (List.flatten (List.map mktuplelist types))
  in
  V.efunc (Map.target **-> V.string **-> (V.list V.table) **->> V.unit)
    luafun
in

C.register_module "Debug"
  [ "explain",      V.efunc (V.unit **->> V.unit) Debug.explain
  ; "paths_proc"  , dump Call.paths_proc
  ; "paths_return", dump Call.paths_return
  ; "paths_cutto" , dump Call.paths_cutto
  ; "path_2_in_overflow", V.efunc (Map.target **-> V.string **->> V.unit)
                          Call.path_2_in_overflow
  ; "run_cc_on_args", V.efunc (Map.target **-> V.string **->
                               listpair V.string V.int **->> V.unit)
                      (Call.run_cc_on_sig_and_print (fun s -> s.Automaton.call))
  ; "run_cc_return", V.efunc (Map.target **-> V.string **->
                               listpair V.string V.int **->> V.list (V.list V.string))
                      (Call.run_cc_on_sig_and_return (fun s -> s.Automaton.call))
  ] g;
@
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Expander"
  [ "ppc"  , backplane_stage Ppc.X.cfg
  ; "x86f" , backplane_stage X86.X.cfg
  ; "ia64f", backplane_stage Ia64.X.cfg
  ; "mips" , backplane_stage Mips.X.cfg
  ; "alpha", backplane_stage Alpha.X.cfg
  ; "sparc", backplane_stage Sparc.X.cfg
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Liveness"
  [ "livenessfn", backplane_stage 
       (fun _ p -> Cfgx.Live.set_live p.Proc.cfg; true)
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Optimize"
  [ "simplify_exps"         , backplane_stage Optimize.simplify_exps
  ; "collapse_branch_chains", backplane_stage Optimize.collapse_branch_chains
  ; "remove_nops"           , backplane_stage Optimize.remove_nops
  ; "validate"              , backplane_stage Optimize.validate
  ; "trim_unreachable_code" , backplane_stage Optimize.trim_unreachable_code
  ; "peephole"              , backplane_stage Peephole.subst_forward
  ; "deadfn"                , backplane_stage Dead.elim_assignments
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Placevar"
  [ "contextfn", V.efunc ((Map.proc --> Map.automaton) **->>  (* currying *)
                        V.func (V.value **-> Map.proc **->> V.bool)) Placevar.context
  ; "ppc",     V.efunc (Map.proc **->> Map.automaton)       Ppc.placevars
  ; "x86",     V.efunc (Map.proc **->> Map.automaton)       X86.placevars
  ; "mips",    V.efunc (Map.proc **->> Map.automaton)       Mips.placevars
  ; "ia64",    V.efunc (Map.proc **->> Map.automaton)       Ia64.placevars
  ; "sparc",   V.efunc (Map.proc **->> Map.automaton)       Sparc.placevars
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Runtime"
  [ "emit_data", V.efunc (Map.asm **->> (Map.stage Map.proc))
       (fun asm _ proc -> Runtimedata.emit_as_asm proc.Proc.target asm
                                                proc.Proc.symbol proc.Proc.spans)
  ; "reg_mapping", V.efunc (Map.target **->> V.unit) Runtimedata.print_reg_map
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Simplify"
  [ "compile_time_ops", (V.list V.string).V.embed Simplify.compile_time_ops
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Stack"
  [ "freeze",  V.efunc (Map.proc **-> Map.block **->> V.unit)   Stack.freeze
  ; "blocks",  V.efunc (Map.proc **->> (V.record V.value))
                       (Stack.blocks Map.block.V.embed (V.list V.value).V.embed
                                     (V.record V.value).V.embed)
  ; "ccname",  V.efunc (Map.proc **->> V.string) (fun p -> p.Proc.cc.Call.name)
  ; "procname",V.efunc (Map.proc **->> V.string) (fun p -> p.Proc.symbol#original_text)
  ] g;                    
@ 
PERHAPS THIS CODE SHOULD REPLACE THE SOMEWHAT HEAVYWEIGHT [[Asm.dot]]???
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Stages"
  [ "writedot", backplane_stage
      (fun _ proc -> 
        prerr_string
          (Cfgutil.cfg2dot ~compress:true ~live:true
             ~name:proc.Proc.symbol#mangled_text proc.Proc.cfg);
        flush stderr;
        true)
  ; "replace_vfp", backplane_stage
      (fun _ proc -> proc.Proc.cc.Call.replace_vfp proc.Proc.cfg; true)
  ]  g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Targets"
  [ "dummy32l", Map.target.V.embed Dummy.dummy32l'
  ; "dummy32b", Map.target.V.embed Dummy.dummy32b'
  ; "ppc",      Map.target.V.embed Ppc.target
  ; "x86",      Map.target.V.embed X86.target
  ; "mips",     Map.target.V.embed Mips.target
  ; "alpha",    Map.target.V.embed Alpha.target
  ; "ia64",     Map.target.V.embed Ia64.target
  ; "sparc",    Map.target.V.embed Sparc.target
  ; "interp",   Map.target.V.embed Interp.target'
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Typecheck" 
 [ "proc",       V.efunc (V.value **-> Map.proc **->> V.int)
                         (fun _ proc -> Typecheck.proc proc; 1)
 ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Unsupported" 
 [ "explain", V.efunc (V.int **-> V.int *****->> V.unit) Unsupported.explain
 ] g;
<<register modules to [[g]] in alphabetical order>>=
let floats ws _ proc =
  let rml = proc.Proc.target.Target.rounding_mode in
  let rm  = Rtlutil.fetch rml in
  G.iter_nodes (G.update_instr (Widen.float ~rm ws)) proc.Proc.cfg;
  1 in
let const n _ proc = G.iter_nodes (G.update_instr (Widen.store_const n)) proc.Proc.cfg;
  1 in
let op_count _ proc =
  Printf.printf "op_count called\n";
  let count = ref 0 in
  let update_count r =
    count := !count + Widen.app_count r
  in
  let do_count = G.update_instr (fun r -> update_count r; r) in
  let () = G.iter_nodes do_count proc.Proc.cfg in
  Printf.printf "Op count = %i\n" !count;
  1
in
let width_cost _ proc =
  Printf.printf "width_cost called\n";
  let sxcount = ref 0 in
  let zxcount = ref 0 in
  let locount = ref 0 in
  let update_count r =
    let (sx, zx, lo) = Widen.width_cost r in
    sxcount := !sxcount + sx;
    zxcount := !zxcount + zx;
    locount := !locount + lo;
  in
  let count   = G.update_instr (fun r -> update_count r; r) in
  let total = !sxcount + !zxcount + !locount in
  Printf.printf "Summary: total=%i, sx=%i, zx=%i, lo=%i\n" total !sxcount !zxcount !locount;
  1
in
let update_gamma_counts _ proc =
  let f x = try G.update_instr (Widen.update_gamma_counts proc.Proc.target) x with Widen.Don't_update -> ()
  in
  Widen.init_gamma_counts();
  G.iter_nodes f proc.Proc.cfg; 1
in
let create_gamma _ _=
(*
  let done_this = ref false in
  (fun _ _ -> (if not !done_this then (done_this := true; Widen.create_gamma())); 1)
*)
Widen.create_gamma(); 1
in
let dpwiden _ proc =
  let upd g r = if Widen.needs_widening proc.Proc.target r then g r
              else raise Widen.Doesn't_need_widening in
  (* better alternative *)
  let widen node = match G.to_executable node with
  | Some r when Widen.needs_widening proc.Proc.target r ->
      G.update_instr (Widen.dpwiden proc.Proc.target) node
  | _ -> () in
  let f g x =
    try 
      G.update_instr (upd g) x
    with Widen.Doesn't_need_widening -> ()
  in
  G.iter_nodes (f (Widen.dpwiden proc.Proc.target)) proc.Proc.cfg;
  1
in
let widenlocs _ proc =
  let upd g r = if Widen.needs_widening proc.Proc.target r then g r
              else raise Widen.Doesn't_need_widening in
  let f g x =
    try
      G.update_instr (upd g) x
    with Widen.Doesn't_need_widening -> ()
  in
  G.iter_nodes (f (Widen.widenlocs proc.Proc.target)) proc.Proc.cfg;
  1
in
C.register_module "Widen" 
 [ "x86_floats", V.efunc (V.value **-> Map.proc **->> V.int) (floats [80])
 ; "store_const",
       V.efunc (V.int **->> V.func (V.value **-> Map.proc **->> V.int)) const
 ; "width_cost", V.efunc (V.value **-> Map.proc **->> V.int) width_cost
 ; "update_gamma_counts", V.efunc (V.value **-> Map.proc **->> V.int) update_gamma_counts
 ; "create_gamma", V.efunc (V.value **-> Map.proc **->> V.int) create_gamma
 ; "dpwiden", V.efunc (V.value **-> Map.proc **->> V.int) dpwiden
 ; "widenlocs", V.efunc (V.value **-> Map.proc **->> V.int) widenlocs
 ; "op_count", V.efunc (V.value **-> Map.proc **->> V.int) op_count
 ] g;
<<register modules to [[g]] in alphabetical order>>=
let pic load_wkr use_return proc =
  let import _ = Error.error "imports not supported in PIC code" in
  Pic.transform ~import ~load_wkr ~use_return proc;
  1
in
(* THESE WELL-KNOWN PIC REGISTERS SHOULD PROBABLY BE CONFIGURABLE IN LUA *)
let regc5 = (('c', Rtl.Identity, Cell.of_size 32), 5, Rtl.C 1) in
let pic_ppc _ proc = 
  let load_wkr l = Rtl.store l (Rtl.fetch (Rtl.reg regc5) 32) 32 in
  pic load_wkr false proc in
let x86_mspace = ('m', Rtl.LittleEndian, Cell.of_size 8) in
let pic_x86 _ proc =
  let amem       = Rtl.mem (Rtl.aligned 4) x86_mspace (Rtl.C 4) in
  let esp        = Rtl.reg X86regs.esp in
  let espval     = Rtl.fetch esp 32 in
  let load_wkr l = Rtl.store l (Rtl.fetch (amem espval) 32) 32 in
  pic load_wkr true proc in
C.register_module "Pic"
 [ "ppc", V.efunc (V.value **-> Map.proc **->> V.int) pic_ppc
 ; "x86", V.efunc (V.value **-> Map.proc **->> V.int) pic_x86
 ] g;

  let namestring = function
    | None -> "<no name>"
    | Some n ->
        match n with
        | V.Fallback s -> s
        | V.Global s -> s
        | V.Element (s, V.String n) -> s ^ "." ^ n
        | V.Element (s, V.Number x) -> s ^ "[" ^ string_of_int (int_of_float x) ^ "]"
        | V.Element (s, _         ) -> s ^ ".?" in
<<lua initialization>>=
"Expander.x86 = { fn = Expander.x86f, uses = { 'proper widths', 'no vars' }, \
                  name = 'Expander.x86', creates = { 'x86 invariant' }, \
                  doc = 'A prototype code expander for the x86' } \
 Expander.ia64 = { fn = Expander.ia64f, uses = { 'proper widths', 'no vars' }, \
                   name = 'Expander.ia64', creates = { 'ia64 invariant' }, \
                   doc = 'A code expander for the ia64' }"
@
