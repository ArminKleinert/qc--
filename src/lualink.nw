% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% vim: ts=8 sw=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Linking the Lua Interpreter}\label{sect:lua-link}
% ------------------------------------------------------------------ 

The compiler is controlled by an embedded Lua interpreter. Types and
values of the compiler are made available as Lua primitives and allow
the user to control the compiler. We build here an interpreter with our
extensions.

<<lualink.mli>>=
module I : Lua.INTERP
@

<<lualink.ml>>=
module G = Cfgx.M

<<Linking QC-- Types>>

module Reloc        = Sledlib.MkReloc (struct type symbol = Symbol.t end)
module NewBackplane = Backplane.M'

module T1 = Lua.Lib.Combine.T5
                (DocType)                   (* T1.TV1 *)
                (Luaiolib.T)                (* T1.TV2 *)
                (AsmType)                   (* T1.TV3 *)
                (AstType)                   (* T1.TV4 *)
                (Colorgraph.NewGCT)         (* T1.TV5 *)

module T    = Lua.Lib.Combine.T9            (* types *)
                (T1)                        (* T.TV1 *)
                (NewBackplane.T)            (* T.TV2 *)
                (EnvType)                   (* T.TV3 *)
                (ProcType)                  (* T.TV4 *)
                (NewTargetType)             (* T.TV5 *)
                (BlockType)                 (* T.TV6 *)
                (AutomatonType)             (* T.TV7 *)
                (CCStageType)               (* T.TV8 *)
                (CounterType)               (* T.TV9 *)

module T1' = Lua.Lib.Lift (T1) (T.TV1)

module DocTV             = T1'.TV1
module LuaioTV           = T1'.TV2
module AsmTV             = T1'.TV3
module AstTV             = T1'.TV4
module NewColorgraphTV   = T1'.TV5

module NewBackplaneTV    = T.TV2
module EnvTV             = T.TV3
module NewProcTV         = T.TV4
module NewTargetTV       = T.TV5
module BlockTV           = T.TV6
module AutomatonTV       = T.TV7
module CCStageTV         = T.TV8
module CounterTV         = T.TV9

module WT = Lua.Lib.WithType (T)

module C = 
  Lua.Lib.Combine.C8                   (* up to 10 libraries *)
    (Luaiolib.Make (LuaioTV))
    (WT (Luastrlib.M))
    (WT (Luamathlib.M))
    (MakeLib 
        (AsmTV) (AstTV) (EnvTV) (NewProcTV) (NewTargetTV) (DocTV) (LuaioTV)
        (BlockTV) (AutomatonTV) (CCStageTV) (CounterTV))
    (Colorgraph.NewMake (NewBackplaneTV) (NewColorgraphTV) (NewProcTV))
    (Dls.Make (NewBackplaneTV) (NewProcTV))
    (WT (Luautil.MakeLib))
    (NewBackplane.MakeLua  (NewBackplaneTV) (NewProcTV))

module I = 
  Lua.MakeInterp                            (* our interpreter *)
    (Lua.Parser.MakeStandard)
    (Lua.MakeEval (T) (C))
@


% ------------------------------------------------------------------ 
\subsection{Export to Lua}
% ------------------------------------------------------------------ 

<<Linking QC-- Types>>=
module NewPersonality = struct
    type proc = Ast2ir.proc
    let target      = Dummy.dummy32b'
    let memsize     = 8
    let wordsize    = 32
    let pointersize = wordsize
    let byteorder   = Rtl.BigEndian
    let charset     = "latin1"
    let float       = "ieee754"

    let cfg2ast proc =
      Cfgutil.cfg2ast Rtlutil.ToAST.rtl proc.Proc.cfg proc.Proc.symbol#mangled_text
end
@

The assemblers for the {\AST} and the interpreter are polymorphic. We
have to supply a target description that defines the sizes of words and
so forth.

<<Linking QC-- Types>>=
module NewAstAsm = Astasm.Make(NewPersonality)

module AsmType = struct
    type 'a t       = 'a Asm.assembler
    let tname       = "asm"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<asm>" 
end
module AstType = struct
    type 'a t       = Srcmap.map * Ast.program
    let tname       = "ast"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<ast>" 
  end
module EnvType = struct
    type 'a t       = 'a Fenv.Clean.env'
    let tname       = "env"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<env>" 
end
module ProcType : Lua.Lib.USERTYPE with type 'a t = Ast2ir.proc = 
struct
    type 'a t       = Ast2ir.proc
    let tname       = "new proc"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> ("<new proc "^t.Proc.symbol#mangled_text^">") 
end
module NewTargetType = struct
    type 'a t       = Ast2ir.tgt
    let tname       = "new target"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<new target " ^ t.Target.name ^ ">" 
end
module DocType = struct
    type 'a t       = Pp.doc
    let tname       = "doc"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<doc>" 
end
module BlockType = struct
    type 'a t       = Block.t
    let tname       = "block"
    let eq _        = fun x y -> x = y
    let to_string   = fun _ t -> "<block>"
end
module AutomatonType = struct
    type 'a t       = Automaton.t
    let tname       = "automaton"
    let eq _        = fun x y -> false
    let to_string   = fun _ t -> "<automaton>"
end
module CCStageType = struct
    type 'a t       = Automaton.stage
    let tname       = "ccstage"
    let eq _        = fun x y -> false
    let to_string   = fun _ t -> "<cconv. stage>"
end
module CounterType = struct
    type 'a t       = int ref
    let tname       = "counter"
    let eq _        = fun x y -> false
    let to_string   = fun _ t -> "<mutable counter>"
end

module MakeLib
  (AsmV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AsmType.t)
  (AstV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AstType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (EnvV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a EnvType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (ProcV   : Lua.Lib.TYPEVIEW with type 'a t     = 'a ProcType.t
                              and  type 'a combined = 'a AsmV.combined)
  (NewTargetV : Lua.Lib.TYPEVIEW with type 'a t     = 'a NewTargetType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (DocV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a DocType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (InOutV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a Luaiolib.T.t    
                              and  type 'a combined = 'a AsmV.combined)
  (BlockV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a BlockType.t    
                              and  type 'a combined = 'a AsmV.combined)
  (AutomatonV  : Lua.Lib.TYPEVIEW with type 'a t    = 'a AutomatonType.t    
                              and  type 'a combined = 'a AsmV.combined)
  (CCStageV : Lua.Lib.TYPEVIEW with type 'a t       = 'a CCStageType.t
                              and  type 'a combined = 'a AsmV.combined)
  (CounterV : Lua.Lib.TYPEVIEW with type 'a t       = 'a CounterType.t
                              and  type 'a combined = 'a AsmV.combined)
    
    : Lua.Lib.USERCODE with type 'a userdata' = 'a AsmV.combined =

struct
  type 'a userdata' = 'a AsmV.combined
  module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a userdata') =
    struct
      module V = C.V
      let ( **-> ) = V.( **-> )
      let ( --> )  = V.( --> )
      let ( **->> ) x y = x **-> V.result y 
      let ( *****->> ) = V.dots_arrow
      <<export goodies to Lua>>
    end (*M*)
end (*MakeLib*)
@ 

HOW ARE THE DIFFERENT ASSEMBLERS [[asm]], [[vasm]], [[new_asm]] SUPPOSED TO
BE USED?  SOME DOCUMENTATION WOULD BE WELCOME. --CL

<<export goodies to Lua>>=
module Map = struct
    let compose ~lo ~hi =
       { V.embed   = (fun x -> hi.V.embed (lo.V.embed x))
       ; V.project = (fun x -> lo.V.project (hi.V.project x))
       ; V.is      = (fun x -> hi.V.is x && lo.V.is (hi.V.project x))
       } 
    let ast       = AstV.makemap  V.userdata V.projection
    let proc      = ProcV.makemap V.userdata V.projection
    let vasm      = AsmV.makemap  V.userdata V.projection
      (* embeds and projects a V.value assembler *)
    let asm' proc =
      compose { V.embed   = Asm.map proc.V.project
              ; V.project = Asm.map proc.V.embed 
              ; V.is      = (fun _ -> true) } (* here's a hopeful notion *)
        vasm
    let asm = asm' proc
    let venv = EnvV.makemap    V.userdata V.projection
    let env' proc =
      compose { V.embed   = Fenv.Clean.map proc.V.project
              ; V.project = Fenv.Clean.map proc.V.embed 
              ; V.is      = (fun _ -> true) } (* and more hope *)
      venv
    let env = env' proc

    let doc           = DocV.makemap       V.userdata V.projection
    let new_target    = NewTargetV.makemap V.userdata V.projection
    let optimize proc = V.closure (proc **-> V.runit)
    let channel       = InOutV.makemap     V.userdata V.projection
    let inchan        = Luaiolib.in'       channel    V.projection
    let outchan       = Luaiolib.out       channel    V.projection
    let stage proc    = V.func (V.value **-> proc **->> V.bool)
    let block         = BlockV.makemap     V.userdata V.projection
    let automaton     = AutomatonV.makemap V.userdata V.projection

    let ccstage       = CCStageV.makemap   V.userdata V.projection
    let counter       = CounterV.makemap   V.userdata V.projection
end
@ 
We also need to import Lua projection/embedding pairs defined in other modules.
<<export goodies to Lua>>=
module RL = Register.RT(C)
@ 
Here we finally bind the exported values to names in the Lua
interpreter. The [[compile]] function receives a lua value such that it
can call Lua functions while it is active.
<<export goodies to Lua>>=
let init g = 
  let backplane_stage = V.efunc (V.value **-> Map.proc **->> V.bool) in
  <<register modules to [[g]] in alphabetical order>>
  Lua.Lib.StringList.of_list [ <<lua initialization>> ]

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Asm"
  [ "cmm" , V.efunc (Map.outchan **->> Map.asm) NewAstAsm.asm     
  ; "dot" , V.efunc (Map.outchan **->> Map.asm) (Dotasm.asm ~compress:true ~live:false)
  ; "big_dot" , V.efunc (Map.outchan **->> Map.asm) 
                            (Dotasm.asm ~compress:false ~live:true)
  ; "x86" ,  V.efunc (Map.outchan **->> Map.asm) (X86asm.make Cfgutil.emit)
  ; "mips",  V.efunc (Map.outchan **->> Map.asm) (Mipsasm.make Cfgutil.emit)
  ; "alpha", V.efunc (Map.outchan **->> Map.asm) (Alphaasm.make Cfgutil.emit)
  ; "interp32l" , V.efunc (Map.outchan **->> Map.asm) 
            (Interpasm.asm' ~byteorder:Rtl.LittleEndian ~memsize:8 ~ptrsize:32)
  ; "interp32b" , V.efunc (Map.outchan **->> Map.asm) 
            (Interpasm.asm' ~byteorder:Rtl.BigEndian ~memsize:8 ~ptrsize:32)
  ] g;
@ 
For information on how we represent registers in Lua, see \module{register.nw}.
<<register modules to [[g]] in alphabetical order>>=
let regty = RL.map in
let overflow memsize bo growth max_alignment =
  let byteorder =
    match String.lowercase bo with
    | "little" -> Rtl.LittleEndian
    | "big"    -> Rtl.BigEndian
    | _        -> raise (V.Projection (V.String bo, "byteorder")) in
  let growth =
    match String.lowercase growth with
    | "down"   -> Memalloc.Down
    | "up"     -> Memalloc.Up
    | _        -> raise (V.Projection (V.String growth, "memory growth")) in
  Automaton.overflow ~memsize ~byteorder ~growth ~max_alignment in

let choice_funs f choices =
  let rec choice cs = match cs with
  |	pred :: s :: rest ->
      let camlpred = match pred with
        | V.String   h -> Automaton.is_hint  h
        | V.Number   _ -> Automaton.is_width (V.int.V.project pred)
        | V.Function _ ->
            let ff = V.func (V.string **-> V.int **->> V.bool) in
                ff.V.project pred
        | _            -> raise (V.Projection (pred, "choice predicate")) in
      let stages = (V.list Map.ccstage).V.project s
      in
        (camlpred, List.fold_right Automaton.( *> ) stages Automaton.unit) ::
        (choice rest)
  |	[] -> []
  |	_  -> raise (V.Projection (V.Nil, "choice predicate/stage list"))
  in
  f (choice choices) in

let widths_errmsg i = 
  Printf.sprintf "width %d not supported in this calling convention" i in
let useregs_errmsg i rs =
  Printf.sprintf
    "cannot satisfy allocation request of width %d with useregs stage" i in

C.register_module "Automaton"
  [ (* first the stage constructors ... *)
    "align_to"    , V.efunc ((V.func (V.int **->> V.int)) **->> Map.ccstage)
                    Automaton.align_to
  ; "argcounter"  , V.efunc (Map.counter        **->> Map.ccstage)
                    Automaton.argcounter
  ; "bitcounter"  , V.efunc (Map.counter        **->> Map.ccstage)
                    Automaton.bitcounter
  ; "overflow"    , V.efunc (V.table **->> Map.ccstage)
                    (fun ovfl ->
                        let field f = V.Table.find ovfl (V.String f) in
                        overflow
                          (V.int.V.project    (field "memsize"))
                          (V.string.V.project (field "byteorder"))
                          (V.string.V.project (field "growth"))
                          (V.int.V.project    (field "max_alignment")))
  ; "regs_by_args", V.efunc (Map.counter **-> V.list regty **->>
                             Map.ccstage)
                    Automaton.argnoregs
  ; "regs_by_bits", V.efunc (Map.counter **-> V.list regty **->>
                             Map.ccstage)
                    Automaton.offsetregs
  ; "useregs"     , V.efunc (V.list regty **->> Map.ccstage)
                    (fun rs -> Automaton.useregs rs ~errormsg:useregs_errmsg)
  ; "widen"       , V.efunc ((V.func (V.int **->> V.int)) **->> Map.ccstage)
                    Automaton.widen
  ; "widths"      , V.efunc (V.list V.int **->> Map.ccstage)
                    (fun ws -> Automaton.widths ws ~errormsg:widths_errmsg)
  ; "choice"      , V.efunc (V.list V.value **->> Map.ccstage)
                    (choice_funs Automaton.choice)
  ; "first_choice", V.efunc (V.list V.value **->> Map.ccstage)
                    (choice_funs Automaton.first_choice)

    (* the prewritten utils ... *)
  ; "is_any"      , V.efunc (V.string **-> V.int **->> V.bool)
                    Automaton.is_any
  ; "new_counter" , V.efunc (V.int **->> Map.counter)
                    Automaton.new_counter
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Block" 
  [ "size",       V.efunc (Map.block **->> V.int)     Block.Lua.size
  ; "alignment",  V.efunc (Map.block **->> V.int)     Block.Lua.alignment
  ; "adjust",     V.efunc (Map.block **->> Map.block) Block.Lua.adjust
  ; "cat",        V.efunc (V.int **-> V.list Map.block **->> Map.block) Block.Lua.cat
  ; "overlap",    V.efunc (V.int **-> V.string **-> V.list Map.block **->> Map.block)
                          (Block.Lua.overlap (C.error g))
  ; "relative",   V.efunc (Map.block **-> V.string **-> V.int **-> V.int 
                                     **->> Map.block) Block.Lua.relative
  ; "base",       V.efunc (Map.block **->> V.string) Block.Lua.base
  ; "constraints",V.efunc (Map.block **->> (V.list V.string)) Block.Lua.constraints
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Boot" 
   [ "qc--.lua",   V.String                            This.boot
   ; "version",    V.efunc (Map.outchan **-> V.runit)  This.version
   ; "manual",     V.String                            This.manual 
   ; "byteorder",  V.String                            This.byteorder
   ; "arch_os",    V.String                            This.arch_os
   ; "install_dir",V.String                            This.install_dir
   ] g;                        
@

We create a [[Caml]] module for functions that come straight out of
{\ocaml} libraries. Unlike the other modules, this has two levels, like
in [[Caml.Filename.check_suffix]].

We make the extension functions from [[Filename]] more forgiving of
files without dots.
<<register modules to [[g]] in alphabetical order>>=
let extension s =
  try
    let without = Filename.chop_extension s in
    String.sub s (String.length without) (String.length s - String.length without)
  with Invalid_argument _ -> "" in
let chop s = try Filename.chop_extension s with Invalid_argument _ -> s in
C.register_module "Caml"
    ["Filename" , V.Table (V.Table.of_list 
        [ "check_suffix",    V.efunc (V.string **-> V.string **->> V.bool)
                                Filename.check_suffix
        ; "chop_extension",  V.efunc (V.string **->> V.string) chop
        ; "extension",       V.efunc (V.string **->> V.string) extension
        ; "concat",          V.efunc (V.string **-> V.string **->> V.string)
                                Filename.concat
        ; "basename",        V.efunc (V.string **->> V.string) Filename.basename
        ])
    ] g;
@

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Dataflow" 
   [ "emit_dot",   V.efunc (V.unit **-> V.runit)  Dataflow.Test.emit_dot
   ] g;                        
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Driver" 
  [ "assemble"  , V.efunc (Map.vasm **-> V.runit)   (fun asm -> asm#emit)
  ; "proc_assembler", V.efunc (Map.vasm **->> (Map.stage V.value)) 
                    (fun asm v p -> asm#cfg_instr p ; true)
  ; "check"     , V.efunc (Map.ast **-> Map.asm **->> Map.env) Driver.check
  ; "emit_asdl" , V.efunc (Map.ast **-> V.runit)               Driver.emit_asdl
  ; "parse"     , V.efunc (V.string**->> Map.ast)              Driver.parse
  ; "print"     , V.efunc (Map.doc **-> V.int **-> Map.outchan **-> V.runit)
                    Driver.print
  ; "pretty"    , V.efunc (Map.ast **->> Map.doc) Driver.pretty
  ; "scan"      , V.efunc (V.string**-> V.runit)  Driver.scan
  ; "version"   , V.efunc (V.unit  **-> V.runit)  Driver.version
  ; "stdin"     , Map.inchan.V.embed              stdin (* hack *)
  ; "stdout"    , Map.outchan.V.embed             stdout(* hack *)
  ; "compile"   , V.efunc (Map.optimize Map.proc **-> V.bool **->
                           Map.ast **-> Map.new_target **-> Map.env **->> Map.asm) 
                          Driver.compile
  ; "reinit"    , V.efunc (V.unit  **-> V.runit)  Driver.reinit
  ] g;
<<register modules to [[g]] in alphabetical order>>=
let dump =   V.efunc ((V.list V.int)    **-> (* widths *)
                      (V.list V.string) **-> (* hints  *)
                       V.result V.unit)  

in C.register_module "Debug"
    ["Mips" , V.Table (V.Table.of_list 
        [ "proc",           dump Mipscall.dump_proc
        ; "proc_all",       V.efunc (V.unit **-> V.runit) 
                            (fun () -> Mipscall.dump_proc'
                            [32,"int";32,"float";64,"float"])
        ; "proc_all_paths", V.efunc (V.unit **-> V.runit) 
                            (fun () -> Mipscall.paths_proc'
                            [32,"int";32,"float";64,"float"])
        ; "cutto",          dump Mipscall.dump_cutto
        ; "proc_paths",     dump Mipscall.paths_proc
        ; "cutto_paths",    dump Mipscall.paths_cutto
        ])
     ;"Alpha" , V.Table (V.Table.of_list 
        [ "proc",           dump Alphacall.dump_proc
        ; "cutto",          dump Alphacall.dump_cutto
        ; "proc_paths",     dump Alphacall.paths_proc
        ; "cutto_paths",    dump Alphacall.paths_cutto
        ])
    ;"X86" , V.Table (V.Table.of_list 
        [ "c_proc",         dump X86call.dump_c_proc
        ; "c_cutto",        dump X86call.dump_c_cutto
        ; "c_proc_paths",   dump X86call.paths_c_proc
        ; "c_cutto_paths",  dump X86call.paths_c_cutto
        ])
    ] g;
@
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Expander"
  [ "x86f" , backplane_stage X86.X.cfg
  ; "mips" , backplane_stage Mips.X.cfg
  ; "alpha", backplane_stage Alpha.X.cfg
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Liveness"
  [ "liveness", backplane_stage 
       (fun _ p -> Cfgx.Live.set_live p.Proc.cfg; true)
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Optimize"
  [ "trim_unreachable_code",  backplane_stage Optimize.trim_unreachable_code
  ; "collapse_branch_chains", backplane_stage Optimize.collapse_branch_chains
  ; "remove_nops",            backplane_stage Optimize.remove_nops
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Placevar"
  [ "fortran", backplane_stage Placevar.fortran'
  ; "context", V.efunc ((Map.proc --> Map.automaton) **->>  (* currying *)
                        V.func (V.value **-> Map.proc **->> V.bool)) Placevar.context
  ; "x86",     V.efunc (Map.proc **->> Map.automaton)       X86.placevars
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Simplify"
  [ "compile_time_ops", (V.list V.string).V.embed Simplify.compile_time_ops
  ] g;

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Stack"
  [ "freeze",  V.efunc (Map.proc **-> Map.block **-> V.runit)   Stack.freeze
  ; "blocks",  V.efunc (Map.proc **->> (V.record V.value))
                       (Stack.blocks Map.block.V.embed (V.list V.value).V.embed
                                     (V.record V.value).V.embed)
  ; "ccname",  V.efunc (Map.proc **->> V.string) (fun p -> p.Proc.cc.Call.name)
  ; "procname",V.efunc (Map.proc **->> V.string) (fun p -> p.Proc.symbol#original_text)
  ] g;                    
@ 
PERHAPS THIS CODE SHOULD REPLACE THE SOMEWHAT HEAVYWEIGHT [[Asm.dot]]???
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Stages"
  [ "writedot", backplane_stage
      (fun _ proc -> 
        prerr_string
          (Cfgutil.cfg2dot ~compress:true ~live:true
             ~name:proc.Proc.symbol#mangled_text proc.Proc.cfg);
        flush stderr;
        true)
  ; "replace_vfp", backplane_stage
      (fun _ proc -> proc.Proc.cc.Call.replace_vfp proc.Proc.cfg; true)
  ]  g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Targets"
  [ "dummy32l", Map.new_target.V.embed Dummy.dummy32l'
  ; "dummy32b", Map.new_target.V.embed Dummy.dummy32b'
  ; "x86",      Map.new_target.V.embed X86.target
  ; "mips",     Map.new_target.V.embed Mips.target
  ; "alpha",    Map.new_target.V.embed Alpha.target
  ; "interp",   Map.new_target.V.embed Interp.target'
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Typecheck" 
 [ "proc",       V.efunc (V.value **-> Map.proc **->> V.int)
                         (fun _ proc -> Typecheck.proc proc; 1)
 ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Unsupported" 
 [ "explain", V.efunc (V.int **-> V.int *****->> V.unit) Unsupported.explain
 ] g;
<<register modules to [[g]] in alphabetical order>>=
let floats ws _ proc =
  let rml = proc.Proc.target.Target.rounding_mode in
  let rm  = Rtlutil.fetch rml in
  G.iter_nodes (G.update_instr (Widen.float ~rm ws)) proc.Proc.cfg;
  1 in
let const n _ proc = G.iter_nodes (G.update_instr (Widen.store_const n)) proc.Proc.cfg;
  1 in
C.register_module "Widen" 
 [ "x86_floats", V.efunc (V.value **-> Map.proc **->> V.int) (floats [80])
 ; "store_const",
       V.efunc (V.int **->> V.func (V.value **-> Map.proc **->> V.int)) const
 ] g;

  let namestring = function
    | None -> "<no name>"
    | Some n ->
        match n with
        | V.Fallback s -> s
        | V.Global s -> s
        | V.Element (s, V.String n) -> s ^ "." ^ n
        | V.Element (s, V.Number x) -> s ^ "[" ^ string_of_int (int_of_float x) ^ "]"
        | V.Element (s, _         ) -> s ^ ".?" in
<<lua initialization>>=
"Expander.x86 = { fn = Expander.x86f, uses = { 'proper widths', 'no vars' }, \
                  name = 'Expander.x86', creates = { 'x86 invariant' }, \
                  doc = 'A prototype code expander for the x86 (new proc)' }";
""
@
