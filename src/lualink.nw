% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% vim: ts=8 sw=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Linking the Lua Interpreter}\label{sect:lua-link}
% ------------------------------------------------------------------ 

The compiler is controlled by an embedded Lua interpreter. Types and
values of the compiler are made available as Lua primitives and allow
the user to control the compiler. We build here an interpreter with our
extensions.

<<lualink.mli>>=
module I : Lua.INTERP
@

<<lualink.ml>>=
<<Linking QC-- Types>>

module Reloc        = Sledlib.MkReloc (struct type symbol = Symbol.t end)
module NewBackplane = Backplane.M'

module T1 = Lua.Lib.Combine.T5
                (DocType)                   (* T1.TV1 *)
                (Luaiolib.T)                (* T1.TV2 *)
                (AsmType)                   (* T1.TV3 *)
                (AstType)                   (* T1.TV4 *)
                (Colorgraph.NewGCT)         (* T1.TV5 *)

module T    = Lua.Lib.Combine.T6            (* types *)
                (T1)                        (* T.TV1 *)
                (NewBackplane.T)            (* T.TV2 *)
                (EnvType)                   (* T.TV3 *)
                (ProcType)                  (* T.TV4 *)
                (NewTargetType)             (* T.TV5 *)
                (BlockType)                 (* T.TV6 *)

module T1' = Lua.Lib.Lift (T1) (T.TV1)

module DocTV             = T1'.TV1
module LuaioTV           = T1'.TV2
module AsmTV             = T1'.TV3
module AstTV             = T1'.TV4
module NewColorgraphTV   = T1'.TV5

module NewBackplaneTV    = T.TV2
module EnvTV             = T.TV3
module NewProcTV         = T.TV4
module NewTargetTV       = T.TV5
module BlockTV           = T.TV6

module WT = Lua.Lib.WithType (T)

module C = 
  Lua.Lib.Combine.C8                   (* up to 10 libraries *)
    (Luaiolib.Make (LuaioTV))
    (WT (Luastrlib.M))
    (WT (Luamathlib.M))
    (MakeLib 
        (AsmTV) (AstTV) (EnvTV) (NewProcTV) (NewTargetTV) (DocTV) (LuaioTV) (BlockTV))
    (Colorgraph.NewMake (NewBackplaneTV) (NewColorgraphTV) (NewProcTV))
    (Dls.Make (NewBackplaneTV) (NewProcTV))
    (WT (Luautil.MakeLib))
    (NewBackplane.MakeLua  (NewBackplaneTV) (NewProcTV))

module I = 
  Lua.MakeInterp                            (* our interpreter *)
    (Lua.Parser.MakeStandard)
    (Lua.MakeEval (T) (C))
@


% ------------------------------------------------------------------ 
\subsection{Export to Lua}
% ------------------------------------------------------------------ 

<<Linking QC-- Types>>=
module NewPersonality = struct
    type proc = Ast2ir.proc
    let target      = Dummy.dummy32b'
    let memsize     = 8
    let wordsize    = 32
    let pointersize = wordsize
    let byteorder   = Rtl.BigEndian
    let charset     = "latin1"
    let float       = "ieee754"

    let cfg2ast proc =
      Cfgutil.cfg2ast Rtlutil.ToAST.rtl proc.Proc.cfg proc.Proc.symbol#mangled_text
end
@

The assemblers for the {\AST} and the interpreter are polymorphic. We
have to supply a target description that defines the sizes of words and
so forth.

<<Linking QC-- Types>>=
module NewAstAsm = Astasm.Make(NewPersonality)

module AsmType = struct
    type 'a t       = 'a Asm.assembler
    let tname       = "asm"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<asm>" 
end
module AstType = struct
    type 'a t       = Srcmap.map * Ast.program
    let tname       = "ast"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<ast>" 
  end
module EnvType = struct
    type 'a t       = 'a Fenv.Clean.env'
    let tname       = "env"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<env>" 
end
module ProcType : Lua.Lib.USERTYPE with type 'a t = Ast2ir.proc = 
struct
    type 'a t       = Ast2ir.proc
    let tname       = "new proc"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> ("<new proc "^t.Proc.symbol#mangled_text^">") 
end
module NewTargetType = struct
    type 'a t       = Ast2ir.tgt
    let tname       = "new target"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<new target " ^ t.Target.name ^ ">" 
end
module DocType = struct
    type 'a t       = Pp.doc
    let tname       = "doc"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<doc>" 
end
module BlockType = struct
    type 'a t       = Block.t
    let tname       = "block"
    let eq _        = fun x y -> x = y
    let to_string   = fun _ t -> "<block>"
end

module MakeLib
  (AsmV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AsmType.t)
  (AstV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AstType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (EnvV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a EnvType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (ProcV   : Lua.Lib.TYPEVIEW with type 'a t     = 'a ProcType.t
                              and  type 'a combined = 'a AsmV.combined)
  (NewTargetV : Lua.Lib.TYPEVIEW with type 'a t     = 'a NewTargetType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (DocV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a DocType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (InOutV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a Luaiolib.T.t    
                              and  type 'a combined = 'a AsmV.combined)
  (BlockV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a BlockType.t    
                              and  type 'a combined = 'a AsmV.combined)
    
    : Lua.Lib.USERCODE with type 'a userdata' = 'a AsmV.combined =

struct
  type 'a userdata' = 'a AsmV.combined
  module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a userdata') =
    struct
      module V = C.V
      let ( **-> ) = V.( **-> )
      let ( **->> ) x y = x **-> V.result y 
      <<export goodies to Lua>>
    end (*M*)
end (*MakeLib*)
@ 

HOW ARE THE DIFFERENT ASSEMBLERS asm, vasm, new_asm SUPPOSED TO BE USED?
SOME DOCUMENTATION WOULD BE WELCOME. --CL

<<export goodies to Lua>>=
module Map = struct
    let compose ~lo ~hi =
       { V.embed   = (fun x -> hi.V.embed (lo.V.embed x))
       ; V.project = (fun x -> lo.V.project (hi.V.project x))
       ; V.is      = (fun x -> hi.V.is x && lo.V.is (hi.V.project x))
       } 
    let ast       = AstV.makemap  V.userdata V.projection
    let proc      = ProcV.makemap V.userdata V.projection
    let vasm      = AsmV.makemap  V.userdata V.projection
      (* embeds and projects a V.value assembler *)
    let asm' proc =
      compose { V.embed   = Asm.map proc.V.project
              ; V.project = Asm.map proc.V.embed 
              ; V.is      = (fun _ -> true) } (* here's a hopeful notion *)
        vasm
    let asm = asm' proc
    let venv = EnvV.makemap    V.userdata V.projection
    let env' proc =
      compose { V.embed   = Fenv.Clean.map proc.V.project
              ; V.project = Fenv.Clean.map proc.V.embed 
              ; V.is      = (fun _ -> true) } (* and more hope *)
      venv
    let env = env' proc

    let doc       = DocV.makemap    V.userdata V.projection
    let new_target= NewTargetV.makemap V.userdata V.projection
    let optimize proc = V.closure (proc **-> V.runit)
    let channel   = InOutV.makemap  V.userdata V.projection
    let inchan    = Luaiolib.in'    channel    V.projection
    let outchan   = Luaiolib.out    channel    V.projection
    let stage proc = V.func (V.value **-> proc **->> V.bool)
    let block     = BlockV.makemap  V.userdata V.projection
end
@ 
Here we finally bind the exported values to names in the Lua
interpreter. The [[compile]] function receives a lua value such that it
can call Lua functions while it is active.
<<export goodies to Lua>>=
let init g = 
  <<register modules to [[g]] in alphabetical order>>
  Lua.Lib.StringList.of_list [ <<lua initialization>> ]

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Asm"
  [ "cmm" , V.efunc (Map.outchan **->> Map.asm) NewAstAsm.asm     
  ; "dot" , V.efunc (Map.outchan **->> Map.asm) (Dotasm.asm ~compress:true ~live:false)
  ; "big_dot" , V.efunc (Map.outchan **->> Map.asm) 
                            (Dotasm.asm ~compress:false ~live:true)
  ; "x86" ,  V.efunc (Map.outchan **->> Map.asm) (X86asm.make Cfgutil.emit)
  ; "mips",  V.efunc (Map.outchan **->> Map.asm) (Mipsasm.make Cfgutil.emit)
  ; "alpha", V.efunc (Map.outchan **->> Map.asm) (Alphaasm.make Cfgutil.emit)
  ; "interp32l" , V.efunc (Map.outchan **->> Map.asm) 
            (Interpasm.asm' ~byteorder:Rtl.LittleEndian ~memsize:8 ~ptrsize:32)
  ; "interp32b" , V.efunc (Map.outchan **->> Map.asm) 
            (Interpasm.asm' ~byteorder:Rtl.BigEndian ~memsize:8 ~ptrsize:32)
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Block" 
  [ "size",       V.efunc (Map.block **->> V.int)     Block.Lua.size
  ; "alignment",  V.efunc (Map.block **->> V.int)     Block.Lua.alignment
  ; "adjust",     V.efunc (Map.block **->> Map.block) Block.Lua.adjust
  ; "cat",        V.efunc (V.int **-> V.list Map.block **->> Map.block) Block.Lua.cat
  ; "overlap",    V.efunc (V.int **-> V.string **-> V.list Map.block **->> Map.block)
                          (Block.Lua.overlap (C.error g))
  ; "relative",   V.efunc (Map.block **-> V.string **-> V.int **-> V.int 
                                     **->> Map.block) Block.Lua.relative
  ; "base",       V.efunc (Map.block **->> V.string) Block.Lua.base
  ; "constraints",V.efunc (Map.block **->> (V.list V.string)) Block.Lua.constraints
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Boot" 
   [ "qc--.lua",   V.String                            This.boot
   ; "version",    V.efunc (Map.outchan **-> V.runit)  This.version
   ; "manual",     V.String                            This.manual 
   ; "byteorder",  V.String                            This.byteorder
   ; "arch_os",    V.String                            This.arch_os
   ] g;                        
@

We create a [[Caml]] module for functions that come straight out of
{\ocaml} libraries. Unlike the other modules, this has two levels, like
in [[Caml.Filename.check_suffix]].

We make the extension functions from [[Filename]] more forgiving of
files without dots.
<<register modules to [[g]] in alphabetical order>>=
let extension s =
  try
    let without = Filename.chop_extension s in
    String.sub s (String.length without) (String.length s - String.length without)
  with Invalid_argument _ -> "" in
let chop s = try Filename.chop_extension s with Invalid_argument _ -> s in
C.register_module "Caml"
    ["Filename" , V.Table (V.Table.of_list 
        [ "check_suffix",    V.efunc (V.string **-> V.string **->> V.bool)
                                Filename.check_suffix
        ; "chop_extension",  V.efunc (V.string **->> V.string) chop
        ; "extension",       V.efunc (V.string **->> V.string) extension
        ; "concat",          V.efunc (V.string **-> V.string **->> V.string)
                                Filename.concat
        ; "basename",        V.efunc (V.string **->> V.string) Filename.basename
        ])
    ] g;
@

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Dataflow" 
   [ "emit_dot",   V.efunc (V.unit **-> V.runit)  Dataflow.Test.emit_dot
   ] g;                        
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Driver" 
  [ "assemble"  , V.efunc (Map.vasm **-> V.runit)   (fun asm -> asm#emit)
  ; "proc_assembler", V.efunc (Map.vasm **->> (Map.stage V.value)) 
                    (fun asm v p -> asm#cfg_instr p ; true)
  ; "check"     , V.efunc (Map.ast **-> Map.asm **->> Map.env) Driver.check
  ; "emit_asdl" , V.efunc (Map.ast **-> V.runit)               Driver.emit_asdl
  ; "parse"     , V.efunc (V.string**->> Map.ast)              Driver.parse
  ; "print"     , V.efunc (Map.doc **-> V.int **-> Map.outchan **-> V.runit)
                    Driver.print
  ; "pretty"    , V.efunc (Map.ast **->> Map.doc) Driver.pretty
  ; "scan"      , V.efunc (V.string**-> V.runit)  Driver.scan
  ; "version"   , V.efunc (V.unit  **-> V.runit)  Driver.version
  ; "stdin"     , Map.inchan.V.embed              stdin (* hack *)
  ; "stdout"    , Map.outchan.V.embed             stdout(* hack *)
  ; "compile"   , V.efunc (Map.optimize Map.proc **-> V.bool **->
                           Map.ast **-> Map.new_target **-> Map.env **->> Map.asm) 
                          Driver.compile
  ; "reinit"    , V.efunc (V.unit  **-> V.runit)  Driver.reinit
  ] g;
<<register modules to [[g]] in alphabetical order>>=
let dump =   V.efunc ((V.list V.int)    **-> (* widths *)
                      (V.list V.string) **-> (* hints  *)
                       V.result V.unit)  

in C.register_module "Debug"
    ["Mips" , V.Table (V.Table.of_list 
        [ "proc",           dump Mipscall.dump_proc
        ; "proc_all",       V.efunc (V.unit **-> V.runit) 
                            (fun () -> Mipscall.dump_proc'
                            [32,"int";32,"float";64,"float"])
        ; "proc_all_paths", V.efunc (V.unit **-> V.runit) 
                            (fun () -> Mipscall.paths_proc'
                            [32,"int";32,"float";64,"float"])
        ; "cutto",          dump Mipscall.dump_cutto
        ; "proc_paths",     dump Mipscall.paths_proc
        ; "cutto_paths",    dump Mipscall.paths_cutto
        ])
     ;"Alpha" , V.Table (V.Table.of_list 
        [ "proc",           dump Alphacall.dump_proc
        ; "cutto",          dump Alphacall.dump_cutto
        ; "proc_paths",     dump Alphacall.paths_proc
        ; "cutto_paths",    dump Alphacall.paths_cutto
        ])
    ;"X86" , V.Table (V.Table.of_list 
        [ "c_proc",         dump X86call.dump_c_proc
        ; "c_cutto",        dump X86call.dump_c_cutto
        ; "c_proc_paths",   dump X86call.paths_c_proc
        ; "c_cutto_paths",  dump X86call.paths_c_cutto
        ])
    ] g;
@
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Expander"
  [ "x86f" , V.efunc (V.value **-> Map.proc **->> V.bool) X86.X.cfg
  ; "mips" , V.efunc (V.value **-> Map.proc **->> V.bool) Mips.X.cfg
  ; "alpha", V.efunc (V.value **-> Map.proc **->> V.bool) Alpha.X.cfg
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Liveness"
  [ "liveness", V.efunc (V.value **-> Map.proc **->> V.bool) 
       (fun _ p -> Cfgx.Live.set_live p.Proc.cfg; true)
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Placevar"
  [ "fortran", V.efunc (V.value **-> Map.proc **->> V.bool) Placevar.fortran'
  ; "context", V.efunc (V.value **-> Map.proc **->> V.bool) Placevar.context
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Simplify"
  [ "compile_time_ops", (V.list V.string).V.embed Simplify.compile_time_ops
  ] g;

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Stack"
  [ "freeze",  V.efunc (Map.proc **-> Map.block **-> V.runit)   Stack.freeze
  ; "blocks",  V.efunc (Map.proc **->> (V.record V.value))
                       (Stack.blocks Map.block.V.embed (V.list V.value).V.embed
                                     (V.record V.value).V.embed)
  ; "ccname",  V.efunc (Map.proc **->> V.string) (fun p -> p.Proc.cc.Call.name)
  ; "procname",V.efunc (Map.proc **->> V.string) (fun p -> p.Proc.symbol#original_text)
  ] g;                    
@ 
PERHAPS THIS CODE SHOULD REPLACE THE SOMEWHAT HEAVYWEIGHT [[Asm.dot]]???
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Stages"
  [ "writedot", V.efunc (V.value **-> Map.proc **->> V.bool)
      (fun _ proc -> 
        prerr_string
          (Cfgutil.cfg2dot ~compress:true ~live:true
             ~name:proc.Proc.symbol#mangled_text proc.Proc.cfg);
        flush stderr;
        true)
  ; "replace_vfp", V.efunc (V.value **-> Map.proc **->> V.bool)
      (fun _ proc -> proc.Proc.cc.Call.replace_vfp proc.Proc.cfg; true)
  ]  g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Targets"
  [ "dummy32l", Map.new_target.V.embed Dummy.dummy32l'
  ; "dummy32b", Map.new_target.V.embed Dummy.dummy32b'
  ; "x86",      Map.new_target.V.embed X86.target
  ; "mips",     Map.new_target.V.embed Mips.target
  ; "alpha",    Map.new_target.V.embed Alpha.target
  ; "interp",   Map.new_target.V.embed Interp.target'
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Typecheck" 
 [ "proc",       V.efunc (V.value **-> Map.proc **->> V.int)
                         (fun _ proc -> Typecheck.proc proc; 1)
 ] g;
 
<<lua initialization>>=
"Expander.x86 = { fn = Expander.x86f, uses = { 'proper widths', 'no vars' }, \
                  name = 'Expander.x86', creates = { 'x86 invariant' }, \
                  doc = 'A prototype code expander for the x86 (new proc)' }";
""
@
