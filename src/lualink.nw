% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% vim: ts=8 sw=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Linking the Lua Interpreter}\label{sect:lua-link}
% ------------------------------------------------------------------ 

The compiler is controlled by an embedded Lua interpreter. Types and
values of the compiler are made available as Lua primitives and allow
the user to control the compiler. We build here an interpreter with our
extensions.

<<lualink.mli>>=
module I : Lua.INTERP
@

<<lualink.ml>>=
<<Linking QC-- Types>>

module Reloc             = Sledlib.MkReloc
                            (struct type symbol = Symbol.t end)
module MSparcRtlEncoder  = Msparcenc.Mk(Reloc)
module MSparcRtlExpander = Sparcexpander.Make (Reloc) (MSparcRtlEncoder)

module T    = Lua.Lib.Combine.T10           (* types *)
                (AsmType)                   (* T1 *)
                (AstType)                   (* T2 *)
                (EnvType)                   (* T3 *)
                (ProcType)                  (* T4 *)
                (TargetType)                (* T5 *)
                (DocType)                   (* T6 *)
                (Luaiolib.T)                (* T7 *)
                (Backplane.T)               (* T8 *)
                (Colorgraph.GCT)            (* T9 *)
                (BlockType)                 (* T10 *)

module AsmT        = T.T1
module AstT        = T.T2
module EnvT        = T.T3
module ProcT       = T.T4
module TargetT     = T.T5
module DocT        = T.T6
module LuaioT      = T.T7
module BackplaneT  = T.T8
module ColorgraphT = T.T9
module BlockT      = T.T10

module IO = Lua.Lib.Extend (LuaioT)

module L1 = 
  Lua.Lib.Combine.L10                   (* up to 10 libraries *)
    (Luaiolib.Make (LuaioT))
    (IO (Luastrlib.M))
    (IO (Luamathlib.M))
    (MakeLib (AsmT) (AstT) (EnvT) (ProcT) (TargetT) (DocT) (LuaioT) (BlockT))
    (Backplane.Make  (BackplaneT) (ProcT))
    (Colorgraph.Make (BackplaneT) (ColorgraphT) (ProcT))
    (Targets.MakeLib (TargetT))
    (Placevar.Make (BackplaneT) (ProcT))
    (Linscan.Make (ProcT))
    (IO (Luautil.MakeLib))
                

module XXX = MSparcRtlExpander.Lua


module L2 = 
  Lua.Lib.Combine.L5                    (* up to 9 more libs *)
    (L1)
    (Dummyexpander.Make          (ProcT))
    (Placevar2.Make (BackplaneT) (ProcT))
    (MSparcRtlExpander.Lua       (ProcT))
    (IO (Rtleval2.Lua)) 

module I = 
  Lua.MakeInterp                            (* our interpreter *)
    (Lua.Parser.MakeStandard)
    (Lua.MakeCore (T) (L2))
@


% ------------------------------------------------------------------ 
\subsection{Export to Lua}
% ------------------------------------------------------------------ 

<<Linking QC-- Types>>=
module Personality = struct
    let target = Targets.dummy
end
@

The assemblers for the {\AST} and the interpreter are polymorphic. We
have to supply a target description that defines the sizes of words and
so forth.

<<Linking QC-- Types>>=
module Asm       = Astasm.Make(Personality)
module InterpAsm = Interpasm.Make(Interp)

module AsmType = struct
    type 'a t       = Asm3.assembler
    let tname       = "asm"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<asm>" 
end
module AstType = struct
    type 'a t       = Srcmap.map * Ast.program
    let tname       = "ast"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<ast>" 
  end
module EnvType = struct
    type 'a t       = Fenv.Clean.env
    let tname       = "env"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<env>" 
end
module ProcType = struct
    type 'a t       = Proc.t
    let tname       = "proc"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> ("<proc "^t.Proc.symbol#text^">") 
end
module TargetType = struct
    type 'a t       = Target2.t
    let tname       = "target"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<target " ^ t.Target2.name ^ ">" 
end
module DocType = struct
    type 'a t       = Pp.doc
    let tname       = "doc"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<doc>" 
end
module BlockType = struct
    type 'a t       = Block.t
    let tname       = "block"
    let eq _        = fun x y -> x = y
    let to_string   = fun _ t -> "<block>"
end

module MakeLib
  (AsmV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AsmType.t)
  (AstV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AstType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (EnvV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a EnvType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (ProcV   : Lua.Lib.TYPEVIEW with type 'a t        = 'a ProcType.t
                              and  type 'a combined = 'a AsmV.combined)
  (TargetV : Lua.Lib.TYPEVIEW with type 'a t        = 'a TargetType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (DocV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a DocType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (InOutV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a Luaiolib.T.t    
                              and  type 'a combined = 'a AsmV.combined)
  (BlockV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a BlockType.t    
                              and  type 'a combined = 'a AsmV.combined)
    
    : Lua.Lib.TYPEFUL with type 'a combined = 'a AsmV.combined =

struct
  type 'a combined = 'a AsmV.combined
  module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
    struct
      module V = C.V
      let ( **-> ) = V.( **-> )
      <<export goodies to Lua>>
    end (*M*)
end (*MakeLib*)
@ 

Here we finally bind the exported values to names in the Lua
interpreter. The [[compile]] function receives a lua value such that it
can call Lua functions while it is active.

<<export goodies to Lua>>=
module Map = struct
    let ast       = AstV.makemap    V.userdata V.projection
    let asm       = AsmV.makemap    V.userdata V.projection
    let env       = EnvV.makemap    V.userdata V.projection
    let proc      = ProcV.makemap   V.userdata V.projection
    let doc       = DocV.makemap    V.userdata V.projection
    let target    = TargetV.makemap V.userdata V.projection
    let optimize  = V.closure (proc **-> V.runit)
    let channel   = InOutV.makemap  V.userdata V.projection
    let inchan    = Luaiolib.in'    channel    V.projection
    let outchan   = Luaiolib.out    channel    V.projection
    let stage     = V.func (V.value **-> proc **-> V.result V.bool)
    let block     = BlockV.makemap  V.userdata V.projection
end

let init g = 
  C.register_module "Asm"
    [ "cmm"     , V.efunc (Map.outchan **-> V.result Map.asm) Asm.asm     
    ; "ast"     , V.efunc (Map.outchan **-> V.result Map.asm) Asm.asm
    ; "dot"     , V.efunc (Map.outchan **-> V.result Map.asm) Dotasm.asm
    ; "asdl"    , V.efunc (Map.outchan **-> V.result Map.asm) Asdlasm.asm 
    ; "x86"     , V.efunc (Map.outchan **-> V.result Map.asm) X86asm.make
    ; "interp"  , V.efunc (Map.outchan **-> V.result Map.asm) InterpAsm.asm
    ; "sparc", V.efunc (V.bool **-> Map.outchan 
                               **-> V.result Map.asm)       Msparcasm.asm
    ] g;
  C.register_module "Driver" 
    [ "assemble"  , V.efunc (Map.asm **-> V.runit)   (fun asm -> asm#emit)
    ; "proc_assembler", V.efunc (Map.asm **-> V.result Map.stage) 
                      (fun asm v p -> asm#cfg_instr p ; true)
    ; "check"     , V.efunc (Map.ast **-> Map.asm 
                                     **-> V.result Map.env)   Driver2.check
    ; "emit_asdl" , V.efunc (Map.ast **-> V.runit)            Driver2.emit_asdl
    ; "parse"     , V.efunc (V.string**-> V.result Map.ast)   Driver2.parse
    ; "print"     , V.efunc (Map.doc **-> V.int **-> V.runit) Driver2.print
    ; "pretty"    , V.efunc (Map.ast **-> V.result Map.doc)   Driver2.pretty
    ; "scan"      , V.efunc (V.string**-> V.runit)            Driver2.scan
    ; "version"   , V.efunc (V.unit  **-> V.runit)            Driver2.version
    ; "stdin"     , Map.inchan.V.embed                        stdin (* hack *)
    ; "stdout"    , Map.outchan.V.embed                       stdout(* hack *)
    ; "compile"   , V.efunc (Map.optimize 
                            **-> Map.ast  **-> Map.target 
                            **-> Map.env  **-> V.result Map.asm) Driver2.compile
    ] g;
  C.register_module "Expander"
    [ "x86f" , V.efunc (V.value **-> Map.proc **-> V.result V.bool) X86.X.cfg
    ] g;
  C.register_module "Liveness"
    [ "liveness", V.efunc (V.value **-> Map.proc **-> V.result V.bool)
         (fun _ p -> 
            let module LI = Olive.Make(Cfg4) in LI.liveness p.Proc.cfg; true)
    ] g;
  C.register_module "Targets"
    [ "dummy",      Map.target.V.embed Targets.dummy 
    ; "sparc",      Map.target.V.embed Targets.sparc
    ; "x86",        Map.target.V.embed X86.target
    ; "interp",     Map.target.V.embed Interp.target
    ] g;
  C.register_module "Block" 
    [ "size",       V.efunc (Map.block **-> V.result V.int)  Block.Lua.size
    ; "alignment",  V.efunc (Map.block **-> V.result V.int)  Block.Lua.alignment
    ; "adjust",     V.efunc (Map.block **-> V.result Map.block) Block.Lua.adjust
    ; "cat",        V.efunc (V.int **-> V.list Map.block **-> V.result Map.block) 
                        Block.Lua.cat
    ; "overlap",    V.efunc (V.int **-> V.string **-> V.list Map.block
                                   **-> V.result Map.block)
                            (Block.Lua.overlap (C.error g))
    ; "mk",         V.efunc (Map.block **-> V.int **-> V.int 
                                       **-> V.option V.string
                                       **-> V.result Map.block) Block.Lua.mk
    ] g;
  (* someone who groks the Lua map mechanism could rewrite the embedding
     below of Stack.blocks: Proc.t -> (string * Block.t) list. I don't know
     how to map string * Block.t into a table easily -- CL *)
  C.register_module "Stack"
    [ "freeze",     V.efunc (Map.proc **-> Map.block **-> V.result V.unit) 
                        Stack.freeze
    ; "blocks",     V.efunc (Map.proc **-> V.result V.table)
                    (let embed (str,blk) = (str, Map.block.V.embed blk)
                     in fun p -> 
                        V.Table.of_list (List.map embed (Stack.blocks p)))
    ] g;                    
  C.register_module "Typecheck" 
    [ "proc",       V.efunc (V.value **-> Map.proc **-> V.result V.int)
                            (fun _ proc -> Typecheck.proc proc; 1)
    ] g;                        
  C.register_module "Export" 
    [ "tolua",       V.efunc (V.value **-> Map.proc **-> V.result V.int)
                    (fun _ proc -> 
                        let cfg = proc.Proc.cfg 
                        in Cfg4.interp cfg stdout;1)
                        
    ] g;                        
  
  Lua.Lib.StringList.of_list [ <<lua initialization>> ]
@  
<<lua initialization>>=
"Expander.x86 = { fn = Expander.x86f, uses = { 'proper widths', 'no vars' }, \
                  name = 'Expander.x86', creates = { 'x86 invariant' }, \
                  doc = 'A prototype code expander for the x86' }";
""
@
