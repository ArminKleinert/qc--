% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% vim: ts=8 sw=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Linking the Lua Interpreter}\label{sect:lua-link}
% ------------------------------------------------------------------ 

The compiler is controlled by an embedded Lua interpreter. Types and
values of the compiler are made available as Lua primitives and allow
the user to control the compiler. We build here an interpreter with our
extensions.

<<lualink.mli>>=
module I : Lua.INTERP
@

<<lualink.ml>>=
<<Linking QC-- Types>>

module Reloc        = Sledlib.MkReloc (struct type symbol = Symbol.t end)
module NewBackplane = Backplane.M'

module T1 = Lua.Lib.Combine.T5
                (DocType)                   (* T1.T1 *)
                (Luaiolib.T)                (* T1.T2 *)
                (AsmType)                   (* T1.T3 *)
                (AstType)                   (* T1.T4 *)
                (Colorgraph.NewGCT)         (* T1.T5 *)

module T    = Lua.Lib.Combine.T6            (* types *)
                (T1)                        (* T1 *)
                (NewBackplane.T)            (* T2 *)
                (EnvType)                   (* T3 *)
                (NewProcType)               (* T4 *)
                (NewTargetType)             (* T5 *)
                (BlockType)                 (* T6 *)

module T1V = Lua.Lib.Lift (T1) (T.T1)

module DocT             = T1V.T1
module LuaioT           = T1V.T2
module AsmT             = T1V.T3
module AstT             = T1V.T4
module NewColorgraphT   = T1V.T5

module NewBackplaneT    = T.T2
module EnvT             = T.T3
module NewProcT         = T.T4
module NewTargetT       = T.T5
module BlockT           = T.T6

module IO = Lua.Lib.Extend (LuaioT)

module L1 = 
  Lua.Lib.Combine.L6                   (* up to 10 libraries *)
    (Luaiolib.Make (LuaioT))
    (IO (Luastrlib.M))
    (IO (Luamathlib.M))
    (MakeLib 
        (AsmT) (AstT) (EnvT) (NewProcT) (NewTargetT) (DocT) (LuaioT) (BlockT))
    (Colorgraph.NewMake (NewBackplaneT) (NewColorgraphT) (NewProcT))
    (IO (Luautil.MakeLib))
                

module L2 = 
  Lua.Lib.Combine.L2                    (* up to 9 more libs *)
    (L1)
    (NewBackplane.MakeLua  (NewBackplaneT) (NewProcT))

module I = 
  Lua.MakeInterp                            (* our interpreter *)
    (Lua.Parser.MakeStandard)
    (Lua.MakeCore (T) (L2))
@


% ------------------------------------------------------------------ 
\subsection{Export to Lua}
% ------------------------------------------------------------------ 

<<Linking QC-- Types>>=
module NewPersonality = struct
    type proc = Ast2ir.proc
    let target      = Dummy.dummy32b'
    let memsize     = 8
    let wordsize    = 32
    let pointersize = wordsize
    let byteorder   = Rtl.BigEndian
    let charset     = "latin1"
    let float       = "ieee754"

    let cfg2ast proc =
      Cfgutil.cfg2ast Rtlutil.ToAST.rtl proc.Proc.cfg proc.Proc.symbol#mangled_text
end
@

The assemblers for the {\AST} and the interpreter are polymorphic. We
have to supply a target description that defines the sizes of words and
so forth.

<<Linking QC-- Types>>=
module NewAstAsm = Astasm.Make(NewPersonality)

module AsmType = struct
    type 'a t       = 'a Asm.assembler
    let tname       = "asm"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<asm>" 
end
module AstType = struct
    type 'a t       = Srcmap.map * Ast.program
    let tname       = "ast"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<ast>" 
  end
module EnvType = struct
    type 'a t       = 'a Fenv.Clean.env'
    let tname       = "env"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<env>" 
end
module NewProcType = struct
    type 'a t       = Ast2ir.proc
    let tname       = "new proc"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> ("<new proc "^t.Proc.symbol#mangled_text^">") 
end
module NewTargetType = struct
    type 'a t       = Ast2ir.tgt
    let tname       = "new target"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<new target " ^ t.Target.name ^ ">" 
end
module DocType = struct
    type 'a t       = Pp.doc
    let tname       = "doc"
    let eq _        = fun x y -> x = y
    let to_string _ = fun t -> "<doc>" 
end
module BlockType = struct
    type 'a t       = Block.t
    let tname       = "block"
    let eq _        = fun x y -> x = y
    let to_string   = fun _ t -> "<block>"
end

module MakeLib
  (AsmV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AsmType.t)
  (AstV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a AstType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (EnvV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a EnvType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (NewProcV   : Lua.Lib.TYPEVIEW with type 'a t     = 'a NewProcType.t
                              and  type 'a combined = 'a AsmV.combined)
  (NewTargetV : Lua.Lib.TYPEVIEW with type 'a t     = 'a NewTargetType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (DocV    : Lua.Lib.TYPEVIEW with type 'a t        = 'a DocType.t 
                              and  type 'a combined = 'a AsmV.combined)
  (InOutV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a Luaiolib.T.t    
                              and  type 'a combined = 'a AsmV.combined)
  (BlockV  : Lua.Lib.TYPEVIEW with type 'a t        = 'a BlockType.t    
                              and  type 'a combined = 'a AsmV.combined)
    
    : Lua.Lib.TYPEFUL with type 'a combined = 'a AsmV.combined =

struct
  type 'a combined = 'a AsmV.combined
  module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
    struct
      module V = C.V
      let ( **-> ) = V.( **-> )
      <<export goodies to Lua>>
    end (*M*)
end (*MakeLib*)
@ 

HOW ARE THE DIFFERENT ASSEMBLERS asm, vasm, new_asm SUPPOSED TO BE USED?
SOME DOCUMENTATION WOULD BE WELCOME. --CL

<<export goodies to Lua>>=
module Map = struct
    let compose ~lo ~hi =
       { V.embed   = (fun x -> hi.V.embed (lo.V.embed x))
       ; V.project = (fun x -> lo.V.project (hi.V.project x))
       } 
    let ast       = AstV.makemap    V.userdata V.projection
    let proc      = NewProcV.makemap   V.userdata V.projection
    let vasm      = AsmV.makemap    V.userdata V.projection
      (* embeds and projects a V.value assembler *)
    let asm' proc =
      compose { V.embed =   Asm.map proc.V.project
              ; V.project = Asm.map proc.V.embed }
        vasm
    let asm = asm' proc
    let venv = EnvV.makemap    V.userdata V.projection
    let env' proc =
      compose { V.embed =   Fenv.Clean.map proc.V.project
              ; V.project = Fenv.Clean.map proc.V.embed }
      venv
    let env = env' proc

    let doc       = DocV.makemap    V.userdata V.projection
    let new_target= NewTargetV.makemap V.userdata V.projection
    let optimize proc = V.closure (proc **-> V.runit)
    let channel   = InOutV.makemap  V.userdata V.projection
    let inchan    = Luaiolib.in'    channel    V.projection
    let outchan   = Luaiolib.out    channel    V.projection
    let stage proc = V.func (V.value **-> proc **-> V.result V.bool)
    let block     = BlockV.makemap  V.userdata V.projection
end
@ 
Here we finally bind the exported values to names in the Lua
interpreter. The [[compile]] function receives a lua value such that it
can call Lua functions while it is active.
<<export goodies to Lua>>=
let init g = 
  <<register modules to [[g]] in alphabetical order>>
  Lua.Lib.StringList.of_list [ <<lua initialization>> ]

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Asm"
  [ "cmm" , V.efunc (Map.outchan **-> V.result Map.asm) NewAstAsm.asm     
  ; "dot" , V.efunc (Map.outchan **-> V.result Map.asm) 
                            (Dotasm.asm ~compress:true ~live:false)
  ; "big_dot" , V.efunc (Map.outchan **-> V.result Map.asm) 
                            (Dotasm.asm ~compress:false ~live:true)
  ; "x86" , V.efunc (Map.outchan **-> V.result Map.asm) 
                            (X86asm.make Cfgutil.emit)
  ; "mips", V.efunc (Map.outchan **-> V.result Map.asm) 
                            (Mipsasm.make Cfgutil.emit)
  ; "alpha", V.efunc (Map.outchan **-> V.result Map.asm) 
                            (Alphaasm.make Cfgutil.emit)
  ; "interp32l" , V.efunc (Map.outchan **-> V.result Map.asm) 
            (Interpasm.asm' ~byteorder:Rtl.LittleEndian ~memsize:8 ~ptrsize:32)
  ; "interp32b" , V.efunc (Map.outchan **-> V.result Map.asm) 
            (Interpasm.asm' ~byteorder:Rtl.BigEndian ~memsize:8 ~ptrsize:32)
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Block" 
  [ "size",       V.efunc (Map.block **-> V.result V.int)  Block.Lua.size
  ; "alignment",  V.efunc (Map.block **-> V.result V.int)  Block.Lua.alignment
  ; "adjust",     V.efunc (Map.block **-> V.result Map.block) Block.Lua.adjust
  ; "cat",        V.efunc (V.int **-> V.list Map.block **-> V.result Map.block) 
                      Block.Lua.cat
  ; "overlap",    V.efunc (V.int **-> V.string **-> V.list Map.block
                                 **-> V.result Map.block)
                          (Block.Lua.overlap (C.error g))
  ; "relative",   V.efunc (Map.block **-> V.string **-> V.int **-> V.int 
                                     **-> V.result Map.block) Block.Lua.relative
  ; "base",       V.efunc (Map.block **-> V.result V.string) Block.Lua.base
  ; "constraints",V.efunc (Map.block **-> V.result (V.list V.string)) 
                            Block.Lua.constraints
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Boot" 
   [ "qc--.lua",   V.String                            This.boot
   ; "version",    V.efunc (Map.outchan **-> V.runit)  This.version
   ; "manual",     V.String                            This.manual 
   ; "byteorder",  V.String                            This.byteorder
   ; "arch_os",    V.String                            This.arch_os
   ] g;                        
@

We create a [[Caml]] module for functions that come straight out of
{\ocaml} libraries. Unlike the other modules, this has two levels, like
in [[Caml.Filename.checksuffix]].

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Caml"
    ["Filename" , V.Table (V.Table.of_list 
        [ "checksuffix", V.efunc (V.string **-> V.string **-> V.result V.bool)
                         Filename.check_suffix
        ; "chopsuffix",  V.efunc (V.string **-> V.result V.string)
                         Filename.chop_extension
        ])
    ] g;
@

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Dataflow" 
   [ "emit_dot",   V.efunc (V.unit **-> V.runit)  Dataflow.Test.emit_dot
   ] g;                        
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Driver" 
  [ "assemble"  , V.efunc (Map.vasm **-> V.runit)   (fun asm -> asm#emit)
  ; "proc_assembler", V.efunc (Map.vasm **-> V.result (Map.stage V.value)) 
                    (fun asm v p -> asm#cfg_instr p ; true)
  ; "check"     , V.efunc (Map.ast **-> Map.asm 
                                   **-> V.result Map.env)   Driver.check
  ; "emit_asdl" , V.efunc (Map.ast **-> V.runit)            Driver.emit_asdl
  ; "parse"     , V.efunc (V.string**-> V.result Map.ast)   Driver.parse
  ; "print"     , V.efunc (Map.doc **-> V.int 
                                   **-> Map.outchan
                                   **-> V.runit)            Driver.print
  ; "pretty"    , V.efunc (Map.ast **-> V.result Map.doc)   Driver.pretty
  ; "scan"      , V.efunc (V.string**-> V.runit)            Driver.scan
  ; "version"   , V.efunc (V.unit  **-> V.runit)            Driver.version
  ; "stdin"     , Map.inchan.V.embed                        stdin (* hack *)
  ; "stdout"    , Map.outchan.V.embed                       stdout(* hack *)
  ; "compile"   , V.efunc (Map.optimize Map.proc
                          **-> Map.ast      **-> Map.new_target 
                          **-> Map.env  **-> V.result Map.asm) 
                          Driver.compile
  ] g;
<<register modules to [[g]] in alphabetical order>>=
let dump =   V.efunc ((V.list V.int)    **-> (* widths *)
                      (V.list V.string) **-> (* hints  *)
                       V.result V.unit)  

in C.register_module "Debug"
    ["Mips" , V.Table (V.Table.of_list 
        [ "proc",           dump Mipscall.dump_proc
        ; "proc_all",       V.efunc (V.unit **-> V.runit) 
                            (fun () -> Mipscall.dump_proc'
                            [32,"int";32,"float";64,"float"])
        ; "proc_all_paths", V.efunc (V.unit **-> V.runit) 
                            (fun () -> Mipscall.paths_proc'
                            [32,"int";32,"float";64,"float"])
        ; "cutto",          dump Mipscall.dump_cutto
        ; "proc_paths",     dump Mipscall.paths_proc
        ; "cutto_paths",    dump Mipscall.paths_cutto
        ])
     ;"Alpha" , V.Table (V.Table.of_list 
        [ "proc",           dump Alphacall.dump_proc
        ; "cutto",          dump Alphacall.dump_cutto
        ; "proc_paths",     dump Alphacall.paths_proc
        ; "cutto_paths",    dump Alphacall.paths_cutto
        ])
    ;"X86" , V.Table (V.Table.of_list 
        [ "c_proc",         dump X86call.dump_c_proc
        ; "c_cutto",        dump X86call.dump_c_cutto
        ; "c_proc_paths",   dump X86call.paths_c_proc
        ; "c_cutto_paths",  dump X86call.paths_c_cutto
        ])
    ] g;
@
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Expander"
  [ "x86f" , V.efunc (V.value **-> Map.proc **-> V.result V.bool) X86.X.cfg
  ; "mips" , V.efunc (V.value **-> Map.proc **-> V.result V.bool) Mips.X.cfg
  ; "alpha", V.efunc (V.value **-> Map.proc **-> V.result V.bool) Alpha.X.cfg
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Liveness"
  [ "liveness", V.efunc (V.value **-> Map.proc **-> V.result V.bool) 
       (fun _ p -> Cfgx.Live.set_live p.Proc.cfg; true)
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Placevar"
  [ "fortran", V.efunc (V.value **-> Map.proc **-> V.result V.bool) 
                            Placevar.fortran'
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Simplify"
  [ "compile_time_ops", (V.list V.string).V.embed Simplify.compile_time_ops
  ] g;

<<register modules to [[g]] in alphabetical order>>=
C.register_module "Stack"
  [ "freeze", V.efunc (Map.proc **-> Map.block **-> V.runit) 
                  Stack.freeze
  ; "blocks", V.efunc (Map.proc **-> V.result (V.record V.value))
                  (Stack.blocks Map.block.V.embed (V.list V.value).V.embed)
  ; "ccname",     V.efunc (Map.proc **-> V.result (V.string))
                  (fun p -> p.Proc.cc.Call.name)
  ; "procname",   V.efunc (Map.proc **-> V.result (V.string))
                  (fun p -> p.Proc.symbol#original_text)
  ] g;                    
@ 
PERHAPS THIS CODE SHOULD REPLACE THE SOMEWHAT HEAVYWEIGHT [[Asm.dot]]???
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Stages"
  [ "writedot", V.efunc (V.value **-> Map.proc **-> V.result V.bool)
      (fun _ proc -> 
        prerr_string
          (Cfgutil.cfg2dot ~compress:true ~live:true ~name:proc.Proc.symbol#mangled_text proc.Proc.cfg);
        flush stderr;
        true)
  ; "replace_vfp", V.efunc (V.value **-> Map.proc **-> V.result V.bool)
      (fun _ proc -> proc.Proc.cc.Call.replace_vfp proc.Proc.cfg; true)
  ]  g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Targets"
  [ "dummy32l", Map.new_target.V.embed Dummy.dummy32l'
  ; "dummy32b", Map.new_target.V.embed Dummy.dummy32b'
  ; "x86",      Map.new_target.V.embed X86.target
  ; "mips",     Map.new_target.V.embed Mips.target
  ; "alpha",    Map.new_target.V.embed Alpha.target
  ; "interp",   Map.new_target.V.embed Interp.target'
  ] g;
<<register modules to [[g]] in alphabetical order>>=
C.register_module "Typecheck" 
 [ "proc",       V.efunc (V.value **-> Map.proc **-> V.result V.int)
                         (fun _ proc -> Typecheck.proc proc; 1)
 ] g;
 
<<lua initialization>>=
"Expander.x86 = { fn = Expander.x86f, uses = { 'proper widths', 'no vars' }, \
                  name = 'Expander.x86', creates = { 'x86 invariant' }, \
                  doc = 'A prototype code expander for the x86 (new proc)' }";
""
@
