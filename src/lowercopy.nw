
\input{macros.tex}

% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>


% ------------------------------------------------------------------ 
\section{Lowering Copy-In and Copy-Out Nodes}
% ------------------------------------------------------------------ 

The flow graph of a procedure, as part of the assembly program emitted
by the \module{ast2ir} module, contains so-called copy-in and copy-out
nodes.  They represent the conventions for parameter passing on an
abstract level.  When the calling conventions are known, these nodes
can be replaced by sequences of nodes that pass parameters in
registers and memory.  This module transforms a flow graph to a
slightly different flow-graph without copy-nodes.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

This module provides a functor [[Make]] that creates a
module, that implements an abstract flow graph. The implementation of
[[MakeLowerCopy]] has itself a (lower-level) implementation of an
abstract flow-graph available. 

The flow-graph implementation created by [[Make]] will represent
[[copy_in]] and [[copy_out]] nodes in terms of simpler nodes.  We
reveal some facts of the implementation using [[with]] constraints.

<<lowercopy.mli>>=
module Make(G: Agraph.S): Agraph.S 
    with type graph      = G.graph
    with type ginit      = G.ginit
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation for the most part just uses the lower level
implementation [[G]] to define the new one. Only two functions
actually differ from the implementation in [[G]]: [[copy_in]] and
[[copy_out]]. 

<<lowercopy.ml>>=
module Make(G: Agraph.S) = struct
    module A  = Automaton
    module AG = Agraph
    module T  = Target
    <<module make>>
end
@

A [[copy]] node is implemented as a sequence of [[G.node]]s from the
lower-level implementation.  Since properties can be bound later to a
node we have a problem:  the [[bind]] function must bind the
properties to all nodes that represent a [[copy]] node.  We solve the
problem by escaping to higher order functions:  a [[unode]] is
represented as a function.  A typical call like [[exit g]] creates a
function [[unode]] that expects properties.  Only after the properties
are supplied, the implementation is invoked.  This permits the
implementation to use the properties.  In case of the [[copy]] nodes
the properties can be passed to all primitive nodes that implement a
[[copy]] node. 
 
<<module make>>=
type ginit      = G.ginit
type graph      = G.graph
type node       = G.node
type unode      = G.Props.properties -> G.node
type cont       = G.cont

module Props    = G.Props

let bind props unode = unode props

module Make = struct

    let graph           = G.Make.graph
    let graph_of        = G.Make.graph_of
    let exit g p        = G.bind p (G.Make.exit g) 
    let entry n p       = G.bind p (G.Make.entry n)
    let goto g e l p    = G.bind p (G.Make.goto g e l)
    let branch e x y p  = G.bind p (G.Make.branch e x y)
    let assign r n p    = G.bind p (G.Make.assign r n)
    let call e c p      = G.bind p (G.Make.call e c)
    let jump g e l p    = G.bind p (G.Make.jump g e l)
    let label l n p     = G.bind p (G.Make.label l n)
    let return g x y p  = G.bind p (G.Make.return g x y)
    let make_cont       = G.Make.make_cont

    <<copyio>>      
end
@

% ------------------------------------------------------------------ 
\subsubsection{Copy-In}
% ------------------------------------------------------------------ 

The [[copy_in]] node is responsible for receiving parameters passed
from a call to a procedure, from a return to the point of return, or
from a cut to a continuation.  The location of the parameters are
determined by an [[Automaton.t]] that is part of the calling
convention [[conv]].  The formal parameters [[formals]] are pushed
through the automaton to obtain the locations of the incoming
parameters.  An incoming value is assigned to its corresponding
variable from the list of formal parameters.

<<copyio>>=
let copy_in formals context conv after props =
    let dfa = ( match context with
              | AG.ProcParameters -> conv.T.proc_param
              | AG.ProcResults    -> conv.T.proc_result
              | AG.ContParameters -> conv.T.proc_param
              ) in
    let rec loop dfa = function  
        | []         -> after
        | frml :: ff ->
            let (write,read),dfa = A.Run.next dfa (Types.bits frml.AG.width
                                                  , frml.AG.hint
                                                  ) in
            let var = Rtl.Var ( frml.AG.name
                              , frml.AG.index
                              , frml.AG.width
                              )        in
            let t     = Rtl.Const(Rtl.Bool(true))         in
            let store = Rtl.Store(var,read,frml.AG.width) in
            let rtl   = Rtl.Rtl [t,store]                 in
                assign rtl (loop dfa ff) props
    in
        loop dfa formals
@

% ------------------------------------------------------------------ 
\subsection{Copy-Out}
% ------------------------------------------------------------------ 

A [[copy_out]] node takes the values of actual parameters and puts
them into locations determined by calling conventions.  A [[copy_out]]
node is typically followed by a call, or a [[cut to]] that transfers
control to code that receives the values. 

Constructing the {\rtl} that assigns the value of an actual parameter
to a location is easy: the calling convention automaton returns a
function [[write: Rtl.expr -> Rtl.effect]] that assigns a supplied
value to the right location.
              
<<copyio>>=
let copy_out actuals context conv after props = 
    let dfa = ( match context with
              | AG.ProcParameters -> conv.T.proc_param
              | AG.ProcResults    -> conv.T.proc_result
              | AG.ContParameters -> conv.T.proc_param
              ) in
    let rec loop dfa = function  
        | []                     -> after
        | (expr,width,hint):: ff ->
            let (write,read),dfa = A.Run.next dfa ( Types.bits width
                                                  , hint
                                                  )       in
            let t     = Rtl.Const(Rtl.Bool(true))         in
            let rtl   = Rtl.Rtl [t,write expr]            in
                assign rtl (loop dfa ff) props
    in
        loop dfa actuals
@

% ------------------------------------------------------------------ 
\subsection{Extras}
% ------------------------------------------------------------------ 


