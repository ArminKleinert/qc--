% -*- mode: Noweb; noweb-code-mode: c-mode -*-

% l2h substitution qquad &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

\input{macros.tex}

% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>
% l2h macro nwanchorname 2 <a name=#$1>#2</a>

% ------------------------------------------------------------------ 
\section{An Interface to Assembly Languages}
% ------------------------------------------------------------------ 

\ifhtml
\tableofcontents
\fi

This document describes an {\asdl} datatype that can represent an
assembly-language program.  Representations of instructions, labels,
and relocatable addresses are left as abstract as possible.  We expect
that the representation of instructions will change with every
machine.  

We hope that there will eventually be tools to do three thigns with
this interface:  emit assembly language, emit object code, and help
emit RTLs for \emph{vpo}.\footnote{The interface may also be used
within \emph{vpo}, which will then emit assembly language or object
code.} Therefore, this interface does not attempt to be the best
possible interface for assembly; rather, it defines a plausible
interface that is consistent with existing assemblers. 

The design of the interface is similar to that of the New Jersey
Machine-Code Toolkit's library.  We imagine that implementations
supporting binary emission would in fact use the Toolkit. 
Nonetheless, this interface attempts to be independent of the Toolkit.

An assembly-language program is described by a sequence of actions the
assembler is requested to take.  The assembler is also passed a list
of strings it can use to intialize itself.

<<asm.asdl>>=
module asm {
  <<asm types>>
  
  program       = (string* initialization_args, action*)
  action        = <<constructors for actions>>
 
  symbol        = <<constructors for symbols>>
  label         = <<constructors for labels>>
  reladdr       = <<constructors for relocatable addresses>>
}  
@

{\asdl} has no abstraction, so we use [[string]] to represent an
opaque type. 

% ------------------------------------------------------------------ 
\subsection{What the assembler does}
% ------------------------------------------------------------------ 

Like most assemblers, this one operates with a collection of named
``sections,'' one of which is the ``current section.'' A section
identifies a contiguous block of memory in the running process image. 
Typically, the location at which the section is mapped is not known
until link time.

Much of the assembler's job is determining the contents of the
sections.  Each section has a ``location counter,'' which identifies a
current location.  The location counter is an integer, and the current
location is the location at that offset from the beginning of the
current section.  Many actions in this interface are intended to
deposit data (or instructions) at the current location and advance the
location counter.

The assembler also uses names to refer to constants or to locations
within sections.  To support separate compilation, names may include
references to locations defined in other compilations; such references
are resolved at link time.

% ------------------------------------------------------------------ 
\subsection{Labels and relocatable addresses}
% ------------------------------------------------------------------ 

Labels and relocatable addresses both resolve to integers at link
time.  Labels, but not relocatable addresses, can be bound to
locations or to values.  Relocatable addresses can nevertheless
appear as operands to many machine instructions, so it is appropriate
to use them in {\rtl}s.

<<constructors for labels>>=
  Symlabel (symbol)
@

In most assemblers, a relocatable address is:

\begin{itemize}
\item a label, or
\item a relocatable address plus a constant, or
\item a relocatable address plus the difference of two relocatable
      addresses.
\end{itemize}

In this assembler, a relocatable addresses is equivalent to a label
plus a constant, which we normally write~$L+k$.%
\footnote{If you think you need the more general version, perhaps to
generate position-independent jump tables, please write to
\texttt{zephyr-investigators@virginia.edu}.} 
Addresses can be created relative to some label or relative to an
existing address.

<<constructors for relocatable addresses>>=
  Newaddr (label l, int offset)
| Shiftaddr (reladdr a, int offset)
@ 

Note that labels are not created directly; instead they are part of
assembly-language symbols, as detailed below.

% ------------------------------------------------------------------  
\subsection{Names and symbols}
% ------------------------------------------------------------------ 

The assembler works with a \emph{single} name space.  Names can be
imported, exported, common (Fortran-style), or local to the
compilation unit.  \footnote{N.B.~the name space is flat, so there is
no such thing as a symbol that is local to a function.}

Every name is associated with a relocatable address.  Except in the
special case of [[offset]], the [[k]]~part of the relocatable address
is zero, so the label part is directly associated with the name. 
Imported labels are unbound.  Exported and local labels are bound
either to locations in relocatable blocks or to integers.  Note that
additional information is associated with common symbols.

<<constructors for symbols>>=
  Import (string name)
| Export (string name)
| Local (string name)
| Common (string name, int size, int align, string section)
<<other constructors for symbols>>
@ 

It is an unchecked error to create a program that registers the same
name in different scopes.  Multiple calls to [[Import]] with the same
name are Ok.  It is not determined whether implementations can handle
multiple calls of [[Export]] or [[Local]] with the same name.

A common symbol may be declared in multiple compilation units, with
multiple sizes and alignments.  The linker reserves an area with the
largest size and the most strict alignment, and the symbol is bound to
the address of that area.  The area is reserved in the section
specified in the [[Common]] directive; it is an unchecked (link-time)
error to declare a common symbol in different sections.  Some
assemblers or linkers may restrict the sections in which common
symbols may be declared, and some linkers may require that the same
size and alignment be used in all declarations of a common symbol. 
Consult the Processor Supplement for information about restrictions.

Symbols that have been registered can be looked up.  It is a checked
error to create a program that looks up an unregistered symbol.

<<other constructors for symbols>>=
| Lookup (string name)
@

{\tt lcc} uses an unusual convention for relocatable addresses of the
form $L+k$; it represents them as symbols.  So as to touch the {\tt
lcc} back ends as little as possible, we make it possible to create a
new symbol that represents an offset from an existing symbol.  Such
symbols have no labels associated with them.  To create $p=L+k$, we
call \mbox{$\mathtt{Offset}(p, L, k)$}.

<<other constructors for symbols>>=
| Offset (string name, symbol, int)
@ 

[[Offset]] is deprecated and may be removed from a future version of
this interface.

Local symbols can be defined to point at the current location in the
current relocatable block, or to be constants.

<<constructors for actions>>=
  DefineSymbolHere  (symbol)
| DefineSymbolConst (symbol, int)
@ 

It is an unchecked runtime error to define the same symbol twice.

For convenience only, we provide a generic routine for mapping names
to relocatable addresses by looking up names in the assembler's symbol
table.

<<constructors for relocatable addresses>>=
| Symreloc (string name)
@

% ------------------------------------------------------------------ 
\subsection{Procedures}
% ------------------------------------------------------------------ 

It may be useful, especially when generating MIPS assembly code, to
announce the beginnings of procedures.  (Why not also the ends?  Why
not delete this function from the interface?  What about textual
assembly languages that require register-save masks and similar goo? 
Perhaps a better strategy is to require machine-specific extensions to
the interface?)

<<constructors for actions>>=
| Function (symbol)
@ 

% ------------------------------------------------------------------ 
\subsection{Sections}
% ------------------------------------------------------------------ 

The semantic model of a section is that of a relocatable block as
defined by the New Jersey Machine-Code Toolkit, which is roughly a
sequence of bytes plus the location counter.  This interface is
substantially simpler than the Toolkit, however, because it does not
provide for examining the contents of a section, but only for writing
them.

Sections are referred to by name.  The exact set of valid section
names is determined by the target machine and~OS; it is documented in
the Processor Supplement.  Most targets are likely to support
[["text"]] for code and [["data"]] for initialized data.  [[Section]]
switches to a given section.

<<constructors for actions>>=
| Section (string name)
@ 

The location counter, [[lc]], is a nonnegative offset into a section,
measured in bytes.  The location counter is considered part of the
section, so [[Section]] saves the current location counter and
restores the proper one for the new section.

The location counter of the current section can be manipulated in
various ways:

<<constructors for actions>>=
| Org   (int n)		 -- set lc to n 
| Align (int n)          -- round lc up to an n-byte boundary
| Addlc (int n)	         -- add n to lc
@ 

If advancing the location counter results in unwritten areas in a
section, the contents of those areas are undefined.  It's also
possible to advance the location counter by filling in with zeroes:

<<constructors for actions>>=
| EmitZeroes (int n)    -- write n zero bytes
@

% ------------------------------------------------------------------ 
\subsection{Instructions}
% ------------------------------------------------------------------ 

[[EmitInstruction]] emits an instruction at the current location.  The
definition of [[instruction]] is machine-dependent and not part of
this interface.  (In fact, an application like a compiler might use
this interface with more than one representation of instruction, in
which case one would have to do some jujitsu involving {\asdl} views
--- ugh.) A (machine-dependent) definition of [[instruction]] might be
generated automatically from a {\small SLED} description of the
instruction set. 

<<constructors for actions>>=
| EmitInstruction (concrete_instruction)

<<asm types>>=
concrete_instruction = (string) -- view !
@ 

% ------------------------------------------------------------------ 
\subsection{Values}\label{sec:asm:values}
% ------------------------------------------------------------------ 

{\PAL} considers all values as a bit vector, no matter whether they
are interpreted as integer, float, or address. Thus, a single action
to emit a value suffices.

<<constructors for actions>>=
| Emit (bits)                   -- width in bits

<<asm types>>=
bits = (int value, int width)   -- width in bits, view!
@

% ------------------------------------------------------------------
\subsection{Comments}
% ------------------------------------------------------------------ 

This function may be used to attempt to insert a comment into the
output.  Only implementations that emit ASCII assembly language are
likely to succeed in the attempt; all implementations are free to
ignore [[Comment]] actions.  It is an unchecked runtime error for a
comment to contain a newline, line feed, form feed, etc.

<<constructors for actions>>=
| Comment (string)
@ 

% ------------------------------------------------------------------ 
\subsection{Escape hatch}
% ------------------------------------------------------------------ 

This escape hatch can be used to emit textual assembly language
directly.  Implementations not based on textual assembly language
(e.g., binary emitters) may ignore this information entirely, or they
may try to glean something from the strings.  Use of this action is
deprecated.

<<constructors for actions>>=
| Asmtext (string)
@

% ------------------------------------------------------------------ 
\subsection{View}
% ------------------------------------------------------------------ 

The defined using {\asdl} are not used literally in the compiler. Some
of them are overridden by so-called views. Values are represented by
[[Bits.bits]]: 

<<asm.view>>=
asm.bits <= {
    natural_type:       Bits.bits
    wrapper:            to_bits
    unwrapper:          of_bits
}
@

We need some {\asdl} view trickery to get an abstract [[instruction]]
type. The code chunk [[view ocaml]] is automatically extracted to
implement the view.
 
<<asm.view>>=
module asm <= interface_prologue
%%
module type Instruction = sig
    type instruction
end

module type S = sig
    type instruction
%%


module asm <= interface_epilogue
%%
end (* module type S *) 
%%

module asm <= implementation_prologue
%%
let of_bits b     = (Bits.to_int b, Bits.width b)
let to_bits (n,w) = Bits.of_int n w

<<automatically generated asm.mli>>

module Make (I : Instruction) : S = struct
    type instruction = I.instruction
    let wrap_instruction i = assert false
    let unwrap_instruction i = assert false
%%


module asm <= implementation_epilogue
%%
end (* module Make *)
%%

asm.concrete_instruction <= {
    natural_type:   instruction
    wrapper:        wrap_instruction
    unwrapper:      unwrap_instruction
}
@

<<automatically generated asm.mli>>=
(*
  Machine generated. Edit at your own risk 
  Reproduce with the following
 --line_width=74
 --no_action=false
 --output_directory=.
 --pickler=sexp
 --view=OCaml
 *)
(* module type Asm*)
  
module type Instruction = sig
    type instruction
end

module type S = sig
    type instruction
type bits = (StdPrims.std_int *
      StdPrims.std_int)
  and concrete_instruction = (StdPrims.std_string)
  and symbol =
        Import of (StdPrims.std_string)
      | Export of (StdPrims.std_string)
      | Local of (StdPrims.std_string)
      | Common of (StdPrims.std_string *
          StdPrims.std_int *
          StdPrims.std_int *
          StdPrims.std_string)
      | Lookup of (StdPrims.std_string)
      | Offset of (StdPrims.std_string * symbol * StdPrims.std_int)
  
  and action =
        DefineSymbolHere of (symbol)
      | DefineSymbolConst of (symbol * StdPrims.std_int)
      | Function of (symbol)
      | Section of (StdPrims.std_string)
      | Org of (StdPrims.std_int)
      | Align of (StdPrims.std_int)
      | Addlc of (StdPrims.std_int)
      | EmitZeroes of (StdPrims.std_int)
      | EmitInstruction of (instruction)
      | Emit of (Bits.bits)
      | Comment of (StdPrims.std_string)
      | Asmtext of (StdPrims.std_string)
  
  and program = (StdPrims.std_string list * action list)
  and label =
        Symlabel of (symbol)
  
  and reladdr =
        Newaddr of (label * StdPrims.std_int)
      | Shiftaddr of (reladdr * StdPrims.std_int)
      | Symreloc of (StdPrims.std_string)
  
  
end (* module type S *) 


@

\ifhtml
\subsection{Index of identifiers}
\nowebindex
\subsection{List of code chunks}
\nowebchunks
\fi
