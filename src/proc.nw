% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Procedure Intermediate Representation}
% ------------------------------------------------------------------ 

The \module{ast3ir} module translates {\PAL} {\AST} to abstract assembly
code, where each instruction represents an entire procedure. A procedure
is represented by a control-flow graph and some accompanied
informations. This module provides a data type for this intermediate
representation of a procedures.

The data type provided here is in-complete and there will change. The
main purpose of this module is to provide a centralized defintion and
documentation for it.

<<type t>>=
type overflow = (Block.t list, Block.t list) Call.split_blocks
type ('automaton, 'cfg, 'cc, 'tgt) t = 
    { symbol:         Symbol.t           (* of procedure *)
    ; cc:             'cc                (* calling convention                   *)
    ; target:         'tgt               (* target of this procedure             *)
    ; temps:          Talloc.Multiple.t  (* allocator for temporaries            *)
    ; mk_symbol:      string -> Symbol.t (* allocator for symbols            *)
    ; cfg:            'cfg               (* control-flow graph                   *)
    ; oldblocks:      overflow           (* stack - incoming parms, outgoing results *)
    ; youngblocks:    overflow           (* stack - outgoing parms, incoming results *)
    ; stackd:         Block.t            (* stack - user stack data              *)
    ; conts:          Block.t            (* pairs of pointers for conts *)
    ; sp:             Block.t            (* the `standard' location of sp in body *)
    ; priv:           'automaton         (* stack - spill slots etc - still open *)
    ; eqns:           Rtleqn.t list      (* eqns for compile time consts *)
    ; vars:           int                (* number of local vars + parameters *)
    ; mutable varMap: Rtl.Private.loc VarMap.t
    }
@

\begin{itemize}
\item [[symbol]]:               the name of the procedure represented by this.
\item [[cc]]:                  calling convention for this procedure.
\item [[target]]:              the target we are compiling for.    
\item [[temps]]:               an allocator for temporaries
\item [[mk_symbol]]:           an allocator for symbols
\item [[cfg]]:                 the control-flow graph of the procedure.
\item [[oldblocks]]:    stack area for incoming overflow parameters or
outgoing overflow results, some allocated by the
                               caller and some by the callee
\item [[youngblocks]]:  stack area for outgoing overflow parameters or
incoming overflow results, some deallocated by the
                               caller and some by the callee.
\item [[incoming]]:            stack area for incoming parameters.
\item [[outgoing]]:            stack area for outgoing parameters.
\item [[stackd]]:              User stack data, from the [[stack data]] construct.
\item [[conts]]:               Area on the stack where continuations are stored.
\item [[sp]]:                  The block where the sp is stored during the procedure
             									 body.
\item [[priv]]:                Automaton that provides register-like \emph{memory}
                               locations for spill slots, continuations, etc. The 
                               memory will be allocated on the stack.
\item [[eqns]]:                Constraints for symbolic compile-time constants.
                               They are introduced by [[Area.t]] values that are
                               concatenated and overlayed to form a procedure's
                               stack frame.
\item [[vars]]:                Parameters and local variables in a procdure are
                               numbered starting from zero for the runtime system. 
                               [[vars]] is the number of parameters plus the number
                               of local variables.
\end{itemize}

<<proc.mli>>=
module VarMap : Map.S with type key = int
<<type t>> 
<<proc.ml>>= 
module VarMap = Map.Make (struct type t = int let compare = compare end)
<<type t>> 
@
