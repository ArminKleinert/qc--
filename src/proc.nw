% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% l2h substitution cfg CFG
% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Procedure Intermediate Representation}
% ------------------------------------------------------------------ 

The \module{ast3ir} module translates {\PAL} {\AST} to abstract assembly
code, where each instruction represents an entire procedure. A procedure
is represented by a control-flow graph and some accompanied
informations. This module provides a data type for this intermediate
representation of a procedures.

The data type provided here is in-complete and there will change. The
main purpose of this module is to provide a centralized defintion and
documentation for it.

<<type t>>=
type ('automaton, 'cfg, 'cc, 'tgt) t' = 
    { symbol:      Symbol.t            (* of procedure *)
    ; cc:          'cc                 (* calling convention                   *)
    ; target:      'tgt                (* target of this procedure             *)
    ; temps:       Talloc.Multiple.t   (* allocator for temporaries            *)
    ; cfg:         'cfg                (* control-flow graph                   *)
    ; oldblocks:   Block.t list        (* stack - incoming parms, outgoing results *)
    ; youngblocks: Block.t list        (* stack - outgoing parms, incoming results *)
    ; stackd:      Block.t             (* stack - user stack data              *)
    ; conts:       Block.t             (* pairs of pointers for conts *)
    ; sp:          Block.t             (* the `standard' location of sp in body *)
    ; priv:        'automaton          (* stack - spill slots etc - still open *)
    ; eqns:        Const2.t list       (* eqns for compile time consts *)
    ; vars:        int                 (* number of local vars + parameters *)
    ; mutable varMap: Rtl.Private.loc VarMap.t
    }
type t = (Automaton2.t, Cfg4.cfg, Automaton2.spec Target2.cc', Target2.t) t'
@

\begin{itemize}
\item [[name]]:     the name of the procedure represented by this.
\item [[cc]]:       calling convention for this procedure.
\item [[target]]:   the target we are compiling for.    
\item [[cfg]]:      the control-flow graph of the procedure.
\item [[incoming]]: stack area for incoming parameters.
\item [[outgoing]]: stack area for outgoing parameters.
\item [[stackd]]:   User stack data, from the [[stack data]] construct.
\item [[priv]]:     Automaton that provides register-like \emph{memory}
                    locations for spill slots, continuations, etc. The 
                    memory will be allocated on the stack.
\item [[eqns]]:     Constraints for symbolic compile-time constants.
                    They are introduced by [[Area.t]] values that are
                    concatenated and overlayed to form a procedure's
                    stack frame.
\item [[vars]]:     Parameters and local variables in a procdure are
                    numbered starting from zero for the runtime system. 
                    [[vars]] is the number of parameters plus the number
                    of local variables.
\end{itemize}

<<proc.mli>>=
module VarMap : Map.S with type key = int
<<type t>> 
<<proc.ml>>= 
module VarMap = Map.Make (struct type t = int let compare = compare end)
<<type t>> 
@
