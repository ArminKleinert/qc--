% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:
% ------------------------------------------------------------------ 
\section{PPC Recognizer} \label{ppcrec.sec}
% ------------------------------------------------------------------ 

This module provides functions that recognize a PPC RTL. The level of
indirection is an artifact from the old days. We keep it because in
the future, the recognizer might want to take a module parameter.
N.B.~A~recognizer takes two forms: one to say if we have an
instruction, and one to convert to an assembly-language string.
<<ppcrec.mli>>=
module M : sig
  val is_instruction : Rtl.rtl -> bool
  val to_asm         : Rtl.rtl -> string list -> string
end
<<ppcrec.mlb>>=
%head {: <<modules>> 
         module M = struct
           <<code to precede the labeler>>
      :}
%tail {:   <<code to follow the labeler>>
         end (* of M *) 
      :}

%term <<names of types of terminals>>
%%
<<rules>>
@
A few abbreviations.
<<modules>>=
module BO   = Bits.Ops
module RP   = Rtl.Private
module RU   = Rtlutil
module SS   = Space.Standard32
module Down = Rtl.Dn      (* Convert Down  to private repr. *)
module Up   = Rtl.Up      (* Convert Up    to abstract repr. *)

exception Error of string
let error msg = raise (Error msg)
let sprintf = Printf.sprintf
@ 
% ------------------------------------------------------------------ 
\subsection{Utilities}
% ------------------------------------------------------------------ 
<<code to precede the labeler>>=
let cat = String.concat ""
@   
The [[guard]] function turns a predicate into a cost.
<<code to precede the labeler>>=
let infinity = Camlburg.inf_cost
let guard b = if b then 0 else infinity
@ 
Utilities for instructions.
<<code to precede the labeler>>=

let fits b w =
  let i  = Bits.S.to_int64 b in
  let i' = Int64.abs i in
  let i' = Int64.shift_right i' w in
  Int64.compare i' Int64.zero = 0

let imports = ref ([] : string list)

let ind_addr name =
  if List.exists ((=$=) name) (!imports) then "L" ^ name ^ "$stub" else name

let ppc_op = function
  | "ltu" -> ("l", "lt")
  | "leu" -> ("l", "le")
  | "gtu" -> ("l", "gt")
  | "geu" -> ("l", "ge")
  | op    -> ("" , op  )
@
% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
% ------------------------------------------------------------------ 
In a {\burg} pattern, a name denotes either a polymorphic nonterminal
symbol or a monomorphic terminal symbol. 
We distinguish terminals from nonterminals by name, so we have to
announce the names of the nonterminals.
<<names of types of terminals>>=
n w bits symbol
@ Terminals [[n]] and [[w]] are an index and width; both are integers.
Terminal [[bits]] is a constant of types [[Bits.bits]]; terminal
[[symbol]] is a string.

<<rules>>=
const32:  Bits(bits) [{: guard (fits bits 32) :}] {: Bits.to_decimal_string bits :}
const16:  Bits(bits) [{: guard (fits bits 16) :}] {: Bits.to_decimal_string bits :}

lconst: Link(symbol, w:int)        {: symbol#mangled_text :}
pic:    Diff(c1:lconst, c2:lconst) {: c1 ^ "-" ^ c2 :}
pic:    Fetch(Mem(Diff(c1:lconst, c2:lconst)), w2:int) {: c1 ^ "-" ^ c2 :}
@ 
\paragraph{Registers}
<<rules>>=
regl: Reg('r', n:int) [{: guard (n<>0) :}] {: "r" ^ string_of_int n :}

pcl:  Reg('c', 0) {: () :}
cial: Reg('c', 1) {: () :}
crl:  Reg('c', 2) {: () :}
xerl: Reg('c', 4) {: () :}
lrl:  Reg('c', 5) {: () :}
spl:  Reg('r', 14) {: () :}

reg:                  Fetch(regl, w:int)         {: regl :}
reg:  BitExtract(any, Fetch(regl, w:int), n:int) {: regl :}

pc:   Fetch(pcl,  32) {: () :}
cia:  Fetch(cial, 32) {: () :}
cr:   Fetch(crl,  32) {: () :}
lr:   Fetch(lrl,  32) {: () :}
sp:   Fetch(spl,  32) {: () :}
@
\paragraph{Addresses}
<<rules>>=
addr: const16                 {: const16 ^ "(r0)"          :}
addr: reg                     {:          "0(" ^ reg ^ ")" :}
addr: Add(reg, const16)       {: const16 ^ "(" ^ reg ^ ")" :}

index_addr: Add(reg1:reg, reg2:reg) {: reg1 ^","^ reg2 :}
@
\paragraph{Data Movement}
<<rules>>=
inst:  Store(regl, reg, w:int) {: "mr " ^ regl ^ "," ^ reg :}
inst:  Store(regl,  lr, w:int) {: "mflr " ^ regl :}
inst:  Store(lrl,  reg, w:int) {: "mtlr " ^ reg  :}
inst:  Store(regl,  cr, w:int) {: "mfcr " ^ regl :}

inst: Store(regl, const16, 32) {: "addi " ^ regl ^",0,"^ const16 :}

inst: Store(Slice(16, 0, regl),  const16, 16) {: "addi "  ^ regl ^",0,"^ const16 :}
inst: Store(Slice(16, 16, regl), const16, 16) {: "addis " ^ regl ^","^ regl ^","^ const16 :}

inst: Store (regl, Fetch(Mem(addr      ),32), 32) {: "lwz "  ^ regl ^","^ addr  :}
inst: Store (regl, Fetch(Mem(index_addr),32), 32) {: "lwzx " ^ regl ^","^ index_addr :}

inst: Store (Mem(addr      ), Fetch(regl,32), 32) {: "stw "  ^ regl ^","^ addr  :}
inst: Store (Mem(index_addr), Fetch(regl,32), 32) {: "stwx " ^ regl ^","^ index_addr :}
@ 
Position-independent code. The integer register r2 is used for
position-independent code.
<<rules>>=
inst:  Store(regl, Add(reg,pic), 32)
       {: "addis " ^ regl ^ ","^ reg ^",ha16(" ^ pic ^ ")\n\tla " ^ regl ^
          ",lo16(" ^ pic ^ ")(" ^ regl ^ ")" :}
inst:  Store(regl, pic, 32)
       {: "li " ^ regl ^ ",ha16(" ^ pic ^ ")\n\tla " ^ regl ^
          ",lo16(" ^ pic ^ ")(" ^ regl ^ ")" :}
@
\paragraph{Control Flow}
<<rules>>=
inst:  Goto(lconst) {: "b " ^ ind_addr lconst :}
inst:  Goto(lr)     {: "blr"                  :}
@
The [[cut to]] is supposed to look atomic, but it is a sequence of two
instructions. 
<<rules>>=
inst : Par(Goto(lr),Store(regl,reg,w:int)) {: sprintf "mr %s, %s; blr" regl reg :}
@
The [[next]] pattern covers the expression $PC + 4$ which denotes the
instruction following the branch instruction.

<<rules>>=
next:  Add(cia,const32) {: () :}
inst:  Par(Goto(lconst), Store(lrl,next,32)) {: "bl " ^ ind_addr lconst :}
@

Here are conditional branches. The {\rtl} operator names fit the {\mips}
assembly branch op-codes. We cannot inline the [[Cmp]] constructor
because the [[op]] terminal symbol would be unaccessible. Only top-level
terminals are in scope for the semantic action.

<<rules>>=
cmp:   Cmp(op:string, x:reg, y:reg) {: ("",  ppc_op op,x,y) :}
cmp:   Cmp(op:string, x:reg, y:const16) {: ("i", ppc_op op,x,y) :}
inst:  Guarded(cmp,Goto(lconst)) 
       {: match cmp with
          | (i_, (l_, op),x,y) -> "cmp" ^ l_ ^ "w" ^ i_ ^ " cr0," ^ x ^ "," ^
                                  y ^ "\n\tb" ^ op ^ " " ^ lconst
       :}
inst : Guarded(OvSet(Fetch(xerl,32)), Goto(lconst))
       {: "bo " ^ lconst :}
@ 
\paragraph{Arithmetic instructions}

<<rules>>=
inst:  Store(regl, Add(x:reg,y:reg), w:int)
       {: "add "  ^ regl ^ "," ^ x    ^ "," ^ y     :}
inst:  Store(regl, Add(x:reg,y:const16), w:int)
       {: "addi " ^ regl ^ "," ^ x    ^ "," ^ y     :}
inst:  Store(regl, Sub(x:reg,y:reg), w:int)
       {: "sub " ^ regl ^ "," ^ x    ^ "," ^ y     :}
inst:  Store(regl, Mul(x:reg,y:reg), w:int)
       {: "mullw " ^ regl ^ "," ^ x    ^ "," ^ y     :}
inst:  Store(regl, Neg(reg), w:int) {: "neg " ^ reg ^ "," ^ reg :}

@ 
\paragraph{Logical instructions}

<<rules>>=
inst:  Store(regl, And(x:reg,y:reg), w:int)
       {: "and "   ^ regl ^ "," ^ x    ^ "," ^ y     :}
inst:  Store(regl, And(x:reg,y:const16), w:int)
       {: "andi. " ^ regl ^ "," ^ x    ^ "," ^ y     :}
inst:  Store(regl, Or(x:reg,y:reg), w:int)
       {: "or "  ^ regl ^ "," ^ x    ^ "," ^ y     :}
inst:  Store(regl, Or(x:reg,y:const16), w:int)
       {: "ori " ^ regl ^ "," ^ x    ^ "," ^ y     :}
inst:  Store(regl, Xor(x:reg,y:reg), w:int)
       {: "xor "  ^ regl ^ "," ^ x    ^ "," ^ y     :}
inst:  Store(regl, Xor(x:reg,y:const16), w:int)
       {: "xori " ^ regl ^ "," ^ x    ^ "," ^ y     :}
inst: Store(regl, Shl(x:reg, y:reg), w:int)
       {: "slw " ^ regl ^ "," ^  x    ^ "," ^ y     :}
@
\paragraph{Other instructions}
<<rules>>=
inst : Nop() {: "nop" :}
@ 
\paragraph{Support for debugging}
If an RTL should fail to match, one can uncomment the following rule
and get a printout of exactly how that RTL is represented using {\burg}
constructors. 
<<rules>>=
inst : any [100] {: "<" ^ any ^ ">" :}

any : True  () {: "True"  :}
any : False () {: "False" :}
any : Link(symbol, w:int) {: "Link(" ^ symbol#mangled_text ^ "," ^ string_of_int w ^ ")" :}
any : Diff(c1:any, c2:any) {: "Diff(" ^ c1 ^ ", " ^ c2 ^ ")" :}
any : Late(string, w) {: "Late(" ^ string ^ "," ^ string_of_int w ^")" :}
any : Bits(bits)     {: sprintf "Bits(%s)" (Bits.to_string bits) :}

any : Fetch (any, w:int) {: "Fetch(" ^ any ^ "," ^ string_of_int w ^ ")" :}

any : Add(x:any, y:any) {: "Add(" ^ x ^ ", " ^ y ^ ")" :}
any : Sub(x:any, y:any) {: "Sub(" ^ x ^ ", " ^ y ^ ")" :}
any : Mul(x:any, y:any) {: "Mul(" ^ x ^ ", " ^ y ^ ")" :}
any : Neg(any) {: "Neg(" ^ any ^ ")" :}
any : And(x:any, y:any) {: "And(" ^ x ^ ", " ^ y ^ ")" :}
any : Or(x:any, y:any) {: "Or(" ^ x ^ ", " ^ y ^ ")" :}
any : Xor(x:any, y:any) {: "Xor(" ^ x ^ ", " ^ y ^ ")" :}
any : Shl(x:any, y:any) {: "Shl(" ^ x ^ ", " ^ y ^ ")" :}
any : Shra(x:any, y:any) {: "Shra(" ^ x ^ ", " ^ y ^ ")" :}
any : Shrl(x:any, y:any) {: "Shrl(" ^ x ^ ", " ^ y ^ ")" :}
any : Rem(x:any, y:any)  {: "Rem(" ^ x ^ ", " ^ y ^ ")" :}

any : Lobits(any, w) {: "Lobits(" ^ any ^ ", " ^ string_of_int w ^ ")" :}
any : BitExtract(lsb:any, y:any, n:int) {: sprintf "BitExtract(%s, %s, %d)" lsb y n :}

any : Slice(w:int, n:int, y:any) {: sprintf "Slice(%d, %d, %s)" w n y :}

any : Mem(any) {: "Mem(" ^any ^ ")" :}
any : Reg(char, n:int) {: sprintf "Reg(%s, %d)" (Char.escaped char) n :}

any : Store (dst:any, src:any, w:int)
 {: "Store(" ^ dst ^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}
any : Kill(any) {: "Kill(" ^ any ^ ")" :}

any : Guarded(guard:any, any) {: "Guarded(" ^ guard ^ "," ^ any ^ ")" :}
any : Cmp(op:string, x:any, y:any)    
                        {: cat [ "Cmp(";op;",";x;",";y;")" ] :}
any : Par(l:any, r:any) {: "Par(" ^ l ^ "," ^ r ^ ")" :}
any : Goto(any) {: "Goto(" ^ any ^ ")" :}
@


% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

The code in this section walks an RTL and calls suitable \burg\
constructors. 
<<code to follow the labeler>>=  
let rec const = function
  | RP.Bool(true)             -> conTrue  ()
  | RP.Bool(false)            -> conFalse ()
  | RP.Link(s,_,w)            -> conLink s w
  | RP.Diff(c1,c2)            -> conDiff (const c1) (const c2)
  | RP.Late(s,w)              -> conLate s w
  | RP.Bits(b)                -> conBits(b)
@
<<code to follow the labeler>>=  
let cmp = ["eq";"ge";"geu";"gt";"gtu";"le";"leu";"lt";"ltu";"ne"] 

let rec exp = function
  | RP.Const(k)               -> const (k)
  | RP.Fetch(l,w)             -> conFetch (loc l) w
  | RP.App(("add",  ws), [x; y]) -> conAdd  (exp x) (exp y)
  | RP.App(("sub",  ws), [x; y]) -> conSub  (exp x) (exp y)
  | RP.App(("mul",  ws), [x; y]) -> conMul (exp x) (exp y)
  | RP.App(("neg",  ws), [x])    -> conNeg  (exp x)
  | RP.App(("and",  ws), [x; y]) -> conAnd  (exp x) (exp y)
  | RP.App(("or",   ws), [x; y]) -> conOr   (exp x) (exp y)
  | RP.App(("xor",  ws), [x; y]) -> conXor  (exp x) (exp y)
  | RP.App(("shl",  ws), [x; y]) -> conShl  (exp x) (exp y)
  | RP.App(("shra", ws), [x; y]) -> conShra (exp x) (exp y)
  | RP.App(("shrl", ws), [x; y]) -> conShrl (exp x) (exp y)
  | RP.App(("rem",  ws), [x; y]) -> conRem  (exp x) (exp y)
  | RP.App(("ppc_xer_ov_set", []), [x]) -> conOvSet (exp x)
  | RP.App(("bitExtract", [w; n]), [lsb; src]) -> conBitExtract (exp lsb) (exp src) n
  | RP.App((op, ws), [x; y])
    when List.mem op cmp -> conCmp op (exp x) (exp y)
  | RP.App((o,_),_)           -> error (sprintf "unknown operator %s" o)
@ 
<<code to follow the labeler>>=  
and loc l = match l with
  | RP.Mem(('m',_,_), Rtl.C c, e, ass) -> conMem (exp e)
  | RP.Reg((sp, _,_), i, w)            -> conReg sp i 
  | RP.Mem(_, _, _, _)     -> error "non-mem, non-reg cell"
  | RP.Var _ | RP.Global _ -> error "var found"
  | RP.Slice(w,i,l)        -> conSlice w i (loc l)

and effect = function
  | RP.Store(RP.Reg(('c',_,_), i, w),r,_) 
    when i = SS.indices.SS.pc         -> conGoto (exp r)
  | RP.Store(l,e,w)                   -> conStore (loc l) (exp e) w
  | RP.Kill(l)                        -> conKill (loc l)

and guarded g eff = match g with
| RP.Const(RP.Bool b) -> if b then effect eff else conNop()
| _ -> conGuarded (exp g) (effect eff)

and geffects = function
    | [] -> conNop ()
    | [g, s] -> guarded g s
    | (g, s) :: t -> conPar (guarded g s) (geffects t)
and rtl (RP.Rtl es) = geffects es
@

\subsection{The exported recognizers}

The only tricky bits here are what we do when something goes wrong.
In a production compiler, we should always halt the compiler.
But here, it is more informative to drop an error message into the
assembly language and to allow the assembler to barf downstream.
<<code to follow the labeler>>=
let errmsg r msg =
  List.iter prerr_string
    [ "recognizer error: "; msg; " on "; RU.ToString.rtl r; "\n" ]

let to_asm r i =
  try
    let _ = imports := i in
    let plan = rtl (Down.rtl r) in
    plan.inst.Camlburg.action ()
  with 
  | Camlburg.Uncovered -> cat [" not an instruction: " ; RU.ToString.rtl r]
  | Error msg -> (errmsg r msg; " error in recognizer: " ^ msg)

let is_instruction r =
  try
    let plan = rtl (Down.rtl r) in
    plan.inst.Camlburg.cost < 100
  with
  | Camlburg.Uncovered -> false
  | Error msg -> (errmsg r msg; false)
@                        
