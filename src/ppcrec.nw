% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

\newcommand{\syryu}[1]{#1}
\newcommand{\delete}[1]{}

% ------------------------------------------------------------------ 
\section{PPC Recognizer} \label{ppcrec.sec}
% ------------------------------------------------------------------ 

%%Grades: B Subsystem Later

This module provides functions that recognize a PPC RTL.
As an experiment, the recognizer is implemented using BURG rules.
If the instruction is recognized, it is coverable with small cost.
(Perhaps one day, the cost could be bytes of code.)
If it is not recognized, there is a catchall rule that recognizes
anything with cost~100 (I~hope).

WARNING: THIS RECOGNIZER DOES NOT (YET) RECOGNIZE KILLS.

The level of indirection is an artifact from the old days.
We keep it because in the future, the recognizer might want to take a
module parameter.
N.B.~A~recognizer takes two forms: one to say if we have an
instruction, and one to convert to an assembly-language string.
<<ppcrec.mli>>=
module M : sig
  val is_instruction : Rtl.rtl -> bool
  val to_asm         : Rtl.rtl -> string
end
@ 
<<ppcrec.mlb>>=
%head {: <<modules>> 
         module M = struct
           <<code to precede the labeler>>
      :}
%tail {:   <<code to follow the labeler>>
         end (* of M *) 
      :}

%term <<names of types of terminals>>

<<ppcrec.mlb>>=
%%
<<rules>>
@
A few abbreviations.
<<modules>>=
module RP = Rtl.Private
module RU = Rtlutil
module SS = Space.Standard32
module Down  = Rtl.Dn      (* Convert Down  to private repr. *)
module Up    = Rtl.Up       (* Convert Up    to abstract repr. *)
@
If something goes wrong during recognition, we raise this exception.
It's different from merely ``unrecognized;'' it means something
happened that shouldn't have.
<<code to precede the labeler>>=
exception Error of string
let error msg = raise (Error msg)
@
We should be using [[sprintf]] more.
<<code to precede the labeler>>=
let sprintf = Printf.sprintf
@ 


% ------------------------------------------------------------------ 
\subsection{Utilities}
% ------------------------------------------------------------------ 

We've had some mystery problems; in particular, we've seen the integer
$-4$ get converted to 32~bits with its sign bit clear.
<<code to precede the labeler>>=
let native' w b = 
  assert (Bits.width b = w);
  Nativeint.to_string (Bits.U.to_native b)
let native = native' 32
let cat = String.concat ""
@   
The [[guard]] function turns a predicate into a cost.
<<code to precede the labeler>>=
let infinity = Camlburg.inf_cost
let guard b = if b then 0 else infinity
@ 
The PPC uses a suffix to denote width.
<<code to precede the labeler>>=
let suffix w = match w with
| 8  -> "b"
| 16 -> "h"
| 32 -> "w"
| _ -> Impossible.impossible "width in x86 not 8/16/32"
@ 
% ------------------------------------------------------------------ 
\subsection{Register names}
% ------------------------------------------------------------------ 
<<code to precede the labeler>>=
let regname n = "r" ^ string_of_int n

@ 
% ------------------------------------------------------------------ 
\subsection{Utilities for instructions}
% ------------------------------------------------------------------ 
<<code to precede the labeler>>=
let fst (x, _) = x
let snd (_, x) = x

let int_load str (suff, z_a, (x_, mem)) r =
  match (String.get z_a 0, String.get suff 0) with
  | ('z',  _) | ('a','h') -> sprintf str suff z_a x_ r mem
  | _ -> Impossible.impossible "wrong integer load instruction"
 
let get_reg mem_str =
  match String.get mem_str (String.length mem_str - 1) with
  | ')' -> let start = (String.index mem_str '(') + 1
           in  (String.sub mem_str start (String.length mem_str - (start+1)),
                None)
  | _   -> let middle = String.index mem_str ','
           in  (String.sub mem_str 0 middle,
                Some(String.sub mem_str (middle+1)
                                        (String.length mem_str - (middle+1))))

let int_loadu str (suff, z_a, (x_, mem)) r r1 r2 =
  match (String.get z_a 0, String.get suff 0) with
  | ('z',  _) | ('a','h') -> 
    (match get_reg mem with
    | (r1',None    ) -> if r1=r1' then sprintf str suff z_a x_ r mem else "nop"
    | (r1',Some r2') -> if r1=r1' && r2=r2'
                                  then sprintf str suff z_a x_ r mem else "nop")
  | _ -> Impossible.impossible "wrong integer load with update instruction"

let int_store  str suff (x_, mem) r = sprintf str suff x_ r mem
let int_storeu str suff (x_, mem) r r1 r2 =
  match get_reg mem with
  | (r1',None    ) -> if r1=r1' then sprintf str suff x_ r mem else "nop"
  | (r1',Some r2') -> if r1=r1' && r2=r2' 
                                then sprintf str suff x_ r mem else "nop"
@
% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
% ------------------------------------------------------------------ 
In a {\burg} pattern, a name denotes either a polymorphic nonterminal
symbol or a monomorphic terminal symbol. 
We distinguish terminals from nonterminals by name, so we have to
announce the names of the nonterminals.
<<names of types of terminals>>=
n w bits symbol
@ Terminals [[n]] and [[w]] are an index and width; both are integers.
Terminal [[bits]] is a constant of types [[Bits.bits]]; terminal
[[symbol]] is a string.

<<rules>>=
const:  Bits(bits) [{: guard (Bits.width bits = 32) :}] {: native bits :}
lconst: Link(symbol, w:int)      {: symbol#mangled_text :}
@ 
\paragraph{Registers}
<<rules>>=
regl: Reg('r', n:int, w:int) [{: guard (n<>0) :}] {: regname n :}

pcl:  Reg('c', 0, w:int) {: () :}
lrl:  Reg('c', 2, w:int) {: () :} -- need to check with the postexpander

reg:                  Fetch(regl, w:int)         {: regl :}
reg:  BitExtract(any, Fetch(regl, w:int), n:int) {: regl :}

pc:   Fetch(pcl, 32) {: () :}
lr:   Fetch(lrl, 32) {: () :}
@

\paragraph{Addresses}
<<rules>>=
meml: Mem(addr, w:int)       {: addr :}
mem:  Sx(Fetch(meml, w:int)) {: (suffix w, "a", meml) :}
mem:  Zx(Fetch(meml, w:int)) {: (suffix w, "z", meml) :}
mem:     Fetch(meml, w:int)  {: (suffix w, "z", meml) :}

addr: i_r                     {: ("",  i_r) :}
addr: Add(reg, imm)           {: ("",  imm ^ "(" ^ reg ^ ")") :}
addr: Add(reg1:reg, reg2:reg) {: ("x", reg1 ^ "," ^ reg2) :}

i_r: imm {: imm :}
i_r: reg {: reg :}
@

\paragraph{Constant Expressions}
<<rules>>=
imm:  const {: const :}
@

\paragraph{Data Movement}

Load register from memory. A load of a value smaller than 32 bits
implies a zero or sign extension.

<<rules>>=
inst:  Store(regl, mem, 32) {: int_load "l%s%s%s %s,%s" mem regl :}
inst:  Par(Store(regl1:regl, mem, 32), Llr(regl2:regl, "add", i_r, 32))
       {: int_loadu "l%s%su%s %s,%s" mem regl1 regl2 i_r :}
@

Store register to memory. No extension here; the 8, 16, or 32 bits are
simply written to memory.
  
<<rules>>=
inst:  Store(meml, reg, w:int)
       {: int_store  "st%s%s %s,%s"  (suffix w) meml reg :}
inst:  Par(Store(meml, reg, w:int), Llr(regl, "add", i_r, 32))
       {: int_storeu "st%su%s %s,%s" (suffix w) meml reg regl i_r :}
@ 
\paragraph{Control Flow}
<<rules>>=
inst:  Goto(lconst) {: "b " ^ lconst :}
@

The [[next]] pattern covers the expression $PC + 4$ which denotes the
instruction following the branch instruction.
<<rules>>=
next:  Add(pc, const) {: () :}
inst:  Par(Store(lrl,next,32), Goto(addr)) {: "bl " ^ (fst addr) :}
@ 
\paragraph{Other instructions}
<<rules>>=
inst : Nop() {: "nop" :}
@ 
\paragraph{Support for debugging}
If an RTL should fail to match, one can uncomment the following rule
and get a printout of exactly how that RTL is represented using {\burg}
constructors. 
<<rules>>=
inst : any [100] {: "<" ^ any ^ ">" :}

any : True  () {: "True"  :}
any : False () {: "False" :}
any : Link(symbol, w:int) {: "Link(" ^ symbol#mangled_text ^ "," ^ string_of_int w ^ ")" :}
any : Late(string, w) {: "Late(" ^ string ^ "," ^ string_of_int w ^")" :}
any : Bits(bits)     {: sprintf "Bits(%s)" (Bits.to_string bits) :}

any : Fetch (any, w:int) {: "Fetch(" ^ any ^ "," ^ string_of_int w ^ ")" :}

any : Add(x:any, y:any) {: "Add(" ^ x ^ ", " ^ y ^ ")" :}
any : Sub(x:any, y:any) {: "Sub(" ^ x ^ ", " ^ y ^ ")" :}
any : Sx(any) {: "Sx(" ^ any ^ ")" :}
any : Zx(any) {: "Zx(" ^ any ^ ")" :}
any : Lobits(any, w) {: "Lobits(" ^ any ^ ", " ^ string_of_int w ^ ")" :}
any : BitExtract(lsb:any, y:any, n:int) {: sprintf "BitExtract(%s, %s, %d)" lsb y n :}

any : Slice(n:w, lsb:n, y:any) {: sprintf "Slice(%d, %d, %s)" n lsb y :}

any : Mem(any, w:int) {: "Mem(" ^any ^ "," ^ string_of_int w ^ ")" :}
any : Reg(char, n:int, w:int) {: sprintf "Reg(%s, %d, %d)"   (Char.escaped char) n w :}

any : Store (dst:any, src:any, w:int)
 {: "Store(" ^ dst ^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}
any : Kill(any) {: "Kill(" ^ any ^ ")" :}

any : Guarded(guard:any, any) {: "Guarded(" ^ guard ^ "," ^ any ^ ")" :}
any : Cmp(op:string, x:any, y:any)    
                        {: cat [ "Cmp(";op;",";x;",";y;")" ] :}
any : Par(l:any, r:any) {: "Par(" ^ l ^ "," ^ r ^ ")" :}
any : Goto(any) {: "Goto(" ^ any ^ ")" :}
any : Llr(dst:any, string, src:any, w:int) 
  {: "Llr(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}
@


% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

The code in this section walks an RTL and calls suitable \burg\
constructors. 
The most interesting code is probably the code that maps the
general representation of application into one that uses a unique
constructor for each operator.
<<special cases for particular operators>>=
| RP.App(("add", [w]), [x; y])            -> conAdd (exp x) (exp y)
| RP.App(("sub", [w]), [x; y])            -> conSub (exp x) (exp y)
| RP.App(("bitExtract", [w; n]), [lsb; src]) -> conBitExtract (exp lsb) (exp src) n
| RP.App((op, [w]), [x; y]) 
    when Strutil.Set.mem op cmp           -> conCmp op (exp x) (exp y)
@ 
Here is the rest of the mapping.  
<<code to follow the labeler>>=  
let const = function
  | RP.Bool(true)             -> conTrue  ()
  | RP.Bool(false)            -> conFalse ()
  | RP.Link(s,w)              -> conLink s w
  | RP.Late(s,w)              -> conLate s w
  | RP.Bits(b)                -> conBits(b)
<<code to follow the labeler>>=  
let cmp = 
    Strutil.from_list ["eq";"ge";"geu";"gt";"gtu";"le";"leu";"lt";"ltu";"ne"] 

let rec exp = function
  | RP.Const(k)               -> const (k)
  | RP.Fetch(l,w)             -> conFetch (loc l) w
  <<special cases for particular operators>>
  | RP.App((o,_),_)           -> error (sprintf "unknown operator %s" o)
@ 
\syryu{
If [[loc]] is a memory location, then its space is either [['m']] or [['f']].
For the x86, when [[loc]] is [[fpcc]] (the FPU condition codes) or
[[fpustatus]] (the FPU status word) is the special case. How about the PPC?
Finally, [[loc]] cannot be [[RP.Var]].}
<<code to follow the labeler>>=  
and loc l = match l with
  | RP.Mem('m', aff, w, e, ass) -> conMem (exp e) w
  | RP.Reg(sp, i, w)          -> conReg sp i w 
  | RP.Mem(_, _, _, _, _)     -> error "non-mem, non-reg cell"
  | RP.Var(s, i, w)           -> error "var found"
  | RP.Slice(w,i,l)           -> (*error "cannot handle slice"*)
      conSlice w i (loc l)
@ 
Things start to get a bit baroque here, as we recognize different
special forms a single effect can take.
\syryu{
If an effect is the form $L \mathrel{:=} L \oplus R$, it should be as
follows:\\
[[        RP.Store(l, RP.App((_, _), [RP.Fetch(l',_); _]), w)]]\\
where [[l]] equals to [[l']].
If an effect is the form $L \mathrel{:=} \oplus L$, it should be as
follows:\\
[[        RP.Store(l, RP.App((_, [w']), [RP.Fetch(l',_)]), w)]]\\
where [[l]] equals to [[l']] and [[w]] equals to [[w']].
Finally, if the location of a store effect is a control and special register,
then the location should be either [[SS.indices.SS.pc]] or
[[SS.indices.SS.cc]] which represents the [[Goto]] or [[Setflags]] effect,
respectively.
}
<<code to follow the labeler>>=  
and effect = function
  | RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r]), w) 
    when l = l'                       -> conLlr (loc l) o (exp r) w
  | RP.Store(RP.Reg('c', i, w),r,_) 
    when (i = SS.indices.SS.pc)       -> conGoto (exp r)
  | RP.Store(l,e,w)                   -> conStore (loc l) (exp e) w
  | RP.Kill(l)                        -> conKill (loc l)
@
The truly ghastly stuff is the stuff that recognizes multiple
effects that set flags.
<<code to follow the labeler>>=  
and rtl (RP.Rtl es) = geffects es
and geffects = function
    | [] -> conNop ()
    | [g, s] -> guarded g s
    | (g, s) :: t -> conPar (guarded g s) (geffects t)
and is8 b =
  Bits.width b > 3 & Bits.Ops.eq b (Bits.U.of_int 8 (Bits.width b))
@ 
Dealing with a guard is straightforward.
Either it's trivial, it's a conditional branch, or we pass it off to
the recognizer (which currently falls on the floor).
\syryu{
If a guard [[(guard, effect)]] is a conditional branch, 
then [[guard]] is as follows:\\
[[        RP.App((compare, [32]), [RP.Fetch(RP.Reg('c', n, _), _)])]]\\
where the name of [[compare]] begins with [[ppc_]],
[[n]] equals to [[SS.indices.SS.cc]],
and [[effect]] is as follows:\\
[[        RP.Store(RP.Reg('c', i, _), r, _)]]\\
where [[i]] equals to [[SS.indices.SS.pc]].}
<<code to follow the labeler>>=  
and guarded g eff = match g with
| RP.Const(RP.Bool b) -> if b then effect eff else conNop()
| _ -> conGuarded (exp g) (effect eff)
@
\syryu{
For the x86, [[SS.indices.SS.cc]] is [[eflags]]. How about the PPC?
}
@

\subsection{The exported recognizers}

The only tricky bits here are what we do when something goes wrong.
In a production compiler, we should always halt the compiler.
But here, it is more informative to drop an error message into the
assembly language and to allow the assembler to barf downstream.
<<code to follow the labeler>>=
let errmsg r msg =
  List.iter prerr_string
    [ "recognizer error: "; msg; " on "; RU.ToReadableString.rtl r; "\n" ]

let to_asm r =
  try
    let plan = rtl (Down.rtl r) in
    plan.inst.Camlburg.action ()
  with 
  | Camlburg.Uncovered -> cat [" not an instruction: " ; RU.ToReadableString.rtl r]
  | Error msg -> (errmsg r msg; " error in recognizer: " ^ msg)

let is_instruction r =
  try
    let plan = rtl (Down.rtl r) in
    plan.inst.Camlburg.cost < 100  (* should be true, but shade this... *)
  with 
  | Camlburg.Uncovered -> false
  | Error msg -> (errmsg r msg; false)
@                        
