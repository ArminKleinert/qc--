% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et:
% ------------------------------------------------------------------ 
\section{PPC Recognizer} \label{ppcrec.sec}
% ------------------------------------------------------------------ 

This module provides functions that recognize a PPC RTL. The level of
indirection is an artifact from the old days. We keep it because in
the future, the recognizer might want to take a module parameter.
N.B.~A~recognizer takes two forms: one to say if we have an
instruction, and one to convert to an assembly-language string.
<<ppcrec.mli>>=
module M : sig
  val is_instruction : Rtl.rtl -> bool
  val to_asm         : Rtl.rtl -> string list -> string
end
<<ppcrec.mlb>>=
%head {: <<modules>> 
         module M = struct
           <<code to precede the labeler>>
      :}
%tail {:   <<code to follow the labeler>>
         end (* of M *) 
      :}

%term <<names of types of terminals>>
%%
<<rules>>
@
A few abbreviations.
<<modules>>=
module BO   = Bits.Ops
module RP   = Rtl.Private
module RU   = Rtlutil
module SS   = Space.Standard32
module Down = Rtl.Dn      (* Convert Down  to private repr. *)
module Up   = Rtl.Up      (* Convert Up    to abstract repr. *)

exception Error of string
let error msg = raise (Error msg)
let sprintf = Printf.sprintf
@ 
% ------------------------------------------------------------------ 
\subsection{Utilities}
% ------------------------------------------------------------------ 
<<code to precede the labeler>>=
let cat = String.concat ""
@   
The [[guard]] function turns a predicate into a cost.
<<code to precede the labeler>>=
let infinity = Camlburg.inf_cost
let guard b = if b then 0 else infinity
@ 
Utilities for instructions.
<<code to precede the labeler>>=
let fits b w =  (* REPLACE WITH Bits.S.fits?? *)
  let i  = Bits.S.to_int64 b in
  let i' = Int64.abs i in
  let i' = Int64.shift_right i' w in
  Int64.compare i' Int64.zero = 0

let imports = ref ([] : string list)

let ind_addr name =
  if List.exists ((=$=) name) (!imports) then "L" ^ name ^ "$stub" else name

let ppc_op = function
  | "ltu" -> ("l", "lt")
  | "leu" -> ("l", "le")
  | "gtu" -> ("l", "gt")
  | "geu" -> ("l", "ge")
  | op    -> ("" , op  )
@
% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
% ------------------------------------------------------------------ 
In a {\burg} pattern, a name denotes either a polymorphic nonterminal
symbol or a monomorphic terminal symbol. 
We distinguish terminals from nonterminals by name, so we have to
announce the names of the nonterminals.
<<names of types of terminals>>=
n w bits symbol
@ Terminals [[n]] and [[w]] are an index and width; both are integers.
Terminal [[bits]] is a constant of types [[Bits.bits]]; terminal
[[symbol]] is a string.

<<rules>>=
const32:  Bits(bits) [{: guard (fits bits 32) :}] {: Bits.to_decimal_string bits :}
const16:  Bits(bits) [{: guard (fits bits 16) :}] {: Bits.to_decimal_string bits :}

lconst: Link(symbol, w:int)        {: symbol#mangled_text :}
pic:    Diff(c1:lconst, c2:lconst) {: c1 ^ "-" ^ c2 :}
pic:    Fetch(Mem(Diff(c1:lconst, c2:lconst)), w2:int) {: c1 ^ "-" ^ c2 :}
@ 
\paragraph{Registers}
<<rules>>=
pcl:  Reg('c', 0) {: () :}
cial: Reg('c', 1) {: () :}
crl:  Reg('c', 2) {: () :}
xerl: Reg('c', 4) {: () :}
lrl:  Reg('c', 5) {: () :}
spl:  Reg('r', 14) {: () :}

pc:   Fetch(pcl,  32) {: () :}
cia:  Fetch(cial, 32) {: () :}
cr:   Fetch(crl,  32) {: () :}
lr:   Fetch(lrl,  32) {: () :}
sp:   Fetch(spl,  32) {: () :}

regl: Reg('r', n:int) [{: guard (n<>0) :}] {: "r" ^ string_of_int n :}
reg:  Fetch(regl, 32) {: regl :}
@
\paragraph{Addresses}
<<rules>>=
addr: const16                 {: const16 ^ "(r0)"          :}
addr: reg                     {:          "0(" ^ reg ^ ")" :}
addr: Add(reg, const16)       {: const16 ^ "(" ^ reg ^ ")" :}

ndx_addr: Add(reg1:reg, reg2:reg) {: reg1 ^","^ reg2 :}
@
\paragraph{Data Movement}
<<rules>>=
inst: Store(regl, reg, w:int) {: "mr " ^ regl ^ "," ^ reg :}
inst: Store(regl,  lr, w:int) {: "mflr " ^ regl :}
inst: Store(lrl,  reg, w:int) {: "mtlr " ^ reg  :}
inst: Store(regl,  cr, w:int) {: "mfcr " ^ regl :}

inst: Store(regl,                const16, 32) {: "addi " ^ regl ^",0,"^ const16 :}
inst: Store(Slice(16, 0, regl),  const16, 16) {: "addi "  ^ regl ^",0,"^ const16 :}
inst: Store(Slice(16, 16, regl), const16, 16) {: "addis " ^ regl ^","^ regl ^","^ const16 :}

inst: Store (regl, Fetch(Mem(addr    ),32), 32)     {: "lwz "   ^ regl ^","^ addr  :}
inst: Store (regl, Fetch(Mem(ndx_addr),32), 32)     {: "lwzx "  ^ regl ^","^ ndx_addr :}
inst: Store (regl, Zx(Fetch(Mem(addr),8)), 32)      {: "lbz "   ^ regl ^","^ addr  :}
inst: Store (regl, Zx(Fetch(Mem(ndx_addr),8)), 32)  {: "lbzx "  ^ regl ^","^ ndx_addr  :}
inst: Store (regl, Zx(Fetch(Mem(addr),16)), 32)     {: "lhz "   ^ regl ^","^ addr  :}
inst: Store (regl, Zx(Fetch(Mem(ndx_addr),16)), 32) {: "lhzx "  ^ regl ^","^ ndx_addr  :}
inst: Store (regl, Sx(Fetch(Mem(addr),8)), 32)      {: "lbz "   ^ regl ^","^ addr ^ "\n\t" ^
                                                       "extsb " ^ regl ^","^ regl :}
inst: Store (regl, Sx(Fetch(Mem(ndx_addr),8)), 32)  {: "lbzx "  ^ regl ^","^ ndx_addr ^ "\n\t" ^
                                                       "extsb " ^ regl ^","^ regl :}
inst: Store (regl, Sx(Fetch(Mem(addr),16)), 32)     {: "lha "   ^ regl ^","^ addr  :}
inst: Store (regl, Sx(Fetch(Mem(ndx_addr),16)), 32) {: "lhax "  ^ regl ^","^ ndx_addr  :}

inst: Store (Mem(addr    ), reg, 32)           {: "stw "  ^ reg ^","^ addr  :}   
inst: Store (Mem(ndx_addr), reg, 32)           {: "stwx " ^ reg ^","^ ndx_addr :}
inst: Store (Mem(addr    ), Lobits(reg, 8), 8) {: "stb "  ^ reg ^","^ addr  :}
inst: Store (Mem(ndx_addr), Lobits(reg, 8), 8) {: "stbx " ^ reg ^","^ ndx_addr  :}
inst: Store (Mem(addr    ), Lobits(reg,16),16) {: "sth "  ^ reg ^","^ addr  :}
inst: Store (Mem(ndx_addr), Lobits(reg,16),16) {: "sthx " ^ reg ^","^ ndx_addr  :}
@ 
\paragraph{Position-independent Code}
<<rules>>=
inst:  Store(regl, Add(reg,pic), 32)
       {: "addis " ^ regl ^ ","^ reg ^",ha16(" ^ pic ^ ")\n\t" ^
          "la "    ^ regl ^ ",lo16(" ^ pic ^ ")(" ^ regl ^ ")" :}

inst:  Store(regl, pic, 32)
       {: "li " ^ regl ^ ",ha16(" ^ pic ^ ")\n\t" ^
          "la " ^ regl ^ ",lo16(" ^ pic ^ ")(" ^ regl ^ ")" :}
@
\paragraph{Control Flow}
<<rules>>=
inst:  Goto(lconst) {: "b " ^ ind_addr lconst :}
inst:  Goto(lr)     {: "blr"                  :}
@
The [[cut to]] is supposed to look atomic, but it is a sequence of two
instructions. 
<<rules>>=
inst : Par(Goto(lr),Store(regl,reg,w:int)) {: sprintf "mr %s, %s; blr" regl reg :}
@
The [[next]] pattern covers the expression $PC + 4$ which denotes the
instruction following the branch instruction.
<<rules>>=
next:  Add(cia,const32) {: () :}
inst:  Par(Goto(lr    ), Store(lrl,next,32)) {: "blrl" :}
inst:  Par(Goto(lconst), Store(lrl,next,32)) {: "bl " ^ ind_addr lconst :}
@

Here are conditional branches. The {\rtl} operator names fit the {\mips}
assembly branch op-codes. We cannot inline the [[Cmp]] constructor
because the [[op]] terminal symbol would be unaccessible. Only top-level
terminals are in scope for the semantic action.

<<rules>>=
cmp:   Cmp(op:string, x:reg, y:reg) {: ("",  ppc_op op,x,y) :}
cmp:   Cmp(op:string, x:reg, y:const16) {: ("i", ppc_op op,x,y) :}
inst:  Guarded(cmp,Goto(lconst)) 
       {: match cmp with
          | (i_, (l_, op),x,y) -> "cmp" ^ l_ ^ "w" ^ i_ ^ " cr0," ^ x ^ "," ^
                                  y ^ "\n\tb" ^ op ^ " " ^ lconst
       :}
inst : Guarded(OvSet(Fetch(xerl,32)), Goto(lconst))
       {: "bo " ^ lconst :}
@ 
\paragraph{Instructions}
<<rules>>=

inst: Store(regl,  Add(x:reg, y:reg), 32)       {: sprintf "add  %s,%s,%s" regl x y :}
inst: Store(regl,  Add(x:reg, y:const16), 32)   {: sprintf "addi %s,%s,%s" regl x y :}

inst: Store(regl, Unop (opr:string, x:reg),           32) {: sprintf "%s  %s,%s"    opr regl x :}
inst: Store(regl, Binop(opr:string, x:reg,y:reg),     32) {: sprintf "%s  %s,%s,%s" opr regl x y :}
inst: Store(regl, Binop(opr:string, x:reg,y:const16), 32) {: sprintf "%si %s,%s,%s" opr regl x y :}
@
\paragraph{Support for debugging}
If an RTL should fail to match, one can uncomment the following rule
and get a printout of exactly how that RTL is represented using {\burg}
constructors. 
<<rules>>=
inst : any [100] {: "<" ^ any ^ ">" :}

any : True  () {: "True"  :}
any : False () {: "False" :}
any : Link(symbol, w:int) {: "Link(" ^ symbol#mangled_text ^ "," ^ string_of_int w ^ ")" :}
any : Diff(c1:any, c2:any) {: "Diff(" ^ c1 ^ ", " ^ c2 ^ ")" :}
any : Bits(bits)     {: sprintf "Bits(%s)" (Bits.to_string bits) :}

any : Fetch (any, w:int) {: "Fetch(" ^ any ^ "," ^ string_of_int w ^ ")" :}

any : Sx(any)           {: "Sx(" ^ any ^ ")"  :}
any : Zx(any)           {: "Zx(" ^ any ^ ")"  :}
any : Add(x:any, y:any) {: "Add(" ^ x ^ ", " ^ y ^ ")" :}

any : Unop (op:string, x:any)         {: op ^ " of " ^ x  :}
any : Binop(op:string, x:any, y:any)  {: op ^ " of " ^ x ^ "," ^ y  :}

any : Nop () {: "nop" :}

any : Lobits(any, w:int) {: "Lobits(" ^ any ^ ", " ^ string_of_int w ^ ")" :}
any : BitExtract(lsb:any, y:any, n:int) {: sprintf "BitExtract(%s, %s, %d)" lsb y n :}

any : Slice(w:int, n:int, y:any) {: sprintf "Slice(%d, %d, %s)" w n y :}

any : Mem(any) {: "Mem(" ^any ^ ")" :}
any : Reg(char, n:int) {: sprintf "Reg(%s, %d)" (Char.escaped char) n :}

any : Store (dst:any, src:any, w:int)
 {: "Store(" ^ dst ^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}
any : Kill(any) {: "Kill(" ^ any ^ ")" :}

any : Guarded(guard:any, any) {: "Guarded(" ^ guard ^ "," ^ any ^ ")" :}
any : Cmp(op:string, x:any, y:any)    
                        {: cat [ "Cmp(";op;",";x;",";y;")" ] :}
any : Par(l:any, r:any) {: "Par(" ^ l ^ "," ^ r ^ ")" :}
any : Goto(any) {: "Goto(" ^ any ^ ")" :}
@


% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

The code in this section walks an RTL and calls suitable \burg\
constructors. 
<<code to follow the labeler>>=  
let rec const = function
  | RP.Bool(true)             -> conTrue  ()
  | RP.Bool(false)            -> conFalse ()
  | RP.Link(s,_,w)            -> conLink s w
  | RP.Diff(c1,c2)            -> conDiff (const c1) (const c2)
  | RP.Late(s,w)              -> Impossible.impossible "Late constant in recognizer"
  | RP.Bits(b)                -> conBits(b)
@
<<code to follow the labeler>>=
let is_cmp (opr,ws) =
  let cmp = ["eq";"ge";"geu";"gt";"gtu";"le";"leu";"lt";"ltu";"ne"] in
  if not (List.mem opr cmp) then false
  else match ws with
    [32]  -> true
  | _     -> error "comparison not at 32 bits in PPC recognizer"

let rtl2ppc = function
    "and"  -> "and"
  | "divu" -> "divwu"
  | "mul"  -> "mullw"
  | "neg"  -> "neg"
  | "or"   -> "or"
  | "shl"  -> "slw"
  | "shrl" -> "srw"
  | "sub"  -> "sub"
  | "xor"  -> "xor"
  | opr    -> error (sprintf "Unsupported RTL operator \"%s\"" opr)

let rec exp = function
  | RP.Const(k)                  -> const (k)
  | RP.Fetch(l,w)                -> conFetch (loc l) w
  | RP.App(("sx", [8 ;32]), [x]) -> conSx (exp x)
  | RP.App(("sx", [16;32]), [x]) -> conSx (exp x)
  | RP.App(("zx", [8 ;32]), [x]) -> conZx (exp x)
  | RP.App(("zx", [16;32]), [x]) -> conZx (exp x)
  | RP.App(("add",[16]), [x; y]) -> conAdd  (exp x) (exp y)
  | RP.App(("add",[32]), [x; y]) -> conAdd  (exp x) (exp y)


  | RP.App(("ppc_xer_ov_set", []), [x])        -> conOvSet (exp x)
  | RP.App(("bitExtract", [_; n]), [lsb; src]) -> conBitExtract (exp lsb) (exp src) n

  | RP.App(("lobits", [32;w]), [x]) -> conLobits (exp x) w

  | RP.App((opr, ws), [x])          -> conUnop (rtl2ppc opr) (exp x)
  | RP.App((opr, ws), [x;y])        -> if is_cmp(opr,ws) then conCmp opr (exp x) (exp y)
                                       else conBinop (rtl2ppc opr) (exp x) (exp y)

  | RP.App((o,_),_) -> error (sprintf "unknown operator %s" o)
@ 
<<code to follow the labeler>>=  
and loc l = match l with
  | RP.Mem(('m',_,_), Rtl.C c, e, ass) -> conMem (exp e)
  | RP.Reg((sp, _,_), i, w)            -> conReg sp i 
  | RP.Mem(_, _, _, _)                 -> error "non-mem, non-reg cell"
  | RP.Var _ | RP.Global _             -> error "var found"
  | RP.Slice(w,i,l)                    -> conSlice w i (loc l)

and effect = function
  | RP.Store(RP.Reg(('c',_,_),i,_),r,_)
    when i = SS.indices.SS.pc          -> conGoto (exp r)
  | RP.Store(l,e,w)                    -> conStore (loc l) (exp e) w
  | RP.Kill(l)                         -> conKill (loc l)

and guarded g eff =
  match g with
  | RP.Const(RP.Bool b) -> if b then effect eff else conNop()
  | _                   -> conGuarded (exp g) (effect eff)

and geffects = function
    | []          -> conNop()
    | [g, s]      -> guarded g s
    | (g, s) :: t -> conPar (guarded g s) (geffects t)
and rtl (RP.Rtl es) = geffects es
@

\subsection{The exported recognizers}

The only tricky bits here are what we do when something goes wrong.
In a production compiler, we should always halt the compiler.
But here, it is more informative to drop an error message into the
assembly language and to allow the assembler to barf downstream.
<<code to follow the labeler>>=
let errmsg r msg =
  List.iter prerr_string
    [ "recognizer error: "; msg; " on "; RU.ToString.rtl r; "\n" ]

let to_asm r i =
  try
    let _ = imports := i in
    let plan = rtl (Down.rtl r) in
    plan.inst.Camlburg.action ()
  with 
  | Camlburg.Uncovered -> cat [" not an instruction: " ; RU.ToString.rtl r]
  | Error msg -> (errmsg r msg; " error in recognizer: " ^ msg)

let is_instruction r =
  try
    let plan = rtl (Down.rtl r) in
    plan.inst.Camlburg.cost < 100
  with
  | Camlburg.Uncovered -> false
  | Error msg -> (errmsg r msg; false)
@                        
