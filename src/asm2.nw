
\input{../config/macros.tex}

% l2h substitution dots ...
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Abstract Assembler Interface}
% ------------------------------------------------------------------ 

One way for the code generator to emit code is using an external
assembler.  In order to support as many target platforms as possible the
idiosyncrasies of individual assemblers and platforms are best hidden
behind a common interface.  This module defines such an interface by
exposing commonalities among assemblers and leaving the representation
of instructions abstract. We hope that the design is even general enough
to support emitting binary code directly. 

<<asm2.mli>>=
module type S = sig
    <<module type s>>
end
<<asm2.ml>>=
module type S = sig
    <<module type s>>
end
@

% ------------------------------------------------------------------ 
\subsection{Syntax for Names}
% ------------------------------------------------------------------ 

Each assembler has its own syntax for names. If a name in the source
language does not respect this syntax it must be \emph{mangled}
accordingly. An assembler provides a mangler function that is created by
passing a map of names to [[mangle]]. The map allows to specify an
initial mapping of certain names. Of course, the provider of the map is
responsible that the mapping respects the syntax of the assembler. See
module \module{mangle} for the details of name mangling.

<<module type s>>=
val mangle: string Strutil.Map.t -> (string -> string)
@

\begin{quote}\it
    In the current design of {\PAL} name mangling comnines two aspects:
    translation of {\PAL} names to assembly symbols, and translation of
    names such they respect an assemblers's syntax. We like to split
    these aspects and provide an assembler interface that allows any
    name to be used as a symbol. Mapping {\PAL} names to symbols would
    be left outside of the assembler.
\end{quote}

% ------------------------------------------------------------------ 
\subsection{Program Representation}
% ------------------------------------------------------------------ 

An assembly program is represented by an abstract type [[asm]].  It is
built by a sequence of [[action]]s, which are appended to an initially
empty assembly program.  The general assumption is, that an assembly
program is constructed in its natural order, from top to bottom. 

<<module type s>>=
type asm        
type action

val append: asm -> action -> asm
@

The type of [[append]] allows both a functional and an imperative
construction of an [[asm]] value. In a functional setting [[asm]] could
be some algebraic data type, in an imperative setting a file descriptor
that append uses to create output.

It may happen that an implementation does not implement this interface
completely. To signal unimplemented functionality, an implementation
should use the [[Unsupported]] exception.

<<module type s>>=
exception Unsupported of string
@

A program is created by an [[init]] function that receives an abstract
[[info]] value.

<<module type s>>=
type init
val init:           init -> asm
@

The [[nop]] action does nothing. 

<<functional>>=
val nop:            action
@

% ------------------------------------------------------------------ 
\subsection{Sections and Locations}
% ------------------------------------------------------------------ 

An assembler maintains named \emph{sections} and for each section a
\emph{location counter}.  The [[section]] action announces the start of
a new section.  An assembly program [[asm]] maintains a current section,
which can be observed.

<<module type s>>=
val section : section:string -> action
val current : asm -> string
@

The location counter of the current section can be manipulated: [[org]]
sets it to a value, [[align n]] aligns the location pointer to the next
largest multiple of [[n]], in case the current value of the location
pointer is not a multiple of [[n]].  Finally, [[addloc n]] increments
the value of the location pointer by [[n]].

<<module type s>>=
val org     : int -> action
val align   : int -> action
val addloc  : int -> action
@

Some assemblers also like procdures to be announced. The [[proc]] 
actions does this and receives some abstract [[proc_info]] value.

<<module type s>>=
type proc_info
val proc    : proc_info -> action
@

% ------------------------------------------------------------------ 
\subsection{Symbols and Addresses}
% ------------------------------------------------------------------ 

A [[symbol]] is an assembly-level name that binds a value.  This can be
an address, but also an integer value.  To support emitting binary code
directly, a symbol must be declared before it can be used. A
\emph{declaration} creates a symbol that is one of the following
disjoint kinds:

\begin{enumerate}
\item [[local]]:  the value of the symbol is defined exactly once
      inside the compilation unit (program) at hand and not visible
      outside of it.

\item [[import]]: the value of the symbol is defined in another
      compilation unit but made visible in the compilation unit at
      hand by an import declaration. No symbol exported from the
      module at hand can be imported.

\item [[export]]: the symbol is defined like a [[local]] symbol but
      additionally exported such that other compilation units can
      import it. No imported symbol can be exported.

\item [[common]]: several compilation units can define the same symbol
      as common. During the link process the different definitions are
      unified. This feature is currently not used.
\end{enumerate}      

The following four actions declare symbols for names and return them.
The symbol for a name is also registered in the assembler and can be
looked up. This allows the client to ignore the returned symbol.

<<module type s>>=
type symbol = 
    | Local    of string
    | Import   of string
    | Export   of string
    | Common   of string
@
 
<<module type s>>=
val import  : string -> asm -> symbol * asm
val export  : string -> asm -> symbol * asm
val local   : string -> asm -> symbol * asm
val common  : string -> size:int -> align:int -> section:string -> symbol * asm

val lookup  : string -> asm -> symbol   (* Not_found *)
@

A \emph{definition} binds a value to a symbol: [[define_label]] binds
the current location to a symbol, [[define_const]] a constant.

<<module type s>>=
val define_label    : symbol -> action  
val define_const    : symbol -> Bits.bits -> action
@

% ------------------------------------------------------------------ 
\subsection{Relocatable Addresses}
% ------------------------------------------------------------------ 

A link-time value is either a constant of the native pointer type, or a
simple expression of the native pointer type denoting a  relocatable
address.

<<module type s>>=
module RelAddr : sig 
    type t
    type sym = symbol 

    val sym:    sym -> t 
    val const:  Bits.bits -> t          (* native pointer size! *)
    val add:    t -> t  -> t
    val sub:    t -> t  -> t
end
@

% ------------------------------------------------------------------ 
\subsection{Emitting Values and Instructions}
% ------------------------------------------------------------------ 

The point of an assembly interface is to emit instructions.  Of course,
in order to be general the representation of an [[instruction]] is
hidden and left to an implementation.  The [[inst]] action emits an
instruction.

<<module type s>>=
type instruction
val instr           : instruction -> action
@

Instructions are one half of an assembly program, data is the other.
The following functions emit data:  [[zeroes n]] emits [[n]] zero values
of the target [[memsize]], [[link]] emits a link-time value, and
[[value]] emits a value.  The assembler takes care of the [[byteorder]]. 

<<module type s>>=
val zeroes          : int -> action
val value           : Bits.bits -> action
val addr            : RelAddr.t -> action
@

% ------------------------------------------------------------------ 
\subsection{Byteorder and Comments}
% ------------------------------------------------------------------ 

A target specific assembler takes the target's byteorder into account.
The [[byteorder]] value tells it.

<<module type s>>=
val byteorder       : Fenv.Clean.endianness
@

To emit a comment, use the [[comment]] action. A comment should
contain only printable characters and especially no newline character.

<<module type s>>=
val comment         : string -> action 
@
