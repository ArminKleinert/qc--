% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% Table of Contents
%
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later

This is more my idea of an elaborated representation.
<<exposed types>>=
type bits = Bits.bits
type exp  = Rtl.exp
type loc  = Rtl.loc (* optimism *)
type rtl  = Rtl.rtl
type name = string
type size = int
type hint = string
type index = int
type convention = string
type procname   = string
type label      = string

type oty = Ty of int  (* bits$n$ *)
type ty = Types.ty
@ 
Initialized and uninitialized data have the same type.
<<exposed types>>=
type init =
  | ExpData    of exp list
  | StringData of string

@ 
Here we have register variables (which double as formal parameters),
continuation parameters, actual parameters.
<<exposed types>>=
type runtime_access = Invisible | Invariant | Variant

type register = runtime_access * hint * ty * name (* ? *)
type cformal  = hint * name
type actual   = hint * exp
@ 
Flow annotations on calls and cut to.
<<exposed types>>=
type flow = {
    cuts_to : name list;
    unwinds_to : name list;
    returns_to : name list;
    aborts : bool;
    returns : bool;
  }

type cflow = {
    ccuts_to : name list;
    caborts : bool;
  }
@
Statements.  We push as close to RTLs as possible.
<<exposed types>>=
  (* N.B. Switch and prim not implemented *)
type stmt =
  | IfStmt     of exp * stmt list * stmt list
  | LabelStmt  of name
  | ContStmt   of name * cformal list
  | SpanStmt   of bits * exp * stmt list
  | AssignStmt of rtl
  | CallStmt   of loc list * convention * exp * actual list * procname list * flow
  | GotoStmt   of exp * label list
  | JumpStmt   of convention * exp * actual list * procname list
  | CutStmt    of exp * actual list * cflow 
  | ReturnStmt of convention * int * int * actual list
@ 
Procedures and sections in nice normal form.
<<exposed types>>=
type proc =
  { env : unit Fenv.Dirty.env';
    cc  : name;
    name : name;
    formals : (index * hint * Ast.variance * Types.ty * name) list;
    locals  : unit list;
    continuations : unit list;
    stackmem      : Block.t;
    stacklabels   : Rtl.exp list;
    code          : (Rtl.loc, Rtl.exp, Rtl.rtl) Nast.stmt list;
  } 

type datum =
  | Datalabel         of name
  | Align             of int
  | InitializedData   of (exp * ty) list
  | UninitializedData of int  (* counts the number of mems *)
  | Procedure         of proc

type spans = (bits * exp) list

type section = {
    sname : string;
    contents: (datum * spans) list;
  }
@ 
And last, the target and compilation unit.
<<exposed types>>=
type xtarget = {
  memsize : int;
  byteorder:      Rtl.aggregation   ; (* big/little endian, id *)
  wordsize:       int               ; (* bits *)
  pointersize:    int               ; (* bits *)
  floatrep : string;
  charset  : string;                 (*????*)
}
type target = Ofenv.Clean.target

type compunit = {
    target  : target;
    imports : name list;
    exports : name list;
    globals : register list;
    constants : (name * bits) list;     (* maybe unnecessary *)
    sections : section list;
  }
@ 
<<nelab.mli>>=
<<exposed types>>
@ 
% ------------------------------------------------------------------ 
\section{Checking Static Semantics}
% ------------------------------------------------------------------ 

To check the static semantics of a {\PAL} program the meaning of all
names used by it must be determined and their correct usage verified. 
The visibility of names in {\PAL} is controlled by name spaces and
scopes.  There are four name spaces:
\begin{enumerate}
\item Values (Procedures, Constants, Registers, Imports, \dots).
\item Types (names defined by [[typedef]]).
\item Primitive compile-time operators ([[%add]], \dots).
\item Primitive run-time operators; this a super set of the compile-time
      operators.
\end{enumerate}

Since operators are predefined they are visible everywhere and have no
further scoping rules.  On the other hand, names for values and types
are scoped:
\begin{enumerate}
\item The scope of the compilation unit is called \textit{global}. It
      includes the top-level and all sections. Labels at the statement
      level of procedures have additionally global scope.
%      
\item The scope of a procedure is called \textit{local}.  Values and types
      declared inside a procedure have local scope.  Entries in the
      local scope shadow entries in the global scope.
\end{enumerate} 

A name is visible inside its whole scope, even before its declaration.
Type declarations can refer to each other; compile-time computes
(constant) value declarations can refer to type declarations and each
other.  All run-time computed named values can only refer to type
declarations.  Before the static semantics of a scope can be checked
all names are resolved in a multi-step approach:
\begin{enumerate}
\item
Compute target metrics and create an empty fat environment
\item
Sort, evaluate, and bind type definitions
\item
Sort, evaluate, and bind constant definitions
\item
Bind each of the following declarations into the fat environment:
\begin{enumerate}
\item
Imported names
\item
Code labels
\item
Data labels, whether initialized data or stack data
\item
Procedures
\item
Continuations
\item
Register variables, including formal parameters
\end{enumerate}
\item
Check export declarations
\item
Elaborate expressions and assignments into RTL expressions and RTLs.
\item
Check other properties
\end{enumerate}

% ------------------------------------------------------------------ 
\subsection{Assembler Symbols}
% ------------------------------------------------------------------ 

Many names in a {\PAL} program correspond to assembler \emph{symbols}
after translation. For each name that corresponds later to a symbol the
denotation of that name includes its assembler symbol. Hence, this
module reserves assembler symbols for these names and enters them into
the fat environment.


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

@
The static semantics of a [[program]] is checked by [[Check.check]]. 
Any errors found are reported to stderr and the marked in the returned
environment.
<<nelab.mli>>=
@
    
% ------------------------------------------------------------------ 
\subsection{Implementation -- The 30\,000 feet overview}
% ------------------------------------------------------------------ 

<<nelab.ml>>=
<<exposed types>>
module A  = Ast
module B  = Bits
module E  = Error
module F  = Fenv.Dirty
module N  = Nast
module R  = Rtl
module RP = Rtl.Private
module Dn = Rtl.Dn
module Up = Rtl.Up
module T  = Types

let unimp = Impossible.unimp
let impossf fmt = Printf.kprintf Impossible.impossible fmt

<<nelab.ml>>=
<<auxiliaries>>
@ 
The key to understand the implementation is the fat environment
[[Fenv.Dirty]]; it defines a symbol table that holds the type, value, and
target environment.  Names are chosen similar to the non-terminals
used in the grammar.
@
An outlined in the introduction, an environment must be built up before
the static semantics can be checked. 
@
Because type and constant declarations can refer to each other they
can not be simply processed in source code order.  They are collected,
then sorted, and finally processed.  The sort function is provided by
the [[Topsort.Make]] functor, which is parameterized over the
declarations being sorted.  In the case of type declarations, for
example, module [[Typedef.Decl]] provides the necessary informations
about type declarations. 
@
<<xxxnelab.ml>>=
module Env = struct
    <<module Env>>
    let global (env:'a Ofenv.Dirty.env') (program:Ast.program) =
(*        let env = Pass1.global env program in *)
(*        let env = setDefaults env in  *)
        let env = Typedefs.bindTypeDefns env in 
        let env = Consts.bindConstants env in 
        let env = foldl (toplevel Srcmap.null) env program in
        env 

    let local env (_,_,ff,bb as proc) =
(*        let env = Pass1.local env bb in *)
        let env = Typedefs.bindTypeDefns env in
        let env = Consts.bindConstants env in
        let env = foldl (formal Srcmap.null)       env ff  in
        let env = foldl (body   Srcmap.null Local) env bb  in
        env
end
@
\paragraph{Check}. The [[Check]] module implements the check of the
static semantics with the help of the fat environment that was built
up using the peceding modules.
<<xxxnelab.ml>>=
module Check = struct
    <<module Check>>
end
@

@ 
% ------------------------------------------------------------------ 
\subsection{Auxiliaries}
% ------------------------------------------------------------------ 

The non-terminal symbol [[lvalue]] is used in different contexts that
we would like to distinguish: only in the [[Call]] context lvalues may
carry hints for calling conventions.
<<auxiliaries>>=
type context = Assign     (* x,y = y,x  *)
             | Call       (* x,y = f()  *)
             | PrimCall   (* x,y = %f() *)
@
Fold is the most frequently used higher order function in this module. 
We therefore like a short name.  Unlike its cousin
[[List.fold_right]], [[foldl]] is tail-recursive.
<<auxiliaries>>=
let foldl: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a = List.fold_left 
@
To remove offending declarations from a list we use [[--]]: 
[[xx -- yy]] returns those elements of [[xx]] not also [[yy]]. 
Since we expect [[yy]] to be very short (1 to 3 elements) we have
chosen a naive approach for implementation.  Efficiency is also less
of a concern because we are dealing with a program that has errors and
thus nobody expects us to be fast.
<<auxiliaries>>=
let (--) xx yy = List.filter (fun x  -> List.mem x yy) xx 
@
For error reports we need a source-code map to resolve character
positions into meaningful file, line, column triples.  The source map
can be obtained from the fat environment.  Here is a suitable error
reporting function for [[E.catch]]:
<<auxiliaries>>=
let error r env msg = E.errorRegionPrt (F.srcmap env,r) msg 
@
The static semantics of procedures are checked after everything
else has been checked. The following function returns the list of
procedures of a program.
<<auxiliaries>>=
let procedures ast = 
  let rec section acc = function
    | A.SectionAt(x,_)     -> section acc x
    | A.Decl(d)            -> acc
    | A.Datum( d)          -> acc
    | A.Procedure(p)       -> p::acc
    | A.SSpan( e1, e2, ss) -> List.fold_left section acc ss in   
  let rec toplevel acc = function
    | A.ToplevelAt(x, _)   -> toplevel acc x
    | A.Section(name, ss)  -> List.fold_left section acc ss
    | A.TopDecl(d)         -> acc
    | A.TopProcedure(p)    -> p::acc in
  List.fold_left toplevel [] ast
@    
The interface to [[Ofenv]] has changed and somtimes the old interface
was just more convenient. Here are some handy conversion functions.
<<auxiliaries>>=
let bindv name x y env = F.bindv name (x,y) env 
let bindt name x y env = F.bindt name (x,y) env 
let findv name     env = let (_,scope),entry = F.findv name env in scope,entry
let findt name     env = let (_,scope),entry = F.findt name env in scope,entry
@
Project a [[Rtl.exp]] value to a [[Bits.bits]] value.
<<auxiliaries>>=
let to_bits e = match Dn.exp e with
    | RP.Const (RP.Bits b) -> b
    | _                    -> impossf "expression deemed constant wasn't Bits"
@
% ------------------------------------------------------------------ 
\subsection{Sorting and binding type and constant declarations}
% ------------------------------------------------------------------ 

@
Here's the code to generically bind definitions that have to be
sorted.
Type~[[d]] is the declaration, which we have to be able to sort,
evaluate, and bind.
<<nelab.ml>>=
module type SB = sig
  type d
  module Decl : Topsort.Sortable with type decl = d N.marked
  val what : string
  type rhs
  val eval : 'a F.env' -> Decl.decl -> rhs E.error
  val bind : string -> rhs E.error N.marked -> 'a F.env' -> 'a F.env'
end
@ 
When a cycle is found in the list [[ds]] of declarations it is
removed and we sort and bind the remaining declarations.
Time is no object
because we have an illegal {\PAL} program.  When no cycle exists,
declarations are processed in topological order by [[bind_one]],
which enters them into [[env]].
<<nelab.ml>>=
module SortAndBind (D : SB) = struct
  module Sort = Topsort.Make (D.Decl)
  let bind_sortable_definitions env ds =
    <<definitions of sort-binding functions>>
    let rec bind env ds =
      try
        foldl bind_one env (Sort.sort ds)
      with Sort.Cycle offending ->
        let ds    = ds -- offending         in
        let env   = bind_to_error env offending in
        ( report_cycle env offending ; bind env ds ) in
    bind env ds
end
@
Because in general a definition binds multiple names, we bind them all.
<<definitions of sort-binding functions>>=
let bind_each_name rhs env ((r, _) as d) =
  foldl (fun env n -> D.bind n (r, rhs) env) env (D.Decl.defines d) in 
let bind_to_error env decls = 
  foldl (bind_each_name E.Error) (F.flagError env) decls in
@
<<definitions of sort-binding functions>>=
let rec bind_one env d =
  match D.eval env d with
  | E.Error       -> bind_each_name E.Error (F.flagError env) d
  | E.Ok _ as rhs -> bind_each_name rhs env d in
@
When cycles are found in the list of declarations they are reported.
Their source code positions were attached to them during their
collection. 
<<definitions of sort-binding functions>>=
let report_cycle env ds = 
  let report d =
    error (fst d) env
      (D.what ^ " definition for "^(List.hd (D.Decl.defines d))^" is cyclic") in
  List.iter report ds in
@
\subsubsection{Types}
Here's how we sort and bind type definitions.
<<nelab.ml>>=
module Type = struct
  type d = N.typedefn
  module Decl = struct
    type decl = N.typedefn N.marked
    let defines (_, (_,names)) = names
    let uses    (_, (t,_    )) =
      let rec u = function 
        | A.BitsTy _    -> []
        | A.TypeSynonym x   -> [x]
        | A.TyAt (t, _) -> u t in
      u t
  end
  let what = "type"
  type rhs = Types.ty
  let eval env (_, (t, _)) = Elabexp.elab_ty env t
  let bind = F.bindt
end
module TypeSortBind = SortAndBind(Type)
@
% ------------------------------------------------------------------ 
\subsubsection{Constants}
% ------------------------------------------------------------------ 

        EVENTUALLY, SUPPORT FOR CONSTANT EXPRESSIONS SHOULD MOVE INTO
        THE [[Elabexp]] MODULE.


A constant declaration must declare a value of type [[bits]]; although
it is syntactically and type-wise possible to declare a boolean value
this is not permitted. The optionally provided type must match the
actual type of the defining expression.
<<nelab.ml>>=
module Const = struct
  type d = Ast.expr N.constdefn
  <<utility functions for constants>>
  module Decl = struct
    type decl = d N.marked
    let defines (_, (t,name,expr)) = [name]
    let uses    (_, (t,name,expr)) = freeExprVars expr []
  end
  let what = "constant"
  type rhs = Bits.bits * Types.ty
  let eval env (r, (ty, name, e)) =
    let errorf x =
      Printf.kprintf (fun s -> E.errorRegionPrt (F.srcmap env, r) s; E.Error) x in
    E.seq (evalExpr env e) (fun (b, t) ->
      if t = Types.bool then errorf "constant has type bool but must have a bits type"
      else
        match ty with
        | None -> E.Ok (b, t)
        | Some ty ->
            E.seq (Elabexp.elab_ty env ty) (fun t' ->
              if t = t' then E.Ok (b, t)
              else errorf "constant %s declared with type %s has actual type %s"
                           name (Types.to_string t') (Types.to_string t)))
  let bind name (r, typed_exp) env = 
    F.bindv name (r, E.ematch typed_exp (fun (b, t) -> F.Constant b, t)) env
end
module ConstSortBind = SortAndBind(Const)
@ 
A constant expression can refer to other constant and link-time
constants.  To find the right topological order it is only important
to find other constants.  Of course, these can not be syntactically
distinguished and so we will collect all free variables of an
expression.  This leads to used names that are not constants and that
appear to be undefined from the perspective of the topological
[[sort]] function.  But [[sort]] assumes that these undeclared names
do not depend on any constant---which is correct. 

The [[freeExprVars]] function returns all names referenced in an
expression. A constant expression depends on all of them.
<<utility functions for constants>>=
let rec freeExprVars e tail = match e with
| A.ExprAt(x,_)     -> freeExprVars x tail
| A.Fetch(lvalue)   -> freeLValueVars lvalue tail
| A.BinOp(e1,_,e2)  -> freeExprVars e1 (freeExprVars e2 tail)
| A.UnOp(_,e)       -> freeExprVars e tail
| A.PrimOp(_,args)  -> foldl (fun t (_,e) -> freeExprVars e t) tail args
| A.Int _           -> tail
| A.Float _         -> tail
| A.Char _          -> tail
@ 
<<utility functions for constants>>=
and freeLValueVars l tail = match l with
| A.NameOrMemAt(x,r) -> freeLValueVars x tail
| A.Mem(_,e,_, _)    -> freeExprVars e tail
| A.Name(_,name)     -> if List.mem name tail then tail else name :: tail
@

% ------------------------------------------------------------------ 
\paragraph  {Evaluating constant declarations}
% ------------------------------------------------------------------ 

\begin{quote}\it
    Module [[Expcheck]] also provides code to check the static
    semantics of an expression and [[Simplify]] could be used to evaluate
    it. Why are we not using it here? --CL 

    Several reasons: We would need a translation from {\AST} to
    [[Rtl.env]]. The existing one in \module{ast3ir} is written against
    the [[Ofenv.Clean]] interface, but we need one written against the
    [[Ofenv.Dirty]] interface. The translation of an application needs
    the widths of its arguments. Therefore type-checking using
    [[Expcheck]] would be done twice: once before translation and then
    again during translation. Detailed error messages are simpler to
    generate with the existing approach. --CL
\end{quote}

Constant declarations must be sorted topologically before they can be
processed.  Processing includes checking their types and evaluating
their values.  Both type and value are bound in the environment.

Processing a constant declaration means to
\begin{enumerate}
\item infer its type and compare it to an optionally supplied type that
      is part of its declaration,
\item evaluate it,
\item bind the value and the type in the environment.
\end{enumerate}

The topological sorting guarantees that every named value a constant
declaration depends on, is already processed and the name is bound in
the environment.  However, we can still encounter undefined names
which are cought by [[F.findv]].  The following functions type check
and evaluate constants in a single step.  Each function returns a pair
of a type and a value. 

[[literalExpr]] must be outside the [[let rec]] because it is
polymorphic.
<<utility functions for constants>>=
let literalExpr env v ty cvt  =
    E.ematch ty
    ( function 
    | T.Bool            -> E.error "a named constant value must have type bitsXX"
    | T.Bits width as t -> (cvt v width, t) 
    )
@ 
<<utility functions for constants>>=
let rec evalFetch env = function
    | A.NameOrMemAt(x,r) -> E.catch (error r env) (evalFetch env) x
    | A.Mem (_,_,_,_)    -> E.error "memory access in const declaration"
    | A.Name(hint,id)  -> 
            ( match snd (F.findv id env) with
            | E.Error                  -> E.Error
            | E.Ok(F.Constant bits,ty) -> E.Ok(bits, ty)
            | _ -> E.error ("access of non-constant "^id^ " in constant expression")
            ) 
@
Applications to primitives operators must be type checked. Only if the
type check passes we apply the values to the implementation [[f]] of the
operator and get the result.  Both result and type are returned.
<<utility functions for constants>>=
and evalPrimOp env op args =
    E.ematch (E.Raise.list (List.map (evalExpr env) args))
    (fun args ->
        let v,t       = List.split args                 in
        let rt,opr    = Rtlop.Translate.operator op t   in
        let of_bits b = R.bits b (B.width b)            in
        let e         = Simplify.exp (Rtl.app opr (List.map of_bits v))    in
            ( match Dn.exp e with
            | RP.Const(RP.Bits b) -> b, rt
            | _     -> E.error ("not a compile-time operator: "^op)
            )
    )
@
The {\AST} contains literal values as strings. The reason is that the
width of a literal cannot be known when the literal is parsed. Here we
know the exact type and thus are able to parse the literal into a
[[Bits.bits]] value.
<<utility functions for constants>>=
and evalExprs env es = E.Raise.list (List.map (evalExpr env) es)
and evalExpr env =
  let wordTy env = E.Ok (Types.Bits (F.metrics env).Metrics.wordsize) in
  let ty = Elabexp.elab_ty in
  function
    | A.ExprAt(x,r)       -> E.catch (error r env) (evalExpr env) x
    | A.Int  (n  , Some t)-> literalExpr env n (ty     env t) B.U.of_string
    | A.Int  (n  , None)  -> literalExpr env n (wordTy env)   B.U.of_string
    | A.Float(n  , Some t)-> literalExpr env n (ty     env t) B.U.of_string
    | A.Float(n  , None)  -> literalExpr env n (wordTy env)   B.U.of_string
    | A.Char (n  , Some t)-> literalExpr env n (ty     env t) B.U.of_int
    | A.Char (n  , None)  -> literalExpr env n (E.Ok(T.bits 8)) B.U.of_int
    
    | A.Fetch  (v)        -> evalFetch env v
    | A.BinOp  (l,op,r)   -> evalPrimOp env op [l;r]
    | A.UnOp   (op,expr)  -> evalPrimOp env op [expr]
    | A.PrimOp (op,args)  -> evalPrimOp env op (List.map snd args)
@

% ------------------------------------------------------------------ 
\subsection{Building the environment}
% ------------------------------------------------------------------ 

We assume here the elaboration of expressions and lvalues.
Because of mutual recursion, we have to make two passes over procedures

In addition to being bound and checked,
imports and exports have two effects

<<nelab.ml>>=
type scope = Local | Global
let elab lvalue typed_expr srcmap asm ast =
  E.ematch (Metrics.of_ast srcmap ast.N.target) (fun metrics ->
    let flag = function E.Error -> F.flagError | E.Ok _ -> (fun env -> env) in
    let eprint r s = E.errorRegionPrt (srcmap, r) s in
    let errorf r   = Printf.kprintf (fun s -> eprint r s; E.Error) in
    let pointerty = Types.Bits metrics.Metrics.pointersize in
    let wordty    = Types.Bits metrics.Metrics.wordsize in
    let vfp       = Vfp.mk metrics.Metrics.wordsize in
    let memsize   = metrics.Metrics.memsize in
    <<definitions of name-binding functions>>
    <<definitions of elaboration functions>>
    let env = F.empty srcmap metrics asm in
    let env = TypeSortBind. bind_sortable_definitions env ast.N.udecls.N.types in
    let env = ConstSortBind.bind_sortable_definitions env ast.N.udecls.N.constants in
    let env = foldl bind_and_remember_import env ast.N.imports in
    let env = foldl remember_export          env ast.N.exports in
    let env = registers_from Global 0 ast.N.globals env in
    let env = foldl (foldl bind_code_label) env ast.N.code_labels in
    let env = foldl bind_section_names env ast.N.sections in
    let ss  = E.Raise.list (List.map (section env) ast.N.sections) in
    let env = flag ss env in
    let env = foldl check_export env ast.N.exports in
    env, ss)
@
In a procedure, labels have global scope, but they are bound a
second time in the local environment. This has the following advantages:
\begin{itemize}
\item The second binding clashes with any other local binding that
      might shadows the global binding.

\item A [[goto]] must have a local target. Now is is possible to test
      for this. 
\end{itemize}
<<definitions of procedure-processing functions>>=
let proc env p =
  let env = F.push env F.emptyscope in
  let env = TypeSortBind. bind_sortable_definitions env p.N.pdecls.N.types in
  let env = ConstSortBind.bind_sortable_definitions env p.N.pdecls.N.constants in
  let env, n, formals = formals_from 0 p.N.formals env in
  let env = registers_from Local n p.N.locals env in
  let env = foldl bind_code_label env p.N.labels in  (* odd -- explain *)
  let env = foldl bind_continuation env p.N.continuations in
  let stackmem, stacklabels, env = stackdata env p.N.stackdata in
  E.Ok (Procedure
  { env = env; cc = p.N.cc; name = p.N.name; formals = formals;
    locals = unimp "locals"; continuations = unimp "continuations";
    stackmem = stackmem; stacklabels = stacklabels; code = unimp "code"; }) in
@ 
A continuation knows its address (in the form of an empty, unaligned
block).
It also maintains some mutable data, filled in by [[Elabexp]] and
[[Elabstmt]], that tells if the continuation is used in an expression
or an annotation.
<<definitions of name-binding functions>>=
let bind_continuation env (r, name) =
  let addrblock =
    Block.relative vfp ("continuation " ^ name) Block.at ~size:0 ~alignment:1 in
  let k = { F.base = addrblock; F.escapes = false;
            F.cut_to = false; F.unwound_to = false; F.returned_to = false } in
  F.bindv name (r, E.Ok (F.Continuation k, pointerty)) env in
@ 
\subsubsection{Easy stuff}

\paragraph{Imports}
Imports have to be the native pointer size.
Code [[F.import]] remembers the [[import as]] relationship.
<<definitions of name-binding functions>>=
let bind_and_remember_import env (r, ty, imports) = 
  let import env (foreign,name) =
    let env = F.import r (Aux.Option.get name foreign) name env in
    let sym = F.symbol env name in
    let den = F.Import (Aux.Option.get name foreign, sym) in
    let ty  = <<convert optional importing [[ty]] as long as it is pointer size>> in
    F.bindv name (r, E.Raise.right (den, ty)) env in
  foldl import env imports in
<<convert optional importing [[ty]] as long as it is pointer size>>=
match ty with None -> E.Ok pointerty
| Some t -> E.seq (Elabexp.elab_ty env t) (fun t ->
    if t = pointerty then E.Ok pointerty
    else errorf r "imported type %s is inconsistent with native pointer type %s"
        (Types.to_string t) (Types.to_string pointerty))
@ 
\paragraph{Labels}
No checking for labels.  Just create the assembly-language symbol and
give it the native pointer type.
<<definitions of name-binding functions>>=
let bind_code_label env (r, n) = 
  F.bindv n (r, E.Ok (F.Label(F.Code (F.symbol env n)), pointerty)) env in
@ 
\subsubsection{Register variables and formal parameters}
<<definitions of name-binding functions>>=
let rec registers_from scope n rs env =
  let register env (rgn, (v,hint,t,name,hwreg)) k =
    let reg h = { F.index = n; F.rhint = h; F.loc = None; F.variance = v } in
    let den h = E.Ok (F.Variable (reg h)) in
    let den = match hint, hwreg with
    | Some _, Some _ -> errorf rgn "can't have hint and hardware register"
    | None,   Some r ->
        if scope = Local then errorf rgn "local register can't be mapped to hardware"
        else den (F.RReg r)
    | Some _, None   -> errorf rgn "hints permissible only on formal parameters" 
    | None,   None   -> den F.RNone in
    k (F.bindv name (rgn, E.Raise.pair (den, Elabexp.elab_ty env t)) env) in
  match rs with
  | [] -> env
  | r :: rs -> register env r (registers_from scope (n+1) rs) in
<<definitions of name-binding functions>>=
let formals_from n rs env =
  let rec formals prev' n rs env = match rs with
  | [] -> env, n, List.rev prev'
  | (r, (hint, inv, ty, name)) :: rs ->
      match Elabexp.elab_ty env ty with
      | E.Ok t ->
          let i = { F.index = n; F.variance = inv;
                    F.loc = None; F.rhint = F.RHint hint; } in
          let env = F.bindv name (r, E.Ok (F.Variable i, t)) env in
          formals ((n, hint, inv, t, name)::prev') (n+1) rs env
      | E.Error ->
          formals prev' n rs (F.bindv name (r, E.Error) env) in
  formals [] n rs env in
@ 
<<definitions of name-binding functions>>=
let bind_section_names env (secname, ds) = 
  <<definitions of name-binding functions for data>>
  foldl datum env ds in
<<definitions of elaboration functions>>=
let section env (secname, ds) =
  <<definitions of procedure-processing functions>>
  <<definitions of elaboration functions for data>>
  unimp "elaboration of section" in
@ 
\subsection{Translation of \texttt{stackdata} declarations, accumulating labels}

We process [[stackdata]] declarations to accumulate three results:
\begin{quote}
\begin{tabular}{ll}
[[mem]]& Memory layout for stack data\\
[[stacklabels']]& [[stackdata]] labels, reversed\\
[[env]]& Environment with bindings for stack labels\\
\end{tabular}
\end{quote}
@ 
The traversal is straightforward and needs little documentation.
<<definitions of name-binding functions>>=
let stackdata env =
  <<definitions of stack-data functions>> in
  stackdata (Memalloc.relative vfp "stackdata" Memalloc.Up) [] env in
@ 
<<definitions of stack-data functions>>=
let rec stackdata mem stacklabels' env ds = match ds with
| [] -> Memalloc.freeze mem, List.rev stacklabels', env
| d :: ds ->
    stackdatum mem stacklabels' env d
      (fun mem stacklabels' env -> stackdata mem stacklabels' env ds) 
@ 
Any error flags the environment and continues.
We don't really care if [[mem]] or [[stacklabels']] becomes bad in that case.

A [[stackdatum]] declaration must respect some constraints:  (1)~no
initialized data, (2)~no [[[]]] used as a size, (3)~an
alignment must be a power of two. 
<<definitions of stack-data functions>>=
and stackdatum mem stacklabels' env (r, d) k =
  let errorf fmt = Printf.kprintf
      (fun s -> eprint r s; k mem stacklabels' (F.flagError env)) fmt in
  match d with
  | N.Datalabel l ->
      let loc = Memalloc.current mem in
      let env = F.bindv l (r, E.Ok (F.Label (F.Stack loc), pointerty)) env in
      k mem (loc :: stacklabels') env
  | N.Align n when is2power n ->
      k (Memalloc.align mem n) stacklabels' env
  | N.Align n -> errorf "alignment %d is not a power of 2" n
  | N.ReserveMem(ty,size,Some _) -> errorf "initialization not permitted for stackdata"
  | N.ReserveMem(ty,A.DynSize,_) -> errorf "illegal size for stackdata"
  | N.ReserveMem(ty,size,None) ->
      unimp "memdecl check";
      (match Elabexp.elab_ty env ty with
      | E.Error -> k mem stacklabels' env
      | E.Ok Types.Bool -> impossf "boolean type in abstract syntax"
      | E.Ok (Types.Bits w) ->
          let finish size =
            if w mod memsize = 0 then
              k (Memalloc.allocate mem (size * (w / memsize))) stacklabels' env
            else
              errorf "width %d of initialized data is not a multiple of memsize %d"
                w memsize in
          match size with 
          | A.NoSize    -> finish 1 
          | A.DynSize   -> impossf "dynamic memory size"
          | A.FixSize e ->
              match Const.evalExpr env e with
              | E.Ok (bits, _) -> finish (Bits.U.to_int bits)
              | E.Error        -> k mem stacklabels' (F.flagError env)
      )
  | N.Procedure _ -> impossf "nested procedures"
  | N.SSpan (_, _, _) -> impossf "span in stackdata"
@
\paragraph{Export checking}

Not all named values can be exported: registers, continuations, and
stack labels are values that can't be exported. Export declarations
optionally can specify the type of declared symbols. Such a type must
match the actual type of an exported symbol.
<<definitions of name-binding functions>>=
let remember_export env (r, _, exports) = 
  let export env (name,foreign) =
    F.export r name (Aux.Option.get name foreign) env in
  foldl export env exports in
@ 
The only thing that can happen to the environment here is that it gets
flagged with an error.
<<definitions of name-binding functions>>=
let check_export env (r, ty, pairs) = 
  let errorf fmt = Printf.kprintf (fun s -> eprint r s; F.flagError env) fmt in
  let check_pair env (name, foreign) =
    E.seq' env (snd (F.findv name env)) (fun (den, ty) ->
      if ty <> pointerty then
        errorf "exported value must have native pointer type"
      else
        match den with
        | F.Label (F.Proc _ | F.Code _ | F.Data _) -> env
        | _ -> errorf "%s can't be exported" name) in
  let env = match ty with
  | Some t ->
      E.seq' env (Elabexp.elab_ty env t) (fun ty ->
        if ty <> pointerty then
          errorf "exported value must have native pointer type"
        else
          env)
  | None -> env in
  foldl check_pair env pairs in
@

\subsubsection{Initialized data and other sectionish things}

Top-level data are more complicated than stackdata.

Any error flags the environment and continues.
The only environment operation for a toplevel datum is to bind labels.
The rest should be drawn from ast2ir.
<<definitions of name-binding functions for data>>=
let datum env (r, d) =
  let errorf fmt = Printf.kprintf (fun s -> eprint r s; F.flagError env) fmt in
  match d with
  | N.Datalabel l ->
      F.bindv l (r, E.Ok (F.Label (F.Data (F.symbol env l)), pointerty)) env
  | N.Align n when is2power n -> env
  | N.Align n -> errorf "alignment %d is not a power of 2" n
  | N.ReserveMem(ty,size,init) -> env
  | N.Procedure p ->
      let den = F.Label (F.Proc (F.symbol env p.N.name)) in
      F.bindv p.N.name (r, E.Ok (den, pointerty)) env
  | N.SSpan (_, _, _) -> unimp "section span" in
@ 
<<definitions of elaboration functions for data>>=
let rec data prev' ds = match ds with
| [] -> List.rev prev'
| (r, d) :: ds ->
    let finish x = data (x::prev') ds in
    match d with
    | N.Datalabel l -> finish (E.Ok (Datalabel l))
    | N.Align n     -> finish (E.Ok (Align n))      (* checked earlier *)
    | N.Procedure p -> finish (proc env p)
    | N.ReserveMem(ty,size,init) -> finish (reserve_mem r ty size init)
    | N.SSpan (_, _, _) -> unimp "section span" 
@
A memory declaration has a type, a type, and optionally a number of
expressions to initialize the memory.  The number of expressions must
match the size specification, and the type of the expressions must
match the declared type.
<<definitions of elaboration functions for data>>=
and reserve_mem r ty size idata =
    E.seq2 (Elabexp.elab_ty env ty) (init_size r size) (fun ty n ->
      match idata with
      | None ->
          (match ty with
          | Types.Bits w when w mod memsize = 0 ->
              E.Ok (UninitializedData (Aux.Option.get 1 n * (w / memsize)))
          | Types.Bits w ->
              errorf r "width %d of initialized data is not a multiple of memsize = %d"
                w memsize
          | Types.Bool -> Impossible.impossible "boolean type from ast")
      | Some i ->
          E.seq (init r ty i) (fun inits ->
            let rcount = List.length inits in
            let lcount = Aux.Option.get rcount n in
            if      rcount > lcount then errorf r "too many initial values"
            else if rcount < rcount then errorf r "too few initial values"
            else E.Ok (InitializedData inits)))
@
The [[init_size]] function returns the number of objects to reserve
memory for. Any given number must be nonnegative.
<<definitions of elaboration functions for data>>=
and init_size r = function
  | A.DynSize   -> E.Ok (None)
  | A.NoSize    -> E.Ok (Some 1)
  | A.FixSize e ->
      E.seq (Const.evalExpr env e) (fun (bits, ty) -> 
        match ty with
        | Types.Bits _ ->
            (try
              let size = Bits.S.to_int bits in
              if size >= 0 then E.Ok (Some size)
              else errorf r "negative count for initialized data"
            with Bits.Overflow -> errorf r "overflow computing size")
        | _ -> errorf r "Boolean count for initialized data")
@    
All initial values for a memory declaration must match the declared
type [[t]] of the memory declaration. The [[init]] function checks for
this and returns the number of initial expressions.
<<definitions of elaboration functions for data>>=
and init r ty i = 
  match i with
  | A.InitAt (x,r) -> E.catch (error r env) (init r ty) x
  | A.InitExprs(es)  ->
      E.seq (E.Raise.list (List.map (typed_expr env) es)) (fun tes ->
        if List.for_all (fun (e, t) -> t = ty) tes then
          E.Ok tes
        else
          errorf r "typeof an initial value does not match declared type")
  | A.InitStr s ->
      let to_texpr c = R.bits (Bits.U.of_int (Char.code c) 8) 8, ty in
      if ty = T.Bits 8 then
        E.Ok (Aux.String.foldr (fun c l -> to_texpr c :: l) s [])
      else
        errorf r "initialized string must specify type bits8"
  | A.InitUStr(s) ->
      if ty = T.Bits 16 then
        unimp "Unicode"
      else
        errorf r "initialized Unicode string must specify type bits16" in
@ 
================================================================

NEXT: HANDLE CONTINUATIONS BY GIVING EACH ONE A PAIR CONSISTING OF A
FRESH, UNBOUND, EMPTY BLOCK AND A MUTABLE BOOLEAN INDICATING WHETHER
THE CONTINUATION ESCAPES (HAS A DYNAMIC VALUE).

@
A procedure opens a local scope:  the procedure's parameters and all
local [[typedef]], [[const]], [[continuation]] belong to the local
scope.  When collecting the global values only the procedure's name is
bound in the environment and the [[goto]] labels in its body.
@

% ------------------------------------------------------------------ 
\subsection{Checking the static semantics}
% ------------------------------------------------------------------ 

After all global names for types and values are bound in the fat
environment the static semantics can be checked.  This essentially
means to walk over the abstract syntax and check all the constraints
defined by the static semantics.  In case of an error we like to
report it but continue to check the rest of a program.  
<<module Check>>=
<<Check auxiliaries>>
<<type check expression>>
<<check>>
@
Alignments must be a power of two.  This predicates is true, iff its
argument is a positive power of two.
<<auxiliaries>>=
let is2power x = x > 0 && x land (x - 1) = 0
@

% ------------------------------------------------------------------ 
\subsubsection{Expression types}
% ------------------------------------------------------------------ 

We use the generic functionality of module [[Expcheck]] for checking
the static semantics of expressions. 
<<type check expression>>=
let tyExpr env e =
  let typed_expr, _ = Expcheck.exprfuns (fun _ -> Rtl.late "continuation?!" 99) env in
  E.ematch (typed_expr e) snd
@
% ------------------------------------------------------------------ 
\subsubsection{Checking the static semantics}
% ------------------------------------------------------------------ 

Checking the static semantics really starts here.  We traverse the
abstract syntax and check all the constraints.  The result of checking
the static semantics is an environment; in case error are found by the
check they are manifest in the returned environment.  So every
function that takes part in checking the static semantics receives and
returns an environment.

THERE IS AN IMPORTANT PIECE MISSING HERE: THE CONTROL-FLOW
RESTRICTIONS ARE NOT CHECKED.  IT WILL BE NECESSARY TO EXTEND THE
ENVIRONMENT SO THAT WHEN A STATEMENT IS CHECKED, THE CHECKER KNOWS
WHETHER CONTROL CAN FALL THROUGH TO THAT STATEMENT.
IF THE ANSWER IS YES, THE STATEMENT HAD BETTER NOT BE A CONTINUATION.
SIMILARLY, IT HAD BETTER NOT BE THE END OF THE PROCEDURE BODY EITHER.

To evaluate constant expressions we use the code from [[Const.Eval]];
the returned value has type [[(Types.ty * F.value) E.error]]
<<check>>=
let constExpr env e = Consts.evalExpr env e
@
The type of range-expressions in a [[switch]] statement must match the
type [[t]] of the [[switch]] expression.  The parameter [[t]] is in
the [[E.error]] domain and thus function from the [[E]] module are
used for access. 
<<check>>=
and range t env r =
    let msg1 = "Range type does not match expression type" in
    E.seq' (F.flagError env) t
    ( fun t -> match r with
    | A.Point(e) -> 
        E.seq' (F.flagError env) (constExpr env e)
        ( function
        | (t',v) when t=t'   -> env
        | otherwise          -> E.error msg1
        )

    | A.Range(e1,e2) -> 
        let e1e2 = E.Raise.pair (constExpr env e1, constExpr env e2) in
        E.seq' (F.flagError env) e1e2
        ( function 
        | (t1,v1), (t2,v2) 
           when t1=t && t2=t -> env
        | otherwise          -> E.error msg1
        )
    )
@
All ranges that guard a [[switch]] arm must match the type of the
[[switch]]-expression
<<check>>=
and arm t env = function
    | A.ArmAt(x,r)   -> E.catch' (F.flagError env) (error r env) (arm t env) x
    | A.Case(rr, ss) ->
        let env = foldl body env ss              in 
        let env = foldl (range t) env rr         in 
            ( match rr with 
            | [] -> E.error "must specify range for this arm"
            | _  -> env
            )
@
A top level [[span]] contains [[section]]s but otherwise behaves like a
[[span]] statement: the two expressions [[e1]] and [[e2]] must denote a
word and a (data) pointer. The latter must be also a link-time constant
which is currently \emph{not} checked.
<<check>>=
and topSpan r env (e1,e2,ss) =
    let msg1 = "span token must be a constant word" in
    let msg2 = "span value must be a data pointer " in
    let env  = foldl (section r) env ss                 in
        E.seq' env (Error.Raise.quad ( constExpr env e1
                                     , tyExpr env e2
                                     , wordTy env
                                     , pointerTy env
                                     ))
        ( function
        | (t1,v1), _ ,w, p when t1 <> w -> E.error msg1
        | _      , t2,w, p when t2 <> p -> E.error msg2
        | _                        -> env
        )
@
A procedure opens a new scope which contains additional local names.
The [[Env.local]] functions computes this environment which is used by
the functions that check the body of a procedure. Errors recorded in
the local environment must be copied to the global environment.

A procedure numbers its local parameters and registers starting from~0.
We must save the actual value of [[F.getIndex]] and set it later
such that the global counter for indexing registers is maintained
across procedures.
\begin{quote}\it
    Can't this be tied to opening a new scope? Looks like a
    historic legancy from the time when we had no first-class scopes.
    --CL 
\end{quote}

The local environment for the procedure is bound in the fat
environment such that it can be re-used later.  This function updates
the existing entry for the procedure in the fat environment. 
<<check>>=
and proc r env (_,name,_,bb as p) =
    let env   = F.push env F.emptyscope  (* open new scope *)   in 
    let env   = Env.local env p                                 in
    let env   = foldl body env bb (* traverse body *)           in
    let index = F.getIndex env                                  in
    let scope = F.top env                                       in
    let env   = F.pop env                                       in
    let r,x   = try F.findv name env (* lookup this proc *)  
                with Not_found -> assert false                  in
    let entry = E.ematch x
               ( function
               | (F.Label(F.Proc(sym,None,_)),t) -> (* update denotation *)
                    F.Label(F.Proc(sym,Some scope,index)),t
               | _ -> assert false
               )                                            
    in
        F.rebindv name (r,entry) env (* update proc entry *)
@
