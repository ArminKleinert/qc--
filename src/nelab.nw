% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% Table of Contents
%
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later

This is more my idea of an elaborated representation.
<<exposed types>>=
type bits = Bits.bits
type exp  = Rtl.exp
type loc  = Rtl.loc (* optimism *)
type rtl  = Rtl.rtl
type name = string
type size = int
type hint = string
type convention = string
type procname   = string
type label      = string

type ty = Ty of int  (* bits$n$ *)
@ 
Initialized and uninitialized data have the same type.
<<exposed types>>=
type init =
  | ExpData    of exp list
  | StringData of string

type datum =
  | Datalabel of name
  | Align of int
  | ReserveMem of ty * size * init option  (* init always none on stackdata *)

@ 
Here we have register variables (which double as formal parameters),
continuation parameters, actual parameters.
<<exposed types>>=
type runtime_access = Invisible | Invariant | Variant

type register = runtime_access * hint * ty * name (* ? *)
type cformal  = hint * name
type actual   = hint * exp
@ 
Flow annotations on calls and cut to.
<<exposed types>>=
type flow = {
    cuts_to : name list;
    unwinds_to : name list;
    returns_to : name list;
    aborts : bool;
    returns : bool;
  }

type cflow = {
    ccuts_to : name list;
    caborts : bool;
  }
@
Statements.  We push as close to RTLs as possible.
<<exposed types>>=
  (* N.B. Switch and prim not implemented *)
type stmt =
  | IfStmt     of exp * stmt list * stmt list
  | LabelStmt  of name
  | ContStmt   of name * cformal list
  | SpanStmt   of bits * exp * stmt list
  | AssignStmt of rtl
  | CallStmt   of loc list * convention * exp * actual list * procname list * flow
  | GotoStmt   of exp * label list
  | JumpStmt   of convention * exp * actual list * procname list
  | CutStmt    of exp * actual list * cflow 
  | ReturnStmt of convention * int * int * actual list
@ 
Procedures and sections in nice normal form.
<<exposed types>>=
type proc = {
    formals : register list;
    vars : register list;
    stackdata : datum list;
    code : stmt list;
  }

type content =
  | Datum of datum
  | Procedure of proc

type spans = (bits * exp) list

type section = {
    sname : string;
    contents: (content * spans) list;
  }
@ 
And last, the target and compilation unit.
<<exposed types>>=
type xtarget = {
  memsize : int;
  byteorder:      Rtl.aggregation   ; (* big/little endian, id *)
  wordsize:       int               ; (* bits *)
  pointersize:    int               ; (* bits *)
  floatrep : string;
  charset  : string;                 (*????*)
}
type target = Ofenv.Clean.target

type compunit = {
    target  : target;
    imports : name list;
    exports : name list;
    globals : register list;
    constants : (name * bits) list;     (* maybe unnecessary *)
    sections : section list;
  }
@ 
<<nelab.mli>>=
<<exposed types>>
@ 
<<nelab.ml>>=
<<exposed types>>
@ 
% ------------------------------------------------------------------ 
\section{Checking Static Semantics}
% ------------------------------------------------------------------ 

To check the static semantics of a {\PAL} program the meaning of all
names used by it must be determined and their correct usage verified. 
The visibility of names in {\PAL} is controlled by name spaces and
scopes.  There are four name spaces:
\begin{enumerate}
\item Values (Procedures, Constants, Registers, Imports, \dots).
\item Types (names defined by [[typedef]]).
\item Primitive compile-time operators ([[%add]], \dots).
\item Primitive run-time operators; this a super set of the compile-time
      operators.
\end{enumerate}

Since operators are predefined they are visible everywhere and have no
further scoping rules.  On the other hand, names for values and types
are scoped:
\begin{enumerate}
\item The scope of the compilation unit is called \textit{global}. It
      includes the top-level and all sections. Labels at the statement
      level of procedures have additionally global scope.
%      
\item The scope of a procedure is called \textit{local}.  Values and types
      declared inside a procedure have local scope.  Entries in the
      local scope shadow entries in the global scope.
\end{enumerate} 

A name is visible inside its whole scope, even before its declaration.
Type declarations can refer to each other; compile-time computes
(constant) value declarations can refer to type declarations and each
other.  All run-time computed named values can only refer to type
declarations.  Before the static semantics of a scope can be checked
all names are resolved in a multi-step approach:
\begin{enumerate}
\item
Compute target metrics and create an empty fat environment
\item
Sort, evaluate, and bind type definitions
\item
Sort, evaluate, and bind constant definitions
\item
Bind each of the following declarations into the fat environment:
\begin{enumerate}
\item
Imported names
\item
Code labels
\item
Data labels, whether initialized data or stack data
\item
Procedures
\item
Continuations
\item
Register variables, including formal parameters
\end{enumerate}
\item
Check export declarations
\item
Elaborate expressions and assignments into RTL expressions and RTLs.
\item
Check other properties
\end{enumerate}

% ------------------------------------------------------------------ 
\subsection{Assembler Symbols}
% ------------------------------------------------------------------ 

Many names in a {\PAL} program correspond to assembler \emph{symbols}
after translation. For each name that corresponds later to a symbol the
denotation of that name includes its assembler symbol. Hence, this
module reserves assembler symbols for these names and enters them into
the fat environment.


% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

@
The static semantics of a [[program]] is checked by [[Check.check]]. 
Any errors found are reported to stderr and the marked in the returned
environment.
<<nelab.mli>>=
@
    
% ------------------------------------------------------------------ 
\subsection{Implementation -- The 30\,000 feet overview}
% ------------------------------------------------------------------ 

<<nelab.ml>>=
module A  = Ast
module B  = Bits
module E  = Error
module F  = Fenv.Dirty
module N  = Nast
module R  = Rtl
module RP = Rtl.Private
module Dn = Rtl.Dn
module Up = Rtl.Up
module T  = Types

let unimp = Impossible.unimp

<<nelab.ml>>=
<<auxiliaries>>
@ 
The key to understand the implementation is the fat environment
[[Fenv.Dirty]]; it defines a symbol table that holds the type, value, and
target environment.  Names are chosen similar to the non-terminals
used in the grammar.
@
An outlined in the introduction, an environment must be built up before
the static semantics can be checked. 
@
Because type and constant declarations can refer to each other they
can not be simply processed in source code order.  They are collected,
then sorted, and finally processed.  The sort function is provided by
the [[Topsort.Make]] functor, which is parameterized over the
declarations being sorted.  In the case of type declarations, for
example, module [[Typedef.Decl]] provides the necessary informations
about type declarations. 
@
<<xxxnelab.ml>>=
module Env = struct
    <<module Env>>
    let global (env:'a Ofenv.Dirty.env') (program:Ast.program) =
(*        let env = Pass1.global env program in *)
(*        let env = setDefaults env in  *)
        let env = Typedefs.bindTypeDefns env in 
        let env = Consts.bindConstants env in 
        let env = foldl (toplevel Srcmap.null) env program in
        env 

    let local env (_,_,ff,bb as proc) =
(*        let env = Pass1.local env bb in *)
        let env = Typedefs.bindTypeDefns env in
        let env = Consts.bindConstants env in
        let env = foldl (formal Srcmap.null)       env ff  in
        let env = foldl (body   Srcmap.null Local) env bb  in
        env
end
@
\paragraph{Check}. The [[Check]] module implements the check of the
static semantics with the help of the fat environment that was built
up using the peceding modules.
<<xxxnelab.ml>>=
module Check = struct
    <<module Check>>
end
@

@ 
% ------------------------------------------------------------------ 
\subsection{Auxiliaries}
% ------------------------------------------------------------------ 

The non-terminal symbol [[lvalue]] is used in different contexts that
we would like to distinguish: only in the [[Call]] context lvalues may
carry hints for calling conventions.
<<auxiliaries>>=
type context = Assign     (* x,y = y,x  *)
             | Call       (* x,y = f()  *)
             | PrimCall   (* x,y = %f() *)
@
Fold is the most frequently used higher order function in this module. 
We therefore like a short name.  Unlike its cousin
[[List.fold_right]], [[foldl]] is tail-recursive.
<<auxiliaries>>=
let foldl: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a = List.fold_left 
@
To remove offending declarations from a list we use [[--]]: 
[[xx -- yy]] returns those elements of [[xx]] not also [[yy]]. 
Since we expect [[yy]] to be very short (1 to 3 elements) we have
chosen a naive approach for implementation.  Efficiency is also less
of a concern because we are dealing with a program that has errors and
thus nobody expects us to be fast.
<<auxiliaries>>=
let (--) xx yy = List.filter (fun x  -> List.mem x yy) xx 
@
For error reports we need a source-code map to resolve character
positions into meaningful file, line, column triples.  The source map
can be obtained from the fat environment.  Here is a suitable error
reporting function for [[E.catch]]:
<<auxiliaries>>=
let error r env msg = E.errorRegionPrt (F.srcmap env,r) msg 
@
Types in the abstract syntax may be names and must be evaluated before
they can be used.  The evaluation can fail in case the name is
undefined and therefore an [[E.error]] type is used.
<<auxiliaries>>=
let rec evalTy env = function
    | A.TyAt(x,r)    -> E.catch (error r env) (evalTy env) x
    | A.BitsTy(size) -> E.Ok(Types.Bits size)
    | A.TypeSynonym(n) -> snd (F.findt n env)
@
The static semantics of procedures are checked after everything
else has been checked. The following function returns the list of
procedures of a program.
<<auxiliaries>>=
let procedures ast = 
  let rec section acc = function
    | A.SectionAt(x,_)     -> section acc x
    | A.Decl(d)            -> acc
    | A.Datum( d)          -> acc
    | A.Procedure(p)       -> p::acc
    | A.SSpan( e1, e2, ss) -> List.fold_left section acc ss in   
  let rec toplevel acc = function
    | A.ToplevelAt(x, _)   -> toplevel acc x
    | A.Section(name, ss)  -> List.fold_left section acc ss
    | A.TopDecl(d)         -> acc
    | A.TopProcedure(p)    -> p::acc in
  List.fold_left toplevel [] ast
@    
The interface to [[Ofenv]] has changed and somtimes the old interface
was just more convenient. Here are some handy conversion functions.
<<auxiliaries>>=
let bindv name x y env = F.bindv name (x,y) env 
let bindt name x y env = F.bindt name (x,y) env 
let findv name     env = let (_,scope),entry = F.findv name env in scope,entry
let findt name     env = let (_,scope),entry = F.findt name env in scope,entry
@
Project a [[Rtl.exp]] value to a [[Bits.bits]] value.
<<auxiliaries>>=
let to_bits e = match Dn.exp e with
    | RP.Const (RP.Bits b) -> b
    | _                    -> assert false 
@
% ------------------------------------------------------------------ 
\subsection{Sorting and binding type and constant declarations}
% ------------------------------------------------------------------ 

@
Here's the code to generically bind definitions that have to be
sorted.
Type~[[d]] is the declaration, which we have to be able to sort,
evaluate, and bind.
<<nelab.ml>>=
module type SB = sig
  type d
  module Decl : Topsort.Sortable with type decl = d N.marked
  val what : string
  type rhs
  val eval : 'a F.env' -> Decl.decl -> rhs E.error
  val bind : string -> rhs E.error N.marked -> 'a F.env' -> 'a F.env'
end
@ 
When a cycle is found in the list [[ds]] of declarations it is
removed and we sort and bind the remaining declarations.
Time is no object
because we have an illegal {\PAL} program.  When no cycle exists,
declarations are processed in topological order by [[bind_one]],
which enters them into [[env]].
<<nelab.ml>>=
module SortAndBind (D : SB) = struct
  module Sort = Topsort.Make (D.Decl)
  let bind_sortable_definitions env ds =
    <<definitions of sort-binding functions>>
    let rec bind env ds =
      try
        foldl bind_one env (Sort.sort ds)
      with Sort.Cycle offending ->
        let ds    = ds -- offending         in
        let env   = bind_to_error env offending in
        ( report_cycle env offending ; bind env ds ) in
    bind env ds
end
@
Because in general a definition binds multiple names, we bind them all.
<<definitions of sort-binding functions>>=
let bind_each_name rhs env ((r, _) as d) =
  foldl (fun env n -> D.bind n (r, rhs) env) env (D.Decl.defines d) in 
let bind_to_error env decls = 
  foldl (bind_each_name E.Error) (F.flagError env) decls in
@
<<definitions of sort-binding functions>>=
let rec bind_one env d =
  match D.eval env d with
  | E.Error       -> bind_each_name E.Error (F.flagError env) d
  | E.Ok _ as rhs -> bind_each_name rhs env d in
@
When cycles are found in the list of declarations they are reported.
Their source code positions were attached to them during their
collection. 
<<definitions of sort-binding functions>>=
let report_cycle env ds = 
  let report d =
    error (fst d) env
      (D.what ^ " definition for "^(List.hd (D.Decl.defines d))^" is cyclic") in
  List.iter report ds in
@
\subsubsection{Types}
Here's how we sort and bind type definitions.
<<nelab.ml>>=
module Type = struct
  type d = N.typedefn
  module Decl = struct
    type decl = N.typedefn N.marked
    let defines (_, (_,names)) = names
    let uses    (_, (t,_    )) =
      let rec u = function 
        | A.BitsTy _    -> []
        | A.TypeSynonym x   -> [x]
        | A.TyAt (t, _) -> u t in
      u t
  end
  let what = "type"
  type rhs = Types.ty
  let rec evalTy env = function
    | A.TyAt(x,r)    -> E.catch (error r env) (evalTy env) x
    | A.BitsTy(size) -> E.Ok(Types.Bits size)
    | A.TypeSynonym(n)   -> snd (F.findt n env)
  let eval env (_, (t, _)) = evalTy env t
  let bind = F.bindt
end
module TypeSortBind = SortAndBind(Type)
@
% ------------------------------------------------------------------ 
\subsubsection{Constants}
% ------------------------------------------------------------------ 

A constant declaration must declare a value of type [[bits]]; although
it is syntactically and type-wise possible to declare a boolean value
this is not permitted. The optionally provided type must match the
actual type of the defining expression.
<<nelab.ml>>=
module Const = struct
  type d = Ast.expr N.constdefn
  <<utility functions for constants>>
  module Decl = struct
    type decl = d N.marked
    let defines (_, (t,name,expr)) = [name]
    let uses    (_, (t,name,expr)) = freeExprVars expr []
  end
  let what = "constant"
  type rhs = Rtl.exp * Types.ty
  let eval env (r, (ty, name, e)) =
    let errorf x =
      Printf.kprintf (fun s -> E.errorRegionPrt (F.srcmap env, r) s; E.Error) x in
    E.seq (evalExpr env e) (fun (e, t) ->
      if t = Types.bool then errorf "constant has type bool but must have a bits type"
      else
        match ty with
        | None -> E.Ok (e, t)
        | Some ty ->
            E.seq (Type.evalTy env ty) (fun t' ->
              if t = t' then E.Ok (e, t)
              else errorf "constant %s declared with type %s has actual type %s"
                           name (Types.to_string t') (Types.to_string t)))
  let bind name (r, typed_exp) env = 
    F.bindv name (r, E.ematch typed_exp (fun (e, t) -> F.Constant(to_bits e), t)) env
end
module ConstSortBind = SortAndBind(Const)
@ 
A constant expression can refer to other constant and link-time
constants.  To find the right topological order it is only important
to find other constants.  Of course, these can not be syntactically
distinguished and so we will collect all free variables of an
expression.  This leads to used names that are not constants and that
appear to be undefined from the perspective of the topological
[[sort]] function.  But [[sort]] assumes that these undeclared names
do not depend on any constant---which is correct. 

The [[freeExprVars]] function returns all names referenced in an
expression. A constant expression depends on all of them.
<<utility functions for constants>>=
let rec freeExprVars e tail = match e with
| A.ExprAt(x,_)     -> freeExprVars x tail
| A.Fetch(lvalue)   -> freeLValueVars lvalue tail
| A.BinOp(e1,_,e2)  -> freeExprVars e1 (freeExprVars e2 tail)
| A.UnOp(_,e)       -> freeExprVars e tail
| A.PrimOp(_,args)  -> foldl (fun t (_,e) -> freeExprVars e t) tail args
| A.Int _           -> tail
| A.Float _         -> tail
| A.Char _          -> tail
@ 
<<utility functions for constants>>=
and freeLValueVars l tail = match l with
| A.NameOrMemAt(x,r) -> freeLValueVars x tail
| A.Mem(_,e,_, _)    -> freeExprVars e tail
| A.Name(_,name)     -> if List.mem name tail then tail else name :: tail
@

% ------------------------------------------------------------------ 
\paragraph  {Evaluating constant declarations}
% ------------------------------------------------------------------ 

\begin{quote}\it
    Module [[Expcheck]] also provides code to check the static
    semantics of an expression and [[Simplify]] could be used to evaluate
    it. Why are we not using it here? --CL 

    Several reasons: We would need a translation from {\AST} to
    [[Rtl.env]]. The existing one in \module{ast3ir} is written against
    the [[Ofenv.Clean]] interface, but we need one written against the
    [[Ofenv.Dirty]] interface. The translation of an application needs
    the widths of its arguments. Therefore type-checking using
    [[Expcheck]] would be done twice: once before translation and then
    again during translation. Detailed error messages are simpler to
    generate with the existing approach. --CL
\end{quote}

Constant declarations must be sorted topologically before they can be
processed.  Processing includes checking their types and evaluating
their values.  Both type and value are bound in the environment.

Processing a constant declaration means to
\begin{enumerate}
\item infer its type and compare it to an optionally supplied type that
      is part of its declaration,
\item evaluate it,
\item bind the value and the type in the environment.
\end{enumerate}

The topological sorting guarantees that every named value a constant
declaration depends on, is already processed and the name is bound in
the environment.  However, we can still encounter undefined names
which are cought by [[F.findv]].  The following functions type check
and evaluate constants in a single step.  Each function returns a pair
of a type and a value. 

[[literalExpr]] must be outside the [[let rec]] because it is
polymorphic.
<<utility functions for constants>>=
let literalExpr env v ty cvt  =
    E.ematch ty
    ( function 
    | T.Bool            -> E.error "a named constant value must have type bitsXX"
    | T.Bits width as t -> (R.bits (cvt v width) width, t) 
    )
@ 
<<utility functions for constants>>=
let rec evalFetch env = function
    | A.NameOrMemAt(x,r) -> E.catch (error r env) (evalFetch env) x
    | A.Mem (_,_,_,_)    -> E.error "memory access in const declaration"
    | A.Name(hint,id)  -> 
            ( match snd (F.findv id env) with
            | E.Error                -> E.Error
            | E.Ok(F.Constant(bits),ty) -> 
                E.Ok(R.bits bits (B.width bits), ty)
            | _ -> E.error ("access of non-constant "^id)
            ) 
@
Applications to primitives operators must be type checked. Only if the
type check passes we apply the values to the implementation [[f]] of the
operator and get the result.  Both result and type are returned.
<<utility functions for constants>>=
and evalPrimOp env op args =
    E.ematch (E.Raise.list (List.map (evalExpr env) args))
    (fun args ->
        let v,t    = List.split args                 in
        let rt,opr = Rtlop.Translate.operator op t   in
        let e      = Simplify.exp (Rtl.app opr v)    in
            ( match Dn.exp e with
            | RP.Const(RP.Bits _) -> e, rt
            | _     -> E.error ("not a compile-time operator: "^op)
            )
    )
@
The {\AST} contains literal values as strings. The reason is that the
width of a literal cannot be known when the literal is parsed. Here we
know the exact type and thus are able to parse the literal into a
[[Bits.bits]] value.
<<utility functions for constants>>=
and evalExprs env es = E.Raise.list (List.map (evalExpr env) es)
and evalExpr env =
  let wordTy env = E.Ok (Types.Bits (F.metrics env).Metrics.wordsize) in
  function
    | A.ExprAt(x,r)       -> E.catch (error r env) (evalExpr env) x
    | A.Int  (n  , Some t)-> literalExpr env n (evalTy env t) B.U.of_string
    | A.Int  (n  , None)  -> literalExpr env n (wordTy env)   B.U.of_string
    | A.Float(n  , Some t)-> literalExpr env n (evalTy env t) B.U.of_string
    | A.Float(n  , None)  -> literalExpr env n (wordTy env)   B.U.of_string
    | A.Char (n  , Some t)-> literalExpr env n (evalTy env t) B.U.of_int
    | A.Char (n  , None)  -> literalExpr env n (E.Ok(T.bits 8)) B.U.of_int
    
    | A.Fetch  (v)        -> evalFetch env v
    | A.BinOp  (l,op,r)   -> evalPrimOp env op [l;r]
    | A.UnOp   (op,expr)  -> evalPrimOp env op [expr]
    | A.PrimOp (op,args)  -> evalPrimOp env op (List.map snd args)
@

% ------------------------------------------------------------------ 
\subsection{Building the environment}
% ------------------------------------------------------------------ 

We assume here the elaboration of expressions and lvalues.
<<nelab.ml>>=
let elab lvalue typed_expr srcmap asm ast =
  E.ematch (Metrics.of_ast srcmap ast.N.target) (fun metrics ->
    let errorf r =
      Printf.kprintf (fun s -> E.errorRegionPrt (srcmap, r) s; E.Error) in
    let pointerty = Types.Bits metrics.Metrics.pointersize in
    let wordty    = Types.Bits metrics.Metrics.wordsize in
    <<definitions of name-binding functions>>
    let env = F.empty srcmap metrics asm in
    let env = TypeSortBind. bind_sortable_definitions env ast.N.udecls.N.types in
    let env = ConstSortBind.bind_sortable_definitions env ast.N.udecls.N.constants in
    let env = foldl bind_import env ast.N.imports in
    let env = foldl bind_reg env (registers_from 0 ast.N.globals) in
    let env = foldl bind_code_label env ast.N.code_labels in
    let env = foldl bind_section_labels env ast.N.sections in
    let env = check_exports env ast.N.exports in
    env)
@ 
<<definitions of name-binding functions>>=
let bind_import env (r, ty, imports) = 
  let import env (foreign,name) =
    let sym = F.symbol env name in
    let den = F.Import (Aux.Option.get name foreign, sym) in
    let ty  = <<convert optional importing [[ty]] as long as it is pointer size>> in
    F.bindv name (r, E.Raise.right (den, ty)) env in
  foldl import env imports in
<<convert optional importing [[ty]] as long as it is pointer size>>=
match ty with None -> E.Ok pointerty
| Some t -> E.seq (Type.evalTy env t) (fun t ->
    if t = pointerty then E.Ok pointerty
    else errorf r "imported type %s is inconsistent with native pointer type %s"
        (Types.to_string t) (Types.to_string pointerty))
@ 
<<definitions of name-binding functions>>=
let bind_code_label env (r, n) = unimp "code-label binding" in
@ 
<<definitions of name-binding functions>>=
let bind_reg env _ = unimp "register binding" in
let registers_from n rs = unimp "register elaboration and numbering" in
@ 
<<definitions of name-binding functions>>=
let bind_section_labels env _ = unimp "section-label binding" in
@ 
<<definitions of name-binding functions>>=
let check_exports env _ = unimp "export checking" in
@ 
================================================================
@ 
Labels and names for procedures have fixed types.  Types of register
and import declarations on the other hand can refer to named types
which may be undefined. A declaration which refers to an undefined type
is bound to [[Error.Error]].
<<module Env>>=
let rec ty r env = function
    | A.TyAt(x,r)       -> E.catch (error r env) (ty r env) x
    | A.BitsTy(n)       -> E.Ok(T.bits n)
    | A.TypeSynonym(n)      -> snd (F.findt n env)
@
<<module Env>>=
type scope = Local | Global
@
The following functions traverse the abstract syntax of the global or
local scope and enter all names into the environment -- except for
constants.  The parameter [[scope]] indicates whether local or global
symbols are bound.

Global symbols are all those on the top level and section level.
Additionally all labels for code inside procedures are also
bound because they have global scope. When local symbols (inside a
procedure) are bound, labels are bound a second time with a local scope
in the environment. This helps to decide whether a symbol is local or
global when it is accessed from inside a procedure.

An imported symbol always has global scope. This was changed during
the development of the compiler to make the mapping between {\PAL}
names and assembly level names easier.
<<module Env>>=
@ 
<<module Env>>=
let register r scope env = function
    | (_,Some h,t,name,Some x) -> E.error "can't have hint and hardware register"
    | (_,h,t,name,Some x) when scope = Local ->
        E.error "local registers can't be mapped to hardware"
    | (_,h,t,name,reg) ->
        let i = { F.index = F.getIndex env
                ; F.rhint = ( match h,reg with
                            | None  , None   -> F.RNone
                            | Some h, None   -> F.RHint h
                            | None  , Some r -> F.RReg r
                            | _ -> assert false
                            ) 
                ; F.loc   = None
                } in
        F.bindv name (r, E.ematch (ty r env t)
                          (fun t -> F.Variable i, t)) (F.nextIndex env)
@
A [[datum]] label is a [[F.Label(F.Data)]] when the datum belongs to a
top-level datum, and a [[F.Label(F.Stack)]] when the datum belongs to
a [[stackdatum]]. We thus have two functions: [[datum]] and [[stackdatum]].
<<module Env>>=
let rec datum r scope env = function
    | A.DatumAt(x,r) -> E.catch' env (error r env) (datum r scope env) x
    | A.Label(n)     ->
        let sym    = F.symbol env n in
        let ventry = (E.ematch (pointerTy env) 
                     (fun p -> F.Label(F.Data sym),p)) in
        F.bindv n (r,ventry) env
    | _              -> env
@
The denotation of a [[stackdatum]] label includes the [[offset]] into its
procedure's stack data. This offset is not yet known and will be added
in a later phase.
WHY CAN'T THE LOCATION BE COMPUTED SYMBOLICALLY NOW?
THIS CHANGE WOULD SIMPLIFY THE DATA TYPE.
<<module Env>>=
let rec stackdatum r scope env = function
    | A.DatumAt(x,r) -> E.catch' env (error r env) (stackdatum r scope env) x
    | A.Label(n)     -> F.bindv n (r,
                                (E.ematch (pointerTy env) 
                                    (fun p ->  F.Label(F.Stack(None)),p)))
                                env
    | _              -> env
@
Continuations are local to procedures and thus they are only bound
when in [[Local]] mode; labels have global scope, but are bound a
second time in the local environment. This has the following advantages:
\begin{itemize}
\item The second binding clashes with any other local binding that
      might shadows the global binding.

\item A [[goto]] must have a local target. Now is is possible to test
      for this. 
\end{itemize}
<<module Env>>=
let rec stmt r scope env = function 
    | A.StmtAt(x,r)               ->
        E.catch' env (error r env) (stmt r scope env) x
    | A.IfStmt ( e, ss1, ss2)     ->
        foldl (body r scope) (foldl (body r scope) env ss1) ss2
    | A.LabelStmt(n) ->
        let sym    = F.symbol env n in
        let ventry = (E.ematch (pointerTy env) 
                     (fun p -> F.Label(F.Code sym),p)) in
            F.bindv n (r,ventry) env
    | A.SpanStmt(e1,e2,ss)        ->
        foldl (body r scope) env ss
    | A.SwitchStmt (range,e,arms) ->
        foldl (arm r range scope)  env arms
    | A.ContStmt(n,ee) when scope = Local ->
        let sym    = F.symbol env n in
        let ventry = (E.ematch (pointerTy env) 
                     (fun p -> F.Continuation (Idgen.cont n,sym),p)) in
            F.bindv n (r,ventry) env
    | otherwise                   ->
        env

and arm r range scope env = function
    | A.ArmAt(x,r)      -> E.catch' env (error r env) (arm r range scope env) x
    | A.Case(ranges, ss)-> foldl (body r scope) env ss
@
We have two functions to deal with declarations:  [[gdecl]] for
(global) declarations on the program and section level, and [[ldecl]]
for declarations on the procedure level.  Declarations processed by
[[gdecl]] always have global scope.  Some declarations on the (local)
procedure level declare \emph{global} values.  Therefore, local
declarations are processed when collection global ([[scope]] =
[[Global]]) declarations.

Imported values have global scope and thus must not be recorded when
we are in a [[Local]] [[scope]].
<<module Env>>=
and ldecl r scope env = function
    | A.DeclAt(x,r)    -> E.catch' env (error r env) (ldecl r scope env) x
    | A.Import(ty,ii)  when scope=Global 
                       -> imports r env ty ii
    | A.Registers(rr)  when scope = Local
                       -> foldl (register r scope) env rr
    | _                -> env

and gdecl r env = function
    | A.DeclAt(x,r)    -> E.catch' env (error r env) (gdecl r env) x
    | A.Import(ty,ii)  -> imports r env ty ii
    | A.Registers(rr)  -> foldl (register r Global) env rr
    | _                -> env
@
A \textit{body} is always local to procedure.  However, a body also
contains names of global scope (labels, imports) and thus must be
traversed to bind them.
<<module Env>>=
and body r scope env = function
    | A.BodyAt(x, r) -> E.catch' env (error r env) (body r scope env) x
    | A.DeclBody(d)  -> ldecl r scope env d 
    | A.DataBody(dd) when scope = Local 
                     -> foldl (stackdatum r scope) env dd 
    | A.StmtBody(s)  -> stmt r scope env s
    | _              -> env
@
A procedure opens a local scope:  the procedure's parameters and all
local [[typedef]], [[const]], [[continuation]] belong to the local
scope.  When collecting the global values only the procedure's name is
bound in the environment and the [[goto]] labels in its body.
<<module Env>>=
let formal r env (hint, inv, ty, name) =
    match evalTy env ty with
    | E.Ok(t) -> let i = { F.index = F.getIndex env (* run-time API *)
                         ; F.rhint = ( match hint with
                                     | Some h -> F.RHint h
                                     | None   -> F.RNone
                                     ) 
                         ; F.loc   = None
                         }
                     in
                         F.bindv name (r,(E.Ok(F.Variable(i),t))) 
                         (F.nextIndex env) 
    | E.Error -> F.bindv name (r, E.Error) env
@
<<module Env>>=
let proc r env (_,name,ff,bb as p) =
    let sym     = F.symbol env name in
    let ventry  = E.ematch (pointerTy env) 
                           (fun p -> F.Label(F.Proc(sym,None,0)),p) in
    let env     = foldl (body r Global) env bb     in 
    let env     = F.bindv name (r,ventry) env    in
        env
@
The high level non-terminals [[section]] and [[toplevel]] are just
containers.  We use them to catch errors and otherwise just call the
functions that do the real work.
<<module Env>>=
let rec section r env = function
    | A.SectionAt(x,r)     -> E.catch' env (error r env) (section r env) x
    | A.Decl(d)            -> gdecl r env d
    | A.SSpan( e1, e2, ss) -> foldl (section r) env ss
    | A.Datum( d)          -> datum r Global env d
    | A.Procedure(p)       -> proc r env p
@ 
<<module Env>>=
let rec toplevel r env = function 
    | A.ToplevelAt(x, r)  -> E.catch' env (error r env) (toplevel r env) x
    | A.Section(name, ss) -> foldl (section r) env ss
    | A.TopDecl(d)        -> gdecl r env d
    | A.TopProcedure(p)   -> proc r env p 

@

% ------------------------------------------------------------------ 
\subsection{Checking the static semantics}
% ------------------------------------------------------------------ 

After all global names for types and values are bound in the fat
environment the static semantics can be checked.  This essentially
means to walk over the abstract syntax and check all the constraints
defined by the static semantics.  In case of an error we like to
report it but continue to check the rest of a program.  
<<module Check>>=
<<Check auxiliaries>>
<<type check expression>>
<<check>>
@
Alignments must be a power of two.  This predicates is true, iff its
argument is a positive power of two.
<<Check auxiliaries>>=
let is2power x = x > 0 && x land (x - 1) = 0
@

% ------------------------------------------------------------------ 
\subsubsection{Expression types}
% ------------------------------------------------------------------ 

We use the generic functionality of module [[Expcheck]] for checking
the static semantics of expressions. 
<<type check expression>>=
let tyExpr env e =
  let typed_expr, _ = Expcheck.exprfuns (fun _ -> Rtl.late "continuation?!" 99) env in
  E.ematch (typed_expr e) snd
@
% ------------------------------------------------------------------ 
\subsubsection{Checking the static semantics}
% ------------------------------------------------------------------ 

Checking the static semantics really starts here.  We traverse the
abstract syntax and check all the constraints.  The result of checking
the static semantics is an environment; in case error are found by the
check they are manifest in the returned environment.  So every
function that takes part in checking the static semantics receives and
returns an environment.

THERE IS AN IMPORTANT PIECE MISSING HERE: THE CONTROL-FLOW
RESTRICTIONS ARE NOT CHECKED.  IT WILL BE NECESSARY TO EXTEND THE
ENVIRONMENT SO THAT WHEN A STATEMENT IS CHECKED, THE CHECKER KNOWS
WHETHER CONTROL CAN FALL THROUGH TO THAT STATEMENT.
IF THE ANSWER IS YES, THE STATEMENT HAD BETTER NOT BE A CONTINUATION.
SIMILARLY, IT HAD BETTER NOT BE THE END OF THE PROCEDURE BODY EITHER.

To evaluate constant expressions we use the code from [[Const.Eval]];
the returned value has type [[(Types.ty * F.value) E.error]]
<<check>>=
let constExpr env e = Consts.evalExpr env e
@    
The [[lvalue]] function checks an lvalue and returns its type. 
Depending on the [[context]], an [lvalue] must be a register.  In case
an assignment to memory is allowed the size of the memory being
assigned to must be a multiple of the memsize.  The address of the
memory must be an data pointer.
<<check>>=
let rec lvalue context env = function
    | A.NameOrMemAt(x,r)       -> E.catch (error r env) (lvalue context env) x
    | A.Name(Some h,x) when context <> Call ->
        E.error "no hint allowed in this context"
    | A.Name(hint,name)      -> 
        E.ematch (E.Raise.right (F.findv name env))
        ( function
        | _, (F.Variable _,t) -> t
        | _                   -> E.error ("not a register: "^name)
        )
    | A.Mem(t,e,a,_) when context <> Assign -> 
        E.error "no memory assignment allowed in this context"
    | A.Mem(t,e,aligned,aliasing) -> 
        let msg1   = "alignment not a power of 2"                in
        let msg2   = "type must be a multiple of target memsize" in
        let msg3   = "unknown target memsize"                    in
        let msg4   = "expression is not a pointer"               in
        let msg5   = "bool is not a value type"                  in
        let align  = function
            | Some a when not (is2power a) -> E.error msg1
            | Some a                       -> ()
            | None                         -> () 
        in
            ( align aligned (* check alignment constraint *)
            ; E.ematchQuad ( evalTy env t
                           , tyExpr env e
                           , F.findMemsize env
                           , pointerTy env
                           )
            ( function
            | _       , _           , None   ,_ -> E.error msg3
            | T.Bool  , _           , _      ,_ -> E.error msg5
            | T.Bits n, _           , Some m ,_
              when n mod m <> 0                 -> E.error msg2
            | t       , t'          , _      ,p
              when t' = p                       -> t
            | _                                 -> E.error msg4
            ))
@
The [[memsize]] function returns the number of objects to reserve
memory for. Any given number must be a positive value.
<<check>>=
let memsize env = function
    | A.DynSize       -> E.Ok(None)
    | A.NoSize        -> E.Ok(Some 1)
    | A.FixSize(e)    -> E.ematch (Consts.evalExpr env e)
        ( function 
        | Types.Bits(_), exp ->
            let size = try Bits.U.to_int (to_bits exp) with
                       Bits.Overflow -> E.error "size too big"
            in 
                if size > 0 then Some (size)
                else E.error "invalid memory size"
        | _ ->       E.error "invalid memory size"
        )
@    
All initial values for a memory declaration must match the declared
type [[t]] of the memory declaration. The [[init]] function checks for
this and returns the number of initial expressions.
<<check>>=
let rec init env ty i = 
    let msg1 = "types of initial values do not match declared type" in
    E.seq ty
    ( fun t -> match i with
    | A.InitAt(x,r)    -> E.catch (error r env) (init env ty) x
    | A.InitExprs(es)  -> E.seq (E.Raise.list (List.map (tyExpr env) es))
                          ( fun ts -> (* check type consistency *)
                            if   (foldl (fun res t' -> res && t' = t) true ts)
                            then E.Ok(List.length es)
                            else E.error msg1
                          )
    | A.InitStr(s)      
      when t = T.bits 8 -> E.Ok(String.length s)
    | A.InitUStr(s)   
      when t = T.bits 16 -> E.Ok(String.length s)
    | _                -> E.error msg1
    )
@
A memory declaration has a type, a type, and optionally a number of
expressions to initialize the memory.  The number of expressions must
match the size specification, and the type of the expressions must
match the declared type.
<<check>>=
let memdecl env ty size init_exprs =
    let t = evalTy env ty    in
    let n = memsize env size in
    match init_exprs with
    | None   -> E.seq' (F.flagError env) (E.Raise.pair   (t,n)) (fun _ -> env)
    | Some i -> E.seq' (F.flagError env) (E.Raise.triple (t,n,init env t i))
        ( function 
        | t, Some n, m when m > n -> E.error "too many initial values"
        | t, Some n, m when m < n -> E.error "foo few initial values"
        | t, Some n, _            -> env
        | t, None  , _            -> env
        )
@
A [[stackdatum]] declaration must respect some constraints:  (1) no
expressions to initialize memory, (2) no [[[]]] used as a size, (3) an
alignment must be a power of two. 
<<check>>=
let rec stackdatum env = function
    | A.DatumAt(x,r)            -> E.catch' (F.flagError env) (error r env) 
                                      (stackdatum env) x
    | A.Label(n) -> env
    | A.Align(a) when not (is2power a) ->
        E.error ("illegal alignment: " ^ string_of_int a)
    | A.Align(a)                -> env 
    | A.MemDecl(t,A.DynSize,_)  -> E.error ("illegal size for stack data")
    | A.MemDecl(t,n,None)       -> 
        let env = memdecl env t n None in
            E.seq' env (memsize env n)
            ( function 
            | Some n -> env
            | None   -> assert false        (* impossible *)
            )
    | A.MemDecl(t,n,_   )       -> 
        E.error "no initial values allowed for stackdata"
@
Labels as part of memory data must not be processed because they have been
already entered into the fat environment in a previous step. This leaves
alignments and memory declarations to be checked.
<<check>>=
let rec datum env = function
    | A.DatumAt(x,r)  -> E.catch' (F.flagError env) (error r env) (datum env) x
    | A.Label(n)      -> env
    | A.Align(a)      -> if   is2power a 
                         then env 
                         else E.error "illegal alignment"
    | A.MemDecl(t,s,i)-> memdecl env t s i
@
Not all named values can be exported: registers, continuations, and
stack labels are values that can't be exported. Export declarations
optionally can specify the type of declared symbols. Such a type must
match the actual type of an exported symbol.
<<check>>=
let export' env = function
    | None, name   -> 
        E.seq' (F.flagError env) (snd (F.findv name env))
        ( function
        | F.Label(F.Proc _), _ -> env
        | F.Label(F.Code _), _ -> env
        | F.Label(F.Data _), _ -> env
        | _                    -> E.error (name^" can't be exported")
        )
    | Some t, name -> 
        let t = evalTy env t in
        E.seq' (F.flagError env) (E.Raise.pair (snd (F.findv name env), t))
        ( function
        | (F.Label(F.Proc _ ),t), t' when t = t' -> env
        | (F.Label(F.Code _ ),t), t' when t = t' -> env
        | (F.Label(F.Data _ ),t), t' when t = t' -> env
        | (F.Label(F.Proc _ ),_), _ 
        | (F.Label(F.Data _ ),_), _ 
        | (F.Label(F.Code _ ),_), _  -> E.error (name^" has not declared type")
        | _                          -> E.error (name^" can't be exported")
        )

let export env (t,ns) = foldl (fun env (n,_) -> export' env (t,n)) env ns
@
A target for a [[goto]] statement must be a local code pointer.
<<check>>=
let checkGotoTarget env x = E.seq' env (snd (F.findv x env))
    ( function 
    | (F.Label(F.Code _),_) when F.is_localv x env -> env
    | (F.Label(F.Code _),_)  -> E.error (x^" not a local label")
    | (F.Label(_)     ,_)    -> E.error (x^" is not a goto label")
    | otherwise              -> E.error (x^" is not a label")
    )
@
A call-target must be either a procedure, or an imported symbol with
the native code pointer type.
<<check>>=
let checkCallTarget env x = 
    E.seq' env (E.Raise.pair (pointerTy env,E.Raise.right (F.findv x env)))
    ( function
    | p,(_      ,(F.Label(F.Proc(_)),_)) ->  env
    | p,(_      ,(F.Import _     ,t)) 
      when t = p                         ->  env
    | otherwise                          ->  E.error (x^" is not call target")
    )
@
A flow annotation must be a (local) continuation.  The flow
annotations [[returns to]] and [[unwinds to]] are meaningless when
used to annotate a [[cuts to]] statement.  We are checking a [[cut
to]] statement when [[isCutTo]] is true. 
<<check>>=
let rec checkFlow isCutTo env f =
    let check env x = E.seq' env (snd (F.findv x env))
        ( function
        | (F.Continuation _,_) -> env
        | _                    -> E.error (x^" is not a continuation")
        )     
    in match f with
    | A.FlowAt(x,r)     -> E.catch' (F.flagError env)
                                    (error r env) (checkFlow isCutTo env) x
    | A.CutsTo(ns)      -> foldl check env ns 
    | A.UnwindsTo(ns)   -> if isCutTo 
                           then E.error "unwinds is meaningless for cut to" 
                           else foldl check env ns 
    | A.ReturnsTo(ns)   -> if isCutTo 
                           then E.error "returns is meaningless for cut to"
                           else foldl check env ns 
    | A.Aborts          -> env
@
The [[isLabel env e]] function returns [[true]] if the expression [[e]]
denotes a statically known label for [[goto]]. Analogously,
[[isNoFunction]] is true, if an expression is statically known
\emph{not} to address a function. Basically, an expression is known not
to be a function if it is a name that does not denote a function.
<<check>>=
let rec isGotoLabel env = function
    | A.ExprAt(x,_)                             -> isGotoLabel env x
    | A.Fetch(A.NameOrMemAt(x,_))               -> isGotoLabel env (A.Fetch x)
    | A.Fetch(A.Name(_,x))                      -> 
          ( match F.findv x env with
          | _       ,E.Error                    -> false
          | scope   ,E.Ok(F.Label(F.Code(_)),_) -> true
          | _                                   -> false
          )        
    | _                                         -> false

let rec isNoFunction env = function
    | A.ExprAt(x,_)                             -> isNoFunction env x
    | A.Fetch(A.NameOrMemAt(x,_))               -> isNoFunction env (A.Fetch x)
    | A.Fetch(A.Name(_,x))                      -> 
          ( match F.findv x env with
          | _       ,E.Error                    -> false (* could be proc *)
          | scope   ,E.Ok(F.Import _,_)         -> false
          | scope   ,E.Ok(F.Label(F.Proc(_)),_) -> false
          | scope   ,E.Ok(F.Variable _,_)       -> false
          | _                                   -> true
          )        
    | _                                         -> false
@
The expression of an [[if]] statement must be a boolean value. Errors
in any of the two statement blocks are recorded in the environment.
<<check>>=
let rec ifStmt env (e,ss1,ss2) =
    let msg = "if-condition must be of type bool" in           
    let env = foldl body env ss1 in
    let env = foldl body env ss2 in
        E.seq' env (tyExpr env e)
        ( function 
        | t when t = T.Bool -> env 
        | _                 -> E.error msg
        )
@
A [[span]] statement has two expressions [[e1]] and [[e2]].  The first
(token) must be a constant native word, the second a link time (data)
pointer.  Of course, all statement inside the span must be checked as
well. Currently we don't check the link-time property of [[e2]].
<<check>>=
and spanStmt env (e1,e2,ss) =
    let msg1 = "span token must be a constant word" in
    let msg2 = "span value must be a pointer"       in
    let env  = foldl body env ss                    in
        E.seq' env (Error.Raise.quad ( constExpr env e1
                                     , tyExpr env e2
                                     , pointerTy env
                                     , wordTy env
                                     ))
        ( function
        | (t1,v1), _ , p, w when t1 <> p -> E.error msg1
        | _      , t2, p, w when t2 <> w -> E.error msg2
        | _                              -> env
        )
@
Two two sides of an assign statement must match: the number and types
of lvalues and expressions are checked against each other.  For
improved error messages [[List.combine]] is re-implemented. Details
of the left hand side are handled by the [[lvalue]] function.

The right hand side may contain optional guarding expressions of type
[[bool]].
<<check>>=
and assignStmt env left_right =
    let msg0 = "type mismatch of left and right side in assignment" in
    let msg1 = "guard must have type bool" in
    let rec combine = function (* like List.combine *)
        | []   , []    -> []
        | _    , []    -> E.error "too many locations on the left side"
        | []   , _     -> E.error "too many expression on the right side"
        | x::xx, y::yy -> (x,y)::combine (xx,yy) in
    let pairs = combine left_right in
    let check env = function
        | (lhs,(None,exp)) -> E.seq' (F.flagError env) 
           (E.Raise.pair (lvalue Assign env lhs, tyExpr env exp))
           ( function 
           | tl, tr when tl = tr -> env
           | _                   -> E.error msg0
           )
        |  (lhs,(Some g,exp)) -> E.seq' (F.flagError env) 
           (E.Raise.triple ( lvalue Assign env lhs
                           , tyExpr env exp
                           , tyExpr env g))
               ( fun (tl, tr, gt) ->
                      if tl =  tr && gt = T.Bool then env
                 else if tl <> tr                then E.error msg0
                 else                                 E.error msg1
               )
    in
        foldl check env pairs
@
A [[goto]] statement must name all possible (local) targets [[ts]] for
its code pointer expression [[e]].  Targets may be omitted if the
expression is a statically known target, i.e.~a label. 
<<check>>=
and gotoStmt env (e,ts) =
    let msg1 = "goto-expression has no pointer type" in
    let msg2 = "no target list for goto or not a goto target" in
    let env  = foldl checkGotoTarget env ts          in
    let env  = E.seq' (F.flagError env) (E.Raise.pair ( tyExpr env e
                                                      , pointerTy env  
                                                      ))
        ( function 
        | t,p when t = p -> env
        | _              -> E.error msg1
        )
    in
        if ts = [] && not (isGotoLabel env e)
        then E.error msg2
        else env
@
A call need not name targets;
the only requirement is that the expression by of the native pointer
type.  
The
details of the assignment in a [[Call]] context are handled by
[[lvalue]].  To make sure all errors are recorded in [[env]] the
argument to [[E.seq']] includes [[left]] and [[at]] although only the
type of [[exp]] is used.
<<check>>=
and callStmt env (left,cc,exp,args,ts,fs) =
    let msg1 = "call expression is not a function"                in
    let msg2 = "call expression is not a pointer"                 in
    let left = E.Raise.list (List.map (lvalue Call env) left)     in
    let env  = foldl (checkFlow false) env fs                     in
    let env  = foldl  checkCallTarget  env ts                     in
    let args = List.map snd args (* strip hints *)                in
    let at   = E.Raise.list (List.map (tyExpr env) args)          in
        if isNoFunction env exp then E.error msg1 else 
        E.seq' (F.flagError env) 
               (E.Raise.quad (tyExpr env exp,left,at,pointerTy env)) 
               ( function 
               | t,_,_,p when t = p    -> env
               | otherwise             -> E.error msg2 
               ) 
@
A call of a primitive is type checked: argument types must have the
expected types. This is done by [[Rtlop.Translate.check]].
<<check>>=
and primStmt env (left,cc,op,args,fs) =
    let left   = E.Raise.list (List.map (lvalue PrimCall env) left) in
    let env    = foldl (checkFlow false) env fs                     in
    let args   = List.map snd args                                  in
    let t      = E.Raise.list (List.map (tyExpr env) args)          in 
    let right  = E.ematch t (fun t -> fst (Rtlop.Translate.operator op t)) in
        E.seq' (F.flagError env) (E.Raise.pair (left,right)) (fun _ -> env)
@
The formal parameters of a continuation statement must be local
registers. 
<<check>>=
and contStmt env (n,ns) = 
    let check env (hint,name) = E.seq' env (snd (F.findv name env))
        ( function  
        | (F.Variable _,_) when F.is_localv name env -> env
        | (F.Variable _,_) -> E.error (name^" is not a local register")  
        | _ -> E.error ("formal continuation parameter not a register: "^n)
        )
    in
        foldl check env ns
@
A continuation expression must have a continuation type. 
<<check>>=
and cutStmt env (e,args,fs) =
    let msg1 = "expression not of continuation type"     in
    let args = List.map (tyExpr env) (List.map snd args) in
    let env  = foldl (checkFlow true) env fs             in
        E.seq' (F.flagError env)
               (E.Raise.triple (tyExpr env e, E.Raise.list args, pointerTy env))
               ( fun (t,_,p) ->
                 if   t <> p
                 then E.error msg1
                 else env
               )
@
A [[return]] may specify alternate return continuations.  The
expressions $e_1/e_2$ must be both of the native word type and $0 \leq
e1 \leq e_2$.
<<check>>=
and returnStmt env (cc,alt,args) =
    let args  = List.map snd args  in
    let env   = E.seq' (F.flagError env) 
                       (E.Raise.list (List.map (tyExpr env) args)) 
                       (fun _ -> env) in
        match alt with
        | None         -> env
        | Some (e1,e2) -> 
            let e1' = constExpr env e1 in
            let e2' = constExpr env e2 in
                E.seq' (F.flagError env) (E.Raise.triple (e1',e2',wordTy env))
                ( function 
                | (tx, x),(ty, y),w when
                   (  tx = w
                   && ty = w
                   && Bits.S.to_int (to_bits x) >= 0 
                   && Bits.S.to_int (to_bits y) >= 0 
                   && Bits.S.to_int (to_bits x) <= Bits.S.to_int (to_bits y)
                   )  -> env 
                | _ -> E.error "illegal <x/y> combination"
                )
@
A [[jump]] has to lists it targets except when the jump target is
statically known. The jump expression must be a (code) pointer.
<<check>>=
and jumpStmt env (cc,e,args,ts) =
    (*MUST CHECK THAT CALLING CONVENTION IS THE SAME AS CONTAINING PROCEDURE*)
    let args = List.map (tyExpr env) (List.map snd args) in
    let env  = foldl checkCallTarget env ts              in
    let env  = E.seq' env (E.Raise.pair (tyExpr env e,pointerTy env)) 
               ( function 
               | t,p when t = p -> env
               | otherwise      -> E.error "jump target is not a pointer"
               )
    in
        if isNoFunction env e then
            E.error "jump target is not a function"
        else 
            E.seq' (F.flagError env) (E.Raise.list args) (fun x -> env)
@
The type of range-expressions in a [[switch]] statement must match the
type [[t]] of the [[switch]] expression.  The parameter [[t]] is in
the [[E.error]] domain and thus function from the [[E]] module are
used for access. 
<<check>>=
and range t env r =
    let msg1 = "Range type does not match expression type" in
    E.seq' (F.flagError env) t
    ( fun t -> match r with
    | A.Point(e) -> 
        E.seq' (F.flagError env) (constExpr env e)
        ( function
        | (t',v) when t=t'   -> env
        | otherwise          -> E.error msg1
        )

    | A.Range(e1,e2) -> 
        let e1e2 = E.Raise.pair (constExpr env e1, constExpr env e2) in
        E.seq' (F.flagError env) e1e2
        ( function 
        | (t1,v1), (t2,v2) 
           when t1=t && t2=t -> env
        | otherwise          -> E.error msg1
        )
    )
@
All ranges that guard a [[switch]] arm must match the type of the
[[switch]]-expression
<<check>>=
and arm t env = function
    | A.ArmAt(x,r)   -> E.catch' (F.flagError env) (error r env) (arm t env) x
    | A.Case(rr, ss) ->
        let env = foldl body env ss              in 
        let env = foldl (range t) env rr         in 
            ( match rr with 
            | [] -> E.error "must specify range for this arm"
            | _  -> env
            )
@
The type of the switch expression must be matched by the guarding
ranges of the arms.  An empty switch-statement is an error because no
arm can match the value of the switch-expression at run-time.
<<check>>=
and switchStmt env (r, expr, arms) =
    let t   = tyExpr env expr in
    let env = match r with
        | Some r -> range t env r
        | None   -> env in
    let env = foldl (arm t) env arms in
        E.seq' (F.flagError env) t
        ( fun t -> 
            if arms = [] 
            then E.error "empty switch statement"
            else env
        )
@
The [[stmt]] function catches errors detected in individual statements
and flags them in the environment. Nothing needs to be done for most
declarations and labels since they were entered into [[env]] in
previous steps.
<<check>>=
and stmt env = function
    | A.StmtAt(x,r)     -> E.catch' (F.flagError env) (error r env) (stmt env) x
    | A.IfStmt  x       -> ifStmt     env x
    | A.SpanStmt x      -> spanStmt   env x
    | A.AssignStmt x    -> assignStmt env x
    | A.CallStmt x      -> callStmt   env x
    | A.PrimStmt x      -> primStmt   env x
    | A.GotoStmt x      -> gotoStmt   env x
    | A.CutStmt x       -> cutStmt    env x
    | A.ReturnStmt x    -> returnStmt env x
    | A.JumpStmt x      -> jumpStmt   env x
    | A.ContStmt x      -> contStmt   env x
    | A.SwitchStmt x    -> switchStmt env x
    | A.LabelStmt x     -> env        (* nothing to do *)
    | A.EmptyStmt       -> env        (* nothing to do *)  
    | A.CommentStmt _   -> env
@
A [[body]] belongs either to a procedure or a [[span]] statement. Data
declarations as part of a [[body]] always declare data on the stack.
<<check>>=
and body env = function
    | A.BodyAt (x,r)   -> E.catch' (F.flagError env) (error r env) (body env) x
    | A.DeclBody x     -> decl env x
    | A.StmtBody x     -> stmt env x
    | A.DataBody x     -> foldl stackdatum env x
@    
Declarations for values and types have already been processed at this
stage. Only the [[export]] declaration must be checked.
<<check>>=
and decl env = function
    | A.DeclAt(x,r)   -> E.catch' (F.flagError env) (error r env) (decl env) x
    | A.Import      x -> env
    | A.Export      x -> export env x
    | A.Const       x -> env
    | A.Registers   x -> env
    | A.Typedef     x -> env
    | A.Target      x -> env
    | A.Pragma        -> env
@
A top level [[span]] contains [[section]]s but otherwise behaves like a
[[span]] statement: the two expressions [[e1]] and [[e2]] must denote a
word and a (data) pointer. The latter must be also a link-time constant
which is currently \emph{not} checked.
<<check>>=
and topSpan r env (e1,e2,ss) =
    let msg1 = "span token must be a constant word" in
    let msg2 = "span value must be a data pointer " in
    let env  = foldl (section r) env ss                 in
        E.seq' env (Error.Raise.quad ( constExpr env e1
                                     , tyExpr env e2
                                     , wordTy env
                                     , pointerTy env
                                     ))
        ( function
        | (t1,v1), _ ,w, p when t1 <> w -> E.error msg1
        | _      , t2,w, p when t2 <> p -> E.error msg2
        | _                        -> env
        )
@
A procedure opens a new scope which contains additional local names.
The [[Env.local]] functions computes this environment which is used by
the functions that check the body of a procedure. Errors recorded in
the local environment must be copied to the global environment.

A procedure numbers its local parameters and registers starting from~0.
We must save the actual value of [[F.getIndex]] and set it later
such that the global counter for indexing registers is maintained
across procedures.
\begin{quote}\it
    Can't this be tied to opening a new scope? Looks like a
    historic legancy from the time when we had no first-class scopes.
    --CL 
\end{quote}

The local environment for the procedure is bound in the fat
environment such that it can be re-used later.  This function updates
the existing entry for the procedure in the fat environment. 
<<check>>=
and proc r env (_,name,_,bb as p) =
    let env   = F.push env F.emptyscope  (* open new scope *)   in 
    let env   = Env.local env p                                 in
    let env   = foldl body env bb (* traverse body *)           in
    let index = F.getIndex env                                  in
    let scope = F.top env                                       in
    let env   = F.pop env                                       in
    let r,x   = try F.findv name env (* lookup this proc *)  
                with Not_found -> assert false                  in
    let entry = E.ematch x
               ( function
               | (F.Label(F.Proc(sym,None,_)),t) -> (* update denotation *)
                    F.Label(F.Proc(sym,Some scope,index)),t
               | _ -> assert false
               )                                            
    in
        F.rebindv name (r,entry) env (* update proc entry *)
@
The following functions deal with the top-level nonterminal symbols
that themselves need no checking.  The real work is done at a lower
level.
<<check>>=
and section r env = function
    | A.SectionAt(x,r)     -> E.catch' (F.flagError env) (error r env) 
                              (section r env) x
    | A.Decl(d)            -> decl env d
    | A.Datum( d)          -> datum env d
    | A.Procedure(p)       -> proc r env p 
    | A.SSpan x            -> topSpan r env x 
@             
<<check>>=
let rec toplevel r env = function
    | A.ToplevelAt(x, r)  -> E.catch' (F.flagError env) (error r env) 
                                      (toplevel r env) x
    | A.Section(name, ss) -> foldl (section r)  env ss
    | A.TopDecl(d)        -> decl env d
    | A.TopProcedure(p)   -> proc r env p
@ 
<<check>>=
let global env program = foldl (toplevel Srcmap.null) env program
@
