% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{macros.tex}

% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Implementation of the Abstract Assembler Interface}
% ------------------------------------------------------------------ 

The \module{asm2} describes an abstract interface to assemblers. This
module provides an implementation of that interface by representing
actions of the assembler in {\PAL}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface is a sub-type of [[Asm2.S]]: it provides everything
outlined there.

An assembler reflects many of the characteristics of the underlying
target architecture.  Since {\PAL} is quite flexible with respect to
pointer sizes, byteorder and such, we like to functorize our
implementation over these aspects, which we call the
\emph{personality} of the assembler.  A functor seems to be a good
compromise between a fixed personality, and a run-time configured
personality.

The personality provides additionally an abstract representation of
instructions. In this specific implementation a single instruction is
used to implement an entire procedure. However, this implementation
requires a function [[ext]] thant translates an instruction to the
abstract syntax of a procedure.

<<module type personality>>=
module type PERSONALITY = sig
    val target: Target2.t
    type instr
    val  ext: instr -> Target2.t -> Ast.proc
    val mangle: Mangle.mangler
end
@

<<asm2ast.mli>>=
<<module type personality>>

module Make (P: PERSONALITY): sig 
    include Asm2.S

    val ast: asm -> Ast.program         (* extra *)
end
    with type instruction = P.instr 
    with type init        = unit
    with type offset      = unit
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

It is a bit ironic, that the abstract interface to assemblers (module
\module{asm2}) does not match perfectly with the abstract syntax of
{\PAL}, the portable assembler. 

<<asm2ast.ml>>=
<<module type personality>>

module Make (P: PERSONALITY) = struct
    type instruction = P.instr

    <<module make>>
end

<<module make>>=
module T        = Target2
module A        = Ast
module Symbol   = Map.Make(struct type t=string let compare=compare end)
@

The [[Unsupported]] exception is raised when using features provided
by the interface, but not by this implementation.
 
<<module make>>=
exception Unsupported of string
let unsupported msg = raise (Unsupported msg)
@

An assembler is not independent from the personality of the underlying
architecture. The personality module [[P]] provides us with the
necessary informations. The following functions helps to create types
and values in {\AST} syntax.

<<module make>>=
let pointer     = A.BitsTy(P.target.T.pointersize)
let bits n      = A.BitsTy n
let int n       = A.Int( Bits.of_int n P.target.T.wordsize
                       , Some (bits P.target.T.wordsize)
                       )
let one         = int 1 (* wordsize *)
let zero        = A.Int( Bits.of_int 0 P.target.T.memsize
                       , Some (bits P.target.T.memsize)
                       ) (* memsize *)
@

The following types for section names, sizes and alignments are
dictated by the assembly interface.

<<module make>>=
type section    = string
type size       = int
type align      = int
@

A [[sym]] value is created from the [[mksym]] function.  A [[symbol]]
represents a label that was registered in the assemblers symbol table.

<<module make>>=
type symclass   = Import        
                | Export
                | Local
                | Common of size * align * section
type symbol     = string * symclass
type sym        = Sym of string
@                

An assembler program is represented by an [[asm]] value; it contains: 

\begin{itemize}
\item A symbol table: the assembler interface allows to create symbols
      that can be looked up later. Symbols are registered in the
      symbol table.

\item The name of the current section.

\item A list of actions belonging to the current action. For
      efficiency, actions are inserted at the front of the list. As a little
      reminder, the field name is primed:  [[actions']].  The list of
      actions is reversed we the section is closed.

\item A list of sections, making up the top level of the program. Again,
      the sections are in backward order for efficiency.  The [[ast]]
      function reverses this list before making it accessible for
      clients.
\end{itemize}

<<module make>>=
type asm =      { symbols:      symbol Symbol.t
                ; section:      string
                ; actions':     A.section list
                ; toplevel':    (string * A.section list) list
                }
@

The initially empty {\PAL} program puts everything into the ``this
can't happen'' section.  This is admittedly ugly. 

<<module make>>=
type init = unit
let init args =
    { symbols           = Symbol.empty
    ; section           = "this can't happen"
    ; actions'          = []
    ; toplevel'         = []
    }
@

An assembly [[action]] roughly corresponds to an [[Ast.section]]. 
Unfortunately this correspondence does not always hold and thus
actions must be categorized.  The effect of the [[append]] function
that adds an action to an assembly program depends on the category of
an action.

<<module make>>=
type action     = NewSection    of string
                | CurSection    of A.section
                | DefSym        of symbol
                | Nop
@

The [[mksym]] function creates [[sym]] values.  Symbols ultimately
create {\PAL} names and must be mangled for that.  This implementation
mangles the names as part of symbols when the {\AST} is created.

<<module make>>=
let mksym s    = Sym s
@

The [[append]] function adds an [[action]] to an [[asm]] value.  It
looks at the category of an action and then creates a new [[asm]]
value.  Whenever a new section is started, the current list of actions
is reversed, before the now closed section is added \emph{in front} of
the list of sections.  This means, that each section is in the right
order, but the order of sections is still reversed.

<<module make>>=
let append asm = function
    | NewSection s -> 
        { asm with 
          toplevel' = ( match asm.actions' with 
                      | [] -> asm.toplevel'  (* drop empty section *)
                      | aa -> (asm.section, List.rev aa) :: asm.toplevel'
                      )
        ; section   = s
        ; actions'  = []             
        }
    
    | CurSection x ->
        { asm with actions' = x :: asm.actions' }
    | DefSym (n,c) -> 
        if Symbol.mem n asm.symbols
        then asm
        else let actions = 
            ( match c with
            | Import   -> A.Decl(A.Import(pointer,[(None,n)])) :: asm.actions'
            | Export   -> A.Decl(A.Export(None,[(n,None)])) :: asm.actions'
            | Local    -> asm.actions' (* ignored - ok ?*)
            | Common _ -> asm.actions' (* ignored *)
            ) in { asm with 
                   actions' = actions
                 ; symbols = Symbol.add n (n,c) asm.symbols
                 }
    | Nop          -> asm
@

The semantics of the following functions is mostly determined by the
assembly interface.  However, this translation to {\PAL} is imperfect
in some cases. 

[[section]] closes the [[current]] section and starts a new one.  The
names of sections are \emph{not} mangled before they are used in the
{\AST}.

<<module make>>=
let section s   = NewSection s
let current asm = asm.section
@

For completeness, a \emph{no-operation} is provided.

<<module make>>=
let nop = Nop
@

Our assembler does not announce procedures.  Since instructions are
{\PAL} procedures, we rely on them to do The Right Thing.

<<module make>>=
type proc_info = unit
let proc () = Nop
@

{\PAL} provides no concept of a directly accessible location counter
and thus it can't be set.  Since all code we are generating here is
outside of procedures the [[align]] action must denote an alignment
for data and can not denote an align statement.

<<module make>>=
let org    n = unsupported "no location counter in this implementation"
let align  n = CurSection(A.Datum(A.Align n))
@

We represent [[addloc]] that advances the location counter by emitting
uninitialized data.

<<module make>>=
let addloc n = 
    let memsize = P.target.T.memsize in
    let ty      = bits memsize            in
    let size    = int n                   in
        CurSection(A.Datum(A.MemDecl(ty,A.FixSize(size),None)))
@
    

The actions related to symbols define new symbols, which are also entered
into the symbol table. The [[lookup]] function helps to find them.

<<module make>>=
let import (Sym n)                  = DefSym(n,Import)
let export (Sym n)                  = DefSym(n,Export)
let local  (Sym n)                  = DefSym(n,Local)
let common (Sym n) size algn sect   = DefSym(n,Common(size,algn,sect))
let lookup (Sym n) asm              = Symbol.find n asm.symbols
@


All labels must be mangled in order to obey the {\PAL} syntax.

<<module make>>=
let define_label (n,c)      = CurSection(A.Datum(A.Label(P.mangle n)))
let define_const (n,c) b    = 
    let bits = A.Int(b,Some (bits (Bits.width b))) 
    in CurSection(A.Decl(A.Const(None,P.mangle n,bits)))  
let define_local (Sym n)    = CurSection(A.Datum(A.Label (P.mangle n)))
@

This implementation does not support relocatable addresses. 

<<module make>>=
type reladdr = sym
type offset  = unit

let offset i        = unsupported "relocatable addresses unsupported"
let diff s s        = unsupported "relocatable addresses unsupported"
let reladdr (n,c) () = (Sym n) 
@

<<module make>>=
let instr i = CurSection(A.Procedure(P.ext i P.target))
@

The [[zeroes n]] function emits [[bits8[n]{0,0,...,0}]], where
[[bits8]] is the type for [[memsize]].

<<module make>>=
let zeroes n = 
    let memsize = P.target.T.memsize in
    let ty      = bits memsize            in
    let size    = int n                   in
    let rec z   = function
        | 0 -> []
        | n -> zero :: z (n-1)            in
    let init n  = Some(A.InitExprs(z n))  in
        if n = 0 
        then Nop
        else CurSection(A.Datum(A.MemDecl(ty,A.FixSize(size),init n)))
<<module make>>=
let value  v = 
    let ty   = bits (Bits.width v)              in
    let init = A.InitExprs([A.Int(v, Some ty)]) in
        CurSection(A.Datum(A.MemDecl(ty, A.FixSize one, Some init)))
<<module make>>=
let addr (Sym a)   =
    let ty   = pointer in
    let init = A.InitExprs([A.Fetch(A.Var(None,a))]) in
        CurSection(A.Datum(A.MemDecl(ty, A.FixSize one, Some init)))

<<module make>>=
let byteorder = match P.target.T.byteorder with
    | Rtl.BigEndian    -> Fenv.Clean.Big
    | Rtl.LittleEndian -> Fenv.Clean.Little
    | _                -> assert false
@

We can't emmit comments (at the moment), because the {\AST} provides
only a comment \emph{statement}.  Statements are part of procedures
which this code does not deal with.

<<module make>>=
let comment n = Nop
@

% ------------------------------------------------------------------ 
\subsection{Extras}
% ------------------------------------------------------------------         

The [[ast]] function provides the abstract {\PAL} syntax of the
``assembly'' program.  It closes the current section and reverse the
list of sections of [[asm.toplevel']] before returning them.

The program generated by the assembler interface inherits its
personality from the functor arguments [[P]] of type [[PERSONALITY]].
The personality is represented by an number of declarations at the
head of the program.

\begin{itemize}
\item [[target]] declarations announce the byte order and similar
      target dependent settings.

\item Hardware registers are declared as registers with hardware
      registers attached to them.
\end{itemize}

<<module make>>=
let personality =
    [ A.Memsize P.target.T.memsize
    ; ( match P.target.T.byteorder with
      | Rtl.BigEndian    -> A.ByteorderBig
      | Rtl.LittleEndian -> A.ByteorderLittle
      | _                -> assert false
      )
    ; A.PointerSize P.target.T.pointersize
    ; A.WordSize    P.target.T.wordsize
    ; A.Charset     P.target.T.charset
    ; A.FloatRepr   P.target.T.float
    ]
@

<<module make>>=
let ast asm = 
    let section  = (asm.section, List.rev asm.actions') in
    let toplevel = List.rev (section :: asm.toplevel')  in
    let sections = List.map (fun (name,sect) -> A.Section(name,sect)) 
                            toplevel                    in
    let target   = A.TopDecl(A.Target personality)      in
        target :: sections
@


