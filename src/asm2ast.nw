
\input{macros.tex}

% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Implementation of the Abstract Assembler Interface}
% ------------------------------------------------------------------ 

The \module{asm2} describes an abstract interface to assemblers. This
module provides an implementation of that interface by representing
actions of the assembler in {\PAL}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface is a sub-type of [[Asm2.S]]: it provides everything
outlined there.

An assembler reflects many of the characteristics of the underlying
target architecture.  Since {\PAL} is quite flexible with respect to
pointer sizes, byteorder and such, we like to functorize our
implementation over these aspects, which we call the
\emph{personality} of the assembler.  A functor seems to be a good
compromise between a fixed personality, and a run-time configured
personality.

The personality provides additionally an asbtract representation of
instructions. In this specific implementation a single instruction is
used to implement an entire procedure. However, this implementation
requires a function [[ext]] thant translates an instruction to
abstract syntax of a procedure.

<<module type personality>>=
module type PERSONALITY = sig
    val target: Target.info
    type instr
    val  ext: instr -> Ast.proc
    val mangle: Mangle.mangler
end
@

<<asm2ast.mli>>=
<<module type personality>>

module Make (P: PERSONALITY): sig 
    include Asm2.S

    val ast: asm -> Ast.program         (* extra *)
end
    with type instruction = P.instr
    with type init        = unit
    with type offset      = unit
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

It is a bit ironic, that the abstract interface to assemblers (module
\module{asm2}) does not match perfectly with the abstract syntax of
{\PAL}, the portable assembler. 

<<asm2ast.ml>>=
<<module type personality>>

module Make (P: PERSONALITY) = struct
    type instruction = P.instr

    <<module make>>
end

<<module make>>=
module A        = Ast
module Symbol   = Map.Make(struct type t=string let compare=compare end)
@

The [[Unsupported]] exception is raised when using features provided
by the interface, but not by this implementation.
 
<<>>=
exception Unsupported of string
let unsupported msg = raise (Unsupported msg)
@

An assembler is not independent from the personality of the underlying
architecture. The personality module [[P]] provides us with the
necessary informations. The following functions helps to create types
and values in {\AST} syntax.

<<>>=
let pointer     = A.BitsTy(P.target.Target.pointersize)
let bits n      = A.BitsTy n
let int n       = A.Int( Bits.of_int n P.target.Target.wordsize
                       , Some (bits P.target.Target.wordsize)
                       )
let one         = int 1 (* wordsize *)
let zero        = A.Int( Bits.of_int 0 P.target.Target.memsize
                       , Some (bits P.target.Target.memsize)
                       ) (* memsize *)
@

The following types for section names, sizes and alignments are
dictated by the assembly interface.

<<>>=
type section    = string
type size       = int
type align      = int
@

A [[sym]] value is created from the [[mksym]] function.  A [[symbol]]
represents a label that was registered in the assemblers symbol table.

<<>>=
type symclass   = Import        
                | Export
                | Local
                | Common of size * align * section
type symbol     = string * symclass
type sym        = Sym of string
@                

An assembler program is represented by an [[asm]] value; it contains: 

\begin{itemize}
\item A symbol table: the assembler interface allows to create symbols
      that can be looked up later. Symbols are registered in the
      symbol table.

\item The name of the current section.

\item A list of actions belonging to the current action. For
      efficiency, actions are inserted at the front of the list. As a little
      reminder, the field name is primed:  [[actions']].  The list of
      actions is reversed we the section is closed.

\item A list of sections, making up the top level of the program. Again,
      the sections are in backward order for efficiency.  The [[ast]]
      function reverses this list before making it accessible for
      clients.
\end{itemize}

<<>>=
type asm =      { symbols:      symbol Symbol.t
                ; section:      string
                ; actions':     A.section list
                ; toplevel':    (string * A.section list) list
                }
@

The initially empty {\PAL} program puts everything into the ``this
can't happen'' section.  This is admittedly ugly. 

<<>>=
type init = unit
let init args =
    { symbols           = Symbol.empty
    ; section           = "this can't happen"
    ; actions'          = []
    ; toplevel'         = []
    }
@

An assembly [[action]] roughly corresponds to an [[Ast.section]]. 
Unfortunately this correspondence does not always hold and thus
actions must be categorized.  The effect of the [[append]] function
that adds an action to an assembly program depends on the category of
an action.

<<>>=
type action     = NewSection    of string
                | CurSection    of A.section
                | DefSym        of symbol
                | Nop
@

The [[mksym]] function creates [[sym]] values.  Symbols ultimately
create {\PAL} names and must be mangled for that.  This implementation
mangles the names as part of symbols when the {\AST} is created.

<<>>=
let mksym s    = Sym s
@

The [[append]] function adds an [[action]] to an [[asm]] value.  It
looks at the category of an action and then creates a new [[asm]]
value.  Whenever a new section is started, the current list of actions
is reversed, before the now closed section is added \emph{in front} of
the list of sections.  This means, that each section is in the right
order, but the order of sections is still reversed.

<<>>=
let append asm = function
    | NewSection s -> 
        { asm with 
          toplevel' = ( match asm.actions' with 
                      | [] -> asm.toplevel'  (* drop empty section *)
                      | aa -> (asm.section, List.rev aa) :: asm.toplevel'
                      )
        ; section   = s
        ; actions'  = []             
        }
    
    | CurSection x ->
        { asm with actions' = x :: asm.actions' }
    | DefSym (n,c) -> 
        if Symbol.mem n asm.symbols
        then asm
        else let actions = 
            ( match c with
            | Import   -> A.Decl(A.Import(pointer,[(None,n)])) :: asm.actions'
            | Export   -> A.Decl(A.Export(None,[(n,None)])) :: asm.actions'
            | Local    -> asm.actions' (* ignored - ok ?*)
            | Common _ -> asm.actions' (* ignored *)
            ) in { asm with 
                   actions' = actions
                 ; symbols = Symbol.add n (n,c) asm.symbols
                 }
    | Nop          -> asm
@

The semantics of the following functions is mostly determined by the
assembly interface.  However, this translation to {\PAL} is imperfect
in some cases. 

[[section]] closes the [[current]] section and starts a new one.  The
names of sections are \emph{not} mangled before they are used in the
{\AST}.

<<>>=
let section s   = NewSection s
let current asm = asm.section
@

For completeness, a \emph{no-operation} is provided.

<<>>=
let nop = Nop
@

Our assembler does not announce procedures.  Since instructions are
{\PAL} procedures, we rely on them to do The Right Thing.

<<>>=
type proc_info = unit
let proc () = Nop
@

{\PAL} provides no concept of a directly accessible location counter
and thus it can't be set.  Since all code we are generating here are
outside of procedures the [[align]] action must denote an alignment
for data and can not denote an align statement.

<<>>=
let org    n = unsupported "no location counter in this implementation"
let align  n = CurSection(A.Datum(A.Align n))
@

We represent [[addloc]] that advances the location counter by emitting
uninitialized data.

<<>>=
let addloc n = 
    let memsize = P.target.Target.memsize in
    let ty      = bits memsize            in
    let size    = int n                   in
        CurSection(A.Datum(A.MemDecl(ty,A.FixSize(size),None)))
@
    

The actions related to symbols define new symbols, which are also entered
to the symbol table. The [[lookup]] function helps to find them.

<<>>=
let import (Sym n)                  = DefSym(n,Import)
let export (Sym n)                  = DefSym(n,Export)
let local  (Sym n)                  = DefSym(n,Local)
let common (Sym n) size algn sect   = DefSym(n,Common(size,algn,sect))
let lookup (Sym n) asm              = Symbol.find n asm.symbols
@


All labels must be mangled in order to obey the {\PAL} syntax.

<<>>=
let define_label (n,c)      = CurSection(A.Datum(A.Label(P.mangle n)))
let define_const (n,c) b    = 
    let bits = A.Int(b,Some (bits (Bits.width b))) 
    in CurSection(A.Decl(A.Const(None,P.mangle n,bits)))  
let define_local (Sym n)    = CurSection(A.Datum(A.Label (P.mangle n)))
@

This implementation does not support relocatable addresses. 

<<>>=
type reladdr = sym
type offset  = unit

let offset i        = unsupported "relocatable addresses unsupported"
let diff s s        = unsupported "relocatable addresses unsupported"
let reladdr (n,c) () = (Sym n) 
@

<<>>=
let instr i = CurSection(A.Procedure(P.ext i))
@

The [[zeroes n]] function emits [[bits8[n]{0,0,...,0]], where
[[bits8]] is the type for [[memsize]].

<<>>=
let zeroes n = 
    let memsize = P.target.Target.memsize in
    let ty      = bits memsize            in
    let size    = int n                   in
    let rec z   = function
        | 0 -> []
        | n -> zero :: z (n-1)            in
    let init n  = Some(A.InitExprs(z n))  in
        if n = 0 
        then Nop
        else CurSection(A.Datum(A.MemDecl(ty,A.FixSize(size),init n)))
<<>>=        
let value  v = 
    let ty   = bits (Bits.width v)              in
    let init = A.InitExprs([A.Int(v, Some ty)]) in
        CurSection(A.Datum(A.MemDecl(ty, A.FixSize one, Some init)))
<<>>=
let addr (Sym a)   =
    let ty   = pointer in
    let init = A.InitExprs([A.Fetch(A.Var(None,a))]) in
        CurSection(A.Datum(A.MemDecl(ty, A.FixSize one, Some init)))

<<>>=
let byteorder = match P.target.Target.byteorder with
    | Rtl.BigEndian    -> Fenv.Clean.Big
    | Rtl.LittleEndian -> Fenv.Clean.Little
    | _                -> assert false
@

We can't emmitit comments (at the moment), because the {\AST} provides
only a comment \emph{statement}.  Statements are part of procedures
which this code does not deal with.

<<>>=
let comment n = Nop
@

% ------------------------------------------------------------------ 
\subsection{Extras}
% ------------------------------------------------------------------         

The [[ast]] function provides the abstract {\PAL} syntax of the
``assembly'' program.  It closes the current section and reverse the
list of sections of [[asm.toplevel']] before returning them.

The program generated by the assembler interface inherits its
personality from the functor arguments [[P]] of type [[PERSONALITY]].
The personality is represented by an number of declarations at the
head of the program.

\begin{itemize}
\item [[target]] declarations announce the byte order and similar
      target dependent settings.

\item Hardware registers are declared as registers with hardware
      registers attached to them.
\end{itemize}

<<>>=
let personality =
    [ A.Memsize P.target.Target.memsize
    ; ( match P.target.Target.byteorder with
      | Rtl.BigEndian    -> A.ByteorderBig
      | Rtl.LittleEndian -> A.ByteorderLittle
      | _                -> assert false
      )
    ; A.PointerSize P.target.Target.pointersize
    ; A.WordSize    P.target.Target.wordsize
    ; A.Charset     P.target.Target.charset
    ; A.FloatRepr   P.target.Target.float
    ]
@

The target's personality includes a map of known hardware registers. 
Since programs a free to use these registers, we have to declare them. 
We walk over the map, and create declarations based on the name and
the width of the registers.  In order to avoid name clashes with user
declared variables, we append a space to a register's name before we
mangle it.  Of course, this convention must be respected when
references to these registers are generated.  This applies especially
to the translation of {\rtl}s to {\PAL} in module \module{rtl2ast}: 
hardware registers names must be extended by a space and then mangled.


<<>>=
let decl name loc dd = match loc with 
    | Rtl.Cell ('r', _, w, _, _) ->
        let r = (A.Variant, None, A.BitsTy w ,P.mangle (name^" "), Some name) 
        in  r::dd
    | _ -> assert false

let decls = Target.StrMap.fold decl P.target.Target.regmap []
    

<<>>=
let ast asm = 
    let section  = (asm.section, List.rev asm.actions') in
    let toplevel = List.rev (section :: asm.toplevel')  in
    let sections = List.map (fun (name,sect) -> A.Section(name,sect)) 
                            toplevel                    in
    let target   = A.TopDecl(A.Target personality)      in
        target :: A.TopDecl(A.Registers(decls)) :: sections
@


