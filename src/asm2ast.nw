% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{../config/macros.tex}

% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Implementation of the Abstract Assembler Interface}
% ------------------------------------------------------------------ 

The \module{asm2} describes an abstract interface to assemblers. This
module provides an implementation of that interface by representing
actions of the assembler in {\PAL}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

An assembler reflects many of the characteristics of the underlying
target architecture.  Since {\PAL} is quite flexible with respect to
pointer sizes, byteorder and such, we like to functorize our
implementation over these aspects, which we call the \emph{personality}
of the assembler.  A functor seems to be a good compromise between a
fixed personality, and a run-time configured personality.

The personality provides additionally an abstract representation of
instructions. In this specific implementation a single instruction is
used to implement an entire procedure. However, this implementation
requires a function [[ext]] thant translates an instruction to the
abstract syntax of a procedure. 

Names that are passed to the assembler become {\PAL} names in the output
and therefore must obey certain rules. We assume that the client side
knows about these rules and passes only legal names. This means in
practice that names passed into this interface are not touched here and
should be mangled previously (see module \module{mangle}). See the note
in \module{asm2} about future plans.

<<init type>>=
unit
@

<<module type personality>>=
module type PERSONALITY = sig
    val target: Target2.t
    type instr
    val  ext: instr -> Target2.t -> <<init type>> -> Ast.proc
end
@

<<asm2ast.mli>>=
<<module type personality>>

module Make (P: PERSONALITY): sig 
    include Asm2.S

    val ast: asm -> Ast.program         (* extra *)
end
    with type instruction = P.instr 
    with type init        = <<init type>>
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The assembler implementation is parameterized over its personality. 

<<asm2ast.ml>>=
<<module type personality>>

module Make (P: PERSONALITY) = struct
    type instruction = P.instr

    <<module make>>
end
@

The personality determines the native pointer-, and wordsize. The
following functions help to emit values. 

<<module make>>=
module T        = Target2
module A        = Ast

let pointer     = A.BitsTy(P.target.T.pointersize)
let bits n      = A.BitsTy n
let int n       = A.Int( Bits.of_int n P.target.T.wordsize
                       , Some (bits P.target.T.wordsize)
                       )
let one         = int 1 (* wordsize *)
let zero        = A.Int( Bits.of_int 0 P.target.T.memsize
                       , Some (bits P.target.T.memsize)
                       ) (* memsize *)
@

The [[Unsupported]] exception is raised when using features provided
by the interface, but not by this implementation.
 
<<module make>>=
exception Unsupported of string
let unsupported msg = raise (Unsupported msg)
@

This assembler creates {\PAL} output and therefore must respect the
{\PAL} syntax for names. The [[mangle]] value allows a client to build a
name mangler that respect the {\PAL} rules for names. 

<<module make>>=
let symbol = 
    let reserved =
        [ "aborts"; "align"; "aligned"; "also"; "as"; "big"; "byteorder";
        "case"; "const"; "continuation"; "cut"; "cuts"; "else"; "equal";
        "export"; "foreign"; "goto"; "if"; "import"; "invariant"; "jump";
        "little"; "memsize"; "pragma"; "register"; "return"; "returns";
        "section"; "semi"; "span"; "stackdata"; "switch"; "target"; "targets";
        "to"; "typedef"; "unicode"; "unwinds"; "float"; "charset";
        "pointersize"; "wordsize"]
    
    in
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '.' 
        | '_' 
        | '$' 
        | '@'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '@' 
    in    
        { Mangle.preprocess = (fun x -> x)
        ; Mangle.replace    = replace
        ; Mangle.reserved   = reserved
        ; Mangle.avoid      = (fun x -> x ^ "$")
        }

let mangle = Mangle.mk symbol   
@

An assembly program is represented by an [[asm]] value; it contains: 

\begin{itemize}
\item A symbol table: the assembler interface allows to create symbols
      that can be looked up later. Symbols are registered in the
      symbol table.

\item The name of the current section.

\item A list of actions belonging to the current action. For
      efficiency, actions are inserted at the front of the list. As a little
      reminder, the field name is primed:  [[actions']].  The list of
      actions is reversed we the section is closed.

\item A list of sections, making up the top level of the program. Again,
      the sections are in backward order for efficiency.  The [[ast]]
      function reverses this list before making it accessible for
      clients.
\end{itemize}

<<module make>>=
module Symbol = Str.Map

<<type symbol>>
and init = <<init type>>
and asm =       { symbols:      symbol Symbol.t
                ; section:      string
                ; actions':     A.section list
                ; toplevel':    (string * A.section list) list
                ; init:         init
                }
@

The initially empty {\PAL} program puts everything into the ``this can't
happen'' section.  This is admittedly ugly. 

<<module make>>=
let init (x:init) =
    { symbols           = Symbol.empty
    ; section           = "this can't happen"
    ; actions'          = []
    ; toplevel'         = []
    ; init              = x
    }
@

    
The assembler maintains a current section. To guarantee that
everything goes into a meaningful section, a client should define a
section as its first action.

<<module make>>=
let current asm = asm.section
@

A symbol falls in one of four classes. Symbols are simply created from
the names provided at their declaration. A binart emitter would do
something more complicated.

<<type symbol>>=
type symbol = 
    | Local    of string
    | Import   of string
    | Export   of string
    | Common   of string
@
 
<<module make>>=
let declare s sym asm = (sym, {asm with symbols = Symbol.add s sym asm.symbols})
let local  s asm      = declare s (Local s)  asm
let export s asm      = declare s (Export s) asm
let import s asm      = declare s (Import s) asm
let common s _        = unsupported "Asm2ast.common"
@

<<module make>>=
let lookup name asm = Symbol.find name asm.symbols
@

An assembly [[action]] roughly corresponds to an [[Ast.section]]. 
Unfortunately this correspondence does not always hold and thus
actions must be categorized.  The effect of the [[append]] function
that adds an action to an assembly program depends on the category of
an action.

<<module make>>=
type action     = NewSection    of string
                | CurSection    of A.section
                | Instruction   of instruction
                | Nop
@

The [[append]] function adds an [[action]] to an [[asm]] value.  It
looks at the category of an action and then creates a new [[asm]]
value.  Whenever a new section is started, the current list of actions
is reversed, before the now closed section is added \emph{in front} of
the list of sections.  This means, that each section is in the right
order, but the order of sections is still reversed.

<<module make>>=
let append asm = function
    | NewSection s -> 
        { asm with 
          toplevel' = ( match asm.actions' with 
                      | [] -> asm.toplevel'  (* drop empty section *)
                      | aa -> (asm.section, List.rev aa) :: asm.toplevel'
                      )
        ; section   = s
        ; actions'  = []             
        }
    
    | CurSection x ->
        { asm with actions' = x :: asm.actions' }
    
    | Instruction i ->  (* special case of current section *)
        let proc = A.Procedure(P.ext i P.target asm.init) in
        { asm with actions' = proc :: asm.actions' }

    | Nop          -> asm
@

The semantics of the following functions is mostly determined by the
assembly interface.  However, this translation to {\PAL} is imperfect
in some cases. 

[[section]] closes the [[current]] section and starts a new one.  The
names of sections are \emph{not} mangled before they are used in the
{\AST}.  For completeness, a \emph{no-operation} is provided.

<<module make>>=
let section s   = NewSection s
let nop         = Nop
@

Our assembler does not announce procedures.  Since instructions are
{\PAL} procedures, we rely on them to do The Right Thing.

<<module make>>=
type proc_info = unit
let proc () = Nop
@

{\PAL} provides no concept of a directly accessible location counter and
thus it can't be set.  Since all code we are generating here is outside
of procedures the [[align]] action must denote an alignment for data and
cannot denote an align statement.

<<module make>>=
let org    n = unsupported "no location counter in this implementation"
let align  n = CurSection(A.Datum(A.Align n))
@

We represent [[addloc]], which advances the location counter, by emitting
uninitialized data.

<<module make>>=
let addloc n = 
    let memsize = P.target.T.memsize in
    let ty      = bits memsize            in
    let size    = int n                   in
        CurSection(A.Datum(A.MemDecl(ty,A.FixSize(size),None)))
@
    

The actions related to symbols define new symbols, which are also entered
into the symbol table. The [[lookup]] function helps to find them.


We assume that the client is aware of the naming restrictions for labels
and thus just put them into the {\AST} \emph{without} mangling them.

<<module make>>=
let define_label = function
    | Local s  -> CurSection(A.Datum(A.Label s))
    | Export s -> CurSection(A.Datum(A.Label s))
    | _        -> assert false
    
let define_const s b = 
    let bits = A.Int(b,Some (bits (Bits.width b))) in
    match s with
    | Local s  -> CurSection(A.Decl(A.Const(None,s,bits)))  
    | Export s -> CurSection(A.Decl(A.Const(None,s,bits)))  
    | _        -> assert false
@

A link-time constant is an expression of the native pointer type or is
compile-time constant. Link-time expressions are simple, because very
operators are defined on link-time values.

<<module make>>=
module RelAddr = struct
    <<RelAddr>>
end

<<RelAddr>>=
type t   = A.expr
type sym = symbol 

let sym = function
    | Local l  -> A.Fetch (A.Var(None,l))   (*XXX ?? *)
    | Export l -> A.Fetch (A.Var(None,l))   (*XXX ?? *)
    | Import l -> A.Fetch (A.Var(None,l))   (*XXX ?? *)
    | _        -> assert false
    
let const k = A.Int(k, Some(A.BitsTy(Bits.width k)))
let add x y = A.PrimOp ("add", [(None,x);(None,y)])
let sub x y = A.PrimOp ("sub", [(None,x);(None,y)])

<<module make>>=
let instr i = Instruction i

@

The [[zeroes n]] function emits [[bits8[n]{0,0,...,0}]], where
[[bits8]] is the type for [[memsize]].

<<module make>>=
let zeroes n = 
    let memsize = P.target.T.memsize in
    let ty      = bits memsize            in
    let size    = int n                   in
    let rec z   = function
        | 0 -> []
        | n -> zero :: z (n-1)            in
    let init n  = Some(A.InitExprs(z n))  in
        if n = 0 
        then Nop
        else CurSection(A.Datum(A.MemDecl(ty,A.FixSize(size),init n)))

<<module make>>=
let value  v = 
    let ty   = bits (Bits.width v)              in
    let init = A.InitExprs([A.Int(v, Some ty)]) in
        CurSection(A.Datum(A.MemDecl(ty, A.FixSize one, Some init)))

<<module make>>=
let addr e  =
    let ty   = pointer          in      (* e is of native pointer type *)
    let init = A.InitExprs([e]) in
        CurSection(A.Datum(A.MemDecl(ty, A.FixSize one, Some init)))

<<module make>>=
let byteorder = match P.target.T.byteorder with
    | Rtl.BigEndian    -> Fenv.Clean.Big
    | Rtl.LittleEndian -> Fenv.Clean.Little
    | _                -> assert false
@

We can't emmit comments (at the moment), because the {\AST} provides
only a comment \emph{statement}.  Statements are part of procedures
which this code does not deal with.

<<module make>>=
let comment n = Nop
@

% ------------------------------------------------------------------ 
\subsection{Extras}
% ------------------------------------------------------------------         

The [[ast]] function provides the abstract {\PAL} syntax of the
``assembly'' program.  It closes the current section and reverse the
list of sections of [[asm.toplevel']] before returning them.

The program generated by the assembler interface inherits its
personality from the functor arguments [[P]] of type [[PERSONALITY]].
The personality is represented by an number of declarations at the
head of the program.

\begin{itemize}
\item [[target]] declarations announce the byte order and similar
      target dependent settings.

\item Hardware registers are declared as registers with hardware
      registers attached to them.
\end{itemize}

<<module make>>=
let personality =
    [ A.Memsize P.target.T.memsize
    ; ( match P.target.T.byteorder with
      | Rtl.BigEndian    -> A.ByteorderBig
      | Rtl.LittleEndian -> A.ByteorderLittle
      | _                -> assert false
      )
    ; A.PointerSize P.target.T.pointersize
    ; A.WordSize    P.target.T.wordsize
    ; A.Charset     P.target.T.charset
    ; A.FloatRepr   P.target.T.float
    ]
@

<<module make>>=
let globals p asm =
    let f name symbol names =
        if p symbol then name::names else names
    in
        Str.Map.fold f asm.symbols []
            
let exports asm = 
    match globals (function Export _ -> true | _ -> false) asm with
    | []    -> None
    | names -> Some (A.Export(Some pointer, List.map (fun n -> n, None) names))
        
let imports asm = 
    match globals (function Import _ -> true | _ -> false) asm with
    | []    -> None
    | names -> Some (A.Import(pointer, List.map (fun n -> None, n) names))


let ast asm = 
    let section  = (asm.section, List.rev asm.actions') in
    let toplevel = List.rev (section :: asm.toplevel')  in
    let sections = List.map (fun (name,sect) -> A.Section(name,sect)) 
                            toplevel                    in
    let target   = A.TopDecl(A.Target personality)      in
        match imports asm, exports asm with
        | None  , None   -> target :: sections
        | Some i, None   -> target :: A.TopDecl(i) :: sections
        | None  , Some e -> target :: A.TopDecl(e) :: sections
        | Some i, Some e -> target :: A.TopDecl(i) :: A.TopDecl(e) :: sections
        
@


