% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\input{../config/macros.tex}

% l2h substitution dots ...
% l2h substitution AST AST
% l2h substitution ast AST
% l2h substitution rtl RTL
% l2h substitution ir IR
% l2h substitution noweb NOWEB
% l2h substitution qcc QC--
% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution pal C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml
% l2h substitution forall forall
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>

% ------------------------------------------------------------------ 
\section{Implementation of the Abstract Assembler Interface}
% ------------------------------------------------------------------ 

The \module{asm2} describes an abstract interface to assemblers. This
module provides an implementation of that interface by representing
actions of the assembler in {\PAL}.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface is a sub-type of [[Asm2.S]]: it provides everything
outlined there.

An assembler reflects many of the characteristics of the underlying
target architecture.  Since {\PAL} is quite flexible with respect to
pointer sizes, byteorder and such, we like to functorize our
implementation over these aspects, which we call the
\emph{personality} of the assembler.  A functor seems to be a good
compromise between a fixed personality, and a run-time configured
personality.

The personality provides additionally an abstract representation of
instructions. In this specific implementation a single instruction is
used to implement an entire procedure. However, this implementation
requires a function [[ext]] thant translates an instruction to the
abstract syntax of a procedure. 

Names that are passed to the assembler become {\PAL} names in the output
and therefore must obey certain rules. We assume that the client side
knows about these rules and passes only legal names. This means in
practice that names passed into this interface are not touched here and
should be mangled previously (see module \module{mangle}).

The assembler is initialized with a value of type [[init]]. 

<<init type>>=
(optimizer: Cfg3.cfg -> Automaton.t -> unit)
@

<<module type personality>>=
module type PERSONALITY = sig
    val target: Target2.t
    type instr
    val  ext: instr -> Target2.t -> <<init type>> -> Ast.proc
end
@

<<asm2ast.mli>>=
<<module type personality>>

module Make (P: PERSONALITY): sig 
    include Asm2.S

    val ast: asm -> Ast.program         (* extra *)
end
    with type instruction = P.instr 
    with type init        = <<init type>>
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

It is a bit ironic, that the abstract interface to assemblers (module
\module{asm2}) does not match perfectly with the abstract syntax of
{\PAL}, the portable assembler. 

<<asm2ast.ml>>=
<<module type personality>>

module Make (P: PERSONALITY) = struct
    type instruction = P.instr

    <<module make>>
end

<<module make>>=
module T        = Target2
module A        = Ast
module Symbol   = Map.Make(struct type t=string let compare=compare end)
@

The [[Unsupported]] exception is raised when using features provided
by the interface, but not by this implementation.
 
<<module make>>=
exception Unsupported of string
let unsupported msg = raise (Unsupported msg)
@

This assembler creates {\PAL} output and therefore must respect the
{\PAL} syntax for names. The [[mangle]] value allows a client to build a
name mangler that respect the {\PAL} rules for names. 

<<module make>>=
let symbol = 
    let reserved =
        [ "aborts"; "align"; "aligned"; "also"; "as"; "big"; "byteorder";
        "case"; "const"; "continuation"; "cut"; "cuts"; "else"; "equal";
        "export"; "foreign"; "goto"; "if"; "import"; "invariant"; "jump";
        "little"; "memsize"; "pragma"; "register"; "return"; "returns";
        "section"; "semi"; "span"; "stackdata"; "switch"; "target"; "targets";
        "to"; "typedef"; "unicode"; "unwinds"; "float"; "charset";
        "pointersize"; "wordsize"]
    
    in
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '.' 
        | '_' 
        | '$' 
        | '@'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '@' 
    in    
        { Mangle.preprocess = (fun x -> x)
        ; Mangle.replace    = replace
        ; Mangle.reserved   = reserved
        ; Mangle.avoid      = (fun x -> x ^ "$")
        }
@

<<module make>>=
let mangle = Mangle.mk symbol   
@
    
The assembler maintains a current section. To guarantee that
everything goes into a meaningful section, the first action is to
start the [[text]] section.
                      
<<Make translate program>>=
let program env target asm tt = 
    let asm = asm ++ Asm.section "text"           in
    let asm = exports env asm                     in
    let asm = imports env asm                     in
        foldl (toplevel env target) asm tt


An assembler is not independent from the personality of the underlying
architecture. The personality module [[P]] provides us with the
necessary informations. The following functions helps to create types
and values in {\AST} syntax.

<<module make>>=
let pointer     = A.BitsTy(P.target.T.pointersize)
let bits n      = A.BitsTy n
let int n       = A.Int( Bits.of_int n P.target.T.wordsize
                       , Some (bits P.target.T.wordsize)
                       )
let one         = int 1 (* wordsize *)
let zero        = A.Int( Bits.of_int 0 P.target.T.memsize
                       , Some (bits P.target.T.memsize)
                       ) (* memsize *)
@

The following types for section names, sizes and alignments are
dictated by the assembly interface.

<<module make>>=
type section    = string
type size       = int
type align      = int
@

A [[sym]] value is created from the [[mksym]] function.  A [[symbol]]
represents a label that was registered in the assemblers symbol table.

<<module make>>=
type symclass   = Import        
                | Export
                | Local
                | Common of size * align * section
type symbol     = string * symclass
type sym        = Sym of string
@                

An assembler program is represented by an [[asm]] value; it contains: 

\begin{itemize}
\item A symbol table: the assembler interface allows to create symbols
      that can be looked up later. Symbols are registered in the
      symbol table.

\item The name of the current section.

\item A list of actions belonging to the current action. For
      efficiency, actions are inserted at the front of the list. As a little
      reminder, the field name is primed:  [[actions']].  The list of
      actions is reversed we the section is closed.

\item A list of sections, making up the top level of the program. Again,
      the sections are in backward order for efficiency.  The [[ast]]
      function reverses this list before making it accessible for
      clients.
\end{itemize}

<<module make>>=
type init = <<init type>>
type asm =      { symbols:      symbol Symbol.t
                ; section:      string
                ; actions':     A.section list
                ; toplevel':    (string * A.section list) list
                ; init:         init
                }
@

The initially empty {\PAL} program puts everything into the ``this
can't happen'' section.  This is admittedly ugly. 

<<module make>>=
let init (args:init) =
    { symbols           = Symbol.empty
    ; section           = "this can't happen"
    ; actions'          = []
    ; toplevel'         = []
    ; init              = args
    }
@

An assembly [[action]] roughly corresponds to an [[Ast.section]]. 
Unfortunately this correspondence does not always hold and thus
actions must be categorized.  The effect of the [[append]] function
that adds an action to an assembly program depends on the category of
an action.

<<module make>>=
type action     = NewSection    of string
                | CurSection    of A.section
                | Instruction   of instruction
                | DefSym        of symbol
                | Nop
@

The [[mksym]] function creates [[sym]] values.  Symbols ultimately
create {\PAL} names. We assume that the client only passes legal
(i.e.~mangled) names and thus don't touch them.

<<module make>>=
let mksym s    = Sym s
@

The [[append]] function adds an [[action]] to an [[asm]] value.  It
looks at the category of an action and then creates a new [[asm]]
value.  Whenever a new section is started, the current list of actions
is reversed, before the now closed section is added \emph{in front} of
the list of sections.  This means, that each section is in the right
order, but the order of sections is still reversed.

<<module make>>=
let append asm = function
    | NewSection s -> 
        { asm with 
          toplevel' = ( match asm.actions' with 
                      | [] -> asm.toplevel'  (* drop empty section *)
                      | aa -> (asm.section, List.rev aa) :: asm.toplevel'
                      )
        ; section   = s
        ; actions'  = []             
        }
    
    | CurSection x ->
        { asm with actions' = x :: asm.actions' }
    
    | Instruction i ->  (* special case of current section *)
        let proc = A.Procedure(P.ext i P.target asm.init) in
        { asm with actions' = proc :: asm.actions' }

    | DefSym (n,c) -> 
        if Symbol.mem n asm.symbols
        then asm
        else let actions = 
            ( match c with
            | Import   -> A.Decl(A.Import(pointer,[(None,n)])) :: asm.actions'
            | Export   -> A.Decl(A.Export(None,[(n,None)])) :: asm.actions'
            | Local    -> asm.actions' (* ignored - ok ?*)
            | Common _ -> asm.actions' (* ignored *)
            ) in { asm with 
                   actions' = actions
                 ; symbols = Symbol.add n (n,c) asm.symbols
                 }
    | Nop          -> asm
@

The semantics of the following functions is mostly determined by the
assembly interface.  However, this translation to {\PAL} is imperfect
in some cases. 

[[section]] closes the [[current]] section and starts a new one.  The
names of sections are \emph{not} mangled before they are used in the
{\AST}.

<<module make>>=
let section s   = NewSection s
let current asm = asm.section
@

For completeness, a \emph{no-operation} is provided.

<<module make>>=
let nop = Nop
@

Our assembler does not announce procedures.  Since instructions are
{\PAL} procedures, we rely on them to do The Right Thing.

<<module make>>=
type proc_info = unit
let proc () = Nop
@

{\PAL} provides no concept of a directly accessible location counter
and thus it can't be set.  Since all code we are generating here is
outside of procedures the [[align]] action must denote an alignment
for data and can not denote an align statement.

<<module make>>=
let org    n = unsupported "no location counter in this implementation"
let align  n = CurSection(A.Datum(A.Align n))
@

We represent [[addloc]] that advances the location counter by emitting
uninitialized data.

<<module make>>=
let addloc n = 
    let memsize = P.target.T.memsize in
    let ty      = bits memsize            in
    let size    = int n                   in
        CurSection(A.Datum(A.MemDecl(ty,A.FixSize(size),None)))
@
    

The actions related to symbols define new symbols, which are also entered
into the symbol table. The [[lookup]] function helps to find them.

<<module make>>=
let import (Sym n)                  = DefSym(n,Import)
let export (Sym n)                  = DefSym(n,Export)
let local  (Sym n)                  = DefSym(n,Local)
let common (Sym n) size algn sect   = DefSym(n,Common(size,algn,sect))
let lookup (Sym n) asm              = Symbol.find n asm.symbols
@

We assume that the client is aware of the naming restrictions for labels
and thus just put them into the {\AST} \emph{without} mangling them.

<<module make>>=
let define_label (n,c)      = CurSection(A.Datum(A.Label n))
let define_const (n,c) b    = 
    let bits = A.Int(b,Some (bits (Bits.width b))) 
    in CurSection(A.Decl(A.Const(None,n,bits)))  
let define_local (Sym n)    = CurSection(A.Datum(A.Label n))
@

A link-time constant is an expression of the native pointer type or is
compile-time constant. Link-time expressions are simple, because very
operators are defined on link-time values.

<<module make>>=
module RelAddr = struct
    <<RelAddr>>
end

<<RelAddr>>=
type t = A.expr

let sym   l = A.Fetch (A.Var(None,l))   (*XXX ?? *)
let const k = A.Int(k, Some(A.BitsTy(Bits.width k)))
let add x y = A.PrimOp ("add", [(None,x);(None,y)])
let sub x y = A.PrimOp ("sub", [(None,x);(None,y)])

<<module make>>=
let instr i = Instruction i

@

The [[zeroes n]] function emits [[bits8[n]{0,0,...,0}]], where
[[bits8]] is the type for [[memsize]].

<<module make>>=
let zeroes n = 
    let memsize = P.target.T.memsize in
    let ty      = bits memsize            in
    let size    = int n                   in
    let rec z   = function
        | 0 -> []
        | n -> zero :: z (n-1)            in
    let init n  = Some(A.InitExprs(z n))  in
        if n = 0 
        then Nop
        else CurSection(A.Datum(A.MemDecl(ty,A.FixSize(size),init n)))
<<module make>>=
let value  v = 
    let ty   = bits (Bits.width v)              in
    let init = A.InitExprs([A.Int(v, Some ty)]) in
        CurSection(A.Datum(A.MemDecl(ty, A.FixSize one, Some init)))
<<module make>>=
let addr e  =
    let ty   = pointer          in      (* e is of native pointer type *)
    let init = A.InitExprs([e]) in
        CurSection(A.Datum(A.MemDecl(ty, A.FixSize one, Some init)))

<<module make>>=
let byteorder = match P.target.T.byteorder with
    | Rtl.BigEndian    -> Fenv.Clean.Big
    | Rtl.LittleEndian -> Fenv.Clean.Little
    | _                -> assert false
@

We can't emmit comments (at the moment), because the {\AST} provides
only a comment \emph{statement}.  Statements are part of procedures
which this code does not deal with.

<<module make>>=
let comment n = Nop
@

% ------------------------------------------------------------------ 
\subsection{Extras}
% ------------------------------------------------------------------         

The [[ast]] function provides the abstract {\PAL} syntax of the
``assembly'' program.  It closes the current section and reverse the
list of sections of [[asm.toplevel']] before returning them.

The program generated by the assembler interface inherits its
personality from the functor arguments [[P]] of type [[PERSONALITY]].
The personality is represented by an number of declarations at the
head of the program.

\begin{itemize}
\item [[target]] declarations announce the byte order and similar
      target dependent settings.

\item Hardware registers are declared as registers with hardware
      registers attached to them.
\end{itemize}

<<module make>>=
let personality =
    [ A.Memsize P.target.T.memsize
    ; ( match P.target.T.byteorder with
      | Rtl.BigEndian    -> A.ByteorderBig
      | Rtl.LittleEndian -> A.ByteorderLittle
      | _                -> assert false
      )
    ; A.PointerSize P.target.T.pointersize
    ; A.WordSize    P.target.T.wordsize
    ; A.Charset     P.target.T.charset
    ; A.FloatRepr   P.target.T.float
    ]
@

<<module make>>=
let ast asm = 
    let section  = (asm.section, List.rev asm.actions') in
    let toplevel = List.rev (section :: asm.toplevel')  in
    let sections = List.map (fun (name,sect) -> A.Section(name,sect)) 
                            toplevel                    in
    let target   = A.TopDecl(A.Target personality)      in
        target :: sections
@


