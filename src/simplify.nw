% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% Come for the emacs, stay for the vim: ts=8 sw=4 et: 

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{RTL Constant Folding}
% ------------------------------------------------------------------ 

An {\rtl} expression can denote a compile-time, link-time, or run-time
value. The goal is to evaluate any {\rtl} expression as early as
possible to minimize computation at run-time. This module provides
routines to evaluate {\rtl} expressions and to simplify {\rtl}s by
evaluating expressions inside of them. The promise is, that the returned
{\rtl}s and expressions are simpler as the ones provided.

<<simplify.mli>>=
val rtl:    Rtl.rtl -> Rtl.rtl
val exp:    Rtl.exp -> Rtl.exp
val bits:   Rtl.exp -> Bits.bits    (* Error.ErrorExn, convenient function *)
val bool:   Rtl.exp -> bool         (* Error.ErrorExn, convenient function *)
@

The [[Unsafe]] module provides an simplification of {\rtl}s tries to
evaluate guarding expressions by elimination of registers in relations
of the form $r+k = r+k'$. However, this elimination is not semantics
preserving if the $r+k$ would overflow, but $k$ not.  

<<simplify.mli>>=
module Unsafe: sig
    val rtl:    Rtl.rtl -> Rtl.rtl
end
@

We export the list of operators we can evaluate at compile time. 

<<simplify.mli>>=
val compile_time_ops: string list
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation relies on the following idea: we evaluate an
expression (or {\rtl}) bottom up as far as possible. The final result
will tell us whether it needs further ecaluation at link-time or
run-time.

<<simplify.ml>>=
module RS = Reloc.Simple
module R  = Rtl
module RP = Rtl.Private
module D  = Rtl.Dn 
module U  = Rtl.Up

exception Error of string
type reloc     = Bits.bits RS.relocatable

let error msg  = raise (Error msg)
let impossible = Impossible.impossible

module Safe = struct
    <<RTL operator implementations>>
    <<traverse RTL>>
end    
@

The [[Unsafe]] module implements a more agressive simplification of
{\rtl}s that requires certain pre-conditions to be met. In particular,
it tries to evaluate guarding relational expressions like $r+k < r+k'$.
The simplification assumes that it is safe to eliminate the $r$ on both
sides of the $<$ operator.

<<simplify.ml>>=
module Unsafe = struct
    <<unsafe RTL simplification>>
end
@

The exported function work on the public representation of {\rtl}s

<<simplify.ml>>=
let rtl r  = try U.rtl (Safe.rtl (D.rtl r))
             with Error msg -> Impossible.impossible msg

let exp e  = try U.exp (Safe.exp (D.exp e))
             with Error msg -> Impossible.impossible msg

let bits e = match Safe.exp (D.exp e) with
             | RP.Const(RP.Bits(b)) -> b
             | _                    -> Error.error "not a constant value"
             
let bool e = match Safe.exp (D.exp e) with
             | RP.Const(RP.Bool(b)) -> b
             | _                    -> Error.error "not a constant condition"

let compile_time_ops = 
    [ "add"; "and"; "div"; "eq"; "mul"; "neg"; "ne"; "shl"; "shra";
      "shrl"; " sub"; "sx"]
@

% ------------------------------------------------------------------ 
\subsection{RTL Traversal}
% ------------------------------------------------------------------ 

All operator implementations have an easy way out: they just construct a
run-time expression from their arguments and return it. 

<<RTL operator implementations>>=
let default op w args = RP.App((op,w),args)

<<traverse RTL>>=   
let app o w args = match o with
    |  "NaN" 		-> default o w args
    |  "add" 		-> add w args
    |  "and" 		-> default o w args
    |  "bit" 		-> default o w args
    |  "bool" 		-> default o w args
    |  "borrow" 	-> default o w args
    |  "carry" 		-> default o w args
    |  "com" 		-> default o w args
    |  "conjoin" 	-> default o w args
    |  "disjoin" 	-> default o w args
    |  "div" 		-> default o w args
    |  "divu" 		-> default o w args
    |  "eq" 		-> eq w args
    |  "f2f" 		-> default o w args
    |  "f2i" 		-> default o w args
    |  "fabs" 		-> default o w args
    |  "fadd" 		-> default o w args
    |  "fcmp" 		-> default o w args
    |  "fdiv" 		-> default o w args
    |  "feq" 		-> default o w args
    |  "fge" 		-> default o w args
    |  "fgt" 		-> default o w args
    |  "fle" 		-> default o w args
    |  "float_eq" 	-> default o w args
    |  "float_gt" 	-> default o w args
    |  "float_lt" 	-> default o w args
    |  "flt" 		-> default o w args
    |  "fmul" 		-> default o w args
    |  "fmulx" 		-> default o w args
    |  "fne" 		-> default o w args
    |  "fneg" 		-> default o w args
    |  "fordered" 	-> default o w args
    |  "fsqrt" 		-> default o w args
    |  "fsub" 		-> default o w args
    |  "funordered" 	-> default o w args
    |  "ge" 		-> default o w args
    |  "geu" 		-> default o w args
    |  "gt" 		-> gt  w args
    |  "gtu" 		-> gtu w args
    |  "i2f" 		-> default o w args
    |  "le" 		-> default o w args
    |  "leu" 		-> default o w args
    |  "lobits" 	-> default o w args
    |  "lt" 		-> lt w args
    |  "ltu" 		-> ltu w args
    |  "minf" 		-> default o w args
    |  "mod" 		-> default o w args
    |  "modu" 		-> default o w args
    |  "mul" 		-> default o w args
    |  "mul_trunc" 	-> mul_trunc w args
    |  "mulu" 		-> default o w args
    |  "mzero" 		-> default o w args
    |  "ne" 		-> ne  w args
    |  "neg" 		-> neg w args
    |  "not" 		-> default o w args
    |  "or" 		-> default o w args
    |  "pinf" 		-> default o w args
    |  "popcnt" 	-> default o w args
    |  "pzero" 		-> default o w args
    |  "quot" 		-> default o w args
    |  "rem" 		-> default o w args
    |  "rotl" 		-> default o w args
    |  "rotr" 		-> default o w args
    |  "round_down" 	-> round_down w args
    |  "round_nearest" 	-> round_nearest w args
    |  "round_up" 	-> round_up w args
    |  "round_zero" 	-> round_zero w args
    |  "shl" 		-> shl w args
    |  "shra" 		-> shra w args
    |  "shrl" 		-> default o w args
    |  "sub" 		-> sub w args
    |  "sx" 		-> sx w args
    |  "unordered" 	-> default o w args
    |  "xor" 		-> default o w args
    |  "zx" 		-> zx w args
    |  "bitExtract" 	-> default o w args
    |  "bitInsert" 	-> default o w args
    |  "bitTransfer" 	-> default o w args
    |  o                -> default o w args
                      
let rec exp = function
    | RP.Const _ as c               -> c
    | RP.Fetch (l, w)               -> RP.Fetch (loc l, w)
    | RP.App ((o,w),args)           -> app o w (List.map exp args) 
        
and loc = function    
    | RP.Mem(sp, agg, w, e, ass)    -> RP.Mem(sp, agg, w, exp e, ass)
    | RP.Slice(w,i,l)               -> RP.Slice(w, i, loc l)
    | RP.Reg(sp, i, w) as v         -> v
    | RP.Var(s,i,w) as v            -> v

let effect = function
    | RP.Store(l,e,w)               -> RP.Store(loc l, exp e, w)
    | RP.Kill(l)                    -> RP.Kill(loc l)


let guarded (e, eff)                = (exp e, effect eff)
let rtl (RP.Rtl(es))                = RP.Rtl(List.map guarded es)
@

% ------------------------------------------------------------------ 
\subsection{Unsafe Simplification}
% ------------------------------------------------------------------ 

[[reg_offset]] recognizes a $r+k$ expression, where $r$ is a register
and $k$ a constant, and returns either boths as a pair, or [[None]].

<<unsafe RTL simplification>>=
let zero w = RP.Const(RP.Bits (Bits.U.of_int 0 w))
let reg_offset = function
    | RP.App(("add", _), [RP.Fetch(RP.Reg(r),_); RP.Const(_) as k]) -> 
        Some (r,k)
    | RP.Fetch(RP.Reg r, w) -> Some (r, zero w)
    | _                     -> None
@
<<unsafe RTL simplification>>=
let rec app o w args = match Safe.app o w args with
    | RP.App (("ne"|"eq"|"ltu"|"gtu"|"lt"|"gt" as op, w), [left;right]) as x ->
        ( match reg_offset left, reg_offset right with
        | Some(r1,k1), Some(r2,k2) when r1 = r2 -> 
            let r      = app op w [k1;k2] in
            let dbg () = Verbose.say 5 [
                         Printf.sprintf "Simplify2.Unsafe.app: %s `%s` %s = %s\n"
                        (Rtlutil.ToReadableString.exp (Rtl.Up.exp k1))
                        op
                        (Rtlutil.ToReadableString.exp (Rtl.Up.exp k2))
                        (Rtlutil.ToReadableString.exp (Rtl.Up.exp r))]
            in r
               
        | _  -> x
        )
    | x -> x

let rec exp = function
    | RP.Const _ as c               -> c
    | RP.Fetch (l, w)               -> RP.Fetch (loc l, w)
    | RP.App ((o,w),args)           -> app o w (List.map exp args) 
        
and loc = function
    | RP.Mem(sp, agg, w, e, ass)    -> RP.Mem(sp, agg, w, exp e, ass)
    | RP.Slice(w,i,l)               -> RP.Slice(w, i, loc l)
    | RP.Reg(sp, i, w) as v         -> v
    | RP.Var(s,i,w) as v            -> v

let effect = Safe.effect

let guarded (e, eff)                = (exp e, effect eff)
let rtl' (RP.Rtl(es))               =
  let add_guarded e es = match guarded e with
    | RP.Const(RP.Bool false), _ -> es
    | e                          -> e :: es in
  RP.Rtl(List.fold_right add_guarded es [])

(*let rtl' (RP.Rtl es) = RP.Rtl (List.map guarded es)*)

let rtl r  = try U.rtl (rtl' (D.rtl r)) 
             with Error msg -> Impossible.impossible msg

@

% ------------------------------------------------------------------ 
\subsection{RTL Operator Implementations}
% ------------------------------------------------------------------ 

Here are some helper functions used below.

<<RTL operator implementations>>=
let int64 = function
    | RP.Const(RP.Bits(x)) -> Bits.S.to_int64 x
    | _                    -> assert false

let uint64 = function
    | RP.Const(RP.Bits(x)) -> Bits.U.to_int64 x
    | _                    -> assert false

let int = function
    | RP.Const(RP.Bits(x)) -> Bits.S.to_int x
    | _                    -> assert false

let to_bits i w = RP.Const(RP.Bits(Bits.S.of_int64 i w))
let to_bool b   = RP.Const(RP.Bool(b)) 

let const k     = RP.Const(RP.Bits(k))

let is_bits = function
    | RP.Const(RP.Bits(_)) -> true
    | _                    -> false
@

\paragraph{IEEE 754 Constants} How a rounding mode is represented is
implementation specific. We just pick four values here.

<<RTL operator implementations>>=
let round_down    w args = RP.Const(RP.Bits(Bits.U.of_int 3 2))
let round_up      w args = RP.Const(RP.Bits(Bits.U.of_int 2 2))
let round_nearest w args = RP.Const(RP.Bits(Bits.U.of_int 1 2))
let round_zero    w args = RP.Const(RP.Bits(Bits.U.of_int 0 2))

let rec add ws args = 
    let w = match ws with [w] -> w | _ -> Impossible.impossible "ill-typed add" in
    match args with
    | [ RP.App(("add", ws'), [x; RP.Const (RP.Bits k)]); RP.Const (RP.Bits k') ] ->  
                assert (ws=ws');
                add ws [x; RP.Const (RP.Bits (Bits.Ops.add k k'))]
    | [RP.Const (RP.Bits x); RP.Const (RP.Bits y)] ->  
                RP.Const (RP.Bits (Bits.Ops.add x y))
    | [x; RP.Const (RP.Bits y)] when Bits.Ops.eq (Bits.U.of_int 0 w) y -> x
    | args  ->  default "add" ws args

let shra w = function
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                 -> const (Bits.Ops.shra x y)
    | args       -> default "shra" w args

let mul_trunc w = function
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                -> const (Bits.Ops.mul_trunc x y)
    | args      -> default "mul_trunc" w args  

let eq w = function
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                -> to_bool (Bits.Ops.eq x y)
    | args      -> default "eq" w args
    
let ne w = function
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                -> to_bool (Bits.Ops.ne x y)
    | args      -> default "ne" w args
    
let neg ws = function
    | [RP.Const(RP.Bits(x))] 
                -> const (Bits.Ops.neg x)
    | args      -> default "neg" ws args
    

let shl w args  = match (w,args) with
    | [w], [x;y] when is_bits x && is_bits y 
                -> to_bits (Int64.shift_left (int64 x) (int y)) w 
    | _         -> default "shl" w args
let sub w = function
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                -> const (Bits.Ops.sub x y)
    | args      -> default "sub" w args
    
let sx w args   = match (w,args) with
    | [i;j],[RP.Const(RP.Bits(x))]
                -> const (Bits.Ops.sx j x)
    | _         -> default "sx" w args

let zx w args   = match (w,args) with
    | [i;j],[RP.Const(RP.Bits(x))]
                -> const (Bits.Ops.zx j x)
    | _         -> default "zx" w args

let ltu w = function 
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                -> to_bool (Bits.Ops.ltu x y)
    | args      -> default "ltu" w args

let gtu w = function
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                -> to_bool (Bits.Ops.gtu x y)
    | args      -> default "gtu" w args

let lt w = function
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))] 
                -> to_bool (Bits.Ops.lt x y)
    | args      -> default "lt" w args

let gt w = function
    | [RP.Const(RP.Bits(x)); RP.Const(RP.Bits(y))]
                -> to_bool (Bits.Ops.gt x y)
    | args      -> default "gt" w args
    

@
