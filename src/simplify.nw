% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% Come for the emacs, stay for the vim: ts=8 sw=4 et: 

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{RTL Constant Folding}
% ------------------------------------------------------------------ 

An {\rtl} expression can denote a compile-time, link-time, or run-time
value. The goal is to evaluate any {\rtl} expression as early as
possible to minimize computation at run-time. This module provides
routines to evaluate {\rtl} expressions and to simplify {\rtl}s by
evaluating expressions inside of them. The promise is, that the returned
{\rtl}s and expressions are simpler as the ones provided.

<<simplify.mli>>=
val rtl:    Rtl.rtl -> Rtl.rtl
val exp:    Rtl.exp -> Rtl.exp
val bits:   Rtl.exp -> Bits.bits    (* Error.ErrorExn, convenient function *)
val link:   Rtl.exp -> Bits.bits Reloc.Simple.relocatable
val bool:   Rtl.exp -> bool         (* Error.ErrorExn, convenient function *)
@

The [[Unsafe]] module provides an simplification of {\rtl}s tries to
evaluate guarding expressions by elimination of registers in relations
of the form $r+k = r+k'$. However, this elimination is not semantics
preserving if the $r+k$ would overflow, but $k$ not.  

<<simplify.mli>>=
module Unsafe: sig
    val rtl:    Rtl.rtl -> Rtl.rtl
end
@

We export the list of operators we can evaluate at compile time. 

<<simplify.mli>>=
val compile_time_ops: string list
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation relies on the following idea: we evaluate an
expression (or {\rtl}) bottom up as far as possible. The final result
will tell us whether it needs further ecaluation at link-time or
run-time.

<<simplify.ml>>=
module BO = Bits.Ops
module RS = Reloc.Simple
module R  = Rtl
module RP = Rtl.Private
module D  = Rtl.Dn 
module U  = Rtl.Up

exception Error of string
type reloc     = Bits.bits RS.relocatable

let error msg  = raise (Error msg)
let impossible = Impossible.impossible

module Safe = struct
    <<RTL operator implementations>>
    <<traverse RTL>>
end    
@

The [[Unsafe]] module implements a more agressive simplification of
{\rtl}s that requires certain pre-conditions to be met. In particular,
it tries to evaluate guarding relational expressions like $r+k < r+k'$.
The simplification assumes that it is safe to eliminate the $r$ on both
sides of the $<$ operator.

<<simplify.ml>>=
module Unsafe = struct
    <<unsafe RTL simplification>>
end
@

The exported function work on the public representation of {\rtl}s

<<simplify.ml>>=
let rtl r  = try U.rtl (Safe.rtl (D.rtl r))
             with Error msg -> Impossible.impossible msg

let exp e  = try U.exp (Safe.exp (D.exp e))
             with Error msg -> Impossible.impossible msg

let rec location_category = function
  | RP.Mem _ -> "memory"
  | RP.Reg _ -> "a machine register"
  | RP.Var (name, _, _) | RP.Global (name, _, _) ->
      Printf.sprintf "register variable '%s'" name
  | RP.Slice (_, _, loc) -> location_category loc

let bits e =
  let rec cvt = function
    | RP.Const (RP.Bits b) -> b
    | RP.Const (RP.Bool _) -> Error.error "a constant expression may not be a Boolean"
    | RP.Const (RP.Link (s, _, _)) ->
        Error.errorf "constant %s not resolvable until link time" s#original_text
    | RP.Const (RP.Diff (_, _)) ->
        Error.errorf "difference of two constants not resolvable until link time"
    | RP.Const (RP.Late (s, _)) ->
        Error.errorf "late compile-time constant %s is not a constant yet" s
    | RP.Fetch (l, _) ->
        Error.errorf "a constant expression may not refer to %s"
          (location_category l)
    | RP.App ((opr, _), es) ->
        List.iter (fun e -> ignore (cvt e)) es;
        Error.errorf "cannot evaluate operator %%%s at compile time" opr in
  cvt (Safe.exp (D.exp e))
             
let bool e = match Safe.exp (D.exp e) with
             | RP.Const(RP.Bool(b)) -> b
             | _                    -> Error.error "not a constant condition"

let mklink kind s w = U.exp (RP.Const (RP.Link(s, kind, w)))

let link e = match Safe.exp (D.exp e) with
| RP.Const(RP.Bits b)   -> Reloc.Simple.of_const b
| RP.Const(RP.Link(l,kind,w)) -> Reloc.Simple.of_sum (mklink kind) l (Bits.zero w)
| RP.Const(RP.Diff(c1,c2)) ->
    Impossible.unimp "difference of link-time constants"
| RP.App(("add",_),[RP.Const(RP.Link(l,kind,w)); RP.Const(RP.Bits(b))]) ->
    Reloc.Simple.of_sum (mklink kind) l b
| RP.App(("sub",_),[RP.Const(RP.Link(l,kind,w)); RP.Const(RP.Bits(b))]) ->
    Reloc.Simple.of_sum (mklink kind) l (Bits.Ops.neg b)
| RP.App(("sub",_),[RP.Const(RP.Link(l,_,w)); RP.Const(RP.Link(l',_,w'))]) ->
    Impossible.unimp "difference of link-time constants"
| _ ->
    Error.error ("Bad link-time constant " ^ Rtlutil.ToReadableString.exp e)

let compile_time_ops = 
    [ "add"; "and"; "com"; "divu"; "eq"; "ge"; "geu"; "gt"; "gtu"; "le"; "leu";
      "lobits"; "lt"; "ltu"; "mul"; "ne"; "neg"; "or"; "shl"; "shra";
      "shrl"; " sub"; "sx"; "xor"; "zx"]
@

% ------------------------------------------------------------------ 
\subsection{RTL Traversal}
% ------------------------------------------------------------------ 

All operator implementations have an easy way out: they just construct a
run-time expression from their arguments and return it. 

<<RTL operator implementations>>=
let default op w args = RP.App((op,w),args)

<<traverse RTL>>=   
let app o w args = match o with
    |  "NaN" 		-> default o w args
    |  "add" 		-> add w args
    |  "and" 		-> binop o w BO.and' args
    |  "bit" 		-> bit  w args
    |  "bool" 		-> bool w args
    |  "borrow" 	-> default o w args
    |  "carry" 		-> default o w args
    |  "com" 		-> unop o w BO.com args
    |  "conjoin" 	-> conjoin w args
    |  "disjoin" 	-> disjoin w args
    |  "div" 		-> default o w args
    |  "divu" 		-> binop o w BO.divu args
    |  "eq" 		-> cmp_bits o w BO.eq args
    |  "f2f" 		-> default o w args
    |  "f2i" 		-> default o w args
    |  "fabs" 		-> default o w args
    |  "fadd" 		-> default o w args
    |  "fcmp" 		-> default o w args
    |  "fdiv" 		-> default o w args
    |  "feq" 		-> default o w args
    |  "fge" 		-> default o w args
    |  "fgt" 		-> default o w args
    |  "fle" 		-> default o w args
    |  "float_eq" 	-> default o w args
    |  "float_gt" 	-> default o w args
    |  "float_lt" 	-> default o w args
    |  "flt" 		-> default o w args
    |  "fmul" 		-> default o w args
    |  "fmulx" 		-> default o w args
    |  "fne" 		-> default o w args
    |  "fneg" 		-> default o w args
    |  "fordered" 	-> default o w args
    |  "fsqrt" 		-> default o w args
    |  "fsub" 		-> default o w args
    |  "funordered" 	-> default o w args
    |  "ge" 		-> cmp_bits o w (fun x y -> BO.lt  y x) args
    |  "geu" 		-> cmp_bits o w (fun x y -> BO.ltu y x) args
    |  "gt" 		-> cmp_bits o w BO.gt args
    |  "gtu" 		-> cmp_bits o w BO.gtu args
    |  "i2f" 		-> default o w args
    |  "le" 		-> cmp_bits o w (fun x y -> BO.gt  y x) args
    |  "leu" 		-> cmp_bits o w (fun x y -> BO.gtu y x) args
    |  "lobits" 	-> lobits w args
    |  "lt" 		-> cmp_bits o w BO.lt args
    |  "ltu" 		-> cmp_bits o w BO.ltu args
    |  "minf" 		-> default o w args
    |  "mod" 		-> default o w args
    |  "modu" 		-> default o w args
    |  "mul"     	-> binop o w BO.mul args
    |  "mulux" 		-> default o w args
    |  "mulx" 		-> default o w args
    |  "mzero" 		-> default o w args
    |  "ne" 		-> cmp_bits o w BO.ne args
    |  "neg" 		-> unop  o w BO.neg args
    |  "not" 		-> not' w args
    |  "or" 		-> binop o w BO.or' args
    |  "pinf" 		-> default o w args
    |  "popcnt" 	-> default o w args
    |  "pzero" 		-> default o w args
    |  "quot" 		-> default o w args
    |  "rem" 		-> default o w args
    |  "rotl" 		-> default o w args
    |  "rotr" 		-> default o w args
    |  "round_down" 	-> round_down w args
    |  "round_nearest" 	-> round_nearest w args
    |  "round_up" 	-> round_up w args
    |  "round_zero" 	-> round_zero w args
    |  "shl" 		-> binop o w BO.shl args
                               (* likely to break machine invariant on PPC? *)

    |  "shra" 		-> binop o w BO.shra args
    |  "shrl" 		-> binop o w BO.shrl args
    |  "sub" 		-> sub w args
    |  "sx" 		-> sx w args
    |  "unordered" 	-> default o w args
    |  "xor" 		-> binop o w BO.xor args
    |  "zx" 		-> zx w args
    |  "bitExtract" 	-> default o w args
    |  "bitInsert" 	-> default o w args
    |  "bitTransfer" 	-> default o w args
    |  o                -> default o w args
                      
let rec exp e =
    match e with
    | RP.Const _ as c               -> c
    | RP.Fetch (l, w)               -> RP.Fetch (loc l, w)
    | RP.App ((o,w),args)           -> app o w (List.map exp args) 
        
and loc = function    
    | RP.Mem(sp, agg, w, e, ass)    -> RP.Mem(sp, agg, w, exp e, ass)
    | RP.Slice(w,i,l)               -> RP.Slice(w, i, loc l)
    | RP.Reg(sp, i, w) as v         -> v
    | RP.Var   (s,i,w) as v         -> v
    | RP.Global(s,i,w) as v         -> v

let effect = function
    | RP.Store(l,e,w)               -> RP.Store(loc l, exp e, w)
    | RP.Kill(l)                    -> RP.Kill(loc l)

let guarded (e, eff)                = (exp e, effect eff)
let rtl (RP.Rtl(es))                = RP.Rtl(List.map guarded es)
@

% ------------------------------------------------------------------ 
\subsection{Unsafe Simplification}
% ------------------------------------------------------------------ 

[[reg_offset]] recognizes a $r+k$ expression, where $r$ is a register
and $k$ a constant, and returns either boths as a pair, or [[None]].

<<unsafe RTL simplification>>=
let zero w = RP.Const(RP.Bits (Bits.U.of_int 0 w))
let reg_offset = function
    | RP.App(("add", _), [RP.Fetch(RP.Reg(r),_); RP.Const(_) as k]) -> 
        Some (r,k)
    | RP.Fetch(RP.Reg r, w) -> Some (r, zero w)
    | _                     -> None
@
<<unsafe RTL simplification>>=
let rec app o w args = match Safe.app o w args with
    | RP.App (("ne"|"eq"|"ltu"|"gtu"|"lt"|"gt" as op, w), [left;right]) as x ->
        ( match reg_offset left, reg_offset right with
        | Some(r1,k1), Some(r2,k2) when r1 = r2 -> 
            let r      = app op w [k1;k2] in
            let dbg () = Printf.eprintf "Simplify2.Unsafe.app: %s `%s` %s = %s\n"
                        (Rtlutil.ToReadableString.exp (Rtl.Up.exp k1))
                        op
                        (Rtlutil.ToReadableString.exp (Rtl.Up.exp k2))
                        (Rtlutil.ToReadableString.exp (Rtl.Up.exp r)) in
            r
               
        | _  -> x
        )
    | x -> x

let rec exp = function
    | RP.Const _ as c               -> c
    | RP.Fetch (l, w)               -> RP.Fetch (loc l, w)
    | RP.App ((o,w),args)           -> app o w (List.map exp args) 
        
and loc = function
    | RP.Mem(sp, agg, w, e, ass)    -> RP.Mem(sp, agg, w, exp e, ass)
    | RP.Slice(w,i,l)               -> RP.Slice(w, i, loc l)
    | RP.Reg(sp, i, w) as v         -> v
    | RP.Var   (s,i,w) as v         -> v
    | RP.Global(s,i,w) as v         -> v

let effect = Safe.effect

let guarded (e, eff)                = (exp e, effect eff)
let rtl' (RP.Rtl(es))               =
  let add_guarded e es = match guarded e with
    | RP.Const(RP.Bool false), _ -> es
    | e                          -> e :: es in
  RP.Rtl(List.fold_right add_guarded es [])

(*let rtl' (RP.Rtl es) = RP.Rtl (List.map guarded es)*)

let rtl r  = try U.rtl (rtl' (D.rtl r)) 
             with Error msg -> Impossible.impossible msg

@

% ------------------------------------------------------------------ 
\subsection{RTL Operator Implementations}
% ------------------------------------------------------------------ 

Here are some helper functions used below.

<<RTL operator implementations>>=
let to_bool b = RP.Const (RP.Bool b) 
let const k   = RP.Const (RP.Bits k)
@

\paragraph{IEEE 754 Constants} How a rounding mode is represented is
implementation specific. We just pick four values here.

<<RTL operator implementations>>=
let round_down    w args = RP.Const(RP.Bits(Bits.U.of_int 3 2))
let round_up      w args = RP.Const(RP.Bits(Bits.U.of_int 2 2))
let round_nearest w args = RP.Const(RP.Bits(Bits.U.of_int 1 2))
let round_zero    w args = RP.Const(RP.Bits(Bits.U.of_int 0 2))
<<RTL operator implementations>>=
let rec add ws args = 
    let w = match ws with [w] -> w | _ -> Impossible.impossible "ill-typed add" in
    match args with
    | [ RP.App(("add", ws'), [x; RP.Const (RP.Bits k)]); RP.Const (RP.Bits k') ] ->  
                assert (ws=ws');
                add ws [x; RP.Const (RP.Bits (Bits.Ops.add k k'))]
    | [RP.Const (RP.Bits x); RP.Const (RP.Bits y)] ->  
                RP.Const (RP.Bits (Bits.Ops.add x y))
    | [x; RP.Const (RP.Bits y)] when Bits.Ops.eq (Bits.U.of_int 0 w) y -> x
    | args  ->  default "add" ws args

let sub ws args =
  let rec remove_one y xs = match xs with
  | [] -> Impossible.impossible "did not find removable expression"
  | x :: xs when y = x -> xs
  | x :: xs -> x :: remove_one y xs in
  let w = match ws with [w] -> w | _ -> Impossible.impossible "ill-typed sub" in
  match args with
  | [RP.Const(RP.Bits x); RP.Const(RP.Bits y)] -> const (Bits.Ops.sub x y)
  | [RP.App(("add",ws'),args); e] when List.mem e args ->
    (match remove_one e args with
    | _::_::_ as rst -> add ws' rst
    | [a]            -> a
    | []             -> RP.Const(RP.Bits(Bits.zero w))
    )
  | [x; y] when x = y -> RP.Const(RP.Bits(Bits.zero w))
  | args      -> default "sub" ws args
<<RTL operator implementations>>=
let binop name w op = function
    | [RP.Const(RP.Bits x); RP.Const(RP.Bits y)] -> const (op x y)
    | args       -> default name w args
<<RTL operator implementations>>=
let disjoin w = function
    | [RP.Const(RP.Bool true); _] -> RP.Const(RP.Bool true)
    | [_; RP.Const(RP.Bool true)] -> RP.Const(RP.Bool true)
    | [RP.Const(RP.Bool false); p] -> p
    | [p; RP.Const(RP.Bool false)] -> p
    | args       -> default "disjoin" w args

let conjoin w = function
    | [RP.Const(RP.Bool false); _] -> RP.Const(RP.Bool false)
    | [_; RP.Const(RP.Bool false)] -> RP.Const(RP.Bool false)
    | [RP.Const(RP.Bool true); p] -> p
    | [p; RP.Const(RP.Bool true)] -> p
    | args       -> default "conjoin" w args
<<RTL operator implementations>>=
let not' w = function
    | [RP.Const(RP.Bool b)] -> RP.Const(RP.Bool (not b))
    | args       -> default "not" w args
<<RTL operator implementations>>=
let cmp_bits name w op = function
    | [RP.Const(RP.Bits x); RP.Const(RP.Bits y)] -> to_bool (op x y)
    | args       -> default name w args
<<RTL operator implementations>>=
let unop name w op = function
    | [RP.Const(RP.Bits x)] -> const (op x)
    | args       -> default name w args
<<RTL operator implementations>>=
<<RTL operator implementations>>=    
let or' ws args = 
    let w = match ws with [w] -> w | _ -> Impossible.impossible "ill-typed or" in
    match args with
    | [RP.Const (RP.Bits x); RP.Const (RP.Bits y)] ->  
                RP.Const (RP.Bits (Bits.Ops.or' x y))
    | [x; RP.Const (RP.Bits y)] when Bits.Ops.eq (Bits.U.of_int 0 w) y -> x
    | [RP.Const (RP.Bits x); y] when Bits.Ops.eq (Bits.U.of_int 0 w) x -> y
    | args  ->  default "or" ws args

let and' ws args = 
    let w = match ws with [w] -> w | _ -> Impossible.impossible "ill-typed and" in
    match args with
    | [RP.Const (RP.Bits x); RP.Const (RP.Bits y)] ->  
                RP.Const (RP.Bits (Bits.Ops.and' x y))
    | [x; RP.Const (RP.Bits y) as zero] when Bits.Ops.eq (Bits.U.of_int 0 w) y -> zero
    | [RP.Const (RP.Bits x) as zero; y] when Bits.Ops.eq (Bits.U.of_int 0 w) x -> zero
    | args  ->  default "and" ws args
<<RTL operator implementations>>=
let rec zx w args   = match w, args with
| [n;w],[RP.Const (RP.Bits x)] -> const (Bits.Ops.zx w x)
| [n;w],[RP.App (("zx", [n';w']), [x])] -> assert (w' = n); zx [n';w] [x]
| [n;w], [x] when n = w -> x
| _         -> default "zx" w args

let rec sx w args   = match (w,args) with
| [i;j],[RP.Const(RP.Bits x)] -> const (Bits.Ops.sx j x)
| [n;w],[RP.App (("sx", [n';w']), [x])] -> assert (w' = n); sx [n';w] [x]
| [n;w],[RP.App (("zx", [n';w']), [x])] when w' > n' -> assert (w' = n); zx [n';w] [x]
| [i;j], [x] when i = j -> x
| _         -> default "sx" w args

let lobits w args   = match (w,args) with
| [i;j],[RP.Const(RP.Bits x)] -> const (Bits.Ops.lobits j x)
| [i;j], [x] when i = j -> x
| _         -> default "lobits" w args
<<RTL operator implementations>>=
let unsigned n w = RP.Const (RP.Bits (Bits.U.of_int n w))

let zero1 = Bits.U.of_int 0 1
let one1  = Bits.U.of_int 1 1
let bool w args = assert (w = []); match args with
| [RP.Const (RP.Bits x)] -> RP.Const (RP.Bool (Bits.Ops.ne x zero1))
| [RP.App (("lobits", [w; 1]), [x])] ->
    RP.App (("ne", [w]), [RP.App (("and", [w]), [x; unsigned 1 w]); unsigned 0 w])
| _ -> default "bool" w args


let bit w args = assert (w = []); match args with
| [RP.Const (RP.Bool b)] -> RP.Const (RP.Bits (if b then one1 else zero1))
| _ -> default "bit" w args
@
