% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ------------------------------------------------------------------ 
\section{Alpha calling conventions}
% ------------------------------------------------------------------ 

This module implements calling conventions for the Alpha. The
parameters represent the machine instructions to implement [[return]]
and [[cut to]].

The [[cmm]] convention is an experimental test of the [[Callspec]]
module.

<<alphacall.mli>>=
val c   : return_to: (Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
val cmm0: return_to: (Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
val cmm1: return_to: (Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
val cmm2: return_to: (Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
val cmm3: return_to: (Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t

val cconv :
  return_to:(Rtl.exp -> Rtl.rtl) -> 
  Mflow.cut_args Target.map -> 
  string -> Automaton.cc_spec ->
  Call.t
@

The implementation is based on \textit{True64 {\small UNIX} Assembly
Language Programmer's Guide}, Version 5.1, published by Compaq Computer,
Houston.

It is not clear how to handle the requirements that on entry,
register~27 is live and holds the address of the called procedure, or
that on exit, register~26 is live and must hold the return address.
It's probably easier to manage register~26.


\paragraph{Debugging} For debugging we provide functions that dump 
automata that are part of the calling convention to [[stdout]]. The two
arguments are the width and hints to try in every state of an automaton.

<<alphacall.mli>>=
val dump_proc:      int list -> string list -> unit
val dump_return:    int list -> string list -> unit
val dump_cutto:     int list -> string list -> unit
val paths_proc:      int list -> string list -> unit
val paths_return:    int list -> string list -> unit
val paths_cutto:     int list -> string list -> unit
@

% ------------------------------------------------------------------ 
\subsection{Implementation of Alpha calling conventions}
% ------------------------------------------------------------------ 

<<alphacall.ml>>=
module A  = Automaton
module C  = Call
module R  = Rtl
module RP = Rtl.Private
module RS = Register.Set
module RU = Rtlutil
module T  = Target

let impossible = Impossible.impossible
let unimp      = Impossible.unimp
let sprintf    = Printf.sprintf
let wordsize   = 64
@

\paragraph{Registers}

A non-volatile register can be used in a procedure if its initial value
is restored upon exit. Such a register is also called callee-saved. A
volatile register can be used without saving and restoring. Registers
that are neither volatile nor non-volatile are unavailable for register
allocation.

The return address [[ra]] is volatile.  It can be used for register
allocation, but the call instruction always writes it (and it is live on
entry).

<<alphacall.ml>>=
let r n     = ('r',n,wordsize)
let f n     = ('f',n,wordsize)
let d n     = ('f',n,wordsize)
let vfp     = Vfp.mk wordsize
@

Calling conventions treat floating point registers specially; therefore
we have separate lists for them.

Can we use register \$26, \$27 and \$28, \$29? \$27 is used implictly
for sub-routine calls. If we make the use explicit in our call {\rtl},
we could use it.

<<alphacall.ml>>=
let vol_int  = List.map r ((Aux.from 0 ~upto:8)@(Aux.from 16 ~upto:26))
let nvl_int  = List.map r (Aux.from 9  ~upto:15)
let vol_fp   = List.map f ([0;1] @ (Aux.from 10  ~upto:30))
let nvl_fp   = List.map f (Aux.from 2 ~upto:9)
@
Non-volatile registers are saved somewhere in the frame. Currently, we
cannnot provide dedicated locations as they are demanded in \S 6.3.3.5.

<<alphacall.ml>>=
let saved_nvr temps =
    let t = Talloc.Multiple.loc temps 't' in
    let u = Talloc.Multiple.loc temps 'u' in
        function
        | ('r',_,w) -> t w
        | ('f',_,w) -> u w
        | (s  ,i,_) -> impossible (sprintf "cannot save $%c%d" s i)
@

\paragraph{Conventions}

The size of the Alpha frame must be a multiple of 16. This cannot be
specified here.

<<alphacall.ml>>=
let ra        = R.reg (r 26)            (* return address *)
let sp        = R.reg (r 30)            (* stack pointer  *)
let spval     = R.fetch sp wordsize
let growth    = Memalloc.Down           (* stack grows down *)
let byteorder = R.LittleEndian         
let sp_align  = 16                      (* SP always 16-byte aligned *)

let std_sp_location = 
    RU.add wordsize vfp (R.late "minus frame size" wordsize)

let ( *> ) = A.( *> )

let badwidth (msg:string) (w:int) = 
    impossible (sprintf "unsupported (rounded) width %d in Alpha: %s" w msg)

let fatal _ = 
    impossible "fatal error in Alpha automaton"
@

And in Lua:

<<Alpha calling convention automata in Lua>>=
A             = Automaton
Alpha         = Alpha         or {}
Alpha.cc      = Alpha.cc      or {}
Alpha.cc["C"] = Alpha.cc["C"] or {}

function round_mult_64 (k) return Util.round_up_mult(64, k) end

Alpha.growth    = "down"
Alpha.byteorder = "little"
Alpha.sp_align  = 16
Alpha.wordsize  = 64

function reg(sp,i) return({space = sp, index = i, width = Alpha.wordsize}) end
function f(i) return(reg("f", i)) end
function r(i) return(reg("r", i)) end

Alpha.vol_fp  = (f(0) .. f(1)) .. (f(10) .. f(30))  -- includes f0-f1, f10-f30
Alpha.vol_int = (r(0) .. r(8)) .. (r(16) .. r(26))  -- includes r0-f8, r16-f26
@ 

\paragraph{C~return results}

A C~function returns an integer (up to 64 bits wide) in [[$0]], a
floating-point result (up to two 64-bit values) in [[$f0]] and [[$f1]].

THIS IS PROBABLY A BUG!  [[useregs]] CREATES MUTABLE STATE, SO IF A
COMPILATION UNIT HAS MULTIPLE CALL SITES THAT RETURN THE SAME HINT, WE
SHOULD SEE A FAILURE HERE.
<<alphacall.ml>>=
let results =
    A.choice
        [ (A.is_hint "float"),  
            A.widen (Aux.round_up_to ~multiple_of: 64)            *>
            A.widths [64] ~errormsg:(badwidth "Alpha FP return")  *>
            A.useregs [f 0; f 1] ~errormsg:fatal
        ; A.is_any,
            A.widen (Aux.round_up_to ~multiple_of: 64)            *>
            A.widths [64] ~errormsg:(badwidth "Alpha return")     *>  
            A.useregs [r 0] ~errormsg:fatal
        ]
@
And in Lua:
<<Alpha calling convention automata in Lua>>=
Alpha.cc["C"].results =
  { A.widen(round_mult_64)
  , A.widths { 64 }
  , A.choice { "float" , A.useregs { f(0), f(1) }
             , A.is_any, A.useregs { r(0) }
             }
  }
@ 
As an alternative we provide [[cmm_results]] that returns every result
in memory. This is for experiments with custom calling conventions.
<<alphacall.ml>>=
let cmm_results =
    A.widths [64] ~errormsg:(badwidth "can only return 64-bit values") *>
    A.overflow ~memsize:8 ~byteorder ~growth:Memalloc.Up ~max_alignment:sp_align
@

\paragraph{C~procedure parameters}

Table 6-3 summarizes the calling convention: the location of an argument
is determined by its position and type:

\begin{quote}
\begin{tabular}{lll}
Position & Integer  & Floating-Point \\
\hline
1        & [[$16]]  & [[f16]] \\
2        & [[$17]]  & [[f17]] \\
3        & [[$18]]  & [[f18]] \\
4        & [[$19]]  & [[f19]] \\
5        & [[$20]]  & [[f20]] \\
6        & [[$21]]  & [[f21]] \\
7        & stack    & stack   \\
\dots    & \dots    & \dots   \\
\end{tabular}
\end{quote}

The implementation below uses the \emph{position} of a parameter to
determine the register it is passed in. The [[counter]] stage counts
the number of bits requested for allocation; the [[regs_by_bits]] stages
looks at its list of registers, ignores as many registers as are
needed to account for bits already allocated and then uses any
remaining register to satisfy the request.

Note that the direction of [[growth]] in the overflow block is
independent of the stack growth. 
        
<<alphacall.ml>>=        
let arguments () = 
    let ctr = "bits" in
    (A.bitcounter ctr *>
    A.choice
        [ A.is_hint "float",
          A.widths [64] ~errormsg:(badwidth "Alpha FP call") *> 
          A.regs_by_bits ctr [f 16; f 17; f 18; f 19; f 20; f 21]
        ; A.is_any,
          A.widen (Aux.round_up_to ~multiple_of:64) *>
          A.regs_by_bits ctr [r 16; r 17; r 18; r 19; r 20; r 21]
        ]) *>  
  A.overflow ~memsize:8 ~byteorder ~growth:Memalloc.Up ~max_alignment:sp_align
@          

And in Lua:
<<Alpha calling convention automata in Lua>>=
Alpha.cc["C"].call =
  { A.bitcounter("bits")
  , A.choice { "float",  { A.widths { 64 }
                         , A.regs_by_bits("bits", f(16) .. f(21))
                         }
             , A.is_any, { A.widen(round_mult_64)
                         , A.regs_by_bits("bits", r(16) .. r(21))
                         }
             }
  , A.overflow { memsize = 8, byteorder = Alpha.byteorder, growth = "up"
               , max_alignment = Alpha.sp_align }
  }
@

\paragraph{C~cut-to parameters}

Since this is strictly an internal calling convention, we can use
whatever we like. We use all volatile registers.
<<alphacall.ml>>=
let cut_args = 
    A.choice
        [ (A.is_hint "float"),
            A.widen (Aux.round_up_to ~multiple_of:64)        *>
            A.useregs vol_fp  ~errormsg:fatal 
        ; A.is_any,
            A.widen (Aux.round_up_to ~multiple_of:64)        *>
            A.useregs vol_int ~errormsg:fatal 
        ] *>
    A.overflow ~memsize:8 ~byteorder ~growth ~max_alignment:sp_align
@
And in Lua:
<<Alpha calling convention automata in Lua>>=
Alpha.cc["C"].cutto =
 { A.widen(round_mult_64)
 , A.choice { "float",  A.useregs(Alpha.vol_fp)
            , A.is_any, A.useregs(Alpha.vol_int)
            }
 , A.overflow { memsize = 8, byteorder = Alpha.byteorder, growth = Alpha.growth
              , max_alignment = Alpha.sp_align }
 }
@

% ------------------------------------------------------------------ 
\subsection{Putting it together} 
% ------------------------------------------------------------------ 

The Alpha demands (\S 6.3.3.2) that a procedure loads the global pointer
value ($\$27$) into $\$gp$, if the procedure uses large constants. We
have to assume that this is always the case. How do we implement this
requirement? Update: currently there is no appropriate mechanism. For
the Alpha, work is distributed over the code expander, the assembler,
and the recognizer.

I don't understand the meaning of [[autosp]] and [[postsp]]. On the
Alpha, the stack pointer does not move during calls. It is once set in
the prolog of a procedure and set back before the procedure returns. I
hope the code below reflects this.

<<transformations>>=
let prolog =
  let autosp = (fun _ -> vfp) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in call parms" A.at stage.A.call)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
	  ~insp:(fun a _ _ -> autosp a) in

let epilog =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" A.at stage.A.results)
    ~autosp:(fun r -> std_sp_location)
    ~postsp:(fun _ _ -> vfp) in

let call_actuals =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out call parms" A.at stage.A.call)
    ~autosp:(fun r  -> std_sp_location)
    ~postsp:(fun _ sp -> sp) in  

let call_results =
  let autosp = (fun r -> std_sp_location) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" A.at stage.A.results)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a) in


let also_cuts_to =
  let autosp = (fun r -> std_sp_location) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in cont parms" A.at stage.A.cutto)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
	  ~insp:(fun a _ _ -> autosp a) in

let cut_actuals base  =
   C.outgoing ~growth ~sp ~mkauto:(fun () -> A.at base stage.A.cutto)
     ~autosp:(fun r -> spval)
     ~postsp:(fun _ _ -> spval) in

<<alphacall.ml>>=
let rtn return_to k n ~ra =
    if k = 0 & n = 0 then return_to ra
    else impossible "alternate return using C calling convention" 

let new_c ~return_to cut stage = 
    <<transformations>>
    { C.name            = "C"
	; C.overflow_alloc  = { C.parameter_deallocator = C.Caller
                          ; C.result_allocator      = C.Caller
                          }
    ; C.call_parms      = { C.in' = prolog       ; C.out = call_actuals }
    ; C.cut_parms       = { C.in' = also_cuts_to ; C.out = cut_actuals  }
    ; C.results         = { C.in' = call_results ; C.out = epilog       }

    ; C.stack_growth     = growth
    ; C.stable_sp_loc    = std_sp_location
    ; C.replace_vfp      = Cfgx.Vfp.replace_with ~sp
    ; C.sp_align         = sp_align
    ; C.pre_nvregs       = RS.union (RS.of_list nvl_int) (RS.of_list nvl_fp)
    ; C.volregs          = RS.union (RS.of_list vol_int) (RS.of_list vol_fp)
    ; C.saved_nvr        = saved_nvr
    ; C.cutto            = cut
    ; C.return           = rtn return_to
    ; C.ra_on_entry      = (fun _     -> R.fetch ra wordsize)
    ; C.where_to_save_ra = (fun _ t   -> Talloc.Multiple.loc t 't' wordsize)
    ; C.ra_on_exit       = (fun _ _ t -> ra)
    ; C.sp_on_jump       = (fun _ _ -> Rtl.null)
    }

let c ~return_to cut =
  new_c ~return_to cut
    { A.call = arguments() ; A.results = results ; A.cutto = cut_args }

let cconv ~return_to cut ccname stage = 
  let f =
    match ccname with
(*
    | "cmm0" -> cmm0
	| "cmm1" -> cmm1
	| "cmm2" -> cmm2
*)
	| _      -> new_c
  in f ~return_to cut stage
@

And in Lua we simply:
<<Alpha calling convention automata in Lua>>=
-- register the new calling convention!
Backend.alpha.target = A.register_cc(Backend.alpha.target, "C", Alpha.cc["C"])
@ 

\paragraph{Support for Debugging} 

This code should ultimately moved close to the \module{call.nw} module
such that it is available for all calling conventions. The polymorphic
nature of [[Call.t]] make this difficult rigth now.

<<alphacall.ml>>=
let dump what automaton widths hints = 
        what 
        ~mk:(fun () -> A.at (Rtl.bits (Bits.zero wordsize) wordsize) 
                            (automaton ()))
        ~widths ~hints
        
let dump_proc     = dump Automatongraph.print arguments
let dump_return   = dump Automatongraph.print (fun () -> results)
let dump_cutto    = dump Automatongraph.print (fun () -> cut_args)
let paths_proc     = dump Automatongraph.paths arguments
let paths_return   = dump Automatongraph.paths (fun () -> results)
let paths_cutto    = dump Automatongraph.paths (fun () -> cut_args)
@

\paragraph{Test of new calling convention specification} Module
\module{callspec} provides a new interface to build a calling
convention. The convention returned acts as a template for us; we have
to provide some small changes to make it fit.  We have to fix the
location of the return address on exit. It has to be in \$26. Using
[[SaveToTemp]] also crashes the register allocator.

<<alphacall.ml>>=
module CS = Callspec

let template = (* conservative spec *)
        { CS.name           = "cmm"
        ; CS.call           = arguments
        ; CS.results        = (fun () -> results)   
        ; CS.cutto          = (fun () -> cut_args)
        ; CS.stack_growth   = Memalloc.Down
        ; CS.overflow       = CS.overflow C.Caller C.Caller
        ; CS.sp             = r 30
        ; CS.sp_align       = sp_align
        ; CS.all_regs       = RS.of_list (List.concat [nvl_int; nvl_fp;
                                                       vol_int; vol_fp])
        ; CS.nv_regs        = RS.of_list (nvl_int @ nvl_fp)
        ; CS.save_nvr       = saved_nvr
        ; CS.ra             = (ra, CS.ReturnAddress.SaveToTemp 't')
        }
@

We build a [[Call.t]] value from a specification and do the final fixup
for the return address. 

<<alphacall.ml>>=
let cc return_to cut spec =
    let t = CS.to_call cut (rtn return_to) spec in 
        { t with C.ra_on_exit = (fun _ _ t -> ra) }
@

Most variations we are interested in can be expressed in the
specification. Here are calling conventions that we derive from our
template.

<<alphacall.ml>>=
let cmm0 ~return_to cut = cc return_to cut 
    { template with CS.name     = "cmm0"
                  ; CS.overflow = CS.overflow C.Caller C.Caller 
    }
let cmm1 ~return_to cut = cc return_to cut 
    { template with CS.name     = "cmm1"
                  ; CS.overflow = CS.overflow C.Caller C.Callee 
    }
let cmm2 ~return_to cut = cc return_to cut 
    { template with CS.name     = "cmm2"
                  ; CS.overflow = CS.overflow C.Callee C.Caller 
    }
let cmm3 ~return_to cut = cc return_to cut 
    { template with CS.name     = "cmm3"
                  ; CS.overflow = CS.overflow C.Callee C.Callee 
                  ; CS.results  = (fun () -> cmm_results)
    }
@
                                                   
    

