% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{ALPHA calling conventions}

My goal here is to avoid knowing anything about instructions.
The parameters represent the machine instructions to implement
[[return]] and [[cut to]].
<<alphacall.mli>>=
val c : return_to:(Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
  (* C calling convention *)
val cmm : return_to:(Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
  (* C-- calling convention *)
@ 
\section{Implementation of ALPHA calling conventions}
We use these abbreviations:
<<alphacall.ml>>=
module A  = Automaton
module C  = Call
module R  = Rtl
module RP = Rtl.Private
module RS = Register.Set
module RU = Rtlutil
module T  = Target
@ 
\paragraph{General information}
Information on the C~calling convention is from the Tru64 Unix Calling
Standard for Alpha Systems dated August 2000
(Compaq part number AA-RH9MB-TE).

@ 
\paragraph{ALPHA registers and their conventional uses}
Calling conventions refer to registers frequently, so it is
appropriate to be able to refer to them by name.
Lua code would do something similar.
<<alphacall.ml>>=
let regs = Array.init 32 (fun i -> ('r', i, 64))
let vfp = Vfp.mk 64
@ 
Here are the volatile and nonvolatile registers.
N.B. In position-independent code, [[ebx]] is reserved to point to the
global offset table.
Flags are also volatile, except that the direction flag must be set to
``forward'' (that is, zero) on entry and exit.
<<alphacall.ml>>=
let volregs = RS.of_list [eax; ecx; edx]
let nvregs  = RS.of_list [ebx; esi; edi; ebp]
let allregs = RS.elements (RS.union volregs nvregs)
@  N.B. We omit all floating-point registers.
These are all volatile and available for allocation, although
[[%st(0)]] can used to return a floating-point result.
The ABI says that all these registers ``must be empty'' at entry and
exit (except that [[%st(0)]] need not be empty if it holds a result).
Understanding ``empty'' requires understanding $x$86 floating-point.
@ 
For now, we save a nonvolatile register anywhere.
Later, we may want mechanisms for saving them in conventional locations.
<<alphacall.ml>>=
let saved_nvr temps =
  let t = Talloc.Multiple.loc temps 't' in
  fun (_, _, w) -> t w
@
\paragraph{Conventions governing the stack}
Page 3-10.  The stack is word-aligned.
The stack pointer points at the last item on the stack, \emph{not} at
an empty slot.
<<alphacall.ml>>=
let sp       = R.reg esp
let spval    = R.fetch sp 32
let sp_align = 4
let growth   = Memalloc.Down
let bo       = R.LittleEndian
@
\paragraph{Generic automaton support}
The two infix operators both represent the basic composition operator,
which must instantiated at two types:
stage followed by stage is stage,
and 
stage followed by implementation is implementation.
<<alphacall.ml>>=
let ( **> ) f x = f x
let ( *> ) f1 f2 x = f1 (f2 x)
@ 
We provide error parameters to automata.
<<alphacall.ml>>=
let badwidth what w = Impossible.impossible
    ("Unsupported (rounded) width " ^ string_of_int w ^ " in alpha " ^ what)
let imp _ = Impossible.impossible "grave miscalculation in automaton"
@ 
\paragraph{Automata for passing values---C~convention}

Integer results come in register~0.
<<alphacall.ml>>=
let results iregs base = 
  A.hint_choice
     [ ((=) "float"),   A.widen  (Aux.round_up_to ~multiple_of:64) *>
                        A.widths [64] ~errormsg:(badwidth "alpha floating return") *>
                        A.useregs [('f', 0, 64)] ~errormsg:imp
     ; (fun _ -> true), A.widen  (Aux.round_up_to ~multiple_of:64) *>
                        A.widths [64] ~errormsg:(badwidth "alpha return convention") *>
                        A.useregs iregs ~errormsg:imp
     ] **>
  A.no_overflow base 8 "multiple return values for alpha C"
let c_results = results [regs.(0)]
@
When passing procedure parameters, we put
earlier arguments in lower addresses, so even though the
stack grows down, the overflow block grows up.
An argument's size is increased, if necessary, to make it a multiple
of words.  The ABI specifies padding, but we'll use [[widen]] because
the machine is little-endian.
<<alphacall.ml>>=
let c_arguments base = 
  A.widen  (Aux.round_up_to ~multiple_of:32) **>
  A.overflow ~memsize:8 ~byteorder:bo ~start:base
             ~growth:Memalloc.Up ~max_alignment:sp_align
@ 
When passing cut-to parameters, we use all the registers---there's no
reason not to.
<<alphacall.ml>>=
let cut_args base = 
  A.widen  (Aux.round_up_to ~multiple_of:32) **>
  A.widths [32] ~errormsg:(badwidth "alpha cut-to convention") **>
  A.useregs allregs ~errormsg:imp **>
  A.overflow ~memsize:8 ~byteorder:bo ~start:base
             ~growth:Memalloc.Up ~max_alignment:sp_align
@ 
It's worth studying these automata to see what's likely to remain
unchanged across conventions:
memsize, byte order, stack alignment, and growth direction are good
candidates for defaulting.
@
\paragraph{Automata for passing values---{\PAL}~convention}
<<alphacall.ml>>=
let cmm_results = results (RS.elements volregs)
let cmm_arguments base = 
  A.widen  (Aux.round_up_to ~multiple_of:32) **>
  A.useregs (RS.elements volregs) ~errormsg:imp **>
  A.overflow ~memsize:8 ~byteorder:bo ~start:base
             ~growth:Memalloc.Up ~max_alignment:sp_align
@
\paragraph{Managing the stack pointer and return address}
On entry, the stack pointer points to the return address.
This needs some aliasing info?
<<alphacall.ml>>=
let ra = R.mem R.none 'm' bo 32 vfp
@ 
The ``normal'' location for the stack pointer is at the bottom of the
frame. 
This line of code should be the \emph{only} place in the compiler
where the constant [["minus frame size"]] is mentioned.
Clients should use the base of the appropriate block in the calling convention.
<<alphacall.ml>>=
let addk = RU.addk 32
let add  = RU.add  32
let std_sp_location = add vfp (R.late "minus frame size" 32)
@ 
N.B. the call instruction moves the stack pointer.
<<functions to transform automata>>=
let call_actuals  =
  C.outgoing ~what:"call" ~growth ~sp ~spec:specs.call
    ~autosp:(fun r -> Block.base r.A.overflow)
    ~postsp:(fun _ -> std_sp_location)
    ~relative_to:vfp in
let prolog  =
  C.incoming ~what:"prolog" ~growth ~sp ~spec:specs.call
    ~autosp:(fun r -> addk (Block.base r.A.overflow) (-4))
    ~postsp:(fun _ -> std_sp_location)
    ~relative_to:vfp in
@ 
<<functions to transform automata>>=
let call_results  =
  C.incoming ~what:"results" ~growth ~sp ~spec:specs.results
    ~autosp:(fun r -> Block.base r.A.overflow)
    ~postsp:(fun _ -> std_sp_location)  (* irrelevant? *)
    ~relative_to:vfp in
let epilog  =
  C.outgoing ~what:"epilog" ~growth ~sp ~spec:specs.results
    ~autosp:(fun r -> Block.base r.A.overflow)
    ~postsp:(fun _ -> vfp)  (* irrelevant *)
    ~relative_to:vfp in
@ 
If we use [[Call.outgoing]] by itself, we have a problem, because
[[Call.outgoing]] assumes that the overflow block is relative, when in
fact it needs to be exact for a [[cut to]].
We have a horrid patch here.
<<functions to transform automata>>=
let also_cuts_to =
  C.incoming ~what:"continuation" ~growth ~sp ~spec:specs.cutto
    ~autosp:(fun r -> std_sp_location)
    ~postsp:(fun _ -> std_sp_location)
    ~relative_to:vfp in

let cut_actuals base  =
 let out =
   C.outgoing ~what:"cut to" ~growth ~sp ~spec:specs.cutto
     ~autosp:(fun r -> spval)
     ~postsp:(fun _ -> spval)
     ~relative_to:base in
 let out types actuals = 
   let answer = out types actuals in
   let c = Rtleqn.equate base (Block.base answer.C.overflow) in
   {answer with C.overflow = Block.with_constraint answer.C.overflow c} in
 out in
@ 
\paragraph{Putting together the whole convention}
<<alphacall.ml>>=
type ('a, 'b, 'c) specs = { call : 'a; results : 'b; cutto : 'c }
let conv specs ~return_to cut =
  <<functions to transform automata>>
  let return k n ~ra =
    if k = 0 & n = 0 then return_to ra
    else Impossible.impossible "alternate return using C calling convention" in
  { C.call_parms = { C.in' = prolog;       C.out = call_actuals}
  ; C.cut_parms  = { C.in' = also_cuts_to; C.out = cut_actuals}
  ; C.results    = { C.in' = call_results; C.out = epilog}

  ; C.stack_growth    = Memalloc.Down
  ; C.stable_sp_loc   = std_sp_location
  ; C.replace_vfp     = Cfgx.Vfp.replace_with ~sp
  ; C.sp_align        = 4               (* alignment of stack pointer at call/cut *)
  ; C.ra              = ra              (* where return address is on entry *)
  ; C.nvregs          = nvregs          (* registers preserved across calls *)
  ; C.volregs         = volregs         (* registers not preserved across calls *)
  ; C.saved_nvr       = saved_nvr
  ; C.cutto           = cut
  ; C.saved_ra        = (fun _ -> ra)
  ; C.return          = return
  } 

let c   = conv { call = c_arguments;   results=c_results;   cutto=cut_args }
let cmm = conv { call = cmm_arguments; results=cmm_results; cutto=cut_args }
