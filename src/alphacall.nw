% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ------------------------------------------------------------------ 
\section{Alpha calling conventions}
% ------------------------------------------------------------------ 

This module implements calling conventions for the Alpha. The
parameters represent the machine instructions to implement [[return]]
and [[cut to]].

The [[cmm]] convention is an experimental test of the [[Callspec]]
module.

<<alphacall.mli>>=
val c   : return_to: (Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
val cmm0: return_to: (Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
val cmm1: return_to: (Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
val cmm2: return_to: (Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
val cmm3: return_to: (Rtl.exp -> Rtl.rtl) -> Mflow.cut_args Target.map -> Call.t
@

The implementation is based on \textit{True64 {\small UNIX} Assembly
Language Programmer's Guide}, Version 5.1, published by Compaq Computer,
Houston.

It is not clear how to handle the requirements that on entry,
register~27 is live and holds the address of the called procedure, or
that on exit, register~26 is live and must hold the return address.
It's probably easier to manage register~26.


\paragraph{Debugging} For debugging we provide functions that dump 
automata that are part of the calling convention to [[stdout]]. The two
arguments are the width and hints to try in every state of an automaton.

<<alphacall.mli>>=
val dump_proc:      int list -> string list -> unit
val dump_return:    int list -> string list -> unit
val dump_cutto:     int list -> string list -> unit
val paths_proc:      int list -> string list -> unit
val paths_return:    int list -> string list -> unit
val paths_cutto:     int list -> string list -> unit
@

% ------------------------------------------------------------------ 
\subsection{Implementation of Alpha calling conventions}
% ------------------------------------------------------------------ 

<<alphacall.ml>>=
module A  = Automaton
module AE = Automaton.Exclude
module C  = Call
module R  = Rtl
module RP = Rtl.Private
module RS = Register.Set
module RU = Rtlutil
module T  = Target

let impossible = Impossible.impossible
let unimp      = Impossible.unimp
let sprintf    = Printf.sprintf
let wordsize   = 64
@

\paragraph{Registers}

A non-volatile register can be used in a procedure if its initial value
is restored upon exit. Such a register is also called callee-saved. A
volatile register can be used without saving and restoring. Registers
that are neither volatile nor non-volatile are unavailable for register
allocation.

The return address [[ra]] is volatile.  It can be used for register
allocation, but the call instruction always writes it (and it is live on
entry).

<<alphacall.ml>>=
let r n     = ('r',n,wordsize)
let f n     = ('f',n,wordsize)
let d n     = ('f',n,wordsize)
let vfp     = Vfp.mk wordsize
@

Calling conventions treat floating point registers specially; therefore
we have separate lists for them.

Can we use register \$26, \$27 and \$28, \$29? \$27 is used implictly
for sub-routine calls. If we make the use explicit in our call {\rtl},
we could use it.

<<alphacall.ml>>=
let vol_int  = List.map r ((Aux.from 0 ~upto:8)@(Aux.from 16 ~upto:26))
let nvl_int  = List.map r (Aux.from 9  ~upto:15)
let vol_fp   = List.map f ([0;1] @ (Aux.from 10  ~upto:30))
let nvl_fp   = List.map f (Aux.from 2 ~upto:9)
@
Non-volatile registers are saved somewhere in the frame. Currently, we
cannnot provide dedicated locations as they are demanded in \S 6.3.3.5.

<<alphacall.ml>>=
let saved_nvr temps =
    let t = Talloc.Multiple.loc temps 't' in
    let u = Talloc.Multiple.loc temps 'u' in
        function
        | ('r',_,w) -> t w
        | ('f',_,w) -> u w
        | (s  ,i,_) -> impossible (sprintf "cannot save $%c%d" s i)
@

\paragraph{Conventions}

The size of the Alpha frame must be a multiple of 16. This cannot be
specified here.

<<alphacall.ml>>=
let ra        = R.reg (r 26)            (* return address *)
let sp        = R.reg (r 30)            (* stack pointer  *)
let spval     = R.fetch sp wordsize
let growth    = Memalloc.Down           (* stack grows down *)
let byteorder = R.LittleEndian         
let sp_align  = 16                      (* SP always 16-byte aligned *)

let std_sp_location = 
    RU.add wordsize vfp (R.late "minus frame size" wordsize)

let ( *> ) = A.( *> )

let badwidth (msg:string) (w:int) = 
    impossible (sprintf "unsupported (rounded) width %d in Alpha: %s" w msg)

let fatal _ = 
    impossible "fatal error in Alpha automaton"
@

\paragraph{C~return results}

A C~function returns an integer (up to 64 bits wide) in [[$0]], a
floating-point result (up to two 64-bit values) in [[$f0]] and [[$f1]].

<<alphacall.ml>>=
let results =
    A.choice
        [ (A.is_hint "float"),  
            A.widen (Aux.round_up_to ~multiple_of: 64)            *>
            A.widths [64] ~errormsg:(badwidth "Alpha FP return")  *>
            A.useregs [f 0; f 1] ~errormsg:fatal
        ; A.is_any,
            A.widen (Aux.round_up_to ~multiple_of: 64)            *>
            A.widths [64] ~errormsg:(badwidth "Alpha return")     *>  
            A.useregs [r 0] ~errormsg:fatal
        ]
@

As an alternative we provide [[cmm_results]] that returns every result
in memory. This is for experiments with custom calling conventions.

<<alphacall.ml>>=
let cmm_results =
    A.widths [64] ~errormsg:(badwidth "can only return 64-bit values") *>
    A.overflow ~memsize:8 ~byteorder ~growth:Memalloc.Up ~max_alignment:sp_align
@

\paragraph{C~procedure parameters}

Table 6-3 summarizes the calling convention: the location of an argument
is determined by its position and type:

\begin{quote}
\begin{tabular}{lll}
Position & Integer  & Floating-Point \\
\hline
1        & [[$16]]  & [[f16]] \\
2        & [[$17]]  & [[f17]] \\
3        & [[$18]]  & [[f18]] \\
4        & [[$19]]  & [[f19]] \\
5        & [[$20]]  & [[f20]] \\
6        & [[$21]]  & [[f21]] \\
7        & stack    & stack   \\
\dots    & \dots    & \dots   \\
\end{tabular}
\end{quote}

We encode this by exclusion rules between corresponding integer and
floating-point registers.

<<alphacall.ml>>=
let spaces =
  let module SS = Space.Standard64 in
  let r = SS.r 32 byteorder [64] in
  let f = SS.f 32 byteorder [64] in
  function
  | 'r' -> r
  | 'f' -> f
  | _   -> Impossible.impossible "register space in parameter passing"
@

Note that the direction of [[growth]] in the overflow block is
independent of the stack growth. 

<<alphacall.ml>>=
let arguments () =
  (* N.B. exc is mutable and must be made fresh each time *)
  let exc = A.Exclude.of_pairs spaces [ [r 16] , [f 16]
                                      ; [r 17] , [f 17]
                                      ; [r 18] , [f 18]
                                      ; [r 19] , [f 19]
                                      ; [r 20] , [f 20]
                                      ; [r 21] , [f 21]
                                      ] in
  A.choice   
      [ (fun h w -> h = "float" && w = 64),
          A.sharedregs exc [f 16; f 17; f 18; f 19; f 20; f 21] ~errormsg:fatal
      ; (fun h w -> h <> "float" && w = 64),
          A.widen (Aux.round_up_to ~multiple_of:64)        *>
          A.sharedregs exc [r 16; r 17; r 18; r 19; r 20; r 21] ~errormsg:fatal
      ] *>
  A.overflow ~memsize:8 ~byteorder ~growth:Memalloc.Up ~max_alignment:sp_align
@

Here is an alternative implementation of the parameter automaton. Rather
than using an exclusion relation, it uses the \emph{position} of a
parameter to determine the register it is passed in. The [[counter]]
stage counts the number of bits requested for allocation; the
[[offsetregs]] stages looks at its list of registers, ignores as many
registers as are needed to account for bits already allocated and then
uses any remaining register to satisfy the request.
        
<<alphacall.ml>>=        
let arguments' () = 
    let ctr = ref 0 in
    (A.bitcounter ctr *>
    A.choice
        [ A.is_hint "float",
          A.widths [64] ~errormsg:(badwidth "Alpha FP call") *> 
          A.offsetregs ctr [f 16; f 17; f 18; f 19; f 20; f 21]
        ; A.is_any,
          A.widen (Aux.round_up_to ~multiple_of:64) *>
          A.offsetregs ctr [r 16; r 17; r 18; r 19; r 20; r 21]
        ]) *>  
  A.overflow ~memsize:8 ~byteorder ~growth:Memalloc.Up ~max_alignment:sp_align
@          

\paragraph{C~cut-to parameters}

Since this is strictly internal calling convention, we can use whatever
we like. We use all volatile registers.
<<alphacall.ml>>=
let cut_args = 
    A.choice
        [ (A.is_hint "float"),
            A.widen (Aux.round_up_to ~multiple_of:64)        *>
            A.useregs vol_fp  ~errormsg:fatal 
        ; A.is_any,
            A.widen (Aux.round_up_to ~multiple_of:64)        *>
            A.useregs vol_int ~errormsg:fatal 
        ] *>
    A.overflow ~memsize:8 ~byteorder ~growth ~max_alignment:sp_align
@

% ------------------------------------------------------------------ 
\subsection{Putting it together} 
% ------------------------------------------------------------------ 

The Alpha demands (\S 6.3.3.2) that a procedure loads the global pointer
value ($\$27$) into $\$gp$, if the procedure uses large constants. We
have to assume that this is always the case. How do we implement this
requirement? Update: currently there is no appropriate mechanism. For
the Alpha, work is distributed over the code expander, the assembler,
and the recognizer.

I don't understand the meaning of [[autosp]] and [[postsp]]. On the
Alpha, the stack pointer does not move during calls. It is once set in
the prolog of a procedure and set back before the procedure returns. I
hope the code below reflects this.

<<transformations>>=
let prolog  =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in call parms" A.at (arguments' ()))
    ~autosp:(fun _ -> vfp)
    ~postsp:(fun _ _ -> std_sp_location) in

let epilog  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" A.at results)
    ~autosp:(fun r -> std_sp_location)
    ~postsp:(fun _ _ -> vfp) in

let call_actuals  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out call parms" A.at (arguments' ()))
    ~autosp:(fun r  -> std_sp_location)
    ~postsp:(fun _ sp -> sp) in  

let call_results  =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" A.at results)
    ~autosp:(fun r -> std_sp_location)
    ~postsp:(fun _ _ -> std_sp_location) in


let also_cuts_to =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in cont parms" A.at cut_args)
    ~autosp:(fun r -> std_sp_location)
    ~postsp:(fun _ _ -> std_sp_location) in

let cut_actuals base  =
   C.outgoing ~growth ~sp ~mkauto:(fun () -> A.at base cut_args)
     ~autosp:(fun r -> spval)
     ~postsp:(fun _ _ -> spval) in

<<alphacall.ml>>=
let rtn return_to k n ~ra =
    if k = 0 & n = 0 then return_to ra
    else impossible "alternate return using C calling convention" 

let c ~return_to cut = 
    <<transformations>>
    { C.name            = "C"
    ; C.jump_ok         = false
    ; C.call_parms      = { C.in' = prolog;       C.out = call_actuals}
    ; C.cut_parms       = { C.in' = also_cuts_to; C.out = cut_actuals}
    ; C.results         = { C.in' = call_results; C.out = epilog}

    ; C.stack_growth    = growth
    ; C.stable_sp_loc   = std_sp_location
    ; C.replace_vfp     = Cfgx.Vfp.replace_with ~sp
    ; C.sp_align        = sp_align
    ; C.pre_nvregs      = RS.union (RS.of_list nvl_int) (RS.of_list nvl_fp)
    ; C.volregs         = RS.union (RS.of_list vol_int) (RS.of_list vol_fp)
    ; C.saved_nvr       = saved_nvr
    ; C.cutto           = cut
    ; C.return          = rtn return_to
    ; C.ra_on_entry      = (fun _     -> R.fetch ra wordsize)
    ; C.where_to_save_ra = (fun _ t   -> Talloc.Multiple.loc t 't' wordsize)
    ; C.ra_on_exit       = (fun _ _ t -> ra)
    }
@

\paragraph{Support for Debugging} 

This code should ultimately moved close to the \module{call.nw} module
such that it is available for all calling conventions. The polymorphic
nature of [[Call.t]] make this difficult rigth now.

<<alphacall.ml>>=
let dump what automaton widths hints = 
        what 
        ~mk:(fun () -> A.at (Rtl.bits (Bits.zero wordsize) wordsize) 
                            (automaton ()))
        ~widths ~hints
        
let dump_proc     = dump Automatongraph.print arguments'
let dump_return   = dump Automatongraph.print (fun () -> results)
let dump_cutto    = dump Automatongraph.print (fun () -> cut_args)
let paths_proc     = dump Automatongraph.paths arguments'
let paths_return   = dump Automatongraph.paths (fun () -> results)
let paths_cutto    = dump Automatongraph.paths (fun () -> cut_args)
@

\paragraph{Test of new calling convention specification} Module
\module{callspec} provides a new interface to build a calling
convention. The convention returned acts as a template for us; we have
to provide some small changes to make it fit.  We have to fix the
location of the return address on exit. It has to be in \$26. Using
[[SaveToTemp]] also crashes the register allocator.

<<alphacall.ml>>=
module CS = Callspec

let template = (* conservative spec *)
        { CS.name           = "cmm"
        ; CS.wordsize       = 64
        ; CS.call           = arguments'
        ; CS.results        = (fun () -> results)   
        ; CS.cutto          = (fun () -> cut_args)
        ; CS.stack_growth   = Memalloc.Down
        ; CS.overflow       = CS.overflow CS.Caller CS.Caller
        ; CS.sp             = r 30
        ; CS.sp_align       = sp_align
        ; CS.all_regs       = RS.of_list (List.concat [nvl_int; nvl_fp;
                                                       vol_int; vol_fp])
        ; CS.nv_regs        = RS.of_list (nvl_int @ nvl_fp)
        ; CS.save_nvr       = saved_nvr
        ; CS.ra             = (ra, CS.ReturnAddress.SaveToTemp 't')
        }
@

We build a [[Call.t]] value from a specification and do the final fixup
for the return address. 

<<alphacall.ml>>=
let cc return_to cut spec =
    let t = CS.to_call cut (rtn return_to) spec in 
        { t with C.ra_on_exit = (fun _ _ t -> ra) }
@

Most variations we are interested in can be expressed in the
specification. Here are calling conventions that we derive from our
template.

<<alphacall.ml>>=
let cmm0 ~return_to cut = cc return_to cut 
    { template with CS.name     = "cmm0"
                  ; CS.overflow = CS.overflow CS.Caller CS.Caller 
    }
let cmm1 ~return_to cut = cc return_to cut 
    { template with CS.name     = "cmm1"
                  ; CS.overflow = CS.overflow CS.Caller CS.Callee 
    }
let cmm2 ~return_to cut = cc return_to cut 
    { template with CS.name     = "cmm2"
                  ; CS.overflow = CS.overflow CS.Callee CS.Caller 
    }
let cmm3 ~return_to cut = cc return_to cut 
    { template with CS.name     = "cmm3"
                  ; CS.overflow = CS.overflow CS.Callee CS.Callee 
                  ; CS.results  = (fun () -> cmm_results)
    }
@
                                                   
    

