% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: sw=4 ts=8 et:

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Please add grades for this module below. The line must start with % "%%".
% 

%%Grades: B Peripheral Later

%
% Todo: define rounding mode register (names: fp_mode) in space 'c';
% extend 'location' locaion type. Since 'c' is 32 bits wide, but the
% rounding mode only 2 bits wide, we take slices: RP.slice (2, 0,
% fp_mode) when using it.
%


% ------------------------------------------------------------------ 
\section{RTL-Spaces}
% ------------------------------------------------------------------ 

The {\rtl} framework groups memory cells (main memory, registers,
temporaries) into named spaces. The cells forming a space share
properties but the {\rtl} framework does not announce them. This module
provides a type to describe an {\rtl} space. 

The function [[checked]] asserts that its argument satisfies a few
simple invariants, then returns that argument.
<<space.mli>>=
<<type location set>>
<<type classification>>
<<type t>>
val checked : t -> t
@
The module [[Standard]] provides support for common spaces with
standard names.  Memory uses 8-bit cells, and other units use 32-bit
cells.  
Byte order and available aggregate widths must be specified by the
client. 
<<module type Standard>>=
module type Standard = sig
  type generator = Rtl.aggregation -> Rtl.width list -> t
  val m :               generator          (* standard 8-bit memory *)
  val r :  count:int -> generator          (* registers *)
  val t :               generator          (* register temps *)
  val f :  count:int -> generator          (* floats *)
  val u :               generator          (* float temps *)
  val a :  count:int -> generator          (* address registers *)
  val v :               generator          (* address temps *)
  val p :  count:int -> generator          (* predicate registers *)
  val w :               generator          (* predicate temps *)
  val c :  count:int -> generator          (* control and special registers *)
  
  type 'a locations = 
    { pc:       'a
    ; npc:      'a
    ; cc:       'a
    ; fp_mode:  'a  (* FP rounding mode   *)
    ; fp_fcmp:  'a  (* FP %fcmp results   *)
    }

  val locations : c:t -> Rtl.loc locations
        (* apply to c space to get standard locations *)
  val indices : int locations (* standard indices in c space *)
  val vfp : Rtl.exp  (* the virtual frame pointer, $V[0] *)
end

<<space.mli>>=
<<module type Standard>>
module Standard32: Standard
@ 

A [[Rtl.space]] denotes a memory space, the details of a particular
space are covered by a space descriptor [[t]]:  

<<type t>>=
type t  =
    { space:            Rtl.space       (* space being described *)
    ; doc:              string          (* informal doc string *)       
    ; cellwidth:        int             (* bits *)
    ; indexwidth:       int             (* bits *)
    ; indexlimit:       int option      (* None = 2 ** indexwidth *)
    ; aggregation:      Rtl.aggregation      
    ; widths:           int list        (* bit widths of supported aggregates *)
    ; classification:   classification  
    }
@

\begin{itemize}
\item [[doc]]:          Informal documentation string.
\item [[cellwidth]]:    Width of cell in this space. A register space 
                        could be 32 bits wide, a memory space 8 bits.
\item [[indexwidth]]:   Width of an address in this space. A memory
                        space could have 32 bit wide addresses, a
                        register space 5 bit wide addresses.
\item [[indexlimit]]:   Upper bound for an address in this space: $0,
                        \dots, [[indexlimit]]$. 
\item [[aggregation]]:  Supported aggregation.
\item [[widths]]:       Widths of supported aggregates. For example, 
                        if an  memory space 8~bits wide supports 8-, 16-, and
                        32-bit words, [[widths]] would be [[[8;16;32]]].
\item [[classification]]: Classification of a space, see below.

\end{itemize}
@
A space falls into one of the following classifications: memory-like,
register-like, fixed, or temporary. 
<<type classification>>=
type classification = 
    | Mem               
    | Reg               
    | Fixed
    | Temp of location_set
@ Memory-like, register-like, and fixed spaces contiain real hardware
locations.
A~temporary space contains only locations that stand in for hardware
locations.
All temporary locations are removed before code generation is
complete. 
(This is the job of the register allocator.)

The classification of a space depends on the binding time of the
expressions used to index cells in that space.
\begin{itemize}
\item
 If an {\rtl} operand addressing the space denotes a value that
      cannot be computed until run time, the space is memory-like.
      An example of such an expression is $\mathit{SP}+12$.
      The standard \texttt{m}~space is memory-like.
\item
 If every {\rtl} operand addressing the space is a compile-time
 constant, and if the constant can ever be chosen by the compiler,
 then the space is register-like. 
 (In machine-language terms, a space is register-like if the values of its
 indexing expressions can be computed from the operands of the
 instructions that use the space.)
 Most standard spaces are register-like, including \texttt{r},
 \texttt{f}, and~\texttt{a}.
\item
 If every {\rtl} operand addressing the space is a fixed
 constant determined by the nature of the instruction, with no choice
 available to the compiler,
 then the space is fixed. 
 (In machine-language terms, a space is fixed if the values of its
 indexing expressions are determined by the instructions that use the
 space, and the operands of those instructions are irrelevant.)
 The standard \texttt{c}~space is fixed.
\item
   A temporary space is a register-like space that is infinitely large
   and not provided by the hardware.
   A~location in a temporary space denotes one of a set of locations
   drawn from a real register-like space.
   The set is
      characterized by a [[location_set]] value. Example: on the
   SPARC, the \texttt{t}~space is
      a space over \texttt{r}, where the address of an \texttt{r} cell
      is not zero.  
   The register allocator ultimately replaces each temporary location
   with a real hardware location.
\end{itemize}
<<type location set>>=
type predicate    = int -> bool
type location_set =
    { stands_for : Rtl.space  (* space we form a subset of *)
    ; index_ok   : predicate  (* predicate to check the qualifying condition *)
    ; set_doc    : string     (* informal description *)    
    }
@    

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<space.ml>>=
<<type location set>>
<<type classification>>
<<type t>>
<<module type Standard>>
@

<<space.ml>>=
let indexwidth n =
  let rec wid = function
    | 0 -> 0
    | n -> 1 + wid (n lsr 1)  in
  wid (n-1)
let checked s =
  begin
    assert (match s.widths with [] -> false | _ :: _ -> true);
    List.iter (fun w -> assert (w mod s.cellwidth = 0)) s.widths;
    (match s.aggregation with
    | Rtl.Identity -> assert(s.widths = [s.cellwidth])
    | _ -> ());
    (match s.indexlimit with
    | Some n -> assert (indexwidth n <= s.indexwidth)
    | _ -> ());
    s
  end
@

A set of standard spaces can now be constructed from a simple functor
argument. Maybe we need to extend the argument signature for 64-bit
architectures.

<<space.ml>>=
module Standard(A:sig val width: int end) = struct
  type generator = Rtl.aggregation -> Rtl.width list -> t
  let m agg ws = checked 
    { space          = 'm'
    ; doc            = "memory"
    ; cellwidth      = 8
    ; indexwidth     = A.width 
    ; indexlimit     = None
    ; aggregation    = agg
    ; widths         = ws
    ; classification = Mem
    } 

  let r ~count agg ws = checked 
    { space          = 'r'
    ; doc            = "general-purpose registers"
    ; cellwidth      = A.width
    ; indexwidth     = indexwidth count
    ; indexlimit     = Some count
    ; aggregation    = agg
    ; widths         = ws
    ; classification = Reg
    } 

  let t agg ws   = checked 
    { space         = 't'
    ; doc           = "general-purpose temporaries"
    ; cellwidth     = A.width
    ; indexwidth    = A.width
    ; indexlimit    = None
    ; aggregation   = agg
    ; widths        = ws
    ; classification = Temp  
        { stands_for = 'r'
        ; index_ok   = (fun _ -> true) (* lies *)
        ; set_doc    = "general-purpose temporaries"
        } 
    } 

  let f ~count agg ws = checked 
    { space         = 'f'
    ; doc           = "floating-point registers"
    ; cellwidth     = A.width
    ; indexwidth    = indexwidth count
    ; indexlimit    = Some count
    ; aggregation   = agg
    ; widths        = ws
    ; classification = Reg
    }
    
  let u agg ws = checked 
    { space         = 'u'
    ; doc           = "floating-point temporaries"
    ; cellwidth     = A.width
    ; indexwidth    = A.width
    ; indexlimit    = None
    ; aggregation   = agg
    ; widths        = ws
    ; classification = Temp 
        { stands_for = 'f'
        ; index_ok   = (fun _ -> true) (* lies *)
        ; set_doc    = "floating-point temporaries"
        } 
    } 

  let a ~count agg ws = checked 
    { space         = 'a'
    ; doc           = "address registers"
    ; cellwidth     = A.width
    ; indexwidth    = indexwidth count
    ; indexlimit    = Some count
    ; aggregation   = agg
    ; widths        = ws
    ; classification = Reg
    } 
  
  let v agg ws   = checked 
    { space         = 'v'
    ; doc           = "address temporaries"
    ; cellwidth     = A.width
    ; indexwidth    = A.width
    ; indexlimit    = None
    ; aggregation   = agg
    ; widths        = ws
    ; classification = Temp 
        { stands_for = 'a'
        ; index_ok   = (fun _ -> true) (* lies *)
        ; set_doc    = "address temporaries"
        } 
    } 

  let p ~count agg ws = checked 
    { space         = 'p'
    ; doc           = "predicate registers"
    ; cellwidth     = A.width
    ; indexwidth    = indexwidth count
    ; indexlimit    = Some count
    ; aggregation   = agg; widths = ws
    ; classification = Reg
    }
    
  let w agg ws   = checked 
    { space         = 'w'
    ; doc           = "predicate temporaries"
    ; cellwidth     = A.width
    ; indexwidth    = A.width
    ; indexlimit    = None
    ; aggregation   = agg
    ; widths        = ws
    ; classification = Temp 
        { stands_for = 'p'
        ; index_ok   = (fun _ -> true) (* lies *)
        ; set_doc    = "predicate temporaries"
        } 
    } 

    (* CHECK THAT count IS LARGE ENOUGH TO COVER indicies BELOW -- CL*)
  let c ~count agg ws = checked 
    { space         = 'c'
    ; doc           = "control and special"
    ; cellwidth     = A.width
    ; indexwidth    = indexwidth count
    ; indexlimit    = Some count
    ; aggregation   = agg
    ; widths        = ws
    ; classification = Fixed
    } 

  type 'a locations = 
    { pc:       'a
    ; npc:      'a
    ; cc:       'a
    ; fp_mode:  'a  (* FP rounding mode   *)
    ; fp_fcmp:  'a  (* FP condition codes *)
    }
  
  let locations ~c = match c with    
    |   { space       = 'c'
        ; cellwidth   = cw
        ; aggregation = bo
        ; indexwidth  = iw 
        } ->
            let reg n = Rtl.reg ('c', n, cw) in
            { pc      = reg 0
            ; npc     = reg 1
            ; cc      = reg 2 
            ; fp_mode = Rtl.slice 2 0 (reg 4)   
            ; fp_fcmp = Rtl.slice 2 0 (reg 5) 
            }
    |   { space = s } -> Impossible.impossible 
            ( "Standard locations from space " ^ Char.escaped s)
                                 
  
  let indices = { pc = 0; npc = 1; cc = 2; fp_mode = 4 ; fp_fcmp = 5 }
  let vfp = Rtl.fetch (Rtl.reg ('V', 0, A.width)) A.width
end
module Standard32 = Standard(struct let width = 32 end)

@

