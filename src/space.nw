% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=4 et:
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Please add grades for this module below. The line must start with % "%%".
% 

%%Grades: B Peripheral Later

% ------------------------------------------------------------------ 
\section{RTL-Spaces}
% ------------------------------------------------------------------ 

The {\rtl} framework groups memory cells (main memory, registers,
temporaries) into named spaces. The cells forming a space share
properties but the {\rtl} framework does not announce them. This module
provides a type to describe an {\rtl} space. 

\begin{quote}\it
    I feel that the type to describe a space should go into the
    \module{rtl} module. Values for different spaces could be still
    defined somewhere else. NR suggested to have this separate module.
    --CL
\end{quote}
The function [[checked]] asserts that its argument satisfies a few
simple invariants, then returns that argument.
<<space.mli>>=
<<type location set>>
<<type classification>>
<<type t>>
val checked : t -> t
@
The module [[Standard]] provides support for common spaces with
standard names.  Memory uses 8-bit cells, and other units use 32-bit
cells.  
Byte order and available aggregate widths must be specified by the
client. 
<<space.mli>>=
module Standard32 : sig
  type generator = Rtl.aggregation -> Rtl.width list -> t
  val m :               generator          (* standard 8-bit memory *)
  val r :  count:int -> generator          (* registers *)
  val t :               generator          (* register temps *)
  val f :  count:int -> generator          (* floats *)
  val u :               generator          (* float temps *)
  val a :  count:int -> generator          (* address registers *)
  val v :               generator          (* address temps *)
  val p :  count:int -> generator          (* predicate registers *)
  val w :               generator          (* predicate temps *)
  val c :  count:int -> generator          (* control and special registers *)
end
@

A [[Rtl.space]] denotes a memory space, the details of a particular
space are covered by a space descriptor [[t]]:  

<<type t>>=
type t  =
    { space:            Rtl.space       (* space being described *)
    ; doc:              string          (* informal doc string *)       
    ; cellwidth:        int             (* bits *)
    ; indexwidth:       int             (* bits *)
    ; indexlimit:       int option      (* None = 2^indexwidth *)
    ; aggregation:      Rtl.aggregation      
    ; widths:           int list        (* widths of supported aggregates *)
    ; classification:   classification  
    }
@

\begin{itemize}
\item [[doc]]:          Informal documentation string.
\item [[cellwidth]]:    Width of cell in this space. A register space 
                        could be 32 bits wide, a memory space 8 bits.
\item [[indexwidth]]:   Width of an address in this space. A memory
                        space could have 32 bit wide addresses, a
                        register space 5 bit wide addresses.
\item [[indexlimit]]:   Upper bound for an address in this space: $0,
                        \dots, [[indexlimit]]$. 
\item [[aggregation]]:  Supported aggregation.
\item [[widths]]:       Widths of supported aggregates. For example, 
                        if an  memory space 8~bits wide supports 8-, 16-, and
                        32-bit words, [[widths]] would be [[[1; 2; 4]]].
\item [[classification]]: Classification of a space, see below.

\end{itemize}

A space falls into one of the following categories: memory-like,
register-like, fixed, or temporary. 

<<type classification>>=
type classification = 
    | Mem               
    | Reg               
    | Fixed
    | Temp of location_set
@

\begin{itemize}
\item A space is memory-like, if {\rtl} operands that address this space 
      take complex expressions as addresses.
\item A space is memory-like, if {\rtl} operands that address this space
      only take integers as adresses.
\item A space is fixed, if it can not be addresses explicitly, but
      {\rtl} operators address it implicitly. Typical example: status
      register.
\item A temporary space denotes a subset of another space that is
      characterized by a [[location_set]] value. Example: \texttt{t} is
      a space over \texttt{r}, where the address of an \texttt{r} cell
      is not zero.  However, currently we do not plan to use this
      recursively: \texttt{x} is a space over \texttt{y}, that is a
      space over \texttt{z}. Don't do that.
\end{itemize}

<<type location set>>=
type predicate    = int -> bool
type location_set =
    { stands_for : Rtl.space  (* space we form a subset of *)
    ; index_ok   : predicate  (* predicate to check the qualifying condition *)
    ; set_doc    : string     (* informal description *)    
    }
@    

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<space.ml>>=
<<type location set>>
<<type classification>>
<<type t>>
@

<<space.ml>>=
let indexwidth n =
  let rec wid = function
    | 0 -> 0
    | n -> 1 + wid (n lsr 1)  in
  wid (n-1)
let checked s =
  begin
    assert (match s.widths with [] -> false | _ :: _ -> true);
    List.iter (fun w -> assert (w mod s.cellwidth = 0)) s.widths;
    (match s.aggregation with
    | Rtl.Identity -> assert(s.widths = [s.cellwidth])
    | _ -> ());
    (match s.indexlimit with
    | Some n -> assert (indexwidth n <= s.indexwidth)
    | _ -> ());
    s
  end
<<space.ml>>=
module Standard32 = struct
  type generator = Rtl.aggregation -> Rtl.width list -> t
  let m agg ws = checked { space = 'm'; doc = "memory"; cellwidth = 8
                         ; indexwidth = 32 ; indexlimit = None
                         ; aggregation = agg; widths = ws
                         ; classification = Mem
                         } 

  let r ~count agg ws = checked { space = 'r'; doc = "general-purpose registers"
                           ; cellwidth = 32
                           ; indexwidth = indexwidth count; indexlimit = Some count
                           ; aggregation = agg; widths = ws
                           ; classification = Reg
                           } 
  let t agg ws   = checked { space = 't'; doc = "general-purpose temporaries"
                           ; cellwidth = 32
                           ; indexwidth = 32; indexlimit = None
                           ; aggregation = agg; widths = ws
                           ; classification =
                               Temp  { stands_for = 'r'
                                     ; index_ok   = (fun _ -> true) (* lies *)
                                     ; set_doc    = "general-purpose temporaries"
                                     } 
                           } 

  let f ~count agg ws = checked { space = 'f'; doc = "floating-point registers"
                           ; cellwidth = 32
                           ; indexwidth = indexwidth count; indexlimit = Some count
                           ; aggregation = agg; widths = ws
                           ; classification = Reg
                           } 
  let u agg ws   = checked { space = 'u'; doc = "floating-point temporaries"
                           ; cellwidth = 32
                           ; indexwidth = 32; indexlimit = None
                           ; aggregation = agg; widths = ws
                           ; classification =
                               Temp { stands_for = 'f'
                                    ; index_ok   = (fun _ -> true) (* lies *)
                                    ; set_doc    = "floating-point temporaries"
                                    } 
                           } 

  let a ~count agg ws = checked { space = 'a'; doc = "address registers"
                           ; cellwidth = 32
                           ; indexwidth = indexwidth count; indexlimit = Some count
                           ; aggregation = agg; widths = ws
                           ; classification = Reg
                           } 
  let v agg ws   = checked { space = 'v'; doc = "address temporaries"
                           ; cellwidth = 32
                           ; indexwidth = 32; indexlimit = None
                           ; aggregation = agg; widths = ws
                           ; classification =
                               Temp { stands_for = 'a'
                                    ; index_ok   = (fun _ -> true) (* lies *)
                                    ; set_doc    = "address temporaries"
                                    } 
                           } 

  let p ~count agg ws = checked { space = 'p'; doc = "predicate registers"
                           ; cellwidth = 32
                           ; indexwidth = indexwidth count; indexlimit = Some count
                           ; aggregation = agg; widths = ws
                           ; classification = Reg
                           } 
  let w agg ws   = checked { space = 'w'; doc = "predicate temporaries"
                           ; cellwidth = 32
                           ; indexwidth = 32; indexlimit = None
                           ; aggregation = agg; widths = ws
                           ; classification =
                               Temp { stands_for = 'p'
                                    ; index_ok   = (fun _ -> true) (* lies *)
                                    ; set_doc    = "predicate temporaries"
                                    } 
                           } 

  let c ~count agg ws = checked { space = 'c'; doc = "control and special"
                           ; cellwidth = 32
                           ; indexwidth = indexwidth count; indexlimit = Some count
                           ; aggregation = agg; widths = ws
                           ; classification = Reg
                           } 
end
@

A [[Rtl.space]] denotes a memory space, the details of a particular
space are covered by a space descriptor [[t]]:  

type t  =
    { space:            Rtl.space       (* space being described *)
    ; doc:              string          (* informal doc string *)       
    ; cellwidth:        int             (* bits *)
    ; indexwidth:       int             (* bits *)
    ; indexlimit:       int option      (* None = 2^indexwidth *)
    ; aggregation:      Rtl.aggregation      
    ; widths:           int list        (* widths of supported aggregates *)
    ; classification:   classification  
    }

