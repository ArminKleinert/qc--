% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Support for backward dataflow problems}


A dataflow pass is based on a single dataflow fact of type~[['a]], but
to describe a fully general pass requires not one but three type
parameters:
\begin{itemize}
\item
Type parameter [['a]] is the pass's dataflow fact.
Values of type~[['a]] should form a lattice.
\item
Type parameter [['i]] is an input, from which it should be possible to
derived the dataflow fact.
For example, [['i]] might be equal to~[['a]], or it might be a tuple
of which one element is~[['a]].
\item
Type parameter [['o]] is an output.
For a pure analysis, [['o]] is equal to~[['a]].
For a pure transformation, [['o]] is [[graph option]].
For a combined analysis and transformation, [['o]] 
is [['a answer]].
\end{itemize}
The dataflow engine computes a least solution to a set of dataflow
equations defined by a pass.

WE NEED TO TRACK THINGS TO DISCOVER WHETHER ANYTHING HAS CHANGED AS A
RESULT OF RUNNING A PASS.
@
<<dataflowp.mli>>=
<<exported module types>>
module M : S
<<exported module types>>=
module type S = sig
  <<exported types>>
  <<declarations of exported values>>
end
<<exported types>>=
type uid = Zipcfg.uid
type 'a answer = Dataflow of 'a | Rewrite of Zipcfg.graph

type ('i, 'a, 'o) pass' =
 { name      : string;
   prop      : 'a Unique.Prop.t;
   add_info  : 'a -> 'a -> 'a;  (* lattice join (least upper bound) *)
   changed   : old:'a -> new':'a -> bool;  (* is new one bigger? *)
   init_info : 'a;  (* lattice bottom element *)
   last_in   : Zipcfg.Rep.last -> 'o;
   middle_in : 'i -> Zipcfg.Rep.middle -> 'o;
   first_in  : 'i -> Zipcfg.Rep.first -> 'o;
 } 

type 'a analysis = ('a, 'a, 'a) pass'
type 'a transformation = ('a, unit, Zipcfg.graph option) pass'
type 'a pass = ('a, 'a, 'a answer) pass'
@ 
These two functions only set properties.
<<declarations of exported values>>=
val backward_anal : 'a analysis -> Zipcfg.graph -> unit
val backward_pass : 'a pass -> Zipcfg.graph -> unit
@ 
The rewrite pass sets properties and also rewrites the graph.
<<declarations of exported values>>=
val backward_rewrite : 'a pass -> Zipcfg.graph -> Zipcfg.graph
@ 
<<declarations of exported values>>=
val a_t : 'a analysis -> 'a transformation -> 'a pass
@ 
Diagnostic help:
<<declarations of exported values>>=
val debug : ('a -> string) -> 'a pass -> 'a pass
@
\section{Implementation}

<<dataflowp.ml>>=
module G  = Zipcfg
module GR = Zipcfg.Rep
module UA = Unique.Array
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let unimpf  fmt = Printf.kprintf Impossible.unimp      fmt

<<utilities>>

<<exported module types>>
module M : S = struct
  module P = Unique.Prop
  <<exported types>>
  <<definitions of exported functions>>
end
@ 
Revised to use the new flow-graph traversal.
We go from each head to the next join.
<<definitions of exported functions>>=
let backward anal graph =
  let blocks = List.rev (G.postorder_dfs graph) in
  let () = List.iter (fun b -> P.set anal.prop (GR.id b) anal.init_info) blocks in
  let find = P.get anal.prop in
  let changed = ref false in
  let block b =
    let h, l = GR.goto_end (GR.unzip b) in
    let out = anal.last_in l in
    let rec prev h out = match h with
      | GR.Head (h, m) -> prev h (anal.middle_in out m)
      | GR.First f -> anal.first_in out f in
    let in' = prev h out in
    let u = GR.id b in
    let old_in = find u in
    if anal.changed ~old:old_in ~new':in' then
      begin
        P.set anal.prop u in';
        changed := true
      end in
  let rec iterate n =
    let () = changed := false in
    let () = List.iter block blocks in
    if !changed then
      if n < 1000 then iterate (n + 1)
      else impossf "%s didn't converge in %n iterations" anal.name n
    else
      Debug.eprintf anal.name "%s converted in %d iterations\n" anal.name n in
  iterate 1
let backward_anal = backward
@ 
In the general case we solve a graph in the context of a larger subgraph.
<<definitions of exported functions>>=
let rec solve_graph anal graph exit_fact =
  let last' l = match l with
  | GR.Exit 0 -> Dataflow exit_fact
  | _ -> anal.last_in l in
  let anal' = { anal with last_in = last' } in
  let () = general_backward anal' graph in
  P.get anal.prop GR.entry_uid 
and general_backward anal graph =
  let blocks = List.rev (G.postorder_dfs graph) in
  let () = List.iter (fun b -> P.set anal.prop (GR.id b) anal.init_info) blocks in
  let find = P.get anal.prop in
  let solve_graph = solve_graph anal in
  <<definition of [[answer]]>>
  let changed = ref false in
  let block b =
    let h, l = GR.goto_end (GR.unzip b) in
    let out = answerl l in
    let rec prev h out = match h with
      | GR.Head (h, m) -> answerm out m (fun a -> prev h a)
      | GR.First f -> answerf out f in
    let in' = prev h out in
    let u = GR.id b in
    let old_in = find u in
    if anal.changed ~old:old_in ~new':in' then
      begin
        P.set anal.prop u in';
        changed := true
      end in
  let rec iterate n =
    let () = changed := false in
    let () = List.iter block blocks in
    if !changed then
      if n < 1000 then iterate (n + 1)
      else impossf "%s didn't converge in %n iterations" anal.name n
    else
      Debug.eprintf anal.name "%s converted in %d iterations\n" anal.name n in
  iterate 1
let backward_pass anal graph = general_backward anal graph
@ 
<<definition of [[answer]]>>=
let answerf out f = match anal.first_in out f with
| Dataflow a -> a
| Rewrite g -> solve_graph g out in

let answerm out m k = match anal.middle_in out m with
| Dataflow a -> k a
| Rewrite g -> solve_graph g out in

let answerl l = match anal.last_in l with
| Dataflow a -> a
| Rewrite g -> solve_graph g anal.init_info in
@
<<definitions of exported functions>>=
let rec solve_rewrite anal graph exit_fact =
  let _a = solve_graph anal graph exit_fact in
  let last' l = match l with
  | GR.Exit 0 -> Dataflow exit_fact
  | _ -> anal.last_in l in
  let anal' = { anal with last_in = last' } in
  backward_rewrite anal' graph 
and backward_rewrite anal graph =
  let check_property_match a f =
    let a' = P.get anal.prop (GR.id f) in
    if anal.changed a a' or anal.changed a' a then
      impossf "property changed after supposedly reaching fixed point" in
  let blocks = List.rev (G.postorder_dfs graph) in
  let find = P.get anal.prop in
  let solve_rewrite = solve_rewrite anal in
  let rec block rewritten fresh : G.graph = match fresh with
  | [] -> G.of_block_list rewritten 
  | b :: bs ->
      let rec answerl h l = match anal.last_in l with
      | Dataflow a -> propagate h a (GR.Last l) bs
      | Rewrite g ->
          let g = solve_rewrite g anal.init_info in
          let a = find GR.entry_uid in
          let h, t, rewritten = splice_in_backward h g (GR.Last l) rewritten in
          (* continue at entry of g *)
          propagate h a t rewritten
      and propagate h out tail rewritten = match h with
      | GR.Head (h, m) -> (
          match anal.middle_in out m with
          | Dataflow a -> propagate h a (GR.Tail (m, tail)) rewritten
          | Rewrite g ->
              let g = solve_rewrite g out in
              let a = find GR.entry_uid in
              let h, t, rewritten = splice_in_backward h g tail rewritten in
              propagate h a t rewritten)
      | GR.First f ->
          match anal.first_in out f with
          | Dataflow a ->
              let b = (f, tail) in
              check_property_match a b;
              block (b :: rewritten) bs
          | Rewrite g -> impossf "rewriting a label in backward dataflow" in
      let h, l = GR.goto_end (GR.unzip b) in
      answerl h l in
  block [] blocks

let backward_rewrite anal g = solve_rewrite anal g anal.init_info
@
<<utilities>>=
module UM = Unique.Map
let rec revapp h t = match h with
| GR.First f -> f, t
| GR.Head (h, m) -> revapp h (GR.Tail (m, t))

let must_be_empty g =
  if not (UM.is_empty g) then
    impossf "entry connects to exit, but there are more blocks"

let add_blocks map list =
  let add _ b bs = b :: bs in
  UM.fold add map list

let splice_in_backward head graph tail oldblocks =
  let gexit, gblocks = G.openz (G.exit 0 graph) in
  let gh, gl = GR.goto_end gexit in
  (match gl with GR.Exit 0 -> () | _ -> impossf "exit is not exit?!");
  let f, t = revapp gh tail in
  match f with
  | GR.Entry ->
      must_be_empty gblocks;
      head, t, oldblocks
  | GR.Label _ ->
      let gentry, gblocks = G.openz (G.entry (G.of_blocks gblocks)) in
      match GR.zip gentry with
      | GR.Entry, t -> head, t, ((f, t) :: add_blocks gblocks oldblocks)
      | _ -> impossf "entry is not entry?!"
@ 
<<utilities>>=
let ( << ) f g = fun x -> f (g x)
<<definitions of exported functions>>=
let debug s anal =
  let pr = Printf.eprintf in
  let module RS = Rtlutil.ToString in
  let fact dir node a = pr "%s %s for %s = %s\n" anal.name dir node (s a) in
  let rewr node g = pr "%s rewrites %s to <not-shown>\n" anal.name node in
  let wrap f nodestring node =
    let answer = f node in
    let () = match answer with
    | Dataflow a -> fact "in " (nodestring node) a
    | Rewrite g  -> rewr (nodestring node) g in
    answer in
  let wrapout f nodestring out node =
    fact "out" (nodestring node) out;
    wrap (f out) nodestring node in
  let last_in = wrap anal.last_in (RS.rtl << GR.last_instr) in
  let middle_in = wrapout anal.middle_in (RS.rtl << GR.mid_instr) in
  let first_in  =
    let first = function GR.Entry -> "<entry>" | GR.Label ((u, l), _, _) -> l in
    wrapout anal.first_in first in
  { anal with last_in = last_in; middle_in = middle_in; first_in = first_in; }
@ 
<<definitions of exported functions>>=
let a_t anal tx =
 let last_in l =
   match tx.last_in l with
   | Some g -> Rewrite g
   | None   -> Dataflow (anal.last_in l) in
 let middle_in out m =
   match tx.middle_in out m with
   | Some g -> Rewrite g
   | None   -> Dataflow (anal.middle_in out m) in
 let first_in out f =
   match tx.first_in out f with
   | Some g -> Rewrite g
   | None   -> Dataflow (anal.first_in out f) in

 { name      = Printf.sprintf "%s and %s" anal.name tx.name;
   prop      = anal.prop;
   add_info  = anal.add_info;
   changed   = anal.changed;
   init_info = anal.init_info;
   last_in   = last_in;
   middle_in = middle_in;
   first_in  = first_in;
 }
