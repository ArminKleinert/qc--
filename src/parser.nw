
% ------------------------------------------------------------------  
\section{Lexical Analysis}
% ------------------------------------------------------------------  

The scanner for lexical anaylis is generated from a specificaton for
\ocaml~Lex. 

<<scan.mll>>=
(* $Id$ *)

{
    open Error
    open Parse      (* tokens are defined here *)

@ The generated scanner keeps track of its current position in its
input stream by counting the bytes it consumes.  In order to maintain
the more useful information of the current line and column in the
input we maintain some state [[position]] of type [[position]]:

\begin{itemize}
\item [[file]]  is the name of the current input file.
\item [[line]]  is the current line number in [[file]] we are in.
\item [[start]] is the position of the first character in the current line
                in the input stream.  
\item [[tab]]   is an offset in order to keep track of the current
                column in the presence of tab characters.
\end{itemize}

There is one value [[position]] held in the [[Scan]] module which
makes it non-reentrant. It is initialized by [[init]] and
automatically during the initialization of the module.

<<scan.mll>>=
    type position = { mutable file:      string
                    ; mutable start:     int
                    ; mutable line:      int
                    ; mutable tab:       int
                    }

    let position = { file  = "undefined"
                   ; start = 0
                   ; line  = 1
                   ; tab   = 0
                   }

    let init file =
        ( position.file  <- file
        ; position.start <- 0
        ; position.line  <- 1
        ; position.tab   <- 0
        )

@ Whenever the scanner encounters a newline character it updates [[position]]
by calling [[nl]]. The position of the first character of the next line
(the first after the newline) is remembered in [[start]].

<<scan.mll>>= 

    let nl lexbuf =
        ( position.start <- (Lexing.lexeme_start lexbuf) + 1 
        ; position.tab   <- 0
        ; position.line  <- position.line + 1
        )

@ The actual column the scanner is looking is basically the current
position in the input stream minus everything before the actual line.
Tab characters advance the cursor more characters than they are long.
This is honored by adding the [[tab]] value to the value obtained so far.

<<scan.mll>>=
    let column lexbuf =
        Lexing.lexeme_start lexbuf + position.tab - position.start 

@ The tab character is one byte long, but moves the cursor additional
$x$ positions to the right.  The number $x$ of virtual spaces depends
on the column $c$ of the tab:

            $$x = 7 - (c~\textrm{mod}~8)$$ 

Whenever the scanner encounters a tab character it calls the [[tab]]
function to update the [[position.tab]] accordingly.  The first column
is by definition 1 and not zero; this is accounted by the [[pos]]
function, whcih returns the actual position. 

<<scan.mll>>=
    let tab lexbuf =
        let c  = column lexbuf      in
        ( position.tab <- position.tab + 7 - (c mod 8)
        )
        
    let pos lexbuf =
        ( position.file
        , position.line
        , 1 + column lexbuf  
        )
     
    let lexerror lexbuf msg = 
        let (file, line, col) = pos lexbuf      in
        let m = Printf.sprintf "File %s, line %d, column %d: %s"
                file line col msg
        in 
            error m

@ We define some helpers; [[get]] returns the matched string and is
quite intuitive when called as [[get lexbuf]].

<<scan.mll>>=
    let get         = Lexing.lexeme
    let getchar     = Lexing.lexeme_char
    let strlen      = String.length
    let pos_start   = Lexing.lexeme_start
    let pos_end     = Lexing.lexeme_end

@ Some lexems contain data that we like to extract.  Here is a
substring extraction function (inspired by Python's [[slice]]) that
makes this easy.  The parameters [[start]] and [[stop]] denote which
part of [[str]] should be extracted; negative numbers can be used to
reference that starting point from the end of the string.  It is best
to think about the indices as pointing between the characters; some
examples makes this clear:

<<substr example>>=
          h  e  l  l  o  _  w  o  r  l  d
        0  1  2  3  4  5  6  7  8  9  10 11
     -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1  0

    substr 0 0 "hello world"            ;; - : string = "hello world"
    substr 0 1 "hello world"            ;; - : string = "h"
    substr 0 (-1) "hello world"         ;; - : string = "hello worl"
    substr (-3) (-1) "hello world"      ;; - : string = "rl"
    substr (0) (3) "hello world"        ;; - : string = "hel"

<<scan.mll>>=
    let substr start stop str = 
        let start = if start <  0 then String.length str + start else start in
        let stop  = if stop  <= 0 then String.length str + stop  else stop  in
            String.sub str start (stop - start)

@ Strings and character literals may contain escaped characters like in
[["this \n"]] example; [[escape]] decodes them.


<<scan.mll>>=
    let escape = function
        | 't'   -> '\t'
        | 'n'   -> '\n'
        | 'b'   -> '\b'
        | 'r'   -> '\r'
        |  x    ->  x  (* default *)

@ All keywords are stored in a hash table that maps them to tokens;
[[keyword s]] tries to lookup [[s]] in the table of keywords and
retrns the matching token or raises [[Not_found]]. 

<<scan.mll>>=
    let keywords    = Hashtbl.create 127
    let keyword s   = Hashtbl.find keywords s

    let _ = Array.iter (fun (str,tok) -> Hashtbl.add keywords str tok)
        [|("aborts"         , ABORTS)
        ; ("align"          , ALIGN)
        ; ("aligned"        , ALIGNED)
        ; ("also"           , ALSO)
        ; ("const"          , CONST)
        ; ("continuation"   , CONTINUATION)
        ; ("cut"            , CUT)
        ; ("cuts"           , CUTS)
        ; ("else"           , ELSE)
        ; ("equal"          , EQUAL)
        ; ("export"         , EXPORT)
        ; ("foreign"        , FOREIGN)
        ; ("global"         , GLOBAL)
        ; ("goto"           , GOTO)
        ; ("if"             , IF)
        ; ("import"         , IMPORT)
        ; ("invariant"      , INVARIANT)
        ; ("jump"           , JUMP)
        ; ("pragma"         , PRAGMA)
        ; ("return"         , RETURN)
        ; ("returns"        , RETURNS)
        ; ("section"        , SECTION)
        ; ("semi"           , SEMI)
        ; ("span"           , SPAN)
        ; ("stackdata"      , STACKDATA)
        ; ("targets"        , TARGETS)
        ; ("to"             , TO)
        ; ("unicode"        , UNICODE)
        ; ("unwinds"        , UNWINDS)

        (* pragmas *)

        ; ("line"           , LINE)
        |]

} (* end of prolog *)


(* declarations *)

let digit       = ['0'-'9']
let octal       = ['0'-'7']
let decchar     = digit digit digit

let printable   = [' '-'~']     (* add 8bit chars *)
let alpha       = ['a'-'z' 'A'-'Z' '_']

let escape      = ['\\' '\'' '"' 'n' 't' 'b' 'r']

let sign        = ['+' '-']
let nat         = digit+
let frac        = nat? '.' nat
let exp         = ['e''E'] sign? nat
let float       = frac exp? 
                | nat exp


let id          = alpha (alpha | digit | '.')*
let ws          = [' ' '\b']
let nl          = '\n'
let tab         = '\t'
let flag        = '{' alpha+ '}' 

(* lexer entry point *)

rule token = parse
    eof         { EOF          }
  | ws+         { token lexbuf }
  | tab         { tab lexbuf; token lexbuf }
  | nl          { nl lexbuf; token lexbuf }

  | ";"         { SEMI         }
  | ":"         { COLON        }
  | ","         { COMMA        }

  | "("         { LPAREN       }
  | ")"         { RPAREN       }
  | "{"         { LBRACE       }
  | "}"         { RBRACE       }
  | "["         { LBRACKET     }
  | "]"         { RBRACKET     }

  | "="         { EQUAL        }
  

  (* infix/prefix operators *)
  
  | "+"         { PLUS(get lexbuf)      }
  | "-"         { MINUS(get lexbuf)     }
  | "*"         { STAR(get lexbuf)      }
  | "/"         { SLASH(get lexbuf)     }
  | "%"         { PERCENT(get lexbuf)   }
  | ">>"        { GGREATER(get lexbuf)  }
  | "<<"        { LLESS(get lexbuf)     }
  | "&"         { AMPERSAND(get lexbuf) }
  | "|"         { BAR(get lexbuf)       }
  | "^"         { CARET(get lexbuf)     }
  | "~"         { TILDE(get lexbuf)     }
  | "=="        { EEQ(get lexbuf)       }
  | "!="        { NEQ(get lexbuf)       }
  | "<"         { LT(get lexbuf)        }
  | "<="        { LEQ(get lexbuf)       }
  | ">"         { GT(get lexbuf)        }
  | ">="        { GEQ(get lexbuf)       }

              
  | "bits" nat  { let s = substr 4 0 (get lexbuf) in
                  BITSn (int_of_string s)
                }
  | "float" nat { let s = substr 5 0 (get lexbuf) in
                  FLOATn (int_of_string s)
                }
  | id          { let s  = get lexbuf in 
                  let k  = try keyword s with Not_found -> ID s in
                    if k = PRAGMA then pragma1 lexbuf else k  
                } 
  (*
  | float       { FLT (float_of_string (get lexbuf)) }
  *)
  
  | float       { FLT (get lexbuf) }
  | nat         { INT (int_of_string (get lexbuf))     }


  
  | "/*"        { comment lexbuf 0 }
  | "\""        { string lexbuf (Buffer.create 80) }
  | "'"         { character lexbuf } 
 
  | _                           { lexerror lexbuf "illegal character" }


(* character literals *)

and character = parse
    printable      "'"          { CHAR (get lexbuf) }
  | '\\' escape    "'"          { let c = (getchar lexbuf 2) in
                                  CHAR (String.make 1 (escape c))
                                }
  | '\\' decchar   "'"          { let s = substr 2 (-1) (get lexbuf) in
                                  let c = Char.chr (int_of_string s) in
                                  CHAR  (String.make 1 c)
                                }
  | '\\' _                      { lexerror lexbuf "illegal character escape" }
  | _                           { lexerror lexbuf "illegal character constant" }

(* level holds the comment nesting level *)

and comment = parse
    eof                         { fun level ->
                                  lexerror lexbuf "unterminated comment" 
                                }
  | [^ '*' '\n' '\t' '/']+      { fun level ->
                                  comment lexbuf level
                                }
  | nl                          { fun level ->
                                  nl lexbuf; comment lexbuf level 
                                }
  | tab                         { fun level -> 
                                  tab lexbuf; comment lexbuf level
                                }
  | "/*"                        { fun level -> 
                                  comment lexbuf (level+1)
                                }
  | "*"+                        { fun level ->
                                  comment lexbuf level
                                }
  | "*/"                        { fun level ->
                                  if   level = 0 
                                  then token lexbuf
                                  else comment lexbuf (level-1)
                                }
  | _                           { fun level ->
                                  comment lexbuf level 
                                }

(* string gets passed a buffer where the scanned string is accumulated *)

and string = parse
    eof                         { fun buf -> 
                                  lexerror lexbuf "unterminated string" 
                                }
  | "\""                        { fun buf -> STR (Buffer.contents buf) }
  | [^ '\000'-'\031'
       '\128'-'\255'
       '"' '\\' ]+              { fun buf ->
                                  let s    = get lexbuf              in
                                  ( Buffer.add_string buf s
                                  ; string lexbuf buf
                                  )
                                }
  | '\\' escape                 { fun buf ->
                                  let c    = getchar lexbuf 1       in
                                  let c'   = escape c               in
                                  ( Buffer.add_char buf c'
                                  ; string lexbuf buf
                                  )
                                }
  
  | '\\' decchar                { fun buf ->
                                  let s    = substr 1 0 (get lexbuf    ) in
                                  let c    = Char.chr (int_of_string s ) in
                                  ( Buffer.add_char buf c
                                  ; string lexbuf buf
                                  )
                                }
  | '\\' _                      { fun buf ->
                                  lexerror lexbuf "illegal character escape"
                                }
  | _                           { fun buf ->
                                  lexerror lexbuf "illegal character in string"
                                }

(* handle pragmas *)

(* find the identifier (target) of the pragma and return the
   corresponding keyword in case it is known *)

and pragma1 = parse
    eof                 { EOF }
  | ws+                 { pragma1 lexbuf }
  | tab                 { tab lexbuf; pragma1 lexbuf }
  | nl                  { nl lexbuf; pragma1 lexbuf } 
  | id                  { let s  = get lexbuf in 
                          try keyword s with Not_found -> pragma2 lexbuf
                        }
  | _                   { lexerror lexbuf "id for pragma expected" }

(* look for the body of the pragma and call pragma3 to skip over it *)

and pragma2 = parse
    eof                 { lexerror lexbuf "pragma body expected" }
  | ws+                 { pragma2 lexbuf }
  | tab                 { tab lexbuf; pragma2 lexbuf }
  | nl                  { nl lexbuf; pragma2 lexbuf }
  | '{'                 { pragma3 lexbuf 0 }
  | _                   { lexerror lexbuf "pragma body expected" }

(* skip an unknown pragma.  We must recognize strings, comments, and
   character literals because they might contain the terminating
   character. *)

and pragma3 = parse
    eof                         { fun level ->
                                  lexerror lexbuf "unterminated pragma" 
                                }
  | [^ '{' '}'  '\n' '\t' 
       '/' '\'' '"']+           { fun level ->
                                  pragma3 lexbuf level
                                }
  | nl                          { fun level ->
                                  nl lexbuf; pragma3 lexbuf level 
                                }
  | tab                         { fun level -> 
                                  tab lexbuf; pragma3 lexbuf level
                                }
  | '{'                         { fun level -> 
                                  pragma3 lexbuf (level+1)
                                }
  | '}'                         { fun level ->
                                  if   level = 0 
                                  then token lexbuf
                                  else pragma3 lexbuf (level-1)
                                }
  | "/*"                        { fun level -> 
                                  ignore (comment lexbuf 0)
                                ; pragma3 lexbuf level
                                }
  | "\""                        { fun level -> 
                                  ignore (string lexbuf (Buffer.create 80))
                                ; pragma3 lexbuf level
                                }
  | "'"                         { fun level -> 
                                  ignore (character lexbuf)
                                ; pragma3 lexbuf level
                                }
  
  | _                           { fun level ->
                                  pragma3 lexbuf level 
                                }

{

    let tok2str = function

    | ABORTS            -> "ABORTS"
    | ALIGN             -> "ALIGN"
    | ALIGNED           -> "ALIGNED"
    | ALSO              -> "ALSO"
    | COLON             -> "COLON"
    | COMMA             -> "COMMA"
    | CONST             -> "CONST"
    | CONTINUATION      -> "CONTINUATION"
    | CUT               -> "CUT"
    | CUTS              -> "CUTS"
    | ELSE              -> "ELSE"
    | EOF               -> "EOF"
    | EQUAL             -> "EQUAL"
    | EXPORT            -> "EXPORT"
    | FOREIGN           -> "FOREIGN"
    | GLOBAL            -> "GLOBAL"
    | GOTO              -> "GOTO"
    | IF                -> "IF"
    | IMPORT            -> "IMPORT"
    | INVARIANT         -> "INVARIANT"
    | JUMP              -> "JUMP"
    | LBRACE            -> "LBRACE"
    | LBRACKET          -> "LBRACKET"
    | LPAREN            -> "LPAREN"
    | PPERCENT          -> "PPERCENT"
    | PRAGMA            -> "PRAGMA"
    | RBRACE            -> "RBRACE"
    | RBRACKET          -> "RBRACKET"
    | RETURN            -> "RETURN"
    | RETURNS           -> "RETURNS"
    | RPAREN            -> "RPAREN"
    | SECTION           -> "SECTION"
    | SEMI              -> "SEMI"
    | SPAN              -> "SPAN"
    | STACKDATA         -> "STACKDATA"
    | TARGETS           -> "TARGETS"
    | TO                -> "TO"
    | UNICODE           -> "UNICODE"
    | UNWINDS           -> "UNWINDS"

    (* pragmas *)

    | LINE              -> "LINE"

    | AMPERSAND(s)      -> "AMPERSAND(" ^ s ^ ")"
    | BAR(s)            -> "BAR(" ^ s ^ ")"
    | CARET(s)          -> "CARET(" ^ s ^ ")"
    | EEQ(s)            -> "EEQ(" ^ s ^ ")"
    | GEQ(s)            -> "GEQ(" ^ s ^ ")"
    | GGREATER(s)       -> "GGREATER(" ^ s ^ ")"
    | GT(s)             -> "GT(" ^ s ^ ")"
    | LEQ(s)            -> "LEQ(" ^ s ^ ")"
    | LLESS(s)          -> "LLESS(" ^ s ^ ")"
    | LT(s)             -> "LT(" ^ s ^ ")"
    | MINUS(s)          -> "MINUS(" ^ s ^ ")"
    | NEQ(s)            -> "NEQ(" ^ s ^ ")"
    | PERCENT(s)        -> "PERCENT(" ^ s ^ ")"
    | PLUS(s)           -> "PLUS(" ^ s ^ ")"
    | SLASH(s)          -> "SLASH(" ^ s ^ ")"
    | STAR(s)           -> "STAR(" ^ s ^ ")"
    | TILDE(s)          -> "TILDE(" ^ s ^ ")"
    
    | ID(s)             -> "ID(" ^ s ^ ")"
    | STR(s)            -> "STR(" ^ s ^ ")"
    | INT(i)            -> "INT(" ^ string_of_int i ^ ")"
    | FLT(f)            -> "FLT(" ^ f ^ ")"
    | BITSn(i)          -> "BITSn(" ^ string_of_int i ^ ")"
    | FLOATn(i)         -> "FLOATSn(" ^ string_of_int i ^ ")"
    | CHAR(c)           -> "CHAR(" ^ c ^ ")"
    
}

@


% ------------------------------------------------------------------  
\section{Grammatical Analysis}
% ------------------------------------------------------------------  

<<parse.mly>>=
/*
// $Id$
// 
// Expect 2 shift/reduce conflicts.
*/

%{

open Error
open Ast
open List

let parse_error = error

let localReg  = function
    | (pos,var,ty,id,None) -> Register(pos,var,ty,id)
    | (pos,var,ty,id,_)    -> parse_error "no hint allowed for local variable"

let assign left right = 
    let rec loop = function 
        | [], []            -> []
        | [], rr            -> parse_error "too few lvalues in assignment"
        | ll, []            -> parse_error "too many lvalues in assignment"
        | (l::ll),(r::rr)   -> (l,r)::loop (ll,rr) 
    in
        loop (left,right)

(* not used - we will do this check later in oder to create better
   error messages *)

let rec varsOnly = function
    | []                 -> []
    | (Var(_) as v)::vv  -> v :: varsOnly vv
    | _                  -> parse_error "mem location in multiple assignment"
     

let p  () = (Parsing.symbol_start (), Parsing.symbol_end())
let pn n  = (Parsing.rhs_start n, Parsing.rhs_end n)

%}

/* keywords, symbols, flags */

%token ABORTS
%token ALIGN
%token ALIGNED
%token ALSO
%token AMPERSAND
%token COLON
%token COMMA
%token CONST
%token CONTINUATION
%token CUT
%token CUTS
%token ELSE
%token EOF
%token EQUAL
%token EXPORT
%token FOREIGN
%token GLOBAL
%token GOTO
%token IF
%token IMPORT
%token INVARIANT
%token JUMP
%token LBRACE
%token LBRACKET
%token LPAREN
%token PPERCENT
%token PRAGMA
%token RBRACE
%token RBRACKET
%token RETURN
%token RETURNS
%token RPAREN
%token SECTION
%token SEMI
%token SPAN
%token STACKDATA
%token TARGETS
%token TO
%token UNICODE
%token UNWINDS

/* pragmas */

%token LINE

/* infix and prefix operators */

%token <string> EEQ NEQ LT LEQ GT GEQ
%token <string> BAR                      
%token <string> CARET                    
%token <string> AMPERSAND                
%token <string> LLESS GGREATER           
%token <string> PLUS MINUS               
%token <string> PERCENT STAR SLASH       
%token <string> TILDE                    

%token <string> ID
%token <int>    INT
%token <string> FLT
%token <string> CHAR
%token <string> STR
%token <int>    BITSn
%token <int>    FLOATn

/* precedence - from lowest to highest precedence */

%nonassoc   EEQ NEQ LT LEQ GT GEQ
%left       BAR                      
%left       CARET                    
%left       AMPERSAND                
%left       LLESS GGREATER           
%left       PLUS MINUS               
%left       PERCENT STAR SLASH       
%right      TILDE                    

%start program
%type <Ast.program>program

%%

program     :   toplevels                         { p(),rev $1 }

toplevels   :   toplevels toplevel                { $2::$1 }
            |   /**/                              { []     }

pragma      :   LINE LBRACE INT RBRACE            { Pragma(p()) }
            |   PRAGMA LBRACE RBRACE              { Pragma(p()) } 

toplevel    :   IMPORT ty names  SEMI             { Import(p(),$2,rev $3)  }
            |   EXPORT    names  SEMI             { Export(p(),rev $2)     }
            |   CONST LBRACE constants RBRACE     { Const(p(),rev $3)      }
            |   GLOBAL LBRACE registers RBRACE    { Global(p(),$3)         } 
            |   SECTION STR LBRACE section RBRACE { Section(p(),$2,rev $4) }
            |   pragma                            { $1 }

section     :   section procedure                 { $2 :: $1             }
            |   section datum                     { Datum(pn 2,$2) :: $1 }
            |   section span                      { $2 :: $1             }
            |   /**/                              { []                   }

span        :   SPAN expr expr 
                LBRACE section RBRACE             { SSpan(p(),$2,$3,rev $5) }

constants   :   constants ID EQUAL expr SEMI      { (p(),$2,$4)::$1 }
            |   /**/                              { []          }

decls       :   decls decl                        { $1 @ $2  }
            |   /**/                              { []       }

decl        :   register                          { map localReg $1 }
            |   STACKDATA LBRACE data RBRACE      { [Stackdata(p(),rev $3)] }

register    :   INVARIANT ty regs SEMI 
                { map (fun (id,hint) -> (p(),Invariant,$2,id,hint)) (rev $3) }
            |   /*******/ ty regs SEMI       
                { map (fun (id,hint) -> (p(),Variant  ,$1,id,hint)) (rev $2) } 

regs        :   regs COMMA ID STR         { ($3,Some $4)::$1                  }
            |   regs COMMA ID             { ($3,None   )::$1                  }
            |   ID STR                    { [($1,Some $2)]                    }
            |   ID                        { [($1,None   )]                    }

registers   :   registers register        { $1 @ $2                           }
            |   /**/                      { []                                }

datum       :   ID COLON                  { Label(p(),$1)                     }
            |   ALIGN INT SEMI            { Align(p(),$2)                     }
            |   ty size init SEMI         { MemDecl(p(),$1, $2     , Some $3) }
            |   ty size      SEMI         { MemDecl(p(),$1, $2     , None)    }
            |   ty      init SEMI         { MemDecl(p(),$1, NoSize , Some $2) }
            |   ty           SEMI         { MemDecl(p(),$1, NoSize , None)    }


data        :   data  datum                           { $2 :: $1 }
            |   /**/                                  { []       }


init        :   LBRACE   exprs RBRACE             { InitExprs($2) }
            |   string                            { InitStr($1) }
            |   string16                          { InitUStr($1) }

size        :   LBRACKET expr  RBRACKET           { FixSize $2 }
            |   LBRACKET       RBRACKET           { DynSize    }

conv        :   FOREIGN ID                        { Some $2 }

aligned     :   ALIGNED INT                       { Some $2 }

procedure   :   conv ID frmls body      { let (dec,stmt) = $4 in
                                          Procedure(p(),$1  ,$2,$3,dec,stmt) 
                                        }
            |        ID frmls body      { let (dec,stmt) = $3 in
                                          Procedure(p(),None,$1,$2,dec,stmt) 
                                        }


frmls       :   LPAREN  formals RPAREN            { rev $2 }
            |   LPAREN          RPAREN            { [] }
actls       :   LPAREN  actuals RPAREN            { rev $2 }
            |   LPAREN          RPAREN            { [] }

formals     :   formals COMMA formal              { $3 :: $1 }
            |   formal                            { [$1]     }
actuals     :   actuals COMMA actual              { $3 :: $1 }
            |   actual                            { [$1]     }

formal      :   STR INVARIANT ty ID     { p(),Some $1, Invariant, $3, $4 }
            |   STR           ty ID     { p(),Some $1,   Variant, $2, $3 }
            |       INVARIANT ty ID     { p(),None   , Invariant, $2, $3 }
            |                 ty ID     { p(),None   ,   Variant, $1, $2 }

actual      :   STR expr                          { p(),Some $1, $2 }
            |       expr                          { p(),None   , $1 }


flow        :   ALSO CUTS     TO names            { CutsTo(p(),rev $4)    }
            |   ALSO UNWINDS  TO names            { UnwindsTo(p(),rev $4) }
            |   ALSO RETURNS  TO names            { ReturnsTo(p(),rev $4) }
            |   ALSO ABORTS                       { Aborts(p())           }

flows       :   flows flow                        { $2 :: $1 }
            |   /**/                              { []       }

targets     :   TARGETS names                     { rev $2 }
            |   /**/                              { []     }

lvalue      :   ID                                { Var(p(),$1)             } 
            |   ty LBRACKET expr aligned RBRACKET { Mem(p(),$1,$3,$4)       }
            |   ty LBRACKET expr         RBRACKET { Mem(p(),$1,$3,None)     }

lvalues     :   lvalues COMMA lvalue              { $3 :: $1 }
            |   lvalue                            { [$1] }


ty          :   BITSn                             { BitsTy(p(),$1) }
            |   FLOATn                            { FloatTy(p(),$1) }

            /*
             *  the next production causes 2 shift/reduce
             *  conflicts because both decls and stmts can be
             *  empty
             */

body        :   LBRACE decls stmts RBRACE    { $2, rev $3 }
block       :   LBRACE       stmts RBRACE    {     rev $2 }

returnto    :   LT expr SLASH expr GT        { Some ($2,$4) }
            |   /**/                         { None         }

stmt        :   SEMI                         { EmptyStmt(p())               }
            |   ID COLON                     { LabelStmt(p(),$1)            }
            |   SPAN expr expr block         { SpanStmt(p(),$2,$3,$4)       }
            |   lvalues EQUAL exprs SEMI     { AssignStmt(p(),assign $1 $3) }

            |   lvalues EQUAL conv PPERCENT ID actls flows SEMI  
                        { PrimStmt(p(), (*varsOnly*) $1, $3, $5, $6, $7)       }
            |                 conv PPERCENT ID actls flows SEMI
                        { PrimStmt(p(), []        , $1, $3, $4, $5)            }
            |   lvalues EQUAL conv expr actls targets flows SEMI
                        { CallStmt(p(), (*varsOnly*) $1, $3, $4, $5, $6, $7)   }
            |                 conv expr actls targets flows SEMI
                        { CallStmt(p(), []        , $1, $2, $3, $4, $5)        }
            |   lvalues EQUAL      PPERCENT ID actls flows SEMI
                        { PrimStmt(p(), (*varsOnly*) $1, None, $4, $5, $6)     }
            |                      PPERCENT ID actls flows SEMI
                        { PrimStmt(p(), []        , None, $2, $3, $4)          }
            |   lvalues EQUAL      expr actls targets flows SEMI
                        { CallStmt(p(), (*varsOnly*) $1, None, $3, $4, $5, $6) }
            |                      expr actls targets flows SEMI
                        { CallStmt(p(), []        , None, $1, $2, $3, $4)      }
           
            |   IF expr block                     { IfStmt(p(),$2,$3,[])      }
            |   IF expr block ELSE block          { IfStmt(p(),$2,$3,$5)      }
            |   GOTO expr targets SEMI            { GotoStmt(p(),$2,$3)       }
            |   CONTINUATION ID LPAREN names0 RPAREN COLON
                                                  { ContStmt(p(),$2,rev $4)   }
            |   CUT TO ID actls flows SEMI        { CutStmt(p(),$3,$4, rev $5)}
            |   conv JUMP expr actls targets SEMI { JumpStmt(p(),$1  ,$3,$4,$5)}
            |        JUMP expr actls targets SEMI { JumpStmt(p(),None,$2,$3,$4)}
            |   conv RETURN returnto actls SEMI   { ReturnStmt(p(),$1  ,$3,$4)}
            |        RETURN returnto actls SEMI   { ReturnStmt(p(),None,$2,$3)}

stmts       :   stmts stmt                       { $2 :: $1 }
            |   /**/                             { []       }

expr        :   INT                              { Int(p(),$1, None)      }
            |   INT COLON INT                    { Int(p(),$1, Some $3)   }
            |   FLT                              { Float(p(),$1, None)    }
            |   FLT COLON INT                    { Float(p(),$1, Some $3) }
            |   CHAR                             { Char(p(),$1,None)      }
            |   CHAR COLON INT                   { Char(p(),$1, Some $3)  }
            |   lvalue                           { Fetch(p(),$1)          }
            |   PERCENT ID actls                 { PrimOp(p(),$2, $3)     }

            |   expr PLUS       expr             { BinOp(p(),$1,$2,$3)  }
            |   expr MINUS      expr             { BinOp(p(),$1,$2,$3)  }
            |   expr PERCENT    expr             { BinOp(p(),$1,$2,$3)  }
            |   expr STAR       expr             { BinOp(p(),$1,$2,$3)  }
            |   expr SLASH      expr             { BinOp(p(),$1,$2,$3)  }
            |   expr LLESS      expr             { BinOp(p(),$1,$2,$3)  }
            |   expr GGREATER   expr             { BinOp(p(),$1,$2,$3)  }
            |   expr CARET      expr             { BinOp(p(),$1,$2,$3)  }
            |   expr BAR        expr             { BinOp(p(),$1,$2,$3)  }
            |   expr AMPERSAND  expr             { BinOp(p(),$1,$2,$3)  }
            |   expr TILDE      expr             { BinOp(p(),$1,$2,$3)  }
            |   expr EEQ        expr             { BinOp(p(),$1,$2,$3)  }
            |   expr NEQ        expr             { BinOp(p(),$1,$2,$3)  }
            |   expr LT         expr             { BinOp(p(),$1,$2,$3)  }
            |   expr LEQ        expr             { BinOp(p(),$1,$2,$3)  }
            |   expr GEQ        expr             { BinOp(p(),$1,$2,$3)  }
            |   expr GT         expr             { BinOp(p(),$1,$2,$3)  }

exprs       :   exprs COMMA expr                 { $3 :: $1 }
            |   expr                             { [$1]     }

names       :   names COMMA ID                   { $3 :: $1 }
            |   ID                               { [$1]     }

names0      :   names                            { $1 }
            |   /**/                             { [] }



string      :   STR                              { $1 }
string16    :   UNICODE LPAREN STR RPAREN        { $3 }
@


