% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:

\section{Machine-level control flow}

The [[Target]] module provides for substantial generality in the
implementation of control flow:
a target can use any appropriate RTL to represent a control-flow
instruction.
But on most targets, the full generality of the abstraction is not
needed.
A~typical target works with a program counter, which it manipulates in
typical ways.
This module is intended to help reduce the burden of retargeting by providing
the ``standard'' implementations of
control flow at the machine level.
Basically if we know the program counter plus a few facts about return
address, we know enough to go on with.
(To get [[cutto]] right, we will have to add knowledge of the stack
pointer.)

We assume that a machine has a program counter and registers.
Furthermore, we use two different locations to refer to the program
counter: one in an lvalue context and another in an rvalue context.
These are called [[pc_lhs]] and [[pc_rhs]] in the source; here we call
them \emph{nPC} (new PC or next PC) and \emph{PC}.
The distinction is useful to support machines with delayed branches,
such as the SPARC, MIPS, and HP PA-RISC.

We also assume that the call instruction captures the return address
in a register, which we call \emph{RA}.
The ``standard'' implementations of control flow are then as
follows:\\
\begin{tabularx}{\linewidth}{@{\hskip 1.5em}lX}
\texttt{goto} $L$& $\mathit{nPC} \mathbin{:=} L$\\
\texttt{jump} $L$& $\mathit{nPC} \mathbin{:=} L$\\
\texttt{call} $L$& $\mathit{nPC} \mathbin{:=} L \mathrel{|}
                    \mathit{RA} \mathbin{:=} \mathit{PC}+k $\\
\texttt{branch} $p$ $L$&
   $p \rightarrow \mathit{nPC} \mathbin{:=} L$\\
\end{tabularx}
Note that [[cut to]] is not yet correctly implemented in this
interface.

The condition in a conditional branch can be negated by calling [[bnegate]]
on the branch instruction.

Also note that there is no place for [[return]] in this interface.
On many machines, [[return]] is simply an indirect jump, for which
[[goto]] can be used.
On other machines, there seems to be no standard way of, e.g.,
tagging a return for branch prediction or manipulating the stack
pointer during a return.
Targets for such machines will have to define [[return]] on an
individual basis.

<<mflow.mli>>=
<<signatures>>
<<signatures>>=
module type PC = sig
  val pc_lhs : Rtl.loc
  val pc_rhs : Rtl.loc
  val ra_reg : Rtl.loc
  val ra_offset : int   (* at call, ra_reg  := PC + ra_offset *)
end

type cut_args = { new_sp : Rtl.exp; new_pc : Rtl.exp }

module type S = sig (* see types Target.t and Target.map for doco *)
  type 'a map = ('a, Rtl.rtl) Ep.map
  val bnegate : Rtl.loc -> Rtl.rtl -> Rtl.rtl
  val goto    : Rtl.exp map
  val jump    : Rtl.exp map
  val cutto   : sp:Rtl.loc -> cut_args map  (* assumes sp and pc same width *)
    (* N.B. sp is a dynamic argument because it could differ among call conventions *)
  val call    : Rtl.exp map
  val return  : unit map
  val branch  : (Rtl.exp * Rtl.exp) map  (* probably should also be record *)
end
<<mflow.mli>>=
module MakeStandard (Pc : PC) : S
@ 
<<mflow.ml>>=
<<signatures>>
module RU = Rtlutil
module R  = Rtl
module RP = Rtl.Private

module MakeStandard (P : PC) = struct
  type 'a map = ('a, Rtl.rtl) Ep.map
  <<standard machine-level control flow>>
end
@ 
<<standard machine-level control flow>>=
module Up   = Rtl.Up
module Down = Rtl.Dn

let w = RU.Width.loc P.pc_lhs
let downrtl = R.Dn.rtl
let uploc   = R.Up.loc
let upexp   = R.Up.exp
@
In order to negate the branch condition in [[bnegate]], [[cmpneg]] takes a
comparison and flips the operator when possible. If the operator is "not",
then the operator is discarded; if the operator has no negation, then "not" is
applied.
<<standard machine-level control flow>>=
let cmpneg w ~cop ~fetch =
  let flip_op flip = RP.App ((flip, [w]), fetch) in
  match cop with
  | "eq"   -> flip_op "ne"
  | "ne"   -> flip_op "eq"
  | "lt"   -> flip_op "ge"
  | "le"   -> flip_op "gt"
  | "gt"   -> flip_op "le"
  | "ge"   -> flip_op "lt"
  | "ltu"  -> flip_op "geu"
  | "leu"  -> flip_op "gtu"
  | "gtu"  -> flip_op "leu"
  | "geu"  -> flip_op "ltu"
  | "feq"  -> flip_op "fne"
  | "fne"  -> flip_op "feq"
  | "flt"  -> flip_op "fge"
  | "fle"  -> flip_op "fgt"
  | "fgt"  -> flip_op "fle"
  | "fge"  -> flip_op "flt"
  | "not"  -> (match fetch with
               | [r] -> r
               | _ -> Impossible.impossible "negation of multiple arguments")
  | _      -> RP.App (("not", [w]), fetch)
let bnegate bool_flags r = match Down.rtl r with
  | RP.Rtl [RP.App((cop, [w1]), [RP.Fetch (flags, w2)]), RP.Store (pc, tgt, w3)]
    when pc = Down.loc P.pc_lhs && flags = Down.loc bool_flags
      && w1 = w && w2 = w && w3 = w ->
      Up.rtl (RP.Rtl [cmpneg w ~cop ~fetch:[RP.Fetch (flags, w)],
                               RP.Store (pc, tgt, w)])
  | _ -> Impossible.impossible "ill-formed conditional branch"
<<standard machine-level control flow>>=
let goto = { Ep.embed   = (fun e -> R.store P.pc_lhs e w)
           ; Ep.project = (fun r -> match downrtl r with
                                   | RP.Rtl [(_, RP.Store(_, e, _))] -> upexp e
                                   | _ -> Impossible.impossible "projected non-goto")
           } 
let jump = goto
@ 
By convention, the [[cut to]] \emph{always} puts the PC on the
\emph{left}.
This convention will be necessary at least until we have recognizers
that cope with associative-commutative operators.
<<standard machine-level control flow>>=
let cutto ~sp =
  { Ep.embed   = (fun {new_sp=new_sp; new_pc=new_pc} -> 
                   let assign loc e = Rtl.store loc e w in
                   Rtl.par [assign P.pc_lhs new_pc; assign sp new_sp])
  ; Ep.project = (fun r -> match downrtl r with
                           | RP.Rtl [ (_, RP.Store(_,  npc, _))
                                    ; (_, RP.Store(_ , nsp, _))] ->
                                { new_sp=upexp nsp; new_pc= upexp npc }
                           | _ -> Impossible.impossible "projected non-cutto")
  }
<<standard machine-level control flow>>=
let ra_val = 
  let pc = R.fetch P.pc_rhs w in
  RU.addk w pc P.ra_offset

let call = { Ep.embed   = (fun e -> R.par [R.store P.pc_lhs e w;
                                          R.store P.ra_reg ra_val w])
           ; Ep.project = (fun r -> match downrtl r with
                                   | RP.Rtl [(_, RP.Store(_, e, _)); _] -> upexp e
                                   | _ -> Impossible.impossible "projected non-call")
           } 
<<standard machine-level control flow>>=
let return = 
    { Ep.embed   = (fun () -> R.store P.pc_lhs (R.fetch P.ra_reg w) w)
    ; Ep.project = (fun r  -> match downrtl r with
                  | RP.Rtl [(_, RP.Store(_, _, _))] -> ()
                  | _ -> Impossible.impossible "projected non-return"
                  )
    }              
<<standard machine-level control flow>>=
let branch =
  { Ep.embed   = (fun (cond, tgt) -> R.guard cond (goto.Ep.embed tgt))
  ; Ep.project = (fun r -> match downrtl r with
                          | RP.Rtl [(b, RP.Store(_, e, _))] -> (upexp b, upexp e)
                          | _ -> Impossible.impossible "projected non-branch")
  } 
