% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:

\section{Machine-level control flow}

The [[Target]] module provides for substantial generality in the
implementation of control flow:
a target can use any appropriate RTL to represent a control-flow
instruction.
But on most targets, the full generality of the abstraction is not
needed.
A~typical target works with a program counter, which it manipulates in
typical ways.
This module is intended to help reduce the burden of retargeting by providing
the ``standard'' implementations of
control flow at the machine level.
Basically if we know the program counter plus a few facts about return
address, we know enough to go on with.
(To get [[cutto]] right, we will have to add knowledge of the stack
pointer.)

We assume that a machine has a program counter and registers.
Furthermore, we use two different locations to refer to the program
counter: one in an lvalue context and another in an rvalue context.
These are called [[pc_lhs]] and [[pc_rhs]] in the source; here we call
them \emph{nPC} (new PC or next PC) and \emph{PC}.
The distinction is useful to support machines with delayed branches,
such as the SPARC, MIPS, and HP PA-RISC.

We also assume that the call instruction captures the return address
in a register, which we call \emph{RA}.
The ``standard'' implementations of control flow are then as
follows:\\
\begin{tabularx}{\linewidth}{@{\hskip 1.5em}lX}
\texttt{goto} $L$& $\mathit{nPC} \mathbin{:=} L$\\
\texttt{jump} $L$& $\mathit{nPC} \mathbin{:=} L$\\
\texttt{call} $L$& $\mathit{nPC} \mathbin{:=} L \mathrel{|}
                    \mathit{RA} \mathbin{:=} \mathit{PC}+k $\\
\texttt{branch} $p$ $L$&
   $p \rightarrow \mathit{nPC} \mathbin{:=} L$\\
\end{tabularx}
Note that [[cut to]] is not yet correctly implemented in this
interface.

Also note that there is no place for [[return]] in this interface.
On many machines, [[return]] is simply an indirect jump, for which
[[goto]] can be used.
On other machines, there seems to be no standard way of, e.g.,
tagging a return for branch prediction or manipulating the stack
pointer during a return.
Targets for such machines will have to define [[return]] on an
individual basis.

<<mflow.mli>>=
<<signatures>>
<<signatures>>=
module type PC = sig
  val pc_lhs : Rtl.loc
  val pc_rhs : Rtl.loc
  val ra_reg : Rtl.loc
  val ra_offset : int   (* at call, ra_reg  := PC + ra_offset *)
end

module type S = sig (* see types Target2.t and Target2.map for doco *)
  val goto  : Rtl.exp Target2.map
  val jump  : Rtl.exp Target2.map
  val cutto : (Rtl.loc * Rtl.exp * Rtl.exp) Target2.map
  val call  : Rtl.exp Target2.map
  val branch : (Rtl.exp * Rtl.exp) Target2.map
end
<<mflow.mli>>=
module MakeStandard (Pc : PC) : S
@ 
<<mflow.ml>>=
<<signatures>>
module RU = Rtlutil
module R  = Rtl
module RP = Rtl.Private
module T  = Target2

module MakeStandard (P : PC) = struct
  <<standard machine-level control flow>>
end
@ 
<<standard machine-level control flow>>=
let w = RU.Width.loc P.pc_lhs
let downrtl = R.Dn.rtl
let uploc   = R.Up.loc
let upexp   = R.Up.exp
let goto = { T.embed   = (fun e -> R.store P.pc_lhs e w)
           ; T.project = (fun r -> match downrtl r with
                                   | RP.Rtl [(_, RP.Store(_, e, _))] -> upexp e
                                   | _ -> Impossible.impossible "projected non-goto")
           } 
let jump = goto
let cutto = { T.embed   = (fun (sp,newsp,newpc) -> 
                               let assign loc e  =
                                   Rtl.store loc e (Rtlutil.Width.exp e) in
                               Rtl.par [assign sp newsp; assign P.pc_lhs newpc])
            ; T.project = (fun r -> match downrtl r with
                                    | RP.Rtl [ (_, RP.Store(sp, nsp, _))
                                             ; (_, RP.Store(_ , npc, _))] ->
                                         (uploc sp, upexp nsp, upexp npc)
                                    | _ -> Impossible.impossible "projected non-cutto")
            }

let ra_val = 
  let pc = R.fetch P.pc_rhs w in
  RU.addk w pc P.ra_offset

let call = { T.embed   = (fun e -> R.par [R.store P.pc_lhs e w;
                                          R.store P.ra_reg ra_val w])
           ; T.project = (fun r -> match downrtl r with
                                   | RP.Rtl [(_, RP.Store(_, e, _)); _] -> upexp e
                                   | _ -> Impossible.impossible "projected non-call")
           } 

let return = 
    { T.embed   = (fun () -> R.store P.pc_lhs (R.fetch P.ra_reg w) w)
    ; T.project = (fun r  -> match downrtl r with
                  | RP.Rtl [(_, RP.Store(_, _, _))] -> ()
                  | _ -> Impossible.impossible "projected non-return"
                  )
    }              

let branch =
  { T.embed   = (fun (cond, tgt) -> R.guard cond (goto.T.embed tgt))
  ; T.project = (fun r -> match downrtl r with
                          | RP.Rtl [(b, RP.Store(_, e, _))] -> (upexp b, upexp e)
                          | _ -> Impossible.impossible "projected non-branch")
  } 
