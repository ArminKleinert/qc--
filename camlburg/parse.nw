% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
<<parse.mli>>=
type decls = { start : Spec.nonterm list
             ; types : (Spec.ty * Spec.nonterm list) list
             ; terms : string list
             ; head  : Code.fragment list
             }
val spec : Token.t list -> (decls * Spec.rule list) * Token.t list
<<parse.ml>>=
module Pc = Pcagain  (* embarrassing -- too many parser combinators *)
open Pc
module T = Token
module S = Spec
let satisfy = Pc.satisfy' T.to_string
type 'a producer = ('a, Token.t) Pc.parse
let some f = Pc.some' T.to_string f

let quote s = "`" ^ s ^ "'"

let name   = satisfy "name" (function T.Name _ -> true | _ -> false) >> T.to_string
let is_name n =
  satisfy (quote n) (function T.Name n' when n = n' -> true | _ -> false)
  >> const ()
let (!* ) s = satisfy (quote s) ((=) (T.Reserved s)) >> T.to_string
let newline = satisfy "newline" ((=) T.Eol)
let int  = some "integer"   (function T.Int n  -> Some n | _ -> None)
let xxx = Some "gi"

let exp_of_code frags = Code.Raw frags
let some_code = function T.Code (l, c) -> Some [Code.Synch l; Code.Line c] | _ -> None
let raw_code = some "{: ... :}" some_code
let code = raw_code >> exp_of_code


let ( *$-- ) a p = !* a -- !!p >> snd
let ( *--$ ) p a = p -- !! (!* a) >> fst

let rec commas p tokens = (p -- ("," *$-- commas p || empty) >> cons) tokens

let getOpt o default = match o with
  | Some x -> x
  | None -> default
    
let rec tree tokens = (
  name --> (  "(" *$-- commas tree *--$ ")" >> (fun l n -> S.Tree (n, l))
           || optional (":" *$-- name) >> (fun nt n -> S.Var (n, getOpt nt n))
           )
  || int >> (fun n -> S.Const (S.Int n))
) tokens


let (-^-) x y = x -- y >> (fun (x, y) -> x ^ " " ^ y)



let apply (f, l) = match l with
| [] -> f
| _  -> List.fold_left (fun f arg -> Code.Apply (f, arg)) f l
let rec funapps    p = p -- repeat p >> apply
let rec ssep comma p = p -- repeat (!* comma ->- p) >> cons
let tuple = function [e] -> e | l -> Code.Tuple l
let _ = (funapps : Code.exp producer -> Code.exp producer)
let _ = (ssep : string -> 'a producer -> 'a list producer)

let rec mlexp toks =
  let mlexp = (mlexp : Code.exp producer) in
  funapps (  name                                  >> (fun x -> Code.id x)
          || int                                   >> (fun n -> Code.Int n)
          || !* "(" ->- ssep "," mlexp -<- !* ")"  >> (fun l -> tuple l)
          || !* "[" ->- ssep ";" mlexp -<- !* "]"  >> (fun l -> Code.List l)
          ) toks

let cost = "[" *$-- mlexp *--$ "]"

let zero = Code.Int 0

let (rule : S.rule producer) = 
  name *--$ ":" -- !!tree -- !!(optional cost >> (fun c -> getOpt c zero)) -- !!code
  >> (fun (((nt, t), cost), code) -> (nt, t, cost, code))

let rule = rule -<- newline -<- repeat newline

let nonterm = name

let key n p = !*"%" ->- is_name n ->- !! p

type decl = Start of S.nonterm | Type of S.ty * S.nonterm list | Newline

let ty = name

type decls = { start : S.nonterm list
             ; types : (S.ty * S.nonterm list) list
             ; terms : string list
             ; head  : Code.fragment list
             }
let decl =
  let start nt ({ start=s; types=tys; terms=ts; head=h } as state) =
    if List.exists ((=) nt) s then state
    else {start=nt::s; types=tys; terms=ts; head=h}  in
  let addty (t, nts) { start=s; types=tys; terms=ts; head=h } =
    { start=s; types=(t, nts)::tys; terms=ts; head=h }  in
  let addterms terms { start=s; types=tys; terms=ts; head=h } =
    { start=s; types=tys; terms=terms@ts; head=h }  in
  let addheader frags { start=s; types=tys; terms=ts; head=h } =
    { start=s; types=tys; terms=ts; head=h@frags }  in
  
     key "start" nonterm                                  >> start
  || key "type"  ("<" *$-- ty *--$ ">" -- repeat nonterm) >> addty
  || key "term"  (repeat name)                            >> addterms
  || key "head"  raw_code                                 >> addheader
  || newline                                              >> (fun _ s -> s)

let decls = fold decl {start=[]; types=[]; terms=[]; head=[]}

let spec = !! (decls *--$ "%%" -<- repeat newline -- repeat rule -<- eof T.to_string)

