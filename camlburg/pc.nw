% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
\section{Parsing combinators}
<<pc.ml>>=
(* parsing combinators *)
type ('a, 'sym) parse = 'sym list -> 'a * 'sym list

let error nt why tokens = 
  ( List.iter prerr_string ["Error parsing "; nt; ": "; why; "\n  remaining tokens"]
  ; let rec show = function
                   | _, 0 -> (prerr_newline(); exit 1)
                   | h::t, n -> prerr_string " "; prerr_string h; show (t, (n-1))
                   | [], _ -> (prerr_newline(); exit 1)
    in  show (tokens, 6))

exception E of string * string * string list
let fail f nt why toks = raise (E(nt, why, List.map f toks))

(*
infix 5 --
infix 3 >>
infix 0 ||
infix 6 *$-- *--$
*)

let (||) p1 p2 toks = try p1 toks with E _ -> p2 toks
let (!!) p tokens = try p tokens with E (nt, why, tokens) -> error nt why tokens

let (--) p1 p2 tokens = 
  let (x, tokens) = p1 tokens in
  let (y, tokens) = p2 tokens in
  ((x, y), tokens)

let (->-) p1 p2 tokens = 
  let (x, tokens) = p1 tokens in
  let (y, tokens) = p2 tokens in
  (y, tokens)

let eof f = function
  | [] as toks -> ((), toks)
  | toks -> fail f "expected end of file" "eof" toks

let (-<-) p1 p2 tokens = 
  let (x, tokens) = p1 tokens in
  let (y, tokens) = p2 tokens in
  (x, tokens)

let (-->) p1 p2 tokens = 
  let (x, tokens) = p1 tokens in
  let (f, tokens) = p2 tokens in
  (f x, tokens)

let (>>) p f tokens = 
  let (x, tokens) = p tokens
  in  (f x, tokens)
 
let id x = x
let const k x = k
let cons (x, y) = x :: y

let expect' f a = function
  | (x::xs) when a = x -> (a, xs)
  | toks -> fail f "unknown" ("expected " ^ f a) toks

let satisfy' f what p = function
  | (x::xs) when p x -> (x, xs)
  | toks -> fail f "?" ("Expected " ^ what) toks
 
let some' f what p = function
  | (x::xs) -> (match p x with Some y -> (y, xs)
                             | None -> fail f "unknown" ("Expected " ^ what) (x::xs))
  | toks -> fail f "unknown" ("Expected " ^ what) toks



let empty tokens = ([], tokens)
let rec repeat p tokens = (p -- repeat p >> cons || empty) tokens
let optional ph = ph >> (fun x -> Some x) || empty >> const None

let rec fold p zero tokens = (  p -- fold p zero >> (fun (f, z) -> f z)
                             || empty            >> const zero 
                             ) tokens
let fold = (fold : ('a -> 'a, 't) parse -> 'a -> ('a, 't) parse)

(*
let ( *$--) a ph = ($a -- !!ph >> #2)
fun (ph --$ a) = (ph -- !!($a) >> #1)
let commas p tokens = (p -- ("," $-- force (commas p) || empty) >> op ::) tokens
*)
          
@ 
