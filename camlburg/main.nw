% vim: set ts=8 sw=4 et:

% ------------------------------------------------------------------ 
\section{The Main Function}
% ------------------------------------------------------------------ 

This module contains the entry point of the application and deals with
error reporting and command line arguments. Since this module has no
clients, it exports nothing.

<<main.mli>>=
(* nothing *)
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<main.ml>>=
module S = Spec
let rcsid   = "$Id$"
let version = [ "ocamlburg 0.1" 
              ; "(c) 2002 Christian Lindig <lindig@eecs.harvard.edu>"
              ; "         Norman Ramsey <nr@eecs.harvard.edu>"
              ]

exception Error of string
let error msg = raise (Error msg)

@

The [[read]] function reads a specification from a file and returns it
as a [[Spec.t]] value. It catches error related to scanning and parsing
and reports them by raising the local [[Error]] exception.

<<main.ml>>=
let read (file:string) =
    let fd        = try open_in file
                    with Sys_error(msg) -> error msg in
    let finally   = fun () -> close_in fd in              
    let lexbuf    = Lexing.from_channel fd in
    let map       = Srcmap.mk () in
    let lexer lb  = Lex.token lb map in
    let here lb   = Srcmap.Str.point (map, Lexing.lexeme_start lb) in
        try 
            let () = Srcmap.sync map 0 (file,1,1)
            and t  = Parse.spec lexer lexbuf 
                in finally ();t     (* the result *)
        with
            | Parseerror.Error(msg) ->
                ( finally ()
                ; error (Printf.sprintf "semantic error at %s: %s" 
                         (here lexbuf) msg)
                ) 
            | Parsing.Parse_error ->
                ( finally ()
                ; error (Printf.sprintf "parse error at %s" (here lexbuf))
                )          
            | Lex.Error msg -> 
                ( finally ()
                ; error 
                    (Printf.sprintf "scan error at %s: %s" (here lexbuf) msg)
                )
            | e ->
                ( finally ()    (* just clean up *)
                ; raise e
                )
@

The main function expects the file name of the specification on the
command line. It reads the file and calls the code generator.

<<main.ml>>=
let help = 
    [ "usage: ocamlburg file.mlb"
    ; "       ocamlburg -version       show version, authors"
    ; "       ocamlburg -norm          for debugging, show normalized rules"
    ; "       ocamlburg -help          this"
    ]
    
let main () =
    let argv        = Array.to_list Sys.argv in
    let this        = Filename.basename (List.hd argv) in
        match List.tl argv with
        | ["-norm"; file] ->
            let spec  = read file               in
            let rules = Norm.rules spec.S.rules in
            let doc   = Spec.PrettyPrint.rules rules in
                Code.Print.doc doc
        | ["-version"] -> 
            List.iter print_endline version
        | ["-help"] | ["--help"] ->
            List.iter print_endline help            
        | [file] -> 
            let spec = read file in
                (try Burg.generate spec stdout 
                 with Burg.Error msg -> error ("semantic error: "^msg))
        | _ -> 
            error (Printf.sprintf "try `ocamlburg -help'") 
@

At program startup the expression below is evaluated and thus the
[[main]] function called, which does all the work. In case of an error
we report it and exit with a return code of [[1]].

<<main.ml>>=
let _ = 
    try 
        main (); exit 0
    with 
        Error msg -> 
            ( Printf.eprintf "%s\n" msg
            ; exit 1
            )
@

% ------------------------------------------------------------------ 
\subsection{Manual Page}
% ------------------------------------------------------------------ 

The manual page is written in Perl's POD format. This file format can be
translated to a variety of formats, including plain ASCII, Troff, and
HTML.

<<ocamlburg.pod>>=
=head1 NAME

ocamlburg -- Burg code generator generator for Objective Caml

=head1 SYNOPSIS

B<ocamlburg> I<spec.mlb> 

=head1 DESCRIPTION

B<ocamlburg> generates Objective Caml source code from a Burg specification
I<spec.mlb> and emits it to stdout. The generated code implements a
dynamic programming algorithm to cover a tree structure with minimal
cost. B<ocamlburg> is inspired by David Hanson's iburg(1) for C:   Fraser
and Hanson: "Engineering a Simple, Efficient Code Generator Generator",
ACM Letters on Programming Languages and Systems 1, 3 (Sep 1992),
213-226.

=head1 OPTIONS

=over

=item B<-version>

Prints some version information to stdout.

=item B<-help>

Prints a short options summary to stdout.

=item B<-norm> I<spec.mlb>

This is an option for debugging B<ocamlburg>. B<ocamlburg> normalizes rules
during the translation process. In a normalized rule no constructor
pattern has another constructor pattern as argument. When the B<-norm>
flag is present, B<ocamlburg> emits the normalized rule set to stdout.

=back

=head1 BURG SPECIFICATION

B<ocamlburg> accepts a Burg specification that conforms to the following
EBNF grammar. Terminals are enclosed double quotes, all other symbols
are nonterminals. 

    spec    :   { decl } "%%" { rule }

    decl    :   "%term" { ident }
            |   "%head" code
            |   "%tail" code

    rule    :   nonterm ":" pattern [ cost ] code

    code    :   "{:" camlcode ":}"
    cost    :   "[" number | code "]"
    
    pattern :   number
            |   """ string """
            |   "'" char "'"
            |   ident "(" pattern { "," pattern } ")"
            |   ident "(" ")"
            |   ident [ ":" ident ]

In addition to the grammar above, a rule pattern must not be a literal
number, literal string, or a terminal variable. Those can only appear as
constructor arguments like in C<Int(23)>. 

    alpha       = ['a'-'z' 'A'-'Z']
    digit       = ['0'-'9']
    ident       = alpha(digit|alpha|'_')*
    number      = digit+

A I<string> is enclosed in double quotes, a I<number> is a non-negative
integer, a I<char> is enclosed in single quotes. Use escapes for newline
C<\n>, return C<\r>, tabs C<\n>, and single quotes C<\'> in character
constants.  I<Camlcode> is arbitrary code that may include properly
nested pairs of C<{:> and C<:}>. An identifier must start with a
character and can be followed by characters, numbers, and underscores.
Comments start with two hyphens and go to the end of the line.  

Beware when using constructors without arguments: C<Nil> is a variable,
C<Nil()> a constructor. It is easy to forget the parentheses for the
constructor. 

Certain identifier are keywords and cannot be used as variables or
nonterminals: C<start>, C<term>, C<type>, C<head>, C<tail>. Three terminal
types are predefined: C<int>, C<string>, and C<char>. They correspond to
number, string, and character literals.

Here is an example for a specification:

    -- 
    -- sample.mlb
    --

    %head {: (* generated from sample.mlb, do not edit *) }
    %term int string        -- terminal type must be declared

    %%

    number : ADD(x:number,  y:number)     [2]    {: x + y :}
    number : ADD(x:number,  NULL())       [1]    {: x     :}
    number : ADD(x:number,  ADD(NULL(), z:number))  [1] {: x + z :}
    number : SUB(n:number, m:number)             {: n-m :}
    number : MUL(n:number, m:number)             {: n*m :}
    number : DIV(n:number, m:number)    
            {: if m = 0 then assert false else n/m :}
    number : CONST(x: int)                [1]    {: x :}
    number : CONST(0)                     [0]    {: 0 :}

    str    : STR(x: string)               [1]    {: x :}
    str    : CONS(x: string, y:string)    [2]    {: x ^ y :}

    -- chain rules
    str    : number                [1]    {: string_of_int number :}
    number : str                   [1]    {: int_of_string str    :}

Code associated with a C<%head> declaration is copied verbatim to the
output I<before> the code generated for rules, code from a C<%tail>
declaration goes I<after> code for rules. This code is used to declare
type and values used by user code in the rules. A C<%term> declaration
lists Objective Caml types used for variables in rules. In the example
above, C<x:number> is a nonterminal variable, and C<x:string> is a
terminal variable, because C<string> was declared as a terminal type.

A rule defines a nonterminal (type) that is to the left of the colon,
has a pattern, an optional non-negative cost, and a user-provided action. 
A pattern is similar to a pattern in Objective Caml: it can be a literal
value, a terminal or nonterminal variable, or have a constructor with
more patterns as arguments. When a rule is selected and executed at
run-time, it computes a value of the nonterminal of its left hand side.


    -- chain rules
    str    : number                [1]    {: string_of_int number :}
    number : str                   [1]    {: int_of_string str    :}

A variable I<x> without a type annotation stands for a variable
I<x>B<:>I<x>. This often allows to omit types from variables if the
types of variables in a pattern are distinct.  The two so-called chain
rules at the end of the specification are an example: the C<number>
variable in the first rule stands for C<number:number> and thus matches
a C<number> nonterminal value. Chain rules are rules that have only a
non-terminal variable as pattern. They provide conversions between
nonterminal values: a C<number> nonterminal value can be converted into
a C<str> nonterminal value at cost one by the first rule. The two rules
are recursive but the associated costs of one prevent that they are
applied indefinitely.

Rules have an associated non-negative cost.  The cost of a rule is
the sum of cost of its arguments and its own cost, which defaults to
zero.  The cost of arguments are computed at run-time. The rule's own
cost is either static, or dynamic. In the dynamic case the user provides
a cost expression that is evaluated at run-time. The values of terminal
variables in the pattern are available for the cost expression.

=head1 THE GENERATED CODE

The purpose of the generated code is to select the rules from a set that
match a (subject) tree at the smallest cost, according to the cost
annotations.  The generated code contains a function for every
constructor. For the example above, these are:

    module Camlburg: sig
        type cost = int                      
        type 'a nt =                        
            { cost : cost
            ; action : unit -> 'a; 
            } 
        ...
    end

    type ('a, 'b, 'c, 'd) nonterm = 
        { _ADD2     : 'a;           (* private *)
        ; _NULL1    : 'b;           (* private *)
        ; number    : 'c;
        ; str       : 'd;
        } 


    type t =
        ( int       Camlburg.nt     (* private *)
        , unit      Camlburg.nt     (* private *) 
        , int       Camlburg.nt     (* for number nonterminal *)
        , string    Camlburg.nt     (* for str    nonterminal *)  
        ) nonterm 
        
    val conNULL  : unit -> t
    val conCONST : int -> t
    val conSTR   : string -> t
    val conCONS  : string -> string -> t
    val conDIV   : t -> t -> t   
    val conADD   : t -> t -> t   
    val conMUL   : t -> t -> t   
    val conSUB   : t -> t -> t   


=head1 THE CLIENT

To find the cheapest cover for a subject tree, the client walks over the
subject tree and calls the appropriate function for the actual node: For
every pattern constructor I<C> the generated code contains a function
C<con>I<C>.  At a leave with an integer constant, it calls C<conCONST>.
There are two rules for the C<CONST> constructor, depending on the
integer constant the generated code will select the cheaper one and
return a value of type C<t>. This value represents the user-provided
code of the selected rule and the associated cost.  If the client comes
to a node with an C<ADD> constructor, it calls C<conADD> and passes
values as arguments that were returned by the above functions when the
child notes were visited. Finally, the client comes to the root node and
receives a final C<t> value for it. This value represents the cheapest
cover for the subject tree. 

Typically, the root node of a subject tree is covered only by a single
nonterminal, for example the C<number> nonterminal. When the C<action>
for this nonterminal is triggered, the user actions from the rules for
the cheapest cover are computed:

    ...
    let t = conADD(left,right) in
        t.number.Camlburg.action ()     (* an int value *)

The generated code thus has constructed a value C<t> that represents the
cheapest set of rules (and therefore actions) that cover the walked
tree. The C<action> field of the finally returned value gives access to
the actions. In the example, the tree is some kind of expression tree
and the constructed action is an evaluation. Because of the chain rules,
tree that is covered by a C<number> value is also covered by a C<str>
value. This allows to obtain a string value as well:

    ...
    let t = conADD(left,right) in
        t.str.Camlburg.action ()        (* an string value *)

=head1 FILES

The generated code relies on the small module C<Camlburg> that comes as
C<camlburg.mli> and C<camlburg.ml> with B<ocamlburg>. 

=head1 AUTHORS

Christian Lindig <lindig@eecs.harvard.edu>, 
Norman Ramsey <nr@eecs.harvard.edu>.

=head1 COPYING

This software is in the public domain.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND COPYRIGHT HOLDER BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
@

=head1 SEE ALSO

ocaml(1)

Fraser and Hanson: "Engineering a Simple, Efficient Code Generator
Generator", ACM Letters on Programming Languages and Systems 1, 3 (Sep
1992), 213-226.

http://www.cminusminus.org/. B<ocamlburg> is part of the Quick C--
compiler.

=head1 AUTHORS

Norman Ramsey <nr@eecs.harvard.edu>, Christian Lindig
<lindig@eecs.harvard.edu>
@


