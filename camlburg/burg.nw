
% ------------------------------------------------------------------ 
\section{Burg Code Generation}
% ------------------------------------------------------------------ 

This module implements the code generator for a Burg specification. The
[[generate]] function writes the code to a provided channel and raises
[[Error]] in the case of semantic errors in the specification. 

<<burg.mli>>=
exception Error of string
val generate: Spec.t -> fd:out_channel -> unit  (* Error *)
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<burg.ml>>=
module S         = Spec
module C         = Code
module StringMap = Map.Make(struct type t = string let compare = compare end)
module StringSet = Set.Make(struct type t = string let compare = compare end)

let rcsid = "$Id$"
@

We build several maps from strings to lists. If we cannot find a key in
a map this is equivalent to a key mapped to the empty list.

<<burg.ml>>=
let lookup map x = try StringMap.find x map with Not_found -> [] 
@

Semantic errors in a specification are reported with the [[Error]]
exception.

<<burg.ml>>=
exception Error of string
let error msg = raise (Error msg)
@

I have banned the dirty code generation into a sub-module but I'm not
sure this really works.


<<burg.ml>>=
<<sorting rules by cost>>
module CodeGen = struct
    <<CodeGen>>
end

<<burg logic>>
@


% ------------------------------------------------------------------ 
\subsection{Burg Logic}
% ------------------------------------------------------------------ 

We like to sort certain actions based on the cost associated with them.
The cost associated with a rule is a [[Code.exp]] value. In pratice it
is limited to be a non-negative integer or a raw code fragment. Our
total order assigns the smallest cost to raw code fragments.

<<sorting rules by cost>>=
let cost_order x y = match x, y with
    | C.Int x , C.Int y  -> compare x y     
    | C.Raw x , C.Raw y  -> compare x y     
    | C.Int _ , C.Raw _  -> 1               (* raw is smaller *)
    | C.Raw _ , C.Int _  -> -1              (* raw is smaller *)
    | _                  -> assert false    (* can't happen *)
@    

We continue the cost order to rules, i.e.~we define an order that sorts
rules by cost:

<<sorting rules by cost>>=
let rule_order x y = cost_order x.S.cost y.S.cost
@

Normalized rules can be divded into two disjoint classes, depending on
their right hand side:

\begin{itemize}
\item A rule with only a non-terminal variable as a pattern is a chain rule. 
      Since the left and the right hand side of a chain rule is a
      nonterminal, chain rules define a graph with nonterminals as
      nodes.
\item A rule with a constructor at the top-level matches constructors in
      the subject tree.
\end{itemize}

A possible third class is a rule with only a literal value, or a
terminal variable matching literals in the subject tree. This case is
syntactically excluded by the parser because it makes little sense from
a semantic point of view.  

Each class of rules is treated differently for code generation. With
[[split]] we make one pass over the list of rules in a specification and
build simultaneously two data structures, one for each class:

\begin{itemize}
\item A map from the right hand nonterminal of a chain rule to the
      chain rules that have this non-terminal on their right hand side.
      For example, the chain rules $x:y$, $x:z$, $a:b$, $a:y$ lead to
      the map $y \mapsto [a:y, x:y]$, $b \mapsto [a:b]$, $z \mapsto
      [x:z]$. 

\item A map from constructors to the rules using them.
\end{itemize}

<<burg logic>>=
type maps =
    { chains:   S.rule list StringMap.t
    ; cons:     S.rule list StringMap.t
    }
       
let split = 
    let add maps rule = 
        match rule.S.pattern with
        | S.Var(_, S.NonTerm(right)) ->     
            { maps with chains = 
                StringMap.add right (rule::lookup maps.chains right) maps.chains
            } 
        | S.Con(con,_) ->
            { maps with cons =
                StringMap.add con (rule::lookup maps.cons con) maps.cons
            }
        | S.Literal(l) ->           assert false (* syntactically impossible *)
        | S.Var(_, S.Term(term)) -> assert false (* syntactically impossible *) 
    and e = StringMap.empty 
    in
        List.fold_left add {chains = e; cons = e} 
@

At run-time, a polymorphic value is represented by a record that has a
field for every nonterminal in the specification. The [[nonterms]]
function collects the set of all nonterminals from a list of
\emph{normalized} rules and returns them in a list.

<<burg logic>>=
let nonterms rules =
    let add set rule = StringSet.add rule.S.nonterm set in
        StringSet.elements (List.fold_left add StringSet.empty rules)
@

[[Generate]] is the only exported function. It normalizes the rules,
inferrres the type of every constructor, collects all nonterminals, and
finally triggers code generation.

<<burg logic>>=
let generate spec ~fd:chan =
    let top def   = Pp.ppToFile chan 77 (Code.Print.toplevel def) in
    let exp def   = Pp.ppToFile chan 77 (Code.Print.exp def) in
    let tydecl d  = Pp.ppToFile chan 77 (Code.Print.tydecl d) in
    let rules     = Norm.rules spec.S.rules in
    let types     = try S.con_types rules with S.Error msg -> error msg in
    let nts       = nonterms rules in
    let maps      = split rules in
    let nl n      = for i=1 to n do print_newline () done in     
        if rules <> [] then     
             ( List.iter exp spec.S.heads
             ; nl 2
             ; tydecl (CodeGen.tydecl nts) 
             ; nl 2
             ; top (CodeGen.infdef nts)
             ; nl 2
             ; top (CodeGen.nonterms nts maps.chains)
             ; nl 2
             ; top (CodeGen.constructors maps.cons types)
             ; nl 2
             ; List.iter exp spec.S.tails
             )
        else
             ( List.iter exp spec.S.heads
             ; nl 2
             )
@

% ------------------------------------------------------------------ 
\subsection{Code Generating Functions}
% ------------------------------------------------------------------ 

The functions in this section generate code by building their abstract
syntax using the [[Code]] module.

First, here are some special cases of constructor functions for
Objective Caml syntax.

<<CodeGen>>=
let action exp      = C.fun' [C.none] exp
let geq x y         = C.apply (C.apply (C.id ">=") x) y
let let' x e body   = C.let' [C.var' x, e] body
let apply2 f x y    = C.apply (C.apply f x) y
@

The cost of a rule is a sum of integers an user-provided code. We
optimize away the zeroes.

<<CodeGen>>=
let add x y = match x, y with
    | (C.Int 0), y -> y
    | x, (C.Int 0) -> x
    | x, y       ->  C.apply (C.apply (C.id "+")  x) y

let sum exps = List.fold_left add (C.Int 0) exps
@

[[Compose]] takes a list of function expressions $f_1, \ldots, f_n $ and
an argument expression $a$ and creates a application: $f_1 (f_2
(\cdots(f_n~a))\cdots)$. The argument is passed to $f_n$ first and the
result of that application to $f_{n-1}$ and so forth.  

<<CodeGen>>=
let compose fs arg = List.fold_left (fun x f -> C.apply f x) arg fs
@

<<CodeGen>>=
let nt         = "nt"
let x          = "x"
let cost       = "cost"
let upd x      = "update_" ^ x
let arg n      = "arg" ^ (string_of_int n)
let camlburg   = "Camlburg"
let path xs    = String.concat "." xs  
@

[[Choice]] puts its arguments into a list and applies [[choice]] to it.
The [[choice]] function is part of the run-time system.

<<CodeGen>>=
let choice = function
    | []  -> assert false
    | [x] -> x
    | xs  -> C.apply (C.longid [camlburg;"choice"]) (C.list xs)

(*
    (fun x ->
        (update_str
           { cost = nt.cost + 1
           ; action = fun () ->
                   let number = x.number.action ()
                   in string_of_int number 
           }) x)
*)

let chain_fn src rule =
    let dst     = rule.S.nonterm
    and c       = rule.S.cost
    and a       = rule.S.code
    and f       = C.longid ["x";src;camlburg;"action"]
    and ccost   = path [camlburg;"cost"]
    and caction = path [camlburg;"action"]
    in
        C.fun' [C.var' x] 
               (apply2 (C.id (upd rule.S.nonterm))
                       (C.record [ccost  , add (C.longid [nt;camlburg;cost]) c 
                                 ;caction, action (let' src (C.apply f C.unit)
                                                    a) 
                                 ])
                       (C.id x))
@                       


When a nonterminal is updated, the nonterminals connected to this one by
chain rules must be also updated. We want to update these chained
nonterminals in an order, such that the nonterminal with the small
additional costs are updated first. This requires to sort the cain rules
by their cost. 

<<CodeGen>>=
(*
    fun nt x ->
        if nt.cost >= x.number.cost then
            x
        else
            (* composed chain_fn *) { x with number = nt }
*)
let update_fn src chainrules =
    let arg     = C.recordwith x [src, C.id nt]             
    and chns    = List.map (chain_fn src) (List.sort rule_order chainrules)
    in    
        C.fun' [C.var' nt; C.var' x]
               (C.if' (geq (C.longid [nt;camlburg;cost]) 
                           (C.longid [x;src;camlburg;cost]))
                      (C.id x)
                      (compose chns arg))

(*  
    let rec update_number = (* update_fn *) 
    and update_str = (* udpdate_fn *)
    and ...
*)    

let nonterms nts map =
    C.def (List.map (fun nt -> upd nt, update_fn nt (lookup map nt)) nts)
@

Below is some monadic code to deal with the following problem: we have
to refer to function arguments [[arg1]], [[arg2], and so on. Code that
refers to these arguments is derived from an argument list of a pattern
constructor. The number of an argument depends on the position in the
argument list we are looking at. Thus, the actual position must be
threaded through the code generator. To make things a little bit easier
we define a state monad, where the [[state]] is the actual position.
The monadic map function [[mmap]] in particular allows to apply a function
to each argument in the argument list easily. 

<<CodeGen>>=
(* some monadic code to deal with argument positions *)
type state = int
type 'a m  = state -> ('a * state)

let return a  = fun s -> (a, s)
let (>>=) m f = fun s -> let (a, s') = m s in f a s'
let rec sequence  = function
    | []    -> return []
    | c::cs -> c >>= fun c -> sequence cs >>= fun cs -> return (c::cs) 
let mmap f xs = sequence (List.map f xs)
let getpos = fun n -> (n, n+1)      (* obtain argument position *)
@

The monadic [[cost]] function creates an expression that computes the
cost for a sub-tree that matches a constructor argument.

<<CodeGen>>=
let cost pat = getpos >>= fun n ->
    match pat with
    | S.Var(v, S.Term _)    -> return (C.int 0)
    | S.Var(v, S.NonTerm t) -> return (C.longid [arg n; t; camlburg;"cost"])
    | S.Con _               -> assert false (* not in normal form *)
    | S.Literal(S.Int i)    -> return (apply2 (C.longid [camlburg;"matches"]) 
                                              (C.int i)
                                              (C.id (arg n)))
    | S.Literal(S.String s) -> return (apply2 (C.longid [camlburg;"matches"]) 
                                              (C.string s)
                                              (C.id (arg n)))
    | S.Literal(S.Char c)   -> return (apply2 (C.longid [camlburg;"matches"]) 
                                              (C.char c)
                                              (C.id (arg n)))
@

The monadic [[bind]] function creates a binding for a variable in a
pattern. This function can be applied to any pattern; however, a literal
pattern does not define a variable. Therefore, an optional binding is
returned.

<<CodeGen>>=
let bind pat = getpos >>= fun n ->
    match pat with
    | S.Var(v, S.Term _)    -> 
        return (Some(C.var' v, C.id (arg n)))
    | S.Var(v, S.NonTerm t) -> 
        return (Some(C.var' v
                    , C.apply (C.longid [arg n; t; camlburg;"action"]) C.unit))
    | S.Con _ -> 
        assert false (* not in normal form *)
    | S.Literal(_) ->
        return None
@

The [[some]] function filters all values from a list of optional
values that are different from [[None]] and return them. This is used to
generate bindings for only those pattern arguments that define variables
and skip the others.

<<CodeGen>>=
let rec some = function
    | [] -> []
    | Some x :: xs -> x :: some xs
    | None   :: xs -> some xs
@
 
The specification for the cost of a rule is either a fixed number or a
user-provided Objective Caml expression. Such an expression can refer to
the values of terminal variables, which bind the actual value in the
subject tree. The [[bindcost]] function creates a binding for a pattern.

<<CodeGen>>=
let codebind pat = getpos >>= fun n ->
    match pat with
    | S.Var(v, S.Term _) -> return (Some(C.var' v, C.id (arg n)))
    | _                  -> return None
@


[[Con_record]] constructs a cost/action record for a rule with a
constructor pattern. The action let-binds all variables defined by the
constructor arguments and puts the user-supplied code into the let body.

<<CodeGen>>=
let con_record (r:S.rule) =
    let args = match r.S.pattern with
        | S.Con(_,args) -> args
        | _             -> assert false (* not a constructor rule *) in
    let rulecost = match r.S.cost with
        | C.Int _ as fixed   -> fixed
        | C.Raw _ as dynamic -> C.let' (some (fst (mmap codebind args 1)))
                                       dynamic     
        | _                  -> assert false (* impossible *)
    in
        C.record 
            [ path [camlburg;"cost"]  
                , sum (rulecost :: fst (mmap cost args 1))  
            ; path [camlburg;"action"]
                , action (C.let' (some (fst (mmap bind args 1))) r.S.code)
            ]                         
@

[[Partition]] splits a list of rules (with the same constructor as
pattern) by the nonterminals they define. The result is a map that
associates a non-terminal with a list of rules that defines it.

<<CodeGen>>=
let partition rules =
    let add map rule = StringMap.add 
                        rule.S.nonterm (rule :: lookup map rule.S.nonterm) map
    in
        List.fold_left add StringMap.empty rules
@

<<CodeGen>>=
(* 
    (update_number (choice [ (* cost/action records *) ] 
*)

let update_call nt rules =
    C.apply (C.id (upd nt))
            (choice (List.map con_record rules))

(* 
    (update_x (choice [ ..]) (update_y (choice [..]) ... inf)
*)

let con_fn con rules types =
    let t       = S.StringMap.find con types                    in
    let argv    = fst (mmap (fun _ n -> C.var' (arg n), n+1) t 1) in
    let updates = StringMap.fold 
                    (fun nt rules l -> update_call nt rules :: l)
                    (partition rules)
                    []
    in
        C.fun' argv (compose updates (C.id "inf"))
@

The [[constructors]] function creates one function per pattern
constructor that is used in a specification. The [[maps]] argument
associates a constructor with a list of rules that use this constructor.
Such a list is further split with [[partition]] during code generation.

<<CodeGen>>=
let constructors map types =
    let cons = StringMap.fold (fun con _ l -> con :: l) map [] in
        C.def (List.map 
                (fun con -> ("con"^con
                            , con_fn con (lookup map con) types
                            )) 
                cons) 
@


Define the record value [[inf]], the most undefined action/cost record.

<<CodeGen>>=
let inf nts = 
    C.record (List.map (fun nt -> (nt, C.longid [camlburg;"infinity"])) nts)

let infdef nts =
    C.def ["inf", inf nts]
@

Declare the record type [[nonterm]]. It has a type parameter for each
field.

<<CodeGen>>=
let tydecl nts =
    { C.params = nts
    ; C.name   = "nonterm"
    ; C.rep    = Some (C.typrod (List.map (fun x -> (false, x, C.tyvar x)) nts))
    }
@

