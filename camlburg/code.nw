% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

Here we export code types.
Values of these types represent expressions, programs, etc.
<<exported types>>=
type fragment = Line of string | Synch of Srcmap.location
type exp =
  | Record of (string * exp) list
  | Tuple  of exp list
  | List   of exp list
  | Case   of exp * (pat * exp) list
  | Fun    of string list * exp
  | Apply  of exp * exp
  | Qualid of string list
  | Let    of (pat * exp) list * exp
  | Raw    of fragment list
  | Int    of int
  | String of string
and pat =
  | Con    of string * pat list
  | Var    of string
  | Any
@ 
<<code.mli>>=
<<exported types>>
val pprint : exp -> unit
val id     : string -> exp
val print_frags : fragment list -> unit

val plus : exp -> exp -> exp
val let' : pat -> exp -> exp -> exp

val to_syntax : exp -> 'a Syntax.bExp
@ 
<<code.ml>>=
<<exported types>>

<<prettyprinting>>

let id x = Qualid [x]

let plus n m = match n, m with
  | Int 0, m -> m
  | n, Int 0 -> n
  | _        -> Apply (Apply (id "+", n), m)
let let' p e' e = Let ([p, e'], e)
@ 

<<prettyprinting>>=
module S = Syntax
let error s = (prerr_endline s; exit 1)
let blanks = function
  | 0 -> ""
  | k -> let s = String.create k in (String.fill s 0 k ' '; s)
let synch_string file line col =
  "# " ^ string_of_int line ^ " \"" ^ file ^ "\"\n" ^ blanks (col-1)
let raw_to_string l =
  String.concat ""
  (List.map (function Line n -> n ^ "\n" | Synch (f, l, c) -> synch_string f l c) l)

let location_prefix (file, line, col) = "\n" ^ synch_string file line col

let print_frags = List.iter
  (function Line n -> (Format.print_string n; Format.print_newline ())
          | Synch (f, l, c) -> (Format.print_string (synch_string f l c)))

let rec to_syntax = function
  | Record l -> S.RECORD (List.map (fun (n, e) -> n, to_syntax e) l)
  | Tuple  l -> S.TUPLE  (List.map to_syntax l)
  | List   l -> S.LIST   (List.map to_syntax l)
  | Case   (e, arms) ->
      (let unvar = function Var v -> v | _ -> error "non-var in case" in
       let cvt (p, rhs) = match p with
       | Con (c, args) -> (c,  List.map unvar args, to_syntax rhs)
       | _ -> error "non-Con in case"  in
       S.CASEGEN (to_syntax e, List.map cvt arms, None))
  | Fun    (args, e) ->
      List.fold_right (fun x e -> S.LAM (S.ID x, e)) args (to_syntax e)
  | Apply  (f, a) -> S.APP (to_syntax f, to_syntax a)
  | Qualid l -> S.VAR (String.concat "." l)
  | Let (bs, e') -> S.LET (List.map (fun (p, e) -> pat_syntax p, to_syntax e) bs,
                           to_syntax e')
  | Raw (c) -> S.VAR ("(\n" ^ raw_to_string c ^ ")")
  | Int n -> S.INT n
  | String s -> S.STR s
and pat_syntax = function
  | Con ("", args) -> S.TUPLEPAT (List.map pat_syntax args)
  | Con (c,  args) -> error "constructor as pat"
  | Var v -> S.ID v
  | Any -> S.ID "_"

let pprint e = S.pprint (fun _ -> ()) (to_syntax e)
