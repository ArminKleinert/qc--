% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

This document contains the interface and implementation of the C  representations of {\PAL} control flow structures.

% ----------------------------------------------------------------------------
\section{Interface}
% ----------------------------------------------------------------------------

<<controlflow.h>>=
#ifndef _CONTROLFLOW_H
#define _CONTROLFLOW_H

#include <mclib.h>
#include "activation.h"
#include "table.h"
#include "uid.h"

<<type definitions>>
<<global variable declarations>>

<<function prototypes>>

#endif /* _CONTROLFLOW_H */
@ 

% ----------------------------------------------------------------------------
\subsection{Procedures and Continuations}
% ----------------------------------------------------------------------------

The operational semantics for procedure-calling and continuation-calling instructions require more information about procedures and continuations than simple program counters.  
We create types [[procedure]] and [[continuation]] to encapsulate the necessary information for representing procedures and continuations.  
Note that we use [[RAddr]]s to represent addresses in program memory, for these structures are used during the interpretation of the input Lua script before sections of program memory are permanently located at addresses.  
An [[RAddr]] is a relocatable address and is defined by the NJ Machine-Code Toolkit, as will be explained later.
We must also make sure to store a copy of the uid of the continuation's activation; if a continuation were dead when we tried to cut to it, we would have to look at the continuation's [[u]] and not [[dest_act->u]], which may well have been overwritten by a live activation. 

<<type definitions>>=
typedef struct continuation {
  RAddr               raddr;
  actptr              dest_act;   /* pointer to destination activation  */
  uid                 u;          /* uid of continuation's activation   */

  struct continuation *next;      /* for use in a procedure's cont_list */
} continuation;

typedef struct {
  RAddr         raddr;
  unsigned int  num_locals;
  unsigned int  stackdata_size;
  continuation *cont_list;
} procedure;
@

% ----------------------------------------------------------------------------
\subsection{Memory Management}
% ----------------------------------------------------------------------------

To abstract away from the details of memory management, this interface
provides functions to create new [[procedure]]s, [[continuation]]s, and
[[annotations]], as well as a function that frees \emph{all} such objects in 
memory.

<<function prototypes>>=
procedure    *procedure_new(void);
continuation *continuation_new(void);
annotations  *annotations_new(void);

void          controlflow_free_all(void);
@ 

Note that the  $T$[[_new]] functions return pointers to \emph{uninitialized} 
structures.

% ----------------------------------------------------------------------------
\section{Implementation}
% ----------------------------------------------------------------------------

<<controlflow.c>>=
#include "controlflow.h"

#include <cii/arena.h>
#include "interp.h"

<<global variable definitions>>
<<internal static variable definitions>>

<<function definitions>>
@

To keep track of the current procedure, we use a global pointer.

<<global variable declarations>>=
extern procedure *curr_proc;
@ 

<<global variable definitions>>=
procedure *curr_proc = NULL;
@

% ----------------------------------------------------------------------------
\subsection{Memory Allocation}
% ----------------------------------------------------------------------------

We make use of Hanson's ``arenas'' (see \emph{C Interfaces and Implementations})
to assist in allocating and de-allocating memory for control-flow related
structures.

<<internal static variable definitions>>=
static Arena_T controlflow_arena = NULL;
@ 

<<function definitions>>=
procedure *procedure_new(void) {
  procedure *proc;

  if (controlflow_arena == NULL) {
    controlflow_arena = Arena_new();
    mem_assert(controlflow_arena);
  }

  proc = (procedure *) Arena_alloc(controlflow_arena, sizeof(procedure),
                                   __FILE__, __LINE__);
  mem_assert(proc);
  return(proc);
}
continuation *continuation_new(void) {
  continuation *cont;

  if (controlflow_arena == NULL) {
    controlflow_arena = Arena_new();
    mem_assert(controlflow_arena);
  }

  cont = (continuation *) Arena_alloc(controlflow_arena, sizeof(continuation),
                                      __FILE__, __LINE__);
  mem_assert(cont);
  return(cont);
}
annotations *annotations_new(void) {
  annotations *ann;

  if (controlflow_arena == NULL) {
    controlflow_arena = Arena_new();
    mem_assert(controlflow_arena);
  }

  ann = (annotations *) Arena_alloc(controlflow_arena, sizeof(annotations),
                                    __FILE__, __LINE__);
  mem_assert(ann);
  return(ann);
}
@

To free all:

<<function definitions>>=
void controlflow_free_all(void) {
  if (controlflow_arena != NULL) {
    Arena_free(controlflow_arena);
    Arena_dispose(&controlflow_arena);
    controlflow_arena = NULL;
  }
}
@ 
