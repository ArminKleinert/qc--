% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

\section{General Disclaimer}

Before you proceed onward, we disclaim: \emph{this code might seem chaotic and the noweb chunks could likely benefit from some rearrangement; as it is, the code compiles and doesn't explode.}  See the end of this document for personal notes that indicate what is on my mind for the near future.

\section{The Quick~{\PAL} Interpreter's Assembly Language}

The table below includes all commands currently available in the assembly language of the Quick~{\PAL} Interpreter:\\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}llX@{}}
[[CMM_section]]             &$(name)$               &\\
[[CMM_end_section]]         &$()$                   &\\
[[CMM_define_label]]        &$(name)$               &\\
[[CMM_procedure]]           &$(name, numLocals, stackdataSize)$ &\\
\\
[[CMM_push]]                &$(value)$              &\\
% [[CMM_push_symbol]]       &$(address)$            &\\
% [[CMM_fetch]]             &                       &\\
[[CMM_fetch_local]]         &$(index)$              &\\
[[CMM_fetch_global]]        &$(index)$              &\\
% [[CMM_store]]             &                       &\\
[[CMM_store_local]]         &$(index)$              &\\
[[CMM_store_global]]        &$(index)$              &\\
% [[CMM_guarded_store]]     &                       &\\
[[CMM_gstore_local]]        &$(index)$              &\\
[[CMM_gstore_global]]       &$(index)$              &\\
[[CMM_push_arg]]            &$()$                   &\\
[[CMM_pop_arg]]             &$()$                   &\\
% [[CMM_apply_operator]]    &$(opIndex)$            &\\
[[CMM_goto]]                &$()$                   &\\
[[CMM_cbrancht]]            &$(destAddress)$        &\\
[[CMM_cbranchf]]            &$(destAddress)$        &\\
[[CMM_branchtf]]            &$(addressT, addressF)$ &\\
% [[CMM_cmm_call]]          &$(\kappa_c Address, \kappa_u Address, \kappa_r Address, aborts)$ &\\
[[CMM_cmm_tail_call]]       &$()$                   &\\
% [[CMM_c_call]]            &                       &\\
[[CMM_return]]              &$(index, count)$       &\\
[[CMM_cut]]                 &$()$                   &\\
\end{tabularx}

\section{Implementing a Quick~{\PAL} Interpreter}

Here, we implement the Quick~{\PAL} Interpreter.  It reads in Lua source files written in the style of the interpreter assembly language.
The interpreter is implemented in C, using the New Jersey Machine-Code toolkit, and constructs a bytecode representation of its assembly language.

\subsection{Bytecode Representation}

Here is the SLED definition of the bytecode instruction set of the interpreter:

<<bytecode.sled>>=
fields of bcode     (8) op     0:7
fields of byte      (8) bits8  0:7
fields of short    (16) bits16 0:15
fields of long     (32) bits32 0:31
fields of longlong (64) bits64 0:63

patterns
  [ OP8 OP16 PUSH VAR8 VAR16 VARPUSH8 VARPUSH16 PUSH_ARG POP_ARG
    STORE_LOCAL8  STORE_GLOBAL8  FETCH_LOCAL8   FETCH_GLOBAL8
    STORE_LOCAL16 STORE_GLOBAL16 FETCH_LOCAL16  FETCH_GLOBAL16
    GSTORE_LOCAL8 GSTORE_LOCAL16 GSTORE_GLOBAL8 GSTORE_GLOBAL16
    GOTO          CBRANCHT       CBRANCHF       BRANCHTF
    CMM_CALL      CMM_TAIL_CALL  C_CALL         RETURN
    CUT
    HALT
    PLACECODE
  ] is op = {0 to 31}

patterns 
  any8  is OP8   |  VAR8  | VARPUSH8 
         | STORE_LOCAL8   | STORE_GLOBAL8   | FETCH_LOCAL8  | FETCH_GLOBAL8
         | GSTORE_LOCAL8  | GSTORE_GLOBAL8
  any16 is OP16  | VAR16  | VARPUSH16
         | STORE_LOCAL16  | STORE_GLOBAL16  | FETCH_LOCAL16 | FETCH_GLOBAL16
         | GSTORE_LOCAL16 | GSTORE_GLOBAL16
  any32   is PUSH | C_CALL
  nullary is PUSH_ARG | POP_ARG  | GOTO | CUT | CMM_TAIL_CALL

relocatable addr
relocatable addr2
relocatable addr3

placeholder for bcode is PLACECODE
placeholder for long  is bits32 = 0

constructors
  any8        bits8            is  any8;     bits8
  any16       bits16           is  any16;    bits16
  any32       bits32           is  any32;    bits32
  PUSH_SYMBOL addr             is  PUSH;     bits32 = addr
  CBRANCHT    addr             is  CBRANCHT; bits32 = addr
  CBRANCHF    addr             is  CBRANCHF; bits32 = addr
  BRANCHTF    addr addr2       is  BRANCHTF; bits32 = addr; bits32 = addr2
  CMM_CALL  addr; addr2; addr3 is  CMM_CALL; bits32 = addr; bits32 = addr2; bits32 = addr3
  RETURN      bits8 bits16     is  RETURN;   bits8;          bits16
  nullary

# conditional assembly
  apply_operator bits16
    when { }  is op8 (bits16)
    otherwise is op16(bits16)
  var bits16
    when { }  is var8 (bits16)
    otherwise is var16(bits16)
  store_local bits16
    when { }  is store_local8 (bits16)
    otherwise is store_local16(bits16)
  store_global bits16
    when { }  is store_global8 (bits16)
    otherwise is store_global16(bits16)
  gstore_local bits16
    when { }  is gstore_local8 (bits16)
    otherwise is gstore_local16(bits16)
  gstore_global bits16
    when { }  is gstore_global8 (bits16)
    otherwise is gstore_global16(bits16)
  fetch_local bits16
    when { }  is fetch_local8 (bits16)
    otherwise is fetch_local16(bits16)
  fetch_global bits16
    when { }  is fetch_global8 (bits16)
    otherwise is fetch_global16(bits16)
@ 

Here is the general idea:
most bytecodes will carry an integer index that will be used to look
up a function in a table.
That function will modify memory as needed and possibly return new
state elements.
As an example, consider an operator.
It needs access only to the value stack, and it cannot overflow.
Perhaps this stack is represented by an array and a stack pointer.
Then we would have
\begin{verbatim}
   typedef sptr (*operator_fun)(sptr sp);
\end{verbatim}
An operator bytecode would then carry an index into an array of [[operator_fun*]].
@
Here are some sketches about implementation:
\begin{itemize}
\item
A literal or a symbol can be handled by a single push bytecode.
\item
We will want ``short'' and ``long'' versions of many bytecodes (using
8- and 16-bit arguments).
\end{itemize}
@

\subsection{Interpreting Bytecode}

Moving onward to C code, we will begin with some type definitions.  We [[typedef]] the basic unsigned and signed integer types, making use of the definitions in header file [[<stdint.h>]].

<<type definitions>>=

/* the types uintX_t are defined in <stdint.h> */
typedef uint8_t  u_int1;
typedef uint8_t  u_int8;
typedef uint16_t u_int16;
typedef uint32_t u_int32;
typedef uint64_t u_int64;

typedef u_int1   bool;
typedef u_int1   bits1;
typedef u_int8   bits8;
typedef u_int16  bits16;
typedef u_int32  bits32;
typedef u_int64  bits64;

typedef int8_t   s_int8;
typedef int16_t  s_int16;
typedef int32_t  s_int32;
typedef int64_t  s_int64;

/* FIX :  the float types are here defined in a machine-dependent manner; */
typedef float       float32;
typedef double      float64;
typedef long double float96;

typedef enum {
  ROUND_DOWN    = 00U,
  ROUND_UP      = 01U,
  ROUND_NEAREST = 02U,
  ROUND_ZERO    = 03U
} rounding_mode;

typedef enum {
  LITTLE,
  BIG
} byte_order;

/* typedef u_int8 bytecode; */
/* FIX!! */
typedef u_int8 *bytecodeptr;
@ 

The type from which we will build our value stack and argument stack is a union type, which we [[typedef]] to [[value]].

<<type definitions>>=
typedef union {
  bits1   bits1;
  bits8   bits8;
  bits16  bits16;
  bits32  bits32;
  bits64  bits64;
  float32 float32;
  float64 float64;
  float96 float96;
} value;

typedef value *stack;    /* value stack */
typedef value *sptr;     /* stack pointer */

typedef u_int8 data;

typedef data *datastack;
typedef data *dataptr;
@ 

We also specify a number of [[struct]] types to represent operators, unique identifiers, call-site annotations, activations, threads, procedures, continuations, and assembly units (\emph{NOTE: the assembly unit type is still unused; this code presently assumes only one assembly unit is around}).

<<type definitions>>=

typedef sptr (*operator_fun)(sptr values); /* FETCH, STORE, OPERATOR         */
typedef sptr (*push_fun)    (sptr values); /* LITERAL, PUSH_SYMBOL           */
typedef sptr (*var_fun)     (sptr values, value *vars);    /* GLOBAL, LOCAL  */
typedef void (*arg_fun)     (sptr *values, sptr *arguments); /* PUSH/POP_ARG */

typedef struct {
  const char   *opname;  /* operator name */
  unsigned     min_args;
  operator_fun f;
} operator;

typedef struct {
  void         *thread;
  unsigned int frame;
} uid;

/* FIX for now, we leave these annotation elements as pointers to bytecode
   pointers; for example, also_cuts_to should point to an array of
   (bytecodeptr)'s.  it will be (\0)-terminated to signify the end.
 */

typedef struct {
  bytecodeptr *also_cuts_to;
  bytecodeptr *also_unwinds_to;
  bytecodeptr *also_returns_to;
  u_int1      also_aborts;
} annotations;

typedef struct activation_t {
  bytecodeptr pc;

  stack     locals;
  sptr      locals_end;

  datastack stackdata;
  dataptr   stackdata_end;

  annotations kappa;

  uid u;
} activation;

typedef activation *actstack;
typedef activation *actptr;

typedef struct {
  unsigned int next_frame_id;

  /* X_base points to the beginning of the X stack space */
  /* X_limit points to the end of the X stack space */
  /* X_free points to the next available stack-location in the X stack space */

  actstack      callstack_base;
  actptr        callstack_limit;
  actptr        callstack_free;

  stack         locals_base;
  sptr          locals_limit;
  sptr          locals_free;

  datastack     stackdata_base;
  dataptr       stackdata_limit;
  dataptr       stackdata_free;

  interval_list *live_list;
} thread;

typedef struct {
  RAddr        raddr;
  unsigned int num_locals;
  unsigned int stackdata_size;
} procedure;

typedef struct {
  bytecodeptr pc;
  actptr      dest_act;   /* pointer to destination activation */
} continuation;

typedef struct {
  byte_order byte_order;
  unsigned   int memsize;
  unsigned   int wordsize;
  unsigned   int ptrsize;
} assembly_unit;
@ 

Next, some initialization code for the interpreter to build its table of operators and perform other necessary tasks (e.g., uid handling):

<<initialization>>=
static operator operators[] = {
  /* ... */
  /* { opname, minargs, function pointer },
  /* ... */

  { NULL,          0, NULL      }
};

uid new_uid (thread *t) {
  uid u = { (void *) t, t->next_frame_id++ };
  return u;
}

void dies_uid(uid u) {
  thread *t = find_thread(u);
  assert(t != NULL);

  t->live_list = interval_list_remove(t->live_list, u.frame);
}

int islive_uid(uid u) {
  thread *t = find_thread(u);
  assert(t != NULL);

  return interval_list_member(t->live_list, u.frame);
}

thread *find_thread(uid u) {
  return (thread *) u.thread;
}

void error_wrapper(char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  error(0, 0, fmt, args);
  va_end(args);
  exit(1);
}
/* ...
 * some helper functions go here
 * ...
 */
@ 

For now, we also do some simple type assertions just to make sure nothing is going ridiculously wrong.

<<initialization>>=
void check_value_types (void) {
  value v;
  assert(sizeof(v.bits8 ) == 1);
  assert(sizeof(v.bits16) == 2);
  assert(sizeof(v.bits32) == 4);
  assert(sizeof(v.bits64) == 8);
  assert(sizeof(void *)   == sizeof(v.bits32));
}

void init(void) {
  check_value_types();
  /* FIX : register_operators(operators); */
}
@ 

We must initialize each new thread carefully, divvying up stack space.

<<initialization>>=

thread *init_thread(void *stack_space, void *stack_limit) {
  int    space_size;
  thread *t = (thread *) malloc(sizeof(thread));
  assert(t != NULL);

  t->next_frame_id = 0;
  
  space_size = (stack_limit - stack_space) / 3;

  /* we carve out areas for stackdata, callstack, locals from the memory block
     handed into init_thread */

  t->callstack_base  = (actstack)  stack_space;
  t->callstack_limit = (actptr)    (stack_space + space_size);
  t->callstack_free  = t->callstack_base;

  t->locals_base     = (stack)     (stack_space + space_size);
  t->locals_limit    = (sptr)      (stack_space + (2 * space_size));
  t->locals_free     = t->locals_base;

  t->stackdata_base  = (datastack) (stack_space + (2 * space_size));
  t->stackdata_limit = (dataptr)   stack_limit;
  t->stackdata_free  = t->stackdata_base;

  t->live_list       = interval_list_new();
}
@ 

Operators are mostly implemented through macro-generated functions and are insantiated at specific types.

<<operator definitions>>=

/* these will be mostly macro calls to one of:

  BINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B)
   UNARYOP(NAME, EXP, X, TX, T, BX, B)
 T_UNARYOP(NAME, EXP, X, T, B)
T_BINARYOP(NAME, EXP, X, Y, T, B)

   where Ts are C types   : {u_int_N, s_int_N, floatN} where N is 1/8/16/32/64
     and Bs are C-- types : {bits1, bits8, bits16, bits32, bits64}
 */


/* FLOAT operators begin here. */
/* fcmp */
/* (floating-pt comparisons?) */
BINARYOP(feq, v1 == v2, v1,v2, float32, float32, bool, float32, float32, bits1)
BINARYOP(fge, v1 >= v2, v1,v2, float32, float32, bool, float32, float32, bits1)
BINARYOP(fgt, v1 >  v2, v1,v2, float32, float32, bool, float32, float32, bits1)
BINARYOP(fle, v1 <= v2, v1,v2, float32, float32, bool, float32, float32, bits1)
BINARYOP(flt, v1 <  v2, v1,v2, float32, float32, bool, float32, float32, bits1)
BINARYOP(fne, v1 != v2, v1,v2, float32, float32, bool, float32, float32, bits1)
/* fordered   */
/* funordered */
/* NaN */
NULLARYOP(round_down,    { v1 = ROUND_DOWN;    }, v1, u_int8, bits8)
NULLARYOP(round_up,      { v1 = ROUND_UP;      }, v1, u_int8, bits8)
NULLARYOP(round_nearest, { v1 = ROUND_NEAREST; }, v1, u_int8, bits8)
NULLARYOP(round_zero,    { v1 = ROUND_ZERO;    }, v1, u_int8, bits8)
/* f2f */
/* f2i */
/* i2f */
/* fadd */
/* fsub */
/* fdiv */
/* fmul */
/* fmulx */
T_UNARYOP(fabs, fabsf(v1), v1, float, float32)
T_UNARYOP(fneg, -(v1),     v1, float, float32)
/* fsqrt */
/* minf  */
/* mzero */
/* pinf  */
/* pzero */
/* FLOAT operators end here. */

/* INTEGER operators begin here. */
T_BINARYOP(add,     v1 + v2           , v1, v2, s_int16, bits16)
T_BINARYOP(and,     v1 & v2           , v1, v2, u_int16, bits16)
T_UNARYOP (bit,     v1                , v1,     bool   , bits1 )
/* bitExtract  */
/* bitInsert   */
/* bitTransfer */
T_UNARYOP (bool,    v1                , v1,     bool   , bits1 )
/* borrow      */
/* carry       */
T_UNARYOP (com,     ~v1               , v1,     u_int16, bits16)
T_BINARYOP(conjoin, (v1 != 0 ? v2 : 0), v1, v2, bool   , bits1 )
T_BINARYOP(disjoin, (v1 != 0 ? 1 : v2), v1, v2, bool   , bits1 )
/* div  */
BINARYOP  (divu,v1 / v2,  v1,v2, u_int16, u_int8, u_int8,bits16, bits8,  bits8)
BINARYOP  (eq,  v1 == v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bits1)
BINARYOP  (ge,  v1 >= v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bits1)
BINARYOP  (geu, v1 >= v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bits1)
BINARYOP  (gt,  v1 >  v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bits1)
BINARYOP  (gtu, v1 >  v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bits1)
BINARYOP  (le,  v1 <= v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bits1)
BINARYOP  (leu, v1 <= v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bits1)
/* mod  */
BINARYOP  (modu, v1 % v2, v1,v2, u_int16, u_int8, u_int8, bits16, bits8, bits8)
T_BINARYOP(mul,     v1 * v2           , v1, v2, s_int16, bits16)
T_BINARYOP(mulu,    v1 * v2           , v1, v2, u_int16, bits16)
BINARYOP  (ne,   v1 !=v2, v1,v2, u_int16, u_int16,bool,   bits16, bits16,bits1)
T_UNARYOP (neg,     -v1               , v1    , s_int16, bits16)
T_UNARYOP (not,     !v1               , v1    , bool   , bits1 )
T_BINARYOP(or ,     v1 | v2           , v1, v2, u_int16, bits16)
POPCNT    (u_int16, bits16)
BINARYOP  (quot, v1 / v2, v1,v2, u_int16, u_int8, u_int8, bits16, bits8, bits8)
BINARYOP  (rem,  v1 % v2, v1,v2, u_int16, u_int8, u_int8, bits16, bits8, bits8)
ROTL      (u_int16, bits16)
ROTR      (u_int16, bits16)
T_BINARYOP(shl ,    v1 << v2          , v1, v2, u_int16, bits16)
/* shra   */
T_BINARYOP(shrl,    v1 >> v2          , v1, v2, u_int16, bits16)
T_BINARYOP(sub ,    v1 - v2           , v1, v2, s_int16, bits16)
UNARYOP   (sx  ,    (s_int16) v1      , v1, s_int8, s_int16, bits8, bits16)
T_BINARYOP(xor ,    v1 ^ v2           , v1, v2, s_int16, bits16)
UNARYOP   (zx  ,    (u_int16) v1      , v1, u_int8, u_int16, bits8, bits16)
/* INTEGER operators end here. */

@ 

Finally, we get to the main part of the interpreter.  We start by initializing the internal state of the interpreter:

<<initialize interpreter internals>>=
  bytecodeptr pc;            /* pc  */
  sptr        values;        /* V   */

  sptr     locals;           /* rho */
  sptr     locals_end;

  dataptr  stackdata;        /* sp  */
  dataptr  stackdata_end;

  value    *globals;         /* g   */
  /* sigma is left implicit!        */
  sptr     arguments;        /* A   */
  uid      u;                /* u   */

  /* s is kept in t->stackdata_X */
  thread   *t = init_thread(stack_space, stack_limit);

  assert(start != NULL);
  assert(location_known(start->raddr));
  pc = (bytecodeptr) location(start->raddr);

  /* we have to malloc new memory for the values, arguments stacks */

  values_base        = (sptr) malloc(sizeof(value) * DEF_VALUESSTACK_SIZE);
  assert(values_base != NULL);
  values_limit       = values_base + DEF_VALUESSTACK_SIZE;
  values             = values_base - 1;

  arguments_base     = (sptr) malloc(sizeof(value) * DEF_ARGUMENTSSTACK_SIZE);
  assert(arguments_base != NULL);
  arguments_limit    = arguments_base + DEF_ARGUMENTSSTACK_SIZE;
  arguments          = arguments_base - 1;

  /* we know precisely how much to malloc for globals */

  globals            = (value *) malloc(sizeof(value) * num_globals);
  assert(globals != NULL);

  /* we allocate locals-space and stackdata-space for the current activation */

  locals             = t->locals_free;
  t->locals_free    += start->num_locals;
  locals_end         = t->locals_free;

  stackdata          = t->stackdata_free;
  t->stackdata_free += start->stackdata_size;
  stackdata_end      = t->stackdata_free;

  /* generate new uid in thread t */

  u = new_uid(t);
@ 

For the main interpreting loop, we use the ``matching'' feature of the New Jersey Machine-Code Toolkit.  This code is pre-processed by the Toolkit and ends up in normal C format.

<<main interpreter loop>>=
void run_interp(procedure *start, int num_globals, void *stack_space, 
                void *stack_limit)
{
  <<initialize interpreter internals>>
  for (;;) {
    match pc to
    | PUSH(v)           => OVERFLOW_CHECK(values, 1);
                           PUSH(v, values);

    | apply_operator(n) => values = (*operators[n].f)(values);

    | store_local(n)    => UNDERFLOW_CHECK(values, 1);
                           locals[n] = POP(values);

    | fetch_local(n)    => OVERFLOW_CHECK(values, 1);
                           PUSH(locals[n], values);

    | store_global(n)   => UNDERFLOW_CHECK(values, 1);
                           globals[n] = POP(values);

    | fetch_global(n)   => OVERFLOW_CHECK(values, 1);
                           PUSH(globals[n], values);

    | gstore_local(n)   => UNDERFLOW_CHECK(values, 2);
                           if (bool_true(VIEW(STACK_ELT(values, 0), bool))) {
                               STACK_ELT(values, -1) = locals[n];
                               values--;
                           } else {
                               values -= 2;
                           }

    | gstore_global(n)  => UNDERFLOW_CHECK(values, 2);
                           if (bool_true(VIEW(STACK_ELT(values, 0), bool))) {
                               STACK_ELT(values, -1) = globals[n];
                               values--;
                           } else {
                               values -= 2;
                           }

    | PUSH_ARG          => UNDERFLOW_CHECK(values, 1);
                           OVERFLOW_CHECK(arguments, 1);
                           PUSH(POP(values), arguments);

    | POP_ARG           => OVERFLOW_CHECK(values, 1);
                           UNDERFLOW_CHECK(arguments, 1);
                           PUSH(POP(arguments), values);

    | GOTO              => UNDERFLOW_CHECK(values, 1);
                           pc = VIEW(POP(values), bytecodeptr);

    | CBRANCHT(a)       => UNDERFLOW_CHECK(values, 1);
                           if (bool_true(VIEW(POP(values), bool))) {
                               pc = (bytecodeptr) a;
                           }

    | CBRANCHF(a)       => UNDERFLOW_CHECK(values, 1);
                           if (bool_false(VIEW(POP(values), bool))) {
                               pc = (bytecodeptr) a;
                           }

    | BRANCHTF(a, b)    => UNDERFLOW_CHECK(values, 1);
                           if (bool_true(VIEW(POP(values), bool))) {
                               pc = (bytecodeptr) a;
                           } else {
                               pc = (bytecodeptr) b;
                           }

    | CMM_CALL(kc,ku,kr) =>procedure  *proc;
                           actptr      saved;

                           ASSERT_EMPTY(values);
                           UNDERFLOW_CHECK(values, 1);
                           proc = VIEW(POP(values), procedure *);
                           assert(proc != NULL);

                           /* save necessary info in activation record */
                           saved = t->callstack_free++;
                           assert(t->callstack_free <= t->callstack_limit);

                           saved->pc            = pc;
                           saved->locals        = locals;
                           saved->locals_end    = locals_end;
                           saved->stackdata     = stackdata;
                           saved->stackdata_end = stackdata_end;

                           saved->kappa.also_cuts_to    = (bytecodeptr *) kc;
                           saved->kappa.also_unwinds_to = (bytecodeptr *) ku;
                           saved->kappa.also_returns_to = (bytecodeptr *) kr;
                           /* FIX need to save aborts as well!!
                              NOTE that ``also aborts'' defaults to 1 (true) */

                           saved->u             = u;

                           /* allocate memory, update state of the machine */
                           assert(location_known(proc->raddr));
                           pc            = (bytecodeptr) location(proc->raddr);

                           locals        = t->locals_free;
                           locals_end    = (t->locals_free +=
                                                        proc->num_locals);
                           assert(t->locals_free <= t->locals_limit);

                           stackdata     = t->stackdata_free;
                           stackdata_end = (t->stackdata_free += 
                                                        proc->stackdata_size);
                           assert(t->stackdata_free <= t->stackdata_limit);

                           u             = new_uid(t);

    | CMM_TAIL_CALL     => procedure *proc;

                           ASSERT_EMPTY(values);
                           UNDERFLOW_CHECK(values, 1);
                           proc = VIEW(POP(values), procedure *);
                           assert(proc != NULL);

	                       assert(location_known(proc->raddr));
                           pc   = (bytecodeptr) location(proc->raddr);

                           /* for now, make sure there's enough room on locals
                              and stackdata stacks
                            */
                           assert(locals_end    <= t->locals_limit);
                           assert(stackdata_end <= t->stackdata_limit);

                           /* locals ptr stays because we throw out old rho */
                           /* stackdata ptr stays for same reason */

                           t->locals_free = locals_end = locals + 
                                                         proc->num_locals;
                           t->stackdata_free = stackdata_end = stackdata + 
                                                         proc->stackdata_size;

                           /* deal with uid : */
                           dies_uid(u);
                           u = new_uid(t);

    | RETURN(i, count)  => activation *caller;

                           ASSERT_EMPTY(values);
                           assert(i <= count);
                           
                           /* FIX for now, assert we don't walk off stack */
                           assert(t->callstack_free > t->callstack_base);

                           caller = t->callstack_free--;
                           
                           /* FIX for now we don't assert that m = |returns| */
                           
                           pc     = caller->kappa.also_returns_to[i];

                           locals        = caller->locals;
                           locals_end    = caller->locals_end;
                           stackdata     = caller->stackdata;
                           stackdata_end = caller->stackdata_end;
                           
                           /* reclaim freed space */
                           t->locals_free    = locals_end;
                           t->stackdata_free = stackdata_end;

                           dies_uid(u);
                           u = caller->u;
                           
    | CUT               => continuation *cont;
                           actptr a, saved;

                           ASSERT_EMPTY(values);
                           UNDERFLOW_CHECK(values, 1);
                           cont = VIEW(POP(values), continuation *);
                           assert(cont != NULL);
                           assert(cont->dest_act != NULL);

                           assert(islive_uid(cont->dest_act->u));

                           /* FIX : look in kappa annotations in activation 
                              pointed to by called_by to make sure that
                              cont->pc is in kappa.also_cuts_to
                            */

                           if (cont->dest_act->u.thread != u.thread) {
                               /* save needed info in activation record */
                               saved = t->callstack_free++;
                               assert(t->callstack_free <= t->callstack_limit);
 
                               saved->pc            = pc;
                               saved->locals        = locals;
                               saved->locals_end    = locals_end;
                               saved->stackdata     = stackdata;
                               saved->stackdata_end = stackdata_end;
                               /* FIX : store call-site annotations here ?? */
                               saved->u             = u;
 
                               /* jump over to destination thread */
                               t = find_thread(u);
                           } else if (cont->dest_act->u.frame == u.frame) {
                               /* if we're here, then we're cutting to a
                                  continuation in the current activation */
                               /* FIX : for now, just treat like GOTO */
                               pc = cont->pc;
                               continue;
                           }
                           for (a = t->callstack_free - 1; a > cont->dest_act;
                                a--)
                           {
                               /* FIX : update when annotations are figured out
                                */
                               assert(a - 1 >= t->callstack_base);
                               /* assert((a - 1)->annotations.also_aborts); */
                               dies_uid(a->u);
                           }
 
                           /* a should now equal cont->dest_act */
                           /* update state of machine */
                           pc            = cont->pc;
                           locals        = cont->dest_act->locals;
                           locals_end    = cont->dest_act->locals_end;
                           stackdata     = cont->dest_act->stackdata;
                           stackdata_end = cont->dest_act->stackdata_end;
                           u             = cont->dest_act->u;
 
                           /* recover freed memory */
                           t->callstack_free = cont->dest_act;
                           t->locals_free    = cont->dest_act->locals_end;
                           t->stackdata_free = cont->dest_act->stackdata_end;
 
    | HALT              => return;
    endmatch
  }

  <<shut down interpreter>>
}
@ 

\section{Generating the Bytecode to Interpret}

In this section, we see how to generate bytecode from an external Lua file.  First, our code is obligated to define functions [[mc_alloc]] and [[mc_alloc_closure]] for the NJ Machine-Code Toolkit; these functions simply must allocate memory to be used by Toolkit-generated code as ``relocatable memory blocks.''  We must also keep track of toolkit closures, however, so we can later apply them with the toolkit API function [[apply_closure]].

<<bytecode generation>>=
extern void *mc_alloc(int size, Mc_alloc_pool pool) {
  void *a = (void *) malloc(size);
  assert(a != NULL);
  return a;
}

extern RClosure mc_alloc_closure(unsigned size, RBlock dest_block, 
                                 unsigned dest_lc)
{
  /* FIX this function doesn't do what it's supposed to do */

  /* note: RClosure is a typedef'd struct pointer */
  RClosure a = (RClosure) malloc(size);
  assert(a != NULL);

  /* store the closure in a "dynamic array" so it can later be applied */
  if (closures_free >= closures_limit) {
    RClosure *closures_new = realloc(closures_base, 
                             2 * sizeof(RClosure) *
                             (closures_limit - closures_base));
    assert(closures_new != NULL);
    closures_limit = closures_new + 2*(closures_limit - closures_base);
    closures_free  = closures_new + (closures_free - closures_base);
    closures_base  = closures_new;
  }
  (closures_free++)[0] = a;

  return a;
}

@ 

Now, we must export the encoding functions the Toolkit provides us to Lua.
Each \PAL section is given its own relocatable block, with all code from the toplevel unnamed section being placed in a special relocatable block.  We maintain a Lua table that maps section labels to their respective blocks.  Remember also that sections with the same label are effectively concatenated and placed together in memory.

<<bytecode generation>>=
int lua_CMM_section(lua_State *L) {
  RBlock section_block = NULL;

  /* BUT if the stack is empty we assume we should enter the default sect. */
  if (lua_gettop(L) == 0) {
    lua_getglobal(L, DEF_SECTION_TABLE);
    if (lua_isuserdata(L, -1) &&
        (section_block = (RBlock) lua_touserdata(L, -1)) != NULL)
    {
      assert(block_defined(section_block));
      set_block(section_block);
      lua_settop(L, -1);  /* pop off RBlock address */
    } else {
      
    }
    lua_settop(L, -2);    /* pop off nil */

    /* FIX we say 0 size for now */
    section_block = block_new(0);
    assert(block_defined(section_block));
    set_block(section_block);

    lua_pushusertag(L, (void *) section_block, lua_RBlock_tag);
    lua_setglobal(L, DEF_SECTION_TABLE);

    return 0;
  }

  /* if we get down here, there must have been a key string on the stack */
  lua_getglobal(L, SECTION_TABLE);
  if (!lua_istable(L, -1)) {
    lua_settop(L, -2);
    lua_newtable(L);
    lua_setglobal(L, SECTION_TABLE);
    lua_getglobal(L, SECTION_TABLE);
  }

  lua_insert(L, -2);     /* swap stack positions of key string and table */
  lua_pushvalue(L, -1);  /* make copy of key string atop table */
  lua_gettable(L, -3);   /* look up string to see if section is defined  */
  if (lua_isuserdata(L, -1) && 
      (section_block = (RBlock) lua_touserdata(L, -1)) != NULL)
  {
    assert(block_defined(section_block));
    set_block(section_block);

    lua_settop(L, -4);   /* pop off RBlock address, key string copy, table */
  } else {
    /* FIX we say 0 size for now */
    section_block = block_new(0);
    assert(block_defined(section_block));
    set_block(section_block);

    lua_settop(L, -2);   /* pop nil off */
    lua_pushusertag(L, (void *) section_block, lua_RBlock_tag);
    lua_settable(L, -3); /* pops off RBlock address, key string copy */

    lua_settop(L, -2);   /* pop off table */
  }

  return 0;              /* this function pushes 0 results onto Lua stack */
}

int lua_CMM_end_section(lua_State *L) {
  /* remove all from stack */
  lua_pop(L, lua_gettop(L));

  return lua_CMM_section(L);
}

int lua_CMM_procedure(lua_State *L) {
  char      *name;
  procedure *proc;

  /* this function takes three arguments: 

     1. the function's name 
     2. the number of local vars in the proc
     3. the size of stackdata in the proc
   */
  if (!lua_isnumber(L, -1))
    lua_error(L, "must specify size of stackdata within C-- procedure");
  if (!lua_isnumber(L, -2))
    lua_error(L, "must specify number of local variables in C-- procedure");
  if (!lua_isstring(L, -3))
    lua_error(L, "cannot define anonymous procedures in C--");

  name = strcpy(name, lua_tostring(L, -3));
  proc = (procedure *) malloc(sizeof(procedure));
  assert(proc != NULL);

  /* FIX do we need to check to see if label already defined? */
  proc->raddr          = addr_new(label_new(name), 0);
  label_define(proc->raddr->label, 0);
  proc->num_locals     = (unsigned int) lua_tonumber(L, -2);
  proc->stackdata_size = (unsigned int) lua_tonumber(L, -1);

  lua_pop(L, 2); /* pop num_locals and stackdata_size */

  /* FIX FIX */
  
  lua_getglobal(L, PROCEDURE_TABLE);
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    lua_newtable(L);
    lua_setglobal(L, PROCEDURE_TABLE);
    lua_getglobal(L, PROCEDURE_TABLE);
  }

  lua_insert(L, -2);    /* swap stack positions of key string and table */
  lua_pushvalue(L, -1); /* make copy of key string atop table           */
  lua_gettable(L, -3);  /* look up string to see if proc is defined     */
  if (lua_isuserdata(L, -1) && lua_touserdata(L, -1) != NULL) {
    lua_pop(L, 2); /* pop key string, table */
    lua_error(L, "cannot redefine C-- procedure");
  }

  lua_pop(L, 1); /* pop nil off */
  lua_pushusertag(L, (void *) proc, lua_CMMprocedure_tag);
  lua_settable(L, -3); /* pops off pointer, key string */

  lua_pop(L, 1); /* pop table */
  return 0;
}

/* get_label_addr expects a string atop the Lua stack but leaves it with one 
   less item than it started with */
RAddr get_label_addr(lua_State *L, char *name) {
  RLabel label;
  RAddr  addr;

  /* expects a string atop the table ! */
  if (!lua_isstring(L, -1)) {
    lua_error(L, "cannot define a nameless label in C--");
  }

  lua_getglobal(L, LABEL_TABLE);
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    lua_newtable(L);
    lua_setglobal(L, LABEL_TABLE);
    lua_getglobal(L, LABEL_TABLE);
  }
  lua_insert(L, -2);    /* swap stack positions of key string and table */
  lua_pushvalue(L, -1); /* make copy of key string atop table           */
  lua_gettable(L, -3);  /* look up string to see if proc is defined     */
  if (lua_isuserdata(L, -1) && (addr = lua_touserdata(L, -1)) != NULL) {
    lua_pop(L, 2); /* pop key string, table */
  } else {
    /* FIX for now we define at offset of 0 */
    label = label_new(name);
    addr  = addr_new(label, 0);

    lua_pop(L, 1); /* pop nil off */
    lua_pushusertag(L, (void *) addr, lua_RAddr_tag);
    lua_settable(L, -3); /* pops off pointer, key string */
    lua_pop(L, 1); /* pop table */
  }

  return addr;
}

int lua_CMM_define_label(lua_State *L) {
  char   *name;
  RLabel label;
  RAddr  addr;

  /* we expect a key string */
  if (!lua_isstring(L, -1)) {
    lua_error(L, "cannot define a nameless label in C--");
  }

  name  = strcpy(name, lua_tostring(L, -1));
  addr  = get_label_addr(L, name);
  label = addr->label;

  if (!block_defined(label->block))
    label_define(label, 0);
  else
    lua_error(L, "cannot redefine a label in C--");

  return 0;
}
@ 

We need to wrap the encoding functions in simple Lua-style C functions.  We use the help of the macro [[LUA_WRAP_NULLARY]] to wrap nullary encoding functions.

<<bytecode generation>>=
int lua_CMM_push_literal(lua_State *L) {
  if (!lua_isstring(L, -1))
	lua_error(L, "push_literal expects a string literal");

  push((u_int32) atol(lua_tostring(L, -1))); /* emit instruction */
  lua_pop(L, 1);

  return 0;
}

int lua_CMM_cbrancht(lua_State *L) {
  char  *target;
  RAddr addr;

  if (!lua_isstring(L, -1))
    lua_error(L, "cbrancht requires target label");

  target = strcpy(target, lua_tostring(L, -1));
  addr   = get_label_addr(L, target);
  
  lua_pop(L, 1);

  /* emit instruction */
  cbrancht(addr);

  return 0;
}

int lua_CMM_cbranchf(lua_State *L) {
  char  *target;
  RAddr addr;

  if (!lua_isstring(L, -1))
    lua_error(L, "cbranchf requires target label");

  target = strcpy(target, lua_tostring(L, -1));
  addr   = get_label_addr(L, target);

  /* emit instruction */
  cbranchf(addr);

  return 0;
}

int lua_CMM_branchtf(lua_State *L) {
  char  *targetT, *targetF;
  RAddr addrT,    addrF;

  if (!lua_isstring(L, -1) || !lua_isstring(L, -2))
    lua_error(L, "branchtf requires 2 target labels");

  targetT = strcpy(targetT, lua_tostring(L, -2));
  targetF = strcpy(targetF, lua_tostring(L, -1));

  addrF   = get_label_addr(L, targetF);
  addrT   = get_label_addr(L, targetT);

  /* emit instruction */
  branchtf(addrT, addrF);

  return 0;
}

int lua_CMM_return (lua_State *L) {
  if (!lua_isnumber(L, -1) || !lua_isnumber(L, -2))
	lua_error(L, "return requires integer index and count!");

  /* emit instruction */
  return_((unsigned) lua_tonumber(L, -2), (unsigned) lua_tonumber(L, -1));

  lua_pop(L, 2);
  return 0; \
}

/* LUA_WRAP_NULLARY(encodingFunctionName, nameStemForLua) */
LUA_WRAP_NULLARY(push_arg,      push_arg     )
LUA_WRAP_NULLARY(pop_arg,       pop_arg      )
LUA_WRAP_NULLARY(goto_,         goto         )
LUA_WRAP_NULLARY(cmm_tail_call, cmm_tail_call)
LUA_WRAP_NULLARY(cut,           cut          )

/* LUA_WRAP_UNARY_INDEX(encodingFunctionName, nameStemForLua) */
LUA_WRAP_UNARY_INDEX(fetch_local,   fetch_local )
LUA_WRAP_UNARY_INDEX(fetch_global,  fetch_global)
LUA_WRAP_UNARY_INDEX(store_local,   store_local )
LUA_WRAP_UNARY_INDEX(store_global,  store_global)
LUA_WRAP_UNARY_INDEX(gstore_local,  gstore_local )
LUA_WRAP_UNARY_INDEX(gstore_global, gstore_global)
@ 

When we are ready to assign permanent addresses to our relocatable blocks, we do so within Lua.  [[lua_relocate_block]] simply uses malloc to find space in memory, and calls [[set_address]].

<<bytecode generation>>=
int lua_relocate_block(lua_State *L) {
  RBlock bl;

  if (!lua_isuserdata(L, -1) || (bl = (RBlock) lua_touserdata(L, -1)) == NULL)
  {
    lua_pop(L, 1);
    lua_error(L, "internal error relocating block");
  }

  set_address(bl, (unsigned) malloc(block_size(bl)));
  return 0;
}

void lua_error_handle(int err_code, const char *fn) {
  switch (err_code) {
  case 0:
    return;
  case LUA_ERRRUN:
    printf("error: run-time error while interpreting %s\n", fn);
    break;
  case LUA_ERRSYNTAX:
    printf("error: a syntax error was found in %s\n", fn);
    break;
  case LUA_ERRMEM:
    printf("error: memory allocation error [%s]\n", fn);
    break;
  case LUA_ERRERR:
    printf("error: unrecoverable internal error [%s]\n", fn);
    break;
  case LUA_ERRFILE:
    printf("error: cannot open file %s\n", fn);
    break;
  }

  exit(1);
}
@ 

Next, we proceed onto our [[main]] function, in which we will read assembly code from an external Lua source file and emit instruction bytecode into memory.  Our previously defined [[run_interp]] function should be able to properly interpret this bytecode, given a program counter and sufficient memory resources.

<<bytecode generation>>=
int main(int argc, char *argv[])
{
  int       err_code;
  lua_State *lua_interp;
  RClosure  *cl;

  if (argc != 2) {
    printf("For now, interp accepts only one argument.\n");
    printf("usage: interp <filename>\n");
    return 1;
  }

  <<prepare for encoding library>>
  <<initialize a Lua interpreter>>

  <<run Lua source file>>

  <<perform bytecode relocation>>

  /* FIX call run_interp here */

  <<gracefully shut down>>

  return 0;
}
@ 

Before using the encoding library, we must first prepare:

<<prepare for encoding library>>=

  closures_base = (RClosure *) malloc(DEF_CLOSURESARRAY_SIZE*sizeof(RClosure));
  assert(closures_base != NULL);
  closures_free = closures_base;
  closures_limit = closures_base + DEF_CLOSURESARRAY_SIZE;

@ 

To initialize the Lua interpreter:

<<initialize a Lua interpreter>>=

  /* FIX : for now, send lua_open 0; it will default to a stacksize of 1024 */
  lua_interp = lua_open(0);
  lua_baselibopen(lua_interp);

  /* create new Lua tags for userdata */
  lua_RAddr_tag  = lua_newtag(lua_interp);
  lua_RBlock_tag = lua_newtag(lua_interp);
  lua_RLabel_tag = lua_newtag(lua_interp);
  lua_CMMprocedure_tag = lua_newtag(lua_interp);
  
  /* register additional C functions with Lua */
  ITERATE_CMM_FUNCS(LUA_FUNC_REGISTER)
  lua_register(lua_interp, "relocate_block", 
               (lua_CFunction) lua_relocate_block);

  /* create and enter default section */
  assert(lua_gettop(lua_interp) == 0);
  lua_CMM_section(lua_interp);
@ 

And then to run a Lua source file:

<<run Lua source file>>=
  lua_error_handle(lua_dofile(lua_interp, argv[1]), argv[1]);
@ 

We perform the necessary step of bytecode relocation:

<<perform bytecode relocation>>=
  /* relocate all named sections */
  lua_getglobal(lua_interp, SECTION_TABLE);
  if (!lua_isnil(lua_interp, -1)) {
    lua_error_handle(lua_dostring(lua_interp, 
                                "foreach("SECTION_TABLE", relocate_block)"),
                     "<internal code>");
  }
  lua_pop(lua_interp, 1);

  /* apply closures in closure table */
  for (cl = closures_base; cl < closures_free; cl++) {
    apply_closure(*cl, cl_emitm, error_wrapper);
  }

  /* free memory */
  free(closures_base);
@ 

And finally, we can put it all together:

<<decode.m>>=
#include "interp.h"

<<global variable definitions>>

<<operator definitions>>
<<initialization>>

<<main interpreter loop>>

<<bytecode generation>>
@ 

\section{Missing Details}

The missing \texttt{\#include} and \texttt{\#define} directives:

<<preprocessor directives>>=
#include <assert.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <string.h>
#include <error.h>
#include <lua.h>
#include <lualib.h>
#include "intervals.h"
#include "mclib.h"
#include "encode.h"

#define DEF_VALUESSTACK_SIZE    1024
#define DEF_ARGUMENTSSTACK_SIZE 1024
#define DEF_CLOSURESARRAY_SIZE  32768

#define SECTION_TABLE     "CMM_sections"
#define DEF_SECTION_TABLE "CMM_default_section"
#define PROCEDURE_TABLE   "CMM_procedures"
#define LABEL_TABLE       "CMM_labels"

/* STACK_ELT(S, I) evaluates to the value on stack S indexed by I, such that:
  
   STACK_ELT(S, 0) evaluates to the top value on stack S
   STACK_ELT(S, -1) evaluates to the next-to-top value on stack S
   etc.

   (note: STACK_ELT is only intended to work with the value stack, the argument
    stack, and the activation stack)
 */
#define STACK_ELT(S, I)       ((S)[(I)])

/* PUSH(V, S) pushes value V onto value stack S and returns V */
#define PUSH(V, S)            (STACK_ELT(0, (++(S))))

/* POP(S) pops the value on top of stack S and returns it */
#define POP(S)                (STACK_ELT(0, ((S)--)))

/* UNDERFLOW_CHECK(S, N) checks to make sure that popping N elements off stack
   S will not cause it to underflow
 */
#define UNDERFLOW_CHECK(S, N) (assert((S) - (S##_base) > -1))

/* OVERFLOW_CHECK(S, N) checks to make sure that pushing N elements onto stack
   S will not cause it to overflow
 */
#define OVERFLOW_CHECK(S, N)  (assert((S##_limit) - (S) >= 0))

/* VIEW(LVALUE, T) views LVALUE with C type T */
#define VIEW(LVALUE, T)       (*((T *) (&(LVALUE))))

/* FLOAT_BINARY(NAME, EXP, X, Y, TX, TY, T, BX, BY, B, ROUNDMODE)

   generates a function that takes an sptr, pops 2 values off the stack to
   which it points, evaluates floating-point computation EXP with rounding
   mode ROUNDMODE and pushes the result onto the stack, and returns an updated
   sptr

   NAME is the function's name stem
   EXP  is the expression to be evaluated
   X and Y are the names of the two values as EXP calls them
   B is the C-- type for the result value
   T is the C   type for the result value
   BX and BY are the C-- types for input values X and Y, respectively
   TX and TY are the C   types for input values X and Y, respectively
   ROUNDMODE is one of { round_down, round_up, 
*/

/* BINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B)

   generates a function that takes an sptr, pops 2 values off the stack to
   which it points, evaluates EXP and pushes the result onto the stack, and
   returns an updated sptr

   NAME is the function's name stem
   EXP  is the expression to be evaluated
   X and Y are the names of the two values as EXP calls them
   B is the C-- type for the result value
   T is the C   type for the result value
   BX and BY are the C-- types for input values X and Y, respectively
   TX and TY are the C   types for input values X and Y, respectively
*/
#define BINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
\
sptr op##_##NAME##_##B (sptr values) {       \
  TY Y;                                      \
  TX X;                                      \
  UNDERFLOW_CHECK(values, 2);                \
  Y = VIEW(STACK_ELT(values,  0).BY, TY);    \
  X = VIEW(STACK_ELT(values, -1).BX, TX);    \
  VIEW(STACK_ELT(values, -1).B, T) = (EXP);  \
  return values-1;                           \
}

/* UNARYOP(NAME, EXP, X, TX, BX, B)

   generates a function that takes an sptr, pops 1 value off the stack to which
   it points, evaluates EXP and pushes the result onto the stack, and returns
   an updated sptr

   NAME is the function's name stem
   EXP  is the expression to be evaluated
   X    is the name of the input value as EXP calls it
   B    is the C-- type for the result value
   T    is the C   type for the result value
   BX   is the C-- type for input value X
   TX   is the C   type for input value X
*/

#define UNARYOP(NAME, EXP, X, TX, T, BX, B)  \
\
sptr op##_##NAME##_##B (sptr values) {       \
  TX X;                                      \
  UNDERFLOW_CHECK(values, 1);                \
  X = VIEW(STACK_ELT(values, 0).BX, TX);     \
  VIEW(STACK_ELT(values, 0).B, T) = (EXP);   \
  return values;                             \
}

/* IUNARYOP is an imperative form of UNARYOP; destroys value at values */
#define IUNARYOP(NAME, STMS, X, TX, T, BX, B)  \
\
sptr op##_##NAME##_##B (sptr values) {       \
  TX X;                                      \
  UNDERFLOW_CHECK(values, 1);                \
  X = VIEW(STACK_ELT(values, 0).BX, TX);     \
  STMS;                                      \
  VIEW(STACK_ELT(values, 0).B, T) = X;       \
  return values;                             \
}

/* NULLARYOP(NAME, STMS, X, T, B)

   generates a function that takes an sptr, evaluates EXP and pushes the result
   onto the stack pointed to by sptr, and returns an updated sptr

   NAME is the function's name stem
   STMS are the C statements to be evaluated to compute the return value
   X    is the name of the variable to be used to compute the return value
   T    is the C   type for the result value
   B    is the C-- type for the result value
*/

#define NULLARYOP(NAME, STMS, X, T, B) \
\
sptr op##_##NAME##_##B (sptr values) {     \
  T X;                                     \
  OVERFLOW_CHECK(values, 1);               \
  STMS                                     \
  VIEW(STACK_ELT(values, 1).B, T) = X;     \
  return values + 1;                       \
}

/* T_BINARYOP and T_UNARYOP are wrappers for cousins BINARYOP and UNARYOP

   these wrappers assume that all input values are the same type as result
   values
*/

#define T_BINARYOP(NAME, EXP, X, Y, T, B)    \
BINARYOP(NAME, EXP, X, Y, T, T, T, B, B, B)

#define T_UNARYOP(NAME, EXP, X, T, B)        \
UNARYOP(NAME, EXP, X, T, T, B, B)

/* same for below */

#define T_IUNARYOP(NAME, STMS, X, T, B)  \
IUNARYOP(NAME, STMS, X, T, T, B, B)

/* POPCNT generates a function that implements bit-counting;
   T is a C type, B is a C-- type
 */
#define POPCNT(T, B) \
sptr op_popcnt##_##B (sptr values) {       \
  T v, count;                              \
  UNDERFLOW_CHECK(values, 1);              \
  v = VIEW(STACK_ELT(values, 0).B, T);     \
  for ( ; v != 0; v >>= 1)                 \
    count += (v & 1);                      \
  VIEW(STACK_ELT(values, 0).B, T) = count; \
  return values;                           \
}

/* these ROTx macros generate functions to implement bit-rotation;
   T is a C type, B is a C-- type
 */
#define _LS <<
#define ROTL(T, B) \
T_BINARYOP(rotl, (x _LS d) + (((~(((T) ~0) >> d)) & x) >> (sizeof(T)*8 - d)),\
                 x, d, T, B);
#define ROTR(T, B) \
T_BINARYOP(rotr, (x >>  d) + (((~(((T) ~0) << d)) & x) << (sizeof(T)*8 - d)),\
                 x, d, T, B);


/* these macros help out with wrapping C functions in Lua-style C functions
   as well as registering these functions with Lua */
#define LUA_WRAP_NULLARY(FUNC, LUANAME) \
\
int lua_CMM_##LUANAME (lua_State *L) {             \
  if (lua_gettop(L) != 0)                          \
    lua_error(L, #FUNC " is a nullary function!"); \
  FUNC();                                          \
  return 0;                                        \
}

#define LUA_WRAP_UNARY_INDEX(FUNC, LUANAME) \
int lua_CMM_##LUANAME (lua_State *L) { \
  if (!lua_isnumber(L, -1)) \
	lua_error(L, #FUNC " requires an integer index!"); \
  FUNC((unsigned) lua_tonumber(L, -1)); \
  lua_pop(L, 1); \
  return 0; \
}

#define ITERATE_CMM_FUNCS(F) \
F(section) \
F(end_section) \
F(define_label) \
F(procedure) \
F(push_literal) \
F(fetch_local) \
F(fetch_global) \
F(store_local) \
F(store_global) \
F(gstore_local) \
F(gstore_global) \
F(push_arg) \
F(pop_arg) \
F(goto) \
F(cbrancht) \
F(cbranchf) \
F(branchtf) \
F(cmm_tail_call) \
F(return) \
F(cut)

#define ITERATE_UNFINISHED_CMM_FUNCS(F) \
F(push_symbol) \
F(fetch) \
F(store) \
F(guarded_store) \
F(apply_operator) \
F(cmm_call) \
F(c_call)

#define LUA_FUNC_PROTOTYPE(X) \
int lua_CMM_##X (lua_State *L);

#define LUA_FUNC_REGISTER(X) \
lua_register(lua_interp, "CMM_"#X, (lua_CFunction) lua_CMM_##X);

#define bool_true(B)  ((B) != ((bool) 0))
#define bool_false(B) ((B) == ((bool) 0))

#define ASSERT_EMPTY(V) (assert((V) == (V##_base)))
@

The missing definitions of global variables:

<<global variable definitions>>=
static stack     values_base  = NULL;
static sptr      values_limit = NULL;

static stack     arguments_base  = NULL;
static sptr      arguments_limit = NULL;

static RClosure  *closures_base  = NULL;
static RClosure  *closures_free  = NULL;
static RClosure  *closures_limit = NULL;

static int       lua_RAddr_tag;
static int       lua_RBlock_tag;
static int       lua_RLabel_tag;
static int       lua_CMMprocedure_tag;
@ 

Function prototypes for code implemented here:

<<interp.h>>=
<<preprocessor directives>>

<<type definitions>>

void run_interp(procedure *start, int num_globals, void *stack_space,
                void *stack_limit);

/* Initialization Helper Functions: */
void   check_value_types(void);

void   init(void);
thread *init_thread(void *stack_space, void *stack_limit);
thread *find_thread(uid u);

uid    new_uid(thread *t);
void   dies_uid(uid u);
int    islive_uid(uid u);

/* Toolkit helper functions */
RAddr  get_label_addr(lua_State *L, char *name);

/* C-Lua functions */
ITERATE_CMM_FUNCS(LUA_FUNC_PROTOTYPE)
int    lua_relocate_block(lua_State *L);

void   lua_error_handle(int err_code, const char *fn);

/* FIX how about operator implementations, even though they're macro'ed ? */
@ 

Here is how we shut down the interpreter:

<<shut down interpreter>>=

/* free malloc'd space */

free(values_base);
values_base = NULL;

free(arguments_base);
arguments_base = NULL;

free(globals);
@ 

Here is how we gracefully shut down the whole program:

<<gracefully shut down>>=
lua_close(lua_interp);

/* FIX do we have to shut down the encoder somehow?  free memory? */

@ 

And some more information for decoding bytecodes:

<<decode.fetch>>=
address type is "unsigned char *"
fetch 8  using "*%a"
fetch 16 using "%a[0] + (%a[1] << 8)"
fetch 32 using "%a[0] + (%a[1] << 8) + (%a[2] << 16) + (%a[3] << 24)"
@

\section{Personal Notes}

I could probably remove \texttt{locals\_end} and \texttt{stackdata\_end} as local variables in function \texttt{run\_interp}; but they \emph{must} remain stored away in an \texttt{activation} record at all non-tail calls.

Can probably find a better way of uniquely identifying threads.

Do nullary operations have to have a type appended to their names?  (e.g., [[round_down_bits32]])

How should floating-pt computation with rounding best be done?

FIX FIX have to change [[ROTL]] and [[ROTR]] so they deal with the case when $d > x$.

FIX the fact that I have a left shift, some code, a right shift, and noweb things that it's a chunk specifier!!!  For now, I hack around with the [[#define _LS]] bit...

Should macro-generated functions look like [[op_xor_bits16]] or like [[op_xor_bits16_bits16]] or like [[op_xor_bits16_bits16_bits16]] or something else...

[[label_new]] does NOT copy its string argument; do NOT free anything you pass off to [[label_new]]!

The tables I use in Lua may be garbage collected!!!  Use the API functions [[lua_ref]], [[lua_get_ref]], and [[lua_unref]] properly!  It will actually help simplify code.

What do the namespaces look like?  Is there one namespace for labels, procedure names, continuation names, section names?  Or are they separate?  As it is, I effectively have one namespace for all these because I use their names as their label names instead of prepending to it a tag of some sort.

Do we need to allow an [[emit_raddr]] instruction in our VM?

Should change calls to [[lua_settop]] to calls to macro [[lua_pop]].  It's more readable that way.

What kind of a symbol does [[push_symbol]] expect to be pushing?  A label?  An external symbol?  A procedure name?  A continuation name?  Any of these?

No way to push boolean right now, except for simply pushing 0 or 1 and making sure the bits work out.