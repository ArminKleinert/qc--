% -*- mode: Noweb; noweb-code-mode: c-mode -*-

\section{Bytecode for a Quick~{\PAL} Interpreter}

This file contains some SLED definitions and simple functions that
define a bytecode representation of the instructions used in the
Quick~{\PAL} interpreter.

<<bytecode.sled>>=
fields of bcode     (8) op 0:7
fields of byte      (8) bits8  0:7
fields of short    (16) bits16 0:15
fields of long     (32) bits32 0:31
fields of longlong (64) bits64 0:63
@ 
Here's the general idea:
most bytecodes will carry an integer index that will be used to look
up a function in a table.
That function will modify memory as needed and possibly return new
state elements.
As an example, consider an operator.
It needs access only to the value stack, and it can't overflow.
Perhaps this stack is represented by an array and a stack pointer.
Then we would have
\begin{verbatim}
   typedef unsigned (*operator_fun)(Array_T valstack, unsigned sp);
\end{verbatim}
An operator bytecode would then carry an index into an array of [[operator_fun*]].
@
Here are some sketches about implementation:
\begin{itemize}
\item
A literal or a symbol can be handled by a single `push' bytecode.
\item
We will want ``short'' and ``long'' versions of many bytecodes (using
8- and 16-bit arguments).
\end{itemize}
@
Here are type definitions for procedures we might need.
<<type definitions>>=
typedef Array_T stack;
typedef unsigned sptr;

typedef sptr (*operator_fun)(stack values, sptr sp);
  /* FETCH, STORE, OPERATOR */

typedef sprt (*push_fun)    (stack values, sptr sp, stpr limit);
  /* LITERAL, PUSH_SYMBOL */

typedef sptr (*var_fun)     (stack values, sptr sp, value *vars);
  /* GUARDED_STORE */

typedef unsigned (*arg_fun)     (stack values, sptr sp, sptr slimit,
                                 stack args,   sptr ap, sptr alimit);
  /* PUSH_ARG, POP_ARG */
@ 
<<bytecode.sled>>=
patterns
  [ OP8 OP16 PUSH VAR8 VAR16 VARPUSH8 VARPUSH16 PUSH_ARG POP_ARG 
    STORE_LOCAL8  STORE_GLOBAL8  FETCH_LOCAL8  FETCH_GLOBAL8
    STORE_LOCAL16 STORE_GLOBAL16 FETCH_LOCAL16 FETCH_GLOBAL16
    HALT
    PLACECODE
  ] is op = {0 to 18}

patterns 
  any8  is OP8  | VAR8  | VARPUSH8 
         | STORE_LOCAL8  | STORE_GLOBAL8  | FETCH_LOCAL8  | FETCH_GLOBAL8
  any16 is OP16 | VAR16 | VARPUSH16
         | STORE_LOCAL16 | STORE_GLOBAL16 | FETCH_LOCAL16 | FETCH_GLOBAL16
  any32 is PUSH
  nullary is PUSH_ARG | POP_ARG

relocatable addr

placeholder for bcode is PLACECODE
placeholder for long  is bits32 = 0

constructors
  any8  bits8      is  any8;  bits8
  any16 bits16     is  any16; bits16
  any32 bits32     is  any32; bits32
  PUSH_SYMBOL addr is  PUSH; bits32 = addr
  nullary

# conditional assembly
  operator bits16
    when { }  is op8 (bits16)
    otherwise is op16(bits16)
  var bits16
    when { }  is var8 (bits16)
    otherwise is var16(bits16)
  store_local bits16
    when { }  is store_local8 (bits16)
    otherwise is store_local16(bits16)
  store_global bits16
    when { }  is store_global8 (bits16)
    otherwise is store_global16(bits16)
  fetch_local bits16
    when { }  is fetch_local8 (bits16)
    otherwise is fetch_local16(bits16)
  fetch_global bits16
    when { }  is fetch_global8 (bits16)
    otherwise is fetch_global16(bits16)
@ 
<<decode.m>>=
<<type definitions>>

extern operator_fun *operator_funs;
extern var_fun *var_funs;

void run_interp(void) {
    bytecode *pc;
    stack values;
    sptr vsp;
    sprt vlimit;
    stack args;
    sptr asp;
    sprt alimit;
    value *locals;
    value *globals;

      for (;;) {
        match pc to
        | op8 (n) => vsp = operator_funs[n](values, vsp);
        | op16(n) => vsp = operator_funs[n](values, vsp);
        | var8 (n) => vsp = var_funs[n](values, vsp, vlimit);
        | var16(n) => vsp = var_funs[n](values, vsp, alimit);
        | store_local(n) => locals[n] = POP(values, vsp);
        | fetch_local(n) => PUSH(values, vsp, vlimit, locals[n]);
        | store_global(n) => globals[n] = POP(values, vsp);
        | fetch_global(n) => PUSH(values, vsp, vlimit, globals[n]);
        | HALT => return;
        endmatch
      }
}


@ 
<<decode.fetch>>=
address type is "unsigned char *"
fetch 8  using "*%a"
fetch 16 using "%a[0] + (%a[1] << 8)"

