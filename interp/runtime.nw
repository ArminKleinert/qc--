\section{Introduction}
This document contains the interface and implementation of the {\PAL} run-time system, as explained in CVS revision 1.59 of the {\PAL} Reference Manual.
Please see the manual for detailed information about the functions contained herein.

% ----------------------------------------------------------------------------
\section{{\PAL} Runtime System Interface}
% ----------------------------------------------------------------------------

% ----------------------------------------------------------------------------
\subsection{Types}
% ----------------------------------------------------------------------------

<<faux type declarations>>=
typedef Cmm_Codeptr;
typedef Cmm_Dataptr;
typedef Cmm_Word;

typedef Cmm_Activation;
typedef Cmm_Cont;
@

% ----------------------------------------------------------------------------
\subsection{Creating and Running a Thread}
% ----------------------------------------------------------------------------

[[Cmm_CreateThread]] returns a {\PAL} continuation that will execute the {\PAL} call [[f(x)]], when run.
[[Cmm_RunThread]] commences execution on a {\PAL} continuation (a suspended {\PAL} computation) as returned from [[Cmm_CreateThread]].

<<function prototypes>>=
Cmm_Cont       *Cmm_CreateThread(Cmm_Codeptr f, Cmm_Dataptr x, void *s,
                                 unsigned n, void **limit_cookie);
Cmm_Cont       *Cmm_RunThread   (Cmm_Cont *k);
@ 

We also export thread creation to {\PAL} itself in the form of [[CreateThread]], which for now may run with a [[c_call]] from {\PAL}.
[[CreateThread]] takes four arguments: the address of a procedure, data to send to the procedure, a pointer to available space to be used as activation stack space, and the size of this space.
It returns two values: the created thread, and a cookie pointing to the limit of the activation stack created for the thread.
[[CreateThread]] takes 

<<faux {\PAL} prototypes>>=
bits32 CreateThread(bits32 f, bits32 x, bits32 s, bits32 n, bits32 cookie_ptr);
@ 

% ----------------------------------------------------------------------------
\subsection{Walking the Stack}
% ----------------------------------------------------------------------------

<<function prototypes>>=
Cmm_Activation *Cmm_YoungestActivation(const Cmm_Cont *t);
int             Cmm_isOldestActivation(const Cmm_Activation *a);
Cmm_Activation *Cmm_NextActivation(const Cmm_Activation *a);
int             Cmm_ChangeActivation(Cmm_Activation **a);
void           *Cmm_FindLocalVar(const Cmm_Activation *a, unsigned n);
unsigned        Cmm_LocalVarCount(const Cmm_Activation *a);
void           *Cmm_FindDeadLocalVar(const Cmm_Activation *a, unsigned n);
Cmm_Dataptr     Cmm_GetDescriptor(const Cmm_Activation *a, Cmm_Word token);
Cmm_Cont       *Cmm_GetCont(const Cmm_Activation *a, Cmm_Word token);
@ 

% ----------------------------------------------------------------------------
\subsection{The Global Registers}
% ----------------------------------------------------------------------------

<<faux {\PAL} prototypes>>=
SaveGlobals( bits32 gp );
RestoreGlobals( bits32 gp );
%GlobalSize
@ 

<<function prototypes>>=
void           *Cmm_FindGlobalVar(void *gp, int n);
unsigned        Cmm_GlobalCount  (void);
unsigned        Cmm_GlobalSize   (void);
@ 

% ----------------------------------------------------------------------------
\subsection{Controlling the Interpreter}
% ----------------------------------------------------------------------------

The runtime system exports two functions that allow the interpreter to be started up and shut down.
[[Cmm_open]] must only be called once, and must be called before any other interpreter-related functions are called.
[[Cmm_close]] should be called once, but not until after the interpreter has finished its work.

<<function prototypes>>=
int  Cmm_open(int valstack_size, int argspace_size);
void Cmm_close(void);
@ 

% ----------------------------------------------------------------------------
\section{Implementation for the Interpreter}
% ----------------------------------------------------------------------------

The header file for the {\PAL} runtime system is contained within [[runtime.h]].

<<runtime.h>>=
#ifndef _RUNTIME_H
#define _RUNTIME_H

#include "label.h"
#include "interp.h"
#include "thread.h"

<<type definitions>>

<<function prototypes>>

#endif /* _RUNTIME_H */
@ 

We import a few values from [[interp.m]]; namely, the number of globals in the loaded {\PAL} code, the array in which the {\PAL} global values are actually stored, and the Lua tag we use to store [[span]] values in our Lua span tables.
<<faux declarations for external definitions>>=
extern int    num_globals;
extern value *globals;
extern int    lua_CMM_span_value_tag;
extern int    lua_CMM_label_tag;
@

The implementation of the {\PAL} runtime system is contained within [[runtime.c]].

<<runtime.c>>=
#include "runtime.h"

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "interp.h"
#include "value.h"
#include "activation.h"
#include "lualink.h"
#include "ccall.h"
#include "span.h"

<<internal function prototypes>>

<<thread functions>>
<<stack-walking functions>>
<<global register functions>>
<<controlling the interpreter>>

<<internal helpers>>
@ 

% ----------------------------------------------------------------------------
\subsection{Types}
% ----------------------------------------------------------------------------

The types used in the runtime system's interface are all [[typedef]]'d in reality.
We actually use a [[CMM_label]] to represent a code pointer so that we can easily pass more information than simply a program counter (e.g., we can also pass around [[procedure]] records).

<<type definitions>>=
typedef CMM_label   *Cmm_Codeptr;
@ 

[[Cmm_Dataptr]] and [[Cmm_Activation]] are simply renamed (and capitalized) versions of their counterparts ([[dataptr]] and [[activation]]).

<<type definitions>>=
typedef dataptr      Cmm_Dataptr;
typedef activation   Cmm_Activation;
@ 

The next type definition is confusing, though.  A [[Cmm_Cont]] is actually a [[thread]]; we need to keep track of more information than simply a stack pointer and a program counter.

<<type definitions>>=
typedef thread       Cmm_Cont;
@ 

% ----------------------------------------------------------------------------
\subsection{Creating and Running a Thread}
% ----------------------------------------------------------------------------

The work of creating a thread is farmed out to [[init_thread]], as defined in [[interp.nw]]; and the work of running a thread is taken care of by similarly defined [[run_interp]].
\emph{FIX: for the moment, it is unclear what exactly [[Cmm_RunThread]] should return, if anything at all.}

<<thread functions>>=
Cmm_Cont *Cmm_CreateThread(Cmm_Codeptr f, Cmm_Dataptr x, void *s, unsigned n,
                           void **limit_cookie) {
  static unsigned  boot_id  = 0;
  int              rc;
  thread          *t;
  CMM_label       *lbl;

  char            *byteorder_string = (DEF_BYTE_ORDER == BIG ? "'BIG'" 
                                                             : "'LITTLE'");

  /* FIX -- MACHINE SPECIFIC */
  char *bootstring = (char *) malloc(sizeof(char) * 1024);
  sprintf(bootstring, "CMM.imports({ '%s' })               \n"
                      "CMM.exports({ '_boot_proc_%u' })    \n"
                      "CMM.section('_boot_section_%u')     \n"
                      "CMM.define_label('_boot_f_%u')      \n"
                      "CMM.skip(4)                         \n"
                      "CMM.define_label('_boot_x_%u')      \n"
                      "CMM.skip(4)                         \n"
                      "CMM.procedure('_boot_proc_%u',1,0)  \n"

                      "CMM.push_symbol('_boot_x_%u')       \n"
                      "CMM.fetch(%d,%s,%d)                 \n"

                      "CMM.store_local(0)                  \n"
                      "CMM.fetch_local(0)                  \n"
                      "CMM.cbranchf('_boot_label_%u')      \n"

                      "CMM.fetch_local(0)                  \n"
                      "CMM.fetch(%d,%s,%d)                 \n"
                      "CMM.store_arg(0)                    \n"

                      "CMM.define_label('_boot_label_%u')  \n"
                      "CMM.push_symbol('_boot_f_%u')       \n"
                      "CMM.fetch(%d,%s,%d)                 \n"
                      "CMM.call({}, {}, {}, 0)             \n"
                      "CMM.cmm_return(0, 0)                \n"
                      "CMM.end_section()                   \n",

                      CMM_label_raddr(((CMM_label *) f))->label->name,
                      boot_id, boot_id, boot_id, boot_id, boot_id, boot_id,
                      sizeof(void *), byteorder_string, 1, boot_id, 
                      sizeof(void *), byteorder_string, 1, boot_id, boot_id, 
                      sizeof(void *), byteorder_string, 1);

  boot_id++;

  rc = load_assembly_unit(bootstring, SRC_STRING);
  if (rc) {
    fprintf(stderr, "error: could not boot up thread\n");
    exit(1);
  }

  sprintf(bootstring, "_boot_proc_%u", boot_id - 1);
  lbl = cmm_find_export(bootstring);

  free(bootstring);
  assert(lbl != NULL);

  /* initialize thread */
  t = init_thread(lbl, s, n);
  *limit_cookie = t->stack_limit;

  /* initialize f and x placeholders in loaded bootstring unit */
  assert(location_known(CMM_label_raddr((CMM_label *) lbl)));
  {
    void **loc = (void **) CMM_label_location((CMM_label *) lbl);

    /* f */
    loc[-2] = (void *) f;

    /* x */
    loc[-1] = (void *) x;
  }

  return (Cmm_Cont *) t;
}

Cmm_Cont *Cmm_RunThread (Cmm_Cont *k) {
  run_interp((thread *) k);

  /* NOTE this function should not return!
   */
  return NULL;
}
@ 

\paragraph{Exporting to {\PAL}}

We write [[Cmm_CreateThread_helper]] simply to wrap up a call to [[Cmm_CreateThread]].
For now this involves only some simple type casting (pointer arguments are passed as [[void *]]s).

<<thread functions>>=
void *Cmm_CreateThread_helper(void *f, void *x, void *s, unsigned n,
                                 void *limit_cookie)
{
  return (void *) Cmm_CreateThread((Cmm_Codeptr) f, (Cmm_Dataptr) x, 
                                   (void *) s, (unsigned) n,
                                   (void **) limit_cookie);
}
@ 

% ----------------------------------------------------------------------------
\subsection{Walking the Stack}
% ----------------------------------------------------------------------------

Walking the stack is very easy, given our representation of activation stacks.
To find the youngest activation, determine if an activation is the oldest in its thread, and to find the activation of a given activation's caller we do some pointer arithmetic; this arithmetic, of course, relies on the stacks' direction of growth.

<<stack-walking functions>>=
Cmm_Activation *Cmm_YoungestActivation(const Cmm_Cont *t) {
  assert(t->stack_free > t->stack_base);
  return (Cmm_Activation *) (((activation *) t->stack_free) - 1);
}

int Cmm_isOldestActivation(const Cmm_Activation *a) {
  thread *t = find_thread(a->u);

  return (t->stack_base == a->locals);
}

Cmm_Activation *Cmm_NextActivation(const Cmm_Activation *a) {
  if (Cmm_isOldestActivation(a)) {
    runtime_sys_err("[runtime system] already at oldest activation in thread");
  }

  return (Cmm_Activation *) (((activation *) (a->locals)) - 1);
}

int Cmm_ChangeActivation(Cmm_Activation **a) {
  thread *t = find_thread((*a)->u);

  if (t->stack_base == (*a)->locals)
    return 0;
  else {
    (*a) = ((actptr) ((*a)->locals)) - 1;
    /* LOOK AT THIS!!! */
    /* t->stack_free = (void *) (((actptr) (*a)) + 1); */
    return 1;
  }
}
@ 

DOCUMENT
\emph{These functions are unimplemented and fail assertions for now.}

<<stack-walking functions>>=

void *Cmm_FindLocalVar(const Cmm_Activation *a, unsigned n) {
  return (void *) (a->locals + n);
}

unsigned Cmm_LocalVarCount(const Cmm_Activation *a) {
  return (unsigned) (a->locals_end - a->locals);
}

void *Cmm_FindDeadLocalVar(const Cmm_Activation *a, unsigned n) {
  assert(0);

  /* C CODE HERE */
  /* FINISH */
  return NULL;
}

Cmm_Cont *Cmm_GetCont(const Cmm_Activation *a, Cmm_Word token) {
  thread *t    = find_thread(a->u);
  lua_State *L; /* = t->span_table.L; */

  /* FIX the definition of L */
  assert(0);

  /* HAVEN'T REDONE THIS STACK REDO */
  /* STACK REDO
  t->callstack_free--;
  */

  if (token != 0) {
    Cmm_Activation *act = ((Cmm_Activation *) a) - 1;
    annotations    *ann = act->kappa;
    CMM_label      *lbl;

    lua_pushtable(L, ann->also_cuts_to);
    lua_rawgeti(L, -1, (int) token);
    if (!lua_isuserdata(L, -1) ||
        lua_tag(L, -1) != lua_CMM_label_tag ||
        (lbl = lua_touserdata(L, -1)) == NULL)
    {
      lua_pop(L, 2); /* pop bogus value, table */
      runtime_sys_err("invalid continuation index given to Cmm_GetCont");
    }

    act->pc = CMM_label_location(lbl);
    lua_pop(L, 2);
  }
 
  /* HAVEN'T REDONE THIS :: STACK REDO
  (t->callstack_free - 1)->kappa = NULL;
  */

  return (Cmm_Cont *) t;
}
@

Finding a descriptor is harder.
[[Cmm_GetDescriptor]] must look up the given [[token]] in the Lua span table of the given activation's thread; moreover, it must look for the innermost (table entry with greatest index) value associated with the token.

<<stack-walking functions>>=
Cmm_Dataptr Cmm_GetDescriptor(const Cmm_Activation *a, Cmm_Word token) {
  return (Cmm_Dataptr) span_find_value((unsigned) a->pc, (unsigned) token);
}
@ 

% ----------------------------------------------------------------------------
\subsection{Returning Control To Client Runtime}
% ----------------------------------------------------------------------------

\ldots

% ----------------------------------------------------------------------------
\subsection{The Global Registers}
% ----------------------------------------------------------------------------

We have full access to the global variables, so these three functions for accesing the global registers are easy to implement in their present form.

<<global register functions>>=
void *Cmm_FindGlobalVar(void *gp, int n) {
  return (void *) (((value *) globals) + n);
}
unsigned Cmm_GlobalCount(void) {
  return (num_globals < 0 ? 0 : (unsigned) num_globals);
}
unsigned Cmm_GlobalSize(void) {
  return Cmm_GlobalCount() * sizeof(value);
}
@

Although the next two functions are not explicitly provided as C functions in the interface to the runtime system, we use them to help export their functionality to {\PAL}.

<<function prototypes>>=
void Cmm_SaveGlobals_helper(unsigned gpu);
void Cmm_RestoreGlobals_helper(unsigned gpu);
@ 

<<global register functions>>= 
void Cmm_SaveGlobals_helper(unsigned gpu) {
  void *gp = (void *) gpu;
  cmm_assert(gp != NULL, "SaveGlobals given NULL pointer");
  gp = memcpy(gp, globals, sizeof(value) * num_globals);
}

void Cmm_RestoreGlobals_helper(unsigned gpu) {
  void *gp = (void *) gpu;
  cmm_assert(gp != NULL, "RestoreGlobals given NULL pointer");
  globals = memcpy(globals, gp, sizeof(value) * num_globals);
}
@ 

% ----------------------------------------------------------------------------
\subsection{Controlling the Interpreter}
% ----------------------------------------------------------------------------

So we can better control how the runtime system fits in with the interpreter, we wrap the interpreter's [[cmm_interp_open]] and [[cmm_interp_close]] functions.
For one thing, this allows us to register select C functions in the runtime system with the interpreter (to be called from {\PAL}), while keeping the interpreter's implementation otherwise ignorant of the runtime system.

<<controlling the interpreter>>=
int Cmm_open(int valstack_size, int argspace_size) {
  int rc = cmm_interp_open(valstack_size, argspace_size);

  /* register any necessary C functions with C-- */
  register_c_func("SaveGlobals",    (void *) Cmm_SaveGlobals_helper,
                  "unsigned:void");
  register_c_func("RestoreGlobals", (void *) Cmm_RestoreGlobals_helper, 
                  "unsigned:void");
  /* register_c_func("CreateThread",   (void *) Cmm_CreateThread_helper,
                  "pointer,pointer,unsigned,pointer:pointer"); */

  if (rc != 0) { return rc; }
  
  <<load in the standard basis and store error code in [[rc]]>>

  return rc;
}  
@ 

To load in the standard basis, we must first make sure to find it.  We search
a few common directories and if we don't find it, simply try the current
directory.  If all fails, we signal an error.

<<load in the standard basis and store error code in [[rc]]>>=
  {
    char *standard_basis = "function CMM.c_call(s)   \n"
                           "CMM.push_symbol(s)       \n"
                           "CMM.call({}, {}, {}, 0)  \n"
                           "end                      \n";

    rc = load_assembly_unit(standard_basis, SRC_STRING);
  }
@ 

<<controlling the interpreter>>=
void Cmm_close(void) {
  cmm_interp_close();
}
@ 

% ----------------------------------------------------------------------------
\subsection{Error Handling}
% ----------------------------------------------------------------------------

If an error is encountered in one of the runtime system's functions, a call
is made to private internal helper [[runtime_sys_err]].

<<internal function prototypes>>=
void runtime_sys_err(char *fmt, ...);
@ 

This function is given an error message's format string and a variable number
of arguments.

Callers of this function should expect it \emph{not} to return.

<<internal helpers>>=
void runtime_sys_err(char *fmt, ...) {
  va_list args;

  if (fmt != NULL) {
    fprintf(stderr, "error: ");

    va_start(args, fmt);
    vfprintf(stderr, fmt, args);

    fprintf(stderr, "\n");
  }

  fprintf(stderr, "error: C-- runtime system error; cannot continue");
  va_end(args);

  exit(1);
}
@ 
