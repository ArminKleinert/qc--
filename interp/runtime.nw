\section{Introduction}

This document contains the interface and implementation of the {\PAL} run-time system, as explained in CVS revision 1.59 of the {\PAL} Reference Manual.
Please see the manual for detailed information about the functions contained herein.

% ----------------------------------------------------------------------------
\section{{\PAL} Runtime System Interface}
% ----------------------------------------------------------------------------

% ----------------------------------------------------------------------------
\subsection{Types}
% ----------------------------------------------------------------------------

<<faux type declarations>>=
typedef Cmm_Codeptr;
typedef Cmm_Dataptr;
typedef Cmm_Word;

typedef Cmm_Activation;
typedef Cmm_Cont;
@

% ----------------------------------------------------------------------------
\subsection{Creating and Running a Thread}
% ----------------------------------------------------------------------------

[[Cmm_CreateThread]] returns a {\PAL} continuation that will execute the {\PAL} call [[f(x)]], when run.
[[Cmm_RunThread]] commences execution on a {\PAL} continuation (a suspended {\PAL} computation) as returned from [[Cmm_CreateThread]].

<<function prototypes>>=
Cmm_Cont       *Cmm_CreateThread(Cmm_Codeptr f, Cmm_Dataptr x, void *s,
                                 unsigned n, void **limit_cookie);
Cmm_Cont       *Cmm_RunThread   (Cmm_Cont *k);
@ 

% ----------------------------------------------------------------------------
\subsection{Walking the Stack}
% ----------------------------------------------------------------------------

<<function prototypes>>=
Cmm_Activation *Cmm_YoungestActivation(const Cmm_Cont *t);
int             Cmm_isOldestActivation(const Cmm_Activation *a);
Cmm_Activation *Cmm_NextActivation(const Cmm_Activation *a);
int             Cmm_ChangeActivation(Cmm_Activation **a);
void           *Cmm_FindLocalVar(const Cmm_Activation *a, unsigned n);
unsigned        Cmm_LocalVarCount(const Cmm_Activation *a);
void           *Cmm_FindDeadLocalVar(const Cmm_Activation *a, unsigned n);
void           *Cmm_FindStackData(const Cmm_Activation *a, unsigned n);
Cmm_Dataptr     Cmm_GetDescriptor(const Cmm_Activation *a, Cmm_Word token);
Cmm_Cont       *Cmm_GetUnwindCont(const Cmm_Activation *a, Cmm_Word index);
@ 

% ----------------------------------------------------------------------------
\subsection{The Global Registers}
% ----------------------------------------------------------------------------

<<faux {\PAL} prototypes>>=
SaveGlobals( bits32 gp );
RestoreGlobals( bits32 gp );
%GlobalSize
@ 

<<function prototypes>>=
void           *Cmm_FindGlobalVar(void *gp, int n);
unsigned        Cmm_GlobalCount  (void);
unsigned        Cmm_GlobalSize   (void);
@ 

% ----------------------------------------------------------------------------
\subsection{Controlling the Interpreter}
% ----------------------------------------------------------------------------

The runtime system exports two functions that allow the interpreter to be started up and shut down.
[[Cmm_open]] must only be called once (unless [[Cmm_close]] was called since it was last called), and must be called before any other interpreter-related functions are called.
[[Cmm_close]] should be called once, but not until after the interpreter has finished its work, and only after [[Cmm_open]] has been called.

<<function prototypes>>=
int  Cmm_open(int valstack_size, int argspace_size);
void Cmm_close(void);
@ 

% ----------------------------------------------------------------------------
\section{Implementation for the Interpreter}
% ----------------------------------------------------------------------------

The header file for the {\PAL} runtime system is contained within [[runtime.h]].

<<runtime.h>>=
#ifndef _RUNTIME_H
#define _RUNTIME_H

#include "label.h"
#include "interp.h"
#include "thread.h"

<<type definitions>>

<<function prototypes>>

#endif /* _RUNTIME_H */
@ 

We import a few values from other noweb documents; namely, the number of globals in the loaded {\PAL} code, the array in which the {\PAL} global values are actually stored, and the Lua tags we use to store [[span]] values and [[CMM_label]]s in Lua tables.

<<faux declarations for external definitions>>=
extern int    num_globals;
extern value *globals;
extern int    lua_CMM_span_value_tag;
extern int    lua_CMM_label_tag;
@

The implementation of the {\PAL} runtime system is contained within [[runtime.c]].

<<runtime.c>>=
#include "runtime.h"

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "interp.h"
#include "value.h"
#include "activation.h"
#include "lualink.h"
#include "ccall.h"
#include "span.h"

<<internal function prototypes>>

<<thread functions>>
<<stack-walking functions>>
<<global register functions>>
<<controlling the interpreter>>

<<internal helpers>>
@ 

% ----------------------------------------------------------------------------
\subsection{Types}
% ----------------------------------------------------------------------------

The types used in the runtime system's interface are all [[typedef]]'d in reality.
We actually use a [[CMM_label]] to represent a code pointer so that we can easily pass more information than simply a program counter (e.g., we can also pass around [[procedure]] records).

<<type definitions>>=
typedef CMM_label   *Cmm_Codeptr;
@ 

[[Cmm_Dataptr]] and [[Cmm_Activation]] are simply renamed (and capitalized) versions of their counterparts ([[dataptr]] and [[activation]]).

<<type definitions>>=
typedef dataptr      Cmm_Dataptr;
typedef activation   Cmm_Activation;
@ 

The next type definition is confusing, though.  A [[Cmm_Cont]] is actually a [[thread]]; we need to keep track of more information than simply a stack pointer and a program counter.

<<type definitions>>=
typedef thread       Cmm_Cont;
@ 

% ----------------------------------------------------------------------------
\subsection{Creating and Running a Thread}
% ----------------------------------------------------------------------------

The work of creating a thread is farmed out to [[init_thread]], as defined in [[thread.nw]]; and the work of running a thread is taken care of by similarly defined [[run_interp]].
\emph{FIX: for the moment, it is unclear what exactly [[Cmm_RunThread]] should return, if anything at all.}

We also use some partially-static boot-up code to be able to run initial
{\PAL} procedure [[f]] with argument [[x]].
Unfortunately, for the moment, this means that if one were to inspect a
new thread that has yet to be run, he would be surprised to find the thread
suspended at this strange boot-up procedure and not at the procedure he
wrote.

<<thread functions>>=
Cmm_Cont *Cmm_CreateThread(Cmm_Codeptr f, Cmm_Dataptr x, void *s, unsigned n,
                           void **limit_cookie) {
  static unsigned  boot_id  = 0;
  int              rc;
  thread          *t;
  CMM_label       *lbl;

  char            *byteorder_string = (DEF_BYTE_ORDER == BIG ? "'BIG'" 
                                                             : "'LITTLE'");

  /* FIX -- MACHINE SPECIFIC */
  char *bootstring = (char *) malloc(sizeof(char) * 1024);
  sprintf(bootstring, "CMM.imports({ '%s' })               \n"
                      "CMM.exports({ '_boot_proc_%u' })    \n"
                      "CMM.section('_boot_section_%u')     \n"
                      "CMM.align(%d)                       \n"
                      "CMM.define_label('_boot_f_%u')      \n"
                      "CMM.skip(4)                         \n"
                      "CMM.define_label('_boot_x_%u')      \n"
                      "CMM.skip(4)                         \n"
                      "CMM.procedure('_boot_proc_%u',1,0)  \n"

                      "CMM.push_symbol('_boot_x_%u')       \n"
                      "CMM.fetch(%d,%s,%d)                 \n"

                      "CMM.store_local(0)                  \n"
                      "CMM.fetch_local(0)                  \n"
                      "CMM.cbranchf('_boot_label_%u')      \n"

                      "CMM.fetch_local(0)                  \n"
                      "CMM.fetch(%d,%s,%d)                 \n"
                      "CMM.store_arg(0)                    \n"

                      "CMM.define_label('_boot_label_%u')  \n"
                      "CMM.push_symbol('_boot_f_%u')       \n"
                      "CMM.fetch(%d,%s,%d)                 \n"
                      "CMM.call({}, {}, {}, 0)             \n"
                      "CMM.cmm_return(0, 0)                \n"
                      "CMM.end_section()                   \n",

                      CMM_label_raddr(((CMM_label *) f))->label->name, boot_id,
                      boot_id, DEF_ALIGN, boot_id, boot_id, boot_id, boot_id,
                      8*sizeof(void *), byteorder_string, DEF_ALIGN, boot_id, 
                      8*sizeof(void *), byteorder_string, DEF_ALIGN, boot_id, 
                      boot_id, 8*sizeof(void *), byteorder_string, DEF_ALIGN);

  boot_id++;

  rc = load_assembly_unit(bootstring, SRC_STRING);
  if (rc) {
    fprintf(stderr, "error: could not boot up thread\n");
    exit(1);
  }

  sprintf(bootstring, "_boot_proc_%u", boot_id - 1);
  lbl = cmm_find_export(bootstring);

  free(bootstring);
  assert(lbl != NULL);

  /* initialize thread */
  t = init_thread(lbl, s, n);
  *limit_cookie = t->stack_limit;

  /* initialize f and x placeholders in loaded bootstring unit */
  assert(location_known(CMM_label_raddr((CMM_label *) lbl)));
  {
    void **loc = (void **) CMM_label_location((CMM_label *) lbl);

    /* f */
    loc[-2] = (void *) f;

    /* x */
    loc[-1] = (void *) x;
  }

  return (Cmm_Cont *) t;
}

Cmm_Cont *Cmm_RunThread (Cmm_Cont *k) {
  run_interp((thread *) k);

  /* NOTE this function should not return!
   */
  return NULL;
}
@ 

% ----------------------------------------------------------------------------
\subsection{Walking the Stack}
% ----------------------------------------------------------------------------

Walking the stack is very easy, given our representation of activation stacks.
To find the youngest activation, to determine if an activation is the oldest in its thread, and to find the activation of a given activation's caller, we simply perform pointer arithmetic.
This arithmetic, of course, relies on the stacks' direction of growth and general layout (see [[thread.nw]]).

<<stack-walking functions>>=
Cmm_Activation *Cmm_YoungestActivation(const Cmm_Cont *t) {
  assert(t->stack_free > t->stack_base);
  return (Cmm_Activation *) (((activation *) t->stack_free) - 1);
}

int Cmm_isOldestActivation(const Cmm_Activation *a) {
  thread *t = find_thread(a->u);

  return (t->stack_base == a->locals);
}

Cmm_Activation *Cmm_NextActivation(const Cmm_Activation *a) {
  if (Cmm_isOldestActivation(a)) {
    runtime_sys_err("[runtime system] already at oldest activation in thread");
  }

  return (Cmm_Activation *) (((activation *) (a->locals)) - 1);
}

int Cmm_ChangeActivation(Cmm_Activation **a) {
  thread *t = find_thread((*a)->u);

  if (t->stack_base == (*a)->locals)
    return 0;
  else {
    (*a) = ((actptr) ((*a)->locals)) - 1;
    /* LOOK AT THIS!!! */
    /* t->stack_free = (void *) (((actptr) (*a)) + 1); */
    return 1;
  }
}
@ 

<<stack-walking functions>>=
void *Cmm_FindLocalVar(const Cmm_Activation *a, unsigned n) {
  return (void *) (a->locals + n);
}

unsigned Cmm_LocalVarCount(const Cmm_Activation *a) {
  return (unsigned) (a->locals_end - a->locals);
}
@ 

DOCUMENT
\emph{These functions are unimplemented and fail assertions for now.}

<<stack-walking functions>>=
void *Cmm_FindDeadLocalVar(const Cmm_Activation *a, unsigned n) {
  /* will this do the trick? */
  return (void *) (a->locals + n);
}

void *Cmm_FindStackData(const Cmm_Activation *a, unsigned n) {
  assert(0);
  /* IMPLEMENT THIS ! */
  return NULL;
}
@ 

[[Cmm_GetDescriptor]] must look up the given [[token]] in the Lua span table of the given activation's thread; moreover, it must look for the innermost (table entry with greatest index) value associated with the token.
Fortunately, [[span.nw]] exports [[span_find_value]] to take care of the job.

<<stack-walking functions>>=
Cmm_Dataptr Cmm_GetDescriptor(const Cmm_Activation *a, Cmm_Word token) {
  return (Cmm_Dataptr) span_find_value((unsigned) a->pc, (unsigned) token);
}
@ 

\emph{This function is unimplemented and fails an assertion.}

<<stack-walking functions>>=
Cmm_Cont *Cmm_GetUnwindCont(const Cmm_Activation *a, Cmm_Word index) {
  thread *t    = find_thread(a->u);
  lua_State *L; /* = t->span_table.L; */

  /* FIX the definition of L */
  assert(0);

  /* HAVEN'T REDONE THIS STACK REDO */
  /* STACK REDO
  t->callstack_free--;
  */

  if (index != 0) {
    Cmm_Activation *act = ((Cmm_Activation *) a) - 1;
    annotations    *ann = act->kappa;
    CMM_label      *lbl;

    lua_pushtable(L, ann->also_cuts_to);
    lua_rawgeti(L, -1, (int) index);
    if (!lua_isuserdata(L, -1) ||
        lua_tag(L, -1) != lua_CMM_label_tag ||
        (lbl = lua_touserdata(L, -1)) == NULL)
    {
      lua_pop(L, 2); /* pop bogus value, table */
      runtime_sys_err("invalid continuation index given to Cmm_GetCont");
    }

    act->pc = CMM_label_location(lbl);
    lua_pop(L, 2);
  }
 
  /* HAVEN'T REDONE THIS :: STACK REDO
  (t->callstack_free - 1)->kappa = NULL;
  */

  return (Cmm_Cont *) t;
}
@

% ----------------------------------------------------------------------------
\subsection{The Global Registers}
% ----------------------------------------------------------------------------

We have full access to the global variables, so these three functions for accesing the global registers are easy to implement in their present form.

<<global register functions>>=
void *Cmm_FindGlobalVar(void *gp, int n) {
  if (n >= Cmm_GlobalCount() || n < 0)
    runtime_sys_err("globals subscript out of range in Cmm_FindGlobalVar");
  return (void *) (((value *) globals) + n);
}
unsigned Cmm_GlobalCount(void) {
  return (num_globals < 0 ? 0 : (unsigned) num_globals);
}
unsigned Cmm_GlobalSize(void) {
  return Cmm_GlobalCount() * sizeof(value);
}
@

Although the next two functions are not explicitly provided as C functions in the interface to the runtime system, we use them to help export their functionality to {\PAL}.

<<function prototypes>>=
void Cmm_SaveGlobals_helper(unsigned gpu);
void Cmm_RestoreGlobals_helper(unsigned gpu);
@ 

<<global register functions>>= 
void Cmm_SaveGlobals_helper(unsigned gpu) {
  void *gp = (void *) gpu;

  if (num_globals <= 0) return;

  if (gp == NULL)
    runtime_sys_err("SaveGlobals given NULL pointer");
  else
    gp = memcpy(gp, globals, sizeof(value) * num_globals);
}

void Cmm_RestoreGlobals_helper(unsigned gpu) {
  void *gp = (void *) gpu;

  if (num_globals <= 0) return;

  if (gp == NULL)
    runtime_sys_err("RestoreGlobals given NULL pointer");
  else
    globals = memcpy(globals, gp, sizeof(value) * num_globals);
}
@ 

% ----------------------------------------------------------------------------
\subsection{Controlling the Interpreter}
% ----------------------------------------------------------------------------

So we can better control how the runtime system fits in with the interpreter, we wrap the interpreter's [[cmm_interp_open]] and [[cmm_interp_close]] functions.
For one thing, this allows us to register select C functions in the runtime system with the interpreter (to be called from {\PAL}), while keeping the interpreter's implementation otherwise ignorant of the {\PAL} runtime system.

<<controlling the interpreter>>=
int Cmm_open(int valstack_size, int argspace_size) {
  int rc = cmm_interp_open(valstack_size, argspace_size);

  /* register any necessary C functions with C-- */
  register_c_func("SaveGlobals",    (void *) Cmm_SaveGlobals_helper,
                  "unsigned:void");
  register_c_func("RestoreGlobals", (void *) Cmm_RestoreGlobals_helper, 
                  "unsigned:void");

  if (rc != 0) { return rc; }
  
  <<load in the standard basis and store error code in [[rc]]>>

  return rc;
}  
@ 

We use a standard basis mainly to allow some old test code to work fine without
being updated.

<<load in the standard basis and store error code in [[rc]]>>=
  {
    char *standard_basis = "function CMM.c_call(s)   \n"
                           "CMM.push_symbol(s)       \n"
                           "CMM.call({}, {}, {}, 0)  \n"
                           "end                      \n";

    rc = load_assembly_unit(standard_basis, SRC_STRING);
  }
@ 

<<controlling the interpreter>>=
void Cmm_close(void) {
  cmm_interp_close();
}
@ 

% ----------------------------------------------------------------------------
\subsection{Error Handling}
% ----------------------------------------------------------------------------

If an error is encountered in one of the runtime system's functions, a call
is made to private internal helper [[runtime_sys_err]].

<<internal function prototypes>>=
static void runtime_sys_err(char *fmt, ...);
@ 

This function is given an error message's format string and a variable number
of arguments.

Callers of this function should expect it \emph{not} to return.

<<internal helpers>>=
static void runtime_sys_err(char *fmt, ...) {
  va_list args;

  if (fmt != NULL) {
    fprintf(stderr, "error: ");

    va_start(args, fmt);
    vfprintf(stderr, fmt, args);

    fprintf(stderr, "\n");
  }

  fprintf(stderr, "error: C-- runtime system error; cannot continue");
  va_end(args);

  exit(1);
}
@ 
