% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

This document contains the interface and implementation of {\PAL} primitive operators.

% ----------------------------------------------------------------------------
\section{Interface}
% ----------------------------------------------------------------------------

<<operator.h>>=
#ifndef _OPERATOR_H
#define _OPERATOR_H

#include "table.h"
#include "value.h"

<<type definitions>>
<<global variable declarations>>
<<function prototypes>>

#endif /* _OPERATOR_H */
@ 

% ----------------------------------------------------------------------------
\subsection{Global Data Structures}
% ----------------------------------------------------------------------------

The operators are stored in a global Lua table.

<<global variable declarations>>=
extern table operator_table;
@ 

<<global variable definitions>>=
table operator_table;
@ 

% ----------------------------------------------------------------------------
\subsection{Managing Memory for [[operator]]s}
% ----------------------------------------------------------------------------

To abstract away from the details of memory management, this interface
provides a function to create a new [[operator]] and a function that frees
all existing [[operator]]s in memory.

<<function prototypes>>=
operator *operator_new(void);
void      operator_free_all(void);
@ 

Note that [[operator_new]] returns a pointer to an \emph{uninitialized} 
[[operator]].

% ----------------------------------------------------------------------------
\subsection{Generating Operator Definitions}
% ----------------------------------------------------------------------------

Operator definitions are actually generated by a set of macro calls.  [[BINARYOP]], [[UNARYOP]], and [[NULLARYOP]] are macros that generate binary, unary, and nullary operator function definitions, respectively.\\
\\
\begin{tabularx}{\linewidth}{lXX}\hline
Macro Name & Arguments & Argument Descriptions\\
\hline
BINARYOP & \emph{unquoted string literal} [[NAME]] & function name stem \\
         & \emph{expression}              [[EXP]]  & resulting expression, written in terms of variables [[X]] and [[Y]] \\
         & \emph{variable name}           [[X]]    & the name of the first variable (first argument to operator) \\
         & \emph{variable name}           [[Y]]    & the name of the second variable (second argument to operator) \\
         & \emph{C type}                  [[TX]]   & the C type of variable [[X
]] \\
         & \emph{C type}                  [[TY]]   & the C type of variable [[Y]] \\
         & \emph{C type}                  [[T]]    & the C type of the return value \\
         & \emph{{\PAL} type}             [[BX]]   & the {\PAL} type of variable [[X]] \\
         & \emph{{\PAL} type}             [[BY]]   & the {\PAL} type of variable [[Y]] \\
         & \emph{{\PAL} type}             [[B]]    & the {\PAL} type of the return value \\
\hline
UNARYOP  & \emph{unquoted string literal} [[NAME]] & function name stem \\
         & \emph{expression}              [[EXP]]  & resulting expression, written in terms of variable [[X]] \\
         & \emph{variable name}           [[X]]    & the name of the input variable (argument to operator) \\
         & \emph{C type}                  [[TX]]   & the C type of variable [[X
]] \\
         & \emph{C type}                  [[T]]    & the C type of the return value \\
         & \emph{{\PAL} type}             [[BX]]   & the {\PAL} type of variable [[X]] \\
         & \emph{{\PAL} type}             [[B]]    & the {\PAL} type of the return value \\
\hline
NULLARYOP & \emph{unquoted string literal} [[NAME]] & function name stem \\
          & \emph{expression}              [[STMS]] & a list of syntactically valid C statements that need to be evaluated in the function's body \\
          & \emph{variable name}           [[X]]    & the name of the variable used in [[STMS]] and into which the return value is stored \\
          & \emph{C type}                  [[T]]    & the C type of the return value \\
          & \emph{{\PAL} type}             [[B]]    & the {\PAL} type of the return value \\
\hline
\end{tabularx}

These macros are joined by cousins: [[IUNARYOP]] is an imperative form of [[UNARYOP]] that has a [[STMS]] argument instead of its [[EXP]] argument; and [[T_BINARYOP]], [[T_UNARYOP]], and [[T_IUNARYOP]] are versions of the above macros that assume all arguments and the return value share the same C type and {\PAL} type (there are no [[TX]], [[TY]], [[BX]], or [[BY]] arguments to these macros).
Below is a sample use of these macros, showing how the operators [[leu]] (the unsigned $\le$ operator) and [[com]] (the bitwise negation operator) are defined:

<<sample macro calls>>=
BINARYOP(leu, v1 <= v2, v1,v2, u_int16, u_int16, bool, bits16, bits16, bool)
T_UNARYOP(com, ~v1, v1, u_int16, bits16)
@

Additionally, a few other macros help with simplifying the macro calls to construct operators: [[ROTL(T, B)]] and [[ROTR(T, B)]] generate binary operator definitions of left and right bitwise rotation, respectively; and [[POPCNT(T, B)]] generates the unary operator definition of the [[popcnt]] operator (counts the number of 1-bits in a value).

% ----------------------------------------------------------------------------
\subsection{Operator Registration}
% ----------------------------------------------------------------------------

Helping to register C function implementations of {\PAL} operators is helper [[register_operator]].
This helper takes the string description of the operator (as it would be called from {\PAL}), a pointer to the implementing C function, and the number of arguments the operator takes.

<<function prototypes>>=
void register_operator(const char *name, operator_fun f, unsigned num_args,
                       const char *sig);
@

To batch register all default-supported operator instantiations, we provide
[[init_operators]].

<<function prototypes>>=
void init_operators(void);
@ 

% ----------------------------------------------------------------------------
\section{Implementation}
% ----------------------------------------------------------------------------

<<operator.c>>=
#include "operator.h"

#include <stdlib.h>
#include <cii/atom.h>
#include <cii/arena.h>
#include <math.h>
#include "stack.h"
#include "table.h"
#include "types.h"
#include "lualink.h"
#include "interp.h"

<<macro definitions>>
<<operator definitions>>

<<internal static variable definitions>>
<<global variable definitions>>
<<function definitions>>
@

% ----------------------------------------------------------------------------
\subsection{Data Structures}
% ----------------------------------------------------------------------------

\paragraph{Operator Records}

We represent a {\PAL} operator with a [[typedef]]'d [[struct]]: the [[operator]] data type.  However, we actually implement the operators themselves with C functions that take one argument (a value stack pointer) and return a new value stack pointer.

<<type definitions>>=
typedef sptr (*operator_fun)(sptr values);

typedef struct {
  const char   *opname;  /* operator name */
  unsigned     num_args;
  operator_fun f;
} operator;
@

% ----------------------------------------------------------------------------
\subsection{Memory Allocation}
% ----------------------------------------------------------------------------

We make use of Hanson's ``arenas'' (see \emph{C Interfaces and Implementations})
to assist in allocating and de-allocating memory for [[operator]]s.

<<internal static variable definitions>>=
static Arena_T operator_arena = NULL;
@ 

<<function definitions>>=
operator *operator_new(void) {
  operator *op;

  if (operator_arena == NULL) {
    operator_arena = Arena_new();
    mem_assert(operator_arena);
  }

  op = (operator *) Arena_alloc(operator_arena, sizeof(operator), 
                                __FILE__, __LINE__);
  mem_assert(op);
  return op;
}

void operator_free_all(void) {
  if (operator_arena != NULL) {
    Arena_free(operator_arena);
    Arena_dispose(&operator_arena);
    operator_arena = NULL;
  }
}
@ 

% ----------------------------------------------------------------------------
\subsection{Operator Definitions}
% ----------------------------------------------------------------------------

Operators are mostly implemented through macro-generated functions and are instantiated at specific types.

<<operator definitions>>=
  <<floating-point operator definitions>>
  <<integer operator definitions>>
@ 

We use a Lua table represented in C by global variable [[operator_table]] (of type [[table]]) to store associate operator names with the C functions that implement them.

% ----------------------------------------------------------------------------
\subsubsection{Floating-Point Operators}
% ----------------------------------------------------------------------------

We use one macro call per operation to generate the implementations of the IEEE 594 floating-point operations called for in the {\PAL} language specification.
<<floating-point operator definitions>>=
/* FLOAT operators begin here. */
/* fcmp */
/* (floating-pt comparisons?) */
BINARYOP(feq, v1 == v2, v1,v2, float32, float32, bool, float32, float32, bits1)
BINARYOP(fge, v1 >= v2, v1,v2, float32, float32, bool, float32, float32, bits1)
BINARYOP(fgt, v1 >  v2, v1,v2, float32, float32, bool, float32, float32, bits1)
BINARYOP(fle, v1 <= v2, v1,v2, float32, float32, bool, float32, float32, bits1)
BINARYOP(flt, v1 <  v2, v1,v2, float32, float32, bool, float32, float32, bits1)
BINARYOP(fne, v1 != v2, v1,v2, float32, float32, bool, float32, float32, bits1)
/* fordered   */
/* funordered */
/* NaN */
NULLARYOP(round_down,    { v1 = ROUND_DOWN;    }, v1, u_int8, bits8)
NULLARYOP(round_up,      { v1 = ROUND_UP;      }, v1, u_int8, bits8)
NULLARYOP(round_nearest, { v1 = ROUND_NEAREST; }, v1, u_int8, bits8)
NULLARYOP(round_zero,    { v1 = ROUND_ZERO;    }, v1, u_int8, bits8)
/* f2f */
/* f2i */
/* i2f */
/* fadd */
/* fsub */
/* fdiv */
/* fmul */
/* fmulx */
T_UNARYOP(fabs, fabs(v1),  v1, float, float32)
T_UNARYOP(fneg, -(v1),     v1, float, float32)
/* fsqrt */
/* minf  */
/* mzero */
/* pinf  */
/* pzero */
/* FLOAT operators end here. */
@ 

% ----------------------------------------------------------------------------
\subsubsection{Integer Operators}
% ----------------------------------------------------------------------------

As with the floating-point operations, we write one macro call per integer operation specified in the {\PAL} documentation.
<<integer operator definitions>>=
/* INTEGER operators begin here. */
T_BINARYOP(add,     v1 + v2           , v1, v2, s_int16, bits16)
T_BINARYOP(add,     v1 + v2           , v1, v2, s_int32, bits32)
T_BINARYOP(and,     v1 & v2           , v1, v2, u_int16, bits16)
T_BINARYOP(and,     v1 & v2           , v1, v2, u_int32, bits32)
T_UNARYOP (bit,     v1                , v1,     bool   , bits1 )
/* bitExtract  */
/* bitInsert   */
/* bitTransfer */
T_UNARYOP (bool,    v1                , v1,     bool   , bits1 )
/* borrow      */
/* carry       */
T_UNARYOP (com,     ~v1               , v1,     u_int16, bits16)
T_UNARYOP (com,     ~v1               , v1,     u_int32, bits32)
T_BINARYOP(conjoin, (v1 != 0 ? v2 : 0), v1, v2, bool   , bits1 )
T_BINARYOP(disjoin, (v1 != 0 ? 1 : v2), v1, v2, bool   , bits1 )
/* div  */
BINARYOP  (divu,v1 / v2,  v1,v2, u_int16, u_int8, u_int8,bits16, bits8,  bits8)
BINARYOP  (divu,v1 / v2,  v1,v2, u_int32, u_int16,u_int16,bits32,bits16,bits16)
BINARYOP  (eq,  v1 == v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bool )
BINARYOP  (eq,  v1 == v2, v1,v2, u_int32, u_int32,bool , bits32, bits32, bool )
BINARYOP  (ge,  v1 >= v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bool )
BINARYOP  (ge,  v1 >= v2, v1,v2, s_int32, s_int32,bool , bits32, bits32, bool )
BINARYOP  (geu, v1 >= v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bool )
BINARYOP  (geu, v1 >= v2, v1,v2, u_int32, u_int32,bool , bits32, bits32, bool )
BINARYOP  (gt,  v1 >  v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bool )
BINARYOP  (gt,  v1 >  v2, v1,v2, s_int32, s_int32,bool , bits32, bits32, bool )
BINARYOP  (gtu, v1 >  v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bool )
BINARYOP  (gtu, v1 >  v2, v1,v2, u_int32, u_int32,bool , bits32, bits32, bool )
BINARYOP  (le,  v1 <= v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bool )
BINARYOP  (le,  v1 <= v2, v1,v2, s_int32, s_int32,bool , bits32, bits32, bool )
BINARYOP  (leu, v1 <= v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bool )
BINARYOP  (leu, v1 <= v2, v1,v2, u_int32, u_int32,bool , bits32, bits32, bool )
BINARYOP  (lt,  v1 >  v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bool )
BINARYOP  (lt,  v1 >  v2, v1,v2, s_int32, s_int32,bool , bits32, bits32, bool )
/* mod  */
BINARYOP  (modu, v1 % v2, v1,v2, u_int16, u_int8, u_int8, bits16,bits8, bits8 )
BINARYOP  (modu, v1 % v2, v1,v2, u_int32, u_int16,u_int16,bits32,bits16,bits16)
BINARYOP  (modu, v1 % v2, v1,v2, u_int32, u_int32,u_int32,bits32,bits32,bits32)
BINARYOP  (mul,  v1 * v2, v1, v2,s_int8 , s_int8 ,s_int16,bits8 ,bits8 ,bits16)
BINARYOP  (mul,  v1 * v2, v1, v2,s_int16, s_int16,s_int32,bits16,bits16,bits32)
T_BINARYOP(mul_trunc, v1 * v2, v1, v2, u_int16, bits16)
T_BINARYOP(mul_trunc, v1 * v2, v1, v2, u_int32, bits32)
BINARYOP  (mulu, v1 * v2, v1,v2, u_int16, u_int16,u_int32,bits16,bits16,bits32)
BINARYOP  (mulu, v1 * v2, v1,v2, u_int8 , u_int8 ,u_int16,bits8 ,bits8 ,bits16)
BINARYOP  (ne,   v1 !=v2, v1,v2, u_int16, u_int16,bool,   bits16,bits16,bool )
BINARYOP  (ne,   v1 !=v2, v1,v2, u_int32, u_int32,bool,   bits32,bits32,bool )
T_UNARYOP (neg,     -v1               , v1    , s_int16, bits16)
T_UNARYOP (neg,     -v1               , v1    , s_int32, bits32)
T_UNARYOP (not,     !v1               , v1    , bool   , bits1 )
T_BINARYOP(or ,     v1 | v2           , v1, v2, u_int16, bits16)
T_BINARYOP(or ,     v1 | v2           , v1, v2, u_int32, bits32)
POPCNT    (u_int16, bits16)
POPCNT    (u_int32, bits32)
BINARYOP  (quot, v1 / v2, v1,v2, u_int16,u_int8, u_int8, bits16,bits8, bits8 )
BINARYOP  (quot, v1 / v2, v1,v2, u_int32,u_int16,u_int16,bits32,bits16,bits16)
BINARYOP  (rem,  v1 % v2, v1,v2, u_int16,u_int8, u_int8, bits16,bits8, bits8 )
BINARYOP  (rem,  v1 % v2, v1,v2, u_int32,u_int16,u_int16,bits32,bits16,bits16)
ROTL      (u_int16, bits16)
ROTL      (u_int32, bits32)
ROTR      (u_int16, bits16)
ROTR      (u_int32, bits32)
T_BINARYOP(shl ,    v1 << v2          , v1, v2, u_int16, bits16)
T_BINARYOP(shl ,    v1 << v2          , v1, v2, u_int32, bits32)
/* shra   */
T_BINARYOP(shrl,    v1 >> v2          , v1, v2, u_int16, bits16)
T_BINARYOP(shrl,    v1 >> v2          , v1, v2, u_int32, bits32)
T_BINARYOP(sub ,    v1 - v2           , v1, v2, s_int16, bits16)
T_BINARYOP(sub ,    v1 - v2           , v1, v2, s_int32, bits32)
UNARYOP   (sx  ,    (s_int16) v1      , v1, s_int8 , s_int16, bits8 , bits16)
UNARYOP   (sx  ,    (s_int32) v1      , v1, s_int16, s_int32, bits16, bits32)
UNARYOP   (sx  ,    (s_int32) v1      , v1, s_int8 , s_int32, bits8 , bits32)
T_BINARYOP(xor ,    v1 ^ v2           , v1, v2, s_int16, bits16)
T_BINARYOP(xor ,    v1 ^ v2           , v1, v2, s_int32, bits32)
UNARYOP   (zx  ,    (u_int16) v1      , v1, u_int8 , u_int16, bits8 , bits16)
UNARYOP   (zx  ,    (u_int32) v1      , v1, u_int16, u_int32, bits16, bits32)
UNARYOP   (zx  ,    (u_int32) v1      , v1, u_int8 , u_int32, bits8 , bits32)
/* INTEGER operators end here. */
@ 

% ----------------------------------------------------------------------------
\subsection{Operator Registration}
% ----------------------------------------------------------------------------

The main method of registering operators is through the use of helper function [[register_operator]].
This function takes the name of an operator, a pointer to its implementation, and the number of arguments it takes, and creates an [[operator]] structure to represent it.
This [[operator]] is then stored away in the global (Lua) table [[operator_table]].
Note that [[register_operator]] will soundlessly re-register an operator if the same operator name and signature are sent to it more than once.
<<function definitions>>=
void register_operator(const char *name, operator_fun f, unsigned num_args, 
                       const char *sig)
{
  table     op_family = fresh_table();
  lua_State *L        = operator_table.L;
  operator  *op       = operator_new();

  op_family.L  = L;

  op->opname   = Atom_string(name);
  op->f        = f;
  op->num_args = num_args;

  lua_pushtable(L, operator_table);
  lua_pushstring(L, name);
  lua_gettable(L, -2);
  if (!lua_isnumber(L, -1)) {
    lua_pop(L, 1);        /* pop bogus value */
    lua_pushtable(L, op_family);
    lua_pushstring(L, name);
    lua_pushnumber(L, (double) op_family.data);
    lua_settable(L, -4);  /* store ref to op_family in operator_table */
  } else { 
    op_family.data = (unsigned) lua_tonumber(L, -1);
    lua_pop(L, 1);
    lua_pushtable(L, op_family);
  }
  /* op_family is on top, beneath which is operator_table */
  lua_pushstring(L, sig);
  lua_pushusertag(L, (operator *) op, lua_operator_tag);
  lua_settable(L, -3);

  lua_pop(L, 2); /* pop both tables */
}
@ 

To register all operators we have so far, we use [[init_operators]].

<<function definitions>>=
void init_operators(void) {
  <<operator macro redefinition>>
  <<floating-point operator definitions>>
  <<integer operator definitions>>
}
@ 

And now for the hackery that lets us define and register operators with the same piece of code.

<<operator macro redefinition>>=
#undef BINARYOP
#undef UNARYOP
#undef IUNARYOP
#undef NULLARYOP
#undef POPCNT

#define BINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
register_operator(#NAME, op_##NAME##_##BX##_##BY##_##B, 2, #BX "," #BY ":" #B);

#define UNARYOP(NAME, EXP, X, TX, T, BX, B) \
register_operator(#NAME, op_##NAME##_##BX##_##B, 1, #BX ":" #B);

#define IUNARYOP(NAME, STMS, X, TX, T, BX, B) \
register_operator(#NAME, op_##NAME##_##BX##_##B, 1, #BX ":" #B);

#define NULLARYOP(NAME, STMS, X, T, B) \
register_operator(#NAME, op_##NAME##_##B,  0, ":" #B);

#define POPCNT(T, B) \
register_operator("popcnt", op_popcnt_##B, 1, #B ":" #B);
@ 

% ----------------------------------------------------------------------------
\subsection{Operator-Generation Macros}
% ----------------------------------------------------------------------------

An operator implementation function must do the following: take in a pointer to a value stack, pop some number of values off the stack (possibly 0), perform some computations, and push the result value atop the stack.
Most operators fall into three categories: binary operators, unary operators, and nullary operators.
Additionally, binary and unary operators come in two different kinds: those whose arguments and return value share the same type, and those whose arguments and return value differ in type.
We write 5 macros to generate function definitions for members of these categories of operators, as well as a few others for some of the operators that cannot be easily defined with these first macros.
[[BINARYOP]] and [[UNARYOP]] look nearly the same; they generate functions that do underflow checks, perform an expression-based computation with the top two (or one) values on the value stack, and place the result atop the value stack--all the while ensuring that values are interpreted using the correct C and {\PAL} types.
<<macro definitions>>=
#define BINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
\
sptr op_##NAME##_##BX##_##BY##_##B (sptr values) { \
  TY Y;                                      \
  TX X;                                      \
  UNDERFLOW_CHECK(values, 2);                \
  Y = VIEW(STACK_ELT(values,  0).BY, TY);    \
  X = VIEW(STACK_ELT(values, -1).BX, TX);    \
  VIEW(STACK_ELT(values, -1).B, T) = (EXP);  \
  return values-1;                           \
}

#define UNARYOP(NAME, EXP, X, TX, T, BX, B)  \
\
sptr op_##NAME##_##BX##_##B (sptr values) {  \
  TX X;                                      \
  UNDERFLOW_CHECK(values, 1);                \
  X = VIEW(STACK_ELT(values, 0).BX, TX);     \
  VIEW(STACK_ELT(values, 0).B, T) = (EXP);   \
  return values;                             \
}
@ 
[[NULLARYOP]] and [[IUNARYOP]] are similar, but perform the result computation imperatively (allowing for arbitrary code execution of [[STMS]]).
<<macro definitions>>=
#define NULLARYOP(NAME, STMS, X, T, B) \
\
sptr op_##NAME##_##B (sptr values) {       \
  T X;                                     \
  OVERFLOW_CHECK(values, 1);               \
  STMS                                     \
  VIEW(STACK_ELT(values, 1).B, T) = X;     \
  return values + 1;                       \
}

/* IUNARYOP is an imperative form of UNARYOP; destroys value at values */
#define IUNARYOP(NAME, STMS, X, TX, T, BX, B)  \
\
sptr op_##NAME##_##BX##_##B (sptr values) {  \
  TX X;                                      \
  UNDERFLOW_CHECK(values, 1);                \
  X = VIEW(STACK_ELT(values, 0).BX, TX);     \
  STMS;                                      \
  VIEW(STACK_ELT(values, 0).B, T) = X;       \
  return values;                             \
}
@ 
[[T_BINARYOP]], [[T_UNARYOP]], and [[T_IUNARYOP]] are wrapper macros for their cousins; they require fewer type information arguments because they assume that all operator arguments share the same type with the operator return value.
<<macro definitions>>=
#define T_BINARYOP(NAME, EXP, X, Y, T, B)    \
BINARYOP(NAME, EXP, X, Y, T, T, T, B, B, B)

#define T_UNARYOP(NAME, EXP, X, T, B)        \
UNARYOP(NAME, EXP, X, T, T, B, B)

#define T_IUNARYOP(NAME, STMS, X, T, B)  \
IUNARYOP(NAME, STMS, X, T, T, B, B)
@ 
Finally, we write a few extra macros for operators whose return value computations require type-specific information.
By writing these as macros, we make it much easier to instantiate these operators at different types.
<<macro definitions>>=
/* POPCNT generates a function that implements bit-counting;
   T is a C type, B is a C-- type
 */
#define POPCNT(T, B) \
sptr op_popcnt##_##B (sptr values) {       \
  T v, count;                              \
  UNDERFLOW_CHECK(values, 1);              \
  v = VIEW(STACK_ELT(values, 0).B, T);     \
  for ( ; v != 0; v >>= 1)                 \
    count += (v & 1);                      \
  VIEW(STACK_ELT(values, 0).B, T) = count; \
  return values;                           \
}

/* these ROTx macros generate functions to implement bit-rotation;
   T is a C type, B is a C-- type
 */
#define ROTL(T, B) \
T_BINARYOP(rotl, (x @<< d) + (((~(((T) ~0) >> d)) & x) @>> (sizeof(T)*8 - d)),\
                 x, d, T, B)
#define ROTR(T, B) \
T_BINARYOP(rotr, (x >>  d) + (((~(((T) ~0) << d)) & x) << (sizeof(T)*8 - d)),\
                 x, d, T, B)
@ 
