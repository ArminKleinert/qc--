% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

\ifx\nointro\undefined
This document contains the interface and implementation of {\PAL} primitive operators.
\fi

% ----------------------------------------------------------------------------
\interface{{\PAL} Primitive Operators}{
% ----------------------------------------------------------------------------

<<operator.h>>=
#ifndef _OPERATOR_H
#define _OPERATOR_H

#include "table.h"
#include "value.h"

<<type definitions>>
<<global variable declarations>>
<<function prototypes>>

#endif /* _OPERATOR_H */
@ 

% ----------------------------------------------------------------------------
\subsection{Global Data Structures}
% ----------------------------------------------------------------------------

The currently-available operators are stored in a global Lua table.

<<global variable declarations>>=
extern table operator_table;
@ 

<<global variable definitions>>=
table operator_table;
@ 

% ----------------------------------------------------------------------------
\subsection{Managing Memory for [[operator]]s}
% ----------------------------------------------------------------------------

To abstract away from the details of memory management, this interface
provides a function to create a new [[operator]] and a function that frees
all existing [[operator]]s in memory.

<<internal function prototypes>>=
static operator *operator_new(void);
@ 

<<function prototypes>>=
void      operator_free_all(void);
@ 

Note that [[operator_new]] returns a pointer to an \emph{uninitialized} 
[[operator]].

% ----------------------------------------------------------------------------
\subsection{Generating Operator Definitions}
% ----------------------------------------------------------------------------

Operator definitions are actually generated by a set of macro calls.  [[BINARYOP]], [[UNARYOP]], and [[NULLARYOP]] are macros that generate binary, unary, and nullary operator function definitions, respectively.\\
\\
\begin{tabularx}{\linewidth}{lXX}\hline
Macro Name & Arguments & Argument Descriptions\\
\hline
BINARYOP & \emph{unquoted string literal} [[NAME]] & function name stem \\
         & \emph{expression}              [[EXP]]  & resulting expression, written in terms of variables [[X]] and [[Y]] \\
         & \emph{variable name}           [[X]]    & the name of the first variable (first argument to operator) \\
         & \emph{variable name}           [[Y]]    & the name of the second variable (second argument to operator) \\
         & \emph{C type}                  [[TX]]   & the C type of variable [[X
]] \\
         & \emph{C type}                  [[TY]]   & the C type of variable [[Y]] \\
         & \emph{C type}                  [[T]]    & the C type of the return value \\
         & \emph{{\PAL} type}             [[BX]]   & the {\PAL} type of variable [[X]] \\
         & \emph{{\PAL} type}             [[BY]]   & the {\PAL} type of variable [[Y]] \\
         & \emph{{\PAL} type}             [[B]]    & the {\PAL} type of the return value \\
\hline
UNARYOP  & \emph{unquoted string literal} [[NAME]] & function name stem \\
         & \emph{expression}              [[EXP]]  & resulting expression, written in terms of variable [[X]] \\
         & \emph{variable name}           [[X]]    & the name of the input variable (argument to operator) \\
         & \emph{C type}                  [[TX]]   & the C type of variable [[X
]] \\
         & \emph{C type}                  [[T]]    & the C type of the return value \\
         & \emph{{\PAL} type}             [[BX]]   & the {\PAL} type of variable [[X]] \\
         & \emph{{\PAL} type}             [[B]]    & the {\PAL} type of the return value \\
\hline
NULLARYOP & \emph{unquoted string literal} [[NAME]] & function name stem \\
          & \emph{expression}              [[STMS]] & a list of syntactically valid C statements that need to be evaluated in the function's body \\
          & \emph{variable name}           [[X]]    & the name of the variable used in [[STMS]] and into which the return value is stored \\
          & \emph{C type}                  [[T]]    & the C type of the return value \\
          & \emph{{\PAL} type}             [[B]]    & the {\PAL} type of the return value \\
\hline
\end{tabularx}

These macros are joined by cousins.
[[IBINARYOP]] is an imperative form of [[BINARYOP]] that has a [[STMS]] argument instead of its [[EXP]] argument.
[[T_BINARYOP]], [[T_UNARYOP]], and [[T_IBINARYOP]] are versions of the above macros that assume all arguments and the return value share the same C type and {\PAL} type (there are no [[TX]], [[TY]], [[BX]], or [[BY]] arguments to these macros).
Below is a sample use of these macros, showing how the operators [[leu]] (the unsigned $\le$ operator) and [[com]] (the bitwise negation operator) are defined:

<<sample macro calls>>=
BINARYOP(leu, v1 <= v2, v1,v2, u_int16, u_int16, bool, bits16, bits16, bool)
T_UNARYOP(com, ~v1, v1, u_int16, bits16)
@

Additionally, a few other macros help with simplifying the macro calls to construct operators: [[ROTL(T, B)]] and [[ROTR(T, B)]] generate binary operator definitions of left and right bitwise rotation, respectively; and [[POPCNT(T, B)]] generates the unary operator definition of the [[popcnt]] operator (counts the number of 1-bits in a value).

% ----------------------------------------------------------------------------
\subsection{Operator Registration}
% ----------------------------------------------------------------------------

Helping to register C function implementations of {\PAL} operators is helper [[register_operator]].
This helper takes the string description of the operator (as it would be called from {\PAL}), a pointer to the implementing C function, and the number of arguments the operator takes.

<<internal function prototypes>>=
static void register_operator(const char *name,  operator_fun f, 
                              unsigned num_args, const char *sig);
@

To batch register all default-supported operator instantiations, we provide
[[init_operators]].

<<function prototypes>>=
void init_operators(void);
@ 

% ----------------------------------------------------------------------------
}
\implementation {{\PAL} Primitive Operators}{
% ----------------------------------------------------------------------------

<<operator.c>>=
#include "operator.h"

#include <stdlib.h>

#include "c-features.h"
#include "float-features.h"    /* for rounding mode handling */
#include <math.h>

#include "stack.h"
#include "table.h"
#include "types.h"
#include "lualink.h"
#include "interp.h"

#include <cii/atom.h>
#include <cii/arena.h>
#include <cii/mp.h>

<<macro definitions>>
<<operator definitions>>

<<internal static variable definitions>>
<<global variable definitions>>

<<internal function prototypes>>
<<function definitions>>
@

% ----------------------------------------------------------------------------
\subsection{Data Structures}
% ----------------------------------------------------------------------------

\paragraph{Operator Records}

We represent a {\PAL} operator with a [[typedef]]'d [[struct]]: the [[operator]] data type.  However, we actually implement the operators themselves with C functions that take one argument (a value stack pointer) and return a new value stack pointer.

<<type definitions>>=
typedef sptr (*operator_fun)(sptr values);

typedef struct {
  const char   *opname;  /* operator name */
  unsigned     num_args;
  operator_fun f;
} operator;
@

We also define a few types for dealing with floating-point operations.

<<type definitions>>=
typedef enum {
  FLOAT_LT  = 00U,
  FLOAT_EQ  = 01U,
  FLOAT_GT  = 02U,
  UNORDERED = 03U
} float_comparison;
@ 

% ----------------------------------------------------------------------------
\subsection{Memory Allocation}
% ----------------------------------------------------------------------------

We make use of Hanson's ``arenas'' (see \emph{C Interfaces and Implementations})
to assist in allocating and de-allocating memory for [[operator]]s.

<<internal static variable definitions>>=
static Arena_T operator_arena = NULL;
@ 

<<function definitions>>=
static operator *operator_new(void) {
  operator *op;

  if (operator_arena == NULL) {
    operator_arena = Arena_new();
    mem_assert(operator_arena);
  }

  op = (operator *) Arena_alloc(operator_arena, sizeof(operator), 
                                __FILE__, __LINE__);
  mem_assert(op);
  return op;
}

void operator_free_all(void) {
  if (operator_arena != NULL) {
    Arena_free(operator_arena);
    Arena_dispose(&operator_arena);
    operator_arena = NULL;
  }
}
@ 

% ----------------------------------------------------------------------------
\subsection{Operator Definitions}
% ----------------------------------------------------------------------------

Operators are mostly implemented through macro-generated functions and are instantiated at specific types.

<<operator definitions>>=
  <<floating-point operator definitions>>
  <<integer operator definitions>>
@ 

We use a Lua table represented in C by global variable [[operator_table]] (of type [[table]]) to store associate operator names with the C functions that implement them.

% ----------------------------------------------------------------------------
\subsubsection{Floating-Point Operators}
% ----------------------------------------------------------------------------

We use one macro call per operation to generate the implementations of the IEEE 594 floating-point operations called for in the {\PAL} language specification.
<<floating-point operator definitions>>=
/* FLOAT operators begin here. */
NULLARYOP(float_lt , { v1 = FLOAT_LT ; }, v1, u_int8, bits2)
NULLARYOP(float_eq , { v1 = FLOAT_EQ ; }, v1, u_int8, bits2)
NULLARYOP(float_gt , { v1 = FLOAT_GT ; }, v1, u_int8, bits2)
NULLARYOP(unordered, { v1 = UNORDERED; }, v1, u_int8, bits2)
IBINARYOP(fcmp, { if isunordered(v1, v2)    ans = UNORDERED;
                  else if isgreater(v1, v2) ans = FLOAT_GT;
                  else if isless(v1, v2)    ans = FLOAT_LT;
                  else ans = FLOAT_EQ;
                }, v1, v2, ans, float32, float32, bits2,
                                bits2  , bits2  , bits2)
BINARYOP (feq, v1 == v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (fge, v1 >= v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (fgt, v1 >  v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (fle, v1 <= v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (flt, v1 <  v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (fne, v1 != v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (fordered,   !isunordered(v1,v2), v1,v2, float32, float32, bool,
                                                  bits32, bits32, bool) 
BINARYOP (funordered, isunordered(v1, v2), v1,v2, float32, float32, bool,
                                                  bits32, bits32, bool)
/* NaN */
NULLARYOP   (round_down,    { v1 = FE_DOWNWARD;   },  v1, u_int8, bits2)
NULLARYOP   (round_up,      { v1 = FE_UPWARD;     },  v1, u_int8, bits2)
NULLARYOP   (round_nearest, { v1 = FE_TONEAREST;  },  v1, u_int8, bits2)
NULLARYOP   (round_zero,    { v1 = FE_TOWARDZERO; },  v1, u_int8, bits2)
RMUNARYOP   (f2f  , (float64) v1  , v1, float32, float64, bits32, bits64)
RMUNARYOP   (f2f  , (float32) v1  , v1, float64, float32, bits64, bits32)
RMUNARYOP   (f2i  , nearbyintf(v1), v1, float32, s_int32, bits32, bits32)
RMUNARYOP   (f2i  , nearbyint (v1), v1, float64, s_int32, bits64, bits32)
RMUNARYOP   (i2f  , (float32) v1  , v1, s_int32, float32, bits32, bits32)
RMUNARYOP   (i2f  , (float64) v1  , v1, s_int32, float64, bits32, bits64)
T_RMBINARYOP(fadd , v1 + v2       , v1, v2, float32, bits32)
T_RMBINARYOP(fadd , v1 + v2       , v1, v2, float64, bits64)
T_RMBINARYOP(fsub , v1 - v2       , v1, v2, float32, bits32)
T_RMBINARYOP(fsub , v1 - v2       , v1, v2, float64, bits64)
T_RMBINARYOP(fdiv , v1 / v2       , v1, v2, float32, bits32)
T_RMBINARYOP(fdiv , v1 / v2       , v1, v2, float64, bits64)
T_RMBINARYOP(fmul , v1 * v2       , v1, v2, float32, bits32)
T_RMBINARYOP(fmul , v1 * v2       , v1, v2, float64, bits64)
BINARYOP    (fmulx, (float64) v1 * (float64) v2, v1, v2, 
                    float32, float32, float64, bits32, bits32, bits64)
T_UNARYOP   (fabs , (float32) fabs((double) v1) , v1, float32, bits32)
T_UNARYOP   (fneg , -(v1),                        v1, float32, bits32)
T_UNARYOP   (fneg , -(v1),                        v1, float64, bits64)
T_RMUNARYOP (fsqrt, (float32) sqrt((double) v1) , v1, float32, bits32)
/* minf  */
NULLARYOP   (mzero, { v1 = (float32)     -0.0; }, v1, float32, bits32)
NULLARYOP   (pinf , { v1 = (float32) INFINITY; }, v1, float32, bits32)
NULLARYOP   (pzero, { v1 = (float32)      0.0; }, v1, float32, bits32)  
/* FLOAT operators end here. */
@ 

% ----------------------------------------------------------------------------
\subsubsection{Integer Operators}
% ----------------------------------------------------------------------------

As with the floating-point operations, we write one macro call per integer operation specified in the {\PAL} documentation.

<<integer operator definitions>>=
/* INTEGER operators begin here. */
T_BINARYOP(add,     v1 + v2           , v1, v2, s_int16, bits16)
T_BINARYOP(add,     v1 + v2           , v1, v2, s_int32, bits32)
T_BINARYOP(and,     v1 & v2           , v1, v2, u_int16, bits16)
T_BINARYOP(and,     v1 & v2           , v1, v2, u_int32, bits32)
T_UNARYOP (bit,     v1                , v1,     bool   , bits1 )
/* bitExtract  */
/* bitInsert   */
/* bitTransfer */
T_UNARYOP (lobits,  v1                , v1,     u_int32, bits32)
UNARYOP   (lobits,  v1 & 0xff         , v1,     u_int32, u_int8, bits32, bits8)
T_UNARYOP (bool,    v1                , v1,     bool   , bits1 )
/* borrow      */
/* carry       */
T_UNARYOP (com,     ~v1               , v1,     u_int16, bits16)
T_UNARYOP (com,     ~v1               , v1,     u_int32, bits32)
T_BINARYOP(conjoin, (v1 != 0 ? v2 : 0), v1, v2, bool   , bits1 )
T_BINARYOP(disjoin, (v1 != 0 ? 1 : v2), v1, v2, bool   , bits1 )
IBINARYOP (div, { div_t temp = div(v1, v2);
                  ans = (temp.quot < 0 ? temp.quot - (temp.rem > 0)
                                       : temp.quot + (temp.rem > 0));
                },    v1,v2,ans, u_int32, u_int32,u_int32,bits32,bits32,bits32)
BINARYOP  (divu,v1 / v2,  v1,v2, u_int16, u_int16,u_int16,bits16,bits16,bits16)
BINARYOP  (divu,v1 / v2,  v1,v2, u_int32, u_int32,u_int32,bits32,bits32,bits32)
BINARYOP  (eq,  v1 == v2, v1,v2, u_int8 , u_int8 ,bool,  bits2 , bits2 , bool )
BINARYOP  (eq,  v1 == v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bool )
BINARYOP  (eq,  v1 == v2, v1,v2, u_int32, u_int32,bool , bits32, bits32, bool )
BINARYOP  (ge,  v1 >= v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bool )
BINARYOP  (ge,  v1 >= v2, v1,v2, s_int32, s_int32,bool , bits32, bits32, bool )
BINARYOP  (geu, v1 >= v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bool )
BINARYOP  (geu, v1 >= v2, v1,v2, u_int32, u_int32,bool , bits32, bits32, bool )
BINARYOP  (gt,  v1 >  v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bool )
BINARYOP  (gt,  v1 >  v2, v1,v2, s_int32, s_int32,bool , bits32, bits32, bool )
BINARYOP  (gtu, v1 >  v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bool )
BINARYOP  (gtu, v1 >  v2, v1,v2, u_int32, u_int32,bool , bits32, bits32, bool )
BINARYOP  (le,  v1 <= v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bool )
BINARYOP  (le,  v1 <= v2, v1,v2, s_int32, s_int32,bool , bits32, bits32, bool )
BINARYOP  (leu, v1 <= v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bool )
BINARYOP  (leu, v1 <= v2, v1,v2, u_int32, u_int32,bool , bits32, bits32, bool )
BINARYOP  (lt,  v1 <  v2, v1,v2, s_int16, s_int16,bool , bits16, bits16, bool )
BINARYOP  (lt,  v1 <  v2, v1,v2, s_int32, s_int32,bool , bits32, bits32, bool )
BINARYOP  (ltu, v1 <  v2, v1,v2, u_int16, u_int16,bool , bits16, bits16, bool )
BINARYOP  (ltu, v1 <  v2, v1,v2, u_int32, u_int32,bool , bits32, bits32, bool )
IBINARYOP (mod, { div_t temp = div(v1, v2);
                  ans = (temp.quot < 0 ? temp.rem + v2
                                       : temp.rem);
                },    v1,v2,ans, u_int32, u_int32,u_int32,bits32,bits32,bits32)
BINARYOP  (modu, v1 % v2, v1,v2, u_int16, u_int16,u_int16,bits16,bits16,bits16)
BINARYOP  (modu, v1 % v2, v1,v2, u_int32, u_int32,u_int32,bits32,bits32,bits32)
BINARYOP  (mul,  v1 * v2, v1, v2,s_int8 , s_int8 ,s_int16,bits8 ,bits8 ,bits16)
BINARYOP  (mul,  v1 * v2, v1, v2,s_int16, s_int16,s_int32,bits16,bits16,bits32)
T_BINARYOP(mul_trunc, v1 * v2, v1, v2, u_int16, bits16)
T_BINARYOP(mul_trunc, v1 * v2, v1, v2, u_int32, bits32)
BINARYOP  (mulu, v1 * v2, v1,v2, u_int16, u_int16,u_int32,bits16,bits16,bits32)
BINARYOP  (mulu, v1 * v2, v1,v2, u_int8 , u_int8 ,u_int16,bits8 ,bits8 ,bits16)
BINARYOP  (ne,   v1 !=v2, v1,v2, u_int8 , u_int8 ,bool,   bits2 ,bits2 ,bool )
BINARYOP  (ne,   v1 !=v2, v1,v2, u_int16, u_int16,bool,   bits16,bits16,bool )
BINARYOP  (ne,   v1 !=v2, v1,v2, u_int32, u_int32,bool,   bits32,bits32,bool )
T_UNARYOP (neg,     -v1               , v1    , s_int16, bits16)
T_UNARYOP (neg,     -v1               , v1    , s_int32, bits32)
T_UNARYOP (not,     !v1               , v1    , bool   , bits1 )
T_BINARYOP(or ,     v1 | v2           , v1, v2, u_int16, bits16)
T_BINARYOP(or ,     v1 | v2           , v1, v2, u_int32, bits32)
POPCNT    (u_int16, bits16)
POPCNT    (u_int32, bits32)

BINARYOP  (quot, v1 / v2, v1,v2, u_int16,u_int16,u_int16,bits16,bits16,bits16)
BINARYOP  (quot, v1 / v2, v1,v2, u_int32,u_int32,u_int32,bits32,bits32,bits32)
BINARYOP  (rem,  v1 % v2, v1,v2, u_int16,u_int16,u_int16,bits16,bits16,bits16)
BINARYOP  (rem,  v1 % v2, v1,v2, u_int32,u_int32,u_int32,bits32,bits32,bits32)

ROTL      (u_int16, bits16)
ROTL      (u_int32, bits32)
ROTR      (u_int16, bits16)
ROTR      (u_int32, bits32)
@ 

According to the C language definition, right-shifting a signed value [[v1]] 
by [[v2]] number of bits ([[v1 >> v2]]) is non-portable; the result value is
up to the language implementor.
As such, we perform logical right-shifts by viewing our arguments as unsigned
integer in all situations, and arithmetic right-shifts with a few steps of
arithmetic.

<<integer operator definitions>>=
T_BINARYOP(shl ,    v1 << v2          , v1, v2, u_int16, bits16)
T_BINARYOP(shl ,    v1 << v2          , v1, v2, u_int32, bits32)
T_BINARYOP(shra,    v1 / (1 << v2)    , v1, v2, u_int16, bits16)
T_BINARYOP(shra,    v1 / (1 << v2)    , v1, v2, u_int32, bits32)
T_BINARYOP(shrl,    v1 >> v2          , v1, v2, u_int16, bits16)
T_BINARYOP(shrl,    v1 >> v2          , v1, v2, u_int32, bits32)
T_BINARYOP(sub ,    v1 - v2           , v1, v2, s_int16, bits16)
T_BINARYOP(sub ,    v1 - v2           , v1, v2, s_int32, bits32)
UNARYOP   (sx  ,    (s_int16) v1      , v1, s_int8 , s_int16, bits8 , bits16)
UNARYOP   (sx  ,    (s_int32) v1      , v1, s_int8 , s_int32, bits8 , bits32)
UNARYOP   (sx  ,    (s_int32) v1      , v1, s_int16, s_int32, bits16, bits32)
UNARYOP   (sx  ,    (s_int32) v1      , v1, s_int32, s_int32, bits32, bits32)
T_BINARYOP(xor ,    v1 ^ v2           , v1, v2, s_int16, bits16)
T_BINARYOP(xor ,    v1 ^ v2           , v1, v2, s_int32, bits32)
UNARYOP   (zx  ,    (u_int16) v1      , v1, u_int8 , u_int16, bits8 , bits16)
UNARYOP   (zx  ,    (u_int32) v1      , v1, u_int8 , u_int32, bits8 , bits32)
UNARYOP   (zx  ,    (u_int32) v1      , v1, u_int16, u_int32, bits16, bits32)
UNARYOP   (zx  ,    (u_int32) v1      , v1, u_int32, u_int32, bits32, bits32)
/* INTEGER operators end here. */
@ 

% ----------------------------------------------------------------------------
\subsection{Operator Registration}
% ----------------------------------------------------------------------------

The main method of registering operators is through the use of helper function [[register_operator]].
This function takes the name of an operator, a pointer to its implementation, and the number of arguments it takes, and creates an [[operator]] structure to represent it.
This [[operator]] is then stored away in the global (Lua) table [[operator_table]].
Note that [[register_operator]] will soundlessly re-register an operator if the same operator name and signature are sent to it more than once.

<<function definitions>>=
static void register_operator(const char *name,  operator_fun f, 
                              unsigned num_args, const char *sig)
{
  table     op_family = fresh_table();
  lua_State *L        = operator_table.L;
  operator  *op       = operator_new();

  op_family.L  = L;

  op->opname   = Atom_string(name);
  op->f        = f;
  op->num_args = num_args;

  lua_pushtable(L, operator_table);
  lua_pushstring(L, name);
  lua_gettable(L, -2);
  if (!lua_isnumber(L, -1)) {
    lua_pop(L, 1);        /* pop bogus value */
    lua_pushtable(L, op_family);
    lua_pushstring(L, name);
    lua_pushnumber(L, (double) op_family.data);
    lua_settable(L, -4);  /* store ref to op_family in operator_table */
  } else { 
    op_family.data = (unsigned) lua_tonumber(L, -1);
    lua_pop(L, 1);
    lua_pushtable(L, op_family);
  }
  /* op_family is on top, beneath which is operator_table */
  lua_pushstring(L, sig);
  lua_pushusertag(L, (operator *) op, lua_operator_tag);
  lua_settable(L, -3);

  lua_pop(L, 2); /* pop both tables */
}
@ 

To register all operators we have so far, we use [[init_operators]].

<<function definitions>>=
void init_operators(void) {
  <<operator macro redefinition>>
  <<floating-point operator definitions>>
  <<integer operator definitions>>
}
@ 

And now for the hackery that lets us define and register operators with the same piece of code.

<<operator macro redefinition>>=
#undef BINARYOP
#undef RMBINARYOP
#undef UNARYOP
#undef RMUNARYOP
#undef IBINARYOP
#undef NULLARYOP
#undef POPCNT

#define BINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
register_operator(#NAME, op_##NAME##_##BX##_##BY##_##B, 2, #BX "," #BY ":" #B);

#define RMBINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
register_operator(#NAME, op_##NAME##_##BX##_##BY##_bits2_##B, 3, \
                         #BX "," #BY ",bits2:" #B);

#define UNARYOP(NAME, EXP, X, TX, T, BX, B) \
register_operator(#NAME, op_##NAME##_##BX##_##B, 1, #BX ":" #B);

#define RMUNARYOP(NAME, EXP, X, TX, T, BX, B) \
register_operator(#NAME, op_##NAME##_##BX##_bits2_##B, 2, #BX ",bits2:" #B);

#define IBINARYOP(NAME, STMS, X, Y, RES, TX, TY, T, BX, BY, B) \
register_operator(#NAME, op_##NAME##_##BX##_##BY##_##B, 2, #BX "," #BY ":" #B);

#define NULLARYOP(NAME, STMS, X, T, B) \
register_operator(#NAME, op_##NAME##_##B,  0, ":" #B);

#define POPCNT(T, B) \
register_operator("popcnt", op_popcnt_##B, 1, #B ":" #B);
@ 

% ----------------------------------------------------------------------------
\subsection{Operator-Generation Macros}
% ----------------------------------------------------------------------------

An operator implementation function must do the following: take in a pointer to a value stack, pop some number of values off the stack (possibly 0), perform some computations, and push the result value atop the stack.
Most operators fall into three categories: binary operators, unary operators, and nullary operators.
Additionally, binary and unary operators come in two different kinds: those whose arguments and return value share the same type, and those whose arguments and return value differ in type.
We write 5 macros to generate function definitions for members of these categories of operators, as well as a few others for some of the operators that cannot be easily defined with these first macros.
[[BINARYOP]] and [[UNARYOP]] look nearly the same; they generate functions that do underflow checks, perform an expression-based computation with the top two (or one) values on the value stack, and place the result atop the value stack--all the while ensuring that values are interpreted using the correct C and {\PAL} types.
<<macro definitions>>=
#define BINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
\
sptr op_##NAME##_##BX##_##BY##_##B (sptr values) { \
  TY Y;                                      \
  TX X;                                      \
  UNDERFLOW_CHECK(values, 2);                \
  Y = VIEW(STACK_ELT(values,  0).TY, TY);    \
  X = VIEW(STACK_ELT(values, -1).TX, TX);    \
  VIEW(STACK_ELT(values, -1).T, T) = (EXP);  \
  return values-1;                           \
}

#define RMBINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
\
sptr op_##NAME##_##BX##_##BY##_bits2_##B (sptr values) { \
  TY Y;                                      \
  TX X;                                      \
  u_int8 _rmode;                             \
  UNDERFLOW_CHECK(values, 3);                \
  _rmode = VIEW(STACK_ELT(values,  0).bits2, u_int8); \
  Y = VIEW(STACK_ELT(values, -1).TY, TY);    \
  X = VIEW(STACK_ELT(values, -2).TX, TX);    \
  VIEW(STACK_ELT(values, -2).T, T) = (EXP);  \
  return values-2;                           \
}

#define UNARYOP(NAME, EXP, X, TX, T, BX, B)  \
\
sptr op_##NAME##_##BX##_##B (sptr values) {  \
  TX X;                                      \
  UNDERFLOW_CHECK(values, 1);                \
  X = VIEW(STACK_ELT(values, 0).TX, TX);     \
  VIEW(STACK_ELT(values, 0).T, T) = (EXP);   \
  return values;                             \
}

#define RMUNARYOP(NAME, EXP, X, TX, T, BX, B) \
\
sptr op_##NAME##_##BX##_bits2_##B (sptr values) {  \
  TX X;                                      \
  u_int8 _rmode;                             \
  UNDERFLOW_CHECK(values, 2);                \
  _rmode = VIEW(STACK_ELT(values, 0).bits2, u_int8); \
  X = VIEW(STACK_ELT(values, -1).TX, TX);     \
  VIEW(STACK_ELT(values, -1).T, T) = (EXP);   \
  return values-1;                           \
}
@ 
[[NULLARYOP]] and [[IBINARYOP]] are similar, but perform the result computation imperatively (allowing for arbitrary code execution of [[STMS]]).
Note that [[IBINARYOP]] takes an extra argument ([[RES]]) -- the name of the variable into which the operator's result will be placed.
<<macro definitions>>=
#define NULLARYOP(NAME, STMS, X, T, B) \
\
sptr op_##NAME##_##B (sptr values) {       \
  T X;                                     \
  OVERFLOW_CHECK(values, 1);               \
  STMS                                     \
  VIEW(STACK_ELT(values, 1).T, T) = X;     \
  return values + 1;                       \
}

/* IBINARYOP is an imperative form of BINARYOP; destroys value at values */
#define IBINARYOP(NAME, STMS, X, Y, RES, TX, TY, T, BX, BY, B)  \
\
sptr op_##NAME##_##BX##_##BY##_##B (sptr values) { \
  TX X;                                      \
  TY Y;                                      \
  T  RES;                                    \
  UNDERFLOW_CHECK(values, 2);                \
  Y = VIEW(STACK_ELT(values,  0).TY, TY);    \
  X = VIEW(STACK_ELT(values, -1).TX, TX);    \
  STMS;                                      \
  VIEW(STACK_ELT(values, 0).T, T) = RES;     \
  return values;                             \
}
@ 
[[T_BINARYOP]], [[T_UNARYOP]], and [[T_IBINARYOP]] are wrapper macros for their cousins; they require fewer type information arguments because they assume that all operator arguments share the same type with the operator return value.
<<macro definitions>>=
#define T_BINARYOP(NAME, EXP, X, Y, T, B)    \
BINARYOP(NAME, EXP, X, Y, T, T, T, B, B, B)

#define T_RMBINARYOP(NAME, EXP, X, Y, T, B)   \
RMBINARYOP(NAME, EXP, X, Y, T, T, T, B, B, B)

#define T_UNARYOP(NAME, EXP, X, T, B)        \
UNARYOP(NAME, EXP, X, T, T, B, B)

#define T_RMUNARYOP(NAME, EXP, X, T, B)       \
RMUNARYOP(NAME, EXP, X, T, T, B, B)

#define T_IBINARYOP(NAME, STMS, X, Y, RES, T, B)  \
IBINARYOP(NAME, STMS, X, Y, RES, T, T, T, B, B, B)
@ 

Finally, we write a few extra macros for operators whose return value computations require type-specific information.
By writing these as macros, we make it much easier to instantiate these operators at different types.
<<macro definitions>>=
/* POPCNT generates a function that implements bit-counting;
   T is a C type, B is a C-- type
 */
#define POPCNT(T, B) \
sptr op_popcnt##_##B (sptr values) {       \
  T v, count;                              \
  UNDERFLOW_CHECK(values, 1);              \
  v = VIEW(STACK_ELT(values, 0).T, T);     \
  for ( ; v != 0; v >>= 1)                 \
    count += (v & 1);                      \
  VIEW(STACK_ELT(values, 0).T, T) = count; \
  return values;                           \
}

/* these ROTx macros generate functions to implement bit-rotation;
   T is a C type, B is a C-- type
 */
#define ROTL(T, B) \
T_BINARYOP(rotl, (x @<< d) + (((~(((T) ~0) >> d)) & x) @>> (sizeof(T)*8 - d)),\
                 x, d, T, B)
#define ROTR(T, B) \
T_BINARYOP(rotr, (x >>  d) + (((~(((T) ~0) << d)) & x) << (sizeof(T)*8 - d)),\
                 x, d, T, B)
@ 

% ----------------------------------------------------------------------------
}
