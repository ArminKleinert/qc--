% -*- mode: Noweb; noweb-code-mode: sml-mode -*-
\documentclass[letterpaper]{article}
\usepackage{noweb}
\usepackage{amsmath,tabularx,geometry}

\geometry{letterpaper,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}

\title{C-- Interpreter Internals}
\author{Reuben Olinsky}
\date{June 10, 2002}

\pagestyle{empty}

%% beginning of macros

% render a state
% \newcommand\state[6]{\langle #1, #2, #3, #4, #5, #6 \rangle}
\newcommand\dash{\texttt{-}}
\newcommand\state[8]{\langle #1, #2, #3, #4, #5, #6, #7, #8 \rangle}
\newcommand\act[4]{\langle #1, #2, #3, #4 \rangle}

\newcommand\pc{{\mathit{PC}}}   % program counter
\newcommand\ls{{\mathit{ls}}}   % location stack
\newcommand\uid{{\mathit{uid}}} % unique identifier

\newcommand\newpc{\widehat{\pc}}
\newcommand\cmm{\texttt{C-- }}

% give state of data stack as parameter, other components standard
% \newcommand\dstate[1]{\state I \pc {#1} l s A}
\newcommand\dstate{\state \pc V \ls \rho \sigma A u s}
% \newcommand\dstate{\state \pc i V \ls M r A \uid s}
\newcommand\dact{\act \pc \rho \kappa u}

\newcommand\bundle{\langle \kappa_{c}, \kappa_{u}, \kappa_{r}, abort \rangle}

% give state of arg-passing area as parameter, other components standard
%\newcommand\astate[1]{\state i \pc d l s #1}

% for building inference rules
\newcommand{\xfrac}[3][c]{{\displaystyle\genfrac{}{}{0pt}{}{%
  \strut\ifx r#1\hfill\fi#2\ifx l#1\hfill\fi}{#3}}%
  \kern-\nulldelimiterspace}
\def\twoline#1#2{\xfrac{#1}{#2}}
\def\threeline#1#2#3{\xfrac{\xfrac{#1}{#2}}{#3}}
\def\fourline#1#2#3#4{\xfrac{\xfrac{\xfrac{#1}{#2}}{#3}}{#4}}
\def\fiveline#1#2#3#4#5{\xfrac{\xfrac{\xfrac{\xfrac{#1}{#2}}{#3}}{#4}}{#5}}
\def\sixline#1#2#3#4#5#6{\xfrac{\xfrac{\xfrac{\xfrac{\xfrac{#1}{#2}}{#3}}{#4}}{#5}}{#6}}
\def\sevenline#1#2#3#4#5#6#7{\xfrac{\xfrac{\xfrac{\xfrac{\xfrac{\xfrac{#1}{#2}}{#3}}{#4}}{#5}}{#6}}{#7}}
\def\eightline#1#2#3#4#5#6#7#8{\xfrac{\xfrac{\xfrac{\xfrac{\xfrac{\xfrac{\xfrac{#1}{#2}}{#3}}{#4}}{#5}}{#6}}{#7}}{#8}}
\def\nineline#1#2#3#4#5#6#7#8#9{\xfrac{\xfrac{\xfrac{\xfrac{\xfrac{\xfrac{\xfrac{\xfrac{#1}{#2}}{#3}}{#4}}{#5}}{#6}}{#7}}{#8}}{#9}}
\newcommand\twoquad  [2]{{#1}\qquad{#2}}
\newcommand\threequad[1]{{#1}\qquad\twoquad}
\newcommand\fourquad [1]{{#1}\qquad\threequad}
\newcommand\fivequad [1]{{#1}\qquad\fourquad}
\newcommand\sixquad  [1]{{#1}\qquad\fivequad}

\newcommand\cons{\mathbin{::}}

\def\andalso{\qquad}
\def\YIELDS{\Downarrow}
\def\yields{\rightarrow}

% evaluation judgment \step{s1}{s2}
\newcommand\step[2]{#1 \yields #2}

%%% newmacros

\makeatletter
\def\doops[#1]#2#3#4{%
  \global\@namedef{ops-#1}{\showops{#2}{#3}{#4}}\@nameuse{ops-#1}}
\newcommand\ops{\@ifnextchar[{\doops}{\dblops}}
\newcommand\dblops[1]{\doops[#1]{#1}}
\newcommand\useops[1]{%
   \@ifundefined{ops-#1}%
     {\@latex@error{No rule `#1' defined in operational
     semantics}\@opshelp}
     {\@nameuse{ops-#1}}}
\gdef\@opshelp{I never saw a rule by that name.\@ehc}

\makeatother
\newcommand\rulename{\textsc}

\newcommand\showrule[2]{%
    \renewcommand{\theequation}{\mbox{{\rulename{#1}}}}%
                         % dubious \llap hoped to make rules centered...
    \begin{equation}
    #2
    \end{equation}
}
\newcommand\showops[3]{\showrule{#1}{\frac{#2}{#3}}}

%%% end_newmacros

%% end of macros

\begin{document}

\maketitle

\subsection*{Representing State}

\subsubsection*{Type Definitions}

First, some type definitions:

<<type definitions>>=
datatype 'a stack    = STACK of 'a * stack
                     | NIL
type uid             = word * word

datatype value       = BOOLEAN of boolean
                     | BITS    of bit vector

type address         = bit vector      (* width of vector = PTRSIZE *)
datatype location    = REGISTERS of int
                     | DATA_MEMORY of address
                     | PROGRAM_MEMORY of address
type argument        = value

type contAnnotations = (kappa_cut    : location array) * 
                       (kappa_unwind : location array) *
                       (kappa_return : location array) *
                       boolean
datatype space       = REGISTERS
                     | MEMORY
datatype instruction = (* RTL instructions *)
                     | LITERAL      of value
                     | PUSH_SYMBOL  of symbol
                     | FETCH        of size
                     | STORE        of size
                     | FETCH_LOCAL  of int
                     | STORE_LOCAL  of int
                     | PUSH_ARG
                     | POP_ARG
                     | OPERATOR     of operator * size list
                     | LOCATION     of space * size
                     | LITERAL      of value

                       (* CFG instructions *)
                     | GOTO         (* pops target PC off location stack *)
                     | CBRANCH      of label
                     | BRANCH2      of label * label
                     | CMM_CALL     of contAnnotations
                     | C_CALL       of symbol
                     | RETURN       of value list
                     | CUT          (* pops target PC off location stack *)
withtype label       = string
     and symbol      = string
     and size        = int
     and index       = int
     and operator    = int

type register        = word            (* width of word defined in WORDSIZE *)

type memoryCell      = bit vector      (* width of vector = MEMSIZE *)
type memoryPage      = memoryCell array

type memory          = (location * memoryPage) table
type register_set    = register array

type local_env       = value array * (bit vector) array

type activation      = location * local_env * contAnnotations * uid

type machine = location * value stack * location stack * local_env *
               (memory * register_set) * argument stack * uid *
               activation stack
@ 

\subsubsection*{State Representation}

State will be represented by a tuple of the form: $\dstate$, where: \\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}rlX@{}}
$\pc$&:    \texttt{location}& program counter\\
$V$&:      \texttt{value stack}& value data stack\\
$\ls$&:    \texttt{location stack}& location data stack\\
$\rho$&:   \texttt{local\_env}& the current local environment (local variables, local stack data)\\
$\sigma$&: \texttt{memory * register\_set}& the store (\cmm memory and \cmm hardware registers)\\
$A$&:      \texttt{argument stack}& argument-passing area\\
$u$&:      \texttt{uid}& a unique identifier\\
$s$&:      \texttt{activation stack}& the activation stack\\
\end{tabularx}\\
\\
The unique identifiers present in our representation of state will let the \cmm interpreter prevent cuts to dead continuations.  To prepare the \cmm abstract machine for the future possibility of multi-threaded computation we may consider the option of including within our machine multiple activation stacks, each of which represents a separate thread.  Cuts, for example, may occur from an activation on one stack to a continuation on another stack.  To properly ensure cuts may not be taken to dead continuations in a multi-threaded environment, our unique identifier could be implemented with two words: one word to uniquely identify the stack (thread) in which the activation sits, and a second word to uniquely identify where it sits on this stack.

Also note that there is an instruction array present in our state (the program space), but we will not explicitly include it in our tuple because no rules require its modification.  

An activation will be represented by a tuple of the form: $\dact$, where: \\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}rlX@{}}
$\pc$&:    \texttt{location}& program counter for this activation\\
$\rho$&:   \texttt{local\_env}& local environment for this activation (local variables, local stack data)\\
$\kappa$&: \texttt{contAnnotations}& continuation bundle that indicates to which continuations the object of this activation's pending call may cut, unwind, or return; also indicates if same object may be aborted\\
$u$&:   \texttt{uid}& unique identifier for this activation\\
\end{tabularx}\\
\\
A continuation bundle $\kappa$ will be represented by a tuple of the form $\kappa = \bundle$, where:\\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}llX@{}}
$\kappa_{c}$&: \texttt{location array}& array of continuations available through a cut\\
$\kappa_{u}$&: \texttt{location array}& array of continuations available through run-time activation stack unwinding\\
$\kappa_{r}$&: \texttt{location array}& array of continuations available through alternate returns\\
$abort$&:      \texttt{boolean}& whether or not this activation may be aborted\\
\end{tabularx}\\
\\
Elements of the \cmm abstract machine's internal state that are not included in the above tuples: \\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}lX@{}}
instructions to interpret ($i$)& \texttt{instruction array}\\
symbol table to manage labels& \texttt{(string * location) table}\\
symbol table to manage external symbols& \texttt{(string * value) table}\\
\end{tabularx}\\

\subsection*{Instructions}
Here is a list of the RTL instructions available in the abstract \cmm machine:\\*
\\*
\begin{tabularx}{\linewidth}{@{\hskip2em}lX@{}}
\texttt{\#t}& Push true\\
\texttt{\#f}& Push false\\
{\emph{digits}[\texttt:\emph{digits}]}& Push bits\\
\texttt{.}\emph{name}& Push value of external symbol\\
\texttt{fetch-}\emph{size}& Pop location, fetch, push value\\
\texttt{store-}\emph{size}& Pop location, pop value, store\\
\texttt{fetch-local-}\emph{index}& Push value of local variable\\
\texttt{store-local-}\emph{index}& Pop value and store in local variable\\
\texttt{push-arg}& Pop a value from the value stack and push it on the
  argument stack\\
\texttt{pop-arg}& Pop a value from the argument stack and push it on the
  value stack\\
\emph{operator-name}\{\texttt-\emph{size}\}&
  Apply RTL operator to values on stack\\
\texttt{\$}\emph{space}[\texttt{-}\emph{size}]&
  Push location on stack (index taken from value stack).\\
\end{tabularx}\\
\\
Here is a list of the control-flow related instructions available in the abstract \cmm machine:\\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}lX@{}}
\texttt{goto}& pop location, goto it\\
\texttt{cbranch-}\emph{PC}& pop value and branch to \emph{PC} if value is \texttt{\#t}\\
\texttt{branch2-}$\pc_{t}$\dash$\pc_{f}$& pop value \emph{v}; if \emph{v} is \texttt{\#t} then branch to $\pc_{t}$ else if \emph{v} is \texttt{\#f} branch to $\pc_{f}$\\
\texttt{cmm-call-}$\kappa$& pop location $\ell$; call \cmm continuation at $\ell$, asserting call annotations $\kappa$\\
\texttt{c-call-}\emph{symbol}& call C function given by \emph{symbol}\\
\texttt{return}\{\dash\emph{PC}\}& return to continuation \emph{PC} (or default return location if no specified \emph{PC})\\
\texttt{cut}& pop location $\ell$ and cut to continuation at $\ell$\\
\end{tabularx}\\
\\
There will also be a small group of directives for data blocks found within the source code as well as methods of specifying information about the target hardware, etc.:\\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}lX@{}}
\texttt{memsize-}\emph{size}& inform \cmm of the target machine's smallest addressable unit of memory (MEMSIZE)\\
\texttt{ptrsize-}\emph{size}& inform \cmm of the target machine's pointer size (PTRSIZE)\\
\texttt{byte-order-}\emph{option}& inform \cmm of the target machine's byte order (BYTE-ORDER)\\
\texttt{memcell-}\emph{data}& store uninterpreted \emph{data} (of size MEMSIZE) in \cmm memory\\
\texttt{data-}\emph{data}& store uninterpreted \emph{data} (of variable size) in \cmm memory\\
\end{tabularx}\\
\\
And that's it for now.

\subsection*{Operational Semantics}

Below is a sketch of the operational semantics of the legal instructions in the \cmm interpreter \emph{(NOTE: it is far from complete!)}, but first we must wave our hands about some helper functions:\\*
\\*
\begin{tabularx}{\linewidth}{@{\hskip2em}lX@{}}
\texttt{lookup\_symbol}(\emph{name})& lookup the value of symbol \emph{symbol}\\
\texttt{aggregate}(\emph{space, location, size, byte-order})& fetch the (\emph{size} div MEMSIZE) bytes found at \emph{location} in \emph{space} and aggregate them into one value, according to the given byte-order \\
\texttt{store}(\emph{space, location, value, size, byte-order})& split \emph{value} up into multiple pieces of size MEMSIZE and store pieces according to the given byte-order at \emph{location} in \emph{space}\\
\texttt{arity}(\emph{operator-name})& return the arity of operator \emph{operator-name}\\
\texttt{popn}(\emph{stack, n})& pops \emph{n} values off \emph{stack} and returns (list of popped values, stack of remaining values)\\
\texttt{lookup\_label}(\emph{name})& lookup the value (address) of label \emph{label}\\
\texttt{new\_env}(\emph{n})& creates a fresh, empty environment with space for \emph{n} values\\
\texttt{c\_call}(\emph{f})& calls native C function referenced by \emph{f}\\
\end{tabularx}\\
\\
Also, one notational comment: if $\pc$ is the index into the instruction array representing the current instruction, then we write $\newpc$ to mean the index of the immediately next instruction (following along the array linearly).  And now onward to the operational semantics: \\

\ops{Literal}
{i[\pc] = (literal) x}
{\step
  {\dstate}
  {\state \newpc {x\cons{}V} \ls \rho \sigma A u s}
}
\\
\ops{PushSymbol}
{i[\pc] = .name \andalso a = \texttt{lookup\_symbol(}name\texttt{)}}
{\step
  {\dstate}
  {\state \newpc {a\cons{}V} \ls \rho \sigma A u s}
}
\\
\ops{Fetch}
{i[\pc] = \mathtt{fetch-}size \andalso v = \texttt{aggregate(}M,\ell,size,\mathtt{byte-order)}}
{\step
  {\state \pc V {\ell\cons{}\ls} \rho \sigma A u s}
  {\state \newpc {v\cons{}V} \ls \rho \sigma A u s}
}
\\
\ops{Store}
{i[\pc] = \mathtt{store-}size \andalso {\sigma'} = \texttt{store(}\sigma,\ell,v,size,\mathtt{byte-order)}}
{\step
  {\state \pc {v\cons{}V} {\ell\cons{}\ls} \rho \sigma A u s}
  {\state \newpc V \ls \rho {\sigma'} A u s}
}
\\
\ops{Fetch-Local}
{i[\pc] = \mathtt{fetch-local-}x}
{\step
  {\dstate}
  {\state \newpc {\rho[x]\cons{}V} \ls \rho \sigma A u s}
}
\\
\ops{Store-Local}
{i[\pc] = \mathtt{store-local-}x \andalso {\rho'} = \rho\{x\mapsto{}v\}}
{\step
  {\state \pc {v\cons{}V} \ls \rho \sigma A u s}
  {\state \newpc V \ls {\rho'} \sigma A u s}
}
\\
\ops{Push-Arg}
{i[\pc] = \mathtt{push-arg}}
{\step
  {\state \pc {v\cons{}V} \ls \rho \sigma A u s}
  {\state \newpc V \ls \rho \sigma {v\cons{}A} u s}
}
\\
\ops{Pop-Arg}
{i[\pc] = \mathtt{pop-arg}}
{\step
  {\state \pc V \ls \rho \sigma {v\cons{}A} u s}
  {\state \newpc {v\cons{}V} \ls \rho \sigma A u s}
}
\\
\ops{ApplyOp}
{\threeline{i[\pc] = operator{-size} \andalso n = \texttt{arity(}operator\texttt{)}}{(v,V') = \texttt{popn(}V,n\texttt{)}}{v' = operator(v)}}
{\step
  {\dstate}
  {\state \newpc {v\cons{}V'} \ls \rho \sigma A u s}
}
\\
\ops{Location}
{i[\pc] = \mathtt{\$}c}
{\step
  {\state \pc {v\cons{}V} \ls \rho \sigma A u s}
  {\state \newpc V {('c',v)\cons{}\ls} \rho \sigma A u s}
}
\\
And now for the operational semantics of control-flow related instructions: \\

\ops{Goto}
{i[\pc] = \mathtt{goto}}
{\step
  {\state \pc V {\ell\cons\ls} \rho \sigma A u s}
  {\state \ell V \ls \rho \sigma A u s}
}
\\
\ops{CBranchTrue}
{i[\pc] = \mathtt{cbranch-}\pc'}
{\step
  {\state \pc {\mathtt{\#t}\cons{}V} \ls \rho \sigma A u s}
  {\state {\pc'} V \ls \rho \sigma A u s}
}
\\
\ops{CBranchFalse}
{i[\pc] = \mathtt{cbranch-}\pc'}
{\step
  {\state \pc {\mathtt{\#f}\cons{}V} \ls \rho \sigma A u s}
  {\state \newpc V \ls \rho \sigma A u s}
}
\\
\ops{Branch2True}
{i[\pc] = \mathtt{branch2-}\pc_{t}\dash\pc_{f}}
{\step
  {\state \pc {\mathtt{\#t}\cons{}V} \ls \rho \sigma A u s}
  {\state {\pc_{t}} V \ls \rho \sigma A u s}
}
\\
\ops{Branch2False}
{i[\pc] = \mathtt{branch2-}\pc_{t}\dash\pc_{f}}
{\step
  {\state \pc {\mathtt{\#f}\cons{}V} \ls \rho \sigma A u s}
  {\state {\pc_{f}} V \ls \rho \sigma A u s}
}
\\
\ops{CMMCall}
{\fiveline
{i[\pc] = \mathtt{cmm-call-}\kappa}
{V,\ls\textrm{ are empty}}
{P \rightarrow procPC = \pc' \andalso P \rightarrow numLocals = n}
{\rho' = new\_env(n) \andalso u' \textrm{ is a fresh, unique identifier}}
{s' = {\act \pc \rho \kappa u}}
}
{\step
  {\state \pc V {P\cons\ls} \rho \sigma A u s}
  {\state {\pc'} V \ls {\rho'} \sigma A {u'} {s'\cons{}s}}
}
\\
\ops{CCall}
{\fourline
{i[\pc] = \mathtt{c-call-}x}
{f = \texttt{lookup\_symbol(}x\texttt{)}}
{V,\ls\textrm{ are empty}}
{(A',\sigma') = \texttt{c\_call(}f,A,\sigma\texttt{)}}
}
{\step
  {\dstate}
  {\state \newpc V \ls \rho {\sigma'} {A'} u s}
}
\\
\ops{ReturnDefault}
{\threeline
{i[\pc] = \mathtt{return}}
{V,\ls\textrm{ are empty}}
{s = {\act {\pc'} {\rho'} \kappa {u'}}}
}
{\step
  {\state \pc V \ls \rho \sigma A u {s\cons{}S}}
  {\state {\widehat{\pc'}} V \ls {\rho'} \sigma A {u'} S}
}
\\
\ops{ReturnAlt}
{\fiveline
{i[\pc] = \mathtt{return-}x}
{V,\ls\textrm{ are empty}}
{s = {\act {\pc'} {\rho'} \kappa {u'}}}
{\kappa = \bundle}
{\pc'' = \kappa_{r}[x]}
}
{\step
  {\state \pc V \ls \rho \sigma A u {s\cons{}S}}
  {\state {\pc''} V \ls {\rho'} \sigma A {u'} S}
}
\\
\ops{Cut}
{\eightline
{i[\pc] = \mathtt{cut}}
{V,\ls\textrm{ are empty}}
{s = {\act {\pc'} {\rho'} \kappa {u'}}}
{\kappa = \bundle}
{k = {\act {\pc_k} {\rho_k} {\kappa_k} {u_k}}\cons{}S'}
{\pc_k \in \kappa_c}
{k \textrm{ is not dead}}
{\forall \textrm{ activations } a \textrm{ ``above'' } k : a.\kappa.aborts = true}
}
{\step
  {\state \pc V {k\cons{}\ls} \rho \sigma A u {s\cons{}S}}
  {\state {\pc_k} V \ls {\rho_k} \sigma A {u_k} {S'}}
}

\subsection*{Lingering Questions}

What is the state of instructions when it is handed off to the \cmm interpreter.  For example, should the arguments to the \texttt{cbranch} and \texttt{branch2} instructions be labels or locations?  Additionally, should call-site annotations include labels referring to continuations or actual locations of continuations?

Labels may be present within local data chunks (stack-data).  The formalism described in this paper sticks the data within $\rho$, the local environment; so how can labels refer to this data?

\end{document}