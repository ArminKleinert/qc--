% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

\ifx\nointro\undefined
This document contains the interface and implementation of a simple collection of functions for representing lists of integer intervals (sets of natural numbers) in C.
\fi

% ----------------------------------------------------------------------------
\interface{Natural Number Sets}{
% ----------------------------------------------------------------------------

This collection allows a client to efficiently maintain sets of natural
numbers, internally represented as closed intervals on non-negative integers.
Note that this representation of intervals sees the set of intervals
${[3, 7], [8, 10]}$ as identical to ${[3, 10]}$, and does not allow negative
numbers.

Most of the functions contained herein are self-explanatory.
Here is the interface to this collection:

<<function prototypes>>=
interval_list *interval_list_new   (void);
interval_list *interval_list_add   (interval_list *list, unsigned long lower,
                                    unsigned long upper);
interval_list *interval_list_remove(interval_list *list, unsigned long i);
int            interval_list_member(interval_list *list, unsigned long i);
void           interval_list_free  (interval_list *list);
void           interval_list_print (interval_list *list);
void           interval_list_print_file(interval_list *list, FILE *out_file);
@ 

For now, there is no way to remove an interval from the list.
[[interval_list_remove]] only allows a client to remove an individual number
from the list.

Note that [[interval_list_add]] and [[interval_list_remove]] return pointers 
to the new beginning of the lists they were given (which might have changed
during the add or remove operation).

% ----------------------------------------------------------------------------
\subsection{A Sample Client}
% ----------------------------------------------------------------------------

A sample client of this interface might be:

<<sample client>>=
interval_list *i = interval_list_new(); /* creates empty interval list i    */

i = interval_list_add(i, 4, 5);         /* adds the interval [4, 5] to i    */
i = interval_list_add(i, 12, 13);       /* adds the interval [12, 13] to i  */

if (interval_list_member(i, 12))        /* should print out the string      */
     printf("This works!  12 is in i!\n");

interval_list_print(i);                 /* prints the intervals in the list */
interval_list_print_file (i, out_file);  /* prints the intervals in the list
                                           to out_file */
interval_list_free(i);                  /* frees the list                   */
@ 

% ----------------------------------------------------------------------------
}
\implementation {Natural Number Sets}{
% ----------------------------------------------------------------------------

And now for the implementation:

<<intervals.h>>=
#ifndef _INTERVALS_H
#define _INTERVALS_H

#include <stdio.h>

typedef struct interval_list_t {
  unsigned long lower;
  unsigned long upper;

  struct interval_list_t *next;
} interval_list;

<<function prototypes>>

#endif /* _INTERVALS_H */
@ 

And the C code:

<<intervals.c>>=
#include "intervals.h"

#include <stdlib.h>
#include <assert.h>

#define min(X,Y) ((X) < (Y) ? (X) : (Y))
#define max(X,Y) ((X) > (Y) ? (X) : (Y))

/* intervals are specified with inclusive endpoints (i.e., [lower, upper]) */

interval_list *interval_list_new(void) {
  return NULL;
}

interval_list *interval_list_add(interval_list *list, unsigned long lower, 
                                 unsigned long upper)
{
  interval_list *temp,      *last;
  interval_list *free_temp, *free_last;
  interval_list *beg = NULL;
  interval_list *new;

  for (temp = list, last = NULL; temp != NULL; last = temp, temp = temp->next)
  {

    /* If the upper index of the new interval is less than the lower index 
     * of an old interval-1, we want to insert this new interval into the 
     * list */
    if (upper < temp->lower - 1) {

    /* If the lower end of the interval did not overlap with a previous
     * interval, insert it, solo, into the list */
    if (beg == NULL) {
        new = (interval_list *) malloc(sizeof(interval_list));
        assert(new != NULL);
        new->next  = temp;
        new->lower = lower;
        new->upper = upper;
        if (last == NULL)
        return new;
        else {
        last->next = new;
        return list;
        }

        /* Otherwise, it did overlap with a predecesor (beg != NULL) */
    } else {

        /* expand the overlapping intervals to have the largest upper edge*/
        beg->upper = max(upper, last->upper);

        /* Free all the smaller intervals between the start of the overlap 
         * and the current (temp) node */
        for (free_temp = beg->next, free_last = NULL; 
            free_temp != NULL && free_temp != temp;
            free_last = free_temp, free_temp = free_temp->next)
        free(free_last);

        /* fix pointers */
        beg->next  = temp;

        return list;
    }
    }

    /* If the new interval is enveloped be an old interval, we do not pay
     * attention to it; just return the old list */
    if (lower >= temp->lower && upper <= temp->upper)
    return list;


    /* If the new interval overlaps with the current one, keep track of the
     * overlap for the next iteration */
    if ((lower <= temp->lower - 1 || lower <= temp->upper + 1) && beg == NULL)
    {
    beg      = temp;
    beg->lower = min (lower, temp->lower);
    }
  }

  if (beg == NULL) {
      new = (interval_list *) malloc(sizeof(interval_list));
      assert(new != NULL);
      new->next = NULL;
      new->lower = lower;
      new->upper = upper;
      if (last == NULL)
      return new;
      else {
      last->next = new;
      return list;
      }
  } else {
      for (free_temp = beg->next, free_last = NULL; 
          free_temp != NULL && free_temp != temp;
          free_last = free_temp, free_temp = free_temp->next)
      free(free_last);

      beg->next  = NULL;
      beg->upper = max(last->upper, upper);

      return list;
  }
}

interval_list *interval_list_remove(interval_list *list, unsigned long i) {
    interval_list *last, *temp;
    interval_list *new;

    for (temp = list, last = NULL; temp != NULL; last = temp, temp = temp->next)
    {
    if (i == temp->lower && i == temp->upper) {
        if (last == NULL)
        return temp->next;
        last->next = temp->next;
        return list;
    }

    if (i == temp->lower) {
        temp->lower++;
        return list;
    }

    if (i == temp->upper) {
        temp->upper--;
        return list;
    }

    if (i > temp->lower && i < temp->upper) {

        new = (interval_list *) malloc(sizeof(interval_list));
        assert(new != NULL);
        new->next   = temp->next;
        new->lower  = i + 1;
        new->upper  = temp->upper;

        temp->next  = new;
        temp->upper = i - 1;

        if (last == NULL)
          return temp;

        return list;
    }
    }

    return list;
}

int interval_list_member(interval_list *list, unsigned long i) {
    for ( ; list != NULL; list = list->next)
    if (i >= list->lower && i <= list->upper)
        return 1;

    return 0;
}

void interval_list_free(interval_list *list) {
    interval_list *last;

    for (last = NULL; list != NULL; last = list, list = list->next)
    if (last != NULL)
        free(last);

    free(last);
}

void interval_list_print(interval_list *list) {
    interval_list_print_file (list, stdout);
}

void interval_list_print_file (interval_list *list, FILE *out_file) {
    assert(out_file != NULL); 

    for ( ; list != NULL; list = list->next)
    fprintf(out_file, "[%lu, %lu]\n", list->lower, list->upper);
}

@ 

This code has been somewhat substantially tested (i.e., all lines of code
were successfully executed somehow).

% ----------------------------------------------------------------------------
}