% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

This document contains a description of the responsibilities of a client of the Quick~{\PAL} Interpreter.
Additionally, a sample client implementation may be found at the bottom of this document.

% ----------------------------------------------------------------------------
\interface{Interface for clients of the interpreter}
% ----------------------------------------------------------------------------

The Quick~{\PAL} Interpreter is not a standalone application.
Rather, it works in conjunction with a client (a front-end runtime system).
The client must tell the interpreter which files to load as assembly units, which pieces of {\PAL} code to bundle up as ``thread''s, which threads to execute, etc.
A client is responsible for creating the C function named [[main]].
This is where control flow begins for the application; this function should drive the interpreter as it sees fit.

% ----------------------------------------------------------------------------
\subsection{Functions Exported by the Interpreter}
% ----------------------------------------------------------------------------

Below is a list of the functions that the interpreter exports and makes available for client use.

% ----------------------------------------------------------------------------
\paragraph{Initialization}
% ----------------------------------------------------------------------------

To open transactions between the client and the interpreter, the client must call [[Cmm_open]].
This functions expects two arguments, indicating how much memory the interpreter should allocate for the creation of its value stack and argument-passing space, respectively.
If given values of 0, [[Cmm_open]] will choose a non-zero, default size.

<<available exported C functions>>=
int Cmm_open (int valstack_size, int argspace_size);
@ 

To register C functions with the interpreter so that they may be called from {\PAL} code, the interpreter exports function [[register_c_func]].
A signature ([[sig]]) of a C function is a string containing a comma-delimited list of the C types of the function's arguments, followed by a colon and the the function's return type.
An explicit [[void]] should be used in the case of nullary functions.
For example, the signature for a C function that takes two [[int]]s and returns a [[double]] would be [["int,int:double"]].

<<available exported C functions>>=
void register_c_func(const char *name, void *f, const char *sig);
@ 

% ----------------------------------------------------------------------------
\paragraph{Loading Source Code}
% ----------------------------------------------------------------------------

To load a source file (in Lua style) into memory, [[load_assembly_unit]] should be called with the name of the source file (or source string).
Note that code cannot be interpreted until it has been loaded into memory.
[[load_assembly_unit]] returns 0 if and only if [[filename]] was successfully loaded.

<<available exported C functions>>=
int load_assembly_unit (char *s, assembly_unit_type source_type);
@ 

[[source_type]] may either take on the value [[SRC_STRING]], [[SRC_FILE]], or [[SRC_STDIN]] to indicate whether [[s]] is the name of a file, a Lua source string itself, or a reference to [[stdin]].

% ----------------------------------------------------------------------------
\paragraph{Examining Source Code}
% ----------------------------------------------------------------------------

To find the {\PAL} code associated with a certain {\PAL} label (be it a procedure, continuation, or simple code), call on [[cmm_find_export]] with the label in string form.
Note that this function will only find the code for which you are looking if it has been previously loaded into memory using [[load_assembly_unit]], and if the code's assembly unit specified the label as an export (using the [[CMM.exports]] Lua function).

<<available exported C functions>>=
Cmm_Dataptr cmm_find_export (const char *arg);
@ 

For debugging purposes, we also allow clients to disassemble previously loaded code.
[[disassemble_instructions]] prints out a list of the bytecode instructions it finds stored in memory at a given location.
To use this function, first call [[cmm_find_export]] to find the [[Dataptr]] associated with an exported {\PAL} label.

<<available exported C functions>>=
void disassemble_instructions (Cmm_Dataptr loc);
@ 

% ----------------------------------------------------------------------------
\paragraph{Shutdown}
% ----------------------------------------------------------------------------

To shut down the interpreter, [[Cmm_close]] should be called.
This frees all memory the interpreter allocated.

<<available exported C functions>>=
void Cmm_close (void);
@ 

% ----------------------------------------------------------------------------
\subsection{Functions Exported by the Runtime System}
% ----------------------------------------------------------------------------

\emph{For now, look at the {\PAL} manual.}

% ----------------------------------------------------------------------------

\implementation {A Sample Interpreter Client}
% ----------------------------------------------------------------------------

Below is a sample client implentation; it should be useful for demonstration as well as testing.
Its implementation is split across files [[client.h]] and [[client.c]].

<<client.h>>=
#ifndef _CLIENT_H
#define _CLIENT_H

#include <stdarg.h>
#include <stdio.h>
#include "runtime.h"
#include "types.h"

<<constant definitions>>
<<type definitions>>

<<function prototypes>>
#endif /* _CLIENT_H */
@ 

<<client.c>>=
#include "client.h"

#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include "disasm.h"
#include "ccall.h"

<<global variable definitions>>

<<interpreter interaction functions>>
<<utility functions>>
<<application driver>>

<<linker>>
@

% ----------------------------------------------------------------------------
\subsection{Using the Client}
% ----------------------------------------------------------------------------

The interpreter client will present you with a [[>]] prompt.
The following table describes the commands that the interpreter currently understands.\\
\\
\begin{tabularx}{\linewidth}{|l|X|}\hline
[[verbosity]] & turns on extra debugging output
\\\hline
[[stacksize]] $[new_size]$ & gets and optionally sets the current {\PAL} stack size
\\\hline
[[help]] & prints a list of available commands
\\\hline
[[quit]] & quits the interpreter
\\\hline\hline
[[load]] $\{filename\}^{*}$ & loads (assembles into memory) all filenames listed, in the order listed
\\\hline
[[disasm]] $\{label\}^{*}$ & disassembles (to stdout) the program bytecode chunks located at each of the labels listed
\\\hline
[[run]] $label [arg]$ & runs (interprets) the program bytecode chunk (should be a procedure) located at the given label, optionally passing $arg$ to the code as a parameter
\\\hline
\end{tabularx}
Also note that the client takes command line arguments.
Look in the source code or type [[qc--interp --h]] at the command line for information.

% ----------------------------------------------------------------------------
\subsection{Type Definitions}
% ----------------------------------------------------------------------------

To manage threads returned by the {\PAL} runtime system, we use a [[typedef]]'d structure: [[Cmm_TCB]].
A [[Cmm_TCB]] ({\PAL} thread control block) contains the actual thread given us by the {\PAL} runtime system, pointers to the space handed off to the system for use as an activation stack, and a ``cookie'' that points to the limit of the thread's activation stack.
We use this cookie to tell if we've gone off the end of a stack (perhaps by returning or unwinding from the oldest activation on the stack).

<<type definitions>>=
typedef struct {
  Cmm_Cont *cont;

  void     *stack_space;
  unsigned  stack_space_size;

  void     *limit_cookie;
} Cmm_TCB;
@ 

% ----------------------------------------------------------------------------
\subsection{Utility Functions}
% ----------------------------------------------------------------------------

We create a few helper functions to create and destroy [[Cmm_TCB]]s.

<<function prototypes>>=
Cmm_TCB *TCB_new(void);
void     TCB_free(Cmm_TCB *tcb);
@ 

[[TCB_new]] allocates space for the interpreter to use as activation stack space; the space is of size [[stack_space]].

<<utility functions>>=
Cmm_TCB *TCB_new(void) {
  Cmm_Dataptr  data;
  Cmm_TCB     *tcb = (Cmm_TCB *) malloc(sizeof(Cmm_TCB));
  assert(tcb != NULL);

  tcb->stack_space       = (Cmm_Dataptr) malloc(stack_size * sizeof(*data));
  mem_assert(tcb->stack_space);
  tcb->stack_space_size = stack_size;

  return tcb;
}
@ 

[[TCB_free]] frees the space [[TCB_new]] allocated for activation stack space.
Note that it \emph{is} the responsibility of the client to allocate and free
the stack space for a thread.  The interpreter takes care of all other
memory management issues with threads.

<<utility functions>>=
void TCB_free(Cmm_TCB *tcb) {
  free(tcb->stack_space);

  /* FIX make sure that 'cont' is freed? */
  free(tcb);
}
@ 
 
% ----------------------------------------------------------------------------
\subsection{Interpreter Interaction}
% ----------------------------------------------------------------------------

In this client, we register a couple of C functions with the interpreter: 
a simple printing function (that takes a 16 bit [[int]], prints it, and 
returns it) and it 32-bit sibling.

<<function prototypes>>=
u_int16 cmmprint16(u_int16 i);
u_int32 cmmprint32(u_int32 i);
@ 

<<interpreter interaction functions>>=
u_int16 cmmprint16(u_int16 i) {
  printf("[CMMPRINT] %u\n", i);
  return i;
}

u_int32 cmmprint32(u_int32 i) {
  printf("[CMMPRINT] %u\n", i);
  return i;
}
@

To register the functions, the client simply calls [[register_c_func]].
We start with our user-defined C functions.

<<register needed C functions with the interpreter>>=
  register_c_func("cmmprint16", (void *) cmmprint16, "u_int16:u_int16");
  register_c_func("cmmprint32", (void *) cmmprint32, "u_int32:u_int32");
@ 

We then proceed onward to a subset of functions in the C standard library.
Note that [[printf]]'s implementation is somewhat of a hack to get around
the interprer's lack of support for varargs functions.
See [[ccall.nw]] for the details.

<<register needed C functions with the interpreter>>=
  register_c_func("putchar", (void *) putchar, "int:int" );
  register_c_func("printf" , (void *) printf , "printf"  );
  register_c_func("exit"   , (void *) exit   , "int:void");
  register_c_func("getchar", (void *) getchar, "void:int");
  register_c_func("malloc" , (void *) malloc , "unsigned:pointer"       );
  register_c_func("strcpy" , (void *) strcpy , "pointer,pointer:pointer");
  register_c_func("strlen" , (void *) strlen , "pointer:unsigned"       );
  register_c_func("free"   , (void *) free   , "pointer:void");
@ 

% ----------------------------------------------------------------------------
\subsection{Application Driver}
% ----------------------------------------------------------------------------

To drive our sample client application, we have a loop that prompts the user for a command, and acts accordingly--exiting when the user types [[quit]] or an [[EOF]] is sent to the program.

<<constant definitions>>=
#define BUFF_SIZE     256
#define VALSTACK_SIZE 256
#define ARGSPACE_SIZE 256
@

We parameterize activation stack size, and allow the user to modify the size at runtime.
We thus keep [[stack_size]] (as well as a [[verbosity]] flag available globally.

<<global variable definitions>>=
extern int      verbosity;
static unsigned stack_size = 65536;
@ 

The driver opens transactions with the {\PAL} interpreter (passing it sizes for the interpreter's value stack and argument-passing space), registers a few C functions with the interpreter (so they may be called from {\PAL}, loops through user commands, and closes interaction with the interpreter.

<<application driver>>=
int main(int argc, char *argv[]) {
  char        buff[BUFF_SIZE], *c;
  Cmm_Codeptr loc;

  if (Cmm_open(VALSTACK_SIZE, ARGSPACE_SIZE) != 0) {
    exit(1);
  }

  <<register needed C functions with the interpreter>>

  if (argc > 1) {
    <<process command line arguments>>
  } else {
    <<loop and act according to user commands>>
  }

  Cmm_close();
  return 0;
}
@ 

% ----------------------------------------------------------------------------
\subsubsection{Command Line Arguments}
% ----------------------------------------------------------------------------

This client allows a small number of command line arguments.
If any such arguments are given, we do \emph{not} enter the interactive mode defined below (the command loop).
The table below lists and explains the arguments supported.\\
\\
\begin{tabularx}{\linewidth}{|l|X|}\hline
\textbf{Argument}   & \textbf{Description}\\\hline\hline

[[-h]] & lists and explains arguments supported
\\\hline

[[-o ]] $<filename>$ & links files listed on the command line, placing results
in $<filename>$
\\\hline

[[-P]] $<interp_path>$ & specifies path to the interpreter
\\\hline

[[-v]] & turns verbosity ON
\\\hline

[[-]]  & reads in a source file from [[stdin]] and runs its [[main]] procedure
\\\hline

$<filename>$ & reads in source file [[<filename>]]
\end{tabularx}
\\
Note that if any source files are read in using command line arguments, the 
interpreter goes ahead and tries to execute exported {\PAL} procedure [[main]]
after loading all files.

We use POSIX library facility [[getopt]] to ease the work of argument checking.
So the compiler will not complain, we declare the global variables
that [[getopt]] uses (and we need).

<<function prototypes>>=
extern int getopt(int, char **, char *);
@ 

<<global variable definitions>>=
extern char *optarg;
extern int   optind;
extern char  optopt;
extern int   opterr;
@ 

<<process command line arguments>>=
  {
    int   i;
    int   c            = -1;
    int   files_loaded =  0;
    char *link         = NULL;

    char *interp_path  = "/usr/bin/env qc--interp";

    /* process options */
    opterr = 0;
    do {
      c = getopt(argc, argv, "hvo:P:");

      switch (c) {
        case 'h':
          printf("Usage: %s {[--help] | [-] | [<filename>]*}\n", argv[0]);
          printf("Interprets a C-- program as converted into Lua code\n");
          printf("Enters interactive mode unless command line arguments are "
                 "given.\n\n");

          printf("  -h                Display this help screen\n");
          printf("  -o <filename>     Link specified files into <filename>\n");
          printf("  -P <interp_path>  Specifies path to the interpreter\n");
          printf("  -v                Turns verbosity ON\n");
          printf("  -                 Read source file from stdin\n");
          printf("  <filename>*       Read in source files named\n");

          exit(0);

        case 'v':
          verbosity = 1;
          break;

        case 'o':
          if (optarg == NULL) {
            fprintf(stderr,"error: must specify output file with -o option\n");
            exit(1);
          } else if (link != NULL) {
            fprintf(stderr, "error: cannot use -o option twice\n");
            exit(1);
          }
          link   = optarg;
          optarg = NULL;
          break;

        case 'P':
          if (optarg == NULL) {
            fprintf(stderr, "error: must specify interpreter path with -P "
                            "option\n");
            exit(1);
          }
          interp_path = optarg;
          optarg      = NULL;
          break;

        case '?':
          fprintf(stderr, "error: unknown command-line option -%c\n", optopt);
          exit(1);

        case ':':
          fprintf(stderr, "error: missing parameter to option -%c\n", optopt);
          exit(1);

        default:
          break;
      }
    } while (c != -1);

    for (i = optind; i < argc; i++) {
      if (strcmp(argv[i], "-") == 0) {
        if (link == NULL) {
          files_loaded = !load_assembly_unit(NULL, SRC_STDIN) || files_loaded;
        } else {
          fprintf(stderr, "error: linking from stdin not supported\n");
          exit(1);
        }
      } else {
        if (link == NULL) {
          /* assume we're given a filename */
          files_loaded = !load_assembly_unit(argv[i],SRC_FILE) || files_loaded;
        } else {
          /* link the files */
          assert(argv[i] != NULL);
          add_linked_file(link, interp_path, argv[i]);
        }
      }
    }

    if (files_loaded) {
      /* if we're here, then we've loaded in files; let's run them now */
      loc = cmm_find_export("main");
      if (loc == NULL) {
        fprintf(stderr, "error: cannot find procedure \"main\"\n");
      } else {
        int *arg_int_p = NULL;
        <<run code at address [[loc]] with possible arg [[arg_int_p]]>>
      }
    } else {
      /* close off linking output */
      add_linked_file(link, interp_path, NULL);
    }
  }
@ 

% ----------------------------------------------------------------------------
\subsubsection{The Command Loop}
% ----------------------------------------------------------------------------

We loop: read characters in from [[stdin]] into a buffer until we reach a newline character or an [[EOF]].
We then tokenize the line read in and act appropriately.

<<loop and act according to user commands>>=
  printf("Quick C-- Interpreter\n");
  for ( ;; ) {
    char *command, *arg;

    printf("> ");

    c = buff;
    do {
      *(c++) = (char) getchar();
    } while (c[-1] != EOF && c[-1] != '\n' && c[-1] != '\r' && c[-1] != ';');

    if (buff[0] == EOF) break;    
    if (c == buff + 1)  continue;
    c[-1] = '\0';

    command = strtok(buff, " ");

    <<process [[command]]>>
  }
@ 

We process [[command]] with an [[if]] statement.
We compare strings in a case-sensitive manner.
Special commands [[verbosity]] and [[stacksize]] allow the user to slightly alter the behavior of the interpreter.

<<process [[command]]>>=

    if        (strcmp(command, "help") == 0) {
      printf("legal commands: ");
      printf("{ load {filename}*, disasm {label}*, run {label}*, verbosity, stacksize, quit }\n");
    } else if (strcmp(command, "load") == 0) {
      while ((arg = strtok(NULL, " ")) != NULL) {
        <<load file [[arg]] as an assembly unit>>
      }
    } else if (strcmp(command, "disasm") == 0) {
      while ((arg = strtok(NULL, " ")) != NULL) {
        <<[[loc]] $\leftarrow$ address of label [[arg]]>>
        <<disassemble code at label [[arg]] (address [[loc]])>>
      }
    } else if (strcmp(command, "run") == 0) {
      arg = strtok(NULL, " ");
      if (arg != NULL) {
        char *arg_str;
        int   arg_int;
        int  *arg_int_p = NULL;

        for (;;) {
          <<[[loc]] $\leftarrow$ address of label [[arg]]>>
          arg_str = strtok(NULL, " ");
          if (arg_str != NULL) {
            sscanf(arg_str, "%d", &arg_int);
            arg_int_p = &arg_int;
          }
          <<run code at address [[loc]] with possible arg [[arg_int_p]]>>
          break;
        }
      } else {
          printf("nothing to run!\n");
      }
    } else if (strcmp(command, "verbosity") == 0) {
      verbosity = !verbosity;
      printf("verbosity is %s\n", (verbosity ? "ON" : "OFF"));
    } else if (strcmp(command, "stacksize") == 0) {
      if ((arg = strtok(NULL, " ")) != NULL) {
        int i = atoi(arg);
        if (i <= 32)
          printf("invalid stacksize specification\n");
        else
          stack_size = (unsigned) i;
      }
      printf("stacksize is now %u\n", stack_size);
    } else if (strcmp(command, "quit") == 0) {
      break;
    } else
      printf("invalid command, please try again\n");
@

% ----------------------------------------------------------------------------
\paragraph{Loading an Assembly Unit}
% ----------------------------------------------------------------------------

To load a given assembly file, we call on [[load_assembly_unit]].
<<load file [[arg]] as an assembly unit>>=
  load_assembly_unit(arg, SRC_FILE);
@

% ----------------------------------------------------------------------------
\paragraph{Finding Labels and Procedures}
% ----------------------------------------------------------------------------

To find a label, we call on [[cmm_find_export]].
<<[[loc]] $\leftarrow$ address of label [[arg]]>>=
{
  loc = cmm_find_export(arg);
  if (loc == NULL) {
    fprintf(stderr, "error: cannot find specified exported C-- label: %s\n", 
                    arg);
    break;
  }
}
@ 

% ----------------------------------------------------------------------------
\paragraph{Disassembling Bytecode}
% ----------------------------------------------------------------------------

Disassembling the bytecode for a sequence of instructions should yield the instructions originally encoded.
For now [[disassemble_instructions]] sends all output to [[stdout]].
<<disassemble code at label [[arg]] (address [[loc]])>>=
  /* disassemble instructions */
  printf("BEGIN LABEL \"%s\" (<address %x>)\n\n", arg, (unsigned) loc);
  disassemble_instructions(loc);
  printf("\n[END CODE]\n");
@

% ----------------------------------------------------------------------------
\paragraph{Interpreting the Bytecode}
% ----------------------------------------------------------------------------

The runtime system takes care of bytecode interpreting, as long as it is passed off a location or thread at which to start.

<<run code at address [[loc]] with possible arg [[arg_int_p]]>>=
  {
  Cmm_TCB     *tcb = TCB_new();

  <<[[tcb]] $\leftarrow$ thread to execute program at [[loc]]>>
  <<run continuation in [[tcb]]>>

  TCB_free(tcb);
  }
@ 

Creating and running a {\PAL} thread with a continuation to execute the code at [[loc]] is as easy as calling runtime library functions [[Cmm_CreateThread]] and [[Cmm_RunThread]] (see [[runtime.nw]] for more information). 

<<[[tcb]] $\leftarrow$ thread to execute program at [[loc]]>>=
  tcb->cont = Cmm_CreateThread(loc, (void *) arg_int_p, tcb->stack_space, 
                               tcb->stack_space_size, &(tcb->limit_cookie));
@
<<run continuation in [[tcb]]>>=
  tcb->cont = Cmm_RunThread(tcb->cont);
@

% ----------------------------------------------------------------------------
\subsection{Linking}
% ----------------------------------------------------------------------------

Linking multiple Lua files is not too difficult.  Perhaps it shouldn't take 
place here in [[client.nw]], but here it is for now.

<<function prototypes>>=
void add_linked_file(char *out_file, char *interp_path, char *in_file);
@ 

<<linker>>=
void add_linked_file(char *out_file, char *interp_path, char *in_file) {
  static FILE *output_stream = NULL;
  
  FILE *input_stream;
  char  c;

  /* close off I/O */
  if (in_file == NULL) {
    if (output_stream == NULL) return;
    fflush(output_stream);
    fclose(output_stream);

    { int rc = chmod(out_file, S_IXUSR | S_IRUSR | S_IWUSR |
                               S_IXGRP | S_IRGRP |
                               S_IXOTH | S_IROTH            );
      if (rc != 0) {
        fprintf(stderr, "error: output file error\n");
        exit(1);
      }
    }
    return;
  }

  /* initialize output FILE descriptor */
  if (output_stream == NULL) {
    output_stream = fopen(out_file, "w");

    fprintf(output_stream, "#!%s", interp_path);
    fprintf(output_stream, "\n");
  }

  /* open input file */
  input_stream = fopen(in_file, "r");
  for (;;) {
    c = getc(input_stream);
    if (c == EOF) break;
    putc(c, output_stream);
  }
  fclose(input_stream);

  fprintf(output_stream, "\n");
  fprintf(output_stream, "CMM.new_assembly_unit()");
  fprintf(output_stream, "\n");
}
@ 

% ----------------------------------------------------------------------------
