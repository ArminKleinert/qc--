% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

This document contains the interface and implementation of {\PAL} threads.

% ----------------------------------------------------------------------------
\interface{{\PAL} Threads of Execution}{
% ----------------------------------------------------------------------------

<<thread.h>>=
#ifndef _THREAD_H
#define _THREAD_H

#include "intervals.h"
#include "label.h"
#include "types.h"
#include "uid.h"

<<type definitions>>
<<function prototypes>>

#endif /* _THREAD_H */
@ 

% ----------------------------------------------------------------------------
\subsection{Data Structures}
% ----------------------------------------------------------------------------

A {\PAL} thread may simply be realized as a separate activation stack.  

For matters of $uid$ bookkeeping, we need to keep track of the next frame id to be handed out to a fresh activation as well as a list of dead frame id's.  
We use an [[interval_list]] to represent this list (see [[intervals.nw]]).  

We maintain one stack internal to a thread; it is from this that we allocate
space for [[activation]]s, local variables, and stackdata.
Please see the section below on stack layout for more information about this stack.

Additionally, we include a program counter in the [[thread]] structure.
The idea of this is that, in the runtime system, we might want to get some
sort of ``handle'' on a resumption point of the youngest activation without
yet changing the [[pc]] stored in this activation's actual [[activation]]
record.

<<type definitions>>=
typedef struct {
  unsigned int   next_frame_id;

  void          *stack_base;
  void          *stack_limit;
  void          *stack_free;

  interval_list *dead_list;

  bytecodeptr    pc;
} thread;
@ 

% ----------------------------------------------------------------------------
\subsection{Stack Layout}
% ----------------------------------------------------------------------------

Stackdata, locals, and activation information are all stored on a thread's one
stack.

\begin{verbatim}

 The stack in a sample non-suspended thread:

   |----------|<--- t->stack_base
   |          |
   | locals_0 |
   |__________|
   |          |     
   | stackd_0 |
   |__________|
   |          |
   |  act_0   | frame # 0 (oldest frame)
___|__________|_____________
   |          |
   | locals_1 | frame # 1 (youngest frame)
   |__________|
   |          |
   | stackd_0 |
   |          |
---|----------|<--- t->stack_free
   |          |
   |          | free space on stack


   |          |
   |----------|<--- t->stack_limit
   
\end{verbatim}

This is a diagram of a sample non-suspended thread's stack.  The top of the
drawing represents the oldest end of the stack; growth is drawn toward the
bottom.  (In our implementation, growth is directed toward increasing
addresses.)
  When creating space for a new frame on the stack, we create space for locals,
then we create space for stackdata.  The activation record for a currently-
running frame is not actually stored away on the stack until we must leave
the frame for some reason (cut/call/etc.).  Until then, the activation record
for the currently running frame is actually distributed across local C
variables (in function [[run_interp]] of [[interp.nw]]).
  When we must leave a frame or suspend a frame's thread (in order to return 
control to the runtime system or to cut to another thread), we write the
thread's youngest frame's activation record to the stack's extremum--just
beyond the youngest frame's stackdata space (at [[t->stack_free]]).
  If we simply made a {\PAL} call, we also create space for the new activation 
frame's locals and stackdata, and continue onwards.


All activations are of fixed size ([[sizeof(activation)]]). 
Locals and stackdata space vary in size, depending on a specific activation's needs.

Finally, a word on suspended threads.
A suspended thread is essentially one that is not presently running through
the interpreter; in such a thread, the youngest activation \emph{is} present
atop the thread's stack--but it is distinguishable from an ordinary activation.
Such a ``suspended activation'' has a [[NULL]] $\kappa$ field (its call-site 
annotations) as well as a [[NULL]] [[callee]] field.

A suspended activation might be found as the first initialized activation of a
brand-new thread, as the youngest activation of a thread that had been
running and then cut over to another thread, or as the youngest activation of
a thread that transferred control to a C function or the runtime system.

% ----------------------------------------------------------------------------
\subsection{Utility Functions}
% ----------------------------------------------------------------------------

Helper functions [[init_thread]] and [[find_thread]] assist in thread management.
[[init_thread]] initializes the data members of a [[thread]] object, given a sufficient amount of pre-allocated stack space (this means that it is the
front-end's responsibility to allocate stack space when it asks for a new 
thread).
[[find_thread]] returns the thread uniquely identified by some [[uid]].

<<function prototypes>>=
thread *init_thread(CMM_label *lbl, void *stack_space, unsigned n);
thread *find_thread(uid u);
@

% ----------------------------------------------------------------------------
}
\section{Implementation: {\PAL} Threads of Execution}{
% ----------------------------------------------------------------------------

<<thread.c>>=
#include "thread.h"

#include <stdlib.h>
#include "interp.h"
#include "value.h"
#include "activation.h"
#include "table.h"

<<function definitions>>
@

% ----------------------------------------------------------------------------
\subsection{Thread Initialization}
% ----------------------------------------------------------------------------

It takes a bit of work to initialize a new thread.

Given sufficient space in memory, we set up a stack for storing locals,
stackdata, and activations.
See the section above on stack layout for more information about how exactly
we allocate memory on the stack.

We have to remember to initialize the [[thread]]'s fields, as well as set
up the thread's first activation--in suspended state, of course.

<<function definitions>>=
thread *init_thread(CMM_label *lbl, void *stack_space, unsigned n) {
  void   *stack_limit = (void *) (((u_int8 *) stack_space) + n);

  thread *t = (thread *) malloc(sizeof(thread));
  mem_assert(t);

  t->next_frame_id = 0;
  
  t->stack_base  = round_up(stack_space);  /* align to hardware requirements */
  t->stack_limit = stack_limit;
  t->stack_free  = t->stack_base;

  t->dead_list   = interval_list_new();

  <<set up first activation record>>

  t->pc          = CMM_label_location(lbl);

  return t;
}
@

When we initialize a thread, we start it off with an activation in a suspended state.
The only difference between this suspended activation and a normal activation is that its [[kappa]] field (as well as its [[callee]] field) is left [[NULL]], for it was not called by any other activation.

<<set up first activation record>>= 
  assert(lbl != NULL);
  assert(lbl->ty == CMM_PROCEDURE);
  assert(lbl->lbl.proc != NULL);
  {
    /* locals, then stackdata (and then activation) */

    actptr      act;
    stack       locals;
    sptr        locals_end;
    datastack   stackdata;
    dataptr     stackdata_end;

    procedure  *start = lbl->lbl.proc;
    assert(location_known(start->raddr));

    <<allocate local memory for activation of procedure [[start]]>>

    act                = (actptr) t->stack_free;
    t->stack_free      = round_up((void *) (((actptr) (t->stack_free)) + 1));
    assert(t->stack_free <= t->stack_limit);

    act->locals        = locals;
    act->locals_end    = locals_end;
    act->stackdata     = stackdata;
    act->stackdata_end = stackdata_end;

    act->pc            = (bytecodeptr) location(start->raddr);
    act->u             = new_uid(t);

    /* leave kappa and callee NULL to indicate this is the end of a thread */
    act->kappa         = NULL;
    act->callee        = NULL;
    act->caller        = NULL;
  }
@ 

Finally, we must allocate space for the local environment of the first activation to be run (the activation for procedure [[start]]).
This memory is taken off the thread [[t]]'s stack, in accordance with our
stack layout convention.

<<allocate local memory for activation of procedure [[start]]>>=
  /* we allocate locals-space and stackdata-space for the first activation */
  locals             = t->stack_free;
  t->stack_free      = (void *) (((sptr) (t->stack_free)) + 
                                 start->num_locals);
  locals_end         = t->stack_free;

  stackdata          = t->stack_free;
  t->stack_free      = round_up((void *) (((dataptr) (t->stack_free)) +
										  start->stackdata_size));
  stackdata_end      = t->stack_free;
@

% ----------------------------------------------------------------------------
\subsection{Helper Functions}
% ----------------------------------------------------------------------------

Recall that the thread id of a given [[uid]] is actually a [[void *]] pointer to the thread to which the activation uniquely identified by the [[uid]] belongs.
As such, it is rather easy to find a thread given a [[uid]].

<<function definitions>>=
thread *find_thread(uid u) {
  return (thread *) u.thread;
}
@ 

% ----------------------------------------------------------------------------
}