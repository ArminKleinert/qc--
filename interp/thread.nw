% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

\ifx\nointro\undefined
This document contains the interface and implementation of {\PAL} threads.
\fi

% ----------------------------------------------------------------------------
\interface{[[thread]] : {\PAL} Threads of Execution}
% ----------------------------------------------------------------------------

<<thread.h>>=
#ifndef _THREAD_H
#define _THREAD_H

#include "intervals.h"
#include "label.h"
#include "types.h"
#include "uid.h"

<<type definitions>>
<<function prototypes>>

#endif /* _THREAD_H */
@ 

% ----------------------------------------------------------------------------
\subsection{Data Structures}
% ----------------------------------------------------------------------------

A {\PAL} thread may simply be realized as a separate activation stack.  

For matters of $uid$ bookkeeping, we need to keep track of the next frame id
to be handed out to a fresh activation, as well as a list of dead frame id's.  
We use an [[interval_list]] to represent this list (see [[intervals.nw]]).  

We maintain one stack internal to a thread; it is from this that we allocate
space for [[activation]]s, local variables, and stackdata.
The allocation of this stack is the responsibility of the front-end runtime
client of the interpreter, not the [[thread]] module itself.
Please see the section below on stack layout for more information about this
stack.

Additionally, we include a program counter in the [[thread]] structure.
The idea of this is, in the runtime system, we might want to get some
sort of ``handle'' on a resumption point of the youngest activation without
yet changing the [[pc]] stored in this activation's actual [[activation]]
record.

<<type definitions>>=
struct thread {
  unsigned int   next_frame_id;

  void          *stack_base;
  void          *stack_limit;
  void          *stack_free;

  interval_list *dead_list;

  bytecodeptr    pc;
};

typedef struct thread thread;
@ 

% ----------------------------------------------------------------------------
\subsection{Stack Layout}
% ----------------------------------------------------------------------------

Stackdata, locals, and activation information are all stored on a thread's
single stack.

\begin{verbatim}

 A diagram of the stack in a sample, non-suspended thread:

   |----------|<--- t->stack_base
   |          |
   | actptr_0 |
   |----------|
   |          |
   | stackd_0 |
   |__________|
   |          |     
   | locals_0 |
   |__________|
   |          |
   |  act_0   | frame # 0 (oldest frame)
___|__________|_____________
   |          |
   | actptr_1 |
   |----------|
   |          |
   | stackd_1 | frame # 1 (youngest frame)
   |__________|
   |          |
   | locals_1 |
   |          |
---|----------|<--- t->stack_free
   |          |
   |          | free space on stack


   |          |
   |----------|<--- t->stack_limit
   
\end{verbatim}

This is a diagram of a sample non-suspended thread's stack.  The top of the
drawing represents the oldest end of the stack; growth is drawn toward the
bottom.  (In our implementation, growth is directed toward increasing
addresses.)
  When creating space for a new frame on the stack, we first carve out space
for stackdata, and then we allocate space for locals.  The activation record 
for a currently-running frame is not actually stored away on the stack until
we must leave the frame for some reason (cut/call/etc.).  Until then, the
activation record for the currently running frame is distributed across local C
variables (in function [[run_interp]] of the [[interp]] module).
  When we must leave a frame or suspend a frame's thread (in order to return 
control to the runtime system or to cut to another thread), we write the
activation record for the thread's youngest frame at the stack's extremum--just
beyond the this frame's stackdata space (at [[t->stack_free]]).
  If we left the frame to make a {\PAL} call, then we create space for the
stackdata and locals of the callee's activation, and continue execution.
When we resume the execution of a suspended thread, we pop the activation
record of the suspended frame off the stack and resume execution.

Note that all activations are of fixed size ([[sizeof(activation)]]). 
Stackdata and locals space vary in size, depending on a specific activation's 
needs (and on the memory alignment requirements of the host's architecture).

Finally, a few more words on suspended threads.
A suspended thread is essentially one that is not presently running through
the interpreter; in such a thread, the youngest activation \emph{is} present
atop the thread's stack--but it is distinguishable from an ordinary activation.
Such a ``suspended activation'' has a [[NULL]] $\kappa$ field (its call-site 
annotations) as well as a [[NULL]] [[callee]] field.

A suspended activation might be found as the first initialized activation of a
brand-new thread, as the youngest activation of a thread that had been
running and then cut over to another thread, or as the youngest activation of
a thread that transferred control to a C function or the runtime system.

% ----------------------------------------------------------------------------
\subsection{Utility Functions}
% ----------------------------------------------------------------------------

Helper functions [[init_thread]] and [[find_thread]] assist in thread 
management.

[[init_thread]] initializes the data members of a [[thread]] object, given a 
sufficient amount of pre-allocated stack space (this means that it is the
front-end's responsibility to allocate stack space when it asks for a new 
thread).
[[find_thread]] returns the thread uniquely identified by some [[uid]].

<<function prototypes>>=
thread *init_thread(CMM_label *lbl, void *stack_space, unsigned n);
thread *find_thread(uid u);
@

% ----------------------------------------------------------------------------
\implementation{{\PAL} Threads of Execution}
% ----------------------------------------------------------------------------

<<thread.c>>=
#include "thread.h"

#include <stdlib.h>
#include "interp.h"
#include "value.h"
#include "activation.h"
#include "table.h"

<<function definitions>>
@

% ----------------------------------------------------------------------------
\subsection{Thread Initialization}
% ----------------------------------------------------------------------------

It takes a bit of work to initialize a new thread.

Given sufficient space in memory, we set up a stack for storing stackdata,
locals, and activations.
See the section above on stack layout for more information on how exactly
we allocate memory on the stack.

We have to remember to initialize the [[thread]]'s fields, as well as set
up the thread's first activation--in suspended state, of course.

<<function definitions>>=
thread *init_thread(CMM_label *lbl, void *stack_space, unsigned n) {
  void   *stack_limit = (void *) (((u_int8 *) stack_space) + n);

  thread *t = (thread *) malloc(sizeof(thread));
  mem_assert(t);

  t->next_frame_id = 0;
  
  t->stack_base  = round_up(stack_space);  /* align to hardware requirements */
  t->stack_limit = stack_limit;
  t->stack_free  = t->stack_base;

  t->dead_list   = interval_list_new();

  <<set up first activation record>>

  t->pc          = CMM_label_location(lbl);

  return t;
}
@

When we initialize a thread, we start it off with an activation in a
suspended state.
The only difference between this suspended activation and a normal activation
is that its [[kappa]] field (as well as its [[callee]] field) is left [[NULL]],
for it was not called by any other activation.

<<set up first activation record>>= 
  assert(lbl != NULL);
  assert(lbl->ty == CMM_PROCEDURE);
  assert(lbl->lbl.proc != NULL);
  {
    /* actptr, stackdata, then locals (and then activation) */
    actptr     *actptrptr;
    actptr      act;
    vptr        locals;
    vptr        locals_end;
    dataptr     stackdata;
    dataptr     stackdata_end;

    procedure  *start = lbl->lbl.proc;
    assert(location_known(start->raddr));

    <<allocate local memory for activation of procedure [[start]]>>

    act                = (actptr) t->stack_free;
    t->stack_free      = round_up((void *) (((actptr)(t->stack_free)) + 1));
    assert(t->stack_free <= t->stack_limit);

    act->locals        = locals;
    act->locals_end    = locals_end;
    act->stackdata     = stackdata;
    act->stackdata_end = stackdata_end;

    act->pc            = (bytecodeptr) location(start->raddr);
    act->u             = new_uid(t);

    /* leave kappa and callee NULL to indicate this is the end of a thread */
    act->kappa         = NULL;
    act->callee        = NULL;
    act->caller        = NULL;

    /* set up actptrptr */
    *actptrptr = act;
  }
@ 

Finally, we must allocate space for the local environment of the first
activation to be run (the activation for procedure [[start]]).
This memory is taken off the thread [[t]]'s stack, in accordance with our
stack layout convention.

<<allocate local memory for activation of procedure [[start]]>>=
  /* we allocate stackdata-space and locals-space for the first activation */
  actptrptr          = t->stack_free;
  t->stack_free      = round_up((actptr *)(t->stack_free) + 1);

  stackdata          = t->stack_free;
  t->stack_free      = round_up((void *) (((dataptr) (t->stack_free)) +
										  start->stackdata_size));
  stackdata_end      = t->stack_free;

  locals             = t->stack_free;
  t->stack_free      = (vptr)(t->stack_free) + start->num_locals;
  locals_end         = t->stack_free;
@ 

% ----------------------------------------------------------------------------
\subsection{Helper Functions}
% ----------------------------------------------------------------------------

Recall that the thread id of a given [[uid]] is actually a pointer to the
thread containing the activation uniquely identified by the [[uid]].

<<function definitions>>=
thread *find_thread(uid u) {
  return (thread *) u.thread;
}
@ 

