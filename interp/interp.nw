% -*- mode: Noweb; noweb-code-mode: c-mode -*- %
\documentclass{article}
\usepackage{noweb}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{path}
\usepackage[dvips]{graphicx}
\pagestyle{noweb} 
\input{../config/macros.tex}

\def\remark#1{\marginpar{\raggedright\hbadness=10000
        \def\baselinestretch{0.8}\scriptsize
        \it #1\par}}

\input{interp-macros.tex}

\begin{document}
\nwfilename{interp.nw}
\tableofcontents 
\nwbegindocs{}

% begin file

% ----------------------------------------------------------------------------
\section{Formalizing the Interpreter}
% ----------------------------------------------------------------------------

% ----------------------------------------------------------------------------
\subsection{Abstract Machine State}
% ----------------------------------------------------------------------------

In this section, we formally represent the internal state of the Quick~{\PAL} interpreter and present the operational semantics of the instructions available in the interpreter.
The state of our interpreter's abstract machine will be given by a tuple of the form: $\dstate$, where:\\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}rX@{}}
$\pc$    & is the current program counter\\
$V$      & is a value stack\\
$\rho$   & is the current local environment\\
$\spt$   & points to the stack used for local stack-data\\
$g$      & is the global environment\\
$\sigma$ & is the store ({\PAL} memory and {\PAL} hardware registers)\\
$A$      & is the argument-passing stack\\
$u$      & is the current activation's unique identifier ($\uid$)\\
$s$      & is the activation stack
\end{tabularx}\\
\\
The unique identifiers present in our representation of state will let the {\PAL} interpreter prevent cuts to dead continuations.  
To prepare the {\PAL} abstract machine for the future possibility of multi-threaded computation we may consider the option of including within our machine multiple activation stacks, each of which represents a separate thread.  
Cuts, for example, may occur from an activation on one stack to a continuation on another stack.  
To properly ensure cuts may not be taken to dead continuations in a multi-threaded environment, our unique identifier could be implemented with two words: one word to uniquely identify the stack (thread) in which the activation sits, and a second word to uniquely identify where it sits on this stack.

There is an instruction array present in our state (the program space), but we will not explicitly include it in our tuple because no rules require its modification.

Finally, it should be emphasized that the current activation frame is represented by elements in the top-level of the above tuple (i.e., $\pc$, $\rho$, $\spt$, and $u$). $s$ is a stack storing only previous (caller) activation frames, each of which may be represented by a tuple $x$ of the form $\dact$, where: \\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}rX@{}}
$\pc$    & is the program counter pointing to the next instruction to be interpreted in activation $x$\\
$\rho$   & is activation $x$'s local environment\\
$\spt$   & points to the stack containing $x$'s stack-data\\
$\kappa$ & is a ``continuation bundle'' for the $x$'s currently pending procedure call\\
\end{tabularx}
\\
A continuation bundle $\kappa$ is a set of call-site annotations represented by a tuple of the form $\kappa = \bundle$, where:\\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}lX@{}}
$\kappa_{c}$ & is a list of continuations available through cuts\\
$\kappa_{u}$ & is a list of continuations available through run-time activation unwinding\\
$\kappa_{r}$ & is a list of continuations available through alternate returns\\
$abort$      & is a boolean indicating whether or not this activation may be aborted\\
\end{tabularx}\\
\\
Additional implicit elements of state include: the array of instructions to interpret, a $\uid$ liveness table, and tables to manage labels and symbols.  We choose to leave these elements abstract in our formalization, for their internal implementations are of little consequence to the semantics of the interpreter's instructions.

\subsection{Starting Configuration}
The initial configuration of the interpreter's abstract machine is given by the tuple ${\state {\pc_i} \emptystack {\{\}} {\spt_i} {\{\}} {\sigma_i} {\{\}} u \emptystack}$, where: $\pc_i$ is the initial program counter; $\spt_i$ is a pointer to a fresh memory stack; $\sigma_i$ is the initial state of the store after having loaded a {\PAL} program and initial data blocks into memory; and $u$ is a fresh \texttt{uid}.

\subsection{Operational Semantics}
In the rules below, we use the notation $\newpc$ to indicate the address of the instruction that immediately follows instruction $\pc$ in our program memory.

Additionally, we make use of a number of abstract ``helper functions'' that are defined as follows:\\
\\
\begin{tabularx}{\linewidth}{@{\hskip2em}lX@{}}
\texttt{lookup\_symbol}(\emph{name})& lookup the value of symbol \emph{symbol}\\
\texttt{aggregate}(\emph{store, location, size, byte-order})& fetch the (\emph{size} div MEMSIZE) bytes found at \emph{location} in \emph{store} and aggregate them into one value, according to the given byte-order \\
\texttt{store}(\emph{store, location, value, size, byte-order})& split \emph{value} up into multiple pieces of size MEMSIZE and store pieces according to the given byte-order at \emph{location} in \emph{store}\\
\texttt{arity}(\emph{operator-name})& return the arity of operator \emph{operator-name}\\
\texttt{popn}(\emph{stack, n})& pops \emph{n} values off \emph{stack} and returns (list of popped values, stack of remaining values)\\
\texttt{lookup\_label}(\emph{name})& lookup the value (address) of label \emph{label}\\
\texttt{new\_env}(\emph{n})& creates a fresh, empty environment with space for \emph{n} values\\
\texttt{c\_call}(\emph{address, args-stack, store, signature})& calls native C function at \emph{address} and with type signature \emph{signature} with access to arguments and the store; returns modified argument stack and store\\
\texttt{is\_live}(\emph{uid})& returns \emph{true} if and only if the activation uniquely identified by \emph{uid} is still live
\end{tabularx}\\
\\
And now for the rules: \\

\ops{Literal}
{i[\pc] = (literal)\textrm{ }x}
{\step
  {\dstate}
  {\state \newpc {x\cons{}V} \rho \spt g \sigma A u s}
}
\\
\ops{PushSymbol}
{i[\pc] = .name \andalso a = \texttt{lookup\_symbol(}name\texttt{)}}
{\step
  {\dstate}
  {\state \newpc {a\cons{}V} \rho \spt g \sigma A u s}
}
\\
\ops{Fetch}
{i[\pc] = \mathtt{fetch}\dash{}space\dash{}size \andalso v = \texttt{aggregate(}\sigma,\$space[a],size,\mathtt{byte}\dash\mathtt{order)}}
{\step
  {\state \pc {a\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc {v\cons{}V} \rho \spt g \sigma A u s}
}
\\
\ops{Store}
{i[\pc] = \mathtt{store}\dash{}space\dash{}size \andalso {\sigma'} = \texttt{store(}\sigma,\$space[a],v,size,\mathtt{byte}\dash\mathtt{order)}}
{\step
  {\state \pc {v\cons{}a\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V \rho \spt g {\sigma'} A u s}
}
\\
\ops{Fetch-Local}
{i[\pc] = \mathtt{fetch}\dash\mathtt{local}\dash{}x}
{\step
  {\dstate}
  {\state \newpc {\rho[x]\cons{}V} \rho \spt g \sigma A u s}
}
\\
\ops{Store-Local}
{i[\pc] = \mathtt{store}\dash\mathtt{local}\dash{}x \andalso {\rho'} = \rho\{x\mapsto{}v\}}
{\step
  {\state \pc {v\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V {\rho'} \spt g \sigma A u s}
}
\\
\ops{Fetch-Global}
{i[\pc] = \mathtt{fetch}\dash\mathtt{global}\dash{}x}
{\step
  {\dstate}
  {\state \newpc {g[x]\cons{}V} \rho \spt g \sigma A u s}
}
\\
\ops{Store-Global}
{i[\pc] = \mathtt{store}\dash\mathtt{global}\dash{}x \andalso g' = g\{x\mapsto{}v\}}
{\step
  {\state \pc {v\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V \rho \spt {g'} \sigma A u s}
}
\\
\ops{Guarded-Store-True}
{\twoline
{i[\pc] = \mathtt{guarded}\dash\mathtt{store}\dash{}space\dash{}size}
{{\sigma'} = \texttt{store(}\sigma,\$space[a],v,size,\mathtt{byte}\dash\mathtt{order)}}
}
{\step
  {\state \pc {v\cons{}a\cons{}\mathtt{\#t}\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V \rho \spt g {\sigma'} A u s}
}
\\
\ops{Guarded-Store-False}
{i[\pc] = \mathtt{guarded}\dash\mathtt{store}\dash{}space\dash{}size}
{\step
  {\state \pc {v\cons{}a\cons{}\mathtt{\#f}\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V \rho \spt g \sigma A u s}
}
\\
\ops{Guarded-Store-Local-True}
{\twoline
{i[\pc] = \mathtt{guarded}\dash\mathtt{store}\dash\mathtt{local}\dash{}x}
{\rho' = \rho\{x\mapsto{}v\}}
}
{\step
  {\state \pc {v\cons\mathtt{\#t}\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V {\rho'} \spt g \sigma A u s}
}
\\
\ops{Guarded-Store-Local-False}
{i[\pc] = \mathtt{guarded}\dash\mathtt{store}\dash\mathtt{local}\dash{}x}
{\step
  {\state \pc {v\cons\mathtt{\#f}\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V \rho \spt g \sigma A u s}
}
\\
\ops{Guarded-Store-Global-True}
{\twoline
{i[\pc] = \mathtt{guarded}\dash\mathtt{store}\dash\mathtt{global}\dash{}x}
{g' = g\{x\mapsto{}v\}}
}
{\step
  {\state \pc {v\cons\mathtt{\#t}\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V \rho \spt {g'} \sigma A u s}
}
\\
\ops{Guarded-Store-Global-False}
{i[\pc] = \mathtt{guarded}\dash\mathtt{store}\dash\mathtt{global}\dash{}x}
{\step
  {\state \pc {v\cons\mathtt{\#f}\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V \rho \spt g \sigma A u s}
}
\\
\ops{Push-Arg}
{i[\pc] = \mathtt{push}\dash\mathtt{arg}}
{\step
  {\state \pc {v\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V \rho \spt g \sigma {v\cons{}A} u s}
}
\\
\ops{Pop-Arg}
{i[\pc] = \mathtt{pop}\dash\mathtt{arg}}
{\step
  {\state \pc V \rho \spt g \sigma {v\cons{}A} u s}
  {\state \newpc {v\cons{}V} \rho \spt g \sigma A u s}
}
\\
\ops{ApplyOp}
{\threeline{i[\pc] = operator{-size} \andalso n = \texttt{arity(}operator\texttt{)}}{(v,V') = \texttt{popn(}V,n\texttt{)}}{v' = operator(v)}}
{\step
  {\dstate}
  {\state \newpc {v\cons{}V'} \rho \spt g \sigma A u s}
}
\\
\ops{Goto}
{i[\pc] = \mathtt{goto}}
{\step
  {\state \pc {\pc'\cons{}V} \rho \spt g \sigma A u s}
  {\state {\pc'} V \rho \spt g \sigma A u s}
}
\\
\ops{CBranchT-True}
{i[\pc] = \mathtt{cbrancht}\dash\pc'}
{\step
  {\state \pc {\mathtt{\#t}\cons{}V} \rho \spt g \sigma A u s}
  {\state {\pc'} V \rho \spt g \sigma A u s}
}
\\
\ops{CBranchT-False}
{i[\pc] = \mathtt{cbrancht}\dash\pc'}
{\step
  {\state \pc {\mathtt{\#f}\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V \rho \spt g \sigma A u s}
}
\\
\ops{CBranchF-True}
{i[\pc] = \mathtt{cbranchf}\dash\pc'}
{\step
  {\state \pc {\mathtt{\#t}\cons{}V} \rho \spt g \sigma A u s}
  {\state \newpc V \rho \spt g \sigma A u s}
}
\\
\ops{CBranchF-False}
{i[\pc] = \mathtt{cbranchf}\dash\pc'}
{\step
  {\state \pc {\mathtt{\#f}\cons{}V} \rho \spt g \sigma A u s}
  {\state {\pc'} V \rho \spt g \sigma A u s}
}
\\
\ops{BranchTF-True}
{i[\pc] = \mathtt{branchtf}\dash\pc_{t}\dash\pc_{f}}
{\step
  {\state \pc {\mathtt{\#t}\cons{}V} \rho \spt g \sigma A u s}
  {\state {\pc_{t}} V \rho \spt g \sigma A u s}
}
\\
\ops{BranchTF-False}
{i[\pc] = \mathtt{branchtf}\dash\pc_{t}\dash\pc_{f}}
{\step
  {\state \pc {\mathtt{\#f}\cons{}V} \rho \spt g \sigma A u s}
  {\state {\pc_{f}} V \rho \spt g \sigma A u s}
}
\\
\ops{CMMCall}
{\fiveline
{i[\pc] = \mathtt{cmm}\dash\mathtt{call}\dash\kappa}
{V \textrm{ is empty}}
{P \rightarrow procPC = \pc' \andalso P \rightarrow numLocals = n \andalso P \rightarrow stackDataSize = m}
{\rho' = \texttt{new\_env(}n\texttt{)} \andalso u' \textrm{ is a fresh, unique identifier}}
{s' = {\act \newpc \rho \spt \kappa u}}
}
{\step
  {\state \pc {P\cons{}V} \rho \spt g \sigma A u s}
  {\state {\pc'} V {\rho'} {\spt-m} g \sigma A {u'} {s'\cons{}s}}
}
\\
\ops{CMMTailCall}
{\fourline
{i[\pc] = \mathtt{cmm}\dash\mathtt{tail}\dash\mathtt{call}}
{V \textrm{ is empty}}
{P \rightarrow procPC = \pc' \andalso P \rightarrow numLocals = n \andalso P \rightarrow stackDataSize = m}
{\rho' = \texttt{new\_env(}n\texttt{)} \andalso u' \textrm{ is a fresh, unique identifier}}
}
{\twoline
{\step
  {\state \pc {P\cons{}V} \rho \spt g \sigma A u s}
  {\state {\pc'} V {\rho'} {\spt-m} g \sigma A {u'} s}
}
{\textrm{and } u \textrm{ becomes dead}}
}
\\
\ops{CCall}
{\threeline
{i[\pc] = \mathtt{c}\dash\mathtt{call}\dash{}signature}
{V \textrm{ is empty}}
{(A',\sigma') = \texttt{c\_call(}a,A,\sigma,signature\texttt{)}}
}
{\step
  {\dstate}
  {\state \newpc {a\cons{}V} \rho \spt g {\sigma'} {A'} u s}
}
\\
\ops{ReturnDefault}
{\threeline
{i[\pc] = \mathtt{return}\dash{}<m/m>}
{V \textrm{ is empty}}
{s = {\act {\pc'} {\rho'} {\spt'} \kappa {u'}}}
}
{\twoline
{\step
  {\state \pc V \rho \spt g \sigma A u {s\cons{}S}}
  {\state {\pc'} V {\rho'} {\spt'} g \sigma A {u'} S}
}
{\textrm{and } u \textrm{ becomes dead}}
}
\\
\ops{ReturnAlt}
{\sixline
{i[\pc] = \mathtt{return}\dash{}<n/m>}
{V \textrm{ is empty} \andalso n < m}
{s = {\act {\pc'} {\rho'} {\spt'} \kappa {u'}}}
{\kappa = \bundle}
{m = |\kappa_{r}|}
{\pc'' = \kappa_{r}[x]}
}
{\twoline
{\step
  {\state \pc V \rho \spt g \sigma A u {s\cons{}S}}
  {\state {\pc''} V {\rho'} {\spt'} g \sigma A {u'} S}
}
{\textrm{and } u \textrm{ becomes dead}}
}
\\
\ops{Cut}
{\nineline
{i[\pc] = \mathtt{cut}}
{V \textrm{ is empty}}
{s = {\act {\pc'} {\rho'} {\spt'} \kappa {u'}}}
{\kappa = \bundle}
{k = \langle \pc_k, s'\cons{}s'' \rangle}
{\pc_k \in \kappa_c}
{s' = {\act {\pc_k} {\rho_k} {\spt_k} {\kappa_k} {u_k}}}
{\texttt{is\_live(}u_k\texttt{)} = true}
{\kappa_i.aborts = true \textrm{ for all activations above } s' \textrm{ in thread identified by } u_k.thread}
}
{\step
  {\state \pc {k\cons{}V} \rho \spt g \sigma A u {s\cons{}S}}
  {\state {\pc_k} V {\rho_k} {\spt_k} g \sigma A {u_k} {s''}}
}

% ----------------------------------------------------------------------------
\section{Interpreter Interfaces}
% ----------------------------------------------------------------------------

This section contains the interface of the interpreter.
The interpreter's interfaces, as we present them, consist of type definitions, function prototypes, and ``faux prototypes'' for macros defined elsewhere.  
The Quick~{\PAL} Interpreter also makes use of a number of external libraries not standard to C.  
The New Jersey Machine-Code Toolkit is used to ease the burden of generating in-memory bytecode for interpreter instructions and managing relocatable addresses and labels.  
The Lua C libraries allow us to use an embedded Lua interpreter within the C environment to ease the otherwise uninteresting task of parsing input files; additionally, they provide us with access to Lua tables, which are easily manipulated dynamic, associative arrays.  
We will limit our discussion of these libraries to the extent to which we need to make use of them.

<<interp.h>>=
#ifndef _INTERP_H
#define _INTERP_H

#include <lua.h>
#include <mclib.h>

#include "activation.h"
#include "assemblyunit.h"
#include "value.h"
#include "intervals.h"
#include "label.h"
#include "table.h"
#include "thread.h"

<<constant definitions>>
<<macro definitions>>
<<global variable declarations>>

<<function prototypes>>

#endif /* _INTERP_H */
@

% ----------------------------------------------------------------------------
\subsection{Representation}
% ----------------------------------------------------------------------------

% ----------------------------------------------------------------------------
\paragraph{Bytecode}
% ----------------------------------------------------------------------------

Before an input file to the Quick~{\PAL} Interpreter may be interpreted, it is first translated into bytecode and stored in memory.  
Thus, the in-memory format of the instructions is simply a byte array. 
For purposes of internal addressing, we make use of the NJ Machine-Code Toolkit's relocatable address type ([[RAddr]]).
<<external definitions>>=
typedef struct relocatable_address *RAddr;
@ 
We will see later how these addresses are manipulated and how the bytecode is structured in memory with respect to {\PAL} sections.

% ----------------------------------------------------------------------------
\subsection{Bytecode Generation}
% ----------------------------------------------------------------------------

To assist in generating bytecode, we use the NJ Machine-Code toolkit.  As a client of this library, we are responsible for writing a general allocation function and a closure allocation function (allocates [[RClosure]]s).  Additionally, when using certain toolkit functions we are required to supply an error printing function that takes a format string and a variable number of arguments and returns nothing.

<<function prototypes>>=
void *mc_alloc(int size, Mc_alloc_pool pool);
RClosure mc_alloc_closure(unsigned size, RBlock dest_block,
                                 unsigned dest_lc);
void error(char *fmt, ...);
@

Of our own volition, we provide function [[mc_free_all]] to free all memory
allocated by [[mc_alloc]] and [[mc_alloc_closure]] since the last call to
[[mc_free_all]]. 

<<function prototypes>>=
void mc_free_all(void);
@ 

% ----------------------------------------------------------------------------
\paragraph{Encoding Helpers}
% ----------------------------------------------------------------------------

When it comes time to permanently relocate a relocatable blocks ([[RBlock]]), we make a call from a Lua code snippet to the helper function [[lua_relocate_block]], which takes a [[lua_State]], expects a pointer to an [[RBlock]] to be atop the Lua stack, permanently relocates this [[RBlock]], pops the pointer off the Lua stack, and returns 0.

<<function prototypes>>=
int    lua_relocate_block(lua_State *L);
@

Unfortunately, we must use a separate helper function to actually copy the contents of a relocated [[RBlock]] into their permanent memory location.
For this, we use helper [[lua_copy_block_contents]], which takes a [[lua_State]], expects a pointer to an [[RBlock]] to be atop the Lua stack, copies the contents of this [[RBlock]] into its permanent location, pops the pointer off the stack, and returns 0.

<<function prototypes>>=
int    lua_copy_block_contents(lua_State *L);
@ 

% ----------------------------------------------------------------------------
\paragraph{Loading an Assembly Unit}
% ----------------------------------------------------------------------------

To load an entire assembly unit into memory (i.e., generate bytecode for it and store the bytecode in memory), we create the main bytecode generation function [[load_assembly_unit]].
This function takes a string with the name of the source file to be loaded as an assembly unit or the string to be loaded itself, and whether a filename or source string is being passed in; it returns an error code indicates success/failure.
<<function prototypes>>=
int load_assembly_unit(char *s, assembly_unit_type ty);
@ 

% ----------------------------------------------------------------------------
\subsection{Bytecode Interpreting}
% ----------------------------------------------------------------------------

The main interpreting of this application is done in the [[run_interp]] function.  
Given a suspended {\PAL} thread at which to start program interpretation, [[run_interp]] executes program code stored as in-memory bytecode.
<<function prototypes>>=
void run_interp(thread *t);
@ 

% ----------------------------------------------------------------------------
\subsection{Starting it All}
% ----------------------------------------------------------------------------

Finally, we get to the main function that initializes the application: the [[cmm_interp_open]] function.
This function takes two arguments that specify the respective sizes of the value and argument-passing stacks used in the interpreter.

<<function prototypes>>=
int cmm_interp_open(int valstack_size, int argspace_size);
@ 

[[cmm_interp_open]] starts up Lua and prepares for future encoding and interpreting, returning a non-zero [[int]] only if an error occurred.
We make use of helper function [[check_value_types]] (from [[value.nw]]) to perform some assertions about the basic C types used in the interpreter's implementation; and we use [[init_interp]] to perform basic interpreter initialization (including operator registration, etc.).

<<function prototypes>>=
void   init_interp(lua_State *L, int valstack_size, int argspace_size);
@ 

For the sake of this interpreter's implementation and execution, we also make sure that defined [[MEMSIZE]]s and [[PTRSIZE]]s will work with the current architecture.

<<function prototypes>>=
void   check_architecture(assembly_unit *au);
@ 

% ----------------------------------------------------------------------------
\paragraph{Ending it All}
% ----------------------------------------------------------------------------

To close down, we have the function [[cmm_interp_close]].

<<function prototypes>>=
void cmm_interp_close(void);
@ 

% ----------------------------------------------------------------------------
\subsection{Error Handling}
% ----------------------------------------------------------------------------

There are two major sorts of errors we expect to encounter during the interpreter's execution: errors occuring during the loading of assembly files, and errors occurring during the interpreting of bytecode in memory.
We make use of the C standard library's [[setjmp]] and [[longjmp]] functions for error handling; they essentially allow us to perform non-local returns to two main sites.
Whenever we must raise an error, we simply call helper function [[cmm_err]], which prints an appropriate message and then [[longjmp]]s to appropriate error-handling site (either the site of assembly file loading or the site of assembly file interpreting).
[[cmm_err]] is given a error format string and a variable length argument list.

<<function prototypes>>=
void cmm_err(char *fmt, ...);
@ 

To keep track of which error handling site to jump to, we use the global variable [[errorjmp]].

<<global variable definitions>>=
static jmp_buf errorjmp;
@  

As minor helper macros, we use [[mem_assert]] to catch errors that occur when there is a memory allocation error and [[cmm_assert]] to make assertions with better error messages.
[[mem_assert]] should do nothing unless [[ptr]] is [[NULL]].

<<faux prototypes>>=
void mem_assert(void *ptr);
void cmm_assert(int assertion, const char *err_msg);
@ 

For specific matters of Lua errors, we are assisted by error handler [[lua_error_handle]].
This function properly interpets Lua library error codes, acts appropriately (e.g., warning the user, exiting).

<<function prototypes>>=
void   lua_error_handle(int err_code, const char *fn);
@

% ----------------------------------------------------------------------------
\section{Implementation}
% ----------------------------------------------------------------------------

This section contains the implementation of the Quick~{\PAL} Interpreter.
We begin with the SLED definition of the interpreter's instruction set and continue with the implementation of the functions and macros described in the last section.

% ----------------------------------------------------------------------------
\subsection{SLED Definition}
% ----------------------------------------------------------------------------

The following code implements an SLED description of the Quick~{\PAL} Interpreter's abstract machine.
We create fields to represent the different segments of a bytecode (instruction code + arguments), and construct a pattern table from all the instructions we wish to include in the bytecode.  A few instructions from our interpreter's language have multiple versions in the table; this allows for allowing these instructions to take arguments of different bit widths.

<<bytecode.sled>>=
fields of bcode     (8) op      0:7
fields of byte      (8) bits8   0:7
fields of byte2     (8) bits8b  0:7
fields of byte3     (8) bits8c  0:7
fields of short    (16) bits16  0:15
fields of long     (32) bits32  0:31
fields of longlong (64) bits64  0:63

patterns
  [ DEFINE_PROC   END_PROC       PUSH           GSTORE
    FETCH         STORE          FETCH_ARG      STORE_ARG
    STORE_LOCAL8  STORE_GLOBAL8  FETCH_LOCAL8   FETCH_GLOBAL8
    STORE_LOCAL16 STORE_GLOBAL16 FETCH_LOCAL16  FETCH_GLOBAL16
    GSTORE_LOCAL8 GSTORE_LOCAL16 GSTORE_GLOBAL8 GSTORE_GLOBAL16
    GOTO          CBRANCHT       CBRANCHF       BRANCHTF
    CALL          CMM_TAIL_CALL  RETURN         CUT
    BEGIN_SPAN    END_SPAN       EMIT_RADDR
    PLACECODE     PUSH_SYMBOL    OP
    HALT
  ] is op = {0 to 34}
@ 

To add an instruction to the bytecode, one must simply add an instruction name to the [[op]] table above and increase the upper bound of [[op]]'s value range.
We next define another set of patterns to ease constructor generation of similarly structure instructions.

<<bytecode.sled>>=
patterns 
  any8    is STORE_LOCAL8   | STORE_GLOBAL8   | FETCH_LOCAL8  | FETCH_GLOBAL8
           | GSTORE_LOCAL8  | GSTORE_GLOBAL8  | FETCH_ARG     | STORE_ARG
  any16   is STORE_LOCAL16  | STORE_GLOBAL16  | FETCH_LOCAL16 | FETCH_GLOBAL16
           | GSTORE_LOCAL16 | GSTORE_GLOBAL16
  any32   is PUSH  | CALL   | DEFINE_PROC     | END_SPAN      | PUSH_SYMBOL
  memory  is FETCH | STORE  | GSTORE
  nullary is HALT  |  GOTO  | CMM_TAIL_CALL   | CUT           | END_PROC
@ 

The [[relocatable]] and [[placeholder]] keywords allow us to specify that some arguments to instructions will be relocatable addresses ([[RAddr]]s).

<<bytecode.sled>>=
relocatable addr
relocatable addr2
relocatable addr3

placeholder for bcode is PLACECODE
placeholder for long  is bits32 = 0
@ 

Now, we create constructors for our instructions (or for groups of instructions as we defined them in the above pattern definition); these are used in our C code when we need to use the toolkit to parse the bytecode into something human-readable.

<<bytecode.sled>>=
constructors
  any8           bits8                is any8;       bits8
  any16          bits16               is any16;      bits16
  any32          bits32               is any32;      bits32
  memory         bits8  bits8b bits8c is memory;     bits8;      bits8b; bits8c
  EMIT_RADDR     addr                 is bits32=addr
  BEGIN_SPAN     bits32 addr          is BEGIN_SPAN; bits32;     bits32=addr
  APPLY_OPERATOR bits32               is OP;         bits32
  CBRANCHT       addr                 is CBRANCHT;   bits32=addr
  CBRANCHF       addr                 is CBRANCHF;   bits32=addr
  BRANCHTF       addr   addr2         is BRANCHTF;   bits32=addr;bits32=addr2
  RETURN         bits8  bits8b        is RETURN;     bits8;      bits8b
  nullary
@ 

The conditional assembly present in the definition allows an instruction to be represented by multiple opcodes (each is accustomed to arguments of different bit-lengths) yet be connected with one NJ Machine-Code Toolkit constructor.

<<bytecode.sled>>=
# conditional assembly
  store_local bits16
    when { }  is store_local8 (bits16)
    otherwise is store_local16(bits16)
  store_global bits16
    when { }  is store_global8 (bits16)
    otherwise is store_global16(bits16)
  gstore_local bits16
    when { }  is gstore_local8 (bits16)
    otherwise is gstore_local16(bits16)
  gstore_global bits16
    when { }  is gstore_global8 (bits16)
    otherwise is gstore_global16(bits16)
  fetch_local bits16
    when { }  is fetch_local8 (bits16)
    otherwise is fetch_local16(bits16)
  fetch_global bits16
    when { }  is fetch_global8 (bits16)
    otherwise is fetch_global16(bits16)
@ 

% ----------------------------------------------------------------------------
\subsection{Initialization and Error-Handling}
% ----------------------------------------------------------------------------

% ----------------------------------------------------------------------------
\subsubsection{Initialization}
% ----------------------------------------------------------------------------

The actual initial registration of operators occupies some of the body of helper function [[init_interp]].
With some preprocessor exploitation, we are able to reuse the same operator definitions to both implement the operators as functions and to register these functions with the interpreter at runtime.
\emph{NOTE: great care must be taken to make sure that the implementation operator definitions stay above the definition of [[init_interp]]; we redefine the same macros to do different things within [[init_interp]].}

<<utility functions>>=
void init_interp(lua_State *L, int valstack_size, int argspace_size) {

  /* initialize the contents of global tables */
  assembly_units_table   = fresh_table();
  exports_table          = fresh_table();
  operator_table         = fresh_table();
  c_func_table           = fresh_table();
  c_sig_table            = fresh_table();

  /* initialize the lua_State field of global tables */
  assembly_units_table.L = L;
  exports_table.L        = L;
  operator_table.L       = L;
  c_func_table.L         = L;
  c_sig_table.L          = L;
 
  /* allocate globally used memory */
  <<allocate memory for value stack>>
  <<allocate memory for argument-passing stack>>

  /* register C function signatures */
  init_c_sigs();

  /* register operators */
  init_operators();
}
@ 

To allocate memory for the value stack and argument-passing stack (which are re-used throughout all activations), we simply [[malloc]] memory.
The sizes of these stacks are specified by arguments to the [[cmm_interp_open]] function.

<<allocate memory for value stack>>=
  values_base        = (sptr) malloc(sizeof(value) * valstack_size);
  mem_assert(values_base);
  values_limit       = values_base + valstack_size;
  values             = values_base - 1;
@

<<allocate memory for argument-passing stack>>=
  /* ARGS OK */
  arguments          = (sptr) malloc(sizeof(value) * argspace_size);
  mem_assert(arguments);
  arguments_limit    = arguments + argspace_size;
@

% ----------------------------------------------------------------------------
\subsubsection{Utility Functions}
% ----------------------------------------------------------------------------

The utility helper functions assist in error handling and performing some sanity checks on the [[typedef]]'d basic types.

<<utility functions>>=
<<sanity checks>>
<<error-handling functions>>
@ 

% ----------------------------------------------------------------------------
\paragraph{Sanity Checks}
% ----------------------------------------------------------------------------

Although likely unnecessary, we perform a few quick assertions to make sure nothing horribly wrong is going on before we begin to interpret code.

<<sanity checks>>=
void check_architecture(assembly_unit *au) {
  if (au->memsize != 8) {
    fprintf(stderr, "this interpreter can only handle a MEMSIZE of 8");
    exit(1);
  }
  if (au->ptrsize != 32) {
    fprintf(stderr, "this interpreter can only handle a PTRSIZE of 32");
    exit(1);
  }
  if (au->byte_order != DEF_BYTE_ORDER) {
    fprintf(stderr, "this interpreter can only handle native byte-order memory"
                    " access");
    exit(1);
  }
}
@

% ----------------------------------------------------------------------------
\paragraph{Error Handling}
% ----------------------------------------------------------------------------

Whenever we need to raise an error (with a few exceptios), we call [[cmm_err]].
This function prints an appropriate error message, given its arguments, and [[longjmp]]s to the appropriate error-handling site.
Note that this function's behavior is undefined if the error did not occur during assembly file loading ([[load_assembly_unit]]) or during bytecode interpreting (or relocation).

<<error-handling functions>>=
void cmm_err(char *fmt, ...) {
  va_list args;

  if (fmt != NULL) {
    fprintf(stderr, "error: ");

    va_start(args, fmt);
    vfprintf(stderr, fmt, args);

    fprintf(stderr, "\n");
  }

  if (lua_linenumber != LUA_INVALIDLINE) {
      fprintf(stderr, "error: error noticed when reached "
                      "<line number %d>\n", lua_linenumber);
      lua_linenumber = LUA_INVALIDLINE;
  }

  va_end(args);
  longjmp(errorjmp, 1);
}
@

To help catch memory allocation errors, we provide macro [[mem_assert]].

<<macro definitions>>=
#define mem_assert(PTR) ((PTR) != NULL ? (void)0 \
                                       : cmm_err("memory allocation error " \
                                                 "<"__FILE__":%d>", __LINE__))
@ 

To allow failed assertions to generate better error messages, we provide [[cmm_assert]].

<<macro definitions>>=
#define cmm_assert(A, MSG) ((A) ? (void)0 : cmm_err(MSG))
@ 

% ----------------------------------------------------------------------------
\subsection{Bytecode Generation}
% ----------------------------------------------------------------------------

The main plan with bytecode generation is this: a Lua source file written using the functions listed at the top of this document is run using an embedded Lua interpreter that is extended with C functions implementing the {\PAL} Lua functions.  These C functions are more or less wrappers for C encoding functions that are automatically generated when the SLED definition of the interprer's instruction set ([[bytecode.sled]]) is run through the NJ Machine-Code Toolkit.  These generated functions emit bytecode into relocatable memory blocks ([[RBlock]]s), which we use to represent {\PAL} sections.

% ----------------------------------------------------------------------------
\subsubsection{Lua Interaction Helpers}
% ----------------------------------------------------------------------------

To ease interactions with the embedded Lua interpreter, we write a few helper functions.
[[lua_error_handle]] simply checks an error code returned by one of Lua's API functions for interpreting Lua code (e.g., [[lua_dofile]], [[lua_dostring]]).  
If an error occurred, it prints a (somewhat) helpful error message and causes a system exit with a non-zero error code.
Otherwise, the function returns to its caller.

<<bytecode generation>>=
void lua_error_handle(int err_code, const char *fn) {
  switch (err_code) {
  case 0:
    return;
  case LUA_ERRRUN:
    cmm_err("run-time error while interpreting [%s]", fn);
  case LUA_ERRSYNTAX:
    cmm_err("a syntax error was found in [%s]", fn);
  case LUA_ERRMEM:
    fprintf(stderr, "error: Lua memory allocation error [%s]", fn);
    break;
  case LUA_ERRERR:
    fprintf(stderr, "error: unrecoverable internal error [%s]", fn);
    break;
  case LUA_ERRFILE:
    cmm_err("cannot open file [%s]", fn);
  }
  exit(1);
}
@ 

% ----------------------------------------------------------------------------
\subsubsection{NJ Machine-Code Toolkit Library Interactions}
% ----------------------------------------------------------------------------

% ----------------------------------------------------------------------------
\paragraph{Allocation and Closures}
% ----------------------------------------------------------------------------

As a client of the toolkit, our code is obligated to define functions [[mc_alloc]] and [[mc_alloc_closure]]; these functions simply must allocate memory to be used by Toolkit-generated code as ``relocatable memory blocks.''  

We use David Hanson's ``arenas'' for allocation; they allow for one-shot
de-allocation.

<<global variable definitions>>=
static Arena_T mc_arena = NULL;
@ 

<<bytecode generation>>=
void *mc_alloc(int size, Mc_alloc_pool pool) {
  void *a;

  if (mc_arena == NULL) {
    mc_arena = Arena_new();
    mem_assert(mc_arena);
  }

  a = (void *) Arena_alloc(mc_arena, size, __FILE__, __LINE__);
  mem_assert(a);
  return a;
}
@ 

While we allocate memory for closures, we must also keep track of pointers to these closures so we can later apply them with the toolkit API function [[apply_closure]].
A simple array of pointers works here; if the array gets too small to fit the closures, we dynamically resize the array to twice its previous size.

<<global variable definitions>>=
static RClosure  *closures_base  = NULL;
static RClosure  *closures_free  = NULL;
static RClosure  *closures_limit = NULL;
@ 

<<bytecode generation>>=
RClosure mc_alloc_closure(unsigned size, RBlock dest_block, 
                                 unsigned dest_lc)
{
  /* note: RClosure is a typedef'd struct pointer */
  RClosure a = (RClosure) mc_alloc(size, RClosure_pool);

  /* store the closure in a "dynamic array" so it can later be applied */
  if (closures_free >= closures_limit) {
    RClosure *closures_new = realloc(closures_base, 
                             2 * sizeof(RClosure) *
                             (closures_limit - closures_base));
    mem_assert(closures_new);
    closures_limit = closures_new + 2*(closures_limit - closures_base);
    closures_free  = closures_new + (closures_free - closures_base);
    closures_base  = closures_new;
  }
  (closures_free++)[0] = a;

  return a;
}
@

To free all memory allocated for the Machine-code Toolkit since the last call
to [[mc_free_all]], we simply free the contents of [[mc_arena]].

<<bytecode generation>>=
void mc_free_all(void) {
  if (mc_arena != NULL) {
    Arena_free(mc_arena);
    Arena_dispose(&mc_arena);
    mc_arena = NULL;
  }
}
@ 

% ----------------------------------------------------------------------------
\paragraph{Bytecode Relocation}
% ----------------------------------------------------------------------------

When we are ready to assign permanent addresses to our relocatable blocks, we do so within Lua.  [[lua_relocate_block]] is the C function exported to Lua that implements this relocation.  It pops an [[RBlock]] off the Lua stack, uses [[malloc]] to find enough contiguous space in memory to store the [[RBlock]], and calls Toolkit API function [[set_address]] to permanently relocate it.  The 0 return value tells Lua no values are being returned from [[lua_relocate_block]].

<<bytecode generation>>=
int lua_relocate_block(lua_State *L) {
  RBlock bl, oldbl;
  void   *loc;

  if (!lua_isuserdata(L, -1) || 
      lua_tag(L, -1) != lua_RBlock_tag ||
      (bl = (RBlock) lua_touserdata(L, -1)) == NULL)
  {
    lua_pop(L, 1);
    cmm_err("internal error relocating block");
  }

  /* emit a HALT instruction at the end of the block */
  oldbl = crb();
  set_block(bl);
  halt();
  set_block(oldbl);

  /* THIS COULD BE DANGEROUS */
  loc = (void *) mc_alloc(block_size(bl), relocated_pool);

  /* loc = (void *) malloc(block_size(bl)); */
  /* mem_assert(loc); */

  set_address(bl, (unsigned) loc);

  lua_pop(L, 1);

  return 0;
}
@

Unfortunately [[lua_relocate_block]] only assigns a permanent address to an [[RBlock]] and does not actually relocate its contents (remember that we must use [[lua_relocate_block]] to relocate all blocks, then apply all closures, and then move the contents of the [[RBlock]]s into their permanent memory locations).
[[lua_copy_block_contents]] helps here with the actual copying.
It pops an [[RBlock]] off the Lua stack, looks up its permanent address, uses Toolkit API function [[block_copy]] to copy its contents, and returns 0 to tell Lua it's returning no values.

<<bytecode generation>>=
int lua_copy_block_contents(lua_State *L) {
  RBlock bl;
  
  if (!lua_isuserdata(L, -1) ||
      lua_tag(L, -1) != lua_RBlock_tag ||
      (bl = (RBlock) lua_touserdata(L, -1)) == NULL)
  {
    lua_pop(L, 1);
    cmm_err("internal error copying block contents");
  }

  assert(block_address_known(bl));
  block_copy((unsigned char *) block_address(bl), bl, 0, block_size(bl));

  lua_pop(L, 1);

  return 0;
}
@ 

% ----------------------------------------------------------------------------
\paragraph{Helper Functions}
% ----------------------------------------------------------------------------

Such functions in the API of the NJ Machine-Code Toolkit as [[apply_closure]] require error-handling functions that take a format string indicating the error and a variable number of arguments supplying values formatted by the string.
The [[error]] function is taken from page 174 of Kernighan and Ritchie's \emph{The C Programming Language: Second Edition}.

<<bytecode generation>>=
void error(char *fmt, ...) {
  va_list args;

  va_start(args, fmt);
  fprintf(stderr, "error: ");
  vfprintf(stderr, fmt, args);
  fprintf(stderr, "\n");
  va_end(args);
  exit(1);
}
@ 

% ----------------------------------------------------------------------------
\subsubsection{Loading an Assembly Unit}
% ----------------------------------------------------------------------------

To load an assembly unit, we make use of the functions defined above.
As a side effect, [[load_assembly_unit]] changes the current assembly unit ([[unit]]).
Although we do not explicitly use [[au]], the call to [[new_assembly_unit]] is absolutely necessary.
It just happens that we don't need to do anything with [[au]] for the moment.

<<bytecode generation>>=
int load_assembly_unit(char *s, assembly_unit_type ty) {
  lua_State     *L  = assembly_units_table.L;
  RClosure      *cl;
  assembly_unit *au = new_assembly_unit(L);

  assert(au);

  if (setjmp(errorjmp)) {
    if (ty == SRC_FILE) {
      fprintf(stderr, "error: unrecoverable error; cannot finish loading "
                      "file [%s]\n", s);
    } else {
      fprintf(stderr, "error: unrecoverable error; cannot finish loading "
                      "assembly unit\n");
    }
    return 1;
  } else {
    if (ty == SRC_FILE) {
      <<run Lua source file [[s]]>>
    } else if (ty == SRC_STRING) {
      <<run Lua source string [[s]]>>
    } else {
      assert(ty == SRC_STDIN);
      assert(s  == NULL);
      <<run Lua source code on [[stdin]]>>
    }
    <<perform bytecode relocation>>
  }

  lua_linenumber = LUA_INVALIDLINE;

  return 0;
}
@ 

% ----------------------------------------------------------------------------
\paragraph{Source File Encoding}
% ----------------------------------------------------------------------------

To run a Lua source file, we simply call the Lua API function [[lua_dofile]] and relegate error handling to [[lua_error_handle]].

<<run Lua source file [[s]]>>=
  lua_error_handle(lua_dofile(L, s), s);
@

To run a Lua source string, we call Lua API function [[lua_dostring]] and relegate error handling to [[lua_error_handle]].

<<run Lua source string [[s]]>>=
  lua_error_handle(lua_dostring(L, s), s);
@ 

To run Lua source code on [[stdin]], we call [[lua_dofile]] with a [[NULL]] argument.

<<run Lua source code on [[stdin]]>>=
  lua_error_handle(lua_dofile(L, NULL), "<stdin>");
@ 

% ----------------------------------------------------------------------------
\paragraph{Relocating Relocatable Blocks}
% ----------------------------------------------------------------------------

Once we have finished emitting all bytecode into [[RBlock]]s, we are ready to assign permanent addresses to the [[RBlock]]s.
Here, we run a snippet of Lua code that iterates through all values stored in the Lua section table ([[section_table]])--which should be a table of all [[RBlock]]s created during bytecode generation--and calls the Lua function [[relocate_block]] on each value.
This Lua function is actually a C function registered with Lua: [[lua_relocate_block]].

<<perform bytecode relocation>>=
  /* relocate all named sections */
  lua_error_handle(lua_table_foreach(L, unit->section_table, "relocate_block"),
                   "<internal code>");

  /* relocate special block */
  lua_pushusertag(L, (void *) unit->def_section, lua_RBlock_tag);
  lua_relocate_block(L);
@ 

Now, each of the [[RBlock]]s we created to store bytecode have been assigned addresses although their contents have yet to be copied to their final memory locations.
We must then make sure to apply all closures stored away in the C [[closures]] array to propagate permanent addresses to all [[RAddr]]s and [[RLabel]]s.

<<perform bytecode relocation>>=
  /* apply closures in closure table */
  for (cl = closures_base; cl < closures_free; cl++) {
    apply_closure(*cl, cl_emitm, error);
  }

  /* reclaim memory */
  closures_free = closures_base;
@ 

Finally, we must make sure to actually copy the contents of the relocated [[RBlock]]s into their permanent memory locations using a helper C function ([[lua_copy_block_contents]]) registered with Lua.

<<perform bytecode relocation>>=
  /* copy blocks */
  lua_error_handle(lua_table_foreach(L, unit->section_table, 
                                     "copy_block_contents"), 
                   "<internal code>");
  
  /* copy special block */
  lua_pushusertag(L, (void *) unit->def_section, lua_RBlock_tag);
  lua_copy_block_contents(L);
@

% ----------------------------------------------------------------------------
\subsection{Bytecode Interpreting}
% ----------------------------------------------------------------------------

% ----------------------------------------------------------------------------
\subsubsection{Initialization}
% ----------------------------------------------------------------------------

Finally, we get to the main part of the interpreter.  We start by initializing the internal state of the interpreter:

<<initialize interpreter internals, given suspended thread [[t]]>>=
  /* pc    is kept in thread t        */
  /* V     is kept global             */
  /* rho   is kept in thread t        */
  /* sp    is kept in thread t        */
  /* g     is kept global             */
  /* sigma is left implicit!          */
  /* A     is kept global             */
  /* u     is kept in thread t        */
  /* s     is kept in t->stackdata_X  */

  actptr      act;
  bytecodeptr pc;
  stack       locals;
  sptr        locals_end;
  datastack   stackdata;
  dataptr     stackdata_end;
  uid         u;

  assert(t != NULL);
  
  t->stack_free = (void *) (((actptr) t->stack_free) - 1);
  act = (actptr) t->stack_free;
  assert(act >= (actptr) t->stack_base);

  <<copy suspended state from [[act]] into local C variables>>

  /* we have to allocate memory for globals here */
  <<allocate memory for globals>>

  /* FIX reset global variables */
  curr_proc = NULL;
  values    = values_base - 1;
@ 

We copy out the stored, suspended state from [[act]] into local C variables for matters of efficiency (to reduce memory fetches).
This means, though, that the stored activation information will become out-of-date as we proceed through interpreting; we must make sure to update it when we have to leave the activation for any reason (calls, cuts, etc.).

<<copy suspended state from [[act]] into local C variables>>=
  pc            = act->pc;
  locals        = act->locals;
  locals_end    = act->locals;
  stackdata     = act->stackdata;
  stackdata_end = act->stackdata_end;
  u             = act->u;
@

By now we should know how many globals are used in the source {\PAL} code; this number has been stored in the global C variable [[num_globals]].
We [[malloc]] space for them.

<<allocate memory for globals>>=
  /* we know precisely how much to malloc for globals */
  if (globals == NULL) {
    if (num_globals <= 0 || num_globals == INVALID) {
      num_globals = 0;
    } else {
      globals = (value *) malloc(sizeof(value) * num_globals);
      mem_assert(globals);
    }
  }
@

% ----------------------------------------------------------------------------
\subsubsection{The Main Interpreting Loop}
% ----------------------------------------------------------------------------

For the main interpreting loop, we use the ``matching'' feature of the New Jersey Machine-Code Toolkit.  This code is pre-processed by the Toolkit and ends up in normal C format.

<<bytecode interpreting>>=
void run_interp(thread *t) {
  int            err_occurred = 0, 
                 done         = 0;
  unsigned char *next;

  <<initialize interpreter internals, given suspended thread [[t]]>>

  if (setjmp(errorjmp)) {
    fprintf(stderr, "error: experienced unrecoverable runtime error\n");
  } else {
    for (;;) {
      match [next] pc to
        <<matching statement>>
      | HALT              => {
                             cmm_err("fell off end of a C-- section");
                             }
      else cmm_err("unsupported instruction encoutered");
      endmatch

      if (err_occurred || done) break;
    }
  }
}
@ 

The bulk of the matching statement bodies follow from the operational semantics of the interpreter's instructions.
For ease of understanding, the relevant operational rules are reproduced above each instruction's matching statement.
The one thing we must make sure to do in the body of our matching statement is to advance the program counter ([[pc]]) to the proper address in memory.
The local C variable [[next]] is set to the address of the immediately next instruction, as stored in memory; control-flow instructions must do something more interesting than merely setting [[pc = next]], though.
@ 

Literal value pushes, local/global stores and fetches are all straightforward.
We push and pop values using our stack manipulation macros, and use the [[locals]] and [[globals]] arrays for local and global operations.

\useops{Literal}
<<matching statement>>=
    | PUSH(v)           => PUSH(VIEW(v, value), values);  pc = next;
@  

\useops{Fetch-Local}
\useops{Fetch-Global}
<<matching statement>>=
    | fetch_local(n)    => PUSH(locals[n], values);  pc = next;
    | fetch_global(n)   => PUSH(globals[n], values); pc = next;
@ 

\useops{Store-Local}
\useops{Store-Global}
<<matching statement>>=
    | store_local(n)    => locals[n] = POP(values);  pc = next;
    | store_global(n)   => globals[n] = POP(values); pc = next;
@ 

Guarded local and global stores require a little more work; we must see if the expected boolean is true or false with a simple [[if]] statement.

\useops{Guarded-Store-Local-True}
\useops{Guarded-Store-Local-False}
\useops{Guarded-Store-Global-True}
\useops{Guarded-Store-Global-False}
We first perform an underflow check to make sure that we can safely pop 2 values off the value stack (we do not use two sequential [[POP]]s here because that would introduce unnecessary intermediate pointer computations).
We [[VIEW]] the next-to-top stack element, which we expect to be a boolean value.
If we find the boolean is true, we store the top stack value (the value to be stored) in the proper location.
Either way, we must decrement the [[values]] pointer by 2 to simulate the popping of 2 values off the value stack.

<<matching statement>>=
    | gstore_local(n)   => UNDERFLOW_CHECK(values, 2);
                           if (VIEW(STACK_ELT(values, -1), bool)) {
                             STACK_ELT(values, 0) = locals[n];
                           }
                           values -= 2;
                           pc = next;

    | gstore_global(n)  => UNDERFLOW_CHECK(values, 2);
                           if (VIEW(STACK_ELT(values, -1), bool)) {
                             STACK_ELT(values, 0) = globals[n];
                           }
                           values -= 2;
                           pc = next;
@ 
Memory space fetches, stores, and guarded stores are more complex.
They theoretically involve correctly aggregating / breaking up data into small pieces, arranged by the specified byte-order.
For now, we only support the natural byte-order of the machine on which the interpreter is running (i.e., little-endian byte-order on x86 machines).

\useops{Fetch}
\useops{Store}
\useops{Guarded-Store-True}
\useops{Guarded-Store-False}
<<matching statement>>=
    | FETCH(sz,bo,al)   => {
                           /* FIX actually do something with sz,bo,al */
                           assert(bo == DEF_BYTE_ORDER);
                           assert(al == DEF_ALIGN);
                           assert(sz >  0);
                           <<fetch value from given address>>
                           pc = next;
                           }
    | STORE(sz,bo,al)   => {
                           assert(bo == DEF_BYTE_ORDER);
                           assert(al == DEF_ALIGN);
                           assert(sz >  0);
                           <<store given value at given address>>
                           values -= 2;
                           pc = next;
                           }
    | GSTORE(sz,bo,al)  => {
                           assert(bo == DEF_BYTE_ORDER);
                           assert(al == DEF_ALIGN);
                           assert(sz >  0);
                           UNDERFLOW_CHECK(values, 3);
                           if (VIEW(STACK_ELT(values, -2), bool)) {
                             <<store given value at given address>>
                           }
                           values -= 3;
                           pc      = next;
                           }
@ 

For now, we simply fetch and store by dereferencing pointers.

<<fetch value from given address>>=
  {
    value *fetched       = VIEW(STACK_ELT(values, 0), value *);
    STACK_ELT(values, 0) = *fetched;
  }
@ 
<<store given value at given address>>=
  {
    value *tostore       = VIEW(STACK_ELT(values, -1), value *);
    *tostore             = STACK_ELT(values, 0);
  }
@ 

The argument to the operator application instruction should be a pointer to an [[operator]] record.
We simply dereference the function pointer stored within this record, and pass the function [[values]].
Operator implementation functions return a new [[sptr]] so we set [[values]] to the result of this function call.

\useops{ApplyOp}
<<matching statement>>=
    | APPLY_OPERATOR(o) => values = (((operator *) o)->f)(values); 
                           /* REMOVE this print_value_stack call */
                           print_value_stack(values, values_base, "values");
                           pc = next;
@

Fetching and storing from the argument space is not difficult.
\useops{Push-Arg}
\useops{Pop-Arg}
<<matching statement>>=
    /* ARGS OK */

    | STORE_ARG(n)      => cmm_assert(arguments + n < arguments_limit,
                                  "invalid register index to argument space");
                           arguments[n] = POP(values); pc = next;
    | FETCH_ARG(n)      => cmm_assert(arguments + n < arguments_limit,
                                  "invalid register index to argument space");
                           PUSH(arguments[n], values); pc = next;
@ 

For goto and branches, we simply conditionally (or unconditionally in the case of goto) assign a new value to [[pc]].

\useops{Goto}
<<matching statement>>=
    | GOTO              => { 
                           value v = POP(values);
                           pc      = VIEW(v, bytecodeptr);
                           }
@ 
\useops{CBranchT-True}
\useops{CBranchT-False}
\useops{CBranchF-True}
\useops{CBranchF-False}
<<matching statement>>=
    | CBRANCHT(a)       => {
                           value v = POP(values);
                           if (VIEW(v, bool)) {
                             pc = (bytecodeptr) a;
                           } else { pc = next; }
                           }
    | CBRANCHF(a)       => {
                           value v = POP(values);
                           if (!(VIEW(v, bool))) {
                             pc = (bytecodeptr) a;
                           } else { pc = next; }
                           }
@ 
\useops{BranchTF-True}
\useops{BranchTF-False}
<<matching statement>>=
    | BRANCHTF(a, b)    => {
                           value v = POP(values);
                           pc      = (bytecodeptr) (VIEW(v,bool) ? a : b);
                           }
@ 

\useops{PushSymbol}
The encoding function [[lua_CMM_push_symbol]] writes a pointer to a [[CMM_label]] in memory; here, we must actually find the address or structure the label represents.
<<matching statement>>=
    | PUSH_SYMBOL(s)    => {
                           CMM_label *lbl = (CMM_label *) s;
                           value      v;

                           if (lbl == NULL) {
                             cmm_err("cannot push value of undefined symbol");
                           }

                           switch (lbl->ty) {
                           case CMM_LABEL:
                             {
                             unsigned loc = location(lbl->lbl.raddr);
                             v = VIEW(loc, value);
                             break;
                             }
                           case CMM_PROCEDURE:
                           case CMM_CONTINUATION:
                           case CMM_CFUNCTION:
                             v = VIEW(s, value);
                             break;
                           default:
                             cmm_err("internal label error");
                           }

                           PUSH(v, values);
                           pc = next;
                           }
@ 

We implement both {\PAL} and foreign C procedure calls with one matching case.

<<matching statement>>=
    | CALL(a)           => {
                           value        v;
                           CMM_label   *lbl;

                           v    = POP(values);
                           lbl  = VIEW(v, CMM_label *);
                           ASSERT_EMPTY(values);
                           if (lbl->ty == CMM_CFUNCTION) {
                             <<perform C call>>
                           } else if (lbl->ty != CMM_PROCEDURE) {
                             cmm_err("target label not a procedure");
                           } else {
                             <<perform {\PAL} call>>
                           }
                           }
@ 

First, to implement a {\PAL} procedure call, we must store information about the present activation in the current thread's activation stack and perform some pointer bookkeeping.
We pop a pointer to a C [[procedure]] structure off the value stack, and dereference it to find needed information about the callee (so we can properly allocate new memory for locals and stackdata on its thread's stack.

\useops{CMMCall}
<<perform {\PAL} call>>=
                           {
                             actptr       saved;
                             annotations *ann  = (annotations *) a;
                             procedure   *proc = lbl->lbl.proc;

                             assert(ann  != NULL);
                             assert(proc != NULL);

                             <<save current activation info in a stack record>>

                             <<allocate and update memory for new activation>>
                           }
@

To save the caller's activation record, we simply use the next free [[activation]] location in thread [[t]]'s stack and copy over the necessary pointers and information.

<<save current activation info in a stack record>>=
                           /* save necessary info in activation record */
                           saved          = (actptr) t->stack_free;
                           t->stack_free  = ((actptr) t->stack_free) + 1;
                           if (t->stack_free > t->stack_limit)
                             cmm_err("ran out of stack space");

                           saved->pc            = next;
                           saved->locals        = locals;
                           saved->locals_end    = locals_end;
                           saved->stackdata     = stackdata;
                           saved->stackdata_end = stackdata_end;
                           saved->kappa         = ann;
                           saved->u             = u;
@

We allocate memory for locals and stackdata from the thread's stack, create a fresh unique identifier using helper [[new_uid]], and set [[pc]] to the permanent address of the [[RAddr]] stored in [[proc]].
When the matching statement is executed once more during the next cycle of the [[for]] loop, {\PAL} code interpreting will seamlessly continue at the next procedure.

<<allocate and update memory for new activation>>=
                          /* allocate memory, update state of the machine */
                           assert(location_known(proc->raddr));
                           pc            = (bytecodeptr) location(proc->raddr);

                           locals        = t->stack_free;
                           t->stack_free = (void *) (((sptr) t->stack_free) +
                                                     proc->num_locals);
                           locals_end    = (sptr) (t->stack_free);
                           assert(t->stack_free <= t->stack_limit);

                           stackdata     = t->stack_free;
                           t->stack_free = (void *)(((dataptr) t->stack_free) +
                                                   proc->stackdata_size);
                           stackdata_end = (dataptr) (t->stack_free);
                           assert(t->stack_free <= t->stack_limit);

                           /* CALLEE */
                           saved->callee = (actptr) stackdata_end;

                           u             = new_uid(t);
@

C calls can be tricky to perform because we need to specially call any registered C function by casting a stored function pointer to the correct C type and dereferencing it.
Unfortunately we cannot support an infinite number of C function types.

\useops{CCall}
<<perform C call>>=
                           {
                           c_caller      call_helper;
                           void         *f;
                           lua_State    *L = c_func_table.L;
                           unsigned int  i = lbl->lbl.cfunc_id;

                           <<[[call_helper]] $\leftarrow$ pointer to C caller>>
                           <<[[f]] $\leftarrow$ pointer to C function>>

                           <<use [[call_helper]] to call [[f]]>>

                           pc = next;
                           }
@

Retrieving [[call_helper]] and [[f]] simply involves some queries to Lua tables.

<<[[call_helper]] $\leftarrow$ pointer to C caller>>=
                           lua_pushtable(L, c_func_table);
                           lua_rawgeti(L, -1, i);
                           lua_assert_istable(L, -1, 
                                              "internal error with c call");

                           lua_pushstring(L, C_FUNC_CALLER);
                           lua_gettable(L, -2);
                           if (!lua_isuserdata(L, -1) ||
                               lua_tag(L, -1) != lua_c_sig_tag ||
                               (call_helper = (c_caller) 
                                               lua_touserdata(L, -1)) == NULL)
                           {
                             lua_pop(L, 1); /* pop bogus val */
                             cmm_err("internal error with c call");
                           }
                           lua_pop(L, 1);   /* pop call_helper pointer */
@
<<[[f]] $\leftarrow$ pointer to C function>>=
                           lua_pushstring(L, C_FUNC_POINTER);
                           lua_gettable(L, -2);
                           if (!lua_isuserdata(L, -1) ||
                               lua_tag(L, -1) != lua_c_func_tag ||
                               (f = lua_touserdata(L, -1)) == NULL)
                           {
                             lua_pop(L, 3); /* pop bogus val and 2 tables */
                             cmm_err("internal error with c call");
                           }
                           lua_pop(L, 3);   /* pop pointer and 2 tables */
@

We make a call to [[call_helper]], which takes care of arranging the argument stack.
We simply pass the argument stack in and get it back out again (with the pointer to the top of the stack possibly altered).

<<use [[call_helper]] to call [[f]]>>=
                           /* ARGS OK */

                           arguments = call_helper(arguments, f);
@ 

{\PAL} tail calls are easier to implement than regular {\PAL} procedure calls because we need not save the activation record of the calling activation.
In fact, we must effectively kill off the calling activation (we call [[dies_uid]] to signal the death of the activation).
Once more, we pop a [[procedure]] struct pointer off the value stack for information about the callee.

\useops{CMMTailCall}
<<matching statement>>=
    | CMM_TAIL_CALL     => {
                           value      v;
                           CMM_label *lbl;
                           procedure *proc;

                           v    = POP(values);
                           lbl  = VIEW(v, CMM_label *);
                           ASSERT_EMPTY(values);

                           if (lbl->ty != CMM_PROCEDURE) {
                             cmm_err("target label not a procedure");
                           }
                           proc = lbl->lbl.proc;
                           assert(proc != NULL);

                           assert(location_known(proc->raddr));
                           pc   = (bytecodeptr) location(proc->raddr);

                           <<reuse dead local memory for new activation>>

                           /* deal with uid : */
                           dies_uid(u);
                           u = new_uid(t);
                           }
@ 

Because the old activation dies, we can simply reuse the memory chunk it used on its thread's stack for [[locals]] and [[stackdata]].
We do need to make sure, though, that there is enough room on this stacks for the new activation in the case that the new activation needs more local stack memory than the dying one.

<<reuse dead local memory for new activation>>=
                           stackdata     = (datastack) (locals_end = locals + 
                                                         proc->num_locals);
                           stackdata_end = stackdata + proc->stackdata_size;
                           t->stack_free = (void *) stackdata_end;
                           assert(t->stack_free <= t->stack_limit);
@ 

We implement both return rules with one matching case.
\useops{ReturnDefault}
\useops{ReturnAlt}
<<matching statement>>=
    | RETURN(i, count)  => { 
                           actptr     caller;
                           lua_State *L;

                           ASSERT_EMPTY(values);
                           assert(i <= count);
                           
                           /* FIX for now we allow walking off stack */
                           if (locals == t->stack_base) {
                             /* reclaim dead space */
                             interval_list_free(t->dead_list);
                             t->stack_free = t->stack_base;

                             /* THIS COULD BE DANGEROUS */
                             free(t);

                             printf("[returned from specified procedure].\n");
                             done = 1;
                             break;
                           }
                           caller        = ((actptr) locals) - 1;

                           /* reclaim dead space */
                           t->stack_free = caller;

                           <<restore activation record stored at [[caller]]>>

                           dies_uid(u);
                           u = caller->u;
                           }
@ 

We simply copy pointers to restore information from the activation record stored at [[caller]].

<<restore activation record stored at [[caller]]>>=
                           L = caller->kappa->also_returns_to.L;
                           lua_pushtable(L, caller->kappa->also_returns_to);

                           /* FIX we here assert that count = |returns| */
                           assert(count == lua_getn(L, -1));

                           if (i == count) {
                             pc = caller->pc;
                           } else {
                             CMM_label *lbl;

                             /* Lua tables 1-indexed; returns are 0-indexed */
                             lua_rawgeti(L, -1, i + 1);
                             if (!lua_isuserdata(L, -1) ||
                                 lua_tag(L, -1) != lua_CMM_label_tag ||
                                 (lbl = lua_touserdata(L, -1)) == NULL ||
                                 !CMM_label_defined(lbl))
                             {
                               lua_pop(L, 2); /* pop bogus label, table */
                               cmm_err("invalid call-site label");
                             }
                             lua_pop(L, 1); /* pop label */

                             assert(location_known(CMM_label_raddr(lbl)));
                             pc = CMM_label_location(lbl);
                           }
                           lua_pop(L, 1); /* pop table */

                           locals         = caller->locals;
                           locals_end     = caller->locals_end;
                           stackdata      = caller->stackdata;
                           stackdata_end  = caller->stackdata_end;

                           caller->callee = NULL;
@

Next comes the cut instruction, one of the most difficult to implement.
We begin by popping off a [[continuation]] pointer from the value stack and making sure it represents a valid cut continuation.
We then save the current activation if the destination continuation is in a different thread and jump to the new thread.
We kill off all aborted activations (ones that are ``above'' [[cont->dest_act]] in the activation chain of the destination thread).
We restore state information from the destination activation and recover memory once used by the aborted activations.

\useops{Cut}
<<matching statement>>=
    | CUT               => {
                           value         v;
                           CMM_label    *lbl;
                           continuation *cont;
                           bytecodeptr   cont_pc;
                           actptr        saved;

                           v   = POP(values);
                           lbl = VIEW(v, CMM_label *);
                           ASSERT_EMPTY(values);

                           cont = lbl->lbl.cont;
                           cont_pc = CMM_label_location(lbl);

                           <<make sure [[cont]] is a valid cut continuation>>

                           <<save current info in a partial stack record>>
                           
                           if (cont->dest_act->u.thread != u.thread) {
                               /* jump over to destination thread */
                               t = find_thread(u);
                           } else if (cont->dest_act->u.frame == u.frame) {
                               /* if we're here, then we're cutting to a
                                  continuation in the current activation */
                               /* FIX : for now, just treat like GOTO */
                               pc = cont_pc;
                               continue;
                           }

                           <<kill off activations above [[dest_act]] in [[t]]>>
 
                           <<restore info from [[cont->dest_act]]>>

                           /* recover freed memory */
                           t->stack_free     = cont->dest_act;

                           }
@ 

We make sure that [[cont]] is a valid cut continuation by checking to see if the [[uid]] uniquely identifying [[cont->dest_act]] is still live.
Note that this is actually the main purpose of having [[uid]]s around in the interpreter.
We also must ensure that [[cont->dest_act]] was listed as a valid ``also cuts to'' continuation in the caller of the activation we were in at the beginning of the matching statement.

<<make sure [[cont]] is a valid cut continuation>>=
                           assert(cont != NULL);
                           assert(cont->dest_act != NULL);
                           cmm_assert(islive_uid(cont->u),
                                      "cannot cut to dead continuation");

                           /* FIX : look in kappa annotations in activation 
                              pointed to by called_by to make sure that
                              cont_pc is in kappa.also_cuts_to
                            */
@

If we are cutting to a continuation across different threads, we must make sure to save the cutting activation's information in a partial record (partial because there are no call-site annotations).
Remember that [[pc]] is the current program counter and that we must store away [[next]] so that we do not end up in an infinite loop.

<<save current info in a partial stack record>>=
                               /* save needed info in activation record */
                               saved = (actptr) t->stack_free;
                               t->stack_free = (void *) (saved + 1);
                               assert(t->stack_free <= t->stack_limit);

                               /*
                               saved = t->callstack_free++;
                               assert(t->callstack_free <= t->callstack_limit);
                               */ 

                               saved->pc            = next;
                               saved->locals        = locals;
                               saved->locals_end    = locals_end;
                               saved->stackdata     = stackdata;
                               saved->stackdata_end = stackdata_end;
                               /* we set kappa to NULL to signify partiality */
                               saved->kappa         = NULL;
                               saved->callee        = NULL;
                               saved->u             = u;
@

We next kill off all applications ``above'' [[dest_act]] in the activation chain of the destination thread.\footnote{When we say ``above'', we refer to the transitive closure of the following relation: a callee's activation is directly ``above'' its caller's activation if they are in the same thread.}

<<kill off activations above [[dest_act]] in [[t]]>>=
                           /* FIX if callee is NULL what does that mean? */
                           assert(cont->dest_act->callee != NULL);
                           dies_uid_range(
                                  (((actptr) (t->stack_free)) - 1)->u,
                                  (cont->dest_act->callee)->u);
@

Finally, restoring information from the destination activation is as simple as copying pointers and the old [[uid]].

<<restore info from [[cont->dest_act]]>>=
                           /* update state of machine */
                           pc            = cont_pc;
                           locals        = cont->dest_act->locals;
                           locals_end    = cont->dest_act->locals_end;
                           stackdata     = cont->dest_act->stackdata;
                           stackdata_end = cont->dest_act->stackdata_end;
                           u             = cont->dest_act->u;

                           cont->dest_act->callee = NULL;
@

As final matching cases, we interpret the structure-related instructions.
First comes [[DEFINE_PROC]].
Leaving a procedure definition as an instruction allows us to store a pointer to the procedure's activation record within all of its continuations.
This lets us quickly cut to the continuation without unnecessarily winding down the call stack.
The argument to the [[DEFINE_PROC]] constructor should be a [[procedure *]].
We need to store an activation pointer within each of the activations contained within the procedure.

<<matching statement>>=
    | DEFINE_PROC(p)    => {
                           procedure    *proc = (procedure *) p;
                           continuation *c;

                           for (c = proc->cont_list; c != NULL; c = c->next) {
                             c->dest_act = (actptr) t->stack_free;
                             c->u        = u;
                           }

                           curr_proc = proc;

                           pc = next;
                           }
@ 

And its brother, [[END_PROC]].

<<matching statement>>=
    | END_PROC()        => {
                           curr_proc = NULL;
                           }
@ 

Next, we deal with spans.

For [[BEGIN_SPAN]], we associate the given token with the given value in the span table.
Each token gets its own Lua table within the span table.
The value is stored in the last entry in the token's table.

<<matching statement>>=
    | BEGIN_SPAN(tok,v) => {
                           /* assume that we're in a procedure */
                           assert(curr_proc != NULL);

                           /* update current span information */
						   /*
                           span_table_push(curr_proc->span_table, tok, v);
						   */

                           pc = next;
                           }
@ 

For [[END_SPAN]] we simply remove the last entry from the token's table (within the span table).

<<matching statement>>=
    | END_SPAN(tok)     => {
                           /* assume that we're in a procedure */
                           assert(curr_proc != NULL);

                           /* update current span information */
/*
                           span_table_pop(curr_proc->span_table, tok);
*/
                           pc = next;
                           }
@

% ----------------------------------------------------------------------------
\subsection{Application Initialization}
% ----------------------------------------------------------------------------

Next, we proceed onto our [[cmm_interp_open]] and [[cmm_interp_close]] functions.
In [[cmm_interp_open]], we get everything ready for future source-code encoding and interpreting.
[[cmm_interp_close]] closes down the interpreter safely.

<<constant definitions>>=
#define DEF_VALSTACK_SIZE 256
#define DEF_ARGSPACE_SIZE 256
@ 

<<application initialization>>=
int cmm_interp_open(int valstack_size, int argspace_size)
{
  lua_State   *lua_interp;

  if (valstack_size <= 0) valstack_size = DEF_VALSTACK_SIZE;
  if (argspace_size <= 0) argspace_size = DEF_ARGSPACE_SIZE;

  /* FIX */
  if (argspace_size <= 4) argspace_size = 4;

  if (setjmp(errorjmp)) {
    fprintf(stderr, "error: unrecoverable error; quitting interpreter\n");
    return 1; /* signal error */
  } else {
    /* check basic C types */
    check_value_types();

    <<prepare for encoding library>>
    <<initialize a Lua interpreter>>
    <<initialize the {\PAL} interpreter>>
  }
  return 0;
}
void cmm_interp_close(void) {
  lua_State *lua_interp = assembly_units_table.L;

  <<gracefully shut down>>
}
@

% ----------------------------------------------------------------------------
\subsubsection{Preparation and Initialization}
% ----------------------------------------------------------------------------

Initializing the {\PAL} interpreter involves a simple call to helper [[init_interp]].
This helper initializes the operator table and a few other things.

<<initialize the {\PAL} interpreter>>= 
  init_interp(lua_interp, valstack_size, argspace_size);
@ 

Before using the NJ Machine-Code Toolkit encoding library, we must first prepare by creating an array to store closures ([[RClosure]]s).

<<constant definitions>>=
#define DEF_CLOSURESARRAY_SIZE  1024
@ 
<<prepare for encoding library>>=
  closures_base = (RClosure *) malloc(DEF_CLOSURESARRAY_SIZE*sizeof(RClosure));
  mem_assert(closures_base);
  closures_free = closures_base;
  closures_limit = closures_base + DEF_CLOSURESARRAY_SIZE;
@ 

To initialize the Lua interpreter, we must initialize transactions with the Lua C library.
This is wrapped up in function [[init_lua_interp]], as defined in [[lualink.nw]].

<<initialize a Lua interpreter>>=
  lua_interp = init_lua_interp();
@ 

% ----------------------------------------------------------------------------
\subsection{Putting it Together}
% ----------------------------------------------------------------------------

Putting it all together, we have [[interp.m]], the C file with NJ Machine-Code Toolkit constructs that must first be preprocessed by the toolkit and then compiled.

<<interp.m>>=
#include "interp.h"

#include <cii/arena.h>
#include <assert.h>
#include <stdlib.h>
#include <stdarg.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include <setjmp.h>

#include "lualink.h"
#include "encode.h"
#include "ccall.h"
#include "operator.h"
#include "encoding.h"
#include "uid.h"
#include "types.h"
#include "span.h"
#include "stack.h"
#include "controlflow.h"

<<global variable definitions>>

<<utility functions>>

<<bytecode generation>>
<<bytecode interpreting>>

<<application initialization>>

<<standard library extensions>>
@ 

% ----------------------------------------------------------------------------
\subsection{Missing Details}
% ----------------------------------------------------------------------------

We left out a few minor details from the previous sections.
First come [[#define]] constants:
<<constant definitions>>=
#define INVALID         (-1)
@ 

And then come global variables:

<<global variable declarations>>=
extern  sptr   arguments;
extern  sptr   arguments_limit;

extern  sptr   values;
extern  stack  values_base;
extern  sptr   values_limit;

extern  int    num_globals;
extern  value *globals;
extern  int    verbosity;
@ 

<<global variable definitions>>=
sptr    values                = NULL;
stack   values_base           = NULL;
sptr    values_limit          = NULL;

/* ARGS OK */
sptr    arguments             = NULL;
sptr    arguments_limit       = NULL;

int     num_globals           = INVALID;
value  *globals               = NULL;
int     verbosity             = 0;
@

And finally a few functions that should be in the original C standard library
anyway, but that are only in ISO C99.

<<function prototypes>>=
#ifndef strcasecmp

int strcasecmp(const char *s1, const char *s2);

#endif /* strcasecmp */
@ 

<<standard library extensions>>=
#ifndef strcasecmp

int strcasecmp(const char *s1, const char *s2) {
  char     *u1 = (char *) malloc(sizeof(char) * (strlen(s1) + 1));
  char     *u2 = (char *) malloc(sizeof(char) * (strlen(s2) + 2));
  int       rc;
  unsigned  i;

  u1 = strcpy(u1, s1);
  u2 = strcpy(u2, s2);

  for (i = 0; i < strlen(u1); i++)
    u1[i] = toupper(u1[i]);
  for (i = 0; i < strlen(u2); i++)
    u2[i] = toupper(u2[i]);

  rc = strcmp(u1, u2);

  free(u1);
  free(u2);

  return rc;
}

#endif /* strcasecmp */
@ 

% ----------------------------------------------------------------------------
\paragraph{Machine-Dependent Details}
% ----------------------------------------------------------------------------

We must also remember to define aggregated fetch functions for the NJ Machine-Code Toolkit so it can read more than 8 bits of bytecode from memory at a time:

<<decode.fetch.BIG>>=
address type is "unsigned char *"
fetch 8  using "*%a"
fetch 16 using "%a[1] + (%a[0] << 8)"
fetch 32 using "%a[3] + (%a[2] << 8) + (%a[1] << 16) + (%a[0] << 24)"
@

<<decode.fetch.LITTLE>>=
address type is "unsigned char *"
fetch 8  using "*%a"
fetch 16 using "%a[0] + (%a[1] << 8)"
fetch 32 using "%a[0] + (%a[1] << 8) + (%a[2] << 16) + (%a[3] << 24)"
@

We also define a few constants in [[machine.h]] to provide information about the architecture on which the interpreter is currently being run.

<<machine.h.BIG>>=
#ifndef _MACHINE_H
#define _MACHINE_H

/* FIX :  the float types are here defined in a machine-dependent manner; */
typedef float       float32;
typedef double      float64;
typedef long double float96; /* this one doesn't work on liz */

typedef enum {
  ROUND_DOWN    = 00U,
  ROUND_UP      = 01U,
  ROUND_NEAREST = 02U,
  ROUND_ZERO    = 03U
} rounding_mode;

#define DEF_MEMSIZE    8
#define DEF_BYTE_ORDER BIG
#define DEF_ALIGN      4

typedef u_int32 Cmm_Word;
#endif /* _MACHINE_H */
@ 

<<machine.h.LITTLE>>=
#ifndef _MACHINE_H
#define _MACHINE_H
/* FIX :  the float types are here defined in a machine-dependent manner; */
typedef float       float32;
typedef double      float64;
typedef long double float96; /* this one doesn't work on liz */

typedef enum {
  ROUND_DOWN    = 00U,
  ROUND_UP      = 01U,
  ROUND_NEAREST = 02U,
  ROUND_ZERO    = 03U
} rounding_mode;

#define DEF_MEMSIZE    8
#define DEF_BYTE_ORDER LITTLE
#define DEF_ALIGN      1

typedef u_int32 Cmm_Word;
#endif /* _MACHINE_H */
@ 

% ----------------------------------------------------------------------------
\paragraph{Shut Down}
% ----------------------------------------------------------------------------

Finally, we have to properly shut down the interpreter (this code sits in [[cmm_interp_close]]).
<<gracefully shut down>>=

/* free allocated space */

free(values_base);       values_base   = NULL;
free(arguments);         arguments     = NULL;
free(globals);           globals       = NULL;

free(closures_base);     closures_base = NULL; 

    CMM_label_free_all();
         span_free_all();
     operator_free_all();
  controlflow_free_all();
assembly_unit_free_all();
           mc_free_all();

lua_close(lua_interp);
@

% ----------------------------------------------------------------------------
\section{Personal Endnotes}
% ----------------------------------------------------------------------------

I could probably remove \texttt{locals\_end} and \texttt{stackdata\_end} as local variables in function \texttt{run\_interp}; but they \emph{must} remain stored away in an \texttt{activation} record at all non-tail calls.

Do nullary operations have to have a type appended to their names?  (e.g., [[round_down_bits32]])

How should floating-pt computation with rounding best be done?

FIX FIX have to change [[ROTL]] and [[ROTR]] so they deal with the case when $d > x$.

Should macro-generated functions look like [[op_xor_bits16]] or like [[op_xor_bits16_bits16]] or like [[op_xor_bits16_bits16_bits16]] or something else...

[[label_new]] does NOT copy its string argument; do NOT free anything you pass off to [[label_new]]!

No way to push boolean right now, except for simply pushing 0 or 1 and making sure the bits work out.

Need to add citations!!!

Look through standard C header files / libraries for info on bit-standardized types: William Kahan web page, book down in the lab.

Use CII: maybe sequences to store closure pointers, check out Hanson's [[malloc]] interface (that allows debugging), maybe rings for the dead set, look at dvars and [[array_t]].

Only procedures, declarations, and other sections may be in toplevel ``section.''

Make clear that what I mean by an unnamed section is actually just the toplevel part of the assembly unit (i.e., declarations and procedures not in a section).

Don't we have to free [[RBlock]]s when we've finished copying them?

We have to release all lua references when done?

Consider making use of the [[lua_State *]] in the [[table]] structure.

How should we handle [[return]]s from the first procedure interpreted; that is, if our interpreter starts code execution by running a procedure named [[main]], how should it handle a [[return]] from procedure main?

Use ``higher-order'' macros to declare, define and register operator implementations (instead of the current [[#undef]] business).

When we push values, how do we store them?  As what kind of [[bits]]$k$ value?
I think [[lua_CMM_push_literal]] needs some help in this respect.

Document that tables sent to Lua function [[CMM_call]] (as call-site annotations) are used internally by the encoder/interpreter and that changing them would be dangerous.

Do we have to handle [[never returns]] annotations?

Do we need to make sure that continuations are not defined outside of procedures (by testing if [[curr_proc]] is [[NULL]])?

Look at pools / regions.

Convert C loop to Lua.

Remember that spans can only be placed in a section; consider asserting this.

Quote from manual: \emph{All separately compiled modules must have} identical \emph{top-level variable declarations}.

\section{To Do Immediately}
Consider changing operator representation/implementation so that OP bytecode does not need to carry around a 32-bit value (right now it carries around an (operator *)).

Figure out how to get initialized data to work when given as a string or some other value.

Use dynamic arrays!  Stop with this assertion failure business.

Figure out what's up with [[curr_proc]] during interpreting time.

For what kind of calls do we have to bundle up the current activation in a half-activation?
Only for cuts or for C calls as well?

Where do we free threads?

We should apply closures before each interpreting run, not after each loading run!!!  What about imports??

% end file
\nwfilename{interp.nw}
\bibliographystyle{alpha}
\bibliography{qc--} 
\end{document}
