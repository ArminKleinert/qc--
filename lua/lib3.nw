% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Modules for building Lua libraries}

In general, a library can add new types, global mutable state, and new
functions to an interpreter.
Interpreters are typically built by combining multiple libraries, and
the combination determines the [[userdata]] types
ultimately used in the interpreter's values.

We encourage the use of parameterized modules so that libraries can be
combined easily.  There is some run-time cost for the generality, but
it can be minimized as discussed below.

Building the interpreter takes place in three phases:
\begin{enumerate}
\item
Different libraries are combined to determine the ultimate
[[userdata]] and [[state]] types.
The combination is then used to build an interpreter, which matches
signature [[INTERP]].
This step happens at compile time.
\item
The full interpreter is passed back to each library, so that each
library can build a function suitable for initializing interpreters of
built with those types.
This step also happens at compile time.
\item
A fresh state is created and all the initialization functions are
called, building a new, fully initialized interpreter.
This step happens at run time, as often as desired---multiple
interpreters coexist peacefully.
\end{enumerate}
@
Here is everything that a library is deemed to need to know about an
interpreter.
This signature could be extended if necessary.
The information is divided in two pieces: there is one [[INTERP]]
piece,  which looks the same to all libraries.
But each library sees its own [[VIEW]] piece, which provides functions
that map to and from the type and state provided by that library.
<<signatures>>=
module type USERTYPE = sig
  type 'a t                             (* type parameter will be Lua value *)
  val tname : string  (* name of this type, for projection errors *)
  val eq : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
  val to_string : ('a -> string) -> 'a t -> string
end

module type CORE = sig (* need to extend to full interpreter core *)
  module V : Luavalue.S
  val fallback : string -> V.state -> V.value list -> V.value list
end

module type LIB' = functor
 (C : CORE) -> sig val init : C.V.state -> unit end

@ 
In principle, there could be four kinds of libraries:
a [[BARE]] library uses only existing types and state;
a [[FULL]] library adds both a new type and new state;
a \emph{stateful} library could add only a new state; and
a \emph{typeful} library could add only a new type.
This interface currently supports only two of the four alternatives,
but the others could be added easily enough.
Each alternative requires its own view signature.
<<lib3.mli>>=
<<signatures>>
@ 
<<signatures>>=
module type TYPEVIEW = sig
  type 'a t
  module U : USERTYPE
  val postmap : ('a t, 'b) Luavalue.ep -> ('b -> string -> 'a U.t)
                -> ('a U.t, 'b) Luavalue.ep
end

module type COMBINED_TYPE = sig
  include USERTYPE
  module type VIEW = TYPEVIEW with type 'a t = 'a t
  module T1  : VIEW
  module T2  : VIEW
  module T3  : VIEW
  module T4  : VIEW
  module T5  : VIEW
  module T6  : VIEW
  module T7  : VIEW
  module T8  : VIEW
  module T9  : VIEW
  module T10 : VIEW
end
@ 
<<lib3.mli>>=
module Lib : sig
  module type TYPEFUL = sig
    module T : TYPEVIEW (* any of the types on which lib depends,
                           which must all share 'a t *)
    module M : functor (C : CORE with type 'a V.userdata' = 'a T.t) -> sig
      val init : C.V.state -> unit
    end
  end
  module type BARE = 
    functor (C : CORE) -> sig
      val init : C.V.state -> unit
    end
  module Extend (L : BARE) (T : TYPEVIEW) : TYPEFUL with module T = T
end


module Combine : sig
  module T10 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE)
             (T5 : USERTYPE) (T6 : USERTYPE) (T7 : USERTYPE) (T8 : USERTYPE) 
             (T9 : USERTYPE) (T10 : USERTYPE)
   : COMBINED_TYPE with module T1.U = T1 and module T2.U = T2 and module T3.U = T3
                   and  module T4.U = T4 and module T5.U = T5 and module T6.U = T6
                   and  module T7.U = T7 and module T8.U = T8 and module T9.U = T9
                   and  module T10.U = T10 
  <<similar specifications for [[T1]] to [[T9]]>>
  module L10 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L6 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L7 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L8 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L9 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L10 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t) :
    Lib.TYPEFUL with type 'a T.t = 'a L1.T.t
  <<similar specifications for [[L1]] to [[L9]]>>
end
module Unused : sig
  module Type  : USERTYPE
  module Bare   : Lib.BARE
  module Typeful (T : TYPEVIEW) : Lib.TYPEFUL with module T = T
end
(*module Convert (L : LIB) : Lua.Lib.FULL*)

@ As is typical, it's less efficient to string together a bunch of
pairs than it is to build larger tuples.
Perhaps one day soon we will provide more alternatives---perhaps by
generating them automatically.
That's why we've left room for more sub-modules of [[Combine]].
@
\section{Implementation}

If you understand the interfaces, there's nothing of interest here.
It's all bookkeeping.
<<lib3.ml>>=
<<signatures>>
module Lib = struct
  <<[[Lib]] contents>>
end
@ 
<<lib3.ml>>=
module Unused = struct
  module Type : USERTYPE = struct
    type 'a t = unit
    let tname = "unused type"
    let eq _ x y = true
    let to_string _ _ = "<this can't happen -- value of unused type>"
  end (* Type *)

  module Bare =
      functor (C : CORE) -> struct
        let init g = ()
      end (*Unused.Bare*)

  module Typeful (T : TYPEVIEW) =
    struct
      module T = T
      module M (C : CORE with type 'a V.userdata' = 'a T.t) = struct
        let init g = ()
      end (*M*)
    end (*Unused.Typeful*)
end

module Combine = struct
  <<[[Combine]] contents>>
end
@
<<[[Lib]] contents>>=
  module type TYPEFUL = sig
    module T : TYPEVIEW (* any of the types on which lib depends,
                           which must all share 'a t *)
    module M : functor (C : CORE with type 'a V.userdata' = 'a T.t) -> sig
      val init : C.V.state -> unit
    end
  end
  module type BARE = 
    functor (C : CORE) -> sig
      val init : C.V.state -> unit
    end
@
<<[[Lib]] contents>>=
module Extend (L : BARE) (T : TYPEVIEW) : TYPEFUL with module T = T   =
    struct
      module T = T
      module M (C : CORE with type 'a V.userdata' = 'a T.t) = struct
        module M' = L (C)
        let init g = M'.init g
      end (*M*)
    end (*Extend*)
@ 
<<[[Combine]] contents>>=
  module T10 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE)
             (T5 : USERTYPE) (T6 : USERTYPE) (T7 : USERTYPE) (T8 : USERTYPE) 
             (T9 : USERTYPE) (T10 : USERTYPE)
   : COMBINED_TYPE with module T1.U = T1 and module T2.U = T2 and module T3.U = T3
                   and  module T4.U = T4 and module T5.U = T5 and module T6.U = T6
                   and  module T7.U = T7 and module T8.U = T8 and module T9.U = T9
                   and  module T10.U = T10 =
  struct
    type 'a t =
      | T1 of 'a T1.t
      | T2 of 'a T2.t
      | T3 of 'a T3.t
      | T4 of 'a T4.t
      | T5 of 'a T5.t
      | T6 of 'a T6.t
      | T7 of 'a T7.t
      | T8 of 'a T8.t
      | T9 of 'a T9.t
      | T10 of 'a T10.t
    type 'a alias_for_t = 'a t
    let allnames = [T1.tname; T2.tname; T3.tname; T4.tname; T5.tname;
                    T6.tname; T7.tname; T8.tname; T9.tname; T10.tname]
    let tname =
      let add t ts =
        if t = Unused.Type.tname then ts
        else match ts with
        | Some names -> Some (names ^ " or " ^ t)
        | None -> Some t
      in List.fold_right add allnames None
    let tname = match tname with Some n -> n | None -> Unused.Type.tname

    let eq eqvs x y = match x, y with
    | T1 x, T1 y -> T1.eq eqvs x y
    | T2 x, T2 y -> T2.eq eqvs x y
    | T3 x, T3 y -> T3.eq eqvs x y
    | T4 x, T4 y -> T4.eq eqvs x y
    | T5 x, T5 y -> T5.eq eqvs x y
    | T6 x, T6 y -> T6.eq eqvs x y
    | T7 x, T7 y -> T7.eq eqvs x y
    | T8 x, T8 y -> T8.eq eqvs x y
    | T9 x, T9 y -> T9.eq eqvs x y
    | T10 x, T10 y -> T10.eq eqvs x y
    | _, _ -> false

    let to_string vs x = match x with
    | T1 x -> T1.to_string vs x
    | T2 x -> T2.to_string vs x
    | T3 x -> T3.to_string vs x
    | T4 x -> T4.to_string vs x
    | T5 x -> T5.to_string vs x
    | T6 x -> T6.to_string vs x
    | T7 x -> T7.to_string vs x
    | T8 x -> T8.to_string vs x
    | T9 x -> T9.to_string vs x
    | T10 x -> T10.to_string vs x
        
  module type VIEW = TYPEVIEW with type 'a t = 'a t
  module V = Luavalue
  module T1 = struct
    type 'a t = 'a alias_for_t
    module U = T1
    let postmap (upper : ('a t, 'b) V.ep) fail =
      { V.embed   = (fun (x : 'a U.t) -> upper.V.embed (T1 x))
      ; V.project = (fun x -> match upper.V.project x with
                    | T1 x -> x
                    | _ -> fail x U.tname)
      } 
  end
  <<nested [[T2]]..[[T10]] in [[Combine.T10]]>>
  end (* Combine.T10 *)
  <<definitions of [[Combine.T1]] through [[Combine.T9]]>>
@ 
@ 
<<lib3.ml>>=
@ 
<<[[Combine]] contents>>=
  module L10 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L6 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L7 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L8 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L9 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L10 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t) :
    Lib.TYPEFUL with type 'a T.t = 'a L1.T.t   = 
  struct
    module T = L1.T
    module M  (C : CORE with type 'a V.userdata' = 'a T.t) = struct
      module M1 = L1.M(C)
      module M2 = L2.M(C)
      module M3 = L3.M(C)
      module M4 = L4.M(C)
      module M5 = L5.M(C)
      module M6 = L6.M(C)
      module M7 = L7.M(C)
      module M8 = L8.M(C)
      module M9 = L9.M(C)
      module M10 = L10.M(C)
      let init g = M1.init g; M2.init g; M3.init g; M4.init g; M5.init g;
                   M6.init g; M7.init g; M8.init g; M9.init g; M10.init g
    end (*Combine.L10.M*)
  end (* Combine.L10*)
@
<<old lib3.ml>>=
module ConvertType (T : USERTYPE) : Lua.USERDATA with type 'a t = 'a T.t = struct
    type 'a t = 'a T.t
    let tname = T.tname
    let eq = T.eq
    let to_string = T.to_string
    type 'a state = int
    let state () = 3
end

module Convert (T : Client.T) : Lua.Lib.FULL = struct
    module U = ConvertType(T.T)
    module M (This : Lua.Lib.FULL_VIEW with type 'a t = 'a T.T.t and type 'a
state = 'a U.state) = struct
        module Typeview : TYPEVIEW with module I.V = This.Interp.V and type
'a U.t = 'a T.T.t = struct
            module I = This.Interp
            module U = T.T
            let map = This.map
        end
        module Init = T.Make (This.Interp) (Typeview)

        let init = Init.init
    end
end

module EmptyT : Client.T = struct
    module T : USERTYPE = struct
        type 'a t = unit
        let tname = "EMPTY Client.T"
        let eq _ x y = x = y
        let to_string _ _ = "EMPTY Client.T"
    end

    module Make (Interp : INTERP)
                (T' : TYPEVIEW with module U = T and module I = Interp)
                : INIT with type state = Interp.V.state = struct
        type state = Interp.V.state
        let init _ = ()
    end
end
@

<<nested [[T2]]..[[T10]] in [[Combine.T10]]>>=
  module T2 = struct
    type 'a t = 'a alias_for_t
    module U = T2
    let postmap upper fail =
      { V.embed   = (fun x -> upper.V.embed (T2 x))
      ; V.project = (fun x -> match upper.V.project x with
                    | T2 x -> x
                    | _ -> fail x U.tname)
      } 
  end

  module T3 = struct
    type 'a t = 'a alias_for_t
    module U = T3
    let postmap upper fail =
      { V.embed   = (fun x -> upper.V.embed (T3 x))
      ; V.project = (fun x -> match upper.V.project x with
                    | T3 x -> x
                    | _ -> fail x U.tname)
      } 
  end

  module T4 = struct
    type 'a t = 'a alias_for_t
    module U = T4
    let postmap upper fail =
      { V.embed   = (fun x -> upper.V.embed (T4 x))
      ; V.project = (fun x -> match upper.V.project x with
                    | T4 x -> x
                    | _ -> fail x U.tname)
      } 
  end

  module T5 = struct
    type 'a t = 'a alias_for_t
    module U = T5
    let postmap upper fail =
      { V.embed   = (fun x -> upper.V.embed (T5 x))
      ; V.project = (fun x -> match upper.V.project x with
                    | T5 x -> x
                    | _ -> fail x U.tname)
      } 
  end

  module T6 = struct
    type 'a t = 'a alias_for_t
    module U = T6
    let postmap upper fail =
      { V.embed   = (fun x -> upper.V.embed (T6 x))
      ; V.project = (fun x -> match upper.V.project x with
                    | T6 x -> x
                    | _ -> fail x U.tname)
      } 
  end

  module T7 = struct
    type 'a t = 'a alias_for_t
    module U = T7
    let postmap upper fail =
      { V.embed   = (fun x -> upper.V.embed (T7 x))
      ; V.project = (fun x -> match upper.V.project x with
                    | T7 x -> x
                    | _ -> fail x U.tname)
      } 
  end

  module T8 = struct
    type 'a t = 'a alias_for_t
    module U = T8
    let postmap upper fail =
      { V.embed   = (fun x -> upper.V.embed (T8 x))
      ; V.project = (fun x -> match upper.V.project x with
                    | T8 x -> x
                    | _ -> fail x U.tname)
      } 
  end

  module T9 = struct
    type 'a t = 'a alias_for_t
    module U = T9
    let postmap upper fail =
      { V.embed   = (fun x -> upper.V.embed (T9 x))
      ; V.project = (fun x -> match upper.V.project x with
                    | T9 x -> x
                    | _ -> fail x U.tname)
      } 
  end

  module T10 = struct
    type 'a t = 'a alias_for_t
    module U = T10
    let postmap upper fail =
      { V.embed   = (fun x -> upper.V.embed (T10 x))
      ; V.project = (fun x -> match upper.V.project x with
                    | T10 x -> x
                    | _ -> fail x U.tname)
      } 
  end
@ 
<<similar specifications for [[L1]] to [[L9]]>>=
  module L1 (L1 : Lib.TYPEFUL)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t
  module L2 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t
  module L3 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t
  module L4 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t
  module L5 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t
  module L6 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L6 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t
  module L7 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L6 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L7 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t
  module L8 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L6 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L7 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L8 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t
  module L9 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L6 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L7 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L8 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L9 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t
@
<<[[Combine]] contents>>=
  module L1 (L1 : Lib.TYPEFUL)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t   = 
    L10 (L1) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T))
  module L2 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t   = 
    L10 (L1) (L2) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T))
  module L3 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t   = 
    L10 (L1) (L2) (L3) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T))
  module L4 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t   = 
    L10 (L1) (L2) (L3) (L4) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T))
  module L5 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t   = 
    L10 (L1) (L2) (L3) (L4) (L5) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T))
  module L6 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L6 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t   = 
    L10 (L1) (L2) (L3) (L4) (L5) (L6) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T))
  module L7 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L6 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L7 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t   = 
    L10 (L1) (L2) (L3) (L4) (L5) (L6) (L7) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T))
  module L8 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L6 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L7 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L8 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t   = 
    L10 (L1) (L2) (L3) (L4) (L5) (L6) (L7) (L8) (Unused.Typeful(L1.T)) (Unused.Typeful(L1.T))
  module L9 (L1 : Lib.TYPEFUL)
    (L2 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L3 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L4 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L5 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L6 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L7 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L8 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
    (L9 : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t)
  : Lib.TYPEFUL with type 'a T.t = 'a L1.T.t   = 
    L10 (L1) (L2) (L3) (L4) (L5) (L6) (L7) (L8) (L9) (Unused.Typeful(L1.T))
<<similar specifications for [[T1]] to [[T9]]>>=
module T1 (T1 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1
module T2 (T1 : USERTYPE) (T2 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2
module T3 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3
module T4 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4
module T5 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE) (T5 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4 with module T5.U = T5
module T6 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE) (T5 : USERTYPE) (T6 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4 with module T5.U = T5 with module T6.U = T6
module T7 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE) (T5 : USERTYPE) (T6 : USERTYPE) (T7 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4 with module T5.U = T5 with module T6.U = T6 with module T7.U = T7
module T8 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE) (T5 : USERTYPE) (T6 : USERTYPE) (T7 : USERTYPE) (T8 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4 with module T5.U = T5 with module T6.U = T6 with module T7.U = T7 with module T8.U = T8
module T9 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE) (T5 : USERTYPE) (T6 : USERTYPE) (T7 : USERTYPE) (T8 : USERTYPE) (T9 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4 with module T5.U = T5 with module T6.U = T6 with module T7.U = T7 with module T8.U = T8 with module T9.U = T9
@
<<definitions of [[Combine.T1]] through [[Combine.T9]]>>=
module T1 (T1 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1   = 
    T10 (T1) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type)
module T2 (T1 : USERTYPE) (T2 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2   = 
    T10 (T1) (T2) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type)
module T3 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3   = 
    T10 (T1) (T2) (T3) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type)
module T4 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4   = 
    T10 (T1) (T2) (T3) (T4) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type)
module T5 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE) (T5 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4 with module T5.U = T5   = 
    T10 (T1) (T2) (T3) (T4) (T5) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type)
module T6 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE) (T5 : USERTYPE) (T6 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4 with module T5.U = T5 with module T6.U = T6   = 
    T10 (T1) (T2) (T3) (T4) (T5) (T6) (Unused.Type) (Unused.Type) (Unused.Type) (Unused.Type)
module T7 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE) (T5 : USERTYPE) (T6 : USERTYPE) (T7 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4 with module T5.U = T5 with module T6.U = T6 with module T7.U = T7   = 
    T10 (T1) (T2) (T3) (T4) (T5) (T6) (T7) (Unused.Type) (Unused.Type) (Unused.Type)
module T8 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE) (T5 : USERTYPE) (T6 : USERTYPE) (T7 : USERTYPE) (T8 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4 with module T5.U = T5 with module T6.U = T6 with module T7.U = T7 with module T8.U = T8   = 
    T10 (T1) (T2) (T3) (T4) (T5) (T6) (T7) (T8) (Unused.Type) (Unused.Type)
module T9 (T1 : USERTYPE) (T2 : USERTYPE) (T3 : USERTYPE) (T4 : USERTYPE) (T5 : USERTYPE) (T6 : USERTYPE) (T7 : USERTYPE) (T8 : USERTYPE) (T9 : USERTYPE)  : COMBINED_TYPE
 with module T1.U = T1 with module T2.U = T2 with module T3.U = T3 with module T4.U = T4 with module T5.U = T5 with module T6.U = T6 with module T7.U = T7 with module T8.U = T8 with module T9.U = T9   = 
    T10 (T1) (T2) (T3) (T4) (T5) (T6) (T7) (T8) (T9) (Unused.Type)
