% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
<<luastrlib.mli>>=
module M : Lua.Lib.BARE
<<string builtins>>=
let unimp s =
  V.caml_func (fun g _ -> I.error g ("string library does not implement `" ^ s ^ "'"))

let getopt x y = match x with None -> y | Some x -> x

<<support for [[format]]>>

let string_builtins =
  [ "strfind", unimp "strfind"
  ; "strlen", (V.pfunc (V.string **-> V.result V.int)).V.embed String.length
  ; "strsub",
    (V.pfunc (V.string **-> V.int **-> V.option V.int **-> V.result V.string)).V.embed
    (fun s start last ->
      let start = start - 1 in (* caml strings are 0-indexed *)
      let last = match last with None -> String.length s
                               | Some n -> min n (String.length s) in
      let len = last - start in
      String.sub s start len)
  ; "strlower", (V.pfunc (V.string **-> V.result V.string)).V.embed String.lowercase
  ; "strupper", (V.pfunc (V.string **-> V.result V.string)).V.embed String.uppercase
  ; "strrep",   (V.pfunc (V.string **-> V.int **-> V.result V.string)).V.embed
                (fun s n ->
                  if n < 0 then
                    raise (Invalid_argument ("number of replicas " ^ string_of_int n ^
                                             " is negative"))
                  else
                    let rec list l = function 0 -> l | n -> list (s::l) (n-1) in
                    String.concat "" (list [] n))
  ; "ascii",   (V.pfunc (V.string **-> V.option V.int **-> V.result V.int)).V.embed
               (fun s i -> Char.code (String.get s (getopt i 1 - 1)))
  ; "format",  V.caml_func format
  ; "gsub",    unimp "gsub"
  ] 
@ 
Escape character is [[%]].
Specials include [[^$*?.([%]].
<<pattern matching>>=
le
@ 
<<luastrlib.ml>>=
module M (I : Lua.Lib.CORE) = struct
  module V = I.V
  let ( **-> ) = V.( **-> )
  <<string builtins>>
  let init = I.register_globals string_builtins
end
@ 
Code for [[format]] borrowed from standard [[Printf]] library.
<<support for [[format]]>>=
external format_int: string -> int -> string = "format_int"
external format_float: string -> float -> string = "format_float"
let bprintf_internal g buf format =
  let rec doprn i args =
    if i >= String.length format then
      begin
        let res = Buffer.contents buf in
        Buffer.clear buf; (* just in case [bs]printf is partially applied *)
        res
      end
    else begin
      let c = String.get format i in
      if c <> '%' then begin
        Buffer.add_char buf c;
        doprn (succ i) args
      end else begin
        let j = skip_args (succ i) in
        (* Lua conversions: d i o u x X   e E    f g   c  s  p %   q *)
        (*                  ^ ^ ^ ^ ^ ^   ^ ^    ^ ^   ^  ^    ^     *)
        match String.get format j with
        | '%' ->
            Buffer.add_char buf '%';
            doprn (succ j) args
        | c ->
            let arg, args =
              match args with h :: t -> h, t
              | [] -> I.error g
                      "Not enough arguments to string-library function `format'" in
            match c with 
            | 's' ->
                let s = V.string.V.project arg in
                if j <= i+1 then
                  Buffer.add_string buf s
                else begin
                  let p =
                    try
                      int_of_string (String.sub format (i+1) (j-i-1))
                    with _ ->
                      invalid_arg "format: bad %s format" in
                  if p > 0 && String.length s < p then begin
                    Buffer.add_string buf (String.make (p - String.length s) ' ');
                    Buffer.add_string buf s
                  end else if p < 0 && String.length s < -p then begin
                    Buffer.add_string buf s;
                    Buffer.add_string buf (String.make (-p - String.length s) ' ')
                  end else
                    Buffer.add_string buf s
                end;
                doprn (succ j) args
        | 'c' ->
            let c =
              try Char.chr (V.int.V.project arg)
              with Invalid_argument _ -> V.projection arg "Character code" in  
            Buffer.add_char buf c;
            doprn (succ j) args
        | 'd' | 'i' | 'o' | 'x' | 'X' | 'u' ->
            let n = V.int.V.project arg in
            Buffer.add_string buf (format_int (String.sub format i (j-i+1)) n);
            doprn (succ j) args
        | 'f' | 'e' | 'E' | 'g' | 'G' ->
            let f = V.float.V.project arg in
            Buffer.add_string buf (format_float (String.sub format i (j-i+1)) f);
            doprn (succ j) args
        | 'p' | 'q' ->
            I.error g ("string library does not implement format specifier '%" ^
                       String.make 1 c ^ "'")
        | c ->
            I.error g ("bad format specifier '%" ^ String.make 1 c ^ "'")
      end
    end

  and skip_args j =
    match String.get format j with
      '0' .. '9' | ' ' | '.' | '-' -> skip_args (succ j)
    | c -> j

  in doprn 0

let format g args =
  let fmt, args = match args with h :: t -> h, t | [] -> V.Nil, [] in
  [V.String (bprintf_internal g (Buffer.create 16) (V.string.V.project fmt) args)]
