% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Experiment for embedding lua in caml}

If we are to configure the compiler dynamically, we need a
configuration language.  I'm proposing we borrow Lua, version~2.5,
but with a Caml interface based on a style of embedding and projection
that is inspired by Olivier Danvy's work on type-directed partial
evaluation. 
This file sketches some of the supporting details, focusing on the
embedding and projection, which is the new part.
<<oldinterp.mli>>=
<<signatures>>
module Make3  (T : Lualib.COMBINED_TYPE)
                  (L : Lualib.TYPEFUL with type 'a combined = 'a T.t) :
    S with type 'a Value.userdata'  = 'a T.t
@ 
\subsection{Implementation}
<<oldinterp.ml>>=
<<signatures>>
@ 
<<signatures>>=
module type S = sig
  module Value : Luavalue.S
  module Ast : Luaast.S with module Value = Value
  type state = Value.state
  type value = Value.value
  exception Error of string
  val compile : srcdbg:(Srcmap.map * bool) -> Ast.chunk list -> state -> value list
  val test : unit -> (string * value list) list
  val state : unit -> state  (* produce a fresh, initialized state *)
  val error : state -> string -> 'a  (* error fallback *)

  val getglobal : state -> value -> value
  val with_stack  : Value.info -> state -> ('a -> 'b) -> 'a -> 'b
  val fallback : string -> state -> value list -> value list

  val setfallback : state -> string -> value -> value
    (* sets fallback, returns previous one *)
  val register_globals :           (string * value) list -> state -> unit
    (* registers values as named global variables *)
  val register_module  : string -> (string * value) list -> state -> unit
    (* register_module t l inserts members of l into global table t, 
       creating t if needed *)
end
@ 
<<oldinterp.ml>>=
module Make3  (T : Lualib.COMBINED_TYPE)
                  (L : Lualib.TYPEFUL with type 'a combined = 'a T.t) :
    S with type 'a Value.userdata'  = 'a T.t = struct
  module U = struct
    type 'a t = 'a T.t
    let tname = T.tname
    let eq = T.eq
    let to_string = T.to_string
  end
  module Value = Luavalue.Make(U)
  module Ast = Luaast.Make (Value)
  module I = struct
    type state = Value.state
    type value = Value.value
    <<interp toplevel>>
    <<interp fallbacks>>
    <<interp registration>>
    <<interp tests>>
  end
  module Core = struct
    include I
  end
  module L' = L.M(Core)
  include I
  let state () =
    let g = V.state() in
    add_fallbacks g;
    L'.init g;
    g

end (* Make3 *)
@ 
<<new-style state function>>=
module This = struct
  module Interp = struct
    module V = Value
    let fallback = fallback
  end
  type 'a t = 'a V.userdata'
  let map = V.userdata
end

module L' = L.M(This)

let state () =
  let g = V.state () in
  add_fallbacks g;
  L'.init g;
  g
@
Abbreviate!
<<interp toplevel>>=
module A = Ast
module V = Ast.Value
@
<<interp fallbacks>>=
let error g s =
  ignore (fallback "error" g [V.String s]);
  raise (Error "Error fallback returned a value")
<<interp fallbacks>>=
let errorfallback s = fun g args -> fallback "error" g [V.String s]
let arithfallback g = function
  | [V.Number x; V.Number y; V.String s] when s = "pow" -> [V.Number (x ** y)]
  | args -> errorfallback "unexpected type at conversion to number" g args
      
let fbs =
  [ "arith",     arithfallback
  ; "order",     errorfallback "unexpected type at comparison"
  ; "concat",    errorfallback "unexpected type at conversion to string"
  ; "index",     (fun g args -> [V.Nil])
  ; "getglobal", (fun g args -> [V.Nil])
  ; "gettable",  errorfallback "indexed expression not a table"
  ; "settable",  errorfallback "indexed expression not a table"
  ; "function",  errorfallback "call expression not a function"
  ; "error",     default_error_fallback
  ] 
(* make default fallbacks; provide state in V *)
let add_fallbacks g =
  List.iter (fun (k, f) -> Hashtbl.add g.V.fallbacks k (V.caml_func f)) fbs 
@ 
must be able to manage stack correctly
<<interp toplevel>>=
let currentloc_tostack g =
  match g.V.callstack with
  | (info, _) :: t -> g.V.callstack <- (info, g.V.currentloc) :: t
  | [] -> ()

let currentloc_fromstack g =
  match g.V.callstack with
  | (info, where) :: _ -> g.V.currentloc <- where
  | [] -> ()
@ 
Fallbacks can't use the ordinary [[cpscall]] because this could lead
to an infinite loop. 

\emph{Contemplating two revisions: (1)~pass state before args, as in
the function value; (2)~get rid of continuations for calls, since they
don't seem to be doing anything useful.}
<<interp toplevel>>=
exception Error of string
let default_error_fallback g args = 
  let msg = match args with V.String s :: _ -> s | _ -> "??error w/o message??" in
  prerr_string "lua: ";
  prerr_endline msg;
  prerr_endline "Stack trace:";
  currentloc_tostack g;
  List.iter (fun a -> prerr_string "  ";
             List.iter prerr_string (V.activation_strings g a);
             prerr_endline "") g.V.callstack;
  raise (Error msg)

<<state dumping>>

let rec fallback fbname g args =
  let call f g args = match f with
  | V.Function (_, f) -> f g args
  | v when fbname <> "function" -> fallback "function" g (v :: args)
  | v -> default_error_fallback g [V.String "`function' fallback not a function"] in
  let fbval = try Hashtbl.find g.V.fallbacks fbname
              with Not_found -> <<fallback failure>>
  in call fbval g args
<<fallback failure>>=
begin
  prerr_string "no fallback named `";
  prerr_string fbname;
  prerr_endline "' (probably registered an impure function as pure)";
  dump_state g;
  assert false (* can't have any unknown fallbacks *)
end
@ 
Everybody else can use a call that falls back to the fallback.
If the types don't match, we have to do something.
This problem has no counterpart in the C~version, in which it's up to
each individual C~routine to worry about type mismatches.
<<interp toplevel>>=
let cpscall f args g k = match f with
  | V.Function (_, f) ->
      k (try (f g args) with
         | V.Projection (v, what) -> <<projection error fallback>>
         | Invalid_argument msg -> <<argument error fallback>>)
  | v -> k (fallback "function" g (v :: args))

let apply f g args = cpscall f args g (fun x -> x)

<<projection error fallback>>=
fallback "error" g [V.String ("cannot convert value " ^ V.to_string v ^ " to " ^ what)]
<<argument error fallback>>=
fallback "error" g [V.String ("Function raised Invalid_argument " ^ msg)]
@      
To use a fallback or function call in a situation where we expect
exactly one result, we adjust the results.
We do this by maniupulating continuations.
<<interp toplevel>>=
let trim1 = function [] -> V.Nil | h :: t -> h
let adjust1 (f : (V.value list -> 'answer) -> 'answer) : (V.value -> 'answer) -> 'answer =
  fun k -> f (fun x -> k (trim1 x))
let fb1 name state args k = k (trim1 (fallback name state args))
@ 
Operators, like everything else, use CPS
<<interp toplevel>>=
let arith opname op =
  let opname = V.String opname in
  let f x y g = try
    let x = V.float.V.project x in
    let y = V.float.V.project y in
    fun k -> k (V.float.V.embed (op x y))
  with V.Projection (_, _) -> fb1 "arith" g [x; y; opname]
  in f
<<interp toplevel>>=
let negate x g k = try
  let x = V.float.V.project x in
  k (V.float.V.embed (~-. x))
  with V.Projection (_, _) -> fb1 "arith" g [x; V.Nil; V.String "umn"] k
<<interp toplevel>>=
let order opname nop sop =
  let opname = V.String opname in
  let f x y g =
    match x, y with
    | V.Number x, V.Number y -> fun k -> k (V.bool.V.embed (nop x y))
    | _ -> try let x = V.string.V.project x in
               let y = V.string.V.project y in
               fun k -> k (V.bool.V.embed (sop x y))
           with V.Projection (_, _) -> fb1 "order" g [x; y; opname]
  in f
<<interp toplevel>>=
let concat x y g k =
  try let x = V.string.V.project x in
      let y = V.string.V.project y in
      k (V.string.V.embed (x ^ y))
  with V.Projection (_, _) -> fb1 "concat" g [x; y] k
<<interp toplevel>>=
let binop = function
  | A.Plus   -> arith "add" (+.)
  | A.Minus  -> arith "sub" (-.)
  | A.Times  -> arith "mul" ( *. )
  | A.Div    -> arith "div" ( /. )
  | A.Pow    -> fun x y g k -> fb1 "arith" g [x; y; V.String "pow"] k
  | A.Lt     -> order "lt" (<)  (<)
  | A.Le     -> order "le" (<=) (<=)
  | A.Gt     -> order "gt" (>)  (>)
  | A.Ge     -> order "ge" (>=) (>=)
  | A.Eq     -> fun x y g k -> k (V.bool.V.embed (V.eq x y))
  | A.Ne     -> fun x y g k -> k (V.bool.V.embed (not (V.eq x y)))
  | A.And    -> assert false (* short circuit *)
  | A.Or     -> assert false (* short circuit *)
  | A.Concat -> concat
  | A.Not    -> assert false (* unary *)

let unop = function
  | A.Minus  -> negate
  | A.Not    -> fun v g k -> k (match v with V.Nil -> V.Number 1.0 | _ -> V.Nil)
  | _        -> assert false (* all other operators are binary *)
<<interp toplevel>>=
let index g t key = match t with
| V.Table t ->
    (match V.Table.find t key with
    | V.Nil -> trim1 (fallback "index" g [V.Table t; key])
    | v -> v)
| _ -> trim1 (fallback "gettable" g [t; key])

let settable g t key v = match t with
| V.Table t -> V.Table.bind t key v
| _ -> ignore (fallback "settable" g [t; key; v])

<<interp toplevel>>=
let getglobal g k =
  match V.Table.find g.V.globals k with
  | V.Nil -> trim1 (fallback "getglobal" g [k])
  | v -> v
<<interp toplevel>>=
type var = Global | Local of int
let lookup rho x =
  let rec look = function
    | [] -> Global
    | h :: t when h = x -> Local (List.length t)
    | h :: t -> look t
  in look rho

<<interp toplevel>>=
let rec exp rho = function
  | A.Var x -> (match rho x with
                | Global -> fun g l k -> k (getglobal g (V.String x))
                | Local n -> fun g l k -> k (Array.get l n))
  | A.Lit v -> fun g l k -> k v
  | A.Index (tab, key) ->
      let tab = exp rho tab in
      let key = exp rho key in
      fun g l k -> tab g l (fun t -> key g l (fun v -> k (index g t v))) 
@ 
We could perhaps speed this up by walking the contents in advance.
<<interp toplevel>>=
  | A.Table (lists, bindings) ->
      let rec listbind n bs = function
        | [] -> bs
        | h::t -> listbind (n +. 1.0) ((V.Number n, exp rho h) :: bs) t  in
      let rec bind bs = function
        | [] -> bs
        | (n, h) :: t -> bind ((V.String n, exp rho h) :: bs) t  in
      let contents = listbind 1.0 (bind [] bindings) lists in
      let size     = List.length contents in
      fun g l k ->
        let t = V.Table.create size in
        let rec walk = function
          | [] -> k (V.Table t)
          | (n, e) :: rest -> e g l (fun v -> V.Table.bind t n v; walk rest) in
        walk contents
<<interp toplevel>>=
  | A.Binop (e1, op, e2) ->
      let e1 = exp rho e1 in
      let e2 = exp rho e2 in
      ( match op with
      | A.And -> fun g l k -> e1 g l (function V.Nil -> k V.Nil | _ -> e2 g l k)
      | A.Or  -> fun g l k -> e1 g l (function V.Nil -> e2 g l k | v -> k v)
      | _ -> let op = binop op in
             fun g l k -> e1 g l (fun v1 -> e2 g l (fun v2 -> op v1 v2 g k)))
  | A.Unop (op, e) ->
      let e = exp rho e in
      let op = unop op in
      fun g l k -> e g l (fun v -> op v g k)
<<interp toplevel>>=
  | A.Call c ->
      let c = call c rho in
      fun g l -> adjust1 (c g l)
@ 
<<interp toplevel>>=
and explist rho =
  let rec walk = function 
    | [] -> fun g l k -> k []
    | h :: t ->
        let h = exp rho h in
        let t = walk t in
        fun g l k -> h g l (fun v -> t g l (fun vs -> k (v :: vs)))
  in walk 
and call c rho = match c with
| A.Funcall (f, args) ->
    let f    = exp rho f in
    let args = explist rho args in
    fun g l k -> f g l (fun fv -> args g l (fun argv -> cpscall fv argv g k))
| A.Methcall (obj, meth, args) ->
    let self = exp rho obj in
    let args = explist rho args in
    let meth = V.String meth in
    fun g l k -> self g l (fun v -> let m = index g v meth in
                 args g l (fun argv -> cpscall m (v::argv) g k))
@ 
Static environment for a statement includes list of local variables.
Dynamic continuations include return continuation and standard
continuation.
We make a separate function to compute max number of locals.
<<interp toplevel>>=
let notnil = function
  | V.Nil -> false
  | _ -> true

let (_ : (string -> var) -> A.exp -> V.state -> V.value array -> (V.value -> 'answer) -> 'answer) = exp

type answer = unit * string * bool
let (pexp : (string -> var) -> A.exp -> V.state -> V.value array -> (V.value -> answer) -> answer) = exp

let show_locals rho = ()
(*
  prerr_string "=============\n";
  List.iter (fun x ->
    List.iter prerr_string ([x; " is "] @
                            match lookup rho x with
                            | Local n -> [" local variable "; string_of_int n; "\n"]
                            | Global -> ["global\n"])) rho;
  prerr_endline ""
*)

<<interp toplevel>>=
let rec extend rho = function
  | A.Stmt' (_, s) -> extend rho s
  | A.Local (vs, _) -> List.rev_append vs rho
  | _ -> rho
@ 
For statements (although not for expressions), the ordinary and return
continuations can be static parameters.  This setup approximates
direct threaded code.  A little ref-cell jujitsu is needed to make
loops work.
<<interp toplevel>>=
let compilers (srcmap, debug) =
  let rec stmt rho s theta ret = match s with
    | A.Stmt' (charpos, s) ->
        if debug then
          let where = Srcmap.location srcmap charpos in
          let n = ref None in
          let restore g = g.V.currentloc <- !n in
          let restore_cont g l = (restore g; theta g l) in
          let run_cont =
            fun g l -> stmt rho s restore_cont (fun ans -> restore g; ret ans) g l in
          fun g l -> ( n := g.V.currentloc
                     ; g.V.currentloc <- Some where
                     ; run_cont g l
                     ) 
              (* hard to maintain current line if exn raised ... *)
        else
          stmt rho s theta ret
    | A.WhileDo (cond, body) ->
        let loop_cont = ref theta in  (* to become loop continuation *)
        let goto_head g l = !loop_cont g l in
        let cond = exp (lookup rho) cond in
        let body = block rho body goto_head ret in
        let loop g l = cond g l (fun v -> if notnil v then body g l else theta g l) in
        let _ = loop_cont := loop in
        loop
    | A.RepeatUntil (body, cond) ->
        let loop_test = ref theta in (* to become loop-end continuation *)
        let goto_test g l = !loop_test g l in
        let cond = exp (lookup rho) cond in
        let body = block rho body goto_test ret in
        let loop g l = cond g l (fun v -> if notnil v then theta g l else body g l) in
        let _ = loop_test := loop in
        body
    | A.If (c, t, alts, f) ->
        let alts = (c, t) :: alts in
        let f = block rho (match f with None -> [] | Some ss -> ss) theta ret in
        let add (cond, body) f =
          let cond = exp (lookup rho) cond in
          let body = block rho body theta ret in
          fun g l -> cond g l (fun v -> if notnil v then body g l else f g l)  in
        List.fold_right add alts f
    | A.Return es ->
        let es = explist (lookup rho) es in
        fun g l -> es g l ret
    | A.Local (vs, es) ->
        show_locals (List.rev_append vs rho);
        stmt (List.rev_append vs rho) (A.Assign (List.map (fun x -> A.Lvar x) vs, es))
        theta ret
    | A.Assign (vs, [A.Call c]) ->
        assign (lvars (lookup rho) vs) (call c (lookup rho)) theta ret
    | A.Assign (vs, es) ->
        assign (lvars (lookup rho) vs) (explist (lookup rho) es) theta ret
    | A.Callstmt c -> fun g l -> call c (lookup rho) g l (fun _ -> theta g l)
  and block rho body theta ret = match body with
    | [] -> theta
    | s :: ss -> stmt rho s (block (extend rho s) ss theta ret) ret
  and lvar rho : A.lval -> V.state -> V.value array -> V.value -> unit = function
    | A.Lvar x -> (match rho x with
                   | Global  -> fun g l v -> V.Table.bind g.V.globals (V.String x) v
                   | Local n -> fun g l v -> Array.set l n v)
    | A.Lindex (t, key) ->
        let t = exp rho t in
        let key = exp rho key in
        fun g l -> t g l (fun t -> key g l (fun key -> (fun v -> settable g t key v)))
  and lvars rho = function
    | [] -> fun g l vs -> ()
    | h :: t ->
        let h = (lvar rho h : V.state -> V.value array -> V.value -> unit) in
        let t = lvars rho t in
        fun g l ->
          let h = h g l in
          let t = t g l in
          fun vs ->
            let hv, tv = match vs with h::t -> h, t | [] -> V.Nil, [] in (h hv; t tv)
  and assign left right theta ret =
    fun g l ->
      let left = left g l in
      (right g l left; theta g l)
  in stmt, block
let stmt  s = fst (compilers s)
let block s = snd (compilers s)
@ 
Function [[numlocals]] takes a sequence of statements and returns the
maximum number of local variables declared on any path through that sequence.
<<interp toplevel>>=
let rec numlocals = function
  | [] -> 0
  | h :: t -> numlocals t + match h with
    | A.Stmt' (_, s)          -> numlocals [s]
    | A.Local (vs, es)        -> List.length vs
    | A.WhileDo     (_, body) -> numlocals body
    | A.RepeatUntil (body, _) -> numlocals body
    | A.If (c, t, alts, f)    ->
        let add k (_, body) = max k (numlocals body) in
        List.fold_left add (match f with None -> 0 | Some b -> numlocals b)
                           ((c, t) :: alts)
    | A.Assign _   -> 0
    | A.Return _   -> 0
    | A.Callstmt _ -> 0
@ 
Chunks are executed by compiling functions.
<<interp toplevel>>=
let with_stack info g f x =
  let _ = currentloc_tostack g in
  let _ = g.V.callstack <- (info, None) :: g.V.callstack in
  let pop () = g.V.callstack <- List.tl g.V.callstack; currentloc_fromstack g in
  let answer = try f x with e -> (pop(); raise e) in
  let _ = pop() in
  answer

let value_list = V.list V.value
let lambda srcdbg (file, line, col) args varargs body =
  let n = List.length args + (if varargs then 1 else 0) + numlocals body in
  let rho = let args' = List.rev args in if varargs then "arg" :: args' else args' in
  let body = block srcdbg rho body in
  let info = V.info file line in
  info, 
  fun state argv ->
    let locals = Array.make n V.Nil in
    let rec walk n formals actuals = match formals with
      | [] -> if varargs then Array.set locals n (value_list.V.embed actuals)
      | f :: fs ->
          let a, a's = match actuals with [] -> V.Nil, [] | h :: t -> h, t in
          (Array.set locals n a; walk (n+1) fs a's)  in
    let _ = walk 0 args argv in
    with_stack info state
      (body (fun g l -> []) (fun results -> results) state) locals

let (_ : Srcmap.map * bool -> Srcmap.location -> string list -> bool -> A.block -> V.info * V.func) = lambda
@ 
<<interp toplevel>>=
let expname = function
  | A.Var v -> v
  | _ -> "?"
let funname = function
  | A.Lvar v -> v
  | A.Lindex (e, A.Lit (V.String s)) -> expname e ^ "." ^ s
  | A.Lindex (e, e') -> expname e ^ "[" ^ expname e' ^ "]"
let func (info, f) = V.Function (info, f)
let chunk ((smap, dbg) as srcdbg) rho = function
  | A.Statement s -> stmt srcdbg rho s
  | A.Fundef (pos, f, args, varargs, body) ->
      let v = func (lambda srcdbg (Srcmap.location smap pos) args varargs body) in
      stmt srcdbg rho (A.Assign ([f], [A.Lit v]))
  | A.Methdef (pos, obj, meth, args, varargs, body) ->
      let args = "self" :: args in
      let v = func (lambda srcdbg (Srcmap.location smap pos) args varargs body) in
      stmt srcdbg rho (A.Assign ([A.Lindex (obj, A.Lit (V.String meth))], [A.Lit v]))

let rec chunklocals = function
  | [] -> 0
  | A.Statement s :: t -> numlocals [s] + chunklocals t
  | _ :: t -> chunklocals t

let extendchunk rho = function
  | A.Statement s -> extend rho s
  | _ -> rho

let wrap f x = let l = f x in (prerr_string "function returned ";
                               prerr_int (List.length l);
                               prerr_endline " values";
                               l)

let compile srcdbg cs = 
  let locals = Array.make (chunklocals cs) V.Nil in
  let rec chunks rho = function
    | [] -> fun g -> []
    | h :: t ->
        let h' = chunk srcdbg rho h in
        let t' = chunks (extendchunk rho h) t in
        fun g -> h' (fun g l -> t' g) (fun results -> results) g locals
  in chunks [] cs
@ 
<<interp toplevel>>=
let setfallback g fbname fb =
  let fb' = try Hashtbl.find g.V.fallbacks fbname with Not_found -> V.Nil in
  let _ = Hashtbl.replace g.V.fallbacks fbname fb in
  fb'
@ 



<<interp tests>>=  
let nil = A.Lit V.Nil
let three = A.Lit (V.Number 3.0)

let ret = A.Return ([nil; three])

let test_state = V.state ()

let bogusmap = Srcmap.mk ()
let stmts l = compile (bogusmap, false) (List.map (fun s -> A.Statement s) l)

let num n = A.Lit (V.Number (float n))
let rtest = stmts [ret]
let sum = stmts [A.Return ([A.Binop (three, A.Plus, three)])]
let exp = stmts [A.Return ([A.Binop (three, A.Times, A.Binop (num 2, A.Minus, three))])]
let x = A.Var "x"
let gets x e = A.Assign ([A.Lvar x], [e])
let binary op e1 e2 = A.Binop (e1, op, e2)
let lt = binary A.Lt
let times = binary A.Times
let loop = [ gets "x" (num 10)
               ; A.WhileDo (lt x (num 100), [gets "x" (times (num 2) x)])
               ; A.Return [x]]

let test _ =
  [ "return nil and three", rtest test_state
      ; "sum of three and three", sum test_state
      ; "expression minus three", exp test_state
      ; "result of loop", stmts loop test_state
  ] 
@ 
<<old luainterp.ml>>=
module T = Make (NoLibrary)
let t = T.test ()
<<old luainterp.mli>>=
module T : S
val t : (string * T.Value.value list) list
@

<<hell.ml>>=
module type VALUE' = sig
  type userdata
end

module type AST' = sig
  module Value : VALUE'
end

module type INTERP' = sig
  module Value : VALUE'
  module Ast : AST' with module Value = Value
end

module MkInterp' (A : AST') : INTERP' with module Ast = A = struct
  module Value = A.Value
  module Ast = A
end

@ 
\section{Caveats}

Builtin [[type]] doesn't return a tag.
@
<<state dumping>>=
let dump_state g = 
  let err = prerr_string in
  let int = prerr_int in
  let rec value = function
    | V.Table t -> tab t ""
    | v -> err (V.to_string v)
  and tab t sfx =
    err "{"; Luahash.iter (fun k d -> err " "; value k; err "="; value d; err ",") t;
    err "}"; err sfx in
  let stab t sfx =
    err "{"; Hashtbl.iter (fun k d -> err " "; err k; err "="; value d; err ",") t;
    err "}"; err sfx in
  err "state is: \n";
  err "  globals =\n    ";
  tab g.V.globals "\n";
  err "  fallbacks =\n    ";
  stab g.V.fallbacks "\n";
  default_error_fallback g [V.String "Stack trace is:"]

@ 
<<interp registration>>=
let register_globals l g =
  List.iter (fun (k, v) -> V.Table.bind g.V.globals (V.String k) v) l

let register_module tabname members g =
  let t = getglobal g (V.String tabname) in
  let t = match t with
  | V.Nil       -> V.Table.create (List.length members)
  | V.Table t   -> t
  | _           -> error g ("Global value " ^ tabname ^ " is not (table or nil)") in
  let _ = V.Table.bind g.V.globals (V.String tabname) (V.Table t) in
    List.iter (fun (k, v) -> V.Table.bind t (V.String k) v) members
