% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Modules for building Lua libraries}

In general, a library can add new types, global mutable state, and new
functions to an interpreter.
Interpreters are typically built by combining multiple libraries, and
the combination determines the [[userdata]] and [[userstate]] types
ultimately used in the interpreter's value and state.

We encourage the use of parameterized modules so that libraries can be
combined easily.  There is some run-time cost for the generality, but
it can be minimized as discussed below.

Building the interpreter takes place in three phases:
\begin{enumerate}
\item
Different libraries are combined to determine the ultimate
[[userdata]] and [[state]] types.
The combination is then used to build an interpreter, which matches
signature [[INTERP]].
This step happens at compile time.
\item
The full interpreter is passed back to each library, so that each
library can build a function suitable for initializing interpreters of
built with those types.
This step also happens at compile time.
\item
A fresh state is created and all the initialization functions are
called, building a new, fully initialized interpreter.
This step happens at run time, as often as desired---multiple
interpreters coexist peacefully.
\end{enumerate}
@
Here is everything that a library is deemed to need to know about an
interpreter.
This signature could be extended if necessary.
The information is divided in two pieces: there is one [[INTERP]]
piece,  which looks the same to all libraries.
But each library sees its own [[VIEW]] piece, which provides functions
that map to and from the type and state provided by that library.
<<signatures>>=
module type USERTYPE = sig
  type 'a t                             (* type parameter will be Lua value *)
  val tname : string  (* name of this type, for projection errors *)
  val eq : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
  val to_string : ('a -> string) -> 'a t -> string
end

module type USERSTATE = sig
  type 'a t
  val state : 'a -> 'a t
end

module type INIT = sig
  type state
  val init : state -> unit
end

module type INTERP = sig
  module V : Luavalue.S
  val fallback : string -> V.state -> V.value list -> V.value list
end

module type TYPEVIEW = sig
  module I : INTERP
  module U : USERTYPE
  val map : I.V.value U.t I.V.map
end 

module type STATEVIEW = sig
  module I : INTERP
  module U : USERSTATE
  val map : I.V.state -> I.V.value U.t
end 
@ 
In principle, there could be four kinds of libraries:
a [[BARE]] library uses only existing types and state;
a [[FULL]] library adds both a new type and new state;
a \emph{stateful} library could add only a new state; and
a \emph{typeful} library could add only a new type.
This interface currently supports only two of the four alternatives,
but the others could be added easily enough.
Each alternative requires its own view signature.
<<newlib.mli>>=
<<signatures>>
module Client : sig
  <<client signatures>>
end
<<client signatures>>=
  module type BARE = functor (Interp : INTERP) -> INIT with type state = Interp.V.state
  module type T =
   functor (T : USERTYPE) ->
   functor (Interp : INTERP) ->
   functor (T' : TYPEVIEW with module U = T and module I = Interp) ->
   INIT with type state = Interp.V.state
  module type TS =
   functor (T : USERTYPE) ->
   functor (S : USERSTATE) ->
   functor (Interp : INTERP) ->
   functor (T' : TYPEVIEW  with module U = T and module I = Interp) ->
   functor (S' : STATEVIEW with module U = S and module I = Interp) ->
   INIT with type state = Interp.V.state
  module type TT =
   functor (T1 : USERTYPE) ->
   functor (T2 : USERTYPE) ->
   functor (Interp : INTERP) ->
   functor (T1' : TYPEVIEW with module U = T1 and module I = Interp) ->
   functor (T2' : TYPEVIEW with module U = T2 and module I = Interp) ->
   INIT with type state = Interp.V.state
@ 
An interpreter requires at least one [[FULL]] library, so these two
module combinators suffice to mix any number of any kind of libraries.
Initialization takes place left to right, but ordinarily
initialization of different libraries should be independent, so this
shouldn't be an onerous restriction.
<<newlib.mli>>=
module Combine : sig
  
  module FF (L1 : FULL) (L2 : FULL) : FULL
end
module AddBare  (LT : FULL) (LU : BARE) : FULL
@ As is typical, it's less efficient to string together a bunch of
pairs than it is to build larger tuples.
Perhaps one day soon we will provide more alternatives---perhaps by
generating them automatically.
That's why we've left room for more sub-modules of [[Combine]].
@
\section{Implementation}

If you understand the interfaces, there's nothing of interest here.
It's all bookkeeping.
<<newlib.ml>>=
<<signatures>>
module Client = struct
  <<client signatures>>
end
(*
module AddBare (LT : FULL) (LU : BARE) : FULL =
struct
  module U = LT.U
  module M (This : FULL_VIEW with type 'a t = 'a U.t and type 'a state = 'a U.state) =
    struct
      module LT' = LT.M (This)
      module LU' = LU   (This.Interp)
      let init g = (LT'.init g; LU'.init g)
    end
end


module Combine = struct
  module FF (L1 : FULL) (L2 : FULL) : FULL = struct
    module U = struct
      type 'a t =
        | L1 of 'a L1.U.t 
        | L2 of 'a L2.U.t 
      let tname = L1.U.tname ^ " or " ^ L2.U.tname
      let eq veq x y = match x, y with
      | L1 x,    L1 y    -> L1.U.eq veq x y
      | L2 x,    L2 y    -> L2.U.eq veq x y
      | _, _ -> false
      let to_string vs = function
        | L1 x -> L1.U.to_string vs x
        | L2 x -> L2.U.to_string vs x
      type 'a state = { l1 : 'a L1.U.state ; l2 : 'a L2.U.state }
      let state () = { l1 = L1.U.state() ; l2 = L2.U.state () }
    end
    module M (This : FULL_VIEW with type 'a t = 'a U.t and type 'a state = 'a U.state) =
      struct
        module Interp = This.Interp
        module V = Interp.V
        module This1 = struct
          module Interp = Interp
          type 'a t = 'a L1.U.t
          let map = { V.embed = (fun x -> This.map.V.embed (U.L1 x))
                    ; V.project = (fun v -> match This.map.V.project v with
                                          | U.L1 x -> x
                                          | _ -> raise (V.Projection (v, L1.U.tname)))
                  }
          type 'a state = 'a L1.U.state
          let project_state s = (This.project_state s).U.l1
        end
        module This2 = struct
          module Interp = Interp
          type 'a t = 'a L2.U.t
          let map = { V.embed = (fun x -> This.map.V.embed (U.L2 x))
                    ; V.project = (fun v -> match This.map.V.project v with
                                          | U.L2 x -> x
                                          | _ -> raise (V.Projection (v, L2.U.tname)))
                  }
          type 'a state = 'a L2.U.state
          let project_state s = (This.project_state s).U.l2
        end
        module L1' = L1.M (This1)
        module L2' = L2.M (This2)
        let init g = (L1'.init g; L2'.init g)
      end
  end
end

*)
