% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
\section{Lua I/O library}

<<luaiolib.mli>>=
type 'a t = In of in_channel | Out of out_channel
val out :
    ('a t, 'b, 's) Luavalue.ep ->
    ('b -> string -> out_channel) ->
    (out_channel, 'b, 's) Luavalue.ep
val in' :
    ('a t, 'b, 's) Luavalue.ep ->
    ('b -> string -> in_channel) ->
    (in_channel, 'b, 's) Luavalue.ep

module T : Lua.Lib.USERTYPE  with type 'a t = 'a t
module Make (T : Lua.Lib.TYPEVIEW with type 'a t = 'a t)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a T.combined
@ 
<<luaiolib.ml>>=
type 'a t = In of in_channel | Out of out_channel
type 'a state = { mutable currentin  : in_channel
                ; mutable currentout : out_channel
                } 
type 'a alias_for_t = 'a t
type 'a alias_for_state = 'a state
@ 
<<i/o builtins>>=
let {V.embed= embed; V.project=project} = T.makemap V.userdata V.projection in
let infile = { V.embed = (fun f -> embed (In f))
             ; V.project = (fun g v -> match project g v with
                                     | In f -> f
                                     | _ -> raise (V.Projection (v, "input file")))} in
let outfile = { V.embed = (fun f -> embed (Out f))
              ; V.project = (fun g v -> match project g v with
                                      | Out f -> f
                                      | _ -> raise (V.Projection (v, "output file")))}
    in

let wrap_err f = try f () with Sys_error s -> [V.Nil; V.String s] in

let readfrom g =
  let finish_new file =
    io.currentin <- file;
    [infile.V.embed file] in
  function
  | [V.String s] ->
      (match String.get s 0 with
       | '|' ->
           wrap_err (fun () -> finish_new
                       (Unix.open_process_in (String.sub s 1 (String.length s - 1))))
       | _   -> wrap_err (fun () -> finish_new (open_in s)))
  | [] ->
      let c = io.currentin in
      io.currentin <- stdin;
      wrap_err (fun () -> close_in c; [])
  | [v] -> (io.currentin <- infile.V.project g v; [])
  | _ -> C.fallback "error" g [V.String "bad args to readfrom"] in
              
let open_out_append s =
  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_text] 0o666 s  in
let writeto' append g = 
  let finish f = io.currentout <- f; [outfile.V.embed f] in
  function
  | [V.String s] ->
      (match String.get s 0 with
       | '|' ->
           wrap_err (fun () ->
            if append then raise (Sys_error "tried to appendto() a pipe")
            else finish (Unix.open_process_out (String.sub s 1 (String.length s - 1))))
       | _   ->
           wrap_err (fun () ->
                     finish (if append then open_out_append s else open_out s)))
  | [] ->
      ( close_out io.currentout; io.currentout <- stdout; [])
  | [v] -> (io.currentout <- outfile.V.project g v; [v])
  | _ -> C.fallback "error" g [V.String "bad args to writeto"]  in
              
let success = [V.String "OK"] in

let unimp s =
  V.caml_func (fun g _ ->
    C.fallback "error" g [V.String ("string library does not implement `" ^ s ^ "'")]) in

let read g = function
  | None -> [try V.String (input_line io.currentin) with End_of_file -> V.Nil]
  | Some _ -> C.fallback "error" g
              [V.String ("string library does not implement read patterns")]  in

let write_string g v =
  output_string io.currentout (V.string.V.project g v)  in

let getopt x d = match x with Some v -> v | None -> d  in

let date g = function
  | Some _ -> C.fallback "error" g
              [V.String ("string library does not implement read patterns")]
  | None ->
      let t = Unix.localtime (Unix.time ()) in
      let s = string_of_int in
      let mm = t.Unix.tm_mon + 1 in
      let yyyy = t.Unix.tm_year + 1900 in
      let dd = t.Unix.tm_mday in
      [V.String (s mm ^ "/" ^ s dd ^ "/" ^ s yyyy)]  in

let tmpname _ _ =
  let rec tmp here n =
    let s = "luatmp" ^ string_of_int n in
    let s = if here then s else "/tmp/" ^ s in
    if Sys.file_exists s then
      tmp (not here) (n+1)
    else
      [V.String s]
  in tmp false 238  in

let io_builtins =
  [ "readfrom", V.caml_func readfrom
  ; "writeto",  V.caml_func (writeto' false)
  ; "appendto", V.caml_func (writeto' true)
  ; "remove",   V.pure (V.string **-> V.values)
                (fun s -> wrap_err (fun () -> Sys.remove s; success))
  ; "rename",   V.pure (V.string **-> V.string **-> V.values)
                (fun s1 s2 -> wrap_err (fun () -> Sys.rename s1 s2; success))
  ; "tmpname",  V.caml_func tmpname
  ; "read",     V.impure (V.option V.string **-> V.values) read
  ; "write",    V.caml_func (fun g l -> wrap_err (fun () ->
                               List.iter (write_string g) l;
                               flush io.currentout;
                               []))
  ; "date",     V.impure (V.option V.string **-> V.values) date
  ; "exit",     V.pure (V.option V.int **-> V.runit) (fun n -> exit (getopt n 0))
  ; "getenv",   V.pure (V.string **-> V.values)
                (fun s -> try [V.String (Sys.getenv s)] with Not_found -> [V.Nil])
  ; "execute",  V.pure (V.string **-> V.result V.int) Sys.command
(*  ; "map", V.pure (V.func (V.value **-> V.result V.value) **-> V.list V.value **-> V.result (V.list V.value))  List.map *)
  ] in
@ 
<<luaiolib.ml>>=
module T = struct
  type 'a t     = 'a alias_for_t
  let tname = "I/O channel"
  let eq _ x y = match x, y with
  | In x,    In y    -> x = y
  | Out x,   Out y   -> x = y
  | _, _ -> false
  let to_string vs = function
    | In _ -> "<input>"
    | Out _ -> "<output>"
end
<<luaiolib.ml>>=
module Make (T : Lua.Lib.TYPEVIEW with type 'a t = 'a t)
    : Lua.Lib.TYPEFUL with type 'a combined = 'a T.combined =
  struct
    type 'a combined = 'a T.combined
    module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a combined) =
     struct
       module V = C.V
       let ( **-> ) = V.( **-> )
       let init g = 
         let io = {currentin = stdin; currentout = stdout} in
         <<i/o builtins>>
         C.register_globals io_builtins g;
         Lua.Lib.StringList.empty
     end (*M*)
  end (*Make*)
@ 
<<luaiolib.ml>>=
module V = Luavalue
let out (upper) fail =
      { V.embed   = (fun x -> upper.V.embed (Out x))
      ; V.project = (fun g x -> match upper.V.project g x with
                    | Out x -> x
                    | _ -> fail x "out_channel")
      } 
let in' (upper) fail =
      { V.embed   = (fun x -> upper.V.embed (In x))
      ; V.project = (fun g x -> match upper.V.project g x with
                    | In x -> x
                    | _ -> fail x "out_channel")
      } 

