% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Lua I/O library}

<<luaiolib.mli>>=
type 'a t = In of in_channel | Out of out_channel
(*
module M : Lualib.FULL
  with type 'a U.t = 'a t and type 'a U.state = 'a state
*)

module T : Lib3.USERTYPE  with type 'a t = 'a t
module Make (T : Lib3.TYPEVIEW with type 'a U.t = 'a t)
    : Lib3.Lib.TYPEFUL with type 'a T.U.t = 'a t and type 'a T.t = 'a T.t
@ 
<<luaiolib.ml>>=
type 'a t = In of in_channel | Out of out_channel
type 'a state = { mutable currentin  : in_channel
                ; mutable currentout : out_channel
                } 
type 'a alias_for_t = 'a t
type 'a alias_for_state = 'a state
<<old io lib>>=
module M = struct
  module U = struct
    type 'a t     = 'a alias_for_t
    type 'a state = 'a alias_for_state
    let tname = "I/O channel"
    let eq _ x y = match x, y with
    | In x,    In y    -> x = y
    | Out x,   Out y   -> x = y
    | _, _ -> false
    let to_string vs = function
      | In _ -> "<input>"
      | Out _ -> "<output>"
    let state () = { currentin = stdin; currentout = stdout }
  end
  module M (This : Lualib.FULL_VIEW with type 'a t = 'a U.t and type 'a state = 'a U.state)=
  struct
    module V = This.Interp.V
    let ( **-> ) = V.( **-> )
    <<i/o builtins>>
    let init g = 
      List.iter (fun (k, v) -> V.Table.bind g.V.globals (V.String k) v) io_builtins
  end
end
@ 
<<i/o builtins>>=
let embed   = This.map.V.embed
let project = This.map.V.project
let infile = { V.embed = (fun f -> embed (In f))
             ; V.project = (fun v -> match project v with
                                     | In f -> f
                                     | _ -> raise (V.Projection (v, "input file")))}
let outfile = { V.embed = (fun f -> embed (Out f))
              ; V.project = (fun v -> match project v with
                                      | Out f -> f
                                      | _ -> raise (V.Projection (v, "output file")))}

let iostate g = This.project_state g

let wrap_err f = try f () with Sys_error s -> [V.Nil; V.String s]

let readfrom g = function
  | [V.String s] ->
      (match String.get s 0 with
       | '|' ->
           wrap_err (fun () ->
             [infile.V.embed
                   (Unix.open_process_in (String.sub s 1 (String.length s - 1)))])
       | _   -> wrap_err (fun () -> [infile.V.embed (open_in s)]))
  | [] ->
      let io = iostate g in
      ( close_in io.currentin; io.currentin <- stdin; [])
  | [v] -> ((iostate g).currentin <- infile.V.project v; [])
  | _ -> This.Interp.fallback "error" g [V.String "bad args to readfrom"]
              
let open_out_append s =
  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_text] 0o666 s
let writeto' append g = function
  | [V.String s] ->
      (match String.get s 0 with
       | '|' ->
           wrap_err (fun () ->
            if append then raise (Sys_error "tried to appendto() a pipe")
            else [outfile.V.embed
                    (Unix.open_process_out (String.sub s 1 (String.length s - 1)))])
       | _   ->
           wrap_err (fun () ->
             [outfile.V.embed (if append then open_out_append s else open_out s)]))
  | [] ->
      let io = iostate g in
      ( close_out io.currentout; io.currentout <- stdout; [])
  | [v] -> ((iostate g).currentout <- outfile.V.project v; [])
  | _ -> This.Interp.fallback "error" g [V.String "bad args to writeto"]
              
let pf t = (V.pfunc t).V.embed
let func t = (V.func t).V.embed
let success = [V.String "OK"]

let unimp s =
  V.caml_func (fun g _ ->
    This.Interp.fallback "error" g [V.String ("string library does not implement `" ^ s ^ "'")])

let read g = function
  | None -> [V.String (input_line (iostate g).currentin)]
  | Some _ -> This.Interp.fallback "error" g
              [V.String ("string library does not implement read patterns")]

let write_string g v =
  output_string (iostate g).currentout (V.string.V.project v)

let getopt x d = match x with Some v -> v | None -> d

let date g = function
  | Some _ -> This.Interp.fallback "error" g
              [V.String ("string library does not implement read patterns")]
  | None ->
      let t = Unix.localtime (Unix.time ()) in
      let s = string_of_int in
      let mm = t.Unix.tm_mon + 1 in
      let yyyy = t.Unix.tm_year + 1900 in
      let dd = t.Unix.tm_mday in
      [V.String (s mm ^ "/" ^ s dd ^ "/" ^ s yyyy)]

let tmpname _ _ =
  let rec tmp here n =
    let s = "luatmp" ^ string_of_int n in
    let s = if here then s else "/tmp/" ^ s in
    if Sys.file_exists s then
      tmp (not here) (n+1)
    else
      [V.String s]
  in tmp false 238

let io_builtins =
  [ "readfrom", V.caml_func readfrom
  ; "writeto",  V.caml_func (writeto' false)
  ; "appendto", V.caml_func (writeto' true)
  ; "remove",   pf (V.string **-> V.values)
                (fun s -> wrap_err (fun () -> Sys.remove s; success))
  ; "rename",   pf (V.string **-> V.string **-> V.values)
                (fun s1 s2 -> wrap_err (fun () -> Sys.rename s1 s2; success))
  ; "tmpname",  V.caml_func tmpname
  ; "read",     func (V.option V.string **-> V.values) read
  ; "write",    V.caml_func (fun g l -> wrap_err (fun () ->
                               List.iter (write_string g) l;
                               flush (iostate g).currentout;
                               []))
  ; "date",     func (V.option V.string **-> V.values) date
  ; "exit",     pf (V.option V.int **-> V.runit) (fun n -> exit (getopt n 0))
  ; "getenv",   pf (V.string **-> V.values)
                (fun s -> try [V.String (Sys.getenv s)] with Not_found -> [V.Nil])
  ; "execute",  pf (V.string **-> V.result V.int) Sys.command
  ] 
@ 
<<luaiolib.ml>>=
module T = struct
  type 'a t     = 'a alias_for_t
  let tname = "I/O channel"
  let eq _ x y = match x, y with
  | In x,    In y    -> x = y
  | Out x,   Out y   -> x = y
  | _, _ -> false
  let to_string vs = function
    | In _ -> "<input>"
    | Out _ -> "<output>"
end

module S = struct
  type 'a t = 'a alias_for_state
  let state () = { currentin = stdin; currentout = stdout }
end

module Init
    (T : Lib3.TYPEVIEW  with module U = T)
    (C : Lib3.CORE with type 'a V.userdata'  = 'a T.t) =
  struct
    <<contents of [[Init]]>>
  end

<<contents of [[Init]]>>=
    module V = C.V
    let ( **-> ) = V.( **-> )
    let fail v s = raise (V.Projection (v, s))  (* put in Value.S *)
    let file = T.postmap V.userdata fail    
    let infile = { V.embed = (fun f -> file.V.embed (In f))
                 ; V.project = (fun v -> match file.V.project v with
                                     | In f -> f
                                     | _ -> raise (V.Projection (v, "input file")))}
    let outfile = { V.embed = (fun f -> file.V.embed (Out f))
                 ; V.project = (fun v -> match file.V.project v with
                                     | Out f -> f
                                     | _ -> raise (V.Projection (v, "output file")))}
let wrap_err f = try f () with Sys_error s -> [V.Nil; V.String s]

    let init g = 
      let io = { currentin = stdin; currentout = stdout } in
let readfrom g = function
  | [V.String s] ->
      (match String.get s 0 with
       | '|' ->
           wrap_err (fun () ->
             [infile.V.embed
                   (Unix.open_process_in (String.sub s 1 (String.length s - 1)))])
       | _   -> wrap_err (fun () -> [infile.V.embed (open_in s)]))
  | [] ->
      ( close_in io.currentin; io.currentin <- stdin; [])
  | [v] -> (io.currentin <- infile.V.project v; [])
  | _ -> C.fallback "error" g [V.String "bad args to readfrom"]
in

let io_builtins =
  [ "readfrom", V.caml_func readfrom
  ]  
in              

      List.iter (fun (k, v) -> V.Table.bind g.V.globals (V.String k) v) io_builtins

<<luaiolib.ml>>=

module Make (T : Lib3.TYPEVIEW with type 'a U.t = 'a t)
    : Lib3.Lib.TYPEFUL with type 'a T.U.t = 'a t and type 'a T.t = 'a T.t =
  struct
    module T = T
    module M (C : Lib3.CORE with type 'a V.userdata' = 'a T.t) =
     struct
       <<contents of [[Init]]>>
     end
  end
