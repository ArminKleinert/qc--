% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Modules for building Lua libraries}

In general, a library can add new types, global mutable state, and new
functions to an interpreter.
Interpreters are typically built by combining multiple libraries, and
the combination determines the [[userdata]] and [[userstate]] types
ultimately used in the interpreter's value and state.

We encourage the use of parameterized modules so that libraries can be
combined easily.  There is some run-time cost for the generality, but
it can be minimized as discussed below.

Building the interpreter takes place in three phases:
\begin{enumerate}
\item
Different libraries are combined to determine the ultimate
[[userdata]] and [[state]] types.
The combination is then used to build an interpreter, which matches
signature [[INTERP]].
This step happens at compile time.
\item
The full interpreter is passed back to each library, so that each
library can build a function suitable for initializing interpreters of
built with those types.
This step also happens at compile time.
\item
A fresh state is created and all the initialization functions are
called, building a new, fully initialized interpreter.
This step happens at run time, as often as desired---multiple
interpreters coexist peacefully.
\end{enumerate}
@
Here is everything that a library is deemed to need to know about an
interpreter.
This signature could be extended if necessary.
The information is divided in two pieces: there is one [[INTERP]]
piece,  which looks the same to all libraries.
But each library sees its own [[VIEW]] piece, which provides functions
that map to and from the type and state provided by that library.
<<signatures>>=
module type INTERP = sig
  module V : Luavalue.S
  val fallback : string -> V.state -> V.value list -> V.value list
end

module type FULL_VIEW = sig
  module Interp : INTERP
  type 'a t   (* is this parameter needed really? *)
  val map : Interp.V.value t Interp.V.map
  type 'a state 
  val project_state : Interp.V.state -> Interp.V.value state
end
@ 
In principle, there could be four kinds of libraries:
a [[BARE]] library uses only existing types and state;
a [[FULL]] library adds both a new type and new state;
a \emph{stateful} library could add only a new state; and
a \emph{typeful} library could add only a new type.
This interface currently supports only two of the four alternatives,
but the others could be added easily enough.
Each alternative requires its own view signature.
<<signatures>>=
module type FULL = sig
  module U : Luavalue.USERDATA
  module M (This : FULL_VIEW with type 'a t = 'a U.t and type 'a state = 'a U.state) :
      sig
        val init : This.Interp.V.state -> unit
      end
end

module type BARE = 
  functor (Interp : INTERP) -> sig
    val init : Interp.V.state -> unit
  end
@ 
An interpreter requires at least one [[FULL]] library, so these two
module combinators suffice to mix any number of any kind of libraries.
Initialization takes place left to right, but ordinarily
initialization of different libraries should be independent, so this
shouldn't be an onerous restriction.
<<lualib.mli>>=
<<signatures>>
module Combine : sig
  module FF (L1 : FULL) (L2 : FULL) : FULL
end
module AddBare  (LT : FULL) (LU : BARE) : FULL
@ As is typical, it's less efficient to string together a bunch of
pairs than it is to build larger tuples.
Perhaps one day soon we will provide more alternatives---perhaps by
generating them automatically.
That's why we've left room for more sub-modules of [[Combine]].
@
\section{Implementation}

If you understand the interfaces, there's nothing of interest here.
It's all bookkeeping.
<<lualib.ml>>=
<<signatures>>
module AddBare (LT : FULL) (LU : BARE) : FULL =
struct
  module U = LT.U
  module M (This : FULL_VIEW with type 'a t = 'a U.t and type 'a state = 'a U.state) =
    struct
      module LT' = LT.M (This)
      module LU' = LU   (This.Interp)
      let init g = (LT'.init g; LU'.init g)
    end
end


module Combine = struct
  module FF (L1 : FULL) (L2 : FULL) : FULL = struct
    module U = struct
      type 'a t =
        | L1 of 'a L1.U.t 
        | L2 of 'a L2.U.t 
      let tname = L1.U.tname ^ " or " ^ L2.U.tname
      let eq veq x y = match x, y with
      | L1 x,    L1 y    -> L1.U.eq veq x y
      | L2 x,    L2 y    -> L2.U.eq veq x y
      | _, _ -> false
      let to_string vs = function
        | L1 x -> L1.U.to_string vs x
        | L2 x -> L2.U.to_string vs x
      type 'a state = { l1 : 'a L1.U.state ; l2 : 'a L2.U.state }
      let state () = { l1 = L1.U.state() ; l2 = L2.U.state () }
    end
    module M (This : FULL_VIEW with type 'a t = 'a U.t and type 'a state = 'a U.state) =
      struct
        module Interp = This.Interp
        module V = Interp.V
        module This1 = struct
          module Interp = Interp
          type 'a t = 'a L1.U.t
          let map = { V.embed = (fun x -> This.map.V.embed (U.L1 x))
                    ; V.project = (fun v -> match This.map.V.project v with
                                          | U.L1 x -> x
                                          | _ -> raise (V.Projection (v, L1.U.tname)))
                  }
          type 'a state = 'a L1.U.state
          let project_state s = (This.project_state s).U.l1
        end
        module This2 = struct
          module Interp = Interp
          type 'a t = 'a L2.U.t
          let map = { V.embed = (fun x -> This.map.V.embed (U.L2 x))
                    ; V.project = (fun v -> match This.map.V.project v with
                                          | U.L2 x -> x
                                          | _ -> raise (V.Projection (v, L2.U.tname)))
                  }
          type 'a state = 'a L2.U.state
          let project_state s = (This.project_state s).U.l2
        end
        module L1' = L1.M (This1)
        module L2' = L2.M (This2)
        let init g = (L1'.init g; L2'.init g)
      end
  end
end

