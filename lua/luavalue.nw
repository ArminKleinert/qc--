% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
\section{Lua values, parameterized by user data}

As in Lua, we keep the value space simple and small.
Unlike Lua, we have only one kind of function.
The type of [[userdata]] is not specified here; it is intended to be a
functor parameter.

This interface is a key for clients because it not only specifies what
a Lua value is, but also provides higher-order embedding/projection
pairs so that Caml values can be mapped to Lua values and back again.

We begin with embedding/projection, which is shared among all modules
matching [[Luavalue.S]].
We need a synonym because to re-export [[ep]] and [[ep]] would be
consider a circular type defintion.
<<signatures>>=
type ('a, 'b, 'state) ep = { embed : 'a -> 'b; project : 'state -> 'b -> 'a }
type ('a, 'b, 'state) synonym_for_ep = ('a, 'b, 'state) ep = { embed : 'a -> 'b; project : 'state -> 'b -> 'a }
@ 
<<signatures>>=
module type S = sig
  type 'a userdata'
  type info
  type value
    = Nil
    | Number   of float
    | String   of string
    | Function of info * func
    | Userdata of userdata
    | Table    of table
  and func  = state -> value list -> value list
  and table = (value, value) Luahash.t
  and userdata  = value userdata'
  and state = { globals : table
              ; fallbacks : (string, value) Hashtbl.t
              ; mutable callstack : activation list
              ; mutable currentloc : Srcmap.location option (* supersedes top of stack *)
              }
  and activation = info * Srcmap.location option

  val caml_func : func -> value (* each result unique *)
  val lua_func  : file:string -> linedefined:int -> func -> value
  val info      : file:string -> linedefined:int -> info (* must NOT be reused *)
  val eq        : value -> value -> bool
  val to_string : value -> string
  val activation_strings : state -> activation -> string list
  type objname = Fallback of string | Global of string | Element of string * value
  val objname : state -> value -> objname option
     (* 'fallback', 'global', or 'element', name *)

  val state : unit -> state (* empty state, without even fallbacks *)
@ 
Lua tables are not quite like Caml tables, but they are close.
<<signatures>>=
  module Table : sig
    val create : int -> table
    val find   : table -> key:value -> value
    val bind   : table -> key:value -> data:value -> unit
    val of_list : (string * value) list -> table
  end
@ 
Now, for embedding and projection.
This is a key, as it completely replaces the stupid stack-based
interface found in~C.
Instead, we use higher-order functions to whip up functionality as needed.
If a projection fails, it raises [[Projection]] giving the value it
tried to project and a string indicating what it tried to project to.
We re-export [[ep]] to make it easier for clients to get the [[embed]]
and [[project]] fields from the locations of their choice.
WE MIGHT HAVE TO ADD FLEXIBILITY BY MAKING
   [[type 'a map = state -> ('a, value) ep]].
<<signatures>>=
  exception Projection of value * string
  val projection : value -> string -> 'a
  type ('a, 'b, 'state) ep = ('a, 'b, 'state) synonym_for_ep = 
     { embed : 'a -> 'b; project : 'state -> 'b -> 'a }
  type 'a map  = ('a, value, state) ep
  type 'a mapf  (* used to build function maps that curry/uncurry *)
@ 
These functions enable us to convert the basic types.
<<signatures>>=
  val float    : float  map
  val int      : int    map
  val bool     : bool   map
  val string   : string map
  val userdata : userdata map
  val unit     : unit   map
@ 
To convert a value of option type, we represent [[None]] as [[Nil]].
Woe betide you if [[Nil]] is a valid value of your type!
We won't see it.
<<signatures>>=
  val option : 'a map -> 'a option map
@ 
To embed a list of values, we produce a table with a binding of the
length to the name [[n]] and bindings of the values to the numbers $1..n$.
To project a Lua table down to a list, we first look to see if the table 
binds the name~[[n]]. 
If so, we take that to be the number of elements; otherwise we use the table's 
population.  (In the latter case, lists cannot contain [[nil]].)
This way, users are free to include [[n]] or not as they choose.
<<signatures>>=
  val list    : 'a map -> 'a list map   (* does not project nil *)
  val optlist : 'a map -> 'a list map   (* projects nil to empty list *)
@ 
If for some reason a Caml function operates on Lua values, we need an
identity pair.  We also enable functions that expect tables.
<<signatures>>=
  val value  : value map
  val table  : table map
@
Here is the support for converting functions.
First, if one wants a Lua function to be curried (as the Caml
functions are), one can simply use [[-->]].
There's a small gotcha, in that we can't make [[-->]] right
associative.
That's OK, as it probably shouldn't be used for curried functions.

For curried functions that should take lists of arguments in Lua,
we use [[**->]], [[pfunc]], [[func]], [[closure]], and [[result]].
The idea is this: if we have a Caml function type
[[t -> u -> v -> w]], we can turn this into a Lua function of three
arguments by using the embedding/projection pair produced by
\begin{quote}
[[pfunc (t **-> u **-> v **-> result w)]]
\end{quote}
<<signatures>>=
  val ( -->  ) : 'a map  -> 'b map  -> ('a -> 'b) map
  val ( **-> ) : 'a map  -> 'b mapf -> ('a -> 'b) mapf
  val result   : 'a map  -> 'a mapf
  val runit    : unit mapf                         (* for functions w/o results *)
  val values   : value list mapf                   (* functions returning value lists*)
  val func     : 'a mapf -> 'a map                 (* function *)
  val closure  : 'a mapf -> 'a map                 (* function or tbl w/apply method *)
  val pure     : 'a mapf -> 'a            -> value (* pure f = (closure f).embed *)
  val impure   : 'a mapf -> (state -> 'a) -> value (* expose state to function *)
end
@ Here's an example: we embed the [[String.sub]] function, then apply
it to some arguments.
<<tests>>=
let sub = (pfunc (string **-> int **-> int **-> result string)).embed String.sub
let apply = function Function (_, f) -> fun args -> trim1 (f emptystate args)
                   | v -> raise (Projection (v, "function"))
let check = string.project (apply sub [string.embed "hello"; int.embed 0; int.embed 2])
let _ = assert (check = "he")
@ 
If a function is impure (needs access to the Lua state) we use
[[func]].
<<tests>>=
let setglobal {globals=g; fallbacks=f} n v = Table.bind g (String n) v
let sg = ((func (string **-> value **-> runit)).embed setglobal : value)
@ 
For the rest of the interface, we can make Lua values by supplying an
appropriate [[userdata]] type.  
<<signatures>>=
module type USERDATA = sig
  type 'a t                             (* type parameter will be Lua value *)
  val tname : string  (* name of this type, for projection errors *)
  val eq : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
  val to_string : ('a -> string) -> 'a t -> string
end
<<luavalue.mli>>=
<<signatures>>
module Make (U : USERDATA) : S with type 'a userdata'  = 'a U.t 
@
\subsection{Implementation}
<<luavalue.ml>>=
<<signatures>>
module Make (U : USERDATA) : S with type 'a userdata'  = 'a U.t 
= struct
  <<value toplevel>>
  (*<tests>*)
end
@ 
I have to repeat the datatype definition.
<<value toplevel>>=
type 'a userdata'  = 'a U.t
type info = int * string * int (* unique id, filename, linedefined *)
type value
  = Nil
  | Number   of float
  | String   of string
  | Function of info * func
  | Userdata of userdata
  | Table    of table
and func  = state -> value list -> value list
and table = (value, value) Luahash.t
and userdata  = value userdata'
and state = { globals : table
            ; fallbacks : (string, value) Hashtbl.t
            ; mutable callstack : activation list
            ; mutable currentloc : Srcmap.location option (* supersedes top of stack *)
            }
and activation = info * Srcmap.location option
@ 
We need suitable equality.
<<value toplevel>>=
let rec eq x y = match x, y with
| Nil,             Nil             -> true
| Number x,        Number y        -> x = y
| String x,        String y        -> x = y
| Userdata x,      Userdata y      -> U.eq eq x y
| Table x,         Table y         -> x == y
| Function ((x, _, _), _), 
           Function ((y, _, _), _) -> x = y
| _,               _               -> false
@ 
Once we have equality, we can make tables.
<<value toplevel>>=
<<table definition>>
@ 
To make this work, every function gets a unique id.  No exceptions.
<<value toplevel>>=
let info =
  let n = ref 0 in
  fun ~file ~linedefined:line -> (n := !n + 1; (!n, file, line))
let lua_func ~file ~linedefined:line f = Function (info file line, f)
let caml_func = lua_func ~file:"(OCaml)" ~linedefined:(-1)
@ 
<<value toplevel>>=
let rec to_string = function
  | Nil -> "nil"
  | Number x -> string_of_float x
  | String s -> s
  | Function (_, _) -> "function"
  | Userdata u -> U.to_string to_string u
  | Table t  -> "table"
@ 
<<value toplevel>>=
type objname = Fallback of string | Global of string | Element of string * value
let key_matching iter t v =
  let r = ref None in
  iter (fun k v' -> if eq v v' then r := Some k else ()) t;
  !r
let objname g needle =
  match key_matching Hashtbl.iter g.fallbacks needle with
  | Some s -> Some (Fallback s)
  | None -> match key_matching Luahash.iter g.globals needle with
    | Some (String s) -> Some (Global s)
    | _ ->
        let r = ref None in
        Luahash.iter (fun k v ->
          match !r with
          | None -> (match k, v with
            | String n, Table t ->
                (match key_matching Luahash.iter t needle with
                | Some v -> r := Some (Element (n, v))
                | None -> ())
            | _, _ -> ())
          | Some _ -> ()) g.globals;
        !r
<<value toplevel>>=
let activation_strings g ((uid, file, line) as info, current) =
  let first tail = match objname g (Function (info, fun _ _ -> assert false)) with
  | Some (Fallback n) -> "`" :: n :: "' fallback" :: tail
  | Some (Global n)   -> "function " :: n :: tail
  | Some (Element (t, String n)) -> "function " :: t :: "." :: n :: tail
  | Some (Element (t, v))    -> "function " :: t :: "[" :: to_string v :: "]" :: tail
  | None -> "unknown function" :: tail
  in let last = match current with
  | None -> " defined in file " :: file ::
             (if line > 0 then [" at line "; string_of_int line ] else [])
(*  | Some (f, l, c) when f = file ->
      [" at line "; string_of_int l; " column "; string_of_int c]
*)
  | Some (f, l, c) ->
      [" in file "; f; ", line "; string_of_int l; " column "; string_of_int c]
  in match line with
  | 0  -> "main of " :: file :: last
  | -1 -> [file]
  | _  -> first last
@ 
\subsection{Embedding and projection}
Now, for embedding and projection.  More repeats.
<<value toplevel>>=
exception Projection of value * string
let projection v s = raise (Projection(v, s))
type ('a,'b,'state) ep = ('a, 'b,'state) synonym_for_ep = 
  { embed : 'a -> 'b; project : 'state -> 'b -> 'a }
type 'a map  = ('a, value, state) ep
type 'a mapf = 
  { fembed   : 'a -> state -> value list -> value list
  ; fproject : state -> (state -> value list -> value list) -> 'a
  } 
@
Here are the embedding/projection pairs for the simple types.
There are subtle mismatches between Caml types and Lua types, so I do
my best to patch them.
<<value toplevel>>=
let userdata = { embed = (fun x -> Userdata x)
               ; project = fun _ v -> match v with 
                                      | Userdata x -> x
                                      | _ -> raise (Projection (v, U.tname))
               } 

let string = { embed = (fun s -> String s)
             ; project = fun _ v -> match v with
                                  | String s -> s 
                                  | Number x -> string_of_float x
                                  | v -> raise (Projection (v, "string"))
             } 

let is_float_literal s = 
  Luafloat.length (Lexing.from_string s) = String.length s
let pervasive_float = float
let float = { embed = (fun x -> Number x)
            ; project = fun _ v ->
                        match v with
                        | Number x -> x
                        | String s when is_float_literal s -> float_of_string s
                        | v -> raise (Projection (v, "float"))
            } 
<<luafloat.mll>>=
let digit       = ['0'-'9']
let sign        = ['+' '-']
let exp         = ['e''E'] sign? digit+
let number      = digit+ exp?
                | digit+ '.' digit+ exp?
rule length = parse number { Lexing.lexeme_end lexbuf } | _ { -1 }
@ 
<<value toplevel>>=
let to_int x = 
  let n = truncate x in
  if pervasive_float n = x then n else raise (Projection (Number x, "int"))

let int   = { embed = (fun n -> Number (pervasive_float n))
            ; project = fun _ v -> match v with
                                   | Number x -> to_int x 
                                   | v -> raise (Projection (v, "int"))
            } 

let bool  = { embed = (fun b -> if b then String "t" else Nil)
            ; project = fun _ v -> match v with Nil -> false | _ -> true
            } 
let unit =  { embed = (fun () -> Nil)
            ; project = (fun _ v -> match v with Nil -> () 
                                    | v -> raise (Projection (v, "unit")))
            } 
@ 
<<value toplevel>>=
let option t = { embed = (fun v -> match v with None -> Nil | Some x -> t.embed x)
               ; project = (fun g v -> match v with Nil -> None
                                      | v -> Some (t.project g v))
               }
@ 
<<value toplevel>>=
let list' nil_ok (ty : 'a map) = 
  let table l =
    let n = List.length l in
    let t = Table.create n in
    let rec set_elems next = function
      | [] -> Table.bind t (String "n") (Number (pervasive_float n))
      | e :: es -> ( Table.bind t (Number next) (ty.embed e)
                   ; set_elems (next +. 1.0) es)
    in  (set_elems 1.0 l; Table t)
  in
  let untable g (t:table) =
    let n = match Table.find t (String "n") with
    | Number x -> to_int x
    | v -> Luahash.population t  in
    let rec elems i =
      if i > n then []
      else ty.project g (Table.find t (Number (pervasive_float i))) :: elems (i + 1) in
    elems 1
  in { embed = table; project = (fun g v -> match v with
                                        | Table t -> untable g t
                                        | Nil when nil_ok -> []
                                        | v -> raise (Projection (v, "list"))) }
let list    ty = list' false ty
let optlist ty = list' true  ty
@
<<value toplevel>>=
let value = { embed = (fun x -> x); project = (fun _ x -> x) }
let table = { embed = (fun x -> Table x)
            ; project = fun g v -> match v with Table t -> t
                                   | v -> raise (Projection (v, "table"))
            }
@ 
Here is a simple function from one argument to one result.
We implement the usual Lua game of ``adjusting'' the argument list.
<<value toplevel>>=
let trim1 = function  (* trim list of arguments to a single argument *)
  | [] -> Nil
  | h::t -> h

let const f s = f
let state () = 
 { globals = Table.create 50; fallbacks = Hashtbl.create 10; callstack = [];
   currentloc = None }
let emptystate = state()
@ 
There's a horrible choice here.  Do we use the state where the
function is embedded or where it is applied.
Presumably where it is applied is right is really right, but would
botch a pure function.
Maybe we need [[val state : 'a map -> (state -> 'a) map]]?
<<value toplevel>>=
let (-->) arg result =
  { embed =   (fun f -> 
               caml_func (fun g args -> [result.embed (f (arg.project g (trim1 args)))]))
  ; project = fun g v ->
              match v with
              | Function (_, f) -> 
                  fun x -> result.project g (trim1 (f emptystate [arg.embed x]))
              | v -> raise (Projection (v, "function"))
  } 
@ 
What we have above would be enough, except that Caml likes functions
to be curried and Lua likes them uncurried.
We provide [[**->]], [[result]], and [[func]] for embedding and
projecting curried functions.
The functions are a bit subtle, but if you follow the types, you
shouldn't be too baffled. 
<<value toplevel>>=
let ( **-> ) (firstarg : 'a map) (lastargs : 'b mapf) : ( ('a -> 'b) mapf ) =
  let apply (f : 'a -> 'b) g args = 
    let h, t = match args with [] -> Nil, [] | h :: t -> h, t in
    let f = f (firstarg.project g h) in
    lastargs.fembed f g t
  in
  let unapp g f' =
    fun (x : 'a) -> lastargs.fproject g (fun g t -> f' g (firstarg.embed x :: t)) in
  { fembed = apply; fproject = unapp }

let result (r : 'a map) : ('a mapf) = 
  { fembed   = (fun f -> fun g args -> [r.embed f])
  ; fproject = (fun g f -> r.project g (trim1 (f g [])))
  } 

let runit = { fembed   = (fun () g args -> [])
            ; fproject = (fun g f -> match f g [] with [] -> ()
                                    | h::t -> raise (Projection (h, "unit result")))
            } 

let values : value list mapf =
  { fembed = (fun l g args -> l); fproject = (fun g f -> assert false)
  } 

let func (arrow : 'a mapf) : ('a map) =
  { embed   = (fun (f : 'a) -> caml_func (arrow.fembed f))
  ; project = (fun g v -> match v with
                          | Function (_, f) -> (arrow.fproject g f : 'a)
                          | v -> raise (Projection (v, "function")))
  } 

let impure arrow f = caml_func (fun g -> arrow.fembed (f g) g)

let closure (arrow : 'a mapf) : ('a map) =
  { embed   = (fun (f : 'a) -> caml_func (arrow.fembed f))
  ; project = (fun g v -> match v with
                          | Function (_, f) -> (arrow.fproject g f : 'a)
                          | Table t as v -> (<<project table [[t]] into a function>>)
                          | v -> raise (Projection (v, "function")))
  } 

let pure arrow = (closure arrow).embed
@
A table is a function if it has an apply method that is a function.
<<project table [[t]] into a function>>=
let f = try Table.find t (String "apply")
        with Not_found -> raise (Projection (v, "function"))  in
match f with
| Function (_, f) ->
    let f' g vs = f g (v :: vs) in arrow.fproject g f'
| v -> raise (Projection (v, "'apply' element of table as function"))
@ 
Lua tables are very nearly Caml hash tables, except they never have
multiple elements.
<<table definition>>=
module Table = struct
  let create = Luahash.create eq
  let find t ~key:k = try Luahash.find t k with Not_found -> Nil
  let bind t ~key:k ~data:v =
    match v with
    | Nil -> Luahash.remove t k
    | _ -> Luahash.replace t k v
  let of_list l =
    let t = create (List.length l) in
    let _ = List.iter (fun (k, v) -> bind t (String k) v) l in
    t
end
@ 
