% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Core interpreter for Lua statements and expressions}
<<signatures>>=
module type S = sig
  module Value : Luavalue.S
  module Ast : Luaast.S with module Value = Value
  type state = Value.state
  type value = Value.value
  exception Error of string
  val compile : srcdbg:(Srcmap.map * bool) -> Ast.chunk list -> state -> value list
  val test : unit -> (string * value list) list
  val state : unit -> state  (* produce a fresh, initialized state *)
  val error : state -> string -> 'a  (* error fallback *)

  val getglobal : state -> value -> value
  val with_stack  : Value.info -> state -> ('a -> 'b) -> 'a -> 'b
  val fallback : string -> state -> value list -> value list

  val setfallback : state -> string -> value -> value
    (* sets fallback, returns previous one *)
  val register_globals :           (string * value) list -> state -> unit
    (* registers values as named global variables *)
  val register_module  : string -> (string * value) list -> state -> unit
    (* register_module t l inserts members of l into global table t, 
       creating t if needed *)
end
@ 

<<luainterp.mli>>=
<<signatures>>
module Make (T : Lualib.COMBINED_TYPE)
                  (L : Lualib.TYPEFUL with type 'a combined = 'a T.t) :
    S with type 'a Value.userdata'  = 'a T.t
@ 
\subsection{Implementation}
@ 
<<luainterp.ml>>=
<<signatures>>
type answer = unit * string * bool
module Make  (T : Lualib.COMBINED_TYPE)
                  (L : Lualib.TYPEFUL with type 'a combined = 'a T.t) :
    S with type 'a Value.userdata'  = 'a T.t = struct
  module U = struct
    type 'a t = 'a T.t
    let tname = T.tname
    let eq = T.eq
    let to_string = T.to_string
  end
  module Value = Luavalue.Make(U)
  module Ast = Luaast.Make (Value)
  module I = struct
    type state = Value.state
    type value = Value.value
    <<interp toplevel>>
    <<interp fallbacks>>
    <<interp registration>>
    <<interp tests>>
  end
  module Core = struct
    include I
  end
  module L' = L.M(Core)
  include I
  let state () =
    let g = V.state() in
    add_fallbacks g;
    L'.init g;
    g

end (* Make *)
@
Abbreviate!
<<interp toplevel>>=
module A = Ast
module V = Ast.Value
@
<<interp fallbacks>>=
let error g s =
  ignore (fallback "error" g [V.String s]);
  raise (Error "Error fallback returned a value")
<<interp fallbacks>>=
let errorfallback s = fun g args -> fallback "error" g [V.String s]
let arithfallback g = function
  | [V.Number x; V.Number y; V.String s] when s = "pow" -> [V.Number (x ** y)]
  | args -> errorfallback "unexpected type at conversion to number" g args
      
let fbs =
  [ "arith",     arithfallback
  ; "order",     errorfallback "unexpected type at comparison"
  ; "concat",    errorfallback "unexpected type at conversion to string"
  ; "index",     (fun g args -> [V.Nil])
  ; "getglobal", (fun g args -> [V.Nil])
  ; "gettable",  errorfallback "indexed expression not a table"
  ; "settable",  errorfallback "indexed expression not a table"
  ; "function",  errorfallback "call expression not a function"
  ; "error",     default_error_fallback
  ] 
(* make default fallbacks; provide state in V *)
let add_fallbacks g =
  List.iter (fun (k, f) -> Hashtbl.add g.V.fallbacks k (V.caml_func f)) fbs 
@ 
must be able to manage stack correctly
<<interp toplevel>>=
let currentloc_tostack g =
  match g.V.callstack with
  | (info, _) :: t -> g.V.callstack <- (info, g.V.currentloc) :: t
  | [] -> ()

let currentloc_fromstack g =
  match g.V.callstack with
  | (info, where) :: _ -> g.V.currentloc <- where
  | [] -> ()
@ 
Fallbacks can't use the ordinary [[cpscall]] because this could lead
to an infinite loop. 

\emph{Contemplating two revisions: (1)~pass state before args, as in
the function value; (2)~get rid of continuations for calls, since they
don't seem to be doing anything useful.}
<<interp toplevel>>=
exception Error of string
let default_error_fallback g args = 
  let msg = match args with V.String s :: _ -> s | _ -> "??error w/o message??" in
  prerr_string "lua: ";
  prerr_endline msg;
  prerr_endline "Stack trace:";
  currentloc_tostack g;
  List.iter (fun a -> prerr_string "  ";
             List.iter prerr_string (V.activation_strings g a);
             prerr_endline "") g.V.callstack;
  raise (Error msg)

<<state dumping>>

let rec fallback fbname g args =
  let call f g args = match f with
  | V.Function (_, f) -> f g args
  | v when fbname <> "function" -> fallback "function" g (v :: args)
  | v -> default_error_fallback g [V.String "`function' fallback not a function"] in
  let fbval = try Hashtbl.find g.V.fallbacks fbname
              with Not_found -> <<fallback failure>>
  in call fbval g args
<<fallback failure>>=
begin
  prerr_string "no fallback named `";
  prerr_string fbname;
  prerr_endline "' (probably registered an impure function as pure)";
  dump_state g;
  assert false (* can't have any unknown fallbacks *)
end
@ 
Everybody else can use a call that falls back to the fallback.
If the types don't match, we have to do something.
This problem has no counterpart in the C~version, in which it's up to
each individual C~routine to worry about type mismatches.
<<interp toplevel>>=
let cpscall f args g k = match f with
  | V.Function (_, f) ->
      k (try (f g args) with
         | V.Projection (v, what) -> <<projection error fallback>>
         | Invalid_argument msg -> <<argument error fallback>>)
  | v -> k (fallback "function" g (v :: args))

let apply f g args = cpscall f args g (fun x -> x)

<<projection error fallback>>=
fallback "error" g [V.String ("cannot convert value " ^ V.to_string v ^ " to " ^ what)]
<<argument error fallback>>=
fallback "error" g [V.String ("Function raised Invalid_argument " ^ msg)]
@      
To use a fallback or function call in a situation where we expect
exactly one result, we adjust the results.
We do this by maniupulating continuations.
<<interp toplevel>>=
let trim1 = function [] -> V.Nil | h :: t -> h
let fb1 name state args = trim1 (fallback name state args)
@ 
Operators, like everything else, use CPS
<<interp toplevel>>=
let arith opname op =
  let opname = V.String opname in
  let f x y g = try
    let x = V.float.V.project x in
    let y = V.float.V.project y in
    V.float.V.embed (op x y)
  with V.Projection (_, _) -> fb1 "arith" g [x; y; opname]
  in f
<<interp toplevel>>=
let negate x g = try
  let x = V.float.V.project x in
  V.float.V.embed (~-. x)
  with V.Projection (_, _) -> fb1 "arith" g [x; V.Nil; V.String "umn"]
<<interp toplevel>>=
let order opname nop sop =
  let opname = V.String opname in
  let f x y g =
    match x, y with
    | V.Number x, V.Number y -> V.bool.V.embed (nop x y)
    | _ -> try let x = V.string.V.project x in
               let y = V.string.V.project y in
               V.bool.V.embed (sop x y)
           with V.Projection (_, _) -> fb1 "order" g [x; y; opname]
  in f
<<interp toplevel>>=
let concat x y g =
  try let x = V.string.V.project x in
      let y = V.string.V.project y in
      V.string.V.embed (x ^ y)
  with V.Projection (_, _) -> fb1 "concat" g [x; y]
<<interp toplevel>>=
let binop = function
  | A.Plus   -> arith "add" (+.)
  | A.Minus  -> arith "sub" (-.)
  | A.Times  -> arith "mul" ( *. )
  | A.Div    -> arith "div" ( /. )
  | A.Pow    -> fun x y g -> fb1 "arith" g [x; y; V.String "pow"]
  | A.Lt     -> order "lt" (<)  (<)
  | A.Le     -> order "le" (<=) (<=)
  | A.Gt     -> order "gt" (>)  (>)
  | A.Ge     -> order "ge" (>=) (>=)
  | A.Eq     -> fun x y g -> V.bool.V.embed (V.eq x y)
  | A.Ne     -> fun x y g -> V.bool.V.embed (not (V.eq x y))
  | A.And    -> assert false (* short circuit *)
  | A.Or     -> assert false (* short circuit *)
  | A.Concat -> concat
  | A.Not    -> assert false (* unary *)

let unop = function
  | A.Minus  -> negate
  | A.Not    -> fun v g -> (match v with V.Nil -> V.Number 1.0 | _ -> V.Nil)
  | _        -> assert false (* all other operators are binary *)
<<interp toplevel>>=
let index g t key = match t with
| V.Table t ->
    (match V.Table.find t key with
    | V.Nil -> trim1 (fallback "index" g [V.Table t; key])
    | v -> v)
| _ -> trim1 (fallback "gettable" g [t; key])

let settable g t key v = match t with
| V.Table t -> V.Table.bind t key v
| _ -> ignore (fallback "settable" g [t; key; v])

<<interp toplevel>>=
let getglobal g k =
  match V.Table.find g.V.globals k with
  | V.Nil -> trim1 (fallback "getglobal" g [k])
  | v -> v
<<interp toplevel>>=
type var = Global | Local of int
let lookup rho x =
  let rec look = function
    | [] -> Global
    | h :: t when h = x -> Local (List.length t)
    | h :: t -> look t
  in look rho

@ 
To avoid allocation, we allocate locals as temporaries.
The argument [[temp_start]] shows where to allocate the next
temporary.
The semantics of [[exp]] are now as follows:
\begin{itemize}
\item
As early parameters, it takes an expression [[exp]], environment
[[rho]], continuation [[theta]], and index [[loc]] (the location in
the locals into which to put the result).
\item
This function returns a dynamic function that maps global and local
state to answers, and as a side effect deposits the result of
evaluating the expression in [[locals.(loc)]].
\end{itemize}

<<interp toplevel>>=
let setlocal locals n v = Array.set locals n v    (* could be made unsafe *)
let getlocal locals n   = Array.get locals n 

let rec getlocals locals n count =
  if count = 0 then []
  else getlocal locals n :: getlocals locals (n+1) (count-1)

type 'a cont = V.state -> V.value array -> 'a

<<definitions of [[exp]], [[explist]], and friends>>

<<definitions of [[exp]], [[explist]], and friends>>=
let rec exp localref =
  let rec exp rho e loc theta = 
    let finish g l v = setlocal l loc v; theta g l in
    match e with
    | A.Var x -> localref loc;
                 (match rho x with
                  | Global -> fun g l -> finish g l (getglobal g (V.String x))
                  | Local n -> fun g l -> finish g l (getlocal l n))
    | A.Lit v -> localref loc; fun g l -> finish g l v
    | A.Index (tab, key) ->
        let tabloc = loc in
        let keyloc = loc + 1 in
        let theta g l = finish g l (index g (getlocal l tabloc) (getlocal l keyloc)) in
        exp rho tab tabloc (exp rho key keyloc theta) 
@ 
In a table literal, the keys are static, but the values are dynamic.
Luckily, however, we can bind away each value as soon as it is
produced, so we need only one temporary location for values.
Internally we would like to  use a special [[theta]] that takes
\emph{three} dynamic parameters: global, local, and table.
But this would require polymorphic recursion.
<<definitions of [[exp]], [[explist]], and friends>>=
    | A.Table (lists, bindings) ->
        localref loc;                     (* needed if table is empty *)
        let tabloc = loc in
        let vloc   = loc + 1 in
        let tbl l = match getlocal l tabloc with V.Table t -> t | _ -> assert false in
        let rec listbind n theta = function
          | [] -> bind theta bindings
          | h::t ->
              let theta = listbind (n +. 1.0) theta t in
              let theta = fun g l -> V.Table.bind (tbl l) (V.Number n) (getlocal l vloc);
                                     theta g l
              in  exp rho h vloc theta
        and bind theta = function
          | [] -> theta
          | (n, h) :: t ->
              let theta = bind theta t in
              let theta = fun g l -> V.Table.bind (tbl l) (V.String n) (getlocal l vloc);
                                     theta g l
              in  exp rho h vloc theta in
        let size = List.length bindings + List.length lists in
        let theta = listbind 1.0 theta lists in
        fun g l ->
          let t = V.Table.create size in
          setlocal l tabloc (V.Table t);
          theta g l
<<definitions of [[exp]], [[explist]], and friends>>=
    | A.Binop (e1, op, e2) ->
        let short_circuit theta_t theta_f = fun g l ->
          match getlocal l loc with
          | V.Nil -> theta_f g l
          | _ ->     theta_t g l in
        ( match op with
        | A.And -> exp rho e1 loc (short_circuit (exp rho e2 loc theta) theta)
        | A.Or  -> exp rho e1 loc (short_circuit theta (exp rho e2 loc theta))
        | _ ->
            let loc1 = loc in
            let loc2 = loc + 1 in
            let op = binop op in
            exp rho e1 loc1 (
            exp rho e2 loc2 (
            fun g l -> finish g l (op (getlocal l loc1) (getlocal l loc2) g))))
    | A.Unop (op, e) ->
        let op = unop op in
        exp rho e loc (fun g l -> finish g l (op (getlocal l loc) g))
<<definitions of [[exp]], [[explist]], and friends>>=
    | A.Call c ->
        localref loc;
        let theta = fun results g (l:V.value array) ->
                      setlocal l loc (trim1 results); theta g l in
        call localref c rho loc theta
in  exp
@ 
<<definitions of [[exp]], [[explist]], and friends>>=
and explist localref rho es loc theta = match es with
| [] -> theta
| e :: es -> exp localref rho e loc (explist localref rho es (loc+1) theta)
and call localref c rho loc theta = match c with
| A.Funcall (f, args) ->
    let argcount = List.length args in
    let argloc = loc + 1 in
    exp localref rho f loc (
    explist localref rho args argloc
      (fun g l ->
        let fv   = getlocal l loc in
        let argv = getlocals l argloc argcount in
        theta (cpscall fv argv g (fun x -> x)) g l))
| A.Methcall (obj, meth, args) ->
    let mloc = loc in
    let selfloc = mloc + 1 in
    let argloc = selfloc + 1 in
    let argcount = List.length args + 1 in
    let meth = V.String meth in
    exp localref rho obj selfloc (
    let theta_m = explist localref rho args argloc
        (fun g l ->
          let fv = getlocal l loc in
          let argv = getlocals l selfloc argcount in
          theta (cpscall fv argv g (fun x -> x)) g l) in
    fun g l -> setlocal l mloc (index g (getlocal l selfloc) meth); theta_m g l)
@ 
Static environment for a statement includes list of local variables.
Dynamic continuations include return continuation and standard
continuation.
We make a separate function to compute max number of locals.
<<interp toplevel>>=
let notnil = function
  | V.Nil -> false
  | _ -> true

(*
let (_ : (string -> var) -> A.exp -> int -> 'a cont -> 'a cont) = exp' (fun _ -> ())

let (pexp : (string -> var) -> A.exp -> int -> answer cont -> answer cont) = exp' (fun _ -> ())
*)
let show_locals rho = ()
(*
  prerr_string "=============\n";
  List.iter (fun x ->
    List.iter prerr_string ([x; " is "] @
                            match lookup rho x with
                            | Local n -> [" local variable "; string_of_int n; "\n"]
                            | Global -> ["global\n"])) rho;
  prerr_endline ""
*)

<<interp toplevel>>=
let rec extend rho = function
  | A.Stmt' (_, s) -> extend rho s
  | A.Local (vs, _) -> List.rev_append vs rho
  | _ -> rho
@ 
<<interp toplevel>>=
let block_compiler (srcmap, debug) =
  let high_local_limit = ref 0 in
  let localref n = if n >= !high_local_limit then high_local_limit := n+1 in
  let local_size () = !high_local_limit in
  <<definitions of [[block]], [[stmt]], and friends>>
  in  (block:string list -> A.block -> 'a cont -> (V.value list -> 'a) -> 'a cont), local_size
@ 
For statements (although not for expressions), the ordinary and return
continuations can be static parameters.  This setup approximates
direct threaded code.  A little ref-cell jujitsu is needed to make
loops work.
<<definitions of [[block]], [[stmt]], and friends>>=
let rec stmt rho s theta ret = match s with
  | A.Stmt' (charpos, s) ->
      if debug then
        let where = Srcmap.location srcmap charpos in
        let n = ref None in
        let restore g = g.V.currentloc <- !n in
        let restore_cont g l = (restore g; theta g l) in
        let run_cont =
          fun g l -> stmt rho s restore_cont (fun ans -> restore g; ret ans) g l in
        fun g l -> ( n := g.V.currentloc
                   ; g.V.currentloc <- Some where
                   ; run_cont g l
                   ) 
            (* hard to maintain current line if exn raised ... *)
      else
        stmt rho s theta ret
  | A.WhileDo (cond, body) ->
      let loop_cont = ref theta in  (* to become loop continuation *)
      let goto_head g l = !loop_cont g l in
      let condloc = List.length rho in
      let body = block rho body goto_head ret in
      let loop =
        exp localref (lookup rho) cond condloc
          (fun g l -> if notnil (getlocal l condloc) then body g l else theta g l) in
      let _ = loop_cont := loop in
      loop
  | A.RepeatUntil (body, cond) ->
      let loop_test = ref theta in (* to become loop-end continuation *)
      let goto_test g l = !loop_test g l in
      let condloc = List.length rho in
      let body = block rho body goto_test ret in
      let loop =
        exp localref (lookup rho) cond condloc
          (fun g l -> if notnil (getlocal l condloc) then theta g l else body g l) in
      let _ = loop_test := loop in
      body
  | A.If (c, t, alts, f) ->
      let alts = (c, t) :: alts in
      let f = block rho (match f with None -> [] | Some ss -> ss) theta ret in
      let condloc = List.length rho in
      let add (cond, body) f =
        let body = block rho body theta ret in
        exp localref (lookup rho) cond condloc (
          fun g l -> if notnil (getlocal l condloc) then body g l else f g l)  in
      List.fold_right add alts f
  | A.Return es ->
      let loc = List.length rho in
      let result_count = List.length es in 
      explist localref (lookup rho) es loc (fun g l -> ret (getlocals l loc result_count))
  | A.Local (vs, es) ->
      show_locals (List.rev_append vs rho);
      stmt (List.rev_append vs rho) (A.Assign (List.map (fun x -> A.Lvar x) vs, es))
      theta ret
  | A.Assign (vs, [A.Call c]) ->
      lvars localref (lookup rho) (List.length rho) vs (fun setlvs loc ->
        call localref c (lookup rho) loc (fun vs g l ->
          setlvs g l vs;
          theta g l))
  | A.Assign (vs, es) ->
      let rhscount = List.length es in
      lvars localref (lookup rho) (List.length rho) vs (fun setlvs loc ->
        explist localref (lookup rho) es loc (fun g l ->
          setlvs g l (getlocals l loc rhscount);
          theta g l))
  | A.Callstmt c -> call localref c (lookup rho) (List.length rho) (fun vs -> theta)
and block rho body (theta:'a cont) (ret:V.value list -> 'a) = match body with
  | [] -> theta
  | s :: ss -> stmt rho s (block (extend rho s) ss theta ret) ret
@ 
How are we to deal with assigment?
One problem is that the number of right-hand sides cannot always be
bound statically.  But since the number of \emph{left} hand sides is
bound statically, maybe we can pull a bit of a cheat there.

So here's the idea: pass a continuation builder for putting all the right-hand
sides in place, then continue with them.

What's the control flow like?
Well, first we evaluate the lvalue, which may mean using some temps
and then pulling them immediately. 
Then we do the next lvalue and so on.
Then the next step is the rvalues, and for each rvalue, we must have
some sort of dynamic thingummy built up.
When I get this figured out, it should go in the paper!

Argument [[nextlvar]] passed to [[lvar]]
takes a setter for the current lvar and also the
index of the next free location in the temporary space.
The setter takes global and local state, plus a value, and it is
executed only for side effect.
Argument [[finish]] passed to [[lvars]] is similar, except its setter
takes a list of values. 
<<definitions of [[block]], [[stmt]], and friends>>=
and lvar localref rho lv lhsloc nextlvar = 
  let rhs l = getlocal l in
  match lv with
  | A.Lvar x -> 
      let setx = match rho x with
      | Global  -> fun g l v -> V.Table.bind g.V.globals (V.String x) v
      | Local n -> fun g l v -> setlocal l n v in
      nextlvar setx lhsloc
  | A.Lindex (t, key) ->
      let keyloc = lhsloc + 1 in
      let setidx = exp localref rho t lhsloc (exp localref rho key keyloc (fun g l v ->
                    let t = getlocal l lhsloc in
                    let key = getlocal l keyloc in
                    settable g t key v)) in
      nextlvar setidx (lhsloc+2)
and lvars localref rho loc lvs finish = match lvs with
  | [] -> finish (fun g l vs -> ()) loc
  | h :: t ->
      lvar localref rho h loc (fun setter loc ->
        lvars localref rho loc t (fun setlvs loc ->
          let setlvs g l vs =
            let v, vs = match vs with h::t -> h, t | [] -> V.Nil, [] in
            setter g l v;
            setlvs g l vs in
          finish setlvs loc))
@ 
Chunks are executed by compiling functions.
<<interp toplevel>>=
let with_stack info g f x =
  let _ = currentloc_tostack g in
  let _ = g.V.callstack <- (info, None) :: g.V.callstack in
  let pop () = g.V.callstack <- List.tl g.V.callstack; currentloc_fromstack g in
  let answer = try f x with e -> (pop(); raise e) in
  let _ = pop() in
  answer

let value_list = V.list V.value
let lambda srcdbg (file, line, col) args varargs body =
  let rho = let args' = List.rev args in if varargs then "arg" :: args' else args' in
  let block, count = block_compiler srcdbg in
  let body = block rho body (fun g l -> []) (fun results -> results) in
  let n = count() in
  let info = V.info file line in
  info, 
  fun state argv ->
    let locals = Array.make n V.Nil in
    let rec walk n formals actuals = match formals with
      | [] -> if varargs then Array.set locals n (value_list.V.embed actuals)
      | f :: fs ->
          let a, a's = match actuals with [] -> V.Nil, [] | h :: t -> h, t in
          (Array.set locals n a; walk (n+1) fs a's)  in
    let _ = walk 0 args argv in
    with_stack info state (body state) locals

let (_ : Srcmap.map * bool -> Srcmap.location -> string list -> bool -> A.block -> V.info * V.func) = lambda
@ 
<<interp toplevel>>=
let expname = function
  | A.Var v -> v
  | _ -> "?"
let funname = function
  | A.Lvar v -> v
  | A.Lindex (e, A.Lit (V.String s)) -> expname e ^ "." ^ s
  | A.Lindex (e, e') -> expname e ^ "[" ^ expname e' ^ "]"
let func (info, f) = V.Function (info, f)
let chunk ((smap, dbg) as srcdbg) block rho = function
  | A.Statement s -> block rho [s]
  | A.Fundef (pos, f, args, varargs, body) ->
      let v = func (lambda srcdbg (Srcmap.location smap pos) args varargs body) in
      block rho [A.Assign ([f], [A.Lit v])]
  | A.Methdef (pos, obj, meth, args, varargs, body) ->
      let args = "self" :: args in
      let v = func (lambda srcdbg (Srcmap.location smap pos) args varargs body) in
      block rho [A.Assign ([A.Lindex (obj, A.Lit (V.String meth))], [A.Lit v])]

let extendchunk rho = function
  | A.Statement s -> extend rho s
  | _ -> rho

let wrap f x = let l = f x in (prerr_string "function returned ";
                               prerr_int (List.length l);
                               prerr_endline " values";
                               l)

let compile ~srcdbg cs = 
  let block, count = block_compiler srcdbg in
  let block = (block : string list -> A.block -> 'a cont -> (V.value list -> 'a) -> 'a cont) in
  let ret = fun results -> results in
  let rec chunks rho = function
    | [] -> fun g l -> []
    | h :: t -> chunk srcdbg block rho h (chunks (extendchunk rho h) t) ret in
  let theta = chunks [] cs in
  let locals = Array.make (count()) V.Nil in
  fun g -> theta g locals
@ 
<<interp toplevel>>=
let setfallback g fbname fb =
  let fb' = try Hashtbl.find g.V.fallbacks fbname with Not_found -> V.Nil in
  let _ = Hashtbl.replace g.V.fallbacks fbname fb in
  fb'
@ 



<<interp tests>>=  
let nil = A.Lit V.Nil
let three = A.Lit (V.Number 3.0)

let ret = A.Return ([nil; three])

let test_state = V.state ()

let bogusmap = Srcmap.mk ()
let stmts l = compile ~srcdbg:(bogusmap, false) (List.map (fun s -> A.Statement s) l)

let num n = A.Lit (V.Number (float n))
let rtest = stmts [ret]
let sum = stmts [A.Return ([A.Binop (three, A.Plus, three)])]
let exp = stmts [A.Return ([A.Binop (three, A.Times, A.Binop (num 2, A.Minus, three))])]
let x = A.Var "x"
let gets x e = A.Assign ([A.Lvar x], [e])
let binary op e1 e2 = A.Binop (e1, op, e2)
let lt = binary A.Lt
let times = binary A.Times
let loop = [ gets "x" (num 10)
               ; A.WhileDo (lt x (num 100), [gets "x" (times (num 2) x)])
               ; A.Return [x]]

let test _ =
  [ "return nil and three", rtest test_state
      ; "sum of three and three", sum test_state
      ; "expression minus three", exp test_state
      ; "result of loop", stmts loop test_state
  ] 
@ 
\section{Caveats}

Builtin [[type]] doesn't return a tag.
@
<<state dumping>>=
let dump_state g = 
  let err = prerr_string in
  let int = prerr_int in
  let rec value = function
    | V.Table t -> tab t ""
    | v -> err (V.to_string v)
  and tab t sfx =
    err "{"; Luahash.iter (fun k d -> err " "; value k; err "="; value d; err ",") t;
    err "}"; err sfx in
  let stab t sfx =
    err "{"; Hashtbl.iter (fun k d -> err " "; err k; err "="; value d; err ",") t;
    err "}"; err sfx in
  err "state is: \n";
  err "  globals =\n    ";
  tab g.V.globals "\n";
  err "  fallbacks =\n    ";
  stab g.V.fallbacks "\n";
  default_error_fallback g [V.String "Stack trace is:"]

@ 
<<interp registration>>=
let register_globals l g =
  List.iter (fun (k, v) -> V.Table.bind g.V.globals (V.String k) v) l

let register_module tabname members g =
  let t = getglobal g (V.String tabname) in
  let t = match t with
  | V.Nil       -> V.Table.create (List.length members)
  | V.Table t   -> t
  | _           -> error g ("Global value " ^ tabname ^ " is not (table or nil)") in
  let _ = V.Table.bind g.V.globals (V.String tabname) (V.Table t) in
    List.iter (fun (k, v) -> V.Table.bind t (V.String k) v) members
