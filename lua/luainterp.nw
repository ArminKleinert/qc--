% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

\section{Experiment for embedding lua in caml}

If we are to configure the compiler dynamically, we need a
configuration language.  I'm proposing we borrow Lua, version~2.5,
but with a Caml interface based on a style of embedding and projection
that is inspired by Olivier Danvy's work on type-directed partial
evaluation. 
This file sketches some of the supporting details, focusing on the
embedding and projection, which is the new part.
<<lua.mli>>=
<<signatures>>
module MkInterp (XYZ : Ast.S) : INTERP (* with module Ast = XYZ *)
@ 
\subsection{Implementation}
<<lua.ml>>=
<<signatures>>
@ 
\subsection{Steps toward the full language}
@ 
<<signatures>>=
module type INTERP = sig
  module Value : Value.S
  module Ast : Ast.S with module Value = Value
  type state = Value.state
  type value = Value.value
  exception Error of string
  val compile : Ast.chunk list -> state -> value list
  val test : unit -> (string * value list) list
  val fallbacks : unit -> state
  val error : state -> string -> unit  (* error fallback *)

  val getglobal : state -> string -> value
  val with_stack : string -> state -> ('a -> 'b) -> 'a -> 'b
  val fallback : string -> state -> value list -> value list
end
<<lua.ml>>=
module MkInterp (ZZZ : Ast.S) : INTERP (*with module Ast = ZZZ
                                     with module Value = Ast.Value*) = struct 
  module Value = ZZZ.Value
  module Ast : Ast.S with module Value = Value = ZZZ
  type state = Value.state
  type value = Value.value
  <<interp toplevel>>
  <<interp fallbacks>>
  <<interp tests>>
end
@ 
Abbreviate!
<<interp toplevel>>=
module A = Ast
module V = Ast.Value
@
<<interp fallbacks>>=
let error g s = ignore (fallback "error" g [V.String s])
<<interp fallbacks>>=
let errorfallback s = fun g args -> fallback "error" g [V.String s]
let arithfallback g = function
  | [V.Number x; V.Number y; V.String s] when s = "pow" -> [V.Number (x ** y)]
  | args -> errorfallback "unexpected type at conversion to number" g args
      
let fbs =
  [ "arith",     arithfallback
  ; "order",     errorfallback "unexpected type at comparison"
  ; "concat",    errorfallback "unexpected type at conversion to string"
  ; "index",     (fun g args -> [V.Nil])
  ; "getglobal", (fun g args -> [V.Nil])
  ; "gettable",  errorfallback "indexed expression not a table"
  ; "settable",  errorfallback "indexed expression not a table"
  ; "function",  errorfallback "call expression not a function"
  ; "error",     default_error_fallback
  ] 
let fallbacks () =
  let t = Hashtbl.create (List.length fbs) in
  let _ = List.iter (fun (k, f) -> Hashtbl.add t k (V.Function f)) fbs in
  { V.globals = V.Table.create 50
  ; V.fallbacks = t
  ; V.callstack = []
  }
@ 
Fallbacks can't use the ordinary [[cpscall]] because this could lead
to an infinite loop. 

\emph{Contemplating two revisions: (1)~pass state before args, as in
the function value; (2)~get rid of continuations for calls, since they
don't seem to be doing anything useful.}
<<interp toplevel>>=
exception Error of string
let default_error_fallback g args = 
  let msg = match args with V.String s :: _ -> s | _ -> "??error w/o message??" in
  prerr_string "lua: ";
  prerr_endline msg;
  prerr_endline "Stack trace:";
  List.iter (fun f -> prerr_string "  "; prerr_endline f) g.V.callstack;
  raise (Error msg)

let rec fallback fbname g args =
  let call f g args = match f with
  | V.Function f -> f g args
  | v when fbname <> "function" -> fallback "function" g (v :: args)
  | v -> default_error_fallback g [V.String "`function' fallback not a function"] in
  let fbval = try Hashtbl.find g.V.fallbacks fbname
              with Not_found -> <<fallback failure>>
  in call fbval g args
<<fallback failure>>=
begin
  prerr_string "no fallback named `";
  prerr_string fbname;
  prerr_endline "'";
  assert false (* can't have any unknown fallbacks *)
end
@ 
Everybody else can use a call that falls back to the fallback.
If the types don't match, we have to do something.
This problem has no counterpart in the C~version, in which it's up to
each individual C~routine to worry about type mismatches.
<<interp toplevel>>=
let cpscall f args g k = match f with
  | V.Function f ->
      k (try (f g args) with V.Projection (v, what) -> <<projection error fallback>>)
  | v -> k (fallback "function" g (v :: args))

<<projection error fallback>>=
fallback "error" g [V.String ("cannot convert value " ^ V.to_string v ^ " to " ^ what)]
@      
To use a fallback or function call in a situation where we expect
exactly one result, we adjust the results.
We do this by maniupulating continuations.
<<interp toplevel>>=
let trim1 = function [] -> V.Nil | h :: t -> h
let adjust1 (f : (V.value list -> 'answer) -> 'answer) : (V.value -> 'answer) -> 'answer =
  fun k -> f (fun x -> k (trim1 x))
let fb1 name state args k = k (trim1 (fallback name state args))
@ 
Operators, like everything else, use CPS
<<interp toplevel>>=
let arith opname op =
  let opname = V.String opname in
  let f x y g = try
    let x = V.float.V.project x in
    let y = V.float.V.project y in
    fun k -> k (V.float.V.embed (op x y))
  with V.Projection (_, _) -> fb1 "arith" g [x; y; opname]
  in f
<<interp toplevel>>=
let negate x g k = try
  let x = V.float.V.project x in
  k (V.float.V.embed (~-. x))
  with V.Projection (_, _) -> fb1 "arith" g [x; V.Nil; V.String "umn"] k
<<interp toplevel>>=
let order opname nop sop =
  let opname = V.String opname in
  let f x y g =
    match x, y with
    | V.Number x, V.Number y -> fun k -> k (V.bool.V.embed (nop x y))
    | _ -> try let x = V.string.V.project x in
               let y = V.string.V.project y in
               fun k -> k (V.bool.V.embed (sop x y))
           with V.Projection (_, _) -> fb1 "order" g [x; y; opname]
  in f
<<interp toplevel>>=
let concat x y g k =
  try let x = V.string.V.project x in
      let y = V.string.V.project y in
      k (V.string.V.embed (x ^ y))
  with V.Projection (_, _) -> fb1 "concat" g [x; y] k
<<interp toplevel>>=
let eq x y = match x, y with
| V.Nil,        V.Nil        -> true
| V.Number x,   V.Number y   -> x = y
| V.String x,   V.String y   -> x = y
| V.Function x, V.Function y -> x == y
| V.Userdata x, V.Userdata y -> x == y
| V.Table x,    V.Table y    -> x == y
| _,            _            -> false
<<interp toplevel>>=
let binop = function
  | A.Plus   -> arith "add" (+.)
  | A.Minus  -> arith "sub" (-.)
  | A.Times  -> arith "mul" ( *. )
  | A.Div    -> arith "div" ( /. )
  | A.Pow    -> fun x y g k -> fb1 "arith" g [x; y; V.String "pow"] k
  | A.Lt     -> order "lt" (<)  (<)
  | A.Le     -> order "le" (<=) (<=)
  | A.Gt     -> order "gt" (>)  (>)
  | A.Ge     -> order "ge" (>=) (>=)
  | A.Eq     -> fun x y g k -> k (V.bool.V.embed (eq x y))
  | A.Ne     -> fun x y g k -> k (V.bool.V.embed (not (eq x y)))
  | A.And    -> assert false (* short circuit *)
  | A.Or     -> assert false (* short circuit *)
  | A.Concat -> concat
  | A.Not    -> assert false (* unary *)

let unop = function
  | A.Minus  -> negate
  | A.Not    -> fun v g k -> k (match v with V.Nil -> V.Number 1.0 | _ -> V.Nil)
  | _        -> assert false (* all other operators are binary *)
<<interp toplevel>>=
let index g t key = match t with
| V.Table t ->
    (match V.Table.find t key with
    | V.Nil -> trim1 (fallback "index" g [V.Table t; key])
    | v -> v)
| _ -> trim1 (fallback "gettable" g [t; key])

let settable g t key v = match t with
| V.Table t -> V.Table.bind t key v
| _ -> ignore (fallback "settable" g [t; key; v])

<<interp toplevel>>=
let getglobal g x =
  match V.Table.find g.V.globals (V.String x) with
  | V.Nil -> trim1 (fallback "getglobal" g [V.String x])
  | v -> v
<<interp toplevel>>=
type var = Global | Local of int
let lookup rho x =
  let rec look = function
    | [] -> Global
    | h :: t when h = x -> Local (List.length t)
    | h :: t -> look t
  in look rho

<<interp toplevel>>=


let rec exp rho = function
  | A.Var x -> (match rho x with
                | Global -> fun g l k -> k (getglobal g x)
                | Local n -> fun g l k -> k (Array.get l n))
  | A.Lit v -> fun g l k -> k v
  | A.Index (tab, key) ->
      let tab = exp rho tab in
      let key = exp rho key in
      fun g l k -> tab g l (fun t -> key g l (fun v -> k (index g t v))) 
@ 
We could perhaps speed this up by walking the contents in advance.
<<interp toplevel>>=
  | A.Table (lists, bindings) ->
      let rec listbind n bs = function
        | [] -> bs
        | h::t -> listbind (n +. 1.0) ((V.Number n, exp rho h) :: bs) t  in
      let rec bind bs = function
        | [] -> bs
        | (n, h) :: t -> bind ((V.String n, exp rho h) :: bs) t  in
      let contents = listbind 1.0 (bind [] bindings) lists in
      let size     = List.length contents in
      fun g l k ->
        let t = V.Table.create size in
        let rec walk = function
          | [] -> k (V.Table t)
          | (n, e) :: rest -> e g l (fun v -> V.Table.bind t n v; walk rest) in
        walk contents
<<interp toplevel>>=
  | A.Binop (e1, op, e2) ->
      let e1 = exp rho e1 in
      let e2 = exp rho e2 in
      ( match op with
      | A.And -> fun g l k -> e1 g l (function V.Nil -> k V.Nil | _ -> e2 g l k)
      | A.Or  -> fun g l k -> e1 g l (function V.Nil -> e2 g l k | v -> k v)
      | _ -> let op = binop op in
             fun g l k -> e1 g l (fun v1 -> e2 g l (fun v2 -> op v1 v2 g k)))
  | A.Unop (op, e) ->
      let e = exp rho e in
      let op = unop op in
      fun g l k -> e g l (fun v -> op v g k)
<<interp toplevel>>=
  | A.Call c ->
      let c = call c rho in
      fun g l -> adjust1 (c g l)
@ 
<<interp toplevel>>=
and explist rho =
  let rec walk = function 
    | [] -> fun g l k -> k []
    | h :: t ->
        let h = exp rho h in
        let t = walk t in
        fun g l k -> h g l (fun v -> t g l (fun vs -> k (v :: vs)))
  in walk 
and call c rho = match c with
| A.Funcall (f, args) ->
    let f    = exp rho f in
    let args = explist rho args in
    fun g l k -> f g l (fun fv -> args g l (fun argv -> cpscall fv argv g k))
| A.Methcall (obj, meth, args) ->
    let self = exp rho obj in
    let args = explist rho args in
    let meth = V.String meth in
    fun g l k -> self g l (fun v -> let m = index g v meth in
                 args g l (fun argv -> cpscall m (v::argv) g k))
@ 
Static environment for a statement includes list of local variables.
Dynamic continuations include return continuation and standard
continuation.
We make a separate function to compute max number of locals.
<<interp toplevel>>=
let notnil = function
  | V.Nil -> false
  | _ -> true

let (_ : (string -> var) -> A.exp -> V.state -> V.value array -> (V.value -> 'answer) -> 'answer) = exp

type answer = unit * string * bool
let (pexp : (string -> var) -> A.exp -> V.state -> V.value array -> (V.value -> answer) -> answer) = exp


let rec stmt rho = function
  | A.WhileDo (cond, body) ->
      let cond = exp (lookup rho) cond in
      let body = block rho body in
      fun theta ret ->
        let rec loop g l =
          cond g l (fun v -> if notnil v then body loop ret g l else theta g l)  in
        loop
  | A.RepeatUntil (body, cond) ->
      let cond = exp (lookup rho) cond in
      let body = block rho body in
      fun theta ret ->
        let rec loop g l =
          body (fun g l -> cond g l (fun v -> 
                if notnil v then loop g l else theta g l)) ret g l
        in loop
  | A.If (c, t, alts, f) ->
      let alts = (c, t) :: alts in
      let f = block rho (match f with None -> [] | Some ss -> ss) in
      let add (cond, body) f =
        let cond = exp (lookup rho) cond in
        let body = block rho body in
        fun theta ret g l -> cond g l (fun v -> if notnil v then body theta ret g l
                                                else f theta ret g l)  in
      List.fold_right add alts f
  | A.Return es ->
      let es = explist (lookup rho) es in
      fun theta ret g l -> es g l ret
  | A.Local (vs, es) ->
      stmt (List.rev_append vs rho) (A.Assign (List.map (fun x -> A.Lvar x) vs, es))
  | A.Assign (vs, [A.Call c]) ->
      assign (lvars (lookup rho) vs) (call c (lookup rho))
  | A.Assign (vs, es) ->
      assign (lvars (lookup rho) vs) (explist (lookup rho) es)
  | A.Callstmt c -> fun theta ret g l -> call c (lookup rho) g l (fun _ -> theta g l)
and block rho = function
  | [] -> fun theta ret -> theta
  | s :: ss -> fun theta ret -> stmt rho s (block rho ss theta ret) ret
and lvar rho : A.lval -> V.state -> V.value array -> V.value -> unit = function
  | A.Lvar x -> (match rho x with
                 | Global  -> fun g l v -> V.Table.bind g.V.globals (V.String x) v
                 | Local n -> fun g l v -> Array.set l n v)
  | A.Lindex (t, key) ->
      let t = exp rho t in
      let key = exp rho key in
      fun g l -> t g l (fun t -> key g l (fun key -> (fun v -> settable g t key v)))
and lvars rho = function
  | [] -> fun g l vs -> ()
  | h :: t ->
      let h = (lvar rho h : V.state -> V.value array -> V.value -> unit) in
      let t = lvars rho t in
      fun g l ->
        let h = h g l in
        let t = t g l in
        fun vs ->
          let hv, tv = match vs with h::t -> h, t | [] -> V.Nil, [] in (h hv; t tv)
and assign left right =
  fun theta ret g l ->
    let left = left g l in
    (right g l left; theta g l)
@ 
Function [[numlocals]] takes a sequence of statements and returns the
maximum number of local variables declared on any path through that sequence.
<<interp toplevel>>=
let rec numlocals = function
  | [] -> 0
  | h :: t -> numlocals t + match h with
    | A.Local (vs, es)        -> List.length vs
    | A.WhileDo     (_, body) -> numlocals body
    | A.RepeatUntil (body, _) -> numlocals body
    | A.If (c, t, alts, f)    ->
        let add k (_, body) = max k (numlocals body) in
        List.fold_left add (match f with None -> 0 | Some b -> numlocals b)
                           ((c, t) :: alts)
    | A.Assign _   -> 0
    | A.Return _   -> 0
    | A.Callstmt _ -> 0
@ 
Chunks are executed by compiling functions.
<<interp toplevel>>=
let with_stack s g f x =
  let _ = g.V.callstack <- s :: g.V.callstack in
  let pop () = g.V.callstack <- List.tl g.V.callstack in
  let answer = try f x with e -> (pop(); raise e) in
  let _ = pop() in
  answer

let value_list = V.list V.value
let lambda name args varargs body =
  let n = List.length args + (if varargs then 1 else 0) + numlocals body in
  let rho = List.rev (if varargs then "arg" :: args else args) in
  let body = block rho body in
  fun state argv ->
    let locals = Array.make n V.Nil in
    let rec walk n formals actuals = match formals with
      | [] -> if varargs then Array.set locals n (value_list.V.embed actuals)
      | f :: fs ->
          let a, a's = match actuals with [] -> V.Nil, [] | h :: t -> h, t in
          (Array.set locals n a; walk (n+1) fs a's)  in
    let _ = walk 0 args argv in
    with_stack ("in function " ^ name) state
      (body (fun g l -> []) (fun results -> results) state) locals 

let (_ : string -> string list -> bool -> A.block -> V.state -> V.value list -> V.value list) = lambda
@ 
<<interp toplevel>>=
let expname = function
  | A.Var v -> v
  | _ -> "?"
let funname = function
  | A.Lvar v -> v
  | A.Lindex (e, A.Lit (V.String s)) -> expname e ^ "." ^ s
  | A.Lindex (e, e') -> expname e ^ "[" ^ expname e' ^ "]"
let chunk = function
  | A.Statement s -> stmt [] s
  | A.Fundef (f, args, varargs, body) ->
      let v = V.Function (lambda (funname f) args varargs body) in
      stmt [] (A.Assign ([f], [A.Lit v]))
  | A.Methdef (obj, meth, args, varargs, body) ->
      let v = V.Function (lambda (expname obj ^ "." ^ meth) args varargs body) in
      stmt [] (A.Assign ([A.Lindex (obj, A.Lit (V.String meth))], [A.Lit v]))

let rec chunklocals = function
  | [] -> 0
  | A.Statement s :: t -> numlocals [s] + chunklocals t
  | _ :: t -> chunklocals t

let wrap f x = let l = f x in (prerr_string "function returned ";
                               prerr_int (List.length l);
                               prerr_endline " values";
                               l)

let compile cs = 
  let locals = Array.make (chunklocals cs) V.Nil in
  let rec chunks = function
    | [] -> fun g -> []
    | h :: t ->
        let h = chunk h in
        let t = chunks t in
        fun g -> h (fun g l -> t g) (fun results -> results) g locals
  in chunks cs
@ 
<<interp toplevel>>=

@ 
<<interp tests>>=  
let nil = A.Lit V.Nil
let three = A.Lit (V.Number 3.0)

let ret = A.Return ([nil; three])

let state = 
  { V.globals = V.Table.create 10; V.fallbacks = Hashtbl.create 10; V.callstack = [] }

let stmts l = compile (List.map (fun s -> A.Statement s) l)

let num n = A.Lit (V.Number (float n))
let rtest = stmts [ret]
let sum = stmts [A.Return ([A.Binop (three, A.Plus, three)])]
let exp = stmts [A.Return ([A.Binop (three, A.Times, A.Binop (num 2, A.Minus, three))])]
let x = A.Var "x"
let gets x e = A.Assign ([A.Lvar x], [e])
let binary op e1 e2 = A.Binop (e1, op, e2)
let lt = binary A.Lt
let times = binary A.Times
let loop = [ gets "x" (num 10)
               ; A.WhileDo (lt x (num 100), [gets "x" (times (num 2) x)])
               ; A.Return [x]]

let test _ =
  [ "return nil and three", rtest state
      ; "sum of three and three", sum state
      ; "expression minus three", exp state
      ; "result of loop", stmts loop state
  ] 
@ 
<<lua.ml>>=
module U = struct type t = unit let to_string () = "<userdata>" end
module V = Value.Make (U)
module A = Ast.Make (V)
module T = MkInterp (A)
let t = T.test ()
<<lua.mli>>=
module T : INTERP
val t : (string * T.Value.value list) list
@

<<hell.ml>>=
module type VALUE' = sig
  type userdata
end

module type AST' = sig
  module Value : VALUE'
end

module type INTERP' = sig
  module Value : VALUE'
  module Ast : AST' with module Value = Value
end

module MkInterp' (A : AST') : INTERP' with module Ast = A = struct
  module Value = A.Value
  module Ast = A
end

@ 
\section{Caveats}

Builtin [[type]] doesn't return a tag.
