% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
<<builtins.mli>>=
module String : Lua.MIXIN
module Math   : Lua.MIXIN


module Add (MakeParser : Parser.MAKER) (I : Lua.INTERP) : sig
  val do_lexbuf : sourcename:string -> I.state -> Lexing.lexbuf -> I.value list
  val dostring  : I.state -> string -> I.value list
  val dofile    : I.state -> string -> I.value list
  val state : unit -> I.state
  module Value  : Value.S 
  module Parser : Parser.S with type chunk = I.Ast.chunk
  module Interp : Lua.INTERP
end with module Value = I.Value with module Interp = I
<<builtins.ml>>=
module Add (MakeParser : Parser.MAKER) (I : Lua.INTERP) = struct
  module Parser = MakeParser (I.Ast)
  module Value = I.Value
  module Interp = I
  module P = Parser
  module V = I.Value
  <<builtins toplevel>>
  let ( **-> ) = V.( **-> )

  let next t key =
    let k, v =
      try match key with
      | V.Nil -> Thashtbl.first t
      | _   -> Thashtbl.next t key
      with Not_found -> V.Nil, V.Nil
    in [k; v]

  let builtins =

    [ "dofile", (V.func (V.string **-> V.values)).V.embed dofile
    ; "dostring", (V.func (V.string **-> V.values)).V.embed dostring
        (* should catch Sys_error and turn into an error fallback... *)
    ; "next",   (V.pfunc (V.table **-> V.value **-> V.values)).V.embed next
    ; "nextvar", (V.func (V.value **-> V.values)).V.embed
                 (fun g x -> next g.V.globals x)
    ; "tostring", (V.pfunc (V.value **-> V.result V.string)).V.embed V.to_string
    ; "print",    V.caml_func (fun g args ->
                               List.iter (fun x -> print_endline (V.to_string x)) args;
                               flush stdout;
                               [])
    ; "tonumber", (V.pfunc (V.float **-> V.result V.float)).V.embed (fun x -> x)
    ; "type",     (V.pfunc (V.value **-> V.result V.string)).V.embed
                  (function
                    | V.Nil -> "nil"
                    | V.Number _ -> "number"
                    | V.String _ -> "string"
                    | V.Table _  -> "table"
                    | V.Function (_,_) -> "function"
                    | V.Userdata _ -> "userdata")
    ; "assert",  (V.func (V.value **-> V.runit)).V.embed
                 (fun g -> function V.Nil -> I.error g "assertion failed!"
                                  | _ -> ())
    ; "error",   (V.func (V.string **-> V.runit)).V.embed I.error
    ; "setglobal", (V.func (V.value **-> V.value **-> V.runit)).V.embed
                   (fun g k v -> V.Table.bind g.V.globals k v)
    ; "getglobal", (V.func (V.value **-> V.result V.value)).V.embed I.getglobal
    ; "setfallback", (V.func (V.string **-> V.value **-> V.result V.value)).V.embed
                     I.setfallback
    ] 

  let state () =
    let g = I.state () in
    List.iter (fun (k, v) -> V.Table.bind g.V.globals (V.String k) v) builtins;
    g

end
<<builtins toplevel>>=
let lex map buf = Scan.token buf map
let do_lexbuf filename g buf =
  let map = Srcmap.mk () in
  let _ = Srcmap.sync map 0 (filename, 1, 1) in
  let chunks =
    try P.chunks (lex map) buf
    with Parsing.Parse_error ->
      let file, line, _ = Srcmap.last map in begin
        prerr_string file;
        prerr_string ", line ";
        prerr_int line;
        prerr_endline ": syntax error";
        []
      end in
  let pgm = I.compile (map, true) chunks in
  try
    match pgm g with
    | [] -> [I.Value.String "executed without errors"]
    | answers -> answers
  with
  | I.Error s -> (prerr_endline "Lua interpreter halted with error"; [])
  | I.Value.Projection (v, w) -> (prerr_endline ("error projecting to " ^ w); [])
let dostring g s = 
  I.with_stack (V.info ("dostring('" ^ s ^ "')") 0) g
    (do_lexbuf "<string>" g) (Lexing.from_string s)

let dofile g infile =
  try
    let f = match infile with "-" -> stdin | _ -> open_in infile in
    let close () = if infile <> "-" then close_in f else () in
    try 
      let answer = I.with_stack (V.info ("dofile('" ^ infile ^ "')") 0) g
                     (do_lexbuf infile g) (Lexing.from_channel f)
      in  (close(); answer)
    with e -> (close (); raise e)
  with Sys_error msg ->
    I.fallback "error" g [V.String ("dofile: System error " ^ msg)]
@ 
\subsection{Strings}
<<string builtins>>=
let unimp s =
  V.caml_func (fun g _ ->
    I.fallback "error" g [V.String ("string library does not implement `" ^ s ^ "'")])

let getopt x y = match x with None -> y | Some x -> x

let string_builtins =
  [ "strfind", unimp "strfind"
  ; "strlen", (V.pfunc (V.string **-> V.result V.int)).V.embed String.length
  ; "strsub",
    (V.pfunc (V.string **-> V.int **-> V.option V.int **-> V.result V.string)).V.embed
    (fun s start last ->
      let start = start - 1 in (* caml strings are 0-indexed *)
      let last = match last with None -> String.length s
                               | Some n -> min n (String.length s) in
      let len = last - start in
      String.sub s start len)
  ; "strlower", (V.pfunc (V.string **-> V.result V.string)).V.embed String.lowercase
  ; "strupper", (V.pfunc (V.string **-> V.result V.string)).V.embed String.uppercase
  ; "strrep",   (V.pfunc (V.string **-> V.int **-> V.result V.string)).V.embed
                (fun s n ->
                  if n < 0 then
                    raise (Invalid_argument ("number of replicas " ^ string_of_int n ^
                                             " is negative"))
                  else
                    let rec list l = function 0 -> l | n -> list (s::l) (n-1) in
                    String.concat "" (list [] n))
  ; "ascii",   (V.pfunc (V.string **-> V.option V.int **-> V.result V.int)).V.embed
               (fun s i -> Char.code (String.get s (getopt i 1 - 1)))
  ; "format",  unimp "format"
  ; "gsub",    unimp "gsub"
  ] 
@ 
\subsection{Math}
<<math builtins>>=
let unimp s =
  V.caml_func (fun g _ ->
    I.fallback "error" g [V.String ("math library does not implement `" ^ s ^ "'")])

let rfloat = V.result V.float
let float = V.float
let pf x = (V.pfunc x).V.embed
let binary = pf
let math_builtins =
  [ "abs",   pf (float **-> rfloat)            abs_float
  ; "acos",  pf (float **-> rfloat)            acos
  ; "asin",  pf (float **-> rfloat)            asin
  ; "atan",  pf (float **-> rfloat)            atan
  ; "atan2", pf (float **-> float **-> rfloat) atan2
  ; "ceil",  pf (float **-> rfloat)            ceil
  ; "cos",   pf (float **-> rfloat)            cos
  ; "floor", pf (float **-> rfloat)            floor
  ; "log",   pf (float **-> rfloat)            log
  ; "log10", pf (float **-> rfloat)            log10
  ; "max",   pf (float **-> float **-> rfloat) max
  ; "min",   pf (float **-> float **-> rfloat) min
  ; "mod",   pf (float **-> float **-> rfloat) mod_float
  ; "sin",   pf (float **-> rfloat)            sin
  ; "sqrt",  pf (float **-> rfloat)            sqrt
  ; "tan",   pf (float **-> rfloat)            tan
  ; "random", V.caml_func (fun _ _ -> [V.Number (Random.float 1.0)])
  ; "randomseed", pf (V.int **-> V.runit)        Random.init
  ] 
@ 
<<builtins.ml>>=
module String (L : Lua.TIER) = struct
  module U = L.U
  module M (FB : Lua.TOWER with type 'a t = 'a U.t and type 'a state = 'a U.state) = struct
    module I = struct let fallback = FB.fallback end
    module V = FB.V
    let ( **-> ) = V.( **-> )
    <<string builtins>>
    module L' = L.M (FB)
    let init g =
      L'.init g;
      List.iter (fun (k, v) -> V.Table.bind g.V.globals (V.String k) v) string_builtins
  end
end


module Math (L : Lua.TIER) = struct
  module U = L.U
  module M (FB : Lua.TOWER with type 'a t = 'a U.t and type 'a state = 'a U.state) = struct
    module I = struct let fallback = FB.fallback end
    module V = FB.V
    let ( **-> ) = V.( **-> )
    <<math builtins>>
    module L' = L.M (FB)
    let init g =
      L'.init g;
      List.iter (fun (k, v) -> V.Table.bind g.V.globals (V.String k) v) math_builtins
  end
end


