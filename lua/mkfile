# 
# Lua interpreter - library and standalone binary
#
# ------------------------------------------------------------------ 
# call 'mk depend' after sources have been checked out of CVS!
# ------------------------------------------------------------------ 
#
# To add a new module to the library:
# (1) add it to LIBML		if it is a .ml  file
# (2) add it to LIBMLI		if it is a .mli file	
#
# If your module must be scanned for dependencies but is not covered
# by (1) or (2), add it to SCAN
#
# If you have trouble with depdencies check LIBML, LIBMLI, and SCAN.
# Rebuild dependencies with "mk depend".

# This interpreter is being used for performance experiments.  These
# experiments involve plugging in multiple different interperter
# modules.  For that reason, we configure the mkfile as follows:
#    * Source for the interpreter is in ${INTERP}luainterp.nw
#    * Derived ML source goes into $INTERP/luainterp.ml*.
#    * Libraries are named lua-$INTERP.cma, etc.
#    * Binaries are named oclua-$INTERP, oclbench-$INTERP, etc.
#    * `mk update' deposits the default `std' versions.
#      If others are tried, mk `doesn't know how to mk...'
#    * Dependencies now live in DEPEND.$INTERP

TOP    =        ..
LIBDIR =        ../lib
BINDIR =        ../bin

INTERP       =  std
# interp must appear before noweb is included

<../config/ocaml.mk
<../config/noweb.mk

PROFILE      =  -p
OCAMLC_FLAGS = 	-I $INTERP -I $LIBDIR -g
OCAMLO_FLAGS =	-I $INTERP -I $LIBDIR $PROFILE

NWSRC=`echo *.nw`
NWHTML=${NWSRC:%.nw=%.html}

# also reasonable: old

# ------------------------------------------------------------------ 
# high level (virtual) targets
# ------------------------------------------------------------------ 

all:V: 		lua-$INTERP.cma  oclua-$INTERP     oclbench-$INTERP
all.opt:V:      lua-$INTERP.cmxa oclua-$INTERP.opt oclbench-$INTERP$PROFILE.opt

update:V:	update-msg $LIBDIR/lua.cma  $BINDIR/oclbench-$INTERP
update.opt:V:   update-msg $LIBDIR/lua.cmxa update-bench.opt
update-bench.opt:V: $BINDIR/oclbench-$INTERP$PROFILE.opt

update-msg:VQ:
	if [ $INTERP = std ]; then true
	else echo "error: to mk update, must have INTERP=std" 1>&2; exit 1
	fi

depend:V:	DEPEND.$INTERP

doc:V:		lua.ps

html:V:		$NWHTML
dvi:VQ:
                echo "nothing to be done for $target"     
clean:V:
		rm -f *.cmi *.cmo *.ml *.mli *.mly *.mll *.cmx *.o
		rm -f *.aux *.log *.dvi *.toc *.tex *.inc
		rm -f $NWHTML
		rm -f luaparsex.output tspecl lspecl *.icn
		rm -f *~

clobber:V:	clean
		rm -f oclua-* oclua-*.opt *.cma *.cmxa *.a 
		rm -f lua.ps


# ------------------------------------------------------------------ 
# api documentation
# ------------------------------------------------------------------ 

lua.tex: lua.nw
		noweave -x lua.nw > lua.tex

# ------------------------------------------------------------------ 
# lua library
# ------------------------------------------------------------------ 
# The order of files determines the link order. No file must use any
# of its successors

LIBML = 	log.ml		\
		luahash.ml	\
		luafloat.ml	\
		luavalue.ml	\
		luaast.ml	\
		luaparser.ml	\
		luascanner.ml	\
		luabaselib.ml	\
		lualib.ml		\
		$INTERP/luainterp.ml	\
		luarun.ml	\
		lua.ml          \
		luastrlib.ml	\
		luamathlib.ml	\
		luaiolib.ml	\

LIBCMO = ${LIBML:%.ml=%.cmo}
LIBCMX = ${LIBML:%.ml=%.cmx}
LIBOBJ = ${LIBML:%.ml=%.o}

# order does not matter here - so keep it alphabetical
# we wan't easily deduce LIBMLI from LIBML because there might be
# interfaces with no implementation and vice versa.

LIBMLI = 	log.mli		\
		lua.mli		\
		luaast.mli	\
		luabaselib.mli	\
		$INTERP/luainterp.mli	\
		luaiolib.mli	\
		lualib.mli	\
		luamathlib.mli	\
		luaparser.mli	\
		luarun.mli	\
		luastrlib.mli	\
		luavalue.mli	\
		luahash.mli	\

LIBCMI = ${LIBMLI:%.mli=%.cmi}


lua-$INTERP.cma:	$LIBCMO $LIBCMI
		$OCAMLC $OCAMLC_FLAGS -a -o $target $LIBCMO

# this target also creates *.o files and a lua.a library
lua-$INTERP.cmxa:	$LIBCMX	$LIBCMI 
		$OCAMLO $OCAMLO_FLAGS -a -o $target $LIBCMX


# copy library and interfaces to $LIBDIR. Note that lua-std.a is
# implicitly built when lua-std.cmxa is built.

$LIBDIR/lua.cma:Q: lua-std.cma $LIBMLI $LIBCMI dirs
		cmp -s lua-std.cma $target || cp -v lua-std.cma $target
		for f in $LIBMLI $LIBCMI
		do
		    cmp -s $f $LIBDIR/$f || cp -v $f $LIBDIR
		done

$LIBDIR/lua.cmxa:Q: lua-std.cmxa $LIBMLI $LIBCMI dirs
		cmp -s lua-std.cmxa $target || cp -v lua-std.cma $target
		cmp -s lua-std.a    $LIBDIR/lua.a || cp -v lua-std.a $LIBDIR/lua.a
		for f in $LIBMLI $LIBCMI
		do
		    cmp -s $f $LIBDIR/$f || cp -v $f $LIBDIR
		done

$BINDIR/oclbench%:Q: oclbench%
	cp -v $prereq $target

# ------------------------------------------------------------------ 
# lua standalone interpreter (for tests)
# ------------------------------------------------------------------ 

ML =	main.ml 
CMO =	${ML:%.ml=%.cmo}
CMX =	${ML:%.ml=%.cmx}


oclua-$INTERP:	lua-$INTERP.cma $CMO
	$OCAMLC $OCAMLC_FLAGS -o $target unix.cma cllib.cma lua-$INTERP.cma $CMO

oclua-$INTERP.opt: 	lua-$INTERP.cmxa $CMX
	$OCAMLO $OCAMLO_FLAGS -o $target unix.cmxa cllib.cmxa $prereq 

oclbench-$INTERP:	lua-$INTERP.cma bench.cmo
	$OCAMLC $OCAMLC_FLAGS -o $target unix.cma cllib.cma $prereq 

oclbench-$INTERP$PROFILE.opt: 	lua-$INTERP.cmxa bench.cmx
	$OCAMLO $OCAMLO_FLAGS -o $target unix.cmxa cllib.cmxa $prereq 


# ------------------------------------------------------------------ 
# Source files
# The following files are scanned for dependencies. We have to list them
# here to make sure they get extracted from Noweb files and generated if
# neccessary.

SCAN = 		$LIBML $LIBMLI main.ml bench.ml

src:V: $SCAN

# ------------------------------------------------------------------ 
# tests
# ------------------------------------------------------------------ 

# 09 needs I/O library -- dofile needs to return nil on error
TEST=03 04 05 06 07 08 10 12 02

test.opt:V: 	oclua-$INTERP.opt
		for i in $TEST; do ./$prereq test/$i.lua; done	

test:V: 	oclua-$INTERP
		for i in $TEST; do ./$prereq test/$i.lua; done	

# ------------------------------------------------------------------ 
# main interpreter. We special rules to extract sources
# from noweb files. 

^(std|ast)/luainterp.ml'$':R: stdluainterp.nw xinterp-'\1'.nw
	$NOTANGLE -L"$LINE" -filter "$NOCOND" -R`basename $target` $prereq > $target

^(old)/luainterp.ml'$':R: '\1'luainterp.nw 
	$NOTANGLE -L"$LINE" -filter "$NOCOND" -R`basename $target` $prereq > $target

# see if the following two rules can be safely merged (I hope so)

^(std|ast)/luainterp.mli'$':R: stdluainterp.nw
	$NOTANGLE -L"$LINE" -filter "$NOCOND" -R`basename $target` $prereq | cpif $target

^(old)/luainterp.mli'$':R: '\1'luainterp.nw
	$NOTANGLE -L"$LINE" -filter "$NOCOND" -R`basename $target` $prereq | cpif $target

# ------------------------------------------------------------------ 
# lua scanner and parser. We need some extra rules to extract sources
# from noweb files. 

luaparsex.mly: luasyntax.nw
	[ -r $target ] && chmod +w $target
	notangle -Rluaparser.mly $prereq | 
        sed "s/','/COMMA/g;	\
            s/'{'/LBRA/g;	\
            s/'}'/RBRA/g;	\
            s/'<'/LT/g;		\
            s/'>'/GT/g;		\
            s/':'/COLON/g;	\
            s/';'/SEMI/g;	\
            s/'\\^'/HAT/g;	\
            s/'\\*'/STAR/g;	\
            s@'/'@SLASH@g;	\
            s/'('/LPAR/g;	\
            s/')'/RPAR/g;	\
            s/'='/GETS/g;	\
            s/'+'/PLUS/g;	\
            s/'-'/MINUS/g;	\
            s/'\\.'/DOT/g;	\
            s/'\\['/LSQ/g;	\
            s/'\\]'/RSQ/g" > $target
	chmod -w $target

luascanner.mll: luasyntax.nw
	notangle -R$target $prereq > $target

luafloat.mll: luavalue.nw
	notangle -R$target $prereq > $target

luaparser.ml: luaparsex.ml
	cp $prereq $target

luaparser.mli: luaparsex.mli luasyntax.nw
	(sed '/^val /,$d' luaparsex.mli; notangle -L"$LINE" -R$target luasyntax.nw) > $target


# ------------------------------------------------------------------ 

dirs:VQ:
	for i in $LIBDIR; do
	    if [ ! -d $i ]; then
		echo "missing directory $i"
		echo "invoke mk from the toplevel the first time"
		echo "to create all directories"
		false
	    fi
	done    

DEPEND.$INTERP: $SCAN
	$OCAMLDEP $prereq > $target


<DEPEND.$INTERP

