% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

<<luabaselib.mli>>=
module Add (MakeParser : Luaparser.MAKER) (I : Luainterp.S) : sig
  include Luainterp.S
  module Parser : Luaparser.S with type chunk = Ast.chunk
  val do_lexbuf : sourcename:string -> state -> Lexing.lexbuf -> value list
  val dostring  : state -> string -> value list
  val dofile    : state -> string -> value list
  val mk        : unit -> state  (* builds state and runs startup code *)
end with module Value = I.Value
<<luabaselib.ml>>=
module Add (MakeParser : Luaparser.MAKER) (I : Luainterp.S) = struct
  module Parser = MakeParser (I.Ast)
  module P = Parser
  module V = I.Value
  <<toplevel>>
  let ( **-> ) = V.( **-> )

  let next t key =
    let k, v =
      try match key with
      | V.Nil -> Luahash.first t
      | _   -> Luahash.next t key
      with Not_found -> V.Nil, V.Nil
    in [k; v]

  let nextvar g x = next g.V.globals x
  let luabaselib =

    [ "dofile",   V.impure (V.string **-> V.values)             dofile
    ; "dostring", V.impure (V.string **-> V.values)             dostring
        (* should catch Sys_error and turn into an error fallback... *)
    ; "size",     V.pure   (V.table **-> V.result V.int)        Luahash.population
    ; "next",     V.pure   (V.table **-> V.value **-> V.values) next
    ; "nextvar",  V.impure (V.value **-> V.values)              nextvar
    ; "tostring", V.pure   (V.value **-> V.result V.string)     V.to_string
    ; "print",    V.caml_func (fun g args ->
                               List.iter (fun x -> print_endline (V.to_string x)) args;
                               flush stdout;
                               [])
    ; "tonumber", V.pure (V.float **-> V.result V.float)  (fun x -> x)
    ; "type",     V.pure (V.value **-> V.result V.string)
                  (function
                    | V.Nil            -> "nil"
                    | V.Number   _     -> "number"
                    | V.String   _     -> "string"
                    | V.Table    _     -> "table"
                    | V.Function (_,_) -> "function"
                    | V.Userdata _     -> "userdata")
    ; "assert",  V.impure (V.value **-> V.runit)
                 (fun g -> function V.Nil -> I.error g "assertion failed!"
                                  | _ -> ())
    ; "error",       V.impure (V.string **-> V.runit) I.error
    ; "setglobal",   V.impure (V.value **-> V.value **-> V.runit)
                       (fun g k v -> V.Table.bind g.V.globals k v)
    ; "getglobal",   V.impure (V.value **-> V.result V.value) I.getglobal
    ; "setfallback", V.impure (V.string **-> V.value **-> V.result V.value)
                     I.setfallback
    ] 

  include I
  let mk () =
    let g, init = I.pre_mk () in
    I.register_globals luabaselib g;
    init (fun s -> ignore (dostring g s));
    g
end
<<toplevel>>=
let lex map buf = Luascanner.token buf map
let do_lexbuf ~sourcename:filename g buf =
  let map = Srcmap.mk () in
  let _ = Srcmap.sync map 0 (filename, 1, 1) in
  let chunks =
    try P.chunks (lex map) buf
    with Parsing.Parse_error ->
      let file, line, _ = Srcmap.last map in begin
        prerr_string file;
        prerr_string ", line ";
        prerr_int line;
        prerr_endline ": syntax error";
        []
      end in
  let pgm = I.compile ~srcdbg:(map, false) chunks in
  try
    match pgm g with
    | [] -> [I.Value.String "executed without errors"]
    | answers -> answers
  with
  | I.Error s -> (prerr_endline "Lua interpreter halted with error"; [])
  | I.Value.Projection (v, w) -> (prerr_endline ("error projecting to " ^ w); [])
let dostring g s = 
  I.with_stack (V.info ("dostring('" ^ s ^ "')") 0) g
    (do_lexbuf ~sourcename:"<string>" g) (Lexing.from_string s)

let dofile g infile =
  try
    let f = match infile with "-" -> stdin | _ -> open_in infile in
    let close () = if infile <> "-" then close_in f else () in
    try 
      let answer = I.with_stack (V.info ("dofile('" ^ infile ^ "')") 0) g
                     (do_lexbuf ~sourcename:infile g) (Lexing.from_channel f)
      in  (close(); answer)
    with e -> (close (); raise e)
  with Sys_error msg ->
    I.fallback "error" g [V.String ("dofile: System error " ^ msg)]
@ 


