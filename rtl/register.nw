% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Register}
% ------------------------------------------------------------------ 

A [[Register.t]] describes a target-specific register-like location.
Such a location includes hardware-registers or temporaries, but not
spill locations.  The distinguishing feature of a register is a fixed
address within its space: the address is an integer rather than a
general expression.

A [[t]] value includes the target-specific [[space]], its address
within that space, and the [[width]] of the addressed cell.  Other
details, like the width of of addressing expression or the aggregation
scheme of multiple cells is associated with the [[space]], but not
included in a [[t]] value.  They can, however, obtained from the
[[Target.t]] description of the target the register belongs to.

We also define a type [[Register.x]], which is a sum type that may be
either a register or a slice of a register.
This type is useful for performing accurate liveness analysis at the
slice level.

We cannot refer to types in module \module{rtl} because this would
create a cyclic dependency,
<<exported types>>=
type width = int
type reg = char * int * width (* Rtl.space, index, Rtl.width *)
type t = reg
type x = Reg   of t
       | Slice of width * int * t
@
We provide an extended set type.
<<exported types>>=
module type SETX = sig
  include Set.S
  val of_list   : elt list -> t
  val to_string : t -> string    (* elements sep. by commas (no braces) *)
end
@
<<register.mli>>=
<<exported types>>
module SetX: SETX  with type elt = x
module MapX: Map.S with type key = x
module Set:  SETX  with type elt = t
module Map:  Map.S with type key = t
@
Sometimes it is useful to consider only registers; we can promote a type [[x]] to a
type [[t]] by returning the register or the register from which we are taking a slice,
as appropriate.
We can also convert between different types of sets.
<<register.mli>>=
val promote_x     : x -> t
val rset_to_rxset : Set.t  -> SetX.t
val promote_rxset : SetX.t -> Set.t
@
We sometimes need to map a list of registers into a compact set of integers.
[[reg_int_map]] maps a list of $n$ integers into the numbers $[0..n-1]$, in
alphanumeric order (by space, then index).
Additionally, we return the number of registers in the first element of the pair.
<<register.mli>>=
val reg_int_map : t list -> int * int Map.t
@
Registers are exported to Lua as a new \emph{userdata} type.
<<register.mli>>=
module RT (C : Lua.Lib.CORE) : sig
	val map : t C.V.map
end
@
% ------------------------------------------------------------------ 
\section{Implementation of registers}
% ------------------------------------------------------------------ 
<<register.ml>>=
<<exported types>>

module Compare = struct
    type t = reg 
    let compare = compare
end
module CompareX = struct
    type t = x
    let compare = compare
end
<<register.ml>>=
module SetX = struct
  module S = Set.Make(CompareX)
  include S
  let of_list l = List.fold_right add l empty
  let to_string s =
    let elt = function | Reg   (s, i, w) -> Printf.sprintf "%c%d" s i
                       | Slice (w, i, (s, i' ,_)) ->
											    Printf.sprintf "Slice(%d,%d,%c%d)" w i s i' in
    String.concat ", " (List.map elt (elements s))
end
module Set = struct
  module S = Set.Make(Compare)
  include S
  let of_list l = List.fold_right add l empty
  let to_string s =
    let elt (s, i, w) = Printf.sprintf "%c%d" s i in
    String.concat ", " (List.map elt (elements s))
end
<<register.ml>>=
module MapX = Map.Make(CompareX)
module Map  = Map.Make(Compare)
@
<<register.ml>>=
let promote_x = function | Reg r | Slice (_, _, r) -> r
let rset_to_rxset set = Set.fold (fun r rst -> SetX.add (Reg r) rst) set SetX.empty
let promote_rxset set =
  SetX.fold (fun r rst -> match r with | Reg r | Slice (_,_,r) -> Set.add r rst)
            set Set.empty
@
Creating the integer map is rather simple.
<<register.ml>>=
let reg_int_map regs =
  let order = List.sort (fun (s1,i1,_) (s2,i2,_) -> match compare s1 s2 with
                                                    | 0 -> compare i1 i2
                                                    | n -> n)
                        regs in
  (List.fold_left (fun (i,map) r -> (i+1, Map.add r i map)) (0, Map.empty) order)
@
The [[RT]] module creates an embedding/projection pair for registers.
<<register.ml>>=
module RT (C : Lua.Lib.CORE) = struct
    module V = C.V

    let embedRegister (s,i,w) =
      (V.record V.value).V.embed
      [ "space", V.string.V.embed (Char.escaped s)
      ; "index", V.int.V.embed i
      ; "width", V.int.V.embed w
      ] 

    let projectRegister reg = match reg with
      | V.Table reg ->
          let field f = V.Table.find reg (V.String f) in
          let s = String.get (V.string.V.project (field "space")) 0 in
          let i = V.int.V.project (field "index") in
          let w = V.int.V.project (field "width") in
          (s,i,w)
      | _ -> raise (V.Projection (reg, "register"))

    let map = {
      V.embed = embedRegister ; V.project = projectRegister;
      V.is = (fun r -> try ignore (projectRegister r); true
                       with V.Projection (_, _) -> false); }
end
@ 
