% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

% ------------------------------------------------------------------ 
\section{Register}
% ------------------------------------------------------------------ 

A [[Register.t]] describes a target-specific register-like location.
Such a location includes hardware-registers or temporaries, but not
spill locations.  The distinguishing feature of a register is a fixed
address within its space: the address is an integer rather than a
general expression.

A [[t]] value includes the target-specific [[space]], its address
within that space, and the [[width]] of the addressed cell.  Other
details, like the width of of addressing expression or the aggregation
scheme of multiple cells is associated with the [[space]], but not
included in a [[t]] value.  They can, however, obtained from the
[[Target.t]] description of the target the register belongs to.

We cannot refer to types in module \module{rtl} because this would
create a cyclic dependency,
<<exported types>>=
type width = int
type t = char * int * width       (* Rtl.space, index, Rtl.width *)
@
We provide an extended set type.
<<exported types>>=
module type SETX = sig
  include Set.S
  val of_list   : elt list -> t
  val to_string : t -> string    (* elements sep. by commas (no braces) *)
end
@
<<register.mli>>=
<<exported types>>
module Set: SETX  with type elt = t
module Map: Map.S with type key = t
@
Registers are exported to Lua as a new \emph{userdata} type.
<<register.mli>>=
module RT (C : Lua.Lib.CORE) : sig
	val map : t C.V.map
end
@
% ------------------------------------------------------------------ 
\section{Implementation of registers}
% ------------------------------------------------------------------ 
<<register.ml>>=
<<exported types>>

module Compare = struct
    <<exported types>>
    let compare = compare
end
<<register.ml>>=
module Set = struct
  module S = Set.Make(Compare)
  include S
  let of_list l = List.fold_right add l empty
  let to_string s =
    let elt (s, i, w) = Printf.sprintf "%c%d" s i in
    String.concat ", " (List.map elt (elements s))
end
<<register.ml>>=
module Map = Map.Make(Compare)
@
The [[RT]] module creates an embedding/projection pair for registers.
<<register.ml>>=
module RT (C : Lua.Lib.CORE) = struct
    module V = C.V

    let embedRegister (s,i,w) =
      (V.record V.value).V.embed
      [ "space", V.string.V.embed (Char.escaped s)
      ; "index", V.int.V.embed i
      ; "width", V.int.V.embed w
      ] 

    let projectRegister reg = match reg with
      | V.Table reg ->
          let field f = V.Table.find reg (V.String f) in
          let s = String.get (V.string.V.project (field "space")) 0 in
          let i = V.int.V.project (field "index") in
          let w = V.int.V.project (field "width") in
          (s,i,w)
      | _ -> raise (V.Projection (reg, "register"))

    let map = { V.embed = embedRegister ; V.project = projectRegister}
end
@ 
