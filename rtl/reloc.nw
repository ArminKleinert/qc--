% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ------------------------------------------------------------------ 
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
\section{Relocatable Addresses}
% ------------------------------------------------------------------ 

\begin{quote}\it
    There is some confusion about relocatable addresses. We had the
    [[Reladdr]] abstraction but NR did not like it for the back end and
    came up with a new one in [[Sledlib]]. This module is an attempt to
    consolidate the matter but I am not sure it is successful. --CL (Thu
    Apr 11 14:25:33 EDT 2002) 
\end{quote}


A relocatable address is either a constant or a sum of a symbol and a
constant. A symbol is an assembler-specific representation of a
link-time constant.

<<reloc.mli>>=
<<module type RELOCATABLE>>
<<module Simple>>
@

We are not yet sure about our representation for relocatable addresses.
We define a module type that covers the intended use and take clues from
the machine generated code in directory [[gen/]].

A [['a relocatable]] value represents a bit vector of type [[['a]] whose
value might not be known until link time. A relocatable is constructed
as a sum of a symbol and many constants. Since the representation is 
polymorphic over the type of the constant, [[add_const]] receives as
first argument a function that adds constants.

It might be necessary to turn a relocatable address back into an
expression, which might conceivably undergo a PIC transformation.
For that reason, to make a relocatable address from a symbol, it is
necessary to supply a suitable function.
<<module type RELOCATABLE>>=
module type RELOCATABLE = sig
    type symbol                 
    type 'a relocatable         

    (* constructors *)
    val of_const:   'a           -> 'a relocatable
    val of_sum:     (symbol -> Rtl.width -> Rtl.exp) -> symbol -> 'a -> 'a relocatable
    val add_const:  ('a -> 'a -> 'a) -> 'a relocatable -> 'a -> 'a relocatable

    (* observer *)
    val normalize:  'a relocatable -> symbol option * 'a
    val expnormalize:  
       'a relocatable -> (symbol * (symbol -> Rtl.width -> Rtl.exp)) option * 'a
end
<<junk>>=
module type S = sig
    type symbol
    type 'a relocatable = 
      | Const of 'a
      | Sym   of 
      | Sum   of 'a relocatable * 'a relocatable

    val of_const:   'a           -> 'a relocatable
    val of_sym:     (symbol -> Rtl.width -> Rtl.exp) -> symbol -> 'a relocatable
    val add:  ('a -> 'a -> 'a) -> 'a relocatable -> 'a relocatable -> 'a relocatable
    val sub:  ('a -> 'a -> 'a) -> 'a relocatable -> 'a relocatable -> 'a relocatable

    val normalize:  'a relocatable -> symbol option * 'a
    val expnormalize:  
       'a relocatable -> (symbol * (symbol -> Rtl.width -> Rtl.exp)) option * 'a
end
@

The [[MkSimple]] functor allows to build a representation easily and
[[Simple]] is a particular instance of that.

<<module Simple>>=
module MkSimple(S: sig type t end): RELOCATABLE with type symbol = S.t
module Simple:                      RELOCATABLE with type symbol = Symbol.t
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<reloc.ml>>=
<<module type RELOCATABLE>>

module MkSimple(S: sig type t end) = struct
    type symbol          = S.t
    type 'a relocatable  = (symbol * (symbol -> Rtl.width -> Rtl.exp)) option * 'a
    let of_const c       = (None, c)
    let of_sum mk s c    = (Some (s, mk), c)
    let add_const (+)    = fun (s, c) c' -> (s, c + c')
    let expnormalize r   = r
    let normalize (s, c) = match s with
    | None -> None, c
    | Some (s, _) -> Some s, c
end

module Simple = MkSimple(Symbol)
@


