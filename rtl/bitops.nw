% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% ----------------------------------------------------------------
\section{Operations on bit vectors}
% ----------------------------------------------------------------

This module encapsulates operations on bit vectors.  Its primary use
will be to support constant evaluation, but it is also used to evaluate
`early' expressions during {\rtl} creation. Another mayor client is the
encoding and decoding of instructions in {\rtl} representation.

I would argue that these operations belong into the [[Bits]] module
because the representation of [[Bits.bits]] value are abstract. An
implementation here does not have access to the representation and thus
must use observes.

%
<<bitops.mli ((evaluating))>>=
(*module Bitops*)
type t     = Bits.t
type width = Bits.width
@ 
Standard RTL operators
<<bitops.mli ((evaluating))>>=
(* comparisons *)
val eq : t -> t -> bool
val ne : t -> t -> bool
val lt : t -> t -> bool
val le : t -> t -> bool
val gt : t -> t -> bool
val ge : t -> t -> bool

(* extensions *)
val sx : t -> width -> t  (* sign extend to the given width *)
val zx : t -> width -> t

(* shifts *)
val shl  : t -> t -> t
val shra : t -> t -> t
val shrl : t -> t -> t
@

The next two operators are not defined in {\PAL}. Would someone please
explain their semantics.

<<bitops.mli ((evaluating))>>=
(* extractions a painless specialty *)
val bitExtract : lsb:int -> t -> width -> t
val bitInsert  : lsb:int -> wide:t -> narrow:t -> t

(* bitwise operations *)
val com : t -> t

(* floating-point goo *)
val float_lt : t
val float_gt : t
val float_eq : t
val unordered : t

val round_nearest : t
val round_zero : t
val round_down : t
val round_up : t

@ 
Testing for widths.

<<bitops.mli ((evaluating))>>=
val fits_signed : t -> width -> bool
  (* fits_signed v w == v can be narrowed to width w, then
         sign-extended to its original width, without changing its value *)

val fits_unsigned : t -> width -> bool
  (* fits_signed v w == v can be narrowed to width w, then
         zero-extended to its original width, without changing its value *)
@

% ----------------------------------------------------------------
\subsection{Implementation}
% ----------------------------------------------------------------

<<bitops.ml ((evaluating))>>=
module B = Bits
module I = Int64

type t      = B.t
type width  = B.width

exception Impossible of string
let impossible msg = raise (Impossible msg)
let unimp      msg = impossible ("not implemented: "^msg)
@

The following implementation relies heavily on the (hidden) internal
representation of [[bits]] values. Syntactically different values could
still represent the same value. Think about sets and it becomes obvious.
--CL.

<<bad idea>>=
let eq x y  = x = y
let ne x y  = x <> y
@

We do not check the width of operations here, because we know that they
must be equal. This ensures type checking.

<<bitops.ml ((evaluating))>>=
let myassert x = () (* there is a width inconsistency in the subcc RTL *)
let eq x y = myassert (B.width x = B.width y); B.S.to_int64 x =  B.S.to_int64 y
let ne x y = myassert (B.width x = B.width y); not (eq x y)
let lt x y = myassert (B.width x = B.width y); B.S.to_int64 x <  B.S.to_int64 y
let le x y = myassert (B.width x = B.width y); B.S.to_int64 x <= B.S.to_int64 y
let gt x y = myassert (B.width x = B.width y); B.S.to_int64 x >  B.S.to_int64 y
let ge x y = myassert (B.width x = B.width y); B.S.to_int64 x >= B.S.to_int64 y

let sx x w = 
    assert (w > B.width x && w <= 64);
    let i = B.S.to_int64 x in
        B.S.of_int64 i w

let sx64 i w =
    let w' = 64-w in
    I.shift_right (I.shift_left i w') w'
@

[[Mask]] returns the [[w]] least significant bits of [[i]].

<<bitops.ml ((evaluating))>>=
let mask i w =
    if w < 64 then 
        let m = I.shift_right_logical I.minus_one (64-w) in
        I.logand i m
    else
        i

<<bitops.ml ((evaluating))>>=
let zx x w = 
    assert (w > B.width x && w <= 64);
    let i  = B.U.to_int64 x in
        if i > I.zero || w = 64 then
            B.U.of_int64 i w
        else    
            B.U.of_int64 (mask i (B.width x)) w

let com x = 
    let w = B.width x    in
    let i = B.U.to_int64 x in
        B.U.of_int64 (I.lognot i) w

let fits_signed x w = 
    assert (w > 0 && w <= 64);
    let i = B.S.to_int64 x in
        w = 64 or
        let i' = I.shift_right i (w-1) in i' = I.zero || i' = I.minus_one  

let fits_unsigned x w = 
    assert (w > 0 && w <= 64);
    let i = B.U.to_int64 x in
        w = 64 or (I.shift_right_logical i w) = I.zero

let bitExtract ~lsb x w = 
    let w' = B.width x in
    assert (w > 0 && lsb + w < w');
    let i  = B.U.to_int64 x             in
    let i' = mask (I.shift_right i w) w in
        B.U.of_int64 i' w
    
let bitInsert ~lsb ~wide ~narrow =
    let w  = B.U.to_int64 wide   
    and n  = B.U.to_int64 narrow 
    and ww = B.width wide   
    and wn = B.width narrow 
    in
        assert (lsb + wn < ww);
        let n' = I.shift_left n lsb 
        and w' = I.logand w (I.lognot (I.shift_left (mask I.minus_one wn) lsb))
        in
            B.U.of_int64 (I.logor n' w') ww
@

We can't use [[unimp]] for the following values because the
[[Impossible.Impossible]] exception would be raised when the module is
initialized. So we have to use some dummy value.

Here are some useful IEEE 754 constants, taken from C header files:

\begin{tabularx}{\hsize}{llX}
\tt NaN & \tt 0x7f, 0xc0, 0, 0 & on big endian \\
\tt NaN & \tt 0, 0, 0xc0, 0x7f & on little endian \\
\end{tabularx}

\begin{quote}\it
    Are the results for floating point comparison standardized? It
    seems that FPUs use the four results outlined below. However, they
    seem to be free to use any format they want to indicate these. The
    Intel FPUs for example use 3-bit values to indicate a result. In
    that case we would be free to define our own 2-bit values. It
    would be the task for the platform specific implementation of the
    primitives to present the result in the right form.

    The question and consequences apply to the rounding modes, too.
\end{quote}

<<bitops.ml ((evaluating))>>=
let float_lt        = Bits.U.of_int 0 2
let float_gt        = Bits.U.of_int 1 2
let float_eq        = Bits.U.of_int 2 2
let unordered       = Bits.U.of_int 3 2

let round_nearest   = Bits.U.of_int 0 2
let round_down      = Bits.U.of_int 1 2
let round_up        = Bits.U.of_int 2 2
let round_zero      = Bits.U.of_int 3 2

let shift f x k = 
    let k  = B.U.to_int k   in
    let i  = B.U.to_int64 x in
    let w  = B.width x      in
    let i' = mask (f i k) w in
        B.U.of_int64 i' w

let shl  x k = shift I.shift_left  x k
let shra x k = shift I.shift_right x k 
let shrl x k = shift I.shift_right_logical x k
@ 

% ================================================================
\section{Residualising instantiation}
% ================================================================

\emph{I don't know what to do with this code. Currently it is not
compiled into the compiler. --CL}


% ================================================================
\section{Operations on bit vectors}
% ================================================================

This module encapsulates operations on bit vectors.
Its primary use will be to support constant evaluation, but
it is also used to evaluate `early' expressions during RTL creation.
%
<<bitops.mli ((residualizing))>>=
(*module Bitops*)
type t = Bits.bits
type width = Bits.width
@ 
Standard RTL operators
<<bitops.mli ((residualizing))>>=
(* comparisons *)
val eq : t -> t -> Base.std_bool
val lt : t -> t -> bool
val ne : t -> t -> Base.std_bool
val le : t -> t -> bool
val gt : t -> t -> bool
val ge : t -> t -> bool

val eq' : t -> t -> bool
val ne' : t -> t -> bool

(* we need addition *)
val add : t -> t -> t
    
(* extensions *)
val sx : t -> width -> t  (* sign extend to the given width *)
val zx : t -> width -> t

(* extractions a painless specialty *)
val bitExtract : lsb:int -> t -> width -> t
val bitInsert  : lsb:int -> wide:t -> narrow:t -> t

(* bitwise operations *)
val com : t -> t

(* floating-point goo *)
val float_lt : t
val float_gt : t
val float_eq : t
val unordered : t

val round_nearest : t
val round_zero : t
val round_down : t
val round_up : t

@ 
Testing for widths.
<<bitops.mli ((residualizing))>>=
val fits_signed : t -> width -> Base.std_bool
val fits_signed' : t -> width -> bool
  (* fits_signed v w == v can be narrowed to width w, then
         sign-extended to its original width, without changing its value *)
val fits_unsigned : t -> width -> Base.std_bool
val fits_unsigned' : t -> width -> bool
  (* fits_signed v w == v can be narrowed to width w, then
         zero-extended to its original width, without changing its value *)
@



% ----------------------------------------------------------------
\subsection{Implementation}
% ----------------------------------------------------------------

<<bitops.ml ((residualizing))>>=
type t = Bits.bits
type width = Bits.width

module T = Tdpe
module Sy = Syntax
    
exception Unimplemented of string
(*let unimp s = raise (Unimplemented s)*)

(* some brainless solution *)

let unimp s = ((Bits.BV,Sy.APP(Sy.VAR "raise",Sy.VAR "Unimplemented")),0)

let bitsC = T.a'
let bitsCP = T.pair(T.a',T.a')

@ Here I am making a gross approximation. Also, maybe the implementation
is not quite right. Also, perhaps one will want to residualize the calls
to [[Bits.of_]] for side-effects reasons.
<<bitops.ml ((residualizing))>>=    

let commit ((tag,bitv),w) =
  match tag with
    Bits.INT -> Tdpe.nbe' (Tdpe.arrowN(Tdpe.a',Tdpe.arrowN(Tdpe.a',bitsC)))
	(Sy.VAR "Bits.of_int") bitv (Sy.INT w)
  | Bits.NINT -> Tdpe.nbe' (Tdpe.arrowN(Tdpe.a',Tdpe.arrowN(Tdpe.a',bitsC)))
	(Sy.VAR "Bits.of_nativeint") bitv (Sy.INT w)
  | Bits.INT64 -> Tdpe.nbe' (Tdpe.arrowN(Tdpe.a',Tdpe.arrowN(Tdpe.a',bitsC)))
	(Sy.VAR "Bits.of_int64") bitv (Sy.INT w)
  | Bits.BV -> bitv
    

let bits_bits_bool s ((t1,b1),w1) ((t2,b2),w2) =
  let b1 = commit ((t1,b1),w1) in
  let b2 = commit ((t2,b2),w2) in
  if (w1=w2) then
    T.nbe' (T.arrowN(bitsC,T.arrowN(bitsC,T.booNone)))
      (Sy.VAR s) b1 b2
  else false

@ Be careful here: the sign extension should return 32 bits???
<<bitops.ml ((residualizing))>>=


let bits_int_bool s ((t,b),w) y = 
  T.nbe' (T.arrow(bitsCP,T.arrow(T.a',T.boo)))
    (Sy.VAR s) (b,Sy.INT w) (Sy.INT y)

let bits_int_a' s ((t,b),w) y = 
  T.nbe' (T.arrow(bitsCP,T.arrow(T.a',T.a')))
    (Sy.VAR s) (b,Sy.INT w) (Sy.INT y)

let bitsop s ((t,b),w) =
  ((Bits.BV,T.nbe' (T.arrow(bitsC,T.a'))
      (Sy.VAR s) b),
   w)

let bits_bits_a' s ((t1,b1),w1) ((t2,b2),w2) =
  let b1 = commit ((t1,b1),w1) in
  let b2 = commit ((t2,b2),w2) in
  if (w1=w2) then 
    T.nbe' (T.arrowN(bitsC,T.arrowN(bitsC,T.a'))) (Sy.VAR s)
      b1 b2 
  else (Sy.BOOL false)


let eq = bits_bits_a' "Bitops.eq"
let ne = bits_bits_a' "Bitops.ne"
let lt = bits_bits_bool "Bitops.lt"
let le = bits_bits_bool "Bitops.le"
let gt = bits_bits_bool "Bitops.gt"
let ge = bits_bits_bool "Bitops.ge"

let eq' = bits_bits_bool "Bitops.eq"
let ne' = bits_bits_bool "Bitops.ne"


let bits_bits_bits s ((tag,bits),w) ((tag1,bits1),w1) =
  let bv = commit ((tag,bits),w) in
  let bv1 = commit ((tag1,bits1),w1) in
  let (b2,w2) =
    T.nbe' (T.arrowN(bitsC,T.arrowN(bitsC,bitsCP)))
      (Sy.VAR s) bv bv1 in
  ((Bits.BV,b2),w)


let add = bits_bits_bits "Bitops.add"
    
    
let bits_int_bits s ((tag,bits),w) y =
  let bv = commit ((tag,bits),w) in
  let (b2,w2) =
    T.nbe' (T.arrowN(bitsC,T.arrowN(T.a',bitsCP)))
      (Sy.VAR s) bv (Sy.INT y) in
  ((Bits.BV,b2),32)
    
let sx = bits_int_bits "Bitops.sx"
let zx = bits_int_bits "Bitops.zx"

let com = bitsop "Bitops.com"

let fits_signed = bits_int_a' "Bitops.fits_signed"
let fits_unsigned = bits_int_a' "Bitops.fits_unsigned"

let fits_signed' = bits_int_bool "Bitops.fits_signed"
let fits_unsigned' = bits_int_bool "Bitops.fits_unsigned"

@ Here I clearly do not know what to do
<<bitops.ml ((residualizing))>>=
let bitExtract lsb ((t1,b1),w1) w =
  ((Bits.BV,T.nbe' (T.arrow(T.a',T.arrow(bitsCP,T.arrow(T.a',bitsC))))
      (Sy.VAR "Bitops.bitExtractX") (Sy.INT lsb) (b1,Sy.INT w1) (Sy.INT w)),
   w)
let bitInsert lsb ((t1,wide),w1) ((t2,narrow),w2) =
  ((Bits.BV,T.nbe' (T.arrow(T.a',T.arrow(bitsCP,T.arrow(bitsCP,bitsC))))
      (Sy.VAR "Bitops.bitInsertX") (Sy.INT lsb) (wide,Sy.INT w1) (narrow,Sy.INT w2)),
   w2)

let float_lt = unimp "floating-point stuff"
let float_gt = unimp "floating-point stuff"
let float_eq = unimp "floating-point stuff"
let unordered = unimp "floating-point stuff"

let round_nearest = unimp "floating-point stuff"
let round_zero = unimp "floating-point stuff"
let round_down = unimp "floating-point stuff"
let round_up = unimp "floating-point stuff"
