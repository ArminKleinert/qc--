# :VIm ts=8 et sw=4:
# ------------------------------------------------------------------ 
# $Id$
# ------------------------------------------------------------------ 

#                           READ ME FIRST
#
# This mkfile can be used in two modes.  In `gen' mode, the Lambda-RTL
# Translator is used to generate .ml and .mli files from .sled and .rtl
# descriptions.  In `normal' mode, the .ml and .mli files are taken as
# given, and there is no reference to Lambda-RTL.
#
# To use the mkfile in `gen' mode, run `mk MODE=gen'.
#
# To add a new target, modify MACHINEREGEX (and probably also mkfile.gen)

# Currently the compilation of sparcrec.ml to native code with ocamlopt
# fails.  

MODE=normal

# ------------------------------------------------------------------ 
# paths
# ------------------------------------------------------------------ 

TOP    =        ..
INTERP =        evaluating
DEPEND =        DEPEND

LIBDIR =        ../lib
BINDIR =        ../bin
MANDIR =        ../man

# extend PATH for special tools

PATH   =        $PATH:/usr/share/smlnj/bin

TKDIR =         /home/lair/nr/zephyr/cvs/toolkit
TKRTL =         $TKDIR/rtl
SLEDLIBDIR =    $TKDIR
RTLSPECDIR =    $TKRTL
SLEDSPECDIR =   /home/lair/nr/toolkit/www/specs
LRTLHEAP =     /usr/local/smlnj/bin/.heap/lrtl.x86-linux

# ------------------------------------------------------------------ 
# (high level) virtual targets
# ------------------------------------------------------------------ 

all:V:          src cmo libcmo
all.opt:V:      src cmx libcmx
	
# update and update.opt are defined below. They rely on variables
# that are not visible here.

html dvi test:VQ:          
	echo "nothing to be done"          

depend:V:       $DEPEND

# I decided that 'clobber' does not remove files that are in the
# repository but also can be derived using special tools that are
# unavailable to most developers. --CL
#
# Sparcreg is expensive to derive and thus is not removed by clean.

clean.opt:V:
	rm -f `find . -not -name 'sparcrec*' -name '*.cmx'` 
	rm -f `find . -not -name 'sparcrec*' -name '*.o'` 
	rm -f *.cmxa *.a

clean:V:        clean.opt
	rm -f `find . -not -name 'sparcrec*' -name '*.cm[io]'` 
	rm -f *.cma
	
clobber:V:      clean
	rm -f sparcrec*.cm[xio] sparcrec*.o
	rm -f *.output
	rm -f $DEPEND
	rm -f *.aux *.log *.dvi *.tex *.inc *.toc

# ------------------------------------------------------------------ 
# rules and tools for OCaml
# ------------------------------------------------------------------ 

<../config/ocaml.mk
<../config/noweb.mk

MACHINEREGEX=sparc|x86i

<mkfile.$MODE

# compiler flags used by the rules just included
# 
# We compile with -nolabels until the code generators are updated
# to generate OCaml 3.04 compliant code.

PROFILE = -p
OCAMLC_FLAGS =  -g -I $LIBDIR -nolabels
OCAMLO_FLAGS =  $PROFILE -I $LIBDIR -nolabels

# ------------------------------------------------------------------ 
# important file sets
# ------------------------------------------------------------------ 

# currently some machine generated code does not fit to the 
# runtime code in sledlib. Since we don't use it right now,
# we comment those out.

LOCAL =         sledlib.ml      \
                # sparc.ml        \
                # sparcmkasm.ml   \
		x86i.ml		\
		x86imkasm.ml	\
                # sparcrec.ml   \
                # sparcrtl.ml   \
                ast.ml          \
                astUtil.ml      \
                rtlasdl.ml      \
                rtlasdlUtil.ml  \

LOCALI =        sledlib.mli     \
                # sparc.mli       \
                # sparcmkasm.mli  \
		x86i.mli	\
		x86imkasm.mli	\
                ast.mli         \
                astUtil.mli     \
                rtlasdl.mli     \
                rtlasdlUtil.mli \
                

BAREML  =       # sparcrec.ml    

sparcrec.cmi:   sparcrec.cmo
                # do nothing; the compiler does it

CMO = ${LOCAL:%.ml=%.cmo}
CMI1 = ${LOCALI:%.mli=%.cmi} 
CMI2 = ${BAREML:%.ml=%.cmi}
CMI = $CMI1 $CMI2
CMX = ${LOCAL:%.ml=%.cmx}
OBJ = ${LOCAL:%.ml=%.o}

SCAN =          $LOCAL $LOCALI

cmo:V:          $CMO
cmx:V:          $CMX

src:V:          $SCAN

# ------------------------------------------------------------------ 
# building binaries
# ------------------------------------------------------------------ 

LIBCMO =        gen.cma
LIBCMX =        gen.cmxa
LIBOBJ =        gen.a

libcmo          \
$LIBCMO:        $CMO
	$OCAMLC $OCAMLC_FLAGS -a -o $LIBCMO $prereq
	
libcmx          \
$LIBCMX:        $CMX
	$OCAMLO $OCAMLO_FLAGS -a -o $LIBCMX $prereq

# ------------------------------------------------------------------ 
# update hierarchy
# ------------------------------------------------------------------ 

update:V:           $LIBCMO dirs $LOCALI $CMI
	for i in $LIBCMO $LOCALI $CMI
	do
	  cmp -s $i $LIBDIR/$i || cp $i $LIBDIR 
	done

update.opt:V:       $LIBCMX dirs $LOCALI $CMI
	for i in $LIBCMX $LOCALI $CMI $LIBOBJ
	do
	  cmp -s $i $LIBDIR/$i || cp $i $LIBDIR
	done

dirs:VQ:
	for i in $LIBDIR; do
	    if [ ! -d $i ]; then
	        echo "missing directory $i"
	        echo "invoke mk from the toplevel the first time"
	        echo "to create all directories"
	        false
	    fi
	done    


# ------------------------------------------------------------------ 
# recalculate dependencies
# make sure that generators are run first
# ------------------------------------------------------------------ 

depend:V: $DEPEND
$DEPEND:D:        $SCAN
	$OCAMLDEP -I $LIBDIR $SCAN > $DEPEND

# ------------------------------------------------------------------ 
# include dependencies
# ------------------------------------------------------------------ 

<$DEPEND

