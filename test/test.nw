% l2h substitution C C--
% l2h substitution PAL C--
% l2h substitution asdl ASDL
% l2h substitution ocaml OCaml

% ------------------------------------------------------------------  
\section{Testing}
% ------------------------------------------------------------------  

To increase the confidence in our implementation we like to test it. 
And since nobody likes to test because it shows ones own bugs we
want to reuse test cases as much as possible.  Currently we have two
different tests:  a fixpoint test for the parser and pretty printer,
and a regression test.  The later runs the compiler and compares its
result to previously recorded results of the expected outcome.

% ------------------------------------------------------------------ 
\subsection{Writing a test case}
% ------------------------------------------------------------------ 

To keep the test environment as open as possible very few conventions
exist for test cases:

\begin{itemize}
\item A test case should be a file with a [[.c--]] suffix because the
      [[mk test]] target uses all these files as test cases.

\item A test case includes shell commands to perform the test. They
      are embedded in a {\PAL} comment [[///]] starting at the
      beginning of a line:

\begin{verbatim}
// execute the commands below to use this file as a test case
/// ./fp test-000.c--
/// ./regr "../bin/qc-- -check test-000.c--"  -err test-000.2 -x 1

register bits32 x;
register bits32 x;

foo () 
{ }
\end{verbatim}

      It is a convention to name the file for the expected output on
      standard output and standard error after the base name of the
      test case and using the suffix [[.1]] and [[.2]] respectively.
\end{itemize}

In the example above the same test case is used for the fixpoint test
[[fp]] and a regression test [[regr]].  More precisely, the compiler
is expected to exit with an exit code of 1 ([[-x 1]]) and detect the
second declaration of [[x]].  Its output on standard error should
match the file [[test-000.c--]].

The price for the flexibility to include many tests into the same test
case is, that some familiarity with the available tests is required. 
Reusing tests when a new test is added also requires to edit the test
cases because they decide which test to use.

% ------------------------------------------------------------------  
\subsection{Fixpoint Test}
% ------------------------------------------------------------------ 

The [[qc--]] compiler can re-create the concrete syntax of a file that
is has parsed:  [[qc-- -pp file.c--]] writes a pretty printed form of
[[file.c--]] to standard output.  This is an opportunity for a
fixpoint test: 

\begin{enumerate}
\item \label{one} Parse a file and write out its concrete syntax.
\item \label{two} Parse again the output of step \ref{one} and write
      out its concrete syntax. The output of step \ref{one} and this
      one should not differ.
\end{enumerate}

Every \textit{grammatical legal} \C~input can thus be used to easily
test the parsing and pretty printing modules of the compiler.  Doing
it for the actual implementation, however, requires a third parsing
and printing step before the fixpoint is reached:  when [[qc--]]
parses a pragma it pretty prints a comment for it.  Since comments are
skipped while scanning in the next round, this comment will not
produce any output.  When this output again is parsed and printed it
should be equal to the one just parsed. 

A simple shell script implements the fixpoint test. 

<<fp>>=
#! /bin/sh

# interrupt handler

trap "rm -f $tmp/$this.$$.* ; exit 1" 1 2 3 15


this="`basename $0`"
tmp="${TMP:-/tmp}"
qc="../bin/qc--"

# check command line

if [ $# -ne 1 ]; then
    echo "usage: $this file.c--"    
fi

file="$1"

# three rounds

$qc -pp $file           > $tmp/$this.$$.1
$qc -pp $tmp/$this.$$.1 > $tmp/$this.$$.2
$qc -pp $tmp/$this.$$.2 > $tmp/$this.$$.3

diff -c $tmp/$this.$$.2 $tmp/$this.$$.3 || echo ">>> $file "
rc="$?"

# clean up and return

rm -f $tmp/$this.$$.*
exit $rc
@
 
% ------------------------------------------------------------------ 
\subsection{Regression Test}
% ------------------------------------------------------------------ 

While the fixpoint test is good to test the scanner and parser with
legal input it it much less suited for \C~files that contain errors. 
Here is a little script for regression testing that assists in this
job:  it runs a command and compares the exit code, standard output,
and standard error produced by the program with expected results:  

\begin{quote}
    regr "qc-- -pp foo.c--" -out foo.1 -x 0
\end{quote}

This command [[regr]] runs [[qc-- -pp foo.c--]], compares the standard
output with [[foo.1]] and the exit code with [[0]].  Any differences
to the expected outcome are reported.  The [[regr]] script is flexible
enough to provide optionally standard input ([[-in]]) to the command
it runs and can compare files ([[-f]]) the commands creates with
existing files.  Options accepted by [[regr]]:

\begin{itemize}
\item [[-in file]]: The command gets its standard input from [[file]].
\item [[-out file]]: The standard output of the command is compared to
      [[file]]. 
\item [[-err file]]: The standard error output of the command is
      compared to [[file]].
\item [[-x n]]: The command is expected to exit with exit code [[n]].
\item [[-f /some/file]]:  The command is expected to create a file
      [[/some/file]]. The contents of [[/some/file]] and [[file]] in
      the local directory are compared.
\item [[-r]] recording mode: the output of the command is captured in
      the respective files for later comparison.
\end{itemize}

The script can be used in a recording mode where the standard and
error output of a command are recored in files for later comparison.
Running the regression test is especially useful after changes to the
compiler to make sure the old behavior is still matched.

<<regr>>=
#! /bin/sh 
##
##
## regr cmd [-r] [-v] [-in ifile] [-out ofile] [-err efile] [-x n] [-f file].. 
##
## see usage below or call without parameters for usage
##

## set defaults

verbose=off
this="regr"
tmp="${TMP:-/tmp}/$this.$$"
stdin="/dev/null"
stdout="/dev/null"
stderr="/dev/null"
exitc="0"
recording=off
files=""

## interrupt handler

trap "rm -f $tmp.* ; exit 1" 1 2 3 15


## parse command line arguments and show usage

if [ $# -lt 1 ]; then
    cat <<EOF
    
     $this cmd [-r] [-in ifile] [-out ofile] [-err efile] [-x n]  [-f file] .. 
    
     Regression test tool. Runs cmd and matches its behavior against specs
     on the command line:

     
     -x n:        cmd is expected to exit with exitcode n (default 0)
     -out ofile:  cmd's stdout should match ofile         (default /dev/null)
     -err efile:  cmd's stderr should match efile         (default /dev/null)
     -in  ifile:  cmd gets its stdin from ifile           (default /dev/null)
    
     -f   /some/file    
                  cmd is expected to create /some/file. /some/file should 
		  NOT be placed into the \$CWD. /some/file is compared against
                  \$CWD/file. /some/file is deleted after comparison
    
     -r           recording mode: no comparisons are done. Instead all
                  output of cmd is directed to the files specified on the
                  command line.
                  In case of -f /some/file is moved to \$CWD/file
    
                  The recording mode helps to build all the files for
                  later regression testing.  

     -v           Verbose Flag.
EOF
exit 2
fi

cmd="$1"
shift
while : ; do
    case "$1" in
	"")
	    break;;
	-in)
	    stdin="$2"; shift;;
	-out)
	    stdout="$2"; shift;;
	-err)
	    stderr="$2"; shift;;
	-x)
	    exitc="$2"; shift;;
	-v)
            verbode="on";;
	-r)
	    recording="on";;
	-f)
	    files="$files $2"; shift;;
	*)
	    echo "unknown option: $1" 2>&1;
	    exit 2;;
    esac
    shift
done


#
# run cmd
#

if [ "$verbose" = "on" ]; then
    echo "testing command: '$cmd'"
fi

if [ "$recording" = "off" ]; then
    $cmd < "$stdin" 2> "$tmp.stderr" > "$tmp.stdout"
    returnc="$?"
else
    # recording mode - do not compare but create files 
    # as specified on the cmd line

    $cmd < "$stdin" 2> "$stderr" > "$stdout"
    for f in $files; do
	mv $f `basename $f`
    done
    exit 0
fi

#
# check results (only if not in recording mode)
#

# return code for $this

rc=0

if ! [ "$returnc" = "$exitc" ]; then
    echo "failed: '$cmd' exit code $returnc does not match $exitc"
    rc=1
fi

if ! cmp "$stdout" "$tmp.stdout" ; then
    echo "failed: '$cmd' stdout does not match expectation"
    rc=1
fi

if ! cmp "$stderr" "$tmp.stderr" ; then
    echo "failed: '$cmd' stderr does not match expectation"
    rc=1
fi

for f in $files; do
    expect=`basename $f`
    if ! cmp $f $expect; then 
	echo "failed: $f does not match expectation $expect"
	diff -c $f $expect
	rm -f $f
	rc=1
	break
    else
	rm -f $f
    fi
done

#
# clean up
#

rm -f $tmp.*

#
# exit
#

exit $rc
@





