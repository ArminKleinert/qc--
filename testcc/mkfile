# vim:ts=8 et sw=4:
#
# This directory contains code to test calling conventions. Code is
# generated by scripts:
#
#   call.pl:    - horrible script that emits one c-- file per signature
#
# To generate code and run the test, do the following:
#
#   mk all
#   mk asm
#   mk x86-test,    if on x86
#   mk mips-test,   if on MIPS
#   mk alpha-test,  if on Alpha
#

TOP =               ..
QCC =               $TOP/bin/qc--
GEN =               ./call.pl
CC  =               cc

#
# The cmm-internal script generated an unkown number of files. Therfore
# I cannot list them here. I don't know how to organize compiling and
# testing them. 
#

# The following line can reach an internal mk(1) limit when the list of 
# C-- files is long. 
#
# ASM =               `ls -1 *.c-- | sed s'/\.c--/.s/'`
# asm:V:            $ASM
#
# Therefore I reverted to the more explicit asm rule below.

all:V:              alpha-call x86-call mips-call
asm:V:
                    for f in *.c--; do
                        mk `basename $f .c--`.s
                    done    

# A rule to pretty print a C-- source file

%.pp:               %.c--
                    $QCC -pp $prereq

#
# A .sigs file contains lines of signatures for tests. Signatures are
# emitted by the QC-- compiler. You can enlarge the number of signatures
# by specifying more withs and hints to try. This only makes sense if
# they are actually implemented.
#
# Use Debug.Mips.proc_all_paths() to get all signatures relevant for the
# MIPS. This creates 64-bit floats, but no 64-bit integers, which are
# unknown on the MIPS.


alpha-call.sigs:    $QCC 
	$QCC -e 'Debug.Alpha.proc_paths({64},{"int","float"}) exit(0)' > $target

x86-call.sigs:      $QCC
	$QCC -e 'Debug.X86.c_proc_paths({32},{"int"}) exit(0)' > $target

mips-call.sigs:     $QCC
	$QCC -e 'Debug.Mips.proc_paths({32},{"float","int"}) exit(0)' > $target

#
# Generate *.c-- files from one signature file. The test case generator
# must know about endianness, wordsize, and the base name of the test
# files.
#

alpha-call:V:       alpha-call.sigs
                    #$GEN  -name=$target                   -width=64 < $prereq 
                    $GEN  -name=$target-x -c              -width=64 < $prereq
                    #$GEN  -name=$target-cmm0 -conv="cmm0" -width=64 < $prereq 
                    #$GEN  -name=$target-cmm1 -conv="cmm1" -width=64 < $prereq 
                    #$GEN  -name=$target-cmm2 -conv="cmm2" -width=64 < $prereq 
                    #$GEN  -name=$target-cmm3 -conv="cmm3" -width=64 < $prereq 

x86-call:V:         x86-call.sigs             
                    $GEN -name=$target-cmm  -width=32 -conv="notail" < $prereq
                    $GEN -name=$target      -width=32 < $prereq
                    $GEN -name=$target-x -c -width=32 < $prereq
                    $GEN -name=$target-cspec -conv="c'" -c -width=32 < $prereq
                    

mips-call:V:        mips-call.sigs
                    # $GEN -name=$target-x -c -width=32 < $prereq
                    $GEN -name=$target-x-cspec -c -conv="c'" -width=32 < $prereq

#
# Compile *.c-- files to *.s code. Compilation depends on the desired
# target.
# 

x86%.s:             x86%.c--
                    $QCC -globals backend=Backend.x86 -stop .s $prereq

alpha%.s:           alpha%.c--                    
                    $QCC -globals backend=Backend.alpha -stop .s $prereq

mips%.s:            mips%.c--
                    $QCC -globals backend=Backend.mips -stop .s $prereq

alpha%.dbg:        alpha%.c--
                    $QCC -globals backend=Backend.alpha  \
                         backend.asm=Asm.cmm -stop .s -o $target $prereq

#
# Run tests. This will only work on the right platform.
#

x86-test:V:         asm
                    set -x
                    for f in x86-call-main-*.s x86-call-cmm-main-*.s; do
                        cc $f && ./a.out
                    done
                    for f in x86-call-x-main-*.s; do
                        g=`echo $f | sed -e 's/main/callee/' -e 's/\.s/.c/'`
                        cc $f $g && ./a.out
                    done    
                    for f in x86-call-cspec-main-*.s; do
                        g=`echo $f | sed -e 's/main/callee/' -e 's/\.s/.c/'`
                        cc $f $g && ./a.out
                    done    

#
# For machines without mk(1) I write actions to sh(1) script which I
# execute manually.
#

alpha-test:V:       asm alpha.sh
                    sh alpha.sh
alpha.sh:
                    echo '
                    set -x
                    for f in alpha-call-cmm*-main-*.s; do
                        cc $f 2> /dev/null
                        ./a.out
                    done    
                    for f in alpha-call-main-*.s; do
                        cc $f 2> /dev/null
                        ./a.out
                    done    
                    
                    for f in alpha-call-x-main-*.s; do
                        g=`echo $f | sed -e 's/main/callee/' -e 's/\.s/.c/'`
                        cc $f $g 2> /dev/null
                        ./a.out
                    done   
                    ' > $target

mips-test:          asm mips.sh
                    sh mips.sh

mips.sh:
                    echo '
                    set -x
                    for f in mips-call-main-*.s; do
                        cc $f 
                        ./a.out
                    done    
                    for f in mips-call-x-main-*.s; do
                        g=`echo $f | sed -e 's/main/callee/' -e 's/.s$/.c/'`
                        cc $f $g 
                        ./a.out
                    done   
                    for f in mips-call-x-cspec-main-*.s; do
                        g=`echo $f | sed -e 's/main/callee/' -e 's/.s$/.c/'`
                        cc $f $g 
                        ./a.out
                    done   
                    
                    ' > $target

clean:V:
                    rm -f *.c--
                    rm -f *.o
                    rm -f *.c
                    rm -f *.s
                    rm -f *.sigs
                    rm -f a.out
                    rm -f alpha.sh
                    rm -f *.dbg
                    rm -f *.pp

clobber:V:          clean
                    
