# vim:ts=8 et sw=4:
#
# This directory contains code to test calling conventions. Code is
# generated by scripts:
#
#   cmm-internal.pl:    - horrible script that emits one c-- file per signature
#

TOP =               ..
QCC =               $TOP/bin/qc--
GEN =               ./call.pl
CC  =               cc

#
# The cmm-internal script generated an unkown number of files. Therfore
# I cannot list them here. I don't know how to organize compiling and
# testing them. 
#

ASM =               `ls -1 *.c-- | sed s'/\.c--/.s/'`

all:V:              alpha-call x86-c-call mips-call
asm:V:              $ASM

# A rule to pretty print a C-- source file

%.pp:               %.c--
                    $QCC -pp $prereq

#
# A .sigs file contains lines of signatures for tests. Signatures are
# emitted by the QC-- compiler. You can enlarge the number of signatures
# by specifying more withs and hints to try. This only makes sense if
# they are actually implemented.
#

alpha-call.sigs:    $QCC 
                    $QCC -e 'Debug.Alpha.proc_paths({64},{"int"})' > $target

x86-c-call.sigs:    $QCC
                    t=$target
                    $QCC -e 'Debug.X86.c_proc_paths({32},{"int"})' > $t

mips-call.sigs:     $QCC
                    t=$target
                    $QCC -e 'Debug.Mips.proc_paths({32},{"int"})' > $t
                    # $QCC -e 'Debug.Mips.proc_paths({32},{"float"})' > $t

#
# Generate *.c-- files from one signature file. The test case generator
# must know about endianness, wordsize, and the base name of the test
# files.
#

alpha-call:V:       alpha-call.sigs
                    $GEN  -name=$target                   -width=64 < $prereq 
                    $GEN  -name=$target-x -c              -width=64 < $prereq
                    $GEN  -name=$target-cmm0 -conv="cmm0" -width=64 < $prereq 
                    $GEN  -name=$target-cmm1 -conv="cmm1" -width=64 < $prereq 
                    $GEN  -name=$target-cmm2 -conv="cmm2" -width=64 < $prereq 
                    $GEN  -name=$target-cmm3 -conv="cmm3" -width=64 < $prereq 

x86-c-call:V:       x86-c-call.sigs             
                    $GEN -name=$target      -width=32 < $prereq
                    $GEN -name=$target-x -c -width=32 < $prereq

mips-call:V:        mips-call.sigs
                    $GEN -name=$target      -width=32 < $prereq
                    $GEN -name=$target-x -c -width=32 < $prereq

#
# Compile *.c-- files to *.s code. Compilation depends on the desired
# target.
# 

x86%.s:             x86%.c--
                    $QCC backend=Backend.x86   -S $prereq

alpha%.s:           alpha%.c--                    
                    $QCC backend=Backend.alpha -S $prereq

mips%.s:            mips%.c--
                    $QCC backend=Backend.mips  -S $prereq

alpha%.dbg:        alpha%.c--
                    $QCC backend=Backend.alpha  \
                         backend.asm=Asm.cmm -S -o $target $prereq

#
# Run tests. This will only work on the right platform.
#

x86-test:V:         $ASM
                    for f in x86-c-call-main-*.s; do
                        cc $f && ./a.out
                    done
                    for f in x86-c-call-x-main-*.s; do
                        g=`echo $f | sed -e 's/main/callee/' -e 's/\.s/.c/'`
                        cc $f $g && ./a.out
                    done    

#
# Our Alphas don't have mk(1) installed. Therefore I keep the action
# in a sh(1) script which I can run manually.
#

alpha-test:V:       $ASM
                    sh alpha.sh


alpha.sh:V:
                    echo '
                    set -x
                    for f in alpha-call-cmm*-main-*.s; do
                        cc $f 2> /dev/null
                        ./a.out
                    done    
                    for f in alpha-call-main-*.s; do
                        cc $f 2> /dev/null
                        ./a.out
                    done    
                    
                    for f in alpha-call-x-main-*.s; do
                        g=`echo $f | sed -e 's/main/callee/' -e 's/\.s/.c/'`
                        cc $f $g 2> /dev/null
                        ./a.out
                    done   
                    ' > $target

mips.sh:V:
                    echo '
                    set -x
                    for f in mips-call-main-*.s; do
                        cc $f 
                        ./a.out
                    done    
                    
                    for f in mips-call-x-main-*.s; do
                        g=`echo $f | sed -e 's/main/callee/' -e 's/.s$/.c/'`
                        cc $f $g 
                        ./a.out
                    done   
                    ' > $target

clean:V:
                    rm -f *.c--
                    rm -f *.o
                    rm -f *.c
                    rm -f *.s
                    rm -f *.sigs
                    rm -f a.out
                    rm -f alpha.sh
                    rm -f *.dbg

clobber:V:          clean
                    
