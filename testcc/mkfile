# vim:ts=8 et sw=4:
#
# This directory contains code to test calling conventions. Code is
# generated by scripts:
#
#   call.pl:    - horrible script that emits one c-- file per signature
#
# To generate code and run the test, do the following:
#
#   mk
#   mk x86-test     if on x86
#   mk mips-test    if on MIPS
#   mk alpha-test   if on Alpha
#
# If you need to run the tests on another machine, tarballs are created
# for your convenience (<architecture>-test.tar.gz).  Simply expand them
# and run the appropriate script (<architecture>.sh).
#

TOP      = ..
QCC      = $TOP/bin/qc--.opt
#QCCFLAGS = backend.ralloc=Ralloc.dls -v
QCCFLAGS = -v
GEN      = ./call.pl
CC       = cc

#
# The cmm-internal script generated an unknown number of files. Therefore
# I cannot list them here. I don't know how to organize compiling and
# testing them. 
#

# The following line can reach an internal mk(1) limit when the list of 
# C-- files is long. 
#
# ASM = `ls -1 *.c-- | sed s'/\.c--/.s/'`
# asm:V: $ASM
#
# Therefore I reverted to more explicit asm rules.

all:VQ:
  mk call ; mk asm ; mk tarballs

call:V: alpha-call x86-call mips-call
asm :V: alpha-asm  x86-asm  mips-asm

# A rule to pretty print a C-- source file

%.pp: %.c--
    $QCC -pp $prereq

#
# A .sigs file contains lines of signatures for tests. Signatures are
# emitted by the QC-- compiler. You can enlarge the number of signatures
# by specifying more widths and hints to try. This only makes sense if
# they are actually implemented.
#
# Use Debug.Mips.proc_all_paths() to get all signatures relevant for the
# MIPS. This creates 64-bit floats, but no 64-bit integers, which are
# unknown on the MIPS.

alpha-call.sigs:D:
  $QCC -e 'Debug.paths_proc(Backend.alpha.target, "C", {64}, {"int","float"})'\
    > $target

x86-call.sigs:D:
  $QCC -e 'Debug.paths_proc(Backend.x86.target, "C", {32}, {"int"})' > $target

mips-call.sigs:D:
  $QCC -e 'Debug.paths_proc(Backend.mips.target, "C", {32},{"float","int"})' \
    > $target

#
# Generate *.c-- files from one signature file. The test case generator
# must know about endianness, wordsize, and the base name of the test
# files.
#

alpha-call:V: alpha-call.sigs
               $GEN -name=alpha                           -width=64 < $prereq
              #$GEN -name=alpha-cmm0      -conv="cmm0"    -width=64 < $prereq
              #$GEN -name=alpha-cmm1      -conv="cmm1"    -width=64 < $prereq 
              #$GEN -name=alpha-cmm2      -conv="cmm2"    -width=64 < $prereq
              #$GEN -name=alpha-cmm3      -conv="cmm3"    -width=64 < $prereq 
               $GEN -name=alpha-x      -c                 -width=64 < $prereq

x86-call:V:   x86-call.sigs             
               $GEN -name=x86                             -width=32 < $prereq
               $GEN -name=x86-cmm         -conv="notail"  -width=32 < $prereq
               $GEN -name=x86-x        -c                 -width=32 < $prereq
               $GEN -name=x86-x-cspec  -c -conv="C'"      -width=32 < $prereq

mips-call:V:  mips-call.sigs
               $GEN -name=mips                            -width=32 < $prereq
               $GEN -name=mips-x -c                       -width=32 < $prereq
              #$GEN -name=mips-x-cspec -c -conv="c'"      -width=32 < $prereq

#
# Compile *.c-- files to *.s code. Compilation depends on the desired
# target.
# 

X86_CMM    = x86*.c--
ALPHA_NUMS = 0 1 2 3 4 5 6 7
ALPHA_CMM  = ${ALPHA_NUMS:%=alpha\\[%]??.c--}
MIPS_CMM   = mips*.c--

x86-asm:V:
	for f in "`echo "$X86_CMM" | tr ' ' '\n'`" ; do
		$QCC -e 'Options.globals=2' backend=Backend.x86 $QCCFLAGS \
	    	 -stop .s `echo $f`
	done

alpha-asm:V:
    for f in $ALPHA_CMM; do
        PATTERN=`echo $f | tr '\\\\' '*'`
        FILES=`echo $PATTERN`
		$QCC -e 'Options.globals=2' backend=Backend.alpha $QCCFLAGS \
              -stop .s $FILES
	done

mips-asm:V:
	for f in "`echo "$MIPS_CMM" | tr ' ' '\n'`" ; do
		$QCC -e 'Options.globals=2' backend=Backend.mips $QCCFLAGS \
        	 -stop .s `echo $f`
	done

alpha%.dbg: alpha%.c--
  $QCC -e 'Options.globals=2' backend=Backend.alpha  \
       backend.asm=Asm.cmm -stop .s -o $target $prereq

#
# Run tests. This will only work on the right platform.
#

tarballs:V: alpha-test.tar.gz mips-test.tar.gz x86-test.tar.gz

%-tarball:V: %-test.tar.gz

%-test.tar.gz: %.sh
  cd ..
  tar cf - testcc/$prereq testcc/$stem*.c testcc/$stem*.s | \
    gzip -c > testcc/$target
  cd testcc

%-test:Q: %.sh
  sh $prereq

x86.sh:Q:
  echo '
  # set -x
  rm -f x86.log
  NFILES=`ls -1 x86*.s | wc -l`
  I=0
  for f in x86-mn-*.s x86-cmm-mn-*.s; do
    (cc $f && ./a.out) | tee -a x86.log | grep -v success
    I=$((I + 1))
    echo -n -e Finished $I out of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
  done
  for f in x86-x-mn-*.s; do
    g=`echo $f | sed -e "s/mn/callee/" -e "s/\.s/.c/"`
    (cc $f $g && ./a.out) | tee -a x86.log | grep -v success
    I=$((I + 1))
    echo -n -e Finished $I out of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
  done    
  for f in x86-x-cspec-mn-*.s; do
    g=`echo $f | sed -e "s/mn/callee/" -e "s/\.s/.c/"`
    (cc $f $g && ./a.out) | tee -a x86.log | grep -v success
    I=$((I + 1))
    echo -n -e Finished $I out of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
  done
  echo Completed testing x86 architecture.  Log file x86.log created.
  ' > $target  
  chmod +x $target

alpha.sh:Q:
  echo '
  # set -x
  rm -f alpha.log
  NFILES=`ls -1 alpha*.s | wc -l`
  I=0
  # for f in alpha-cmm*-mn-*.s; do
  #   (cc $f && ./a.out) | tee -a alpha.log | grep -v success
  #   I=$((I + 1))
  #   echo -n -e Finished $I out of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
  # done    
  for f in alpha-mn-*.s; do
    (cc $f && ./a.out) | tee -a alpha.log | grep -v success
    I=$((I + 1))
    echo -n -e Finished $I out of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
  done
  for f in alpha-x-mn-*.s; do
    g=`echo $f | sed -e 's/mn/callee/' -e 's/\.s/.c/'`
    (cc $f $g && ./a.out) | tee -a alpha.log | grep -v success
    I=$((I + 1))
    echo -n -e Finished $I out of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
  done   
  echo Completed testing Alpha architecture.  Log file alpha.log created.
  ' > $target
  chmod +x $target

mips.sh:Q:
  echo '
  # set -x
  rm -f mips.log
  NFILES=`ls -1 mips*.s | wc -l`
  I=0
  for f in mips-mn-*.s; do
    (cc -mno-abicalls -fno-pic -Wa,--no-warn $f && ./a.out) | \
      tee -a mips.log | grep -v success
    I=$((I + 1))
    echo -n -e Finished $I out of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
  done    
  for f in mips-x-mn-*.s; do
    g=`echo $f | sed -e 's/mn/callee/' -e 's/.s$/.c/'`
    (cc -Wa,--no-warn $f $g && ./a.out) | \
      tee -a mips.log | grep -v success
    I=$((I + 1))
    echo -n -e Finished $I out of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
  done   
  # for f in mips-x-cspec-mn-*.s; do
  #   g=`echo $f | sed -e 's/mn/callee/' -e 's/.s$/.c/'`
  #   (cc -Wa,--no-warn $f $g && ./a.out)| \
  #     tee -a mips.log | grep -v success
  #   I=$((I + 1))
  #   echo -n -e Finished $I out of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
  # done   
  echo Completed testing MIPS architecture.  Log file mips.log created.
  ' > $target
  chmod +x $target

clean:V:
   rm -f *.c-- *.c *.o *.s a.out *.sigs
   rm -f alpha.sh mips.sh x86.sh
   rm -f *.dbg *.pp *-test.tar.gz
   rm -f *.log

clobber:V: clean
