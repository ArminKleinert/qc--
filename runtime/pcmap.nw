% -*- mode: Noweb; noweb-code-mode: c-mode -*-
% $Id$

% ---------------------------------------------------------------------------
\section{PC Map}
% ---------------------------------------------------------------------------
This file provides an interface to the runtime data emitted by the
compiler. The runtime data is in a table indexed by PC. For each call
site and continuation, there is an entry in the [[pcmap]] section
which points to the runtime data. The actual runtime data is placed in
the [[pcmap_data]] section. Both of these are collected up, sorted by
PC, and placed in the a data section by the system linker. Below is an
example linker script for x86 Linux that makes the pcmap available to
the runtime system.
<<pcmap.ld>>=
SECTIONS {
 .rodata : {
   . =  (. + 3) & ~ 3;
   Cmm_pc_map = .;
   *(.pcmap)
   Cmm_pc_map_limit = .;
   *(.pcmap_data)
 }
}
@
The [[pc_map_index]] and [[pc_map_entry]] structs below are used to
access the PC map table, and runtime data entries emitted by the
compiler. A more detailed description of the layout and contents of
the emitted data can be found in the file [[src/runtimedata.nw]].
<<pcmap.h>>=
#ifndef PC_MAP_H
#define PC_MAP_H

typedef struct {
  Cmm_Word    frame_size;
  Cmm_Word    overflow_size;
  Cmm_Codeptr return_address;
  Cmm_Word*   stackdata_table;
  Cmm_Word    num_registers;
  Cmm_Word    num_locals;
  Cmm_Word    num_spans;
  Cmm_Word    cont_block_size;
  Cmm_Word    data[1]; // registers, locals, continuations, spans.
} pc_map_entry;


#define enf(entry,field) (((pc_map_entry*)entry)->field)

#define registers(e)      ((Cmm_Word*)enf(e,data))
#define locals(e)        (((Cmm_Word*)enf(e,data)) + enf(e,num_registers))
#define continuations(e) (((Cmm_Word*)enf(e,data)) + enf(e,num_registers) \
                                                   + enf(e,num_locals))
#define spans(e)         (((Cmm_Word*)enf(e,data)) + enf(e,num_registers) \
                                                   + enf(e,num_locals)    \
                                                   + enf(e,cont_block_size))

typedef struct {
  Cmm_Codeptr ra;
  pc_map_entry* entry;
} pc_map_index;

pc_map_entry* Cmm_lookup_entry(const Cmm_Codeptr caller);

unsigned is_dead(int local);
unsigned decode_reg(int local);
signed   decode_offset(int local);

void Cmm_show_map(); // for debugging

enum ctypes { CHAR = 0, DOUBLE = 1, FLOAT = 2, INT = 3, LONGDOUBLE = 4, LONGINT = 5
            , LONGLONGINT = 6, SHORT = 7, SIGNEDCHAR = 8, UNSIGNEDCHAR = 9
            , UNSIGNEDLONG = 10, UNSIGNEDSHORT = 11, UNSIGNEDINT = 12
            , UNSIGNEDLONGLONG = 13, ADDRESS = 14 
            };

#endif /* PC_MAP_H */
@ 
The runtime system expects the symbols [[Cmm_pc_map]] and
[[Cmm_pc_map_limit]] to be emitted by the linker.
<<pcmap.c>>=
#include "qc--runtime.h"
#include "pcmap.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

extern pc_map_index Cmm_pc_map[];
extern pc_map_index Cmm_pc_map_limit[];
#define pc_map_size (Cmm_pc_map_limit - Cmm_pc_map)
@ 
If we can rely on the linker (or the compiler) to sort the entries by PC, then the
lookup function can do binary search.
Otherwise we have to do a linear search.

Two adjacent entries with \emph{equal} PCs are considered OK.
This can happen if a call site annotated with [[never returns]] is
followed immediately by a continuation, for example.
<<pcmap.c>>=
static int is_sorted(void) {
  pc_map_index *p;
  for (p = Cmm_pc_map+1; p < Cmm_pc_map_limit; p++)
    if (p[-1].ra > p[0].ra) {  
      fprintf(stderr, "C-- Surprise! PCMAP array is unsorted!\n");
      for (p = Cmm_pc_map; p < Cmm_pc_map_limit; p++)
        fprintf(stderr, "  ra = %8p\n", p->ra);
      return 0;
    }
  return 1;
}

static int compare(const void *x, const void *y) {
  const pc_map_index *p = y;
  return (unsigned) x - (unsigned) p->ra;
}

static pc_map_entry *binlookup(const Cmm_Codeptr caller) {
  pc_map_index *p;
  p = bsearch(caller, Cmm_pc_map, pc_map_size, sizeof(Cmm_pc_map[0]), compare);
  if (p)
    return p->entry;
  else
    return NULL;
}

static pc_map_entry* linlookup(const Cmm_Codeptr caller) {
  unsigned i = 0;
  for(i = 0; i < pc_map_size; ++i) {
    if (Cmm_pc_map[i].ra == caller) {
      return Cmm_pc_map[i].entry;
    }
  }
  return NULL;
}

static pc_map_entry *(*lookup)(const Cmm_Codeptr caller) = NULL;

pc_map_entry*
Cmm_lookup_entry(const Cmm_Codeptr caller)
{
  if (lookup == NULL)
    lookup = is_sorted() ? binlookup : linlookup;
  return lookup(caller);
}
@ 
The compiler encodes the type in the top two bits. Registers are given
the encoding [[01]], dead variables are given [[00]], and offsets are
prefixed with 1. See [[emit_data]] in [[src/runtimedata.nw]] for more
details.
<<pcmap.c>>=
#define GOODBITS (sizeof(local)*8 - 2)
unsigned
decode_reg(int local) {
  if (local > 0 && local @<< 1 < 0)
  {
    int mask   = GOODBITS / 2;
    int slice  = (local & ((1 @<< GOODBITS) - 1)) >> mask;
    int offset =  local & ((1 @<< mask    ) - 1);

    if (slice) {
      fprintf(stderr, "register slices not supported.\n");
      assert(0);
    }
    return offset;
  }
  return 0;
}
<<pcmap.c>>=
signed
decode_offset(int local) {
  assert(local < 0);
  local <<= 1;        // GCC BUG !!
  return local / 2;
}
<<pcmap.c>>=
unsigned
is_dead(int local) {
  if (local >= 0 && local @<< 1 >= 0) {
    return 1;
  } else {
    return 0;
  }
}
@ 
A linear search function is useful for debugging.
<<pcmap.c>>=
@ 
[[show_map]] dumps out all of the runtime data. It is only useful for
debugging the [[qc--]] runtime system.
<<pcmap.c>>=
void Cmm_show_map(void) {
  unsigned i;
  printf("pc_map_size %d\n", pc_map_size);
  for (i = 0; i < pc_map_size; ++i) {
    printf("%d: ra:%p  entry:%p -> frame_size:%X -> %X, overflow:%X\n"
           "\tregs:%X,locals%X,spans:%X,size of cont block:%X\n",
           i, Cmm_pc_map[i].ra, Cmm_pc_map[i].entry,
           Cmm_pc_map[i].entry->frame_size,
           decode_offset(Cmm_pc_map[i].entry->frame_size),
           Cmm_pc_map[i].entry->overflow_size,
           Cmm_pc_map[i].entry->num_registers,
           Cmm_pc_map[i].entry->num_locals,
           Cmm_pc_map[i].entry->num_spans,
           Cmm_pc_map[i].entry->cont_block_size           
           );
  }
}
@ 
