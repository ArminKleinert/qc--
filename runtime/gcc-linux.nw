% -*- mode: Noweb; noweb-code-mode: c-mode -*-
% $Id$

% ---------------------------------------------------------------------------
\section{Walking GCC-Linux Stack Frames}
% ---------------------------------------------------------------------------
This version of the gcc stack walker assumes that a frame pointer is
being used (no --fomit-frame-pointer). Every function stores the frame
pointer in [[EBP]], and this register is saved at the top of each
stack frame on entry.
<<gcc-linux.c>>=
#include "qc--runtime.h"
#include "pcmap.h"
#include <assert.h>
#include <stdio.h>
@ 
We are done when we find a call site in our runtime data.
<<gcc-linux.c>>=
int
cmm_caller(Cmm_Word* fp) {
  pc_map_entry* entry;
  assert(fp);
  entry = Cmm_lookup_entry((const Cmm_Codeptr)*(fp));
  return (entry != 0);
}
@ 
<<gcc-linux.c>>=
int
reasonable(void *fp) {
  return ((unsigned)fp >= 0xB0000000);
}
@
I know how to restore EBP, but not the other regs.
The [[qc--]] client needs to kill all regs before calling a C function.
<<gcc-linux.c>>=
#define EBP 9 /* r[5] */
Cmm_Word*
walk_foreign_frames(Cmm_Word* fp, Cmm_Word* regs)
{
  int tries = 0;
  fp = (Cmm_Word*)regs[EBP];
  do {
    fp = (Cmm_Word*)*fp;
    if (!reasonable(fp) || tries++ > 20)
      return 0;
  } while (!cmm_caller(fp + 1));
  regs[EBP] = (unsigned)fp;
  return fp+1;
}
@
<<gcc-linux.c>>=
void Cmm_init_c_frame(Cmm_Activation *a, char *young_in_overflow) {
  Cmm_Word ebp;
  assert(a->regs[EBP]);
  ebp = *a->regs[EBP];
  a->vfpx = (char *) ebp;
  a->u.cwalk.tries = 0;
}

extern struct cmm_activation_methods *Cmm_cmm_frame_methods;


int Cmm_c_change_activation(Cmm_Activation *a) {
  Cmm_Word callerebp;
  Cmm_Codeptr ra;
  pc_map_entry *entry;
  int i;

  if (a->vfpx == 0) {
    fprintf(stderr, "C walk ended with a->vfp = 0\n");
    return 0;
  }
#if 0
 {
  Cmm_Word *myebp = a->vfpx;
  fprintf(stderr, "Leaving C activation; my ebp = %p, ra = %p, caller's EBP = %p\n",
          myebp, myebp[1], myebp[0]);
  for (i = 0; i < 3; i++) fprintf(stderr, "  arg[%d] = 0x%08x\n", i, myebp[i+2]);
 }
#endif
  for(i = 0; i < NUM_REGS; i++)
    a->regs[i] = NULL;
  callerebp = *(Cmm_Word *)a->vfpx;
#if 0
  fprintf(stderr, "walked to caller %%ebp == 0x%08x\n", callerebp);
#endif
  if (callerebp == 0 || !reasonable((void*)callerebp) || a->u.cwalk.tries++ > 20) {
#if 0
    fprintf(stderr, "finished C walk with callerebp = 0x%08x, tries = %d\n",
            (unsigned)callerebp, a->u.cwalk.tries);
#endif
    return 0;
  }
  ra = ((Cmm_Codeptr *)a->vfpx)[1];
  entry = Cmm_lookup_entry(ra);
  if (entry) {
    a->rtdatax = entry;
    a->pc = ra;  /* probably irrelevant */
    a->vfpx +=
      4 + Cmm_as_offset(entry->overflow_size) - Cmm_as_offset(entry->frame_size);
    a->methods = Cmm_cmm_frame_methods;
  } else {
    a->vfpx = (char *)callerebp;
    a->pc   = ra;
  }
  return 1;
}
