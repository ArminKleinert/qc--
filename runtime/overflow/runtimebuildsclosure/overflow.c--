/*
 * Daniel J. Peng
 * overflowhandler.c--
 *
 * This file implements an overflow handler in pure C--.
 *
 * Here is the high-level overview of what happens when a stack limit check
 * fails.
 *
 * 1) The function checks the stack limit and realizes it has insufficient
 * stack space.
 *
 * 2) It cuts to the overflow handler, passing a recovery continuation, the
 * size of the closure required to reinvoke the function, and a function that
 * invokes the closure (the closure-invocation function).
 *
 * ....
 *
 * 5) The function runs.
 *
 * 6) The function returns to the closure-invocation function.
 *
 * 7) The closure-invocation function cuts to the return continuation on the
 * original stack with the return values.
 *
 * 8) The return continuation returns those values to the calling function.
 *
 * Note that the recovery continuation, the return continuation, and the
 * closure-invocation function must be customized for the types and numbers of
 * the arguments and return values.
 */
 
target byteorder little;

import bits32 malloc;
import bits32 Cmm_CreateThread;

import bits32 getspan;
import bits32 getlocal;

export bits32 get_overflow_handler_on_new_stack;

const SpanArgs = 1;
const SpanRets = 2;
const SpanFP = 3;

get_overflow_handler_on_this_stack(bits32 k) {
/* get_overflow_handler_on_this_stack cuts to k with one argument:
 * an overflowhandler continuation.
 *
 * k should be on a different stack.  Otherwise, it is an unchecked
 * runtime error to cut to the overflowhandler, since this frame
 * would promptly die.
 */
  bits32 returns_to, closure_invoke_function, closure_size, body;

  cut to k(overflowhandler) also cuts to overflowhandler;

continuation overflowhandler(returns_to, closure_invoke_function, body):
  bits32 newstack, num_args, num_rets, closure, fp, i, temp;

  num_args = foreign "C" getspan(returns_to, SpanArgs);
  num_rets = foreign "C" getspan(returns_to, SpanRets);
  fp = foreign "C" getspan(returns_to, SpanFP);

  closure = foreign "C" malloc(4096);
  bits32[closure] = returns_to;
  bits32[closure + 4] = fp;
  
  /* for(i = 0; i < num_args; i++) { closure[2+i] = getlocal(body, i); } */
  i = 0;
loop:
  temp = foreign "C" getlocal(body, i);
  bits32[closure + 4 * (2 + i)] = bits32[temp];
  i = i + 1;
  if (i < num_args) {
    goto loop;
  }
  
  closure_size = 4 * (1 /* return continuation */
                      + 1 /* function pointer */
		      + num_args);
  newstack = closure + closure_size;
  k = foreign "C" Cmm_CreateThread(closure_invoke_function, closure, newstack, 4096-closure_size);
  cut to k() also cuts to overflowhandler;
}

get_overflow_handler_on_new_stack() {
/*
 * get_overflow_handler_on_new_stack returns an overflowhandler
 * continuation on a new stack.
 */
  bits32 newstack, overflow, overflowhandler;

  newstack = foreign "C" malloc(4096);
  overflow = foreign "C" Cmm_CreateThread(get_overflow_handler_on_this_stack, k, newstack, 4096);
  cut to overflow() also cuts to k;

continuation k(overflowhandler):
  return (overflowhandler);
}

