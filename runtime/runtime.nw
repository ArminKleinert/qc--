% -*- mode: Noweb; noweb-code-mode: c-mode -*-
% $Id$

% ---------------------------------------------------------------------------
\section{QC-- Runtime Public Interface}
% ---------------------------------------------------------------------------
For now, we are ignoring threads, and a number of interface functions.
<<qc--runtime.h>>=
#ifndef QCMM_RUNTIME_H
#define QCMM_RUNTIME_H

/* In future, these defines will come out of the compiler.
   Please ignore this embarrassing hack -PG
 */
#define WORDSIZE 4
#define NUM_REGS 12
#define ESP 8 // r[4]
#define EBP 9 // r[5]
#define PC  0 // c[0]

<<data structures>>
<<public functions>>
#endif /* QCMM_RUNTIME_H */
@
The data structures used by the runtime system are considered private.
Their representation is exposed to clients so they can allocate the
correct amount of space for them.
<<data structures>>=
typedef unsigned  Cmm_Word;
typedef void*     Cmm_Dataptr;
typedef void    (*Cmm_Codeptr)();


/* The cmm_cont and cmm_activation structures should be considered private---
   it is an unchecked run-time error to read or write any field */
typedef struct cmm_cont {
  Cmm_Codeptr pc;
  Cmm_Word*   sp;
} Cmm_Cont;

typedef struct cmm_activation {
  Cmm_Word*   vfp;
  Cmm_Codeptr pc;
  Cmm_Word*   unwind_sp;
  Cmm_Dataptr rtdata;
  Cmm_Cont    unwind_cont;
  Cmm_Word*   regs[NUM_REGS];
} Cmm_Activation;
@ 
Functions for walking the stack.
<<public functions>>=
Cmm_Activation Cmm_YoungestActivation (const Cmm_Cont *t);
int            Cmm_isOldestActivation (const Cmm_Activation *a);
Cmm_Activation Cmm_NextActivation     (const Cmm_Activation *a);
int            Cmm_ChangeActivation   (Cmm_Activation *a);
Cmm_Cont*      Cmm_MakeUnwindCont     (Cmm_Activation *a, Cmm_Word index, ...);
<<public functions>>=
Cmm_Dataptr Cmm_GetDescriptor(const Cmm_Activation *a, Cmm_Word token);
@ 
Functions for finding local variables.
<<public functions>>=
void     Cmm_LocalVarWritten  (const Cmm_Activation *a, unsigned n);
unsigned Cmm_LocalVarCount    (const Cmm_Activation *a);
void*    Cmm_FindLocalVar     (const Cmm_Activation *a, unsigned n);
void*    Cmm_FindDeadLocalVar (const Cmm_Activation *a, unsigned n);
void*    Cmm_FindStackLabel   (const Cmm_Activation *a, unsigned n);

void     Cmm_CutTo            (const Cmm_Cont *k);
@ 
<<public functions>>=
Cmm_Cont* Cmm_CreateThread(Cmm_Codeptr f, Cmm_Dataptr x, void *s, unsigned n);
@ 
These functions are currently unimplemented.
<<unimplemented public functions>>=
void*    Cmm_FindGlobalVar (int n);
@ 
% ---------------------------------------------------------------------------
\section{Walking the stack}
% ---------------------------------------------------------------------------
This implementation assumes that a [[C--]] thread can only be
suspended at a continuation. Particularly, this means we do not expect
that the runtime system will be entered in response to an interrupt or
some other method that preempts the [[C--]] thread at an arbitrary
point.

Walking the stack always begins at a continuation. A [[C--]]
continuation contains the program counter and stack pointer at the
point of return to the continuation. From this an initial virtual
frame pointer (vfp) can be derived. The process of walking the stack
involves computing the vfp of each caller, and tracking the locations
of all saved registers along the way.

In order to compute the virtual frame pointer for an activation, the
runtime system needs to know the frame size at each call site and
continuation in the [[C--]] program. In addition, the runtime system
needs to know the locations of caller and callee saved registers.
Happily, for [[C--]] functions, all of this information is emitted by
the [[C--]] compiler as part of the runtime data. Unhappily, none of
this information is available for non-[[C--]] compilers, and compiler
specific techniques must be used to skip over unknown areas of the
stack.

This file contains all of the general stack walking code including all
of the code for handling [[C--]] functions. Compiler specific code is
contained in separate files -- one for each compiler supported. The
compiler specific files must export the function
[[walk_foreign_frames]], which takes as arguments the current frame
pointer, and a list of register values for the current frame. This
function should return a new frame pointer, or [[NULL]] on failure.
<<external functions>>=
extern Cmm_Word*
walk_foreign_frames(Cmm_Word* fp, Cmm_Word* const* regs);
@
The runtime system can begin walking a call stack at a [[C--]]
continuation. The youngest activation is constructed by looking up the
runtime data associated with the given continuation. It is important
to note that none of the runtime functions may allocate memory.
Because of this, the initial activation record is returned by value
which forces the caller to allocate space for it.

SOMETHING MUST BE DONE TO ENSURE CORRECTNESS FOR A CONTINUATION THAT
REPRESENTS A NEWLY CREATED STACK.  
THE CHOICES WOULD BE TO TREAT THAT PC SPECIALLY HERE OR TO SYNTHESIZE
RUNTIMEDATA STRUCTURES FOR IT.
<<public function implementations>>=
Cmm_Activation
Cmm_YoungestActivation(const Cmm_Cont* t) {
  int i;
  Cmm_Activation a;
  pc_map_entry* entry = lookup_entry_linear(t->pc);
  assert(entry);

  //print_stack(t->sp);

  a.vfp = (Cmm_Word*)((int)t->sp - decode_offset(entry->frame_size));
  a.pc = t->pc;
  a.rtdata = (void*)entry;
  for(i = 0; i < NUM_REGS; i++) {
    a.regs[i] = NULL;
  }
  return a;
}
@ 
The main function for walking the stack is [[Cmm_NextActivation]].
Given an activation, [[a]], we start searching the stack at the frame
pointer provided in [[a]]. We get the caller and try to lookup an
entry for that address in the PC map. If the caller is not in the PC
map, then we can try to skip past the unknown frame using
[[walk_foreign_frames]]. If a new activation is found, a new
activation record is populated and returned. Otherwise [[na.fp]] is
set to zero to indicate failure.
<<public function implementations>>=
Cmm_Activation
Cmm_NextActivation(const Cmm_Activation *a) {
  Cmm_Word* fp;
  Cmm_Word* caller;
  Cmm_Activation na;
  pc_map_entry* entry;
  pc_map_entry* old_entry;
  int foreign = 0;
  int i;

  assert(a && a->vfp);
  fp = a->vfp;
  update_saved_regs(&na, a);
  //print_stack(fp);

  entry = (pc_map_entry*)a->rtdata;
  caller = (Cmm_Word*)((int)a->vfp + decode_offset((unsigned)entry->return_address));
  entry = lookup_entry_linear((Cmm_Codeptr)*caller);
          
  if (!entry) {
    foreign = 1;
    fp = walk_foreign_frames(fp, na.regs);
    if (fp) {
      caller = (Cmm_Word*)(fp);
      entry = lookup_entry_linear((Cmm_Codeptr)*caller);
    }
  }

  if (entry) {
    old_entry = (pc_map_entry*)a->rtdata;
    na.vfp = (Cmm_Word*)((int)fp - decode_offset(entry->frame_size)
                                 + decode_offset(old_entry->overflow_size));

    na.pc = (Cmm_Codeptr)*caller;
    na.rtdata = (void*)entry;
    /* The registers were already updated above, but after a foreign walk,
       we no longer believe them. */
    if(foreign) {
      for(i = 0; i < NUM_REGS; i++) {
        na.regs[i] = NULL;
      }
    }
  } else {
    na.vfp = 0; // indicates failure
  }
  return na;
}
@ 
The oldest activations are determined differently for general [[C--]]
stacks than for the system stack. Finding the top of the system stack
may differ for different environments. Currently, this function
returns 0, and the end of the stack is detected by a failure of
[[Cmm_NextActivation]].
THIS LOOKS JUST A LITTLE BOGUS, GUYS...
<<public function implementations>>=
int
Cmm_isOldestActivation(const Cmm_Activation *a) {
  return (a->pc == Cmm_start_thread_helper) ||
         0;
}
@ 
The [[Cmm_ChangeActivation]] is provided for convenience.
<<public function implementations>>=
int
Cmm_ChangeActivation(Cmm_Activation *a) {
  if (Cmm_isOldestActivation(a)) {
    return 0;
  } else {
    *a = Cmm_NextActivation(a);
    return (a->vfp != 0);
  }
}
@ 
We import the assembly code that restores the registers and cuts to the unwind entry
point.
<<public function implementations>>=
extern void (*__cmm_unwindcont)();
Cmm_Cont* Cmm_MakeUnwindCont(Cmm_Activation *a, Cmm_Word index, ...) {
  int i;
  int num_conts;
  Cmm_Word *conts;
  Cmm_Word *var;
  Cmm_Word *unwind_pc;
  Cmm_Word *unwind_sp;
  int offset;
  int varnum;
  int vartype;
  va_list ap;

  pc_map_entry* entry = (pc_map_entry*)a->rtdata;
  assert(entry);
  conts = continuations(entry);
  num_conts = decode_offset(*conts);

  if(index >= num_conts) {
    fprintf(stderr, "Cmm_MakeUnwindCont called with out-of-bounds index %d\n", index);
    assert(0);
  }

  offset = decode_offset(*(conts + 1 + index));
  var = conts + offset;
  va_start(ap, index);
  while(*var) {
    varnum  = decode_offset(*var);
    vartype = decode_offset(*(var+1));

    <<based on [[vartype]], assign to local variable [[varnum]] from [[ap]]>>
    Cmm_LocalVarWritten(a, varnum);
    var = var + 2;
  }
  va_end(ap);

  unwind_pc = var + 1;
  unwind_sp = var + 2;

  /* We initialize unknown registers to a bogus (but clearly live) address:
     that of the activation. Otherwise, they would dereference 0. */
  for(i = 0; i < NUM_REGS; i++) {
    if(a->regs[i] == NULL) {
      a->regs[i] = (Cmm_Word *)a;
    }
  }

  /* Users are not allowed to reuse space in the activation, so we can set the PC
     and ESP to the continuation's entry point and stack pointer. */
  a->regs[PC]  = unwind_pc;
  a->unwind_sp = (Cmm_Word *) ((int) a->vfp + decode_offset(*unwind_sp));
  a->regs[ESP] = (Cmm_Word *)&a->unwind_sp;

  a->unwind_cont.pc = (Cmm_Codeptr) &__cmm_unwindcont;
  a->unwind_cont.sp = (Cmm_Word *) a->regs;

  return(&a->unwind_cont);
}
@ 
Because passing to a varargs function involves implicit promotions, we
do the promotions that are needed.
The [[L]] argument is the type used internally; the [[R]]~version is
the same type as promoted for passing to a varargs function.
<<based on [[vartype]], assign to local variable [[varnum]] from [[ap]]>>=
#define ASSIGN(L,R) *(L*) Cmm_FindLocalVar(a, varnum) = (L) va_arg(ap, R)
switch(vartype) {
  case CHAR:             ASSIGN (char,               int);                break;
  case DOUBLE:           ASSIGN (double,             double);             break;
  case FLOAT:            ASSIGN (float,              double);             break;
  case INT:              ASSIGN (int,                int);                break;
  case LONGDOUBLE:       ASSIGN (long double,        long double);        break;
  case LONGINT:          ASSIGN (long int,           long int);           break;
  case LONGLONGINT:      ASSIGN (long long           int, long long int); break;
  case SHORT:            ASSIGN (short,              int);                break;
  case SIGNEDCHAR:       ASSIGN (signed char,        int);                break;
  case UNSIGNEDCHAR:     ASSIGN (unsigned char,      int);                break;
  case UNSIGNEDLONG:     ASSIGN (unsigned long,      unsigned long);      break;
  case UNSIGNEDSHORT:    ASSIGN (unsigned short,     int);                break;
  case UNSIGNEDINT:      ASSIGN (unsigned int,       unsigned int);       break;
  case UNSIGNEDLONGLONG: ASSIGN (unsigned long long, unsigned long long); break;
  case ADDRESS:          ASSIGN (void *,             void *);             break;
  default: assert(0);
}
@
% ---------------------------------------------------------------------------
\section{Span Data}
% ---------------------------------------------------------------------------
For any activation, the client may ask for the inner-most enclosing
span associated with a given token. The user spans are contained in the
runtime data emitted by the compiler. Tokens must be integers greater
than or equal to zero. A table of descriptors is stored in the pc map
entry immediately following the locals data. Using the activation
record, the table of descriptors is looked up, and the appropriate
entry returned.
<<public function implementations>>=
Cmm_Dataptr
Cmm_GetDescriptor(const Cmm_Activation *a, Cmm_Word token) {
  int num_spans;
  Cmm_Word* descs;
  pc_map_entry* entry = (pc_map_entry*)a->rtdata;
  assert(entry);

  num_spans = decode_offset(entry->num_spans);
  if(token < num_spans) {
    descs = spans(entry);
    return (Cmm_Dataptr)descs[token];
  }
  return 0;
}
@
% ---------------------------------------------------------------------------
\section{Accessing Local Variables}
% ---------------------------------------------------------------------------
Local variables for an activation can can be found either on the
stack, or in registers. The location of parameters is computed using
information generated by the [[C--]] compiler. Each [[C--]] call site
has associated with it the number of locals, and an array containing
information about each local. If a local lives on the stack, an offset
from the frame pointer is given. If a local is in a register, then the
register number is given. The number of registers, and their indexes
are architecture dependent.

In addition to information about locals, each call site has
information about saved registers at the time of the call. If a
register has been saved on the stack, then the offset from the frame
pointer is given. Otherwise, a zero indicates that the register has
not been saved by this activation.

As new activations are created during a walk of the stack, the
locations of saved registers are recorded within the activations. The
locations of all saved registers for an activation can be computed
using information in the pc map table along with the previous
activation.
<<private functions>>=
void
update_saved_regs(Cmm_Activation* new, const Cmm_Activation* prev) {
  int i;
  int r = decode_offset(((pc_map_entry*)(prev->rtdata))->num_registers);
  Cmm_Word* regs = registers(prev->rtdata);

  for (i = 0; i < NUM_REGS; i++) {
      new->regs[i] = prev->regs[i];
  }
  
  for (i = 0; i < r; i+=2) {
    if (regs[i] == regs[i+1]) continue;
    new->regs[decode_reg(regs[i])] =
      (Cmm_Word*)((int)prev->vfp + decode_offset(regs[i + 1]));
  }
}
@ 
Clients of the runtime system must report when a local variable is written.
<<public function implementations>>=
void Cmm_LocalVarWritten(const Cmm_Activation *a, unsigned n) {
  return;
}
@
Clients of the runtime system can ask for the number of locals for a
given activation. This information is stored in the activation
structure.
<<public function implementations>>=
unsigned
Cmm_LocalVarCount(const Cmm_Activation *a) {
  pc_map_entry* entry = (pc_map_entry*)a->rtdata;
  assert(a);
  assert(a->rtdata);
  return decode_offset(entry->num_locals);
}
@ 
Local variables are asked for by index. A pointer is returned to the
local by first looking it up in the array of locals for this
activation. If the local is in a register, a pointer into the saved
register is returned. Otherwise, a pointer into the stack where the
register is saved is returned.
<<public function implementations>>=
void*
Cmm_FindLocalVar(const Cmm_Activation *a, unsigned n) {
  int local, reg;
  pc_map_entry* entry = (pc_map_entry*)a->rtdata;
  if (n >= decode_offset(entry->num_locals)) {
    fprintf(stderr, "local var index out of range");
    assert(0);
  }
  local = (locals(entry))[n];
  if (0 != (reg = decode_reg(local))) {
    assert(a);
    assert(a->regs);
    if(a->regs[reg] == NULL) {
      fprintf(stderr, "Run-Time System Error: Tried to find a local variable in a "
                      "register that could not be recovered. Most likely cause: "
                      "calling a C function in your run-time without using a calling "
                      "convention that kills all the callee-save registers "
                      "(e.g. \"paranoid C\").\n");
      assert(0);
    }
    return a->regs[reg];
  }
  else if (!is_dead(local)) {
    return (void*)((int)a->vfp + decode_offset(local));
  }
  return 0;
}
@ 
In the current implementation it is not possible to find the location
of a dead var.
<<public function implementations>>=
void*
Cmm_FindDeadLocalVar(const Cmm_Activation *a, unsigned n) {
  return Cmm_FindLocalVar(a, n);
}
@
Stack data is stored in a table per procedure. Each PC map entry links
to the correct stack data table.
<<public function implementations>>=
void*
Cmm_FindStackLabel(const Cmm_Activation *a, unsigned n) {
  pc_map_entry* entry = (pc_map_entry*)a->rtdata;
  Cmm_Word* sdt = entry->stackdata_table;
  assert(sdt);

  if (n >= sdt[0]) {
    fprintf(stderr, "Stack data index %d out of range [0..%d)\n", n, sdt[0]);
    assert(0);
  }

  return (void*)((int)a->vfp + decode_offset(sdt[n+1]));
}
@ 
% ---------------------------------------------------------------------------
stitch things together.
<<runtime.c>>=
#include "qc--runtime.h"
#include "pcmap.h"
#include <assert.h>
#include <stdio.h>
#include <stdarg.h>
<<external functions>>
<<private functions>>
<<public function implementations>>
<<private functions>>=
void print_stack(int* fp) {
  int a;
  fprintf(stderr, "stack %X\n", (unsigned)fp);
  for (a = 35; a > -7; --a) {
    fprintf(stderr, "%d: %X: %x\n", a, (unsigned)fp+a, fp[a]);
  }
}
@ 
\section{{\PAL} runtime}

<<cut.c-->>=
target byteorder little;
export Cmm_CutTo;
foreign "C" Cmm_CutTo(bits32 k) {
  cut to k();
}
@ 
\subsection{Threads}

<<external functions>>=
extern void Cmm_start_thread_helper();
<<runtime.c>>=
extern int Cmm_stack_growth; /* to be generated by the compiler */

Cmm_Cont* Cmm_CreateThread(Cmm_Codeptr f, Cmm_Dataptr x, void *s, unsigned n) {
  char *stack = s;
  char *young, *old, *vfp;
  Cmm_Cont *k;
  if (Cmm_stack_growth < 0) {
    <<set up stack for growth downward>>
    return k;
  } else {
    <<set up stack for growth upward>>
    return k;
  }
}
@ 
Here is the layout of a thread with a down-going stack:
\begin{center}
\unitlength=15pt
\def\~{\hspace*{15pt}}
\begin{picture}(22,8)(-14,-5)
  \put(-5,1.5){\framebox(13,1.5)[l]{\~[[k->pc = Cmm_start_thread_helper]]}}
  \put(-5,0){\framebox(13,1.5)[l]{\~[[k->sp = vfp]]}}
  \put(-5,-1.5){\framebox(13,1.5)[l]{\~[[x]]}}
  \put(-5,-3.0){\framebox(13,1.5)[l]{\~[[f]]}}
  \put(-5,-2.7){\makebox(0,0)[r]{[[vfp]]\raisebox{0.5ex}{\vector(1,0){1}}}}
  \put(-5,0.3){\makebox(0,0)[r]{result of [[Cmm_CreateThread]]\raisebox{0.5ex}{\vector(1,0){1}}}}
  \put(-5,-4.5){\makebox(13,2.0)[l]{\vrule\hfill$\vdots$\hfill\vrule}}
\end{picture}
\end{center}
I set up the stack pointer to point to the first empty word.
<<set up stack for growth downward>>=
young = stack;
old   = stack + n;
k = (Cmm_Cont *) old;
k--;
k->sp = (Cmm_Word*) (vfp = old - sizeof(*k) - sizeof(f) - sizeof(x));
k->pc = Cmm_start_thread_helper;
*(Cmm_Codeptr*)vfp = f;
vfp += sizeof(f);
*(Cmm_Dataptr*)vfp = x;
<<set up stack for growth upward>>=
old   = stack;
young = stack + n;
k = (Cmm_Cont *) old;
k++;
k->sp = (Cmm_Word*) (vfp = old + sizeof(*k) + sizeof(f) + sizeof(x));
k->pc = Cmm_start_thread_helper;
*(Cmm_Codeptr*)vfp = f;
vfp -= sizeof(f);
*(Cmm_Dataptr*)vfp = x;
@
<<thread.c-->>=
target byteorder little;
export Cmm_start_thread_helper, Cmm_thread_helper_fence;
import write, abort;
section "text" {
  foreign "C-- thread" Cmm_start_thread_helper(bits32 f, bits32 x) {  
    f(x) also aborts;
    foreign "C" write(2, "address" msg, msg_end - msg);
    foreign "C" abort() never returns;
  }
  Cmm_thread_helper_fence:
}
section "data" {
  msg: bits8[] "fatal C-- error: function passed to Cmm_CreateStack returned!\n";
  msg_end:
}
@ 
The following should be generated by a special call to Quick~{\PAL}.
<<runtime.c>>=
int Cmm_stack_growth = -1;
