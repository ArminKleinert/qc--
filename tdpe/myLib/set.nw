% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>
% l2h macro exfile 1 <a href="#$1"><tt>#1</tt></a>

\input{../macros.tex}

\section{A simple implementation of sets}

We will most deffinitiely need a faster implementation. Try to think how
to implement structural comparisons.

Substraction does not raise exception when failed. Use member first.

<<set.mli>>=

module type COMPTYPE =
  sig
    type t
    val eq : t -> t -> bool
  end
module type SET =
  sig
    type set
    type t
          
    val eq : t -> t -> bool
    val insert : t -> set -> set
    val substract : t -> set -> set
    val member : t -> set -> set
        
  end
module MakeSet (module M:COMPTYPE) : SET with type t = M.t
      
@ \section{Implementation}

<<set.ml>>=

module type COMPTYPE =
  sig
    type t
    val eq : t -> t -> bool
  end

module type SET =
  sig
    type set
    type t
          
    val eq : t -> t -> bool
    val insert : t -> set -> set
    val substract : t -> set -> set

    val empty : set
  end

module MakeSet(M:COMPTYPE) : SET with type t = M.t =
  struct
    type set = M.t list
    type t = M.t
          
    let eq = M.eq

    let empty = []

    let rec insert e set =
      match set with
        [] ->  [e]
      | (e1::xs) ->
        if eq e e1 then set
        else (e1::(insert e xs))
            
    let rec substract e set = 
      match set with
        [] ->  []
      | (e1::xs) ->
        if eq e e1 then xs
        else (e1::(substract e xs))

    let rec member e set = 
      match set with
        [] ->  false
      | (e1::xs) ->
        if eq e e1 then true
        else member e xs
  end

