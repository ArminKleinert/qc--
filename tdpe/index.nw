% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>
% l2h macro exfile 1 <a href="#$1"><tt>#1</tt></a>

\input{macros.tex}

\section{Type-directed partial evaluation of machine-level optimization}

This program implements type-directed partial evaluation of the
machine-level optimization layer of the [[qc--]] compiler.

At the moment, the dependency hierarchy of the progam may be split into
several distinctive sections. They are illustrated in a bottom-up
fashion.

\section{A utility library}
The utility library in \module{myLib/index} defines a few functions for
side-effecting list traversal, an interface to integer mutable cells,
and a few useful functions associated with the [[option]] type
constructor.


\section{Type-directed partial evaluation (TDPE) library}
The TDPE library implements TDPE for a core functional language, and
allows extension of the language to other type constructors and value
constructors. For details, read the documentation in
\module{tdpeLib/index}

\section{Residualizing instantiations of base types}
After having defined the type of residual expressions, we can implement
the residualizing interpretation of the base types and free constants in
our programs. Part of them are found in the [[qc--]] source code:
\begin{itemize}
\item OCaml base types, conversions, basic operators: \module{../src/base}
\item The type of bits and creation functions: \module{../src/bits}
\item Operations with bits: \module{../src/bitops}
\end{itemize}
The remaining part is provided in a residualizing
library :\module{residualInt/index}


\section{RTLs}
Register transfer lists are the intermediate representation in the
[[qc--]] compiler. We reuse the definition and utility functions:
\module{../src/rtl} and \module{../src/rtlutil}

\section{Machine-dependent code}
Machine dependent code is generated by the toolkit. Its structure and
functionality shoud be described elswhere. Maybe have a look at
\module{layout}.

\section{Syntactic representation of machine instructions}
Again, this should be documented elswhere.

\section{Machine-independent code}
Machine independent code gets specialized by TDPE. There are several
modules:
\begin{itemize}
\item Forward substitution: \module{rtlSubst}.
\item Forward substitution revised: \module{rtlSubst2}.
\item Instruction merging based on liveness information:
  \module{rtlMerge}.
\item Generic walker over read/written locations in machine instructions
  (from [[qc--]]): \module{../src/rtlutil}
\item Set-based walker of read/written locations in machine
  instructions \module{readWrite}
\end{itemize}

\section{Machine-dependent optimization}
The functions which are the targets of specialization by TDPE are
defined in the module \module{generic}.

\section{Specialization instances}
Each target of specialization is defined as an instance of a generic
specialization scheme in \module{spec}.

\section{The command-line interface}
The top level of the code is, of course, the module \module{main}.

@
