
\section{Intermediate code}

% l2h substitution PAL C--

\subsection{Intermediate-code nodes}

The design of the intermediate form is governed by the following
desiderata:
\begin{itemize}
\item
It should be relatively easy to assign it a formal semantics, viz, the
semantics in ``Exceptions need not be exceptional.''
\item
It should be straightforward to translate to it from abstract syntax.
\item
It should be straightforward to generate simple machine code, using
primarily local strategies.
\item
It should be straightforward to generate tables that will support the
{\PAL} run-time system.
\end{itemize}

The [[IRNode]] module defines only the nodes used to represent
procedures.
These, together with other data types, may be stitched together to
represent and entire {\PAL} module.
We assume that the global context representing the module provides
\begin{itemize}
\item 
The {\PAL} [[global]] declarations in the context of which the
module is compiled.
\item
A list of all the IR~nodes used to represent procedures in the
module. 
This list is used to map from a ``node id'' to a node.
\item
A mapping from label and procedure names to IR~nodes.
\end{itemize}
<<irnode.asdl>>=
module IRNode (imports RTL) {
  <<ASDL definitions for nodes of abstract \PAL>>
}
@ 
Because ASDL handles trees, not graphs, we represent a graph as a
list of nodes, and we refer to nodes using integer node ids.
Node ids are intended to be unique per module.
<<ASDL definitions for nodes of abstract \PAL>>=
graph  = (node*) -- node ids are indexes into this list
nodeid = Node (int)
@
Flow-graph nodes are taken from Table 2 of 
the paper ``Exceptions Need Not Be Exceptional.''
<<ASDL definitions for nodes of abstract \PAL>>=
node = Entry (continuation*, nodeid next)
     | Exit
     | Copyin  (formal*, copy_context, string convention, nodeid next)
     | Copyout (actual*, copy_context, string convention, nodeid next)
     | Calleesaves (variable*, nodeid next)
     | Assign (RTL.rtl, nodeid next)
     | Branch (RTL.exp, nodeid true, nodeid false) -- exp is condition
     | Goto (RTL.exp, nodeid* targets)             -- exp is address of target
     | Call (RTL.exp, contbund)
     | Jump (RTL.exp, nodeid last)
     | Invoke (RTL.exp, nodeid last)
     | Yield (RTL.exp, contbund)
attributes (keyvalue* enclosing_spans) -- used for spans
keyvalue = (int token, RTL.exp value)  -- value is link-time constant
@ On entry to a code generator,
the RTL expressions should use no space other than the [[m]]~space (memory); 
other spaces, including hardware registers, are reserved for the
private use of the code generator.
@
The list of continuations in the entry node is used to set up the
continuation values.
We need to know a continuation's name, and the node to which it refers.
<<ASDL definitions for nodes of abstract \PAL>>=
continuation = (string, nodeid)
@
The copy nodes ([[Copyin]] for formals and [[Copyout]] for actuals) 
are used in three different contexts.  The contexts must be
identified, because each context is likely to have a different
value-passing convention.
<<ASDL definitions for nodes of abstract \PAL>>=
copy_context = ProcedureParameters    -- used in call, jump, prologue
             | ProcedureResults       -- used in call, return
             | ContinuationParameters -- used in invoke, continuation
@ A formal or actual carries a type and an optional hint.
<<ASDL definitions for nodes of abstract \PAL>>=
formal = (variable, RTL.ty, hint?) 
actual = (RTL.exp,  RTL.ty, hint?)
@ Note that the type is an RTL type; in particular, the distinction
between [[bits]]$k$ and [[float]]$k$ has been folded into the hints,
according to the following table:
\begin{quote}
\begin{tabular}{|l|l||l|l|}
\hline
\multicolumn2{|c||}{Source}&\multicolumn2{c|}{Intermediate}\\
Type&Hint&Type&Hint\\
\hline
[[bits]]$k$& --- & $k$ & --- \\
\hline
[[bits]]$k$& \emph h & $k$ & \emph h \\
\hline
[[float]]$k$& --- & $k$ & \texttt{float} \\
\hline
[[float]]$k$& \emph  h & $k$ & \texttt{float-} \emph h \\
\hline
\end{tabular}
\end{quote}
<<ASDL definitions for nodes of abstract \PAL>>=
hint = (string)
@ 
Variables stand for locations.  On entry, they must have been created
with the [[RTL.VAR]] constructor.
<<ASDL definitions for nodes of abstract \PAL>>=
variable = (RTL.location) -- must be VAR constructor on entry
@
The continuation bundle attached to a call shows the possible
continuations: normal, cuts, unwinds, and returns.
<<ASDL definitions for nodes of abstract \PAL>>=
contbund = 
  (nodeid normal, nodeid* cuts, nodeid* unwinds, nodeid* returns, nodeid? aborts)
@ Variables survive calls, but memory locations need not.
Since these are the only locations used by the elaborator, that's all
we need say about the semantics, but we will add that we expect the
code generator will establish, for each new storage space, whether the
locations in that space may be mutated by calls.
@
To compile a procedure, we need its name and the convention for
mangling the name.
For convenience in supporting the run-time procedure [[FindVar]], we
also require the names and types of its formal parameters and local variables,
in declaration order.
(We don't need the calling convention as it's embodied in the copy
nodes in the flow graph.)
<<ASDL definitions for nodes of abstract \PAL>>=
proc = (string name, string? mangling, var_info* formals, var_info* locals)
var_info = (string name, RTL.ty)
@


\subsection{A program in intermediate form}

Although the AST and IR-node representations are independent, the full
IR representation draws from both.
<<ir.asdl>>=
module IR (imports IRNode imports AST) {
  prog = ( IRNode.graph
         , AST.global_info* globals
         , AST.const_name procedures
         , label_pair* labels_and_procedures
         , seg* segments
         )
  label_pair = (AST.const_name, IRNode.nodeid)
  seg = (AST.segment_name, item*)
  item = Datum (AST.datum)
       | Proc  (AST.const_name procedure)
}
