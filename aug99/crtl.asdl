 --#line 17 "asdl.nw"
module RTL {
  rtl      = RTL   (guarded*)
  guarded  = GUARD (exp, effect)
  effect   = STORE (location dst, exp src, ty)
           | KILL  (location)
           | KILLALL(space)
  cell     = CELL  (space, exp)
  location = AGG   (aggregation, cell)
           
 --#line 74 "asdl.nw"
| IDENTLOC (identifier)
 --#line 25 "asdl.nw"
                                   
  exp      = CONST (const, ty?)
           | FETCH (location, ty)
           | APP   (operator, exp*)
           
 --#line 72 "asdl.nw"
| IDENT (identifier)
 --#line 29 "asdl.nw"
                                     
  ty = (int)  -- width in bits
  space = (char)
  
  -- these are somewhat arbitrary, since ASDL doesn't have char or boolean types
  -- the claim is these definitions can be overridden using ``views''
  
  char = (int)
  bool = (int)
  
  const = BOOL (bool)
        | INT (int)
        | CHAR (char)
  
  -- an operator is an operator name, possibly specialized to certain widths
  operator = (opname, ty*)
  opname = (identifier) --- totally bogus, but ASDL has no opaque types
  
  aggregation
    = BIG_ENDIAN
    | LITTLE_ENDIAN
    | IDENTITY
    | USER_AGG (identifier)

}
 --#line 78 "asdl.nw"
view SML {
 module RTL <= implementation_prologue 
%%
fun int2bool i = i <> 0
fun bool2int p = if p then 1 else 0
%%
  RTL.char <= { natural_type : Char.char
                wrapper : Char.ord
                unwrapper : Char.chr 
              }
  RTL.bool <= { natural_type : Bool.bool
                wrapper  : bool2int
                unwrapper : int2bool
              }
}
 --#line 102 "asdl.nw"
view SML {
  module RTL <= source_name : CRTL
}
