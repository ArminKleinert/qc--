/*
 * Code to test the parser
 */

pragma line { 1 }
pragma foo { this pragma should be '}' (* skipped *)  by "{" the lexer }
pragma pragma { }

import bits32 putchar, puts, printf;
export cmm_main;
global 
{
    invariant bits16 j "j", k "k";

}

global {}


section "data" 
{

    fstr: 
    bits8[]    "%i\n";
    bits8     { 0 } ;	
       
    cr:
    bits8[]     "\n";
    bits8     { 0 };

}

section "text" 
{
    align 32;

    fact(bits32 n)
    { 
        float64     j ;
        float32     k;

        j, k = foreign "c++" %%cout (j,k) also cuts to foo;

        if foo == bar {
            bar:
            bar:
            bar:

        } else {

            bar:
            ;    
            
        }

        foo, bar, baz, boo = 4+4 , 5+5, 6+6, 3+4*5 ;
        
        continuation mycont (j,k):

        span foo bar {
            j = 0;
            loop:
                j = j+1;
                goto loop targets loop;
                goto loop;

                foreign "c" jump bits32[i+j] (j,k) targets foo,bar;
                foreign "java" (bits32[i]) (j,k) also cuts to foo;
                foreign "c++" %%cout (j,k) also cuts to foo;
            k = 1; 
        }

        cut to mycont ("x" 1+2, "y" 3+2) also aborts;

        foreign "c" return < a / b > (x, y);
        return (x);
    }

    foo()
    { 
    }


    foo(bits8 i, bits8 j)
    { 
        bits32  x;
        bits32  y, z;
        invariant bits32  a, z;
    }
}
