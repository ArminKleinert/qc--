% -*- mode: Noweb; noweb-code-mode: fundamental-mode -*-
% ------------------------------------------------------------------ 
\section{Lua Test Driver}
% ------------------------------------------------------------------ 

This is a lua driver for running the [[qc--]] regression tests. The
driver must be run with a test configuration file. A test driver
configuration file can specify the compiler configuration to use, the
source and results directories, and which source files to use.

% ------------------------------------------------------------------ 
\subsection{Usage}
% ------------------------------------------------------------------ 

The configuration files are lua source files with the extension
[[tst]]. As such, the configuration files must have valid lua syntax.
In addition to the compiler settings, the test files may set the
following test variables:

\begin{itemize}
\item [[Test.verbose]] turn on detailed output.
\item [[Test.results]] directory containing expected results files.
\item [[Test.source]] directory containing source files.
\item [[Test.files]] list of source files to test.
\item [[Test.trust_exe]] trust output of exe over assembly.
\end{itemize}

<<example.tst>>=
-- setup x86 backend with color-graph register allocator
backend = backend or Backend.x86
backend.ralloc = backend.ralloc or Ralloc.color

-- compare results with files in x86
Test.results = Test.results or "x86"

-- source files live in src directory
Test.source  = "src"
Test.files = { "add.c--"
             , "bits-bug.c--"
             , "cut.c--"
             , "hello.c--"
             , "ralloc-000.c--"
             , "rnd2.c--"
             , "x86-000.c--"
             , "x86-001.c--"
             }

@ To use this test configuration file, execute [[qc--]] with the test
driver.
<<run output>>=
# ../bin/qc-- testdrv.lua example.tst
# Running Regression Tests 6/23/2003
../bin/qc-- -v testdrv.lua example.tst src/add.c--.test  # FAILED { .s } differ
1 errors detected.
@
In the case of errors, a single line will be printed that can be
executed to get more detailed information on the error.
@
The expected outputs can also be updated using the test driver.
<<run output>>=
# ../bin/qc-- -v testdrv.lua example.tst src/hello.c--.record
# Running Regression Tests 6/23/2003
x86/hello.s     has not changed
x86/hello.s1    has changed             !! updating !!
x86/hello.s2    has not changed
x86/hello.1     has not changed
x86/hello.2     has not changed
@ 
Additional information can be supplied along with the name of the
source file in the form of a table. This table can contain the
following values.
\begin{itemize}
\item [[name]] a name for this test case.
\item [[source]] (required) source file as above.
\item [[stdin]] standard input file.
\item [[stdout]] expected standard output file.
\item [[stderr]] expected standard error file.
\item [[asm]] assembly output file.
\item [[asmout]] expected compiler standard output file.
\item [[asmerr]] expected compiler standard error file.
\item [[other]] additional sources to link with.
\end{itemize}
All of the table entries are optional except for [[source]]. If a
filename contains a ``/'' then it is considered to be a relative path.
Otherwise, the file is assumed to be in the [[Test.results]]
directory.
<<extended example>>=
Test.files = { "add.c--"
             , { source = "fadd.c--"
               , stdin  = "fadd.0"
               , stdout = "fadd.1"
               , stderr = "fadd.2"
               , asm    = "fadd.s"
               , asmout = "fadd.s1"
               , asmerr = "fadd.s2"
               , other  = "test.c test2.c"
               }
             , { source = "hello.c--"
               , asm    = "add.s"
               , name   = "messed-up"
               }
             }
@ 
% ------------------------------------------------------------------ 
\subsubsection{Error Handling}
% ------------------------------------------------------------------ 
Test configuration files may contain custom error handlers for
specific files or file types. When an error is detected, the test
driver will first look for an error handler associated with the file
that has caused the error. If one is not found, then a handler
associated with the file extension is executed. The test driver
provides default error handlers for all of the known extensions.

The example below adds a special error handler for the asembly output
of the [[add.c--]] source file.
<<example.tst>>=
function Test.on_error["add.s"](expected, output)
  -- provide special processing for detailed output
  print("error in add.c--")
  -- or just call default handler for .s files
  Test.on_error[".s"](expected, output)
end
@ 
% ------------------------------------------------------------------
\section{Driver Implementation}
% ------------------------------------------------------------------
<<testdrv.lua>>=
$debug 1
Test = Test  or {}
Test.errors = 0         -- number of failures found
Test.verbose = nil      -- provide detailed failure info
Test.skip_files = nil   -- skip input source files
Test.trust_exe = nil    -- trust exe output for test status
Test.on_error = {}      -- error handlers
Test.files = {}         -- input source files
Test.tst_file = ""      -- name of config file
-- Test.update = nil       -- update differing files
@ 
Lua doee not have a function to get the number of entries in a table/list.
<<testdrv.lua>>=
function Test.list_len(l)
  local i = 1
  while l[i] do i = i + 1 end
  return i - 1
end
@ 
The status line is printed during a batch process.
In the case of an error, we may need to clear the status line before,
anything else is printed.
<<testdrv.lua>>=
function Test.status_line(i, len)
  local left = format("Processing test %d of %d", i, len)
  local right = format("[ %0.2f %% ]", 100 * (i-1) / len)
  local len = 80 - strlen(left)
  local fmt = format('%%s%%%ds\r', len)
  write(format(fmt, left, right))
end

function Test.clear_status_line()
  if Test.verbose then
    print("") -- for pager programs
  else
    write(format("%-80s\r", ""))
  end
end
@ 
Lua does not have a printf like function.
<<testdrv.lua>>=
function Test.log(...)
  if not Test.verbose then return end
  local i = 2
  local cmd = "\"" .. arg[1] .. "\""
  while arg[i] do
    if type(arg[i]) == "string" then
      cmd = cmd .. format(",\"%s\"", arg[i])
    else
      cmd = cmd .. "," .. arg[i]
    end
    i = i + 1
  end
  cmd = "print(\"## \" .. format(" .. cmd .. "))"
  dostring(cmd)
end
@ 
Lua tmpname places files all around the filesystem.
<<testdrv.lua>>=
function Test.temp_name(ext)
  local name = Caml.Filename.basename(tmpname())
  return Caml.Filename.concat("/tmp", name .. ext)
end
@ 
% -------------------------------------------------------------------
\subsubsection{Error Handlers}
% -------------------------------------------------------------------
<<testdrv.lua>>=
function Test.on_error[".1"](expected, output)
  local cmd = format("diff %s %s", expected, output)
  Test.log(cmd)
  execute(cmd)
end
Test.on_error[".2"] = Test.on_error[".1"]
Test.on_error[".s1"] = Test.on_error[".1"]
Test.on_error[".s2"] = Test.on_error[".1"]

Test.sdiff_options = ''   -- .s files used to get a 'diff -y'
function Test.on_error[".s"](expected, output)
  local cmd = format("diff %s %s %s", Test.sdiff_options, expected, output)
  Test.log(cmd)
  execute(cmd)
end
@ 
This function handles dispatching to the correct error handler.
All errors are reported by calling this function.
<<testdrv.lua>>=
function Test.error(file, expected, actual)
  Test.clear_status_line()
  Test.errors = Test.errors + 1
  local basename = Caml.Filename.basename(expected)
  local ext = Caml.Filename.extension(expected)
  if Test.verbose then
    if Test.on_error[basename] then
      Test.on_error[basename](expected, actual)
    else
      if (Test.on_error[ext]) then
        Test.on_error[ext](expected, actual)
      else
        print(format("FAILED %s\n", expected))
      end
    end
  end
end
@ 
% -------------------------------------------------------------------
\subsubsection{Compile and test functions}
% -------------------------------------------------------------------
In order to catch exceptions from Caml code, we have to write a small
function that will not return nil.
<<testdrv.lua>>=
function Test.translate(f, tab)
  CMD.translate_files(f, tab)
  return 1
end

function Test.compile_file(file)
  local s_file = Test.temp_name(".s")
  local so = s_file .. "1"
  local se = s_file .. "2"

  Test.log("compiling %s -> %s", file, s_file)

  Driver.reinit()
  Options.stop_at(".s")
  Options.globals = 1
  Options.output = s_file

  Util.redirect_stdout(so)
  Util.redirect_stderr(se)
  local status = Util.catch(Test.translate, file, CMD.compilertab)
  Util.redirect_stdout()
  Util.redirect_stderr()

  if not status then
    Test.log("Compilation errors detected")
  end

  return { s_file, so, se }
end
@ 
Call [[cc]] to build a final executable file. Calling the [[qc--]]
compiler may not work correctly if the additional files specified by
the user are handled by a frontend we do not know about.
<<testdrv.lua>>=
-- XXX fix me XXX
function Test.build_exe(inputs, s_file)
  local exe_file = Test.temp_name(".exe")

  local other = ""
  if inputs["other"] then other = inputs["other"] end
  local cmd = format("cc -o %s %s %s", exe_file, s_file, other)

  Test.log(cmd)
  if execute(cmd) ~= 0 then
    return nil
  end
  return exe_file
end
<<testdrv.lua>>=
function Test.run_exe(exe_file, stdin)
  local so = exe_file .. ".1"
  local se = exe_file .. ".2"

  local cmd = format("%s < %s > %s 2> %s", exe_file, stdin, so, se)
  Test.log(cmd)
  execute(cmd)

  return { so, se }
end
@ 
Rename does not work across filesystem boundaries.
<<testdrv.lua>>=
function Test.copy_file(src, dest)
  if not readfrom(src) then return nil end
  if not writeto(dest) then readfrom(); return nil end
  local l = read()
  while l do
    if not write(l .. "\n") then
      readfrom()
      writeto()
      return nil
    end
    l = read() 
  end
  writeto()
  readfrom()
  return 1
end
@ 
The [[check_update_file]] function compares two files. If the files
differ, then either the expected file is updated, or an error message
is generated.
<<testdrv.lua>>=
function Test.check_update_file(inputs, file)
  local  ext = Caml.Filename.extension(file)
  if     ext == ".s"  then exp = inputs["asm"]
  elseif ext == ".s1" then exp = inputs["asmout"]
  elseif ext == ".s2" then exp = inputs["asmerr"]
  elseif ext == ".1"  then exp = inputs["stdout"]
  elseif ext == ".2"  then exp = inputs["stderr"] end
    
  local status = Util.catch(Util.compare_files, exp, file)
  if not status then
    if Test.update then
      print(format("%s \thas changed \t\t!! updating !!", exp))
      if not Test.copy_file(file, exp) then
        print(format(" !! error moving file %s to %s !!", file,  exp))
      end
    else
      Test.log("%s does not match output", exp)
      Test.error(inputs["source"], exp, file)
      inputs["diffs"] = inputs["diffs"] .. " " .. ext
    end
    return 1
  else
    if Test.update then
      print(format("%s \thas not changed", exp))
    else
      Test.log("%s matches output", exp)
    end
  end
  return 0
end
@ 
For a given test case, we first compile the course file down to
assembly language by calling the [[qc--]] compiler. If the assembly
output matches the expected output, then the test is passed. Otherwise
if the [[trust_exe]] flag is set, we build and run the executable and
compare the output to what is expected.

If the expected files are being updated or the [[verbose]] flag is set
then all outputs are generated.
<<testdrv.lua>>=
function Test.run_test_case(inputs)
  local file = inputs["source"]
  local files = Test.compile_file(file)
  if not files then return end

  inputs["diffs"] = ""

  local s_file = files[1]
  local so = files[2]
  local se = files[3]

  local status = Test.check_update_file(inputs, s_file)
               + Test.check_update_file(inputs, so)
               + Test.check_update_file(inputs, se)
  if Test.update or (status > 0 and
                    (Test.trust_exe or Test.verbose))
  then
    local exe_file = Test.build_exe(inputs, s_file)
    if exe_file then
      files = Test.run_exe(exe_file, inputs["stdin"])
      local pso = files[1]
      local pse = files[2]
      local s = Test.check_update_file(inputs, pso)
              + Test.check_update_file(inputs, pse)
      if s == 0  and Test.trust_exe then
        status = 0
      end
      remove(pso)
      remove(pse)
      remove(exe_file)
    end
  end
  remove(s_file)
  remove(so)
  remove(se)

  if inputs["diffs"] ~= "" then
    local msg = format("{%s } differ", inputs["diffs"])
    local stat = "FAILED"
    if status == 0 then stat = "PASSED" end
    if Test.verbose then
      print(format("\n## To update these files {%s } run:",
                   inputs["diffs"]))
      print(format("# ../bin/qc-- testdrv.lua %s %s.record",
                   Test.tst_file, inputs["name"]))
    else
      print(format("../bin/qc-- -v testdrv.lua %s %s.test \t# %s %s",
                   Test.tst_file, inputs["name"], stat, msg))
    end
  end
end
@ 
These two function fill in defaults for any options not specified for
a test case, before running the test case.
<<testdrv.lua>>=
function Test.compute_filename(files, entry, dir, name)
  if not files[entry] then
    files[entry] = Caml.Filename.concat(dir, name)
  else
    if not strfind(files[entry], "/") then
      files[entry] = Caml.Filename.concat(dir, files[entry])
    end
  end
end
<<testdrv.lua>>=
function Test.process_file(files)
  if type(files) == "string" then
    files = { source = files }
  end

  if type(files) ~= "table" or not files["source"] then
    error("invalid file entry")
  end

  local bn = Caml.Filename.basename(files["source"])
  if bn == files["source"] then
    files["source"] = Caml.Filename.concat(Test.source, files["source"])
  end

  local name = Caml.Filename.chop_extension(bn)
  local exp = Caml.Filename.concat(Test.results, name)
  local inp = Caml.Filename.chop_extension(files["source"])

  if not files["name"] then files["name"] = bn end

  Test.compute_filename(files, "stdin",  Test.source,  name .. ".0")
  Test.compute_filename(files, "stdout", Test.results, name .. ".1")
  Test.compute_filename(files, "stderr", Test.results, name .. ".2")

  Test.compute_filename(files, "asm",    Test.results, name .. ".s")
  Test.compute_filename(files, "asmout", Test.results, name .. ".s1")
  Test.compute_filename(files, "asmerr", Test.results, name .. ".s2")

  Test.run_test_case(files)
end
@ 
% -------------------------------------------------------------------
\subsubsection{Compiler Table Entries}
% -------------------------------------------------------------------
When a test case name is given on the command line, we need to look it
up in the configuration file to get all of the options specified.
<<testdrv.lua>>=
function Test.find_entry(name)
  local i = 1
  while Test.files[i] do
    local f = Test.files[i]
    if type(f) == "string" and f == name then
      return f
    end
    if type(f) == "table" then
      if f["name"] and f["name"] == name then
        return f
      elseif f["source"] and f["source"] == name then
        return f
      end
    end
    i = i + 1
  end
  return nil
end
<<testdrv.lua>>=
if CMD.compilertab[".record"] then
  error("CMD.compilertab[.record] already defined")
end
function CMD.compilertab[".record"](file)
  file = Caml.Filename.chop_extension(file)
  local entry = Test.find_entry(file)
  if not entry then
    error("Could not find test case")
  end
  Test.update = 1
  Test.process_file(entry)
end
<<testdrv.lua>>=
if CMD.compilertab[".test"] then
  error("CMD.compilertab[.test] already defined")
end
function CMD.compilertab[".test"](file)
  file = Caml.Filename.chop_extension(file)
  local entry = Test.find_entry(file)
  if not entry then
    error("Could not find test case")
  end
  Test.process_file(entry)
end
<<testdrv.lua>>=
if CMD.compilertab[".tst"] then
  error("CMD.compilertab[.tst] already defined")
end
function CMD.compilertab[".tst"](file)
  dofile(file)
  if Test.skip_files or not Test.files then return end

  local len = Test.list_len(Test.files)
  local i = 1
  while Test.files[i] do
    Test.status_line(i, len);
    Test.process_file(Test.files[i])
    i = i + 1
  end
  Test.clear_status_line()
  print(format("%d errors detected.", Test.errors))
end
@ 
Overrides for standard compiler actions.
<<testdrv.lua>>=
function CMD.whatfuns["-compile"]()
  backend = backend or Backend.x86
  CMD.translate_files(Options.argv, CMD.compilertab)
end

function CMD.whatfuns["-interp"]()
  error("-interp flag not supported by testing...")
end

function CMD.whatfuns["-pp"]()
  error("-pp flag not supported by testing...")
end
@
We also override the CMD.exit function.
<<testdrv.lua>>=
function CMD.exit(code)
  print("\n  caught an exit from the compiler!")
  print("  something very bad is happening.\n")
  exit(code)
end
@ 
% -------------------------------------------------------------------
\subsubsection{Startup}
% -------------------------------------------------------------------
The test suite relies on the Util module working correctly. For extra
safety, we test the Util module before each run.
<<testdrv.lua>>=
function Test.test_redir()
  local str = "my test output"
  local tmp_out = tmpname()
  Util.redirect_stdout(tmp_out)
  print(str)
  Util.redirect_stdout()
  readfrom(tmp_out)
  local line = read()
  readfrom()
  remove(tmp_out)
  if line ~= str then
    error("Unix.redirect_* does not seem to be working properly!")
  end
end
@ 
When the driver file is loaded, we steal the [[-v]] flag from the
compiler.
<<testdrv.lua>>=
Test.test_redir()
Test.log("Running Regression Tests %s", date())
if Options.verbose > 0 then
  Test.verbose = 1
  Options.verbose = 0
end
@
... and then we do some basic checking of command line arguments. We
are depending on the fact that the command line arguments have been
fully processed before the driver is loaded.
<<testdrv.lua>>=
local i = 1
while i <= Options.argc do
  local ext = CMD.canonical_extension(Options.argv[i])
  if ext ~= ".lua" and ext ~= ".tst" then
    Test.skip_files = 1
    if ext ~= ".test" and ext ~= ".record" then
      error("invalid command line arguments")
    end
  elseif ext == ".tst" then
    Test.tst_file = Options.argv[i]
  end
  i = i + 1
end
