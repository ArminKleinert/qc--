% -*- mode: Noweb; noweb-code-mode: fundamental-mode -*-
% ------------------------------------------------------------------ 
\section{Lua Test Driver}
% ------------------------------------------------------------------ 

This is a lua driver for running the [[qc--]] regression tests. The
driver must be run with a test configuration file. For more
information on how to use this driver and the test configuration files
see the README file.

% ------------------------------------------------------------------
\section{Driver Implementation}
% ------------------------------------------------------------------
<<testdrv.lua>>=
$debug 1
Test = Test  or {}
Test.errors     = 0      -- number of failures found
Test.verbose    = nil    -- provide detailed failure info
Test.skip_files = nil    -- skip input source files
Test.on_error   = {}     -- error handlers
Test.files      = {}     -- input source files
Test.tst_file   = ""     -- name of config file
--Test.update     = nil    -- update differing files
Test.gen_args   = ""     -- additional arguments for generator
Test.qc         = getenv("QC") or Sys.cmd or "../bin/qc--"
@ 
Lua does not have a function to get the number of entries in a table/list.
<<testdrv.lua>>=
function Test.list_len(l)
  local i = 1
  while l[i] do i = i + 1 end
  return i - 1
end

function Test.list_add(l, x)
  l[Test.list_len(l)+1] = x
end
@ 
The status line is printed during a batch process. In the case of an
error, we may need to clear the status line before, anything else is
printed.
<<testdrv.lua>>=
function Test.status_line(i, len)
  local left  = format("Processing test %d of %d", i, len)
  local right = format("[ %0.2f %% ]", 100 * (i-1) / len)
  local len   = 80 - strlen(left)
  local fmt   = format('%%s%%%ds\r', len)
  if Test.verbose then
    fmt = format('%%s%%%ds\n', len)
  end
  write(format(fmt, left, right))
end
function Test.clear_status_line()
  if not Test.verbose then
    write(format("%-80s\r", ""))
  end
end
@ 
We use [[Util.call]] to log as a printf-like function.
<<testdrv.lua>>=
function Test.log(...)
  if Test.verbose then
    print(Util.call(format, arg))
  end
end
@ 
Lua tmpname places files all around the filesystem.
<<testdrv.lua>>=
function Test.temp_name(ext)
  local name = tmpname()
  remove(name) -- tmpname creates file
  return(name .. ext)
end
@ 
% -------------------------------------------------------------------
\subsubsection{Error Handlers}
% -------------------------------------------------------------------
Users can override error handlers for different types of files by
placing error handling functions in the test configuration files. The
code below dispatches errors to the most specific error handler for a
given file.
<<testdrv.lua>>=
Test.sdiff_options = ''  -- .s files used to get a 'diff -y'
function Test.on_error[".s"](expected, output)
  local cmd = format("diff %s %s %s", Test.sdiff_options, expected, output)
  Test.log(cmd)
  execute(cmd)
end
Test.on_error[".1"]  = Test.on_error[".s"]
Test.on_error[".2"]  = Test.on_error[".s"]
Test.on_error[".s1"] = Test.on_error[".s"]
Test.on_error[".s2"] = Test.on_error[".s"]
@ 
This function handles dispatching to the correct error handler.
All errors are reported by calling this function.
<<testdrv.lua>>=
function Test.error(file, expected, actual)
  Test.clear_status_line()
  Test.errors = Test.errors + 1
  local basename = Caml.Filename.basename(expected)
  local ext = Caml.Filename.extension(expected)
  if Test.verbose then
    if Test.on_error[basename] then
      Test.on_error[basename](expected, actual)
    else
      if (Test.on_error[ext]) then
        Test.on_error[ext](expected, actual)
      else
        print(format("FAILED %s\n", expected))
      end
    end
  end
end
@ 
% -------------------------------------------------------------------
\subsubsection{Compile and test functions}
% -------------------------------------------------------------------
In order to catch exceptions from Caml code, we have to write a small
function that will not return nil.
<<testdrv.lua>>=
function Test.translate(file)
  CMD.translate_files(file, CMD.compilertab)
  return 1
end
function Test.compile_file(file, i)
  local s_file = Test.temp_name(".s")
  local so = s_file .. "1"
  local se = s_file .. "2"

  Test.log("compiling %s -> %s", file, s_file)

  Driver.reinit()
  Options.stop_at(".s")
  if (i or 1) == 1 then
    Options.globals = 1
  else
    Options.globals = nil
  end
  Options.output = s_file

  Util.redirect_stdout(so)
  Util.redirect_stderr(se)
  local compiles_ok = Util.catch(Test.translate, file)
  Util.redirect_stdout()
  Util.redirect_stderr()

  if not compiles_ok then
    Test.log("Compilation errors detected")
  end

  return s_file, so, se, compiles_ok
end
@ 
This function runs both front ends, directing messages to different
files.
The basename of the files is left in [[Test.lastoutname]].
If the two front ends give inconsistent results, the one that rejected
the input is left in [[Test.compare_failed]], which is otherwise left [[nil]].
<<testdrv.lua>>=
function Test.run_both_front_ends(file) 
  if Options.verbose > 0 then write('Comparing front ends on ', file, '\n') end
  if Options.verbose < 2 then
    local ast = Driver.parse(file) 
    local fd  = open_out('/dev/null')
    local asm = backend.asm(fd)
    local outname = Test.temp_name(".s1")
    Test.lastoutname = outname
    Util.redirect_stderr(outname .. "-new")
    local passed = Util.catch(Driver.new_ok, ast, asm)
    Util.redirect_stderr(outname .. "-old")
    local env = Util.catch(Driver.check, ast, asm) -- asm is stored in env
    Util.redirect_stderr()
    if not passed == not env then
      Test.compare_failed = nil
    else
      if passed then Test.compare_failed = "Old" else Test.compare_failed = "New" end
    end
    if fd ~= Driver.stdout then close_out(fd) end -- close fd
    return nil
  end
end
@ 
This function is intended as a drop-in replacement for [[Test.run_test_case]].
It compares error messages from old and new front ends.
<<testdrv.lua>>=
function Test.compare_front_ends(inputs)
  local file = inputs.source
  Test.log("comparing front ends on %s", file)

  Driver.reinit()

  local t = Util.tcopy(CMD.compilertab)
  t['.c--'] = Test.run_both_front_ends
  CMD.translate_files(file, t)
  local outname = Test.lastoutname 
  local old, new = outname .. "-old", outname .. "-new"
  local diff = not (Util.files_nonwhite_equivalent (old, new))

  if Test.compare_failed or diff then
    if Test.compare_failed then Test.errors = Test.errors + 1 end
    if not Test.verbose then
      local why
      if Test.compare_failed then why = "front ends differ" 
      else                        why = "msgs only"
      end      
      Test.clear_status_line()
      print(format("%s -v testdrv.lua newfe.lua %s %s.test \t# %s",
                   Test.qc, Test.tst_file, inputs.name, why))
    else
      if diff then Test.on_error[".s"](old, new) end
      if Test.compare_failed then
        write('=> ', Test.compare_failed, ' rejected ', file,
              ' but the other did not\n')
      end
    end
  end
end
@ 
Call [[cc]] to build a final executable file. Calling the [[qc--]]
compiler may not work correctly if the additional files specified by
the user are handled by a frontend we do not know about.
<<testdrv.lua>>=
function Test.build_exe(inputs, s_files)
  local exe_file = Test.temp_name(".exe")

  local other = inputs.other or ""
  local cmd   = format("cc -o %s %s %s", exe_file, s_files, other)

  Test.log(cmd)
  if execute(cmd) ~= 0 then
    return nil
  end
  return exe_file
end
<<testdrv.lua>>=
function Test.run_exe(exe_file, stdin)
  local so = exe_file .. ".1"
  local se = exe_file .. ".2"

  local cmd = format("%s < %s > %s 2> %s", exe_file, stdin, so, se)
  Test.log(cmd)
  execute(cmd)

  return so, se
end
@ 
The rename library function does not work across filesystem
boundaries.
<<testdrv.lua>>=
function Test.copy_file(src, dest)
  if not readfrom(src) then return nil end
  if not writeto(dest) then readfrom(); return nil end
  local l = read()
  while l do
    if not write(l .. "\n") then
      readfrom()
      writeto()
      return nil
    end
    l = read() 
  end
  writeto()
  readfrom()
  return 1
end
@ 
The [[check_update_file]] function compares two files. If the files
differ, then either the expected file is updated, or an error message
is generated.
<<testdrv.lua>>=
function Test.check_update_file(inputs, file, i)
  local  ext = Caml.Filename.extension(file)
  if     ext == ".s"  then exp = inputs.asm[i]
  elseif ext == ".s1" then exp = inputs.asmout[i]
  elseif ext == ".s2" then exp = inputs.asmerr[i]
  elseif ext == ".1"  then exp = inputs.stdout
  elseif ext == ".2"  then exp = inputs.stderr end

  local equiv = Util.catch(Util.files_nonwhite_equivalent, exp, file)
  if not equiv then
    if Test.update then
      print(format("%s \thas changed \t\t!! updating !!", exp))
      if not Test.copy_file(file, exp) then
        print(format(" !! error moving file %s to %s !!", file,  exp))
      end
    else
      Test.log("%s does not match output", exp)
      Test.error(inputs.source, exp, file)
      inputs.diffs = inputs.diffs .. " " .. ext
    end
    return 1
  else
    if Test.update then
      print(format("%s \thas not changed", exp))
    else
      Test.log("%s matches output", exp)
    end
  end
  return 0
end
@ 
For a given test case, we first compile the sourse file down to
assembly language by calling the [[qc--]] compiler. If the assembly
output matches the expected output, then the test is passed. Otherwise
if the files is runnable, we build and run the executable and compare
the output to what is expected.

If the expected files are being updated or the [[verbose]] flag is set
then all outputs are generated.
<<testdrv.lua>>=
function Test.run_test_case(inputs)
  local sources = inputs.source
  local i = 1
  local status = 0
  local s_files = ""
  local to_remove = { }
  local all_compiles_ok = 'true'
  while sources[i] do
    local file = sources[i]
    local s_file, so, se, compiles_ok = Test.compile_file(file, i)
    all_compiles_ok = all_compiles_ok and compiles_ok
    if not s_file then return end -- not sure if this is right for multiple files

    inputs.diffs = ""

    s_files = s_files .. " " .. s_file
    status = status + Test.check_update_file(inputs, s_file, i)
                    + Test.check_update_file(inputs, so, i)
                    + Test.check_update_file(inputs, se, i)
    i = i + 1
    Test.list_add(to_remove, s_file)
    Test.list_add(to_remove, so)
    Test.list_add(to_remove, se)
  end

  if inputs.runnable and (Test.update or status > 0) then
    if all_compiles_ok then
      local exe_file = Test.build_exe(inputs, s_files)
      if exe_file then
        local pso, pse = Test.run_exe(exe_file, inputs.stdin)
        status = Test.check_update_file(inputs, pso)
               + Test.check_update_file(inputs, pse)
        remove(pso)
        remove(pse)
        remove(exe_file)
      else
        status = 1  -- failed to build exe is an error
      end
    else
      status = 1 -- runnable program does not compile?  error
    end
  end

  i = 1
  while to_remove[i] do remove(to_remove[i]); i = i + 1 end

  if inputs.diffs ~= "" then
    local msg = format("{%s } differ", inputs.diffs)
    local stat = "FAILED"
    if status == 0 then stat = "PASSED" end
    if Test.verbose then
      print(format("\n## To update these files {%s } run:", inputs.diffs))
      print(format("# %s testdrv.lua %s %s.record",
                   Test.qc, Test.tst_file, inputs.name))
    else
      print(format("%s -v testdrv.lua %s %s.test \t# %s %s",
                   Test.qc, Test.tst_file, inputs.name, stat, msg))
    end
  end
end
@ 
These two function fill in defaults for any options not specified for
a test case, before running the test case.
<<testdrv.lua>>=
function Test.compute_filename(files, entry, dir, base, ext)
  if not files[entry] then
    files[entry] = Caml.Filename.concat(dir, base .. ext)
  elseif not strfind(files[entry], "/") then
    files[entry] = Caml.Filename.concat(dir, files[entry])
  end
end

function Test.compute_filenames(files, entry, dir, sources, extension)
  local i = 1
  files[entry] = files[entry] or { }
  while sources[i] do
    local base = Caml.Filename.chop_extension(Caml.Filename.basename(sources[i]))
    Test.compute_filename(files[entry], i, dir, base, extension)
    i = i + 1
  end
end
<<testdrv.lua>>=
function Test.process_file(files)
  if type(files) == "string" then
    files = { source = files }
  end

  if type(files) ~= "table" or not files.source then
    error("invalid file entry---not a table or missing .source field")
  end

  if type(files.source) == 'string' then files.source = { files.source } end
  local i = 1
  while files.source[i] do
    local bn = Caml.Filename.basename(files.source[i])
    if bn == files.source[i] then
      files.source[i] = Caml.Filename.concat(Test.source, bn)
    end
    i = i + 1
  end

  local name = files.name or
               Caml.Filename.chop_extension(Caml.Filename.basename(files.source[1]))
  local exp  = Caml.Filename.concat(Test.results, name)

  files.name = files.name or name

  Test.compute_filename(files, "stdin",  Test.source,  name, ".0")
  Test.compute_filename(files, "stdout", Test.results, name, ".1")
  Test.compute_filename(files, "stderr", Test.results, name, ".2")

  if type(files.asm)    == 'string' then files.asm    = { files.asm } end
  if type(files.asmout) == 'string' then files.asmout = { files.asmout } end
  if type(files.asmerr) == 'string' then files.asmerr = { files.asmerr } end

  Test.compute_filenames(files, "asm",    Test.results, files.source, ".s")
  Test.compute_filenames(files, "asmout", Test.results, files.source, ".s1")
  Test.compute_filenames(files, "asmerr", Test.results, files.source, ".s2")

  files.runnable = files.runnable or "true"
  if files.runnable ~= "true" then files.runnable = nil end

  Test.gen_args = files.args or ""
  Test.run_test_case(files)
end
@ 
% -------------------------------------------------------------------
\subsubsection{Compiler Table Entries}
% -------------------------------------------------------------------
When a test case name is given on the command line, we need to look it
up in the configuration file to get all of the options specified.
<<testdrv.lua>>=
function Test.find_entry(name)
  local i = 1
  while Test.files[i] do
    local f = Test.files[i]
    if type(f) == "string" and Test.source_match(f, name) then
      return f
    elseif type(f) == "table" then
      if f.name == name or Test.source_match(f.source, name) then
        return f
      end
    end
    i = i + 1
  end
  return nil
end

function Test.source_match(src, name)
  if type(src) == 'table' then src = src[1] end
  return src == name or
         Caml.Filename.chop_extension(Caml.Filename.basename(src)) == name
end
<<testdrv.lua>>=
if CMD.compilertab[".record"] then
  error("CMD.compilertab[.record] already defined")
end
function CMD.compilertab[".record"](file)
  file = Caml.Filename.chop_extension(file)
  local entry = Test.find_entry(file)
  if not entry then
    error("Could not find test case named " .. file)
  end
  Test.update = 1
  Test.process_file(entry)
end
<<testdrv.lua>>=
if CMD.compilertab[".test"] then
  error("CMD.compilertab[.test] already defined")
end
function CMD.compilertab[".test"](file)
  file = Caml.Filename.chop_extension(file)
  local entry = Test.find_entry(file)
  if not entry then
    error("Could not find test case named " .. file)
  end
  Test.process_file(entry)
end
<<testdrv.lua>>=
if CMD.compilertab[".tst"] then
  error("CMD.compilertab[.tst] already defined")
end
function CMD.compilertab[".tst"](file)
  dofile(file)
  if Test.skip_files or not Test.files then return end

  local len = Test.list_len(Test.files)
  local i = 1
  while Test.files[i] do
    Test.status_line(i, len);
    Test.process_file(Test.files[i])
    i = i + 1
  end
  Test.clear_status_line()
  local plural = "s"
  if Test.errors == 1 then plural = "" end
  print(format("# %d error%s detected out of %d tests.", Test.errors, plural, i - 1))
end
<<testdrv.lua>>=
if CMD.compilertab[".gen"] then
  error("CMD.compilertab[.gen] already defined")
end
function CMD.compilertab[".gen"](file)
  file = Caml.Filename.chop_extension(file)
  local cmm_file = Test.temp_name(".c--")
  local cmd = "./" .. file .. " " .. Test.gen_args .. ">" .. cmm_file
  Test.log(cmd)
  execute(cmd)
  Test.translate(cmm_file)
  remove(cmm_file)
end
@ 
Overrides for standard compiler actions.
<<testdrv.lua>>=
function CMD.whatfuns["-compile"]()
  backend = backend or Backend.x86
  CMD.translate_files(Options.argv, CMD.compilertab)
end

function CMD.whatfuns["-interp"]()
  error("-interp flag not supported by testing...")
end

function CMD.whatfuns["-pp"]()
  error("-pp flag not supported by testing...")
end
@
We also override the CMD.exit function.
<<testdrv.lua>>=
function CMD.exit(code)
  write(_STDERR, "\n  caught an exit from the compiler!")
  write(_STDERR, "  something very bad is happening.\n")
  exit(code)
end
@ 
% -------------------------------------------------------------------
\subsubsection{Startup}
% -------------------------------------------------------------------
The test suite relies on the Util module working correctly. For extra
safety, we test the Util module before each run.
<<testdrv.lua>>=
function Test.test_redir()
  local str = "my test output"
  local tmp_out = tmpname()
  Util.redirect_stdout(tmp_out)
  print(str)
  Util.redirect_stdout()
  readfrom(tmp_out)
  local line = read()
  readfrom()
  remove(tmp_out)
  if line ~= str then
    error("Unix.redirect_* does not seem to be working properly!")
  end
end
@ 
When the driver file is loaded, we steal the [[-v]] flag from the
compiler.
<<testdrv.lua>>=
Test.test_redir()
Test.log("Running Regression Tests %s", date())
if Options.verbose > 0 then
  Test.verbose = 1
  Options.verbose = 0
end
@
... and then we do some basic checking of command line arguments. We
are depending on the fact that the command line arguments have been
fully processed before the driver is loaded.
<<testdrv.lua>>=
local i = 1
while i <= Options.argc do
  local ext = CMD.canonical_extension(Options.argv[i])
  if ext ~= ".lua" and ext ~= ".tst" then
    Test.skip_files = 1
    if ext ~= ".test" and ext ~= ".record" then
      error("invalid command-line arguments")
    end
  elseif ext == ".tst" then
    Test.tst_file = Options.argv[i]
  end
  i = i + 1
end
@ 
