% -*- mode: Noweb; noweb-code-mode: fundamental-mode -*-
% ------------------------------------------------------------------ 
\section{Lua Test Driver}
% ------------------------------------------------------------------ 

This is a lua driver for running the [[qc--]] regression tests. The
driver must be run with a test configuration file. For more
information on how to use this driver and the test configuration files
see the README file.

% ------------------------------------------------------------------
\section{Driver Implementation}
% ------------------------------------------------------------------
<<testdrv.lua>>=
$debug 1
Test = Test  or {}
Test.errors     = 0      -- number of failures found
Test.verbose    = nil    -- provide detailed failure info
Test.skip_files = nil    -- skip input source files
Test.on_error   = {}     -- error handlers
Test.files      = {}     -- input source files
Test.tst_file   = ""     -- name of config file
--Test.update     = nil    -- update differing files
Test.gen_args   = ""     -- additional arguments for generator
@ 
Lua does not have a function to get the number of entries in a table/list.
<<testdrv.lua>>=
function Test.list_len(l)
  local i = 1
  while l[i] do i = i + 1 end
  return i - 1
end
@ 
The status line is printed during a batch process. In the case of an
error, we may need to clear the status line before, anything else is
printed.
<<testdrv.lua>>=
function Test.status_line(i, len)
  local left  = format("Processing test %d of %d", i, len)
  local right = format("[ %0.2f %% ]", 100 * (i-1) / len)
  local len   = 80 - strlen(left)
  local fmt   = format('%%s%%%ds\r', len)
  if Test.verbose then
    fmt = format('%%s%%%ds\n', len)
  end
  write(format(fmt, left, right))
end
function Test.clear_status_line()
  if not Test.verbose then
    write(format("%-80s\r", ""))
  end
end
@ 
We use [[Util.call]] to log as a printf-like function.
<<testdrv.lua>>=
function Test.log(...)
  if Test.verbose then
    print(Util.call(format, arg))
  end
end
@ 
Lua tmpname places files all around the filesystem.
<<testdrv.lua>>=
function Test.temp_name(ext)
  local name = tmpname()
  remove(name) -- tmpname creates file
  return(name .. ext)
end
@ 
% -------------------------------------------------------------------
\subsubsection{Error Handlers}
% -------------------------------------------------------------------
Users can override error handlers for different types of files by
placing error handling functions in the test configuration files. The
code below dispatches errors to the most specific error handler for a
given file.
<<testdrv.lua>>=
Test.sdiff_options = ''  -- .s files used to get a 'diff -y'
function Test.on_error[".s"](expected, output)
  local cmd = format("diff %s %s %s", Test.sdiff_options, expected, output)
  Test.log(cmd)
  execute(cmd)
end
Test.on_error[".1"]  = Test.on_error[".s"]
Test.on_error[".2"]  = Test.on_error[".s"]
Test.on_error[".s1"] = Test.on_error[".s"]
Test.on_error[".s2"] = Test.on_error[".s"]
@ 
This function handles dispatching to the correct error handler.
All errors are reported by calling this function.
<<testdrv.lua>>=
function Test.error(file, expected, actual)
  Test.clear_status_line()
  Test.errors = Test.errors + 1
  local basename = Caml.Filename.basename(expected)
  local ext = Caml.Filename.extension(expected)
  if Test.verbose then
    if Test.on_error[basename] then
      Test.on_error[basename](expected, actual)
    else
      if (Test.on_error[ext]) then
        Test.on_error[ext](expected, actual)
      else
        print(format("FAILED %s\n", expected))
      end
    end
  end
end
@ 
% -------------------------------------------------------------------
\subsubsection{Compile and test functions}
% -------------------------------------------------------------------
In order to catch exceptions from Caml code, we have to write a small
function that will not return nil.
<<testdrv.lua>>=
function Test.translate(file)
  CMD.translate_files(file, CMD.compilertab)
  return 1
end
function Test.compile_file(file)
  local s_file = Test.temp_name(".s")
  local so = s_file .. "1"
  local se = s_file .. "2"

  Test.log("compiling %s -> %s", file, s_file)

  Driver.reinit()
  Options.stop_at(".s")
  Options.globals = 1
  Options.output = s_file

  Util.redirect_stdout(so)
  Util.redirect_stderr(se)
  local status = Util.catch(Test.translate, file)
  Util.redirect_stdout()
  Util.redirect_stderr()

  if not status then
    Test.log("Compilation errors detected")
  end

  return s_file, so, se
end
@ 
This function runs both front ends, directing messages to different
files.
The basename of the files is left in [[Test.lastoutname]].
If the two front ends give inconsistent results, the one that rejected
the input is left in [[Test.compare_failed]], which is otherwise left [[nil]].
<<testdrv.lua>>=
function Test.run_both_front_ends(file) 
  if Options.verbose > 0 then write('Comparing front ends on ', file, '\n') end
  if Options.verbose < 2 then
    local ast = Driver.parse(file) 
    local fd  = open_out('/dev/null')
    local asm = backend.asm(fd)
    local outname = Test.temp_name(".s1")
    Test.lastoutname = outname
    Util.redirect_stderr(outname .. "-new")
    local passed = Util.catch(Driver.new_ok, ast, asm)
    Util.redirect_stderr(outname .. "-old")
    local env = Util.catch(Driver.check, ast, asm) -- asm is stored in env
    Util.redirect_stderr()
    if not passed == not env then
      Test.compare_failed = nil
    else
      if passed then Test.compare_failed = "Old" else Test.compare_failed = "New" end
    end
    if fd ~= Driver.stdout then close_out(fd) end -- close fd
    return nil
  end
end
@ 
This function is intended as a drop-in replacement for [[Test.run_test_case]].
It compares error messages from old and new front ends.
<<testdrv.lua>>=
function Test.compare_front_ends(inputs)
  local file = inputs["source"]
  Test.log("comparing front ends on %s", file)

  Driver.reinit()

  local t = Util.tcopy(CMD.compilertab)
  t['.c--'] = Test.run_both_front_ends
  CMD.translate_files(file, t)
  local outname = Test.lastoutname 
  local old, new = outname .. "-old", outname .. "-new"
  local diff = not (Util.files_nonwhite_equivalent (old, new))

  if Test.compare_failed or diff then
    if Test.compare_failed then Test.errors = Test.errors + 1 end
    if not Test.verbose then
      local why
      if Test.compare_failed then why = "front ends differ" 
      else                        why = "msgs only"
      end      
      Test.clear_status_line()
      print(format("../bin/qc-- -v testdrv.lua newfe.lua %s %s.test \t# %s",
                   Test.tst_file, inputs["name"], why))
    else
      if diff then Test.on_error[".s"](old, new) end
      if Test.compare_failed then
        write('=> ', Test.compare_failed, ' rejected ', file,
              ' but the other did not\n')
      end
    end
  end
end
@ 
Call [[cc]] to build a final executable file. Calling the [[qc--]]
compiler may not work correctly if the additional files specified by
the user are handled by a frontend we do not know about.
<<testdrv.lua>>=
function Test.build_exe(inputs, s_file)
  local exe_file = Test.temp_name(".exe")

  local other = inputs.other or ""
  local cmd   = format("cc -o %s %s %s", exe_file, s_file, other)

  Test.log(cmd)
  if execute(cmd) ~= 0 then
    return nil
  end
  return exe_file
end
<<testdrv.lua>>=
function Test.run_exe(exe_file, stdin)
  local so = exe_file .. ".1"
  local se = exe_file .. ".2"

  local cmd = format("%s < %s > %s 2> %s", exe_file, stdin, so, se)
  Test.log(cmd)
  execute(cmd)

  return so, se
end
@ 
The rename library function does not work across filesystem
boundaries.
<<testdrv.lua>>=
function Test.copy_file(src, dest)
  if not readfrom(src) then return nil end
  if not writeto(dest) then readfrom(); return nil end
  local l = read()
  while l do
    if not write(l .. "\n") then
      readfrom()
      writeto()
      return nil
    end
    l = read() 
  end
  writeto()
  readfrom()
  return 1
end
@ 
The [[check_update_file]] function compares two files. If the files
differ, then either the expected file is updated, or an error message
is generated.
<<testdrv.lua>>=
function Test.check_update_file(inputs, file)
  local  ext = Caml.Filename.extension(file)
  if     ext == ".s"  then exp = inputs.asm
  elseif ext == ".s1" then exp = inputs.asmout
  elseif ext == ".s2" then exp = inputs.asmerr
  elseif ext == ".1"  then exp = inputs.stdout
  elseif ext == ".2"  then exp = inputs.stderr end

  local equiv = Util.catch(Util.files_nonwhite_equivalent, exp, file)
  if not equiv then
    if Test.update then
      print(format("%s \thas changed \t\t!! updating !!", exp))
      if not Test.copy_file(file, exp) then
        print(format(" !! error moving file %s to %s !!", file,  exp))
      end
    else
      Test.log("%s does not match output", exp)
      Test.error(inputs["source"], exp, file)
      inputs["diffs"] = inputs["diffs"] .. " " .. ext
    end
    return 1
  else
    if Test.update then
      print(format("%s \thas not changed", exp))
    else
      Test.log("%s matches output", exp)
    end
  end
  return 0
end
@ 
For a given test case, we first compile the sourse file down to
assembly language by calling the [[qc--]] compiler. If the assembly
output matches the expected output, then the test is passed. Otherwise
if the files is runnable, we build and run the executable and compare
the output to what is expected.

If the expected files are being updated or the [[verbose]] flag is set
then all outputs are generated.
<<testdrv.lua>>=
function Test.run_test_case(inputs)
  local file = inputs.source
  local s_file, so, se = Test.compile_file(file)
  if not s_file then return end

  inputs["diffs"] = ""

  local status = Test.check_update_file(inputs, s_file)
               + Test.check_update_file(inputs, so)
               + Test.check_update_file(inputs, se)

  if inputs.runnable and (Test.update or status > 0) then
    local exe_file = Test.build_exe(inputs, s_file)
    if exe_file then
      local pso, pse = Test.run_exe(exe_file, inputs["stdin"])
      status = Test.check_update_file(inputs, pso)
             + Test.check_update_file(inputs, pse)
      remove(pso)
      remove(pse)
      remove(exe_file)
    else
      status = 1  -- failed to build exe is an error
    end
  end
  remove(s_file)
  remove(so)
  remove(se)

  if inputs["diffs"] ~= "" then
    local msg = format("{%s } differ", inputs["diffs"])
    local stat = "FAILED"
    if status == 0 then stat = "PASSED" end
    if Test.verbose then
      print(format("\n## To update these files {%s } run:",
                   inputs["diffs"]))
      print(format("# ../bin/qc-- testdrv.lua %s %s.record",
                   Test.tst_file, inputs["name"]))
    else
      print(format("../bin/qc-- -v testdrv.lua %s %s.test \t# %s %s",
                   Test.tst_file, inputs["name"], stat, msg))
    end
  end
end
@ 
These two function fill in defaults for any options not specified for
a test case, before running the test case.
<<testdrv.lua>>=
function Test.compute_filename(files, entry, dir, name)
  if not files[entry] then
    files[entry] = Caml.Filename.concat(dir, name)
  else
    if not strfind(files[entry], "/") then
      files[entry] = Caml.Filename.concat(dir, files[entry])
    end
  end
end
<<testdrv.lua>>=
function Test.process_file(files)
  if type(files) == "string" then
    files = { source = files }
  end

  if type(files) ~= "table" or not files.source then
    error("invalid file entry")
  end

  local bn = files.name or Caml.Filename.basename(files.source)
  if bn == files.source then
    files.source = Caml.Filename.concat(Test.source, files.source)
  end

  local name = Caml.Filename.chop_extension(bn)
  local exp  = Caml.Filename.concat(Test.results, name)
  local inp  = Caml.Filename.chop_extension(files.source)

  files.name = files.name or bn

  Test.compute_filename(files, "stdin",  Test.source,  name .. ".0")
  Test.compute_filename(files, "stdout", Test.results, name .. ".1")
  Test.compute_filename(files, "stderr", Test.results, name .. ".2")

  Test.compute_filename(files, "asm",    Test.results, name .. ".s")
  Test.compute_filename(files, "asmout", Test.results, name .. ".s1")
  Test.compute_filename(files, "asmerr", Test.results, name .. ".s2")

  files.runnable = files.runnable or "true"
  if files.runnable ~= "true" then files.runnable = nil end

  Test.gen_args = files.args or ""
  Test.run_test_case(files)
end
@ 
% -------------------------------------------------------------------
\subsubsection{Compiler Table Entries}
% -------------------------------------------------------------------
When a test case name is given on the command line, we need to look it
up in the configuration file to get all of the options specified.
<<testdrv.lua>>=
function Test.find_entry(name)
  local i = 1
  while Test.files[i] do
    local f = Test.files[i]
    if type(f) == "string" and f == name then
      return f
    elseif type(f) == "table" then
      if f.name   == name or
         f.source == name
      then
        return f
      end
    end
    i = i + 1
  end
  return nil
end
<<testdrv.lua>>=
if CMD.compilertab[".record"] then
  error("CMD.compilertab[.record] already defined")
end
function CMD.compilertab[".record"](file)
  file = Caml.Filename.chop_extension(file)
  local entry = Test.find_entry(file)
  if not entry then
    error("Could not find test case")
  end
  Test.update = 1
  Test.process_file(entry)
end
<<testdrv.lua>>=
if CMD.compilertab[".test"] then
  error("CMD.compilertab[.test] already defined")
end
function CMD.compilertab[".test"](file)
  file = Caml.Filename.chop_extension(file)
  local entry = Test.find_entry(file)
  if not entry then
    error("Could not find test case")
  end
  Test.process_file(entry)
end
<<testdrv.lua>>=
if CMD.compilertab[".tst"] then
  error("CMD.compilertab[.tst] already defined")
end
function CMD.compilertab[".tst"](file)
  dofile(file)
  if Test.skip_files or not Test.files then return end

  local len = Test.list_len(Test.files)
  local i = 1
  while Test.files[i] do
    Test.status_line(i, len);
    Test.process_file(Test.files[i])
    i = i + 1
  end
  Test.clear_status_line()
  print(format("%d errors detected.", Test.errors))
end
<<testdrv.lua>>=
if CMD.compilertab[".gen"] then
  error("CMD.compilertab[.gen] already defined")
end
function CMD.compilertab[".gen"](file)
  file = Caml.Filename.chop_extension(file)
  local cmm_file = Test.temp_name(".c--")
  local cmd = "./" .. file .. " " .. Test.gen_args .. ">" .. cmm_file
  Test.log(cmd)
  execute(cmd)
  Test.translate(cmm_file)
  remove(cmm_file)
end
@ 
Overrides for standard compiler actions.
<<testdrv.lua>>=
function CMD.whatfuns["-compile"]()
  backend = backend or Backend.x86
  CMD.translate_files(Options.argv, CMD.compilertab)
end

function CMD.whatfuns["-interp"]()
  error("-interp flag not supported by testing...")
end

function CMD.whatfuns["-pp"]()
  error("-pp flag not supported by testing...")
end
@
We also override the CMD.exit function.
<<testdrv.lua>>=
function CMD.exit(code)
  write(_STDERR, "\n  caught an exit from the compiler!")
  write(_STDERR, "  something very bad is happening.\n")
  exit(code)
end
@ 
% -------------------------------------------------------------------
\subsubsection{Startup}
% -------------------------------------------------------------------
The test suite relies on the Util module working correctly. For extra
safety, we test the Util module before each run.
<<testdrv.lua>>=
function Test.test_redir()
  local str = "my test output"
  local tmp_out = tmpname()
  Util.redirect_stdout(tmp_out)
  print(str)
  Util.redirect_stdout()
  readfrom(tmp_out)
  local line = read()
  readfrom()
  remove(tmp_out)
  if line ~= str then
    error("Unix.redirect_* does not seem to be working properly!")
  end
end
@ 
When the driver file is loaded, we steal the [[-v]] flag from the
compiler.
<<testdrv.lua>>=
Test.test_redir()
Test.log("Running Regression Tests %s", date())
if Options.verbose > 0 then
  Test.verbose = 1
  Options.verbose = 0
end
@
... and then we do some basic checking of command line arguments. We
are depending on the fact that the command line arguments have been
fully processed before the driver is loaded.
<<testdrv.lua>>=
local i = 1
while i <= Options.argc do
  local ext = CMD.canonical_extension(Options.argv[i])
  if ext ~= ".lua" and ext ~= ".tst" then
    Test.skip_files = 1
    if ext ~= ".test" and ext ~= ".record" then
      error("invalid command-line arguments")
    end
  elseif ext == ".tst" then
    Test.tst_file = Options.argv[i]
  end
  i = i + 1
end
@ 
