% -*- mode: Noweb; noweb-code-mode: fundamental-mode -*-
% ------------------------------------------------------------------ 
\section{Lua Test Driver}
% ------------------------------------------------------------------ 

This is a lua driver for running the [[qc--]] regression tests. The
driver must be run with a test configuration file. For more
information on how to use this driver and the test configuration files
see the README file.

% ------------------------------------------------------------------
\section{Driver Implementation}
% ------------------------------------------------------------------
<<testdrv.lua>>=
$debug 1
Test = Test  or {}
Test.errors     = 0      -- number of failures found
Test.diffs      = 0      -- number of tests passed with different assembly languages
Test.verbose    = nil    -- provide detailed failure info
Test.skip_files = nil    -- skip input source files
Test.on_error   = {}     -- error handlers
Test.files      = {}     -- input source files
Test.tst_file   = nil    -- name of config file
--Test.update     = nil    -- update differing files
Test.gen_args   = ""     -- additional arguments for generator
Test.qc         = getenv("QC") or Sys.cmd or "../bin/qc--"
@ 
Lua does not have a function to get the number of entries in a table/list.
<<testdrv.lua>>=
function Test.list_len(l)
  local i = 1
  while l[i] do i = i + 1 end
  return i - 1
end

function Test.list_add(l, ...)
  local i = 1
  while arg[i] do
    l[Test.list_len(l)+1] = arg[i]
    i = i + 1
  end
end
@ 
The status line is printed during a batch process. In the case of an
error, we may need to clear the status line before, anything else is
printed.
<<testdrv.lua>>=
function Test.status_line(i, len)
  local left  = format("Processing test %d of %d", i, len)
  local right = format("[ %0.2f %% ]", 100 * (i-1) / len)
  local len   = 80 - strlen(left)
  local fmt   = format('%%s%%%ds\r', len)
  if Test.verbose then
    fmt = format('%%s%%%ds\n', len)
  end
  write(format(fmt, left, right))
end
function Test.clear_status_line()
  if not Test.verbose then
    write(format("%-80s\r", ""))
  end
end
@ 
<<testdrv.lua>>=
function Test.print_error_stats(n)
  local es, ds = "s", "s"
  if Test.errors == 1 then es = "" end
  if Test.diffs  == 1 then ds = "" end
  print(format("# %d error%s and %d diff%s detected out of %d tests.", 
               Test.errors, es, Test.diffs, ds, n))
end
@ 
We use [[Util.call]] to log as a printf-like function.
<<testdrv.lua>>=
function Test.log(...)
  if Test.verbose then
    print(Util.call(format, arg))
  end
end
@ 
Lua tmpname places files all around the filesystem.
<<testdrv.lua>>=
function Test.temp_name(ext)
  local name = tmpname()
  Test.remove(name) -- tmpname creates file
  return(name .. ext)
end
@ 
Function [[Test.remove]] removes a single file or a list.
<<testdrv.lua>>=
function Test.remove(...)
  local i = 1
  while arg[i] do
    if type(arg[i]) == 'table' then Util.call(Test.remove, arg[i])
    else remove(arg[i])
    end
    i = i + 1
  end
end
@ 
% -------------------------------------------------------------------
\subsubsection{Error Handlers}
% -------------------------------------------------------------------
Users can override error handlers for different types of files by
placing error handling functions in the test configuration files. The
code below dispatches errors to the most specific error handler for a
given file.
<<testdrv.lua>>=
Test.sdiff_options = ''  -- .s files used to get a 'diff -y'
function Test.on_error[".s"](expected, output)
  local cmd = format("diff %s %s %s", Test.sdiff_options, expected, output)
  Test.log(cmd)
  execute(cmd)
end
Test.on_error[".1"]  = Test.on_error[".s"]
Test.on_error[".2"]  = Test.on_error[".s"]
Test.on_error[".s1"] = Test.on_error[".s"]
Test.on_error[".s2"] = Test.on_error[".s"]
@ 
This function handles dispatching to the correct error handler.
All errors are reported by calling this function.
<<testdrv.lua>>=
function Test.error(file, expected, actual, ext)
  Test.clear_status_line()
  if ext == ".s" then
    Test.diffs  = Test.diffs + 1
  else
    Test.errors = Test.errors + 1
  end
  local basename = Caml.Filename.basename(expected)
  local ext = Caml.Filename.extension(expected)
  if Test.verbose then
    if Test.on_error[basename] then
      Test.on_error[basename](expected, actual)
    else
      if (Test.on_error[ext]) then
        Test.on_error[ext](expected, actual)
      else
        print(format("FAILED %s\n", expected))
      end
    end
  end
end
@ 
% -------------------------------------------------------------------
\subsubsection{Compile and test functions}
% -------------------------------------------------------------------
In order to catch exceptions from Caml code, we have to write a small
function that will not return nil.
<<testdrv.lua>>=
function Test.translate(file)
  CMD.translate_files(file, CMD.compilertab)
  return 1
end
function Test.compile_file(file, i, txlimit)
  local s_file = Test.temp_name(".s")
  local so = s_file .. "1"
  local se = s_file .. "2"

  Test.log("compiling %s -> %s%s", file, s_file,
           txlimit and format(" with transaction limit %d", txlimit) or "")

  Cfg.Tx.set_limit(txlimit or (2^30 - 1))
  Driver.reinit()
  Options.stop_at(".s")
  if (i or 1) == 1 then
    Options.globals = 1
  else
    Options.globals = nil
  end
  Options.output = s_file

  Util.redirect_stdout(so)
  Util.redirect_stderr(se)
  local compiles_ok = Util.catch(Test.translate, file)
  Util.redirect_stdout()
  Util.redirect_stderr()

  if not compiles_ok then
    Test.log("Compilation errors detected")
  end
  if Test.verbose or Debug.tx then
    Test.clear_status_line()
    print(format("Used %d optimization transactions; last was '%s'",
                 Cfg.Tx.used(), Cfg.Tx.last()))
  end

  return s_file, so, se, compiles_ok
end
@ 
This function runs both front ends, directing messages to different
files.
The basename of the files is left in [[Test.lastoutname]].
If the two front ends give inconsistent results, the one that rejected
the input is left in [[Test.compare_failed]], which is otherwise left [[nil]].
<<testdrv.lua>>=
function Test.run_both_front_ends(file) 
  if Options.verbose > 0 then write('Comparing front ends on ', file, '\n') end
  if Options.verbose < 2 then
    local ast = Driver.parse(file) 
    local fd  = open_out('/dev/null')
    local asm = backend.asm(fd)
    local outname = Test.temp_name(".s1")
    Test.lastoutname = outname
    Util.redirect_stderr(outname .. "-new")
    local passed = Util.catch(Driver.new_ok, ast, asm)
    Util.redirect_stderr(outname .. "-old")
    local env = Util.catch(Driver.check, ast, asm) -- asm is stored in env
    Util.redirect_stderr()
    if not passed == not env then
      Test.compare_failed = nil
    else
      if passed then Test.compare_failed = "Old" else Test.compare_failed = "New" end
    end
    if fd ~= Driver.stdout then close_out(fd) end -- close fd
    return nil
  end
end
@ 
This function is intended as a drop-in replacement for [[Test.run_test_case]].
It compares error messages from old and new front ends.
<<testdrv.lua>>=
function Test.compare_front_ends(inputs)
  local file = inputs.source
  Test.log("comparing front ends on %s", file)

  Driver.reinit()

  local t = Util.tcopy(CMD.compilertab)
  t['.c--'] = Test.run_both_front_ends
  CMD.translate_files(file, t)
  local outname = Test.lastoutname 
  local old, new = outname .. "-old", outname .. "-new"
  local diff = not (Util.files_nonwhite_equivalent (old, new))

  if Test.compare_failed or diff then
    if Test.compare_failed then Test.errors = Test.errors + 1 end
    if not Test.verbose then
      local why
      if Test.compare_failed then why = "front ends differ" 
      else                        why = "msgs only"
      end      
      Test.clear_status_line()
      print(format("%s -v testdrv.lua newfe.lua %s %s.test \t# %s",
                   Test.qc, Test.tst_file, inputs.name, why))
    else
      if diff then Test.on_error[".s"](old, new) end
      if Test.compare_failed then
        write('=> ', Test.compare_failed, ' rejected ', file,
              ' but the other did not\n')
      end
    end
  end
end
@ 
Call [[cc]] to build a final executable file. Calling the [[qc--]]
compiler may not work correctly if the additional files specified by
the user are handled by a frontend we do not know about.
<<testdrv.lua>>=
function Test.build_exe(inputs, s_files)
  local exe_file = Test.temp_name(".exe")

  local other = inputs.other or ""
  local snames = s_files
  if type(snames) == 'table' then
    snames = s_files[1] or ""
    local i = 2
    while s_files[i] do snames = snames .. ' ' .. s_files [i]; i = i + 1; end
  end
  local cmd   = format("cc -o %s %s %s", exe_file, snames, other)

  Test.log(cmd)
  if execute(cmd) ~= 0 then
    return nil
  end
  return exe_file
end
<<testdrv.lua>>=
function Test.run_exe(exe_file, stdin)
  local so = exe_file .. ".1"
  local se = exe_file .. ".2"

  local cmd = format("%s < %s > %s 2> %s", exe_file, stdin, so, se)
  Test.log(cmd)
  execute(cmd)

  return so, se
end
@ 
The rename library function does not work across filesystem
boundaries.
<<testdrv.lua>>=
function Test.rename(src, dest)
  local x, y = rename(src, dest)
  if not x and strfind(y, "cross-device") then
    return Test.copy_file(src, dest) and remove(src)
  else
    return x, y
  end
end

function Test.copy_file(src, dest)
  if not readfrom(src) then return nil end
  if not writeto(dest) then readfrom(); return nil end
  local l = read()
  while l do
    if not write(l .. "\n") then
      readfrom()
      writeto()
      return nil
    end
    l = read() 
  end
  writeto()
  readfrom()
  return 1
end
@ 
The [[check_update_file]] function compares two files. If the files
differ, then either the expected file is updated, or an error message
is generated.
When files differ, their extensions are added to [[inputs.diffs]].
<<testdrv.lua>>=
function Test.check_update_file(inputs, file, i)
  local  ext = Caml.Filename.extension(file)
  if     ext == ".s"  then exp = inputs.asm[i]
  elseif ext == ".s1" then exp = inputs.asmout[i]
  elseif ext == ".s2" then exp = inputs.asmerr[i]
  elseif ext == ".1"  then exp = inputs.stdout
  elseif ext == ".2"  then exp = inputs.stderr end

  local equiv = Util.files_nonwhite_equivalent(exp, file)
  if not equiv then
    if Test.update then
      print(format("%s \thas changed \t\t!! updating !!", exp))
      if not Test.copy_file(file, exp) then
        print(format(" !! error moving file %s to %s !!", file,  exp))
      end
    else
      Test.log("%s does not match output", exp)
      Test.error(inputs.source, exp, file, ext)
      inputs.diffs = inputs.diffs .. " " .. ext
    end
    return 1
  else
    if Test.update then
      print(format("%s \thas not changed", exp))
    else
      Test.log("%s matches output", exp)
    end
  end
  return 0
end
@ 
For a given test case, we first compile the sourse file down to
assembly language by calling the [[qc--]] compiler. If the assembly
output matches the expected output, then the test is passed. Otherwise
if the files is runnable, we build and run the executable and compare
the output to what is expected.

If the expected files are being updated or the [[verbose]] flag is set
then all outputs are generated.
<<testdrv.lua>>=
function Test.run_test_case(inputs)
  local sources = inputs.source
  local i = 1
  local status = 0
  local s_files = ""
  local to_remove = { }
  local all_compiles_ok = 'true'
  inputs.diffs = ""

  while sources[i] do
    local file = sources[i]
    local s_file, so, se, compiles_ok = Test.compile_file(file, i)
    all_compiles_ok = all_compiles_ok and compiles_ok
    assert(s_file)

    s_files = s_files .. " " .. s_file
    status = status + Test.check_update_file(inputs, s_file, i)
                    + Test.check_update_file(inputs, so, i)
                    + Test.check_update_file(inputs, se, i)
    i = i + 1
    Test.list_add(to_remove, s_file, so, se)
  end

  if inputs.runnable and (Test.update or Test.force or inputs.force or status > 0) then
    if all_compiles_ok then
      local exe_file = Test.build_exe(inputs, s_files)
      if exe_file then
        local pso, pse = Test.run_exe(exe_file, inputs.stdin)
        status = Test.check_update_file(inputs, pso)
               + Test.check_update_file(inputs, pse)
        Test.remove(pso, pse, exe_file)
      else
        status = 1  -- failed to build exe is an error
      end
    else
      status = 1 -- runnable program does not compile?  error
    end
  end

  Test.remove(to_remove)

  if inputs.diffs ~= "" then
    local msg = format("{%s } differ", inputs.diffs)
    local stat = "FAILED"
    if status == 0 then stat = "PASSED" end
    if Test.verbose then
      print(format("\n## To update these files {%s } run:", inputs.diffs))
      print(format("%s testdrv.lua %s %s.record",
                   Test.qc, Test.tst_file, inputs.name))
    else
      print(format("%s -v testdrv.lua %s %s.test \t# %s %s",
                   Test.qc, Test.tst_file, inputs.name, stat, msg))
    end
  end
end
@ 
\paragraph{VPOISO lives}

To isolate an error in the optimizer, we automatically find the exact
transaction that introduces the failure.
<<testdrv.lua>>=
function Test.iso_test_case(inputs)
  if not inputs.runnable then
    CMD.error('tried to isolate the bad optimization on a non-runnable test case')
  end
  local eq = Util.files_nonwhite_equivalent 
  local sources = inputs.source
  local sourcecount = Test.list_len(sources)
  local to_remove = { }
  local compok = 'true'
  local off_outputs, on_outputs, txcounts = { }, { }, { }
      -- unoptimized and optimized .s files; transaction counts
  <<compile [[sources]], set [[*_outputs]], [[txcounts]], [[to_remove]], [[compok]]>>

  if compok then
    -- embarrassing to run assembler multiple times...
    local off_exe = Test.build_exe(inputs, off_outputs)
    local on_exe  = Test.build_exe(inputs, on_outputs)

    if off_exe and on_exe then
      local pso,  pse  = Test.run_exe(on_exe,  inputs.stdin)
      local pso0, pse0 = Test.run_exe(off_exe, inputs.stdin)
      <<insist [[ps[eo]]] and [[ps[eo]0]] enable isolation, otherwise error>>
      <<set [[i]] such that optimizing exactly files $1..[[i]]$ fails>>
      local n
      <<set [[n]] such that optimizing [[n]] times succeeds, but not $[[n]]+1$>>
      <<print [[n]] and write good and bad assembly files somewhere>>
      Test.remove(pso, pse, pso0, pse0)
    else
      CMD.error('complaining bitterly -- cannot build executables for isolation')
    end
    Test.remove(on_exe, off_exe)
  else
    CMD.error('complaining bitterly -- cannot build assembly for isolation')
  end

  Test.remove(to_remove)
end
@ 
<<compile [[sources]], set [[*_outputs]], [[txcounts]], [[to_remove]], [[compok]]>>=
local i = 1
while sources[i] do
  local file = sources[i]
  local s_file,  so,  se,  compiles_ok  = Test.compile_file(file, i)     -- on
  txcounts[i] = Cfg.Tx.used()
  local s_file0, so0, se0, compiles_ok0 = Test.compile_file(file, i, 0)  -- off
  compok = compok and compiles_ok and compiles_ok0
  assert(s_file and s_file0)
  off_outputs[i] = s_file0
  on_outputs[i]  = s_file

  i = i + 1
  Test.list_add(to_remove, so, so0, se, se0)
end
@ 
With optimizations off, everything has to match.
But with optimizations on, as long as either standard error or
standard output are different, we can isolate.
<<insist [[ps[eo]]] and [[ps[eo]0]] enable isolation, otherwise error>>=
if eq(pso0, inputs.stdout) and eq(pse0, inputs.stderr) and
   (not eq(pso, inputs.stdout) or not eq(pse, inputs.stderr)) then
   -- everything is OK
else
  local o0 = eq(pso0, inputs.stdout) and "OK" or "not OK"
  local e0 = eq(pse0, inputs.stderr) and "OK" or "not OK"
  local o  = eq(pso, inputs.stdout)  and "useless" or "useful" 
  local e  = eq(pse, inputs.stderr)  and "useless" or "useful" 
  CMD.error(format("asked to isolate optimizer bug, but outputs won't work: \n" ..
      "stdout0 %s; stderr0 %s; stdout %s; stderr %s\n", o0, e0, o, e))
end
@ 
Binary search on files is unlikely to be worthwhile---linear search is
good enough.
<<set [[i]] such that optimizing exactly files $1..[[i]]$ fails>>=
local sfiles = { }
local found_it = nil
i = 1
repeat
  assert(sources[i])
  Test.iso_status_line(i, sourcecount)
  local exe = Test.build_exe(inputs, Test.pick_iso_files(i, on_outputs, off_outputs))
  assert(exe)
  local pso, pse = Test.run_exe(exe, inputs.stdin)
  if not eq(pso, inputs.stdout) or not eq(pse, inputs.stderr) then
    found_it = 'yes'
  else
    i = i + 1
  end
  Test.remove(exe, pso, pse)
until found_it   -- had better terminate with differing outputs
@ 
<<testdrv.lua>>=
function Test.pick_iso_files(i, ons, offs)
  local fs = { }
  local j = 1
  local useme = ons
  while useme[j] do
    fs[j] = useme[j]
    if j == i then useme = offs end
    j = j + 1
  end
  return fs
end
@ 
Loop invariant: [[goods]] holds output compiling with [[lo]]
transactions;
[[bads]] holds output compiling with [[hi]] transactions.
<<set [[n]] such that optimizing [[n]] times succeeds, but not $[[n]]+1$>>=
local sfiles = Test.pick_iso_files(i, on_outputs, off_outputs)
local lo, hi = 0, txcounts[i]  -- invariant: lo succeeds, hi fails
local goods, bads = off_outputs[i], on_outputs[i]
while lo < hi - 1 do
  local mid = floor((lo + hi) / 2) -- lo < mid < hi always
  assert(lo < mid and mid < hi)
  Test.iso_status_line(i, sourcecount, mid, txcounts[i])
  local s, so, se, ok = Test.compile_file(sources[i], i, mid)
  assert(ok)
  sfiles[i] = s
  local exe = Test.build_exe(inputs, sfiles)
  local pso, pse = Test.run_exe(exe, inputs.stdin)
  if not eq(pso, inputs.stdout) or not eq(pse, inputs.stderr) then
    -- mid is bad
    Test.remove(bads)
    hi, bads = mid, s
  else
    Test.remove(goods)
    lo, goods = mid, s   
  end
  Test.remove(exe, pso, pse, so, se)
end
n = lo
<<print [[n]] and write good and bad assembly files somewhere>>=
local goodname = inputs.name .. "-good.s"
local badname  = inputs.name .. "-bad.s"
Test.rename(goods, goodname)
Test.rename(bads,  badname)
Test.clear_status_line()
write('# runs ok with ', n, ' transactions; not ok with ', n+1, '\n')
write('# good output on ', goodname, '; bad output on ', badname, '\n')
write("# to see last bad (from '", Cfg.Tx.last(), "'), run\n")
write(Test.qc, ' -e "Cfg.Tx.set_limit(', n+1, ')"\n')
@ 
<<testdrv.lua>>=
function Test.iso_status_line(i, len, tx, txlimit)
  local out   = format("Optimizing %d files of %d", i, len)
                .. (tx and format(" (%d of %d transactions)", tx, txlimit) or "")
  local len   = 80 - strlen(out)
  local fmt   = format('%%s%%%ds\r', len)
  if Test.verbose then
    fmt = format('%%s%%%ds\n', len)
  end
  write(format(fmt, out, ''))
end
@ 
<<testdrv.lua>>=
if CMD.compilertab[".iso"] then
  error("CMD.compilertab[.iso] already defined")
end
function CMD.compilertab[".iso"](file)
  file = Caml.Filename.chop_extension(file)
  Test.did_something = 1
  local entry = Test.find_entry(file)
  if not entry then
    error("Could not find test case named " .. file)
  end
  Test.iso_test_case(Test.complete_test_table(entry))
end
@ 
These two function fill in defaults for any options not specified for
a test case, before running the test case.
<<testdrv.lua>>=
function Test.compute_filename(files, entry, dir, base, ext)
  if not files[entry] then
    files[entry] = Caml.Filename.concat(dir, base .. ext)
  elseif not strfind(files[entry], "/") then
    files[entry] = Caml.Filename.concat(dir, files[entry])
  end
end

function Test.compute_filenames(files, entry, dir, sources, extension)
  local i = 1
  files[entry] = files[entry] or { }
  while sources[i] do
    local base = Caml.Filename.chop_extension(Caml.Filename.basename(sources[i]))
    Test.compute_filename(files[entry], i, dir, base, extension)
    i = i + 1
  end
end
<<testdrv.lua>>=
function Test.process_file(files)
  Test.run_test_case(Test.complete_test_table(files))
end

function Test.complete_test_table(files)
  if type(files) == "string" then
    files = { source = files }
  end

  if type(files) ~= "table" or not files.source then
    error("invalid file entry---not a table or missing .source field")
  end

  if type(files.source) == 'string' then files.source = { files.source } end
  local i = 1
  while files.source[i] do
    local bn = Caml.Filename.basename(files.source[i])
    if bn == files.source[i] then
      files.source[i] = Caml.Filename.concat(Test.source, bn)
    end
    i = i + 1
  end

  local name = files.name or
               Caml.Filename.chop_extension(Caml.Filename.basename(files.source[1]))
  local exp  = Caml.Filename.concat(Test.results, name)

  files.name = files.name or name

  Test.compute_filename(files, "stdin",  Test.source,  name, ".0")
  Test.compute_filename(files, "stdout", Test.results, name, ".1")
  Test.compute_filename(files, "stderr", Test.results, name, ".2")

  if type(files.asm)    == 'string' then files.asm    = { files.asm } end
  if type(files.asmout) == 'string' then files.asmout = { files.asmout } end
  if type(files.asmerr) == 'string' then files.asmerr = { files.asmerr } end

  Test.compute_filenames(files, "asm",    Test.results, files.source, ".s")
  Test.compute_filenames(files, "asmout", Test.results, files.source, ".s1")
  Test.compute_filenames(files, "asmerr", Test.results, files.source, ".s2")

  files.runnable = files.runnable or "true"
  if files.runnable ~= "true" then files.runnable = nil end

  Test.gen_args = files.args or ""
  return files
end
@ 
% -------------------------------------------------------------------
\subsubsection{Compiler Table Entries}
% -------------------------------------------------------------------
When a test case name is given on the command line, we need to look it
up in the configuration file to get all of the options specified.
<<testdrv.lua>>=
function Test.find_entry(name)
  local i = 1
  while Test.files[i] do
    local f = Test.files[i]
    if type(f) == "string" and Test.source_match(f, name) then
      return f
    elseif type(f) == "table" then
      if f.name == name or Test.source_match(f.source, name) then
        return f
      end
    end
    i = i + 1
  end
  return nil
end

function Test.source_match(src, name)
  if type(src) == 'table' then src = src[1] end
  return src == name or
         Caml.Filename.chop_extension(Caml.Filename.basename(src)) == name
end
<<testdrv.lua>>=
if CMD.compilertab[".record"] then
  error("CMD.compilertab[.record] already defined")
end
function CMD.compilertab[".record"](file)
  Test.did_something = 1
  file = Caml.Filename.chop_extension(file)
  local entry = Test.find_entry(file)
  if not entry then
    error("Could not find test case named " .. file)
  end
  Test.update = 1
  Test.process_file(entry)
end
<<testdrv.lua>>=
if CMD.compilertab[".test"] then
  error("CMD.compilertab[.test] already defined")
end
function CMD.compilertab[".test"](file)
  Test.did_something = 1
  file = Caml.Filename.chop_extension(file)
  local entry = Test.find_entry(file)
  if not entry then
    error("Could not find test case named " .. file)
  end
  Test.process_file(entry)
end
<<testdrv.lua>>=
if CMD.compilertab[".tst"] then
  error("CMD.compilertab[.tst] already defined")
end
function CMD.compilertab[".tst"](file)
  if Test.tst_file then
    CMD.error('test driver expects exactly one .tst file; got ' .. Test.tst_file ..
              ' and ' .. file)
  else
    Test.tst_file = file
  end
  dofile(file)
  if not Test.files then
    CMD.error('file ', file, ' did not assign Test.files?!')
  end
end
<<testdrv.lua>>=
if CMD.compilertab[".gen"] then
  error("CMD.compilertab[.gen] already defined")
end
function CMD.compilertab[".gen"](file)
  file = Caml.Filename.chop_extension(file)
  local cmm_file = Test.temp_name(".c--")
  local cmd = "./" .. file .. " " .. Test.gen_args .. ">" .. cmm_file
  Test.log(cmd)
  execute(cmd)
  Test.translate(cmm_file)
  remove(cmm_file)
end
@ 
Overrides for standard compiler actions.
The default action (compile) first translates all the files named,
then if we didn't do anything interesting, it runs all the tests we
know about.
<<testdrv.lua>>=
function CMD.whatfuns["-compile"]()
  backend = backend or Backend.x86
  CMD.translate_files(Options.argv, CMD.compilertab)
  if Test.did_something or not Test.files then return end
  local len = Test.list_len(Test.files)
  local i = 1
  while Test.files[i] do
    Test.status_line(i, len);
    Test.process_file(Test.files[i])
    i = i + 1
  end
  Test.clear_status_line()
  Test.print_error_stats(i-1)
end

function CMD.whatfuns["-interp"]()
  error("-interp flag not supported by testing...")
end

function CMD.whatfuns["-pp"]()
  error("-pp flag not supported by testing...")
end
@
We also override the CMD.exit function.
<<testdrv.lua>>=
function CMD.exit(code)
  write(_STDERR, "\n  caught an exit from the compiler!")
  write(_STDERR, "  something very bad is happening.\n")
  exit(code)
end
@ 
% -------------------------------------------------------------------
\subsubsection{Startup}
% -------------------------------------------------------------------
The test suite relies on the Util module working correctly. For extra
safety, we test the Util module before each run.
<<testdrv.lua>>=
function Test.test_redir()
  local str = "my test output"
  local tmp_out = tmpname()
  Util.redirect_stdout(tmp_out)
  print(str)
  Util.redirect_stdout()
  readfrom(tmp_out)
  local line = read()
  readfrom()
  remove(tmp_out)
  if line ~= str then
    error("Unix.redirect_* does not seem to be working properly!")
  end
end
@ 
When the driver file is loaded, we steal the [[-v]] flag from the
compiler.
<<testdrv.lua>>=
Test.test_redir()
Test.log("Running Regression Tests %s", date())
if Options.verbose > 0 then
  Test.verbose = 1
  Options.verbose = 0
end
@ 
