
% ------------------------------------------------------------------ 
\section{Regression Test Suite}
% ------------------------------------------------------------------ 

Nobody likes testing so we like to automate it as much as possible. The
regression test suite contains {\PAL} source files that are compiled,
assembled, linked, and run. At certain points during the process we
compare the actual output of the compiler and the compiled program with
expected output. Unexpected output leads in general to a failing a test
case.  The expected output is part of the test suite and is organized
along target platform, in particular:

\begin{center}
    \begin{tabular}{ll}
        [[src/file.c--]]        & test case                 \\
        [[src/file.0]]          & stdin for compiled test    \\
        [[x86/linux/file.1]]    & expected stdout for test case\\
        [[x86/linux/file.2]]    & expected stderr for test case\\
        [[x86/linux/file.s]]    & expected assembler output\\
        [[x86/linux/file.s1]]   & expected compiler stdout while compiling\\
        [[x86/linux/file.s2]]   & expected compiler stderr while compiling\\
    \end{tabular}        
\end{center}

The [[src/]] directory contains a files that are shared across all
platforms, where the directory tree \textit{arch}\texttt{/}\textit{os}
contains expected output when compiling on architecture \textit{arch},
running operating system \textit{os}. All files are mandatory but may be
empty.

A test case [[file.c--]] passes the following stages. 

\begin{enumerate}
    \item [[file.c--]] is parsed and pretty printed until a fix
    point is reached. This test requires no other file from the test
    suite and checks the integrity of the parser and the pretty printer.

    \item [[file.c--]] is compiled to an assembly file.
    During the compilation the output of the compiler, like error
    messages or warnings, is compared to the platform specific files
    [[file.s1]] and [[file.s2]]. When this test is passed, the assembly
    file is compared to [[file.s]]. If no differences are found, the
    test case is considered passed. Otherwise, testing continues.

    \item The assembly file produced in the last step is assembled and
    linked to an executable. We expect this process not to produce any
    output on standard output or standard error. Finally the executable
    is run with the contents of [[file.0]] as its standard input. We
    expect it to produce the contents of [[file.1]] on standard output,
    and [[file.2]] on standard error. If no differences are found, the
    test case is considered passed.
\end{enumerate}


Running the test for a single test case is implemented as a Perl script.
The [testqc]] script receives a {\PAL} source file that it compiles and
runs and the \emph{target} to compile for.

\begin{quote}
\texttt{testqc} 
    [\texttt{-verbose}] 
    [\texttt{-nosyntax}]
    [\texttt{-qc=}\textit{path/to/qc-{}-}]
    [\texttt{-base=}\textit{path/to/test}]
    \texttt{-target=}\textit{target}
    \texttt{\dots/}\textit{file}\texttt{.c-{}-}
\end{quote}

Optional arguments include:

\begin{itemize}
\item [[-verbose]] to explain why a test failed.
\item [[-nosyntax]] suppress syntax fixpoint test.
\item [[-base]] to set the the base address of the test suite. Defaults
      to the current directory.
\item [[-qc]] to set path to the [[qc--] executable. The default is
      [[../bin/qc--]].
\end{itemize}

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

<<testqc>>=
# This file is automatically created from testqc.nw. Do no edit!

use File::Basename;
@

During the test temporary files are created in a (shared) directory. To
make their names unique, they include the process ID of the script. The
temporary directory is deduced from environment variables. \emph{To
guarantee truely unique names, we should use a library function
equivalent to mktemp(3).}

<<testqc>>=
$this       = basename($0);
$pid        = $$;
$tmpdir     = $ENV{TMP} || $ENV{TEMP} || "/tmp";
$tmp        = "$tmpdir/$this.$pid"; # template for tmp files
@

The command line options [[-verbose]] and [[-qc=]]$x$ allow to override
the default values for the following two variables. If [[$verbose]] is
true, the reason for a test failure is reported. [[$qc]] names the
binary for the Quick {\PAL} compiler. 

<<testqc>>=
$verbose        = 0;                    # option: -verbose
$qc             = "../bin/qc--";        # option: -qc="/foo/bar"
$base           = ".";                  # option: -base="/some/where"
$syntaxcheck    = 1;                    # option: -nosyntax
$target         = undef;                # option: -target=t
$file           = undef;                # foo.c-- without suffix .c-- 
$cflag          = 0;                    # option: -c
$sflag          = 0;                    # option: -S
$reason         = "success";            # why test failed
$ocamlerror     = "../bin/ocamlerror ../src ../rtl ../lua ../lua/std ../gen";
@

The test script is broken into sub routines. A sub routine never exists
the script but returns a boolean value.

The [[syntax]] routine finds parses and pretty prints a source file and
compares input and output. Ir returns true, if they are the same. To
become independent of the formatting of the source file, the pretty
printed file is parsed and printed again.

We do not clean up temporary files here. Instead, all temporary files
are removed at the end of the script.

\texttt{Install an interrupt handler that also removes temporary files.}

<<testqc>>=

sub mysys {
    my $rc;
    my $signo;
    
    if ($verbose) {
        print "# executing: @_\n";
    }    
    $rc    = system(@_);
    $signo = $rc & 127; 
    $signo && die "killed by signal $signo\n";
    return ($rc >> 8);  
}

<<testqc>>=
sub syntax {
    my $file = shift @_;    # src/file.c
    my $t1   = "$tmp.1";    # names of temporary files
    my $t2   = "$tmp.2";
    my $t3   = "$tmp.3";
    
    mysys("$qc -pp $file -o $t1 2> /dev/null > /dev/null"); 
    mysys("$qc -pp $t1   -o $t2 2> /dev/null > /dev/null"); 
    mysys("$qc -pp $t2   -o $t3 2> /dev/null > /dev/null");
    return (same ($t2,$t3));
}
@

Comparing two files for equality is a frequent task. [[same]] receives
two file names and returns true, if the two files have the same content.

<<testqc>>=
sub same {
    my ($old,$new) = @_;
    my $rc;
    
    if (!-f $old || !-f $new) { 
        $reason = "file $old or $new is missing";
        return 1;
    } 

    if ($verbose) {
        $rc = mysys ("diff -c $old $new | $ocamlerror");
    } else {
        $rc = mysys ("cmp -s $old $new");
    }    
    my $equal = ($rc eq 0 ? 1 : 0);
    $reason = $equal ? $reason : "$old and $new different";
    return $equal;
}
@

[[expect]] runs a command [[$cmd]] in a shell, with its standard input
coming from  file [[$stdin]]. The command is expected to produce output
on standard output and standard error that equals the contents of file
[[$stdout]] and [[$stderr]], respectively. It is possible to pass
[[/dev/null]] for any of the file names.  If no differences are found,
[[expect]] returns true.

<<testqc>>=
sub expect {
    my ($cmd, $stdin, $stdout, $stderr) = @_;
    my $t1 = "$tmp.4";
    my $t2 = "$tmp.5";
    my $rc;
    my $r;
   
    unless (-f $stdout && -f $stderr) { 
        $verbose && print "$stdin or $stdout missing\n";
        $reason = "file $stdin or $stdout missing\n";
        return 0;   # failed
    }
    $rc = mysys ("$cmd < $stdin 2> $t2 > $t1");
    
    # if something goes wrong, we expect the outputs not to match, so we
    # don't check $rc.
    
    if (not (same($stdout,$t1))) {
        $reason = "stdout did not match $stdout";
        return 0;
    }
    if (not (same($stderr,$t2))) {
        $reason = "stderr did not match $stderr";
        return 0;
    }    
    return 1;
}    
@

The [[run]] sub routine implements compiling and running a file. It
receives three parameters and returns true, if the test is passed. The
parameters are: 

\begin{enumerate}
    \item The directory that includes [[src]] and the platform
          specific files,
    \item the target platform
    \item the base name of the test case \emph{without} 
          the [[.s]] suffix.
\end{enumerate}

From these parameters we can construct the file names of all files we
need for the test.

<<testqc>>=
sub run {
    my ( $base      # .../test  - directory with all tests
       , $target    # x86/linux - target for back end
       , $file      # file      - test case name (without .c-- extension)
       )            = @_;    
    my $ts          = "$tmp.s";
    my $tx          = "$tmp.x";
    my $rc;
    my $cmd;

    my $tstdir      = "$base/$target";
    my $srcdir      = "$base/src";
 
    my $filec       = "$srcdir/$file.c--";      
    my $file0       = "$srcdir/$file.0";    # stdin for binary
    my $files       = "$tstdir/$file.s";    # asm file
    my $file1       = "$tstdir/$file.1";    # expected stdout for binary
    my $file2       = "$tstdir/$file.2";    # expected stderr for binary
    my $files1      = "$tstdir/$file.s1";   # expected compiler stdout
    my $files2      = "$tstdir/$file.s2";   # expected compiler stderr
        
    $cmd = "$qc backend=Backend.$target -o $ts -S $filec";
    expect ($cmd, "/dev/null", $files1, $files2) || return 0; #failed

    # check for equality of $ts file, done if equal
    same($files, $ts) && return 1; # success

    # Currently qc-- does not assemble and link so we simply fail
    # here.
    return 0; # failed
    
    # assemble and link $ts file to $tx. no compiler output expected
    $cmd = "$qc backend=$target -o $tx";
    expect ($cmd, "/dev/null", "/dev/null", "/dev/null") || return 0; #failed

    # run $tx file, compare for expected output
    expect ($tx, $file0, $file1, $file2) || return 0; #failed

    return 1; # success
}
@

Short sub routines to deal with final messages and cleanup.

<<testqc>>=
sub failed {
    print "\n $0 -verbose @ARGV #failed: $reason\n";
    cleantmp();
}

sub success {
    $verbose && print "\n# test passed: $file on $target\n";
    cleantmp();
}

$SIG{__DIE__} = sub { cleantmp() };

sub cleantmp {
    mysys ("rm -f $tmp*") && die "$!";
}
@

The following code is executed when the script is started. 

<<testqc>>=
foreach (@ARGV) {
    if      (/^-v(erbose)?$/)   { $verbose=1;       }
    elsif   (/^-qc=(.*)$/)      { $qc=$1;           }  
    elsif   (/^-base=(.*)$/)    { $base=$1;         }
    elsif   (/^-target=(.*$)/)  { $target=$1;       }
    elsif   (/^-nosyntax/)      { $syntaxcheck=0;   }
    elsif   (/^-c/)             { $cflag=1;         }
    elsif   (/^-S/)             { $sflag=1;         }
    else                        { $asm=$_           }
}

defined($asm)      or die "missing case argument: ..src/file.c--";
defined($target)   or die "missing -target=arch/os specification"; 
$cflag and $cflag and die "can't have -c and -S together";

$file = basename($asm,".c--");

if($syntaxcheck) {
    unless (syntax ("$base/src/$file.c--"))     {failed; exit 0}
}

unless (run    ($base, $target, $file))     {failed; exit 0}
success;
exit 0;
@
    
