* The check of the static semantics does not detect when a link-time
  expression uses an operator that is not available at link-time. The
  probem is only detected in the [[Ast3ir]] module. One problem is, that
  link-time expressions could be target specfic.

* The compiler reserves global memory for global registers. This must be
  only by one compilation unit and all others must import the
  corresponding symbol. We thus need a flag (-main ?) that tells whether
  the memory should be reserved or not.

* Cfg3: transaction-based interface: which operations should be
  protected by transactions?

* How are continuations created? The translation of a continuation must 
  store a continuation value on the run-time stack.

* Link-time expression in the Asm interface are incompatible to the 
  link-time expressions as they are calculated by Rtleval.


* The implementation of cutto currently lacks all details to find the
  activation for the continuation and thus the \emph{incoming} area in
  that activations. This is where the [[cut to]] statement puts the
  \emph{outgoing} overflow parameters. Some abstraction for a
  continuation's runt-time representation, similar to [[Automaton.loc]]
  might be appropriate. --CL

* Register.spill/reload needs a review. The RTLs produced may not
  respect the machine invariant. Should these functions be moved into 
  Target.t? Another way would be to pass a code-expander into these
  functions. 

* Should Target.t be an object? 
 
* We need a uniform way to handle errors after the type-checking phase.
  Should we use Error.ErrorExn for this and catch it simply in Driver?

* Error reporting for checked run-time errors is very fractured: I
  like to use assert false because if it is raised it includes a
  source code position.  Some functions use Impossible.impossible
  which raises an exception.  Tracking the cause of such a location
  requires the debugger and backward execution.  Another possibility
  would be to raise the standard exception Invalid_argument. The
  problem of tracking its cause remains the same. 


* Spilling hardware registers is not save: if [[spillee]] is a
  hardware register, it is re-loaded into a new temporary that
  substitutes the hardware register in nodes. However, the hardware
  register might the there because a calling convention demands it.
  --CL

* The register allocator needs to know which hardware registers are available
  for placement.  This might depend on the calling convention. 
  However, the register allocator works on the level of a procedure
  which might include calls using different calling conventions.


* I don't know how to find the data-flow annotations/nodes for continuations.

* Since evaluation and type-checking of expressions are separated,
  types in nested expressions are checked multiple times.  This
  introduces a quadratic complexity.  The only way to avoid this, as
  far as I can see, is a combined bottom-up evaluation and type
  checking.  --CL
    
* Does the {\rtl} used for the return depend on $(x,y)$. I believe
  so and this means the [[Target]] interface should be changed. --CL

* Expcheck provides code to check the static semantics of an
  expression and rtleval code to evaluate a constant.  However, elab
  does not use this code for constants.  I do not remeber why except
  that error messages are less precises when expcheck/rtleval are used.
  --CL

* Rtleval provides evaluation for constant RTL compile-time and
  link-time expressions.  The implementation for link-time
  expressions is missing. 

* Value.Ops is making things a bit ugly when it comes to abstract RTL 
  operators.  Rethink it in light of the more abstract RTL interface.
  Some of the ugliness comes to light in the use of the Ast2ir.Expr.op function.


* look up IEEE 754 floating-point codes and get rid of the worst unimps
  in bitops.nw

* asdlGen:

  module m {
      foo = (int)
      bar = Bar (foo)
  }
  
  When a view maps foo to char the M.bar type becomes Bar of char, but
  M.foo is still int. 
  

* Implement charset, character, and string handling as proposed by NR
  in the changes file.  The current handling of characters and
  strings must be replaced. 

* Constant evaluation: elab.nw contains a constant evaluation (against
  Fenv.Dirty) and ast2ir.nw needs a constant evaluation (against
  Fenv.Clean). The plan is, to use some IR technology for this which
  is not yet in place.
  
  We now have rtleval to evaluate expressions and expcheck to check the
  static semantics of expressions.  

* Added a 'space' property to Target. This seems to be a very general
  description and therefore I like it. But it needs approval from NR.
  Should the Target.space type go to Rtl? Done.

* Area provides overlapping of areas but we need concatenation, too. Done.

* The data-flow nodes in CFG3 do not work for return, jump, cutto
  nodes because they don't have a successor to put a the data-flow
  node before.  I still would like to add annotations directly into
  call/return/jump/ cutto nodes. Solved: we have links to the exit node.
