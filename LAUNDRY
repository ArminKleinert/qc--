* CFG creation: who is responsible to insert jumps and labels into the 
  CFG such that it can be brought into linear form? This means that
  every node with more than one predecessor must be labeled. Currently
  the AST3IR module takes care of this but it could also be deligated to
  the CFG module.

* How are RTLs translated back to C--? C-- syntax has no way to express
  different spaces as they are present in RTLs. 

    $r[2]       -> bits32[2]            no indication of space 
                                        confusing
                -> typedef $r bits32    space becomes type
                   $r[2]                width of '2' can be wrong
                -> bits32[$r+2]         space becomes base address
                                        width of '2' can be wrong    

* The implementation of cutto currently lacks all details to find the
  activation for the continuation and thus the \emph{incoming} area in
  that activations. This is where the [[cut to]] statement puts the
  \emph{outgoing} overflow parameters. Some abstraction for a
  continuation's runt-time representation, similar to [[Automaton.loc]]
  might be appropriate. --CL

* Register.spill/reload needs a review. The RTLs produced may not
  respect the machine invariant. Should these functions be moved into 
  Target.t? Another way would be to pass a code-expander into these
  functions. 

* Should Target.t be an object? 

* Error reporting for checked run-time errors is very fractured: I
  like to use assert false because if it is raised it includes a
  source code position.  Some functions use Impossible.impossible
  which raises an exception.  Tracking the cause of such a location
  requires the debugger and backward execution.  Another possibility
  would be to raise the standard exception Invalid_argument. The
  problem of tracking its cause remains the same. 

* I believe stack slots for registers (spilling, callee saved
  registers, etc) should be managed by an automaton that itself
  allocates memory from an Area. The private area of the stack
  therefore is a concatenation of (at least) two Area.t: user stack
  data and slots used by compiler and run-time system.

* Automaton.freeze and Area.freeze should adjust the size of the area 
  under construction such that is a multiple of the base alignment.
  Otherwise it is not possible to to overlay areas on such that they
  share their high ends.
  
* I would like build a dummy target but need some inspiration what a
  good dummy would look like. Appel's book might help.

* Spilling hardware registers is not save: if [[spillee]] is a
  hardware register, it is re-loaded into a new temporary that
  substitutes the hardware register in nodes. However, the hardware
  register might the there because a calling convention demands it.
  --CL

* The register allocator needs to know which hardware registers are available
  for placement.  This might depend on the calling convention. 
  However, the register allocator works on the level of a procedure
  which might include calls using different calling conventions.

* I'm not sure how Const should work. When are equations solved? --CL

* We currently have the [[Const]] module to relate compile-time
  constants.  However, it maintains a global set of equations despite
  the fact that equations are procedure-local.  I'd like to discuss
  the interface of [[Const]] first before providing an implementation
  for Area.overlap.  --CL

* think about the relationship between Rtl.link and the Const 

* The implementation of Area needs the width of an Rtl.exp.
  Implemented in Rtlutl, but was marked deprecated.

* I don't know how to find the data-flow annotations/nodes for continuations.

* Since evaluation and type-checking of expressions are separated,
  types in nested expressions are checked multiple times.  This
  introduces a quadratic complexity.  The only way to avoid this, as
  far as I can see, is a combined bottom-up evaluation and type
  checking.  --CL
    
* Does the {\rtl} used for the return depend on $(x,y)$. I believe
  so and this means the [[Target]] interface should be changed. --CL

* Expcheck provides code to check the static semantics of an
  expression and rtleval code to evaluate a constant.  However, elab
  does not use this code for constants.  I do not remeber why except
  that error messages are less precises when expcheck/rtleval are used.
  --CL

* Rtleval provides evaluation for constant RTL compile-time and
  link-time expressions.  The implementation for link-time
  expressions is missing. 

* Value.Ops is making things a bit ugly when it comes to abstract RTL 
  operators.  Rethink it in light of the more abstract RTL interface.
  Some of the ugliness comes to light in the use of the Ast2ir.Expr.op function.


* look up IEEE 754 floating-point codes and get rid of the worst unimps
  in bitops.nw

* asdlGen:

  module m {
      foo = (int)
      bar = Bar (foo)
  }
  
  When a view maps foo to char the M.bar type becomes Bar of char, but
  M.foo is still int. 
  
* Literal values are not constants: a constant has width (or a type),
  while the width/type of a literal is unknown. Currently literals are treated
  as constants which is wrong. 

* Implement charset, character, and string handling as proposed by NR
  in the changes file.  The current handling of characters and
  strings must be replaced. 

* Constant evaluation: elab.nw contains a constant evaluation (against
  Fenv.Dirty) and ast2ir.nw needs a constant evaluation (against
  Fenv.Clean). The plan is, to use some IR technology for this which
  is not yet in place.
  
  We now have rtleval to evaluate expressions and expcheck to check the
  static semantics of expressions.  

* Added a 'space' property to Target. This seems to be a very general
  description and therefore I like it. But it needs approval from NR.
  Should the Target.space type go to Rtl? Done.

* Area provides overlapping of areas but we need concatenation, too. Done.

* The data-flow nodes in CFG3 do not work for return, jump, cutto
  nodes because they don't have a successor to put a the data-flow
  node before.  I still would like to add annotations directly into
  call/return/jump/ cutto nodes. Solved: we have links to the exit node.
